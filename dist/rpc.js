var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _listener, _listeners, _cancelled, _allowInsecure, _gzip, _headers, _method, _timeout, _url, _body, _bodyType, _creds, _preflight, _process, _retry, _signal, _throttle, _getUrlFunc, _FetchRequest_instances, send_fn, _statusCode, _statusMessage, _headers2, _body2, _request, _error, _format, _val, _tens, _FixedNumber_instances, checkFormat_fn, checkValue_fn, add_fn, sub_fn, mul_fn, div_fn, _names, _data, _dataLength, _Writer_instances, writeData_fn, _data2, _offset, _bytesRead, _parent, _maxInflation, _Reader_instances, incrementBytesRead_fn, peekBytes_fn, _r, _s, _v, _networkV, _privateKey, _options, _type, _to, _data3, _nonce, _gasLimit, _gasPrice, _maxPriorityFeePerGas, _maxFeePerGas, _value, _chainId, _sig, _accessList, _maxFeePerBlobGas, _blobVersionedHashes, _kzg, _blobs, _auths, _Transaction_instances, getSerialized_fn, _types, _fullTypes, _encoderCache, _TypedDataEncoder_instances, getEncoder_fn, _offset2, _tokens, _TokenString_instances, subTokenString_fn, _ParamType_instances, walkAsync_fn, _AbiCoder_instances, getCoder_fn, _errors, _events, _functions, _abiCoder, _Interface_instances, getFunction_fn, getEvent_fn, _transactions, _logs, _startBlock, _iface, _iface2, _filter, _a, _supports2544, _resolver, _EnsResolver_instances, fetch_fn, _EnsResolver_static, getResolver_fn, _feeDataFunc, _url2, _processFunc, _name, _chainId2, _plugins, _provider, _poller, _interval, _blockNumber, _PollingBlockSubscriber_instances, poll_fn, _provider2, _poll, _running, _tag, _lastBlock, _filter2, _hash, _provider3, _filter3, _poller2, _running2, _blockNumber2, _PollingEventSubscriber_instances, poll_fn2, _subs, _plugins2, _pausedState, _destroyed, _networkPromise, _anyNetwork, _performCache, _lastBlockNumber, _nextTimer, _timers, _disableCcipRead, _options2, _AbstractProvider_instances, perform_fn, call_fn, checkNetwork_fn, getAccountValue_fn, getBlock_fn, hasSub_fn, getSub_fn, _VoidSigner_instances, throwUnsupported_fn, _provider4, _filterIdPromise, _poller3, _running3, _network, _hault, _FilterIdSubscriber_instances, poll_fn3, teardown_fn, _event, _options3, _nextId, _payloads, _drainTimer, _notReady, _network2, _pendingDetectNetwork, _JsonRpcApiProvider_instances, scheduleDrain_fn, _pollingInterval, _connect, _signingKey, _data4, _checksum, _words, _WordlistOwl_instances, loadWords_fn, _HDNodeWallet_instances, account_fn, _HDNodeWallet_static, fromSeed_fn, _Wallet_static, fromAccount_fn;
const version = "6.15.0";
function checkType(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v, index) => {
    accum[keys[index]] = v;
    return accum;
  }, {});
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}
function stringify(value, seen) {
  if (value == null) {
    return "null";
  }
  if (seen == null) {
    seen = /* @__PURE__ */ new Set();
  }
  if (typeof value === "object") {
    if (seen.has(value)) {
      return "[Circular]";
    }
    seen.add(value);
  }
  if (Array.isArray(value)) {
    return "[ " + value.map((v) => stringify(v, seen)).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON(), seen);
  }
  switch (typeof value) {
    case "boolean":
    case "number":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code) {
  return error && error.code === code;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
const _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertNormalize(form) {
  assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
function _getBytes(value, name, copy2) {
  if (value instanceof Uint8Array) {
    if (copy2) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
const HexCharacters = "0123456789abcdef";
function hexlify(data) {
  const bytes2 = getBytes(data);
  let result = "0x";
  for (let i = 0; i < bytes2.length; i++) {
    const v = bytes2[i];
    result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes2 = getBytes(data);
  if (end != null && end > bytes2.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes2,
      length: bytes2.length,
      offset: end
    });
  }
  return hexlify(bytes2.slice(start == null ? 0 : start, end == null ? bytes2.length : end));
}
function stripZerosLeft(data) {
  let bytes2 = hexlify(data).substring(2);
  while (bytes2.startsWith("00")) {
    bytes2 = bytes2.substring(2);
  }
  return "0x" + bytes2;
}
function zeroPad(data, length, left) {
  const bytes2 = getBytes(data);
  assert(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes2),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes2, length - bytes2.length);
  } else {
    result.set(bytes2, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}
const BN_0$a = BigInt(0);
const BN_1$4 = BigInt(1);
const maxValue = 9007199254740991;
function fromTwos(_value2, _width) {
  const value = getUint(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value >> width === BN_0$a, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value2
  });
  if (value >> width - BN_1$4) {
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return -((~value & mask2) + BN_1$4);
  }
  return value;
}
function toTwos(_value2, _width) {
  let value = getBigInt(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1$4 << width - BN_1$4;
  if (value < BN_0$a) {
    value = -value;
    assert(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return (~value & mask2) + BN_1$4;
  } else {
    assert(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
  }
  return value;
}
function mask(_value2, _bits) {
  const value = getUint(_value2, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1$4 << bits) - BN_1$4;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert(result >= BN_0$a, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
const Nibbles$1 = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles$1[v >> 4];
      result += Nibbles$1[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e) {
        assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value2, _width) {
  const value = getUint(_value2, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value2
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value2) {
  const value = getUint(_value2, "value");
  if (value === BN_0$a) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
let Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
}
const BN_0$9 = BigInt(0);
const BN_58 = BigInt(58);
function encodeBase58(_value2) {
  const bytes2 = getBytes(_value2);
  let value = toBigInt(bytes2);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i = 0; i < bytes2.length; i++) {
    if (bytes2[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_0$9;
  for (let i = 0; i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}
function decodeBase64(textData) {
  textData = atob(textData);
  const data = new Uint8Array(textData.length);
  for (let i = 0; i < textData.length; i++) {
    data[i] = textData.charCodeAt(i);
  }
  return getBytes(data);
}
function encodeBase64(_data5) {
  const data = getBytes(_data5);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}
class EventPayload {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter) {
    /**
     *  The event filter.
     */
    __publicField(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    __publicField(this, "emitter");
    __privateAdd(this, _listener);
    __privateSet(this, _listener, listener);
    defineProperties(this, { emitter, filter });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (__privateGet(this, _listener) == null) {
      return;
    }
    await this.emitter.off(this.filter, __privateGet(this, _listener));
  }
}
_listener = new WeakMap();
function errorFunc(reason, offset, bytes2, output2, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1; o < bytes2.length; o++) {
      if (bytes2[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset, bytes2);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes2 = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes2.length) {
    const c = bytes2[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes2, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes2, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes2.length) {
      i += onError("OVERRUN", i - 1, bytes2, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes2[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes2, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function toUtf8CodePoints(str, form) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
function createGetUrl(options) {
  async function getUrl(req, _signal2) {
    assert(_signal2 == null || !_signal2.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let error = null;
    const controller = new AbortController();
    const timer = setTimeout(() => {
      error = makeError("request timeout", "TIMEOUT");
      controller.abort();
    }, req.timeout);
    if (_signal2) {
      _signal2.addListener(() => {
        error = makeError("request cancelled", "CANCELLED");
        controller.abort();
      });
    }
    const init2 = Object.assign({}, options, {
      method: req.method,
      headers: new Headers(Array.from(req)),
      body: req.body || void 0,
      signal: controller.signal
    });
    let resp;
    try {
      resp = await fetch(req.url, init2);
    } catch (_error2) {
      clearTimeout(timer);
      if (error) {
        throw error;
      }
      throw _error2;
    }
    clearTimeout(timer);
    const headers = {};
    resp.headers.forEach((value, key) => {
      headers[key.toLowerCase()] = value;
    });
    const respBody = await resp.arrayBuffer();
    const body = respBody == null ? null : new Uint8Array(respBody);
    return {
      statusCode: resp.status,
      statusMessage: resp.statusText,
      headers,
      body
    };
  }
  return getUrl;
}
const MAX_ATTEMPTS = 12;
const SLOT_INTERVAL = 250;
let defaultGetUrlFunc = createGetUrl();
const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
const reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let locked$5 = false;
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
const Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
const fetchSignals = /* @__PURE__ */ new WeakMap();
class FetchCancelSignal {
  constructor(request) {
    __privateAdd(this, _listeners);
    __privateAdd(this, _cancelled);
    __privateSet(this, _listeners, []);
    __privateSet(this, _cancelled, false);
    fetchSignals.set(request, () => {
      if (__privateGet(this, _cancelled)) {
        return;
      }
      __privateSet(this, _cancelled, true);
      for (const listener of __privateGet(this, _listeners)) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      __privateSet(this, _listeners, []);
    });
  }
  addListener(listener) {
    assert(!__privateGet(this, _cancelled), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    __privateGet(this, _listeners).push(listener);
  }
  get cancelled() {
    return __privateGet(this, _cancelled);
  }
  checkSignal() {
    assert(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
_listeners = new WeakMap();
_cancelled = new WeakMap();
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
const _FetchRequest = class _FetchRequest {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url) {
    __privateAdd(this, _FetchRequest_instances);
    __privateAdd(this, _allowInsecure);
    __privateAdd(this, _gzip);
    __privateAdd(this, _headers);
    __privateAdd(this, _method);
    __privateAdd(this, _timeout);
    __privateAdd(this, _url);
    __privateAdd(this, _body);
    __privateAdd(this, _bodyType);
    __privateAdd(this, _creds);
    // Hooks
    __privateAdd(this, _preflight);
    __privateAdd(this, _process);
    __privateAdd(this, _retry);
    __privateAdd(this, _signal);
    __privateAdd(this, _throttle);
    __privateAdd(this, _getUrlFunc);
    __privateSet(this, _url, String(url));
    __privateSet(this, _allowInsecure, false);
    __privateSet(this, _gzip, true);
    __privateSet(this, _headers, {});
    __privateSet(this, _method, "");
    __privateSet(this, _timeout, 3e5);
    __privateSet(this, _throttle, {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    });
    __privateSet(this, _getUrlFunc, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return __privateGet(this, _url);
  }
  set url(url) {
    __privateSet(this, _url, String(url));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (__privateGet(this, _body) == null) {
      return null;
    }
    return new Uint8Array(__privateGet(this, _body));
  }
  set body(body) {
    if (body == null) {
      __privateSet(this, _body, void 0);
      __privateSet(this, _bodyType, void 0);
    } else if (typeof body === "string") {
      __privateSet(this, _body, toUtf8Bytes(body));
      __privateSet(this, _bodyType, "text/plain");
    } else if (body instanceof Uint8Array) {
      __privateSet(this, _body, body);
      __privateSet(this, _bodyType, "application/octet-stream");
    } else if (typeof body === "object") {
      __privateSet(this, _body, toUtf8Bytes(JSON.stringify(body)));
      __privateSet(this, _bodyType, "application/json");
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return __privateGet(this, _body) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (__privateGet(this, _method)) {
      return __privateGet(this, _method);
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    __privateSet(this, _method, String(method).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, __privateGet(this, _headers));
    if (__privateGet(this, _creds)) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(__privateGet(this, _creds)))}`;
    }
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && __privateGet(this, _bodyType)) {
      headers["content-type"] = __privateGet(this, _bodyType);
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key, value) {
    __privateGet(this, _headers)[String(key).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    __privateSet(this, _headers, {});
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return __privateGet(this, _creds) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    __privateSet(this, _creds, `${username}:${password}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return __privateGet(this, _gzip);
  }
  set allowGzip(value) {
    __privateSet(this, _gzip, !!value);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!__privateGet(this, _allowInsecure);
  }
  set allowInsecureAuthentication(value) {
    __privateSet(this, _allowInsecure, !!value);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return __privateGet(this, _timeout);
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    __privateSet(this, _timeout, timeout);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return __privateGet(this, _preflight) || null;
  }
  set preflightFunc(preflight) {
    __privateSet(this, _preflight, preflight);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return __privateGet(this, _process) || null;
  }
  set processFunc(process) {
    __privateSet(this, _process, process);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return __privateGet(this, _retry) || null;
  }
  set retryFunc(retry) {
    __privateSet(this, _retry, retry);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return __privateGet(this, _getUrlFunc) || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    __privateSet(this, _getUrlFunc, value);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${__privateGet(this, _body) ? hexlify(__privateGet(this, _body)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      __privateGet(this, _throttle).slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      __privateGet(this, _throttle).maxAttempts = params.maxAttempts;
    }
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert(__privateGet(this, _signal) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    __privateSet(this, _signal, new FetchCancelSignal(this));
    return __privateMethod(this, _FetchRequest_instances, send_fn).call(this, 0, getTime$1() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert(__privateGet(this, _signal) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new _FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    __privateSet(req, _headers, Object.assign({}, __privateGet(this, _headers)));
    if (__privateGet(this, _body)) {
      __privateSet(req, _body, new Uint8Array(__privateGet(this, _body)));
    }
    __privateSet(req, _bodyType, __privateGet(this, _bodyType));
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new _FetchRequest(this.url);
    __privateSet(clone, _method, __privateGet(this, _method));
    if (__privateGet(this, _body)) {
      __privateSet(clone, _body, __privateGet(this, _body));
    }
    __privateSet(clone, _bodyType, __privateGet(this, _bodyType));
    __privateSet(clone, _headers, Object.assign({}, __privateGet(this, _headers)));
    __privateSet(clone, _creds, __privateGet(this, _creds));
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    __privateSet(clone, _preflight, __privateGet(this, _preflight));
    __privateSet(clone, _process, __privateGet(this, _process));
    __privateSet(clone, _retry, __privateGet(this, _retry));
    __privateSet(clone, _throttle, Object.assign({}, __privateGet(this, _throttle)));
    __privateSet(clone, _getUrlFunc, __privateGet(this, _getUrlFunc));
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked$5 = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked$5) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl) {
    if (locked$5) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl(options);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
};
_allowInsecure = new WeakMap();
_gzip = new WeakMap();
_headers = new WeakMap();
_method = new WeakMap();
_timeout = new WeakMap();
_url = new WeakMap();
_body = new WeakMap();
_bodyType = new WeakMap();
_creds = new WeakMap();
_preflight = new WeakMap();
_process = new WeakMap();
_retry = new WeakMap();
_signal = new WeakMap();
_throttle = new WeakMap();
_getUrlFunc = new WeakMap();
_FetchRequest_instances = new WeakSet();
send_fn = async function(attempt, expires, delay, _request2, _response) {
  var _a2, _b, _c;
  if (attempt >= __privateGet(this, _throttle).maxAttempts) {
    return _response.makeServerError("exceeded maximum retry limit");
  }
  assert(getTime$1() <= expires, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: _request2
  });
  if (delay > 0) {
    await wait(delay);
  }
  let req = this.clone();
  const scheme = (req.url.split(":")[0] || "").toLowerCase();
  if (scheme in Gateways) {
    const result = await Gateways[scheme](req.url, checkSignal(__privateGet(_request2, _signal)));
    if (result instanceof FetchResponse) {
      let response2 = result;
      if (this.processFunc) {
        checkSignal(__privateGet(_request2, _signal));
        try {
          response2 = await this.processFunc(req, response2);
        } catch (error) {
          if (error.throttle == null || typeof error.stall !== "number") {
            response2.makeServerError("error in post-processing function", error).assertOk();
          }
        }
      }
      return response2;
    }
    req = result;
  }
  if (this.preflightFunc) {
    req = await this.preflightFunc(req);
  }
  const resp = await this.getUrlFunc(req, checkSignal(__privateGet(_request2, _signal)));
  let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request2);
  if (response.statusCode === 301 || response.statusCode === 302) {
    try {
      const location = response.headers.location || "";
      return __privateMethod(_a2 = req.redirect(location), _FetchRequest_instances, send_fn).call(_a2, attempt + 1, expires, 0, _request2, response);
    } catch (error) {
    }
    return response;
  } else if (response.statusCode === 429) {
    if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
      const retryAfter = response.headers["retry-after"];
      let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
        delay2 = parseInt(retryAfter);
      }
      return __privateMethod(_b = req.clone(), _FetchRequest_instances, send_fn).call(_b, attempt + 1, expires, delay2, _request2, response);
    }
  }
  if (this.processFunc) {
    checkSignal(__privateGet(_request2, _signal));
    try {
      response = await this.processFunc(req, response);
    } catch (error) {
      if (error.throttle == null || typeof error.stall !== "number") {
        response.makeServerError("error in post-processing function", error).assertOk();
      }
      let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (error.stall >= 0) {
        delay2 = error.stall;
      }
      return __privateMethod(_c = req.clone(), _FetchRequest_instances, send_fn).call(_c, attempt + 1, expires, delay2, _request2, response);
    }
  }
  return response;
};
let FetchRequest = _FetchRequest;
const _FetchResponse = class _FetchResponse {
  constructor(statusCode, statusMessage, headers, body, request) {
    __privateAdd(this, _statusCode);
    __privateAdd(this, _statusMessage);
    __privateAdd(this, _headers2);
    __privateAdd(this, _body2);
    __privateAdd(this, _request);
    __privateAdd(this, _error);
    __privateSet(this, _statusCode, statusCode);
    __privateSet(this, _statusMessage, statusMessage);
    __privateSet(this, _headers2, Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {}));
    __privateSet(this, _body2, body == null ? null : new Uint8Array(body));
    __privateSet(this, _request, request || null);
    __privateSet(this, _error, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${__privateGet(this, _body2) ? hexlify(__privateGet(this, _body2)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return __privateGet(this, _statusCode);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return __privateGet(this, _statusMessage);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, __privateGet(this, _headers2));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return __privateGet(this, _body2) == null ? null : new Uint8Array(__privateGet(this, _body2));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return __privateGet(this, _body2) == null ? "" : toUtf8String(__privateGet(this, _body2));
    } catch (error) {
      assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new _FetchResponse(599, statusMessage, this.headers, this.body, __privateGet(this, _request) || void 0);
    __privateSet(response, _error, { message, error });
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall2) {
    if (stall2 == null) {
      stall2 = -1;
    } else {
      assertArgument(Number.isInteger(stall2) && stall2 >= 0, "invalid stall timeout", "stall", stall2);
    }
    const error = new Error(message || "throttling requests");
    defineProperties(error, { stall: stall2, throttle: true });
    throw error;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return __privateGet(this, _body2) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return __privateGet(this, _request);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return __privateGet(this, _error).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = __privateGet(this, _error);
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (__privateGet(this, _body2)) {
        responseBody = toUtf8String(__privateGet(this, _body2));
      }
    } catch (e) {
    }
    assert(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
_statusCode = new WeakMap();
_statusMessage = new WeakMap();
_headers2 = new WeakMap();
_body2 = new WeakMap();
_request = new WeakMap();
_error = new WeakMap();
let FetchResponse = _FetchResponse;
function getTime$1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
const BN_N1 = BigInt(-1);
const BN_0$8 = BigInt(0);
const BN_1$3 = BigInt(1);
const BN_5 = BigInt(5);
const _guard$5 = {};
let Zeros$1 = "0000";
while (Zeros$1.length < 80) {
  Zeros$1 += Zeros$1;
}
function getTens(decimals) {
  let result = Zeros$1;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format, safeOp) {
  const width = BigInt(format.width);
  if (format.signed) {
    const limit = BN_1$3 << width - BN_1$3;
    assert(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_0$8) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    const limit = BN_1$3 << width;
    assert(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_1$3;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed2 = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") ;
    else if (value === "ufixed") {
      signed2 = false;
    } else {
      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value);
      signed2 = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    const v = value;
    const check = (key, type, defaultValue) => {
      if (v[key] == null) {
        return defaultValue;
      }
      assertArgument(typeof v[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
      return v[key];
    };
    signed2 = check("signed", "boolean", signed2);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed: signed2, width, decimals, name };
}
function toString(val, decimals) {
  let negative = "";
  if (val < BN_0$8) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros$1 + str;
  }
  const index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
const _FixedNumber = class _FixedNumber {
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(guard, value, format) {
    __privateAdd(this, _FixedNumber_instances);
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    __publicField(this, "format");
    __privateAdd(this, _format);
    // The actual value (accounting for decimals)
    __privateAdd(this, _val);
    // A base-10 value to multiple values by to maintain the magnitude
    __privateAdd(this, _tens);
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    __publicField(this, "_value");
    assertPrivate(guard, _guard$5, "FixedNumber");
    __privateSet(this, _val, value);
    __privateSet(this, _format, format);
    const _value2 = toString(value, format.decimals);
    defineProperties(this, { format: format.name, _value: _value2 });
    __privateSet(this, _tens, getTens(format.decimals));
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return __privateGet(this, _format).signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return __privateGet(this, _format).width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return __privateGet(this, _format).decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return __privateGet(this, _val);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(other) {
    return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other, "add");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(other) {
    return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other, "sub");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(other) {
    return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(other) {
    __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
    const value = __privateGet(this, _val) * __privateGet(other, _val);
    assert(value % __privateGet(this, _tens) === BN_0$8, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(this, _tens), "mulSignal");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(other) {
    return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(other) {
    assert(__privateGet(other, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
    const value = __privateGet(this, _val) * __privateGet(this, _tens);
    assert(value % __privateGet(other, _val) === BN_0$8, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(other, _val), "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(other) {
    let a = this.value, b2 = other.value;
    const delta = this.decimals - other.decimals;
    if (delta > 0) {
      b2 *= getTens(delta);
    } else if (delta < 0) {
      a *= getTens(-delta);
    }
    if (a < b2) {
      return -1;
    }
    if (a > b2) {
      return 1;
    }
    return 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(other) {
    return this.cmp(other) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(other) {
    return this.cmp(other) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(other) {
    return this.cmp(other) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(other) {
    return this.cmp(other) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(other) {
    return this.cmp(other) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let val = __privateGet(this, _val);
    if (__privateGet(this, _val) < BN_0$8) {
      val -= __privateGet(this, _tens) - BN_1$3;
    }
    val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let val = __privateGet(this, _val);
    if (__privateGet(this, _val) > BN_0$8) {
      val += __privateGet(this, _tens) - BN_1$3;
    }
    val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta = this.decimals - decimals;
    const bump = BN_5 * getTens(delta - 1);
    let value = this.value + bump;
    const tens = getTens(delta);
    value = value / tens * tens;
    checkValue(value, __privateGet(this, _format), "round");
    return new _FixedNumber(_guard$5, value, __privateGet(this, _format));
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return __privateGet(this, _val) === BN_0$8;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return __privateGet(this, _val) < BN_0$8;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(format) {
    return _FixedNumber.fromString(this.toString(), format);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(_value2, _decimals, _format2) {
    const decimals = _decimals == null ? 0 : getNumber(_decimals);
    const format = getFormat(_format2);
    let value = getBigInt(_value2, "value");
    const delta = decimals - format.decimals;
    if (delta > 0) {
      const tens = getTens(delta);
      assert(value % tens === BN_0$8, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value2
      });
      value /= tens;
    } else if (delta < 0) {
      value *= getTens(-delta);
    }
    checkValue(value, format, "fromValue");
    return new _FixedNumber(_guard$5, value, format);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(_value2, _format2) {
    const match = _value2.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value2);
    const format = getFormat(_format2);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format.decimals) {
      decimal += Zeros$1;
    }
    assert(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value2
    });
    decimal = decimal.substring(0, format.decimals);
    const value = BigInt(match[1] + whole + decimal);
    checkValue(value, format, "fromString");
    return new _FixedNumber(_guard$5, value, format);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(_value2, _format2) {
    let value = toBigInt(getBytes(_value2, "value"));
    const format = getFormat(_format2);
    if (format.signed) {
      value = fromTwos(value, format.width);
    }
    checkValue(value, format, "fromBytes");
    return new _FixedNumber(_guard$5, value, format);
  }
};
_format = new WeakMap();
_val = new WeakMap();
_tens = new WeakMap();
_FixedNumber_instances = new WeakSet();
checkFormat_fn = function(other) {
  assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
};
checkValue_fn = function(val, safeOp) {
  val = checkValue(val, __privateGet(this, _format), safeOp);
  return new _FixedNumber(_guard$5, val, __privateGet(this, _format));
};
add_fn = function(o, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) + __privateGet(o, _val), safeOp);
};
sub_fn = function(o, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) - __privateGet(o, _val), safeOp);
};
mul_fn = function(o, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(o, _val) / __privateGet(this, _tens), safeOp);
};
div_fn = function(o, safeOp) {
  assert(__privateGet(o, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
    operation: "div",
    fault: "divide-by-zero",
    value: this
  });
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(this, _tens) / __privateGet(o, _val), safeOp);
};
let FixedNumber = _FixedNumber;
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  assert(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset2
    });
  };
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data[offset]) };
}
function decodeRlp(_data5) {
  const data = getBytes(_data5, "data");
  const decoded = _decode(data, 0);
  assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data5);
  return decoded.result;
}
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data = Array.prototype.slice.call(getBytes(object2, "object"));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
const nibbles = "0123456789abcdef";
function encodeRlp(object2) {
  let result = "0x";
  for (const v of _encode(object2)) {
    result += nibbles[v >> 4];
    result += nibbles[v & 15];
  }
  return result;
}
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits(value, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
function parseUnits$1(value, unit) {
  assertArgument(typeof value === "string", "value must be a string", "value", value);
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits$1(ether, 18);
}
function uuidV4(randomBytes2) {
  const bytes2 = getBytes(randomBytes2, "randomBytes");
  bytes2[6] = bytes2[6] & 15 | 64;
  bytes2[8] = bytes2[8] & 63 | 128;
  const value = hexlify(bytes2);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
const WordSize = 32;
const Padding = new Uint8Array(WordSize);
const passProperties$1 = ["then"];
const _guard$4 = {};
const resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names2) {
  resultNames.set(result, names2);
}
function throwError(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
function toObject(names2, items, deep) {
  if (names2.indexOf(null) >= 0) {
    return items.map((item, index) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names2.reduce((accum, name, index) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
const _Result = class _Result extends Array {
  /**
   *  @private
   */
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names2 = (args[2] || []).slice();
    let wrap = true;
    if (guard !== _guard$4) {
      items = args;
      names2 = [];
      wrap = false;
    }
    super(items.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    __privateAdd(this, _names);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names2.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item, index) => {
      const name = names2[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    __privateSet(this, _names, []);
    if (__privateGet(this, _names) == null) {
      void __privateGet(this, _names);
    }
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index = getNumber(prop, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties$1.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError(`index ${index}`, item);
      }
      if (deep && item instanceof _Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names2 = getNames(this);
    return names2.reduce((accum, name, index) => {
      assert(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names2, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names2 = getNames(this);
    const result = [], names2 = [];
    for (let i = start; i < end; i++) {
      result.push(this[i]);
      names2.push(_names2[i]);
    }
    return new _Result(_guard$4, result, names2);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names2 = getNames(this);
    const result = [], names2 = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names2.push(_names2[i]);
      }
    }
    return new _Result(_guard$4, result, names2);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index = getNames(this).indexOf(name);
    if (index === -1) {
      return void 0;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new _Result(_guard$4, items, keys);
  }
};
_names = new WeakMap();
let Result = _Result;
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object2) {
    if (!Array.isArray(object2)) {
      return;
    }
    for (let key in object2) {
      const childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object2[key]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
function getValue$1(value) {
  let bytes2 = toBeArray(value);
  assert(bytes2.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize, offset: bytes2.length });
  if (bytes2.length !== WordSize) {
    bytes2 = getBytesCopy(concat([Padding.slice(bytes2.length % WordSize), bytes2]));
  }
  return bytes2;
}
class Coder {
  constructor(name, type, localName, dynamic) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    __publicField(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    __publicField(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    __publicField(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    __publicField(this, "dynamic");
    defineProperties(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
}
class Writer {
  constructor() {
    __privateAdd(this, _Writer_instances);
    // An array of WordSize lengthed objects to concatenation
    __privateAdd(this, _data);
    __privateAdd(this, _dataLength);
    __privateSet(this, _data, []);
    __privateSet(this, _dataLength, 0);
  }
  get data() {
    return concat(__privateGet(this, _data));
  }
  get length() {
    return __privateGet(this, _dataLength);
  }
  appendWriter(writer) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes2 = getBytesCopy(value);
    const paddingOffset = bytes2.length % WordSize;
    if (paddingOffset) {
      bytes2 = getBytesCopy(concat([bytes2, Padding.slice(paddingOffset)]));
    }
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, bytes2);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getValue$1(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = __privateGet(this, _data).length;
    __privateGet(this, _data).push(Padding);
    __privateSet(this, _dataLength, __privateGet(this, _dataLength) + WordSize);
    return (value) => {
      __privateGet(this, _data)[offset] = getValue$1(value);
    };
  }
}
_data = new WeakMap();
_dataLength = new WeakMap();
_Writer_instances = new WeakSet();
writeData_fn = function(data) {
  __privateGet(this, _data).push(data);
  __privateSet(this, _dataLength, __privateGet(this, _dataLength) + data.length);
  return data.length;
};
const _Reader = class _Reader {
  constructor(data, allowLoose, maxInflation) {
    __privateAdd(this, _Reader_instances);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    __publicField(this, "allowLoose");
    __privateAdd(this, _data2);
    __privateAdd(this, _offset);
    __privateAdd(this, _bytesRead);
    __privateAdd(this, _parent);
    __privateAdd(this, _maxInflation);
    defineProperties(this, { allowLoose: !!allowLoose });
    __privateSet(this, _data2, getBytesCopy(data));
    __privateSet(this, _bytesRead, 0);
    __privateSet(this, _parent, null);
    __privateSet(this, _maxInflation, maxInflation != null ? maxInflation : 1024);
    __privateSet(this, _offset, 0);
  }
  get data() {
    return hexlify(__privateGet(this, _data2));
  }
  get dataLength() {
    return __privateGet(this, _data2).length;
  }
  get consumed() {
    return __privateGet(this, _offset);
  }
  get bytes() {
    return new Uint8Array(__privateGet(this, _data2));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new _Reader(__privateGet(this, _data2).slice(__privateGet(this, _offset) + offset), this.allowLoose, __privateGet(this, _maxInflation));
    __privateSet(reader, _parent, this);
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes2 = __privateMethod(this, _Reader_instances, peekBytes_fn).call(this, 0, length, !!loose);
    __privateMethod(this, _Reader_instances, incrementBytesRead_fn).call(this, length);
    __privateSet(this, _offset, __privateGet(this, _offset) + bytes2.length);
    return bytes2.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
};
_data2 = new WeakMap();
_offset = new WeakMap();
_bytesRead = new WeakMap();
_parent = new WeakMap();
_maxInflation = new WeakMap();
_Reader_instances = new WeakSet();
incrementBytesRead_fn = function(count) {
  var _a2;
  if (__privateGet(this, _parent)) {
    return __privateMethod(_a2 = __privateGet(this, _parent), _Reader_instances, incrementBytesRead_fn).call(_a2, count);
  }
  __privateSet(this, _bytesRead, __privateGet(this, _bytesRead) + count);
  assert(__privateGet(this, _maxInflation) < 1 || __privateGet(this, _bytesRead) <= __privateGet(this, _maxInflation) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${__privateGet(this, _maxInflation)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: getBytesCopy(__privateGet(this, _data2)),
    offset: __privateGet(this, _offset),
    length: count,
    info: {
      bytesRead: __privateGet(this, _bytesRead),
      dataLength: this.dataLength
    }
  });
};
peekBytes_fn = function(offset, length, loose) {
  let alignedLength = Math.ceil(length / WordSize) * WordSize;
  if (__privateGet(this, _offset) + alignedLength > __privateGet(this, _data2).length) {
    if (this.allowLoose && loose && __privateGet(this, _offset) + length <= __privateGet(this, _data2).length) {
      alignedLength = length;
    } else {
      assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: getBytesCopy(__privateGet(this, _data2)),
        length: __privateGet(this, _data2).length,
        offset: __privateGet(this, _offset) + alignedLength
      });
    }
  }
  return __privateGet(this, _data2).slice(__privateGet(this, _offset), __privateGet(this, _offset) + alignedLength);
};
let Reader = _Reader;
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const crypto$2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$1 = (a) => a instanceof Uint8Array;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift) => word << 32 - shift | word >>> shift;
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
const nextTick = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes$1(data);
  if (!u8a$1(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes$1(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a$1(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
const toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes$2(bytesLength = 32) {
  if (crypto$2 && typeof crypto$2.getRandomValues === "function") {
    return crypto$2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
class HMAC extends Hash {
  constructor(hash$1, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash$1);
    const key = toBytes(_key);
    this.iHash = hash$1.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash$1.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash$1.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);
function pbkdf2Init(hash$1, _password, _salt, _opts) {
  hash(hash$1);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number(c);
  number(dkLen);
  number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash$1, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf2$1(hash2, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
class SHA2 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}
const Chi = (a, b2, c) => a & b2 ^ ~a & c;
const Maj = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T12 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T22 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T12 | 0;
      D = C;
      C = B;
      B = A;
      A = T12 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
const sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split$1(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
const toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
const shrSH = (h, _l, s) => h >>> s;
const shrSL = (h, l, s) => h << 32 - s | l >>> s;
const rotrSH = (h, l, s) => h >>> s | l << 32 - s;
const rotrSL = (h, l, s) => h << 32 - s | l >>> s;
const rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
const rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
const rotr32H = (_h, l) => l;
const rotr32L = (h, _l) => h;
const rotlSH = (h, l, s) => h << s | l >>> 32 - s;
const rotlSL = (h, l, s) => l << s | h >>> 32 - s;
const rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
const u64 = {
  fromBig,
  split: split$1,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64.add3L(T1l, sigma0l, MAJl);
      Ah = u64.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512$1 = /* @__PURE__ */ wrapConstructor(() => new SHA512());
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
const crypto$1 = anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256$1.create();
    case "sha512":
      return sha512$1.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key) {
  const algo = { sha256: sha256$1, sha512: sha512$1 }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac.create(algo, key);
}
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  const algo = { sha256: sha256$1, sha512: sha512$1 }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf2$1(algo, password, salt, { c: iterations, dkLen: keylen });
}
function randomBytes$1(length) {
  assert(crypto$1 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  const result = new Uint8Array(length);
  crypto$1.getRandomValues(result);
  return result;
}
let locked$4 = false;
const _computeHmac = function(algorithm, key, data) {
  return createHmac(algorithm, key).update(data).digest();
};
let __computeHmac = _computeHmac;
function computeHmac(algorithm, _key, _data5) {
  const key = getBytes(_key, "key");
  const data = getBytes(_data5, "data");
  return hexlify(__computeHmac(algorithm, key, data));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked$4 = true;
};
computeHmac.register = function(func) {
  if (locked$4) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n$4 = /* @__PURE__ */ BigInt(0);
const _1n$5 = /* @__PURE__ */ BigInt(1);
const _2n$3 = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R = _1n$5, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n$4;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n$5 ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n$3)
      t ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(j)) - _1n$5;
  }
  _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split$1(_SHA3_IOTA, true);
const rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
let locked$3 = false;
const _keccak256 = function(data) {
  return keccak_256(data);
};
let __keccak256 = _keccak256;
function keccak256(_data5) {
  const data = getBytes(_data5, "data");
  return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked$3 = true;
};
keccak256.register = function(func) {
  if (locked$3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
const Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
const rotl$1 = (word, shift) => word << shift | word >>> 32 - shift;
function f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  else if (group === 1)
    return x & y | ~x & z;
  else if (group === 2)
    return (x | ~y) ^ z;
  else if (group === 3)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
}
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl$1(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl$1(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl$1(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl$1(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
}
const ripemd160$1 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());
let locked$2 = false;
const _ripemd160 = function(data) {
  return ripemd160$1(data);
};
let __ripemd160 = _ripemd160;
function ripemd160(_data5) {
  const data = getBytes(_data5, "data");
  return hexlify(__ripemd160(data));
}
ripemd160._ = _ripemd160;
ripemd160.lock = function() {
  locked$2 = true;
};
ripemd160.register = function(func) {
  if (locked$2) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd160);
let locked$1 = false;
const _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
let __pbkdf2 = _pbkdf2;
function pbkdf2(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf2._ = _pbkdf2;
pbkdf2.lock = function() {
  locked$1 = true;
};
pbkdf2.register = function(func) {
  if (locked$1) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf2);
let locked = false;
const _randomBytes = function(length) {
  return new Uint8Array(randomBytes$1(length));
};
let __randomBytes = _randomBytes;
function randomBytes(length) {
  return __randomBytes(length);
}
randomBytes._ = _randomBytes;
randomBytes.lock = function() {
  locked = true;
};
randomBytes.register = function(func) {
  if (locked) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes);
const rotl = (a, b2) => a << b2 | a >>> 32 - b2;
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0; i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N2, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  number(N2);
  number(r);
  number(p);
  number(dkLen);
  number(asyncTick);
  number(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N2 <= 1 || (N2 & N2 - 1) !== 0 || N2 >= 2 ** (blockSize / 8) || N2 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N2 + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf2$1(sha256$1, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N2));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N2 * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N2, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf2$1(sha256$1, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt$1(password, salt, opts) {
  const { N: N2, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0; i < N2 - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N2 - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    for (let i = 0; i < N2; i++) {
      const j = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N: N2, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    let pos = 0;
    await asyncLoop(N2 - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix(V, (N2 - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    await asyncLoop(N2, asyncTick, () => {
      const j = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
let lockedSync = false, lockedAsync = false;
const _scryptAsync = async function(passwd, salt, N2, r, p, dkLen, onProgress) {
  return await scryptAsync(passwd, salt, { N: N2, r, p, dkLen, onProgress });
};
const _scryptSync = function(passwd, salt, N2, r, p, dkLen) {
  return scrypt$1(passwd, salt, { N: N2, r, p, dkLen });
};
let __scryptAsync = _scryptAsync;
let __scryptSync = _scryptSync;
async function scrypt(_passwd, _salt, N2, r, p, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N2, r, p, dkLen, progress));
}
scrypt._ = _scryptAsync;
scrypt.lock = function() {
  lockedAsync = true;
};
scrypt.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt);
function scryptSync(_passwd, _salt, N2, r, p, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N2, r, p, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function() {
  lockedSync = true;
};
scryptSync.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);
const _sha256 = function(data) {
  return createHash("sha256").update(data).digest();
};
const _sha512 = function(data) {
  return createHash("sha512").update(data).digest();
};
let __sha256 = _sha256;
let __sha512 = _sha512;
let locked256 = false, locked512 = false;
function sha256(_data5) {
  const data = getBytes(_data5, "data");
  return hexlify(__sha256(data));
}
sha256._ = _sha256;
sha256.lock = function() {
  locked256 = true;
};
sha256.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha256);
function sha512(_data5) {
  const data = getBytes(_data5, "data");
  return hexlify(__sha512(data));
}
sha512._ = _sha512;
sha512.lock = function() {
  locked512 = true;
};
sha512.register = function(func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha256);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0);
const _1n$4 = BigInt(1);
const _2n$2 = BigInt(2);
const u8a = (a) => a instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n$3; n2 >>= _1n$4, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n$4;
}
const bitSet = (n2, pos, value) => {
  return n2 | (value ? _1n$4 : _0n$3) << BigInt(pos);
};
const bitMask = (n2) => (_2n$2 << BigInt(n2 - 1)) - _1n$4;
const u8n = (data) => new Uint8Array(data);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b2) => hmacFn(k, v, ...b2);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3);
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a, b2) {
  const result = a % b2;
  return result >= _0n$2 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$2 || power < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$3)
    return _0n$2;
  let res = _1n$3;
  while (power > _0n$2) {
    if (power & _1n$3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n$2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$2 || modulo <= _0n$2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b2 = modulo;
  let x = _0n$2, u = _1n$3;
  while (a !== _0n$2) {
    const q = b2 / a;
    const r = b2 % a;
    const m = x - u * q;
    b2 = a, a = r, x = u, u = m;
  }
  const gcd = b2;
  if (gcd !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n$3) / _2n$1;
  let Q, S2, Z;
  for (Q = P - _1n$3, S2 = 0; Q % _2n$1 === _0n$2; Q /= _2n$1, S2++)
    ;
  for (Z = _2n$1; Z < P && pow(Z, legendreC, P) !== P - _1n$3; Z++)
    ;
  if (S2 === 1) {
    const p1div4 = (P + _1n$3) / _4n;
    return function tonelliFast(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n$3) / _2n$1;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S2;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b2); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge = Fp2.pow(g, _1n$3 << BigInt(r - m - 1));
      g = Fp2.sqr(ge);
      x = Fp2.mul(x, ge);
      b2 = Fp2.mul(b2, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n$1) {
    const p1div4 = (P + _1n$3) / _4n;
    return function sqrt3mod4(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n$1);
      const v = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n$1), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  return tonelliShanks(P);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n$2)
    throw new Error("Expected power > 0");
  if (power === _0n$2)
    return f2.ONE;
  if (power === _1n$3)
    return num;
  let p = f2.ONE;
  let d = num;
  while (power > _0n$2) {
    if (power & _1n$3)
      p = f2.mul(p, d);
    d = f2.sqr(d);
    power >>= _1n$3;
  }
  return p;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$2,
    isOdd: (num) => (num & _1n$3) === _1n$3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b2, c) => c ? b2 : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0);
const _1n$2 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p = c.ZERO;
      let d = elm;
      while (n2 > _0n$1) {
        if (n2 & _1n$2)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n$2;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n2) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f2 = c.BASE;
      const mask2 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$2;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFCached(P, precomputesMap, n2, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
const _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b: b2 } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I = Point.ZERO;
      if (n2 === _0n)
        return I;
      assertGE(n2);
      if (n2 === _1n$1)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n$1)
          k1p = k1p.add(d);
        if (k2 & _1n$1)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n$1;
        k2 >>= _1n$1;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(n2);
        point = p;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b2) {
      const G = Point.BASE;
      const mul = (P, a2) => a2 === _0n || a2 === _1n$1 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$1)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$1)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n < num && num < Fp2.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n$1) === _1n$1;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$1;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE(b2.slice(from, to));
  class Signature2 {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature2(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$1);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a2;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig2 = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig2 = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig2 = Signature2.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig2 = new Signature2(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig2.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig2;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h * is);
    const u2 = modN(r * is);
    const R = (_a2 = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a2.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature: Signature2,
    utils
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes$1(...msgs)),
    randomBytes: randomBytes$2
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b2) => (a + b2 / _2n) / b2;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n2, P) * b3 % P;
  const b9 = pow2(b6, _3n2, P) * b3 % P;
  const b11 = pow2(b9, _2n, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n2, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n2);
      const c2 = divNearest(-b1 * k, n2);
      let k1 = mod(k - c1 * a1 - c2 * a2, n2);
      let k2 = mod(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k2 = n2 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256$1);
BigInt(0);
secp256k1.ProjectivePoint;
const ZeroAddress = "0x0000000000000000000000000000000000000000";
const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
const EtherSymbol = "";
const MessagePrefix = "Ethereum Signed Message:\n";
const BN_0$7 = BigInt(0);
const BN_1$2 = BigInt(1);
const BN_2$2 = BigInt(2);
const BN_27$1 = BigInt(27);
const BN_28$1 = BigInt(28);
const BN_35$1 = BigInt(35);
const _guard$3 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
const _Signature = class _Signature {
  /**
   *  @private
   */
  constructor(guard, r, s, v) {
    __privateAdd(this, _r);
    __privateAdd(this, _s);
    __privateAdd(this, _v);
    __privateAdd(this, _networkV);
    assertPrivate(guard, _guard$3, "Signature");
    __privateSet(this, _r, r);
    __privateSet(this, _s, s);
    __privateSet(this, _v, v);
    __privateSet(this, _networkV, null);
  }
  /**
   *  The ``r`` value for a signature.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return __privateGet(this, _r);
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    __privateSet(this, _r, hexlify(value));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    assertArgument(parseInt(__privateGet(this, _s).substring(0, 3)) < 8, "non-canonical s; use ._s", "s", __privateGet(this, _s));
    return __privateGet(this, _s);
  }
  set s(_value2) {
    assertArgument(dataLength(_value2) === 32, "invalid s", "value", _value2);
    __privateSet(this, _s, hexlify(_value2));
  }
  /**
   *  Return the s value, unchecked for EIP-2 compliance.
   *
   *  This should generally not be used and is for situations where
   *  a non-canonical S value might be relevant, such as Frontier blocks
   *  that were mined prior to EIP-2 or invalid Authorization List
   *  signatures.
   */
  get _s() {
    return __privateGet(this, _s);
  }
  /**
   *  Returns true if the Signature is valid for [[link-eip-2]] signatures.
   */
  isValid() {
    return parseInt(__privateGet(this, _s).substring(0, 3)) < 8;
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return __privateGet(this, _v);
  }
  set v(value) {
    const v = getNumber(value, "value");
    assertArgument(v === 27 || v === 28, "invalid v", "v", value);
    __privateSet(this, _v, v);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return __privateGet(this, _networkV);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v = this.networkV;
    if (v == null) {
      return null;
    }
    return _Signature.getChainId(v);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new _Signature(_guard$3, this.r, this._s, this.v);
    if (this.networkV) {
      __privateSet(clone, _networkV, this.networkV);
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this._s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v) {
    const bv = getBigInt(v, "v");
    if (bv == BN_27$1 || bv == BN_28$1) {
      return BN_0$7;
    }
    assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v);
    return (bv - BN_35$1) / BN_2$2;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v) {
    return getBigInt(chainId) * BN_2$2 + BigInt(35 + v - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v) {
    const bv = getBigInt(v);
    if (bv === BN_0$7 || bv === BN_27$1) {
      return 27;
    }
    if (bv === BN_1$2 || bv === BN_28$1) {
      return 28;
    }
    assertArgument(bv >= BN_35$1, "invalid v", "v", v);
    return bv & BN_1$2 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    if (sig == null) {
      return new _Signature(_guard$3, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes2 = getBytes(sig, "signature");
      if (bytes2.length === 64) {
        const r2 = hexlify(bytes2.slice(0, 32));
        const s2 = bytes2.slice(32, 64);
        const v2 = s2[0] & 128 ? 28 : 27;
        s2[0] &= 127;
        return new _Signature(_guard$3, r2, hexlify(s2), v2);
      }
      if (bytes2.length === 65) {
        const r2 = hexlify(bytes2.slice(0, 32));
        const s2 = hexlify(bytes2.slice(32, 64));
        const v2 = _Signature.getNormalizedV(bytes2[64]);
        return new _Signature(_guard$3, r2, s2, v2);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _Signature) {
      return sig.clone();
    }
    const _r2 = sig.r;
    assertError(_r2 != null, "missing r");
    const r = toUint256(_r2);
    const s = function(s2, yParityAndS) {
      if (s2 != null) {
        return toUint256(s2);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes2 = getBytes(yParityAndS);
        bytes2[0] &= 127;
        return hexlify(bytes2);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    const { networkV, v } = function(_v2, yParityAndS, yParity) {
      if (_v2 != null) {
        const v2 = getBigInt(_v2);
        return {
          networkV: v2 >= BN_35$1 ? v2 : void 0,
          v: _Signature.getNormalizedV(v2)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new _Signature(_guard$3, r, s, v);
    if (networkV) {
      __privateSet(result, _networkV, networkV);
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
};
_r = new WeakMap();
_s = new WeakMap();
_v = new WeakMap();
_networkV = new WeakMap();
let Signature = _Signature;
const _SigningKey = class _SigningKey {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    __privateAdd(this, _privateKey);
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    __privateSet(this, _privateKey, hexlify(privateKey));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return __privateGet(this, _privateKey);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(__privateGet(this, _privateKey)), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(__privateGet(this, _privateKey)), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes2 = getBytes(key, "key");
    if (bytes2.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes2, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes2.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes2, 1);
      bytes2 = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes2);
    return hexlify(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature.from(signature);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signature for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};
_privateKey = new WeakMap();
let SigningKey = _SigningKey;
const BN_0$6 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum2 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum2.length < 2) {
    checksum2 = "0" + checksum2;
  }
  return checksum2;
}
const Base36 = function() {
  const result = {};
  for (let i = 0; i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_0$6;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getIcapAddress(address) {
  let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getCreateAddress(tx) {
  const from = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
function getCreate2Address(_from, _salt, _initCodeHash) {
  const from = getAddress(_from);
  const salt = getBytes(_salt, "salt");
  const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
  assertArgument(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  assertArgument(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return getAddress(dataSlice(keccak256(concat(["0xff", from, salt, initCodeHash])), 12));
}
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
function isAddress(value) {
  try {
    getAddress(value);
    return true;
  } catch (error) {
  }
  return false;
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
const _gaurd = {};
function n(value, width) {
  let signed2 = false;
  if (width < 0) {
    signed2 = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
}
function b(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
}
const _typedSymbol = Symbol.for("_ethers_typed");
const _Typed = class _Typed {
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    __publicField(this, "type");
    /**
     *  The actual value.
     */
    __publicField(this, "value");
    __privateAdd(this, _options);
    /**
     *  @_ignore:
     */
    __publicField(this, "_typedSymbol");
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type, value });
    __privateSet(this, _options, options);
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v) => v.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return __privateGet(this, _options);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (__privateGet(this, _options) === true) {
      return -1;
    }
    if (__privateGet(this, _options) === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new _Typed(_gaurd, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v) {
    return n(v, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v) {
    return n(v, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v) {
    return n(v, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v) {
    return n(v, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v) {
    return n(v, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v) {
    return n(v, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v) {
    return n(v, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v) {
    return n(v, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v) {
    return n(v, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v) {
    return n(v, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v) {
    return n(v, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v) {
    return n(v, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v) {
    return n(v, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v) {
    return n(v, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v) {
    return n(v, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v) {
    return n(v, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v) {
    return n(v, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v) {
    return n(v, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v) {
    return n(v, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v) {
    return n(v, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v) {
    return n(v, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v) {
    return n(v, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v) {
    return n(v, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v) {
    return n(v, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v) {
    return n(v, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v) {
    return n(v, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v) {
    return n(v, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v) {
    return n(v, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v) {
    return n(v, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v) {
    return n(v, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v) {
    return n(v, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v) {
    return n(v, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v) {
    return n(v, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v) {
    return n(v, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v) {
    return n(v, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v) {
    return n(v, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v) {
    return n(v, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v) {
    return n(v, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v) {
    return n(v, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v) {
    return n(v, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v) {
    return n(v, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v) {
    return n(v, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v) {
    return n(v, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v) {
    return n(v, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v) {
    return n(v, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v) {
    return n(v, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v) {
    return n(v, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v) {
    return n(v, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v) {
    return n(v, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v) {
    return n(v, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v) {
    return n(v, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v) {
    return n(v, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v) {
    return n(v, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v) {
    return n(v, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v) {
    return n(v, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v) {
    return n(v, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v) {
    return n(v, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v) {
    return n(v, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v) {
    return n(v, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v) {
    return n(v, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v) {
    return n(v, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v) {
    return n(v, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v) {
    return b(v, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v) {
    return b(v, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v) {
    return b(v, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v) {
    return b(v, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v) {
    return b(v, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v) {
    return b(v, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v) {
    return b(v, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v) {
    return b(v, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v) {
    return b(v, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v) {
    return b(v, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v) {
    return b(v, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v) {
    return b(v, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v) {
    return b(v, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v) {
    return b(v, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v) {
    return b(v, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v) {
    return b(v, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v) {
    return b(v, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v) {
    return b(v, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v) {
    return b(v, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v) {
    return b(v, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v) {
    return b(v, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v) {
    return b(v, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v) {
    return b(v, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v) {
    return b(v, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v) {
    return b(v, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v) {
    return b(v, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v) {
    return b(v, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v) {
    return b(v, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v) {
    return b(v, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v) {
    return b(v, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v) {
    return b(v, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v) {
    return b(v, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v) {
    return new _Typed(_gaurd, "address", v);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v) {
    return new _Typed(_gaurd, "bool", !!v);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v) {
    return new _Typed(_gaurd, "bytes", v);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v) {
    return new _Typed(_gaurd, "string", v);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v, dynamic) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v, name) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v) {
    return new _Typed(_gaurd, "overrides", Object.assign({}, v));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};
_options = new WeakMap();
let Typed = _Typed;
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value2) {
    let value = Typed.dereference(_value2, "string");
    try {
      value = getAddress(value);
    } catch (error) {
      return this._throwError(error.message, _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    __publicField(this, "coder");
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    __publicField(this, "coder");
    __publicField(this, "length");
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    __publicField(this, "size");
    defineProperties(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value2) {
    let data = getBytesCopy(Typed.dereference(_value2, this.type));
    if (data.length !== this.size) {
      this._throwError("incorrect data length", _value2);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
}
const Empty = new Uint8Array([]);
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
}
const BN_0$5 = BigInt(0);
const BN_1$1 = BigInt(1);
const BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class NumberCoder extends Coder {
  constructor(size, signed2, localName) {
    const name = (signed2 ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    __publicField(this, "size");
    __publicField(this, "signed");
    defineProperties(this, { size, signed: signed2 }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value2) {
    let value = getBigInt(Typed.dereference(_value2, this.type));
    let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_1$1)) {
        this._throwError("value out-of-bounds", _value2);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_0$5 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value2) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value2, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    __publicField(this, "coders");
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b2) => a.address.localeCompare(b2.address));
  return result;
}
function authorizationify(auth) {
  return {
    address: getAddress(auth.address),
    nonce: getBigInt(auth.nonce != null ? auth.nonce : 0),
    chainId: getBigInt(auth.chainId != null ? auth.chainId : 0),
    signature: Signature.from(auth.signature)
  };
}
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}
const BN_0$4 = BigInt(0);
const BN_2$1 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const BLOB_SIZE = 4096 * 32;
function getKzgLibrary(kzg) {
  const blobToKzgCommitment = (blob) => {
    if ("computeBlobProof" in kzg) {
      if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
        return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));
      }
    } else if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
      return getBytes(kzg.blobToKzgCommitment(blob));
    }
    if ("blobToKZGCommitment" in kzg && typeof kzg.blobToKZGCommitment === "function") {
      return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  const computeBlobKzgProof = (blob, commitment) => {
    if ("computeBlobProof" in kzg && typeof kzg.computeBlobProof === "function") {
      return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));
    }
    if ("computeBlobKzgProof" in kzg && typeof kzg.computeBlobKzgProof === "function") {
      return kzg.computeBlobKzgProof(blob, commitment);
    }
    if ("computeBlobKZGProof" in kzg && typeof kzg.computeBlobKZGProof === "function") {
      return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  return { blobToKzgCommitment, computeBlobKzgProof };
}
function getVersionedHash(version2, hash2) {
  let versioned = version2.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha256(hash2).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleAuthorizationList(value, param) {
  try {
    if (!Array.isArray(value)) {
      throw new Error("authorizationList: invalid array");
    }
    const result = [];
    for (let i = 0; i < value.length; i++) {
      const auth = value[i];
      if (!Array.isArray(auth)) {
        throw new Error(`authorization[${i}]: invalid array`);
      }
      if (auth.length !== 6) {
        throw new Error(`authorization[${i}]: wrong length`);
      }
      if (!auth[1]) {
        throw new Error(`authorization[${i}]: null address`);
      }
      result.push({
        address: handleAddress(auth[1]),
        nonce: handleUint(auth[2], "nonce"),
        chainId: handleUint(auth[0], "chainId"),
        signature: Signature.from({
          yParity: handleNumber(auth[3], "yParity"),
          r: zeroPadValue(auth[4], 32),
          s: zeroPadValue(auth[5], 32)
        })
      });
    }
    return result;
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value2, param) {
  if (_value2 === "0x") {
    return 0;
  }
  return getNumber(_value2, param);
}
function handleUint(_value2, param) {
  if (_value2 === "0x") {
    return BN_0$4;
  }
  const value = getBigInt(_value2, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value2, name) {
  const value = getBigInt(_value2, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function formatAuthorizationList(value) {
  return value.map((a) => {
    return [
      formatNumber(a.chainId, "chainId"),
      a.address,
      formatNumber(a.nonce, "nonce"),
      formatNumber(a.signature.yParity, "yParity"),
      toBeArray(a.signature.r),
      toBeArray(a.signature.s)
    ];
  });
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0; i < value.length; i++) {
    assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy(data) {
  const fields = decodeRlp(data);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_0$4
  };
  if (fields.length === 6) {
    return tx;
  }
  const v = handleUint(fields[6], "v");
  const r = handleUint(fields[7], "r");
  const s = handleUint(fields[8], "s");
  if (r === BN_0$4 && s === BN_0$4) {
    tx.chainId = v;
  } else {
    let chainId = (v - BN_35) / BN_2$1;
    if (chainId < BN_0$4) {
      chainId = BN_0$4;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_0$4 || (v === BN_27 || v === BN_28), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_0$4;
  if (tx.chainId != BN_0$4) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_0$4) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v = BigInt(27 + sig.yParity);
  if (chainId !== BN_0$4) {
    v = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r = zeroPadValue(fields[1], 32);
  const s = zeroPadValue(fields[2], 32);
  const signature = Signature.from({ r, s, yParity });
  tx.signature = signature;
}
function _parseEip1559(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data) {
  let fields = decodeRlp(getBytes(data).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i = 0; i < fields[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b2) => b2.data),
          blobs.map((b2) => b2.commitment),
          blobs.map((b2) => b2.proof)
        ])
      ]);
    }
  }
  return concat(["0x03", encodeRlp(fields)]);
}
function _parseEip7702(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), "invalid field count for transaction type: 4", "data", hexlify(data));
  const tx = {
    type: 4,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    authorizationList: handleAuthorizationList(fields[9], "authorizationList")
  };
  if (fields.length === 10) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(10));
  return tx;
}
function _serializeEip7702(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatAuthorizationList(tx.authorizationList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x04", encodeRlp(fields)]);
}
const _Transaction = class _Transaction {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    __privateAdd(this, _Transaction_instances);
    __privateAdd(this, _type);
    __privateAdd(this, _to);
    __privateAdd(this, _data3);
    __privateAdd(this, _nonce);
    __privateAdd(this, _gasLimit);
    __privateAdd(this, _gasPrice);
    __privateAdd(this, _maxPriorityFeePerGas);
    __privateAdd(this, _maxFeePerGas);
    __privateAdd(this, _value);
    __privateAdd(this, _chainId);
    __privateAdd(this, _sig);
    __privateAdd(this, _accessList);
    __privateAdd(this, _maxFeePerBlobGas);
    __privateAdd(this, _blobVersionedHashes);
    __privateAdd(this, _kzg);
    __privateAdd(this, _blobs);
    __privateAdd(this, _auths);
    __privateSet(this, _type, null);
    __privateSet(this, _to, null);
    __privateSet(this, _nonce, 0);
    __privateSet(this, _gasLimit, BN_0$4);
    __privateSet(this, _gasPrice, null);
    __privateSet(this, _maxPriorityFeePerGas, null);
    __privateSet(this, _maxFeePerGas, null);
    __privateSet(this, _data3, "0x");
    __privateSet(this, _value, BN_0$4);
    __privateSet(this, _chainId, BN_0$4);
    __privateSet(this, _sig, null);
    __privateSet(this, _accessList, null);
    __privateSet(this, _maxFeePerBlobGas, null);
    __privateSet(this, _blobVersionedHashes, null);
    __privateSet(this, _kzg, null);
    __privateSet(this, _blobs, null);
    __privateSet(this, _auths, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return __privateGet(this, _type);
  }
  set type(value) {
    switch (value) {
      case null:
        __privateSet(this, _type, null);
        break;
      case 0:
      case "legacy":
        __privateSet(this, _type, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        __privateSet(this, _type, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        __privateSet(this, _type, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        __privateSet(this, _type, 3);
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        __privateSet(this, _type, 4);
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = __privateGet(this, _to);
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    __privateSet(this, _to, value == null ? null : getAddress(value));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return __privateGet(this, _nonce);
  }
  set nonce(value) {
    __privateSet(this, _nonce, getNumber(value, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return __privateGet(this, _gasLimit);
  }
  set gasLimit(value) {
    __privateSet(this, _gasLimit, getBigInt(value));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = __privateGet(this, _gasPrice);
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_0$4;
    }
    return value;
  }
  set gasPrice(value) {
    __privateSet(this, _gasPrice, value == null ? null : getBigInt(value, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = __privateGet(this, _maxPriorityFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    __privateSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = __privateGet(this, _maxFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    __privateSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return __privateGet(this, _data3);
  }
  set data(value) {
    __privateSet(this, _data3, hexlify(value));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return __privateGet(this, _value);
  }
  set value(value) {
    __privateSet(this, _value, getBigInt(value, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return __privateGet(this, _chainId);
  }
  set chainId(value) {
    __privateSet(this, _chainId, getBigInt(value));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return __privateGet(this, _sig) || null;
  }
  set signature(value) {
    __privateSet(this, _sig, value == null ? null : Signature.from(value));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = __privateGet(this, _accessList) || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    __privateSet(this, _accessList, value == null ? null : accessListify(value));
  }
  get authorizationList() {
    const value = __privateGet(this, _auths) || null;
    if (value == null) {
      if (this.type === 4) {
        return [];
      }
    }
    return value;
  }
  set authorizationList(auths) {
    __privateSet(this, _auths, auths == null ? null : auths.map((a) => authorizationify(a)));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = __privateGet(this, _maxFeePerBlobGas);
    if (value == null && this.type === 3) {
      return BN_0$4;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    __privateSet(this, _maxFeePerBlobGas, value == null ? null : getBigInt(value, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = __privateGet(this, _blobVersionedHashes);
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0; i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    __privateSet(this, _blobVersionedHashes, value);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (__privateGet(this, _blobs) == null) {
      return null;
    }
    return __privateGet(this, _blobs).map((b2) => Object.assign({}, b2));
  }
  set blobs(_blobs2) {
    if (_blobs2 == null) {
      __privateSet(this, _blobs, null);
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i = 0; i < _blobs2.length; i++) {
      const blob = _blobs2[i];
      if (isBytesLike(blob)) {
        assert(__privateGet(this, _kzg), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data = getBytes(blob);
        assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
        if (data.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data);
          data = padded;
        }
        const commit = __privateGet(this, _kzg).blobToKzgCommitment(data);
        const proof = hexlify(__privateGet(this, _kzg).computeBlobKzgProof(data, commit));
        blobs.push({
          data: hexlify(data),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob.commitment);
        blobs.push({
          data: hexlify(blob.data),
          commitment: commit,
          proof: hexlify(blob.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    __privateSet(this, _blobs, blobs);
    __privateSet(this, _blobVersionedHashes, versionedHashes);
  }
  get kzg() {
    return __privateGet(this, _kzg);
  }
  set kzg(kzg) {
    if (kzg == null) {
      __privateSet(this, _kzg, null);
    } else {
      __privateSet(this, _kzg, getKzgLibrary(kzg));
    }
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(__privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = __privateGet(this, _maxFeePerBlobGas) != null || __privateGet(this, _blobVersionedHashes);
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (this.authorizationList && this.authorizationList.length) {
        types.push(4);
      } else if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s = (v) => {
      if (v == null) {
        return null;
      }
      return v.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s(this.gasLimit),
      gasPrice: s(this.gasPrice),
      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
      maxFeePerGas: s(this.maxFeePerGas),
      value: s(this.value),
      chainId: s(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return _Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return _Transaction.from(_parseEip2930(payload));
        case 2:
          return _Transaction.from(_parseEip1559(payload));
        case 3:
          return _Transaction.from(_parseEip4844(payload));
        case 4:
          return _Transaction.from(_parseEip7702(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new _Transaction();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.authorizationList != null) {
      result.authorizationList = tx.authorizationList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
};
_type = new WeakMap();
_to = new WeakMap();
_data3 = new WeakMap();
_nonce = new WeakMap();
_gasLimit = new WeakMap();
_gasPrice = new WeakMap();
_maxPriorityFeePerGas = new WeakMap();
_maxFeePerGas = new WeakMap();
_value = new WeakMap();
_chainId = new WeakMap();
_sig = new WeakMap();
_accessList = new WeakMap();
_maxFeePerBlobGas = new WeakMap();
_blobVersionedHashes = new WeakMap();
_kzg = new WeakMap();
_blobs = new WeakMap();
_auths = new WeakMap();
_Transaction_instances = new WeakSet();
getSerialized_fn = function(signed2, sidecar) {
  assert(!signed2 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const sig = signed2 ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return _serializeLegacy(this, sig);
    case 1:
      return _serializeEip2930(this, sig);
    case 2:
      return _serializeEip1559(this, sig);
    case 3:
      return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
    case 4:
      return _serializeEip7702(this, sig);
  }
  assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let Transaction = _Transaction;
function hashAuthorization(auth) {
  assertArgument(typeof auth.address === "string", "invalid address for hashAuthorization", "auth.address", auth);
  return keccak256(concat([
    "0x05",
    encodeRlp([
      auth.chainId != null ? toBeArray(auth.chainId) : "0x",
      getAddress(auth.address),
      auth.nonce != null ? toBeArray(auth.nonce) : "0x"
    ])
  ]));
}
function verifyAuthorization(auth, sig) {
  return recoverAddress(hashAuthorization(auth), sig);
}
function id(value) {
  return keccak256(toUtf8Bytes(value));
}
var COMPRESSED$1 = "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";
const FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
const NSM_MAX = 4;
function decode_arithmetic(bytes2) {
  let pos = 0;
  function u16() {
    return bytes2[pos++] << 8 | bytes2[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes2[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = 2 ** N2;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N2; i++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b2 - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 2:
        return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 1:
        return offset + bytes2[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
}
function unsafe_atob(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
  let n2 = s.length;
  let ret = new Uint8Array(6 * n2 >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0; i < n2; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n2, next) {
  let v = Array(n2);
  for (let i = 0, x = 0; i < n2; i++) v[i] = x += signed(next());
  return v;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n2 = next();
    if (!n2) break;
    prev += x;
    for (let i = 0; i < n2; i++) {
      ret.push(prev + i);
    }
    prev += n2 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v = read_sorted(next);
    if (v.length) return v;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0) break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0) break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x) break;
    v.push(x);
  }
  return v;
}
function read_transposed(n2, w, next) {
  let m = Array(n2).fill().map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n2, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
}
function read_replacement_table(w, next) {
  let n2 = 1 + next();
  let m = read_transposed(n2, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode2([]), []);
  return ret;
  function decode2(Q) {
    let S2 = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i) => sorted[i]);
      if (cps.length) return decode2(cps);
    });
    return { S: S2, B, Q };
  }
  function expand({ S: S2, B }, cps, saved) {
    if (S2 & 4 && saved === cps[cps.length - 1]) return;
    if (S2 & 2) saved = cps[cps.length - 1];
    if (S2 & 1) ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s) {
  let cps = [];
  for (let pos = 0, len = s.length; pos < len; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0; i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a, b2) {
  let n2 = a.length;
  let c = n2 - b2.length;
  for (let i = 0; c == 0 && i < n2; i++) c = a[i] - b2[i];
  return c;
}
var COMPRESSED = "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";
const S0 = 44032;
const L0 = 4352;
const V0 = 4449;
const T0 = 4519;
const L_COUNT = 19;
const V_COUNT = 21;
const T_COUNT = 28;
const N_COUNT = V_COUNT * T_COUNT;
const S_COUNT = L_COUNT * N_COUNT;
const S1 = S0 + S_COUNT;
const L1 = L0 + L_COUNT;
const V1 = V0 + V_COUNT;
const T1$1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
let SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;
function init$1() {
  let r = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a, b2] = cps;
      let bucket = RECOMP.get(a);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a, bucket);
      }
      bucket.set(b2, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a, b2) {
  if (a >= L0 && a < L1 && b2 >= V0 && b2 < V1) {
    return S0 + (a - L0) * N_COUNT + (b2 - V0) * T_COUNT;
  } else if (is_hangul(a) && b2 > T0 && b2 < T1$1 && (a - S0) % T_COUNT == 0) {
    return a + (b2 - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b2);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add2(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add2(L0 + l_index);
        add2(V0 + v_index);
        if (t_index > 0) add2(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add2(cp);
        }
      }
      if (!buf.length) break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1; i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j) break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc) break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
const HYPHEN = 45;
const STOP_CH = ".";
const FE0F = 65039;
const UNIQUE_PH = 1;
const Array_from = (x) => Array.from(x);
function group_has_cp(g, cp) {
  return g.P.has(cp) || g.Q.has(cp);
}
class Emoji extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
}
let MAPPED, IGNORED, CM, NSM, ESCAPE, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;
function init() {
  if (MAPPED) return;
  let r = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v) => v.forEach((x) => set.add(x));
  MAPPED = new Map(read_mapped(r));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  read_sorted_set();
  let chunks = read_sorted_arrays(r);
  let unrestricted = r();
  const read_chunked = () => {
    let set = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i) => {
    let N2 = read_array_while(r).map((x) => x + 96);
    if (N2.length) {
      let R = i >= unrestricted;
      N2[0] -= 32;
      N2 = str_from_cps(N2);
      if (R) N2 = `Restricted[${N2}]`;
      let P = read_chunked();
      let Q = read_chunked();
      let M = !r();
      return { N: N2, P, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b2) => a - b2);
  wholes.forEach((cp, i) => {
    let d = r();
    let w = wholes[i] = d ? wholes[i - d] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g) => group_has_cp(g, cp));
      let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x) => Array_from(x.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union.filter((g) => !G.has(g)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g of GROUPS) {
    for (let cp of g.P) add_to_union(cp);
    for (let cp of g.Q) add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r).map((v) => Emoji.from(v)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s) {
  return `"${s}"`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev) throw error_placement(`leading ${prev}`);
  let n2 = cps.length;
  let last = -1;
  for (let i = 1; i < n2; i++) {
    cp = cps[i];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i) throw error_placement(`${prev} + ${match}`);
      last = i + 1;
      prev = match;
    }
  }
  if (last == n2) throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0])) buf.push("");
  if (cps.length > max) {
    max >>= 1;
    cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
  }
  let prev = 0;
  let n2 = cps.length;
  for (let i = 0; i < n2; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n2)));
  return buf.join("");
}
function is_combining_mark(cp) {
  init();
  return CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
function ens_normalize(name) {
  return flatten(split(name, nfc, filter_fe0f));
}
function split(name, nf, ef) {
  if (!name) return [];
  init();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
      // codepoint, not substring!
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0])) throw error_placement("leading combining mark");
          for (let i = 1; i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g] = determine_group(unique);
          check_group(g, chars);
          check_whole(g, unique);
          type = g.N;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH) return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set);
      if (!maker.length) return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => group_has_cp(g, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => group_has_cp(g, cp));
    if (!gs.length) {
      if (!GROUPS.some((g) => group_has_cp(g, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1) break;
  }
  return groups;
}
function flatten(split2) {
  return split2.map(({ input, error, output: output2 }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split2.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g, cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (g.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e = decomposed2.length; i < e; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp; j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i; k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node) break;
    let { V } = node;
    if (V) {
      emoji = V;
      cps.length = pos;
    }
  }
  return emoji;
}
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  const bytes2 = toUtf8Bytes(ensNormalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes2.length; i++) {
    const d = bytes2[i];
    if (d === 46) {
      comps.push(checkComponent(bytes2.slice(last, i)));
      last = i + 1;
    }
  }
  assertArgument(last < bytes2.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes2.slice(last)));
  return comps;
}
function ensNormalize(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name);
  } catch (error) {
    assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
  }
}
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
  let result = Zeros;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name, _maxLength) {
  const length = _maxLength != null ? _maxLength : 63;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
function verifyMessage(message, sig) {
  const digest = hashMessage(message);
  return recoverAddress(digest, sig);
}
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0$3 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = getBytes(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return concat([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
const hexTrue = toBeHex(BN_1, 32);
const hexFalse = toBeHex(BN_0$3, 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value2) {
    const value = getBigInt(_value2, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes2 = getBytes(value, "domain.salt");
    assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes2);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT256, signed2 ? width - 1 : width);
      const boundsLower = signed2 ? (boundsUpper + BN_1) * BN__1 : BN_0$3;
      return function(_value2) {
        const value = getBigInt(_value2, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed2 ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes2 = getBytes(value);
        assertArgument(bytes2.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
function splitArray(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
const _TypedDataEncoder = class _TypedDataEncoder {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types2) {
    __privateAdd(this, _TypedDataEncoder_instances);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    __publicField(this, "primaryType");
    __privateAdd(this, _types);
    __privateAdd(this, _fullTypes);
    __privateAdd(this, _encoderCache);
    __privateSet(this, _fullTypes, /* @__PURE__ */ new Map());
    __privateSet(this, _encoderCache, /* @__PURE__ */ new Map());
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types = {};
    Object.keys(_types2).forEach((type) => {
      types[type] = _types2[type].map(({ name, type: type2 }) => {
        let { base, index } = splitArray(type2);
        if (base === "int" && !_types2["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types2["uint"]) {
          base = "uint256";
        }
        return { name, type: base + (index || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    __privateSet(this, _types, JSON.stringify(types));
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types2);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types2);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types2);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types2);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types2);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types2);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      __privateGet(this, _fullTypes).set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(__privateGet(this, _types));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = __privateGet(this, _encoderCache).get(type);
    if (!encoder) {
      encoder = __privateMethod(this, _TypedDataEncoder_instances, getEncoder_fn).call(this, type);
      __privateGet(this, _encoderCache).set(type, encoder);
    }
    return encoder;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = __privateGet(this, _fullTypes).get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray(type).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v) => this._visit(array.prefix, v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new _TypedDataEncoder(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return _TypedDataEncoder.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return _TypedDataEncoder.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type = domainFieldTypes[name];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type });
    }
    domainFields.sort((a, b2) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b2.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types, value) {
    return concat([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain),
      _TypedDataEncoder.from(types).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types, value) {
    return keccak256(_TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = _TypedDataEncoder.from(types);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types, value) {
    _TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = _TypedDataEncoder.from(types);
    types = encoder.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
};
_types = new WeakMap();
_fullTypes = new WeakMap();
_encoderCache = new WeakMap();
_TypedDataEncoder_instances = new WeakSet();
getEncoder_fn = function(type) {
  {
    const encoder = getBaseEncoder(type);
    if (encoder) {
      return encoder;
    }
  }
  const array = splitArray(type).array;
  if (array) {
    const subtype = array.prefix;
    const subEncoder = this.getEncoder(subtype);
    return (value) => {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      let result = value.map(subEncoder);
      if (__privateGet(this, _fullTypes).has(subtype)) {
        result = result.map(keccak256);
      }
      return keccak256(concat(result));
    };
  }
  const fields = this.types[type];
  if (fields) {
    const encodedType = id(__privateGet(this, _fullTypes).get(type));
    return (value) => {
      const values = fields.map(({ name, type: type2 }) => {
        const result = this.getEncoder(type2)(value[name]);
        if (__privateGet(this, _fullTypes).has(type2)) {
          return keccak256(result);
        }
        return result;
      });
      values.unshift(encodedType);
      return concat(values);
    };
  }
  assertArgument(false, `unknown type: ${type}`, "type", type);
};
let TypedDataEncoder = _TypedDataEncoder;
function verifyTypedData(domain, types, value, signature) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);
}
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
const _kwVisib = "constant external internal payable private public pure view override";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
const SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
const _TokenString = class _TokenString {
  constructor(tokens) {
    __privateAdd(this, _TokenString_instances);
    __privateAdd(this, _offset2);
    __privateAdd(this, _tokens);
    __privateSet(this, _offset2, 0);
    __privateSet(this, _tokens, tokens.slice());
  }
  get offset() {
    return __privateGet(this, _offset2);
  }
  get length() {
    return __privateGet(this, _tokens).length - __privateGet(this, _offset2);
  }
  clone() {
    return new _TokenString(__privateGet(this, _tokens));
  }
  reset() {
    __privateSet(this, _offset2, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = __privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, top.match + 1);
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (__privateGet(this, _offset2) < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(__privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, link));
      __privateSet(this, _offset2, link);
    }
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (__privateGet(this, _offset2) >= __privateGet(this, _tokens).length) {
      throw new Error("out-of-bounds");
    }
    return __privateGet(this, _tokens)[__privateGet(this, _offset2)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    __privateWrapper(this, _offset2)._++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = __privateGet(this, _offset2); i < __privateGet(this, _tokens).length; i++) {
      const token = __privateGet(this, _tokens)[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
_offset2 = new WeakMap();
_tokens = new WeakMap();
_TokenString_instances = new WeakSet();
subTokenString_fn = function(from = 0, to = 0) {
  return new _TokenString(__privateGet(this, _tokens).slice(from, to).map((t) => {
    return Object.freeze(Object.assign({}, t, {
      match: t.match - from,
      linkBack: t.linkBack - from,
      linkNext: t.linkNext - from
    }));
  }));
};
let TokenString = _TokenString;
function lex(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t) => Object.freeze(t)));
}
function allowSingle(set, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
const _guard$2 = {};
const internal$1 = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
const _ParamType = class _ParamType {
  /**
   *  @private
   */
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    __privateAdd(this, _ParamType_instances);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    __publicField(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    __publicField(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    __publicField(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    __publicField(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    __publicField(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayChildren");
    assertPrivate(guard, _guard$2, "ParamType");
    Object.defineProperty(this, internal$1, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c) => JSON.parse(c.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v) => _this.arrayChildren.walk(v, process));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v, i) => _this.components[i].walk(v, process));
    }
    return process(this.type, value);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process) {
    const promises = [];
    const result = [value];
    __privateMethod(this, _ParamType_instances, walkAsync_fn).call(this, promises, value, process, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ParamType.from(lex(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => _ParamType.from(t));
        type2 = `tuple(${comps.map((c) => c.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard$2, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard$2, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard$2, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c) => _ParamType.from(c)) : null;
      const tuple = new _ParamType(_guard$2, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType(obj.type);
    return new _ParamType(_guard$2, name || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal$1] === ParamTypeInternal;
  }
};
_ParamType_instances = new WeakSet();
walkAsync_fn = function(promises, value, process, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invalid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    const childType = this.arrayChildren;
    const result2 = value.slice();
    result2.forEach((value2, index) => {
      var _a2;
      __privateMethod(_a2 = childType, _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  if (this.isTuple()) {
    const components = this.components;
    let result2;
    if (Array.isArray(value)) {
      result2 = value.slice();
    } else {
      if (value == null || typeof value !== "object") {
        throw new Error("invalid tuple value");
      }
      result2 = components.map((param) => {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error(`missing value for component ${param.name}`);
        }
        return value[param.name];
      });
    }
    if (result2.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    result2.forEach((value2, index) => {
      var _a2;
      __privateMethod(_a2 = components[index], _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  const result = process(this.type, value);
  if (result.then) {
    promises.push(async function() {
      setValue(await result);
    }());
  } else {
    setValue(result);
  }
};
let ParamType = _ParamType;
class Fragment {
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    /**
     *  The type of the fragment.
     */
    __publicField(this, "type");
    /**
     *  The inputs for the fragment.
     */
    __publicField(this, "inputs");
    assertPrivate(guard, _guard$2, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e) {
      }
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
}
class NamedFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    /**
     *  The name of the fragment.
     */
    __publicField(this, "name");
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
}
function joinParams(format, params) {
  return "(" + params.map((p) => p.format(format)).join(format === "full" ? ", " : ",") + ")";
}
class ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal$1, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard$2, name, inputs);
    }
    return new ErrorFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ErrorFragmentInternal;
  }
}
class EventFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    /**
     *  Whether this event is anonymous.
     */
    __publicField(this, "anonymous");
    Object.defineProperty(this, internal$1, { value: EventFragmentInternal });
    defineProperties(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new EventFragment(_guard$2, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return EventFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard$2, name, inputs, anonymous);
    }
    return new EventFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === EventFragmentInternal;
  }
}
class ConstructorFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    /**
     *  Whether the constructor can receive an endowment.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$1, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format) {
    assert(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [`constructor${joinParams(format, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ConstructorFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard$2, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard$2, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ConstructorFragmentInternal;
  }
}
class FallbackFragment extends Fragment {
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    Object.defineProperty(this, internal$1, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FallbackFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard$2, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard$2, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard$2, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard$2, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FallbackFragmentInternal;
  }
}
class FunctionFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    __publicField(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    __publicField(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    __publicField(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$1, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new FunctionFragment(_guard$2, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FunctionFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard$2, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard$2, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FunctionFragmentInternal;
  }
}
class StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal$1, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return StructFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard$2, name, inputs);
    }
    return new StructFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === StructFragmentInternal;
  }
}
const PanicReasons$1 = /* @__PURE__ */ new Map();
PanicReasons$1.set(0, "GENERIC_PANIC");
PanicReasons$1.set(1, "ASSERT_FALSE");
PanicReasons$1.set(17, "OVERFLOW");
PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
PanicReasons$1.set(34, "BAD_STORAGE_DATA");
PanicReasons$1.set(49, "STACK_UNDERFLOW");
PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(65, "OUT_OF_MEMORY");
PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data) {
    message = "execution reverted";
    const bytes2 = getBytes(data);
    data = hexlify(data);
    if (bytes2.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes2.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes2.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes2.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes2.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes2.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons$1.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data,
    reason,
    transaction,
    invocation,
    revert
  });
}
const _AbiCoder = class _AbiCoder {
  constructor() {
    __privateAdd(this, _AbiCoder_instances);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types) {
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types, values) {
    assertArgumentCount(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types, data, loose) {
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new _AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data) {
    return getBuiltinCallException(action, tx, data, _AbiCoder.defaultAbiCoder());
  }
};
_AbiCoder_instances = new WeakSet();
getCoder_fn = function(param) {
  if (param.isArray()) {
    return new ArrayCoder(__privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, param.arrayChildren), param.arrayLength, param.name);
  }
  if (param.isTuple()) {
    return new TupleCoder(param.components.map((c) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, c)), param.name);
  }
  switch (param.baseType) {
    case "address":
      return new AddressCoder(param.name);
    case "bool":
      return new BooleanCoder(param.name);
    case "string":
      return new StringCoder(param.name);
    case "bytes":
      return new BytesCoder(param.name);
    case "":
      return new NullCoder(param.name);
  }
  let match = param.type.match(paramTypeNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
    return new NumberCoder(size / 8, match[1] === "int", param.name);
  }
  match = param.type.match(paramTypeBytes);
  if (match) {
    let size = parseInt(match[1]);
    assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
    return new FixedBytesCoder(size, param.name);
  }
  assertArgument(false, "invalid type", "type", param.type);
};
let AbiCoder = _AbiCoder;
class LogDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Event.
     */
    __publicField(this, "name");
    /**
     *  The full Event signature.
     */
    __publicField(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    __publicField(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    __publicField(this, "args");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature,
      topic,
      args
    });
  }
}
class TransactionDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    __publicField(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    __publicField(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    __publicField(this, "value");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector,
      value
    });
  }
}
class ErrorDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    /**
     *  The matching fragment.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Error.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    __publicField(this, "args");
    /**
     *  The full Error signature.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Error.
     */
    __publicField(this, "selector");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector
    });
  }
}
class Indexed {
  /**
   *  @_ignore:
   */
  constructor(hash2) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    __publicField(this, "hash");
    /**
     *  @_ignore:
     */
    __publicField(this, "_isIndexed");
    defineProperties(this, { hash: hash2, _isIndexed: true });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const PanicReasons = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons[code.toString()]) {
        reason = PanicReasons[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};
const _Interface = class _Interface {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    __privateAdd(this, _Interface_instances);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    __publicField(this, "fragments");
    /**
     *  The Contract constructor.
     */
    __publicField(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    __publicField(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    __publicField(this, "receive");
    __privateAdd(this, _errors);
    __privateAdd(this, _events);
    __privateAdd(this, _functions);
    //    #structs: Map<string, StructFragment>;
    __privateAdd(this, _abiCoder);
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    __privateSet(this, _functions, /* @__PURE__ */ new Map());
    __privateSet(this, _errors, /* @__PURE__ */ new Map());
    __privateSet(this, _events, /* @__PURE__ */ new Map());
    const frags = [];
    for (const a of abi) {
      try {
        frags.push(Fragment.from(a));
      } catch (error) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    __privateSet(this, _abiCoder, this.getAbiCoder());
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = __privateGet(this, _functions);
          break;
        case "event":
          bucket = __privateGet(this, _events);
          break;
        case "error":
          bucket = __privateGet(this, _errors);
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f2) => f2.format(format));
    return abi;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi.map((j) => JSON.parse(j)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!__privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names2 = Array.from(__privateGet(this, _functions).keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(__privateGet(this, _functions).get(name), i);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!__privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names2 = Array.from(__privateGet(this, _events).keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(__privateGet(this, _events).get(name), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of __privateGet(this, _errors).values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of __privateGet(this, _errors)) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = __privateGet(this, _errors).get(key);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names2 = Array.from(__privateGet(this, _errors).keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(__privateGet(this, _errors).get(name), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data) {
    return __privateGet(this, _abiCoder).decode(params, data);
  }
  _encodeParams(params, values) {
    return __privateGet(this, _abiCoder).encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes2 = getBytesCopy(data);
    if (bytes2.length % 32 === 0) {
      try {
        return __privateGet(this, _abiCoder).decode(fragment.outputs, bytes2);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes2),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data5, tx) {
    const data = getBytes(_data5, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = __privateGet(this, _abiCoder).decode(ef.inputs, data.slice(4));
          error.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(__privateGet(this, _abiCoder).encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        __privateGet(this, _abiCoder).encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(__privateGet(this, _abiCoder).encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: __privateGet(this, _abiCoder).encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? __privateGet(this, _abiCoder).decode(indexed, concat(topics)) : null;
    const resultNonIndexed = __privateGet(this, _abiCoder).decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data) {
    const hexData = hexlify(data);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new _Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};
_errors = new WeakMap();
_events = new WeakMap();
_functions = new WeakMap();
_abiCoder = new WeakMap();
_Interface_instances = new WeakSet();
// Find a function definition by any means necessary (unless it is ambiguous)
getFunction_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const selector = key.toLowerCase();
    for (const fragment of __privateGet(this, _functions).values()) {
      if (selector === fragment.selector) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _functions)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      const lastValue = values.length > 0 ? values[values.length - 1] : null;
      let valueLength = values.length;
      let allowOptions = true;
      if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
        allowOptions = false;
        valueLength--;
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs.length;
        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j = 0; j < values.length; j++) {
          if (!Typed.isTyped(values[j])) {
            continue;
          }
          if (j >= inputs.length) {
            if (values[j].type === "overrides") {
              continue;
            }
            matching.splice(i, 1);
            break;
          }
          if (values[j].type !== inputs[j].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
      const lastArg = values[values.length - 1];
      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
        matching.splice(0, 1);
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
      assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _functions).get(FunctionFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
// Find an event definition by any means necessary (unless it is ambiguous)
getEvent_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const eventTopic = key.toLowerCase();
    for (const fragment of __privateGet(this, _events).values()) {
      if (eventTopic === fragment.topicHash) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _events)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      for (let i = matching.length - 1; i >= 0; i--) {
        if (matching[i].inputs.length < values.length) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j = 0; j < values.length; j++) {
          if (!Typed.isTyped(values[j])) {
            continue;
          }
          if (values[j].type !== inputs[j].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
      assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _events).get(EventFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
let Interface = _Interface;
const BN_0$2 = BigInt(0);
function getValue(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
class FeeData {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    /**
     *  The gas price for legacy networks.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxPriorityFeePerGas");
    defineProperties(this, {
      gasPrice: getValue(gasPrice),
      maxFeePerGas: getValue(maxFeePerGas),
      maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if (req.authorizationList) {
    result.authorizationList = req.authorizationList.slice();
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b2) => {
      if (isBytesLike(b2)) {
        return hexlify(b2);
      }
      return Object.assign({}, b2);
    });
  }
  return result;
}
class Block {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block, provider) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    __publicField(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    __publicField(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    __publicField(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    __publicField(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    __publicField(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    __publicField(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    __publicField(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    __publicField(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    __publicField(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    __publicField(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    __publicField(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    __publicField(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    __publicField(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    __publicField(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    __publicField(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    __publicField(this, "baseFeePerGas");
    __privateAdd(this, _transactions);
    __privateSet(this, _transactions, block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    }));
    defineProperties(this, {
      provider,
      hash: getValue(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return __privateGet(this, _transactions).map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = __privateGet(this, _transactions).slice();
    if (txs.length === 0) {
      return [];
    }
    assert(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash2, miner, prevRandao, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash: hash2,
      miner,
      prevRandao,
      nonce,
      number: number2,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return __privateGet(this, _transactions).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = __privateGet(this, _transactions)[indexOrHash];
    } else {
      const hash2 = indexOrHash.toLowerCase();
      for (const v of __privateGet(this, _transactions)) {
        if (typeof v === "string") {
          if (v !== hash2) {
            continue;
          }
          tx = v;
          break;
        } else {
          if (v.hash !== hash2) {
            continue;
          }
          tx = v;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
}
_transactions = new WeakMap();
class Log {
  /**
   *  @_ignore:
   */
  constructor(log, provider) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    __publicField(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    __publicField(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    __publicField(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    __publicField(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    __publicField(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    __publicField(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    __publicField(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    __publicField(this, "transactionIndex");
    this.provider = provider;
    const topics = Object.freeze(log.topics.slice());
    defineProperties(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter(this);
  }
}
class TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    __publicField(this, "to");
    /**
     *  The sender of the transaction.
     */
    __publicField(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    __publicField(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    __publicField(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    __publicField(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    __publicField(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    __publicField(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    __publicField(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    __publicField(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    __publicField(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    __publicField(this, "root");
    __privateAdd(this, _logs);
    __privateSet(this, _logs, Object.freeze(tx.logs.map((log) => {
      return new Log(log, provider);
    })));
    let gasPrice = BN_0$2;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return __privateGet(this, _logs);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash2,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash2,
      index,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
}
_logs = new WeakMap();
const _TransactionResponse = class _TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    __publicField(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    __publicField(this, "index");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    __publicField(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    __publicField(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    __publicField(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    __publicField(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    __publicField(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    __publicField(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    __publicField(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    __publicField(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    __publicField(this, "value");
    /**
     *  The chain ID.
     */
    __publicField(this, "chainId");
    /**
     *  The signature.
     */
    __publicField(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    __publicField(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    __publicField(this, "blobVersionedHashes");
    /**
     *  The [[link-eip-7702]] authorizations (if any).
     */
    __publicField(this, "authorizationList");
    __privateAdd(this, _startBlock);
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;
    __privateSet(this, _startBlock, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index, hash: hash2, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash2,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature,
      to,
      index,
      type,
      value: toJson(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout2) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout2 == null ? 0 : _timeout2;
    let startBlock = __privateGet(this, _startBlock);
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < __privateGet(this, _startBlock)) {
          nextScan = __privateGet(this, _startBlock);
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash2 of block) {
          if (hash2 === this.hash) {
            return;
          }
        }
        for (let i = 0; i < block.length; i++) {
          const tx = await block.getTransaction(i);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$2) {
              reason = "cancelled";
            }
            assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (confirms === 1 || await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c) => c());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new _TransactionResponse(this, this.provider);
    __privateSet(tx, _startBlock, startBlock);
    return tx;
  }
};
_startBlock = new WeakMap();
let TransactionResponse = _TransactionResponse;
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
}
class EventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log, iface, fragment) {
    super(log, log.provider);
    /**
     *  The Contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The matching event.
     */
    __publicField(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    __publicField(this, "args");
    const args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties(this, { args, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class UndecodedEventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log, error) {
    super(log, log.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    __publicField(this, "error");
    defineProperties(this, { error });
  }
}
class ContractTransactionReceipt extends TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    __privateAdd(this, _iface);
    __privateSet(this, _iface, iface);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log) => {
      const fragment = log.topics.length ? __privateGet(this, _iface).getEvent(log.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log, __privateGet(this, _iface), fragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return log;
    });
  }
}
_iface = new WeakMap();
class ContractTransactionResponse extends TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    __privateAdd(this, _iface2);
    __privateSet(this, _iface2, iface);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(__privateGet(this, _iface2), this.provider, receipt);
  }
}
_iface2 = new WeakMap();
class ContractUnknownEventPayload extends EventPayload {
  /**
   *  @_event:
   */
  constructor(contract, listener, filter, log) {
    super(contract, listener, filter);
    /**
     *  The log with no matching events.
     */
    __publicField(this, "log");
    defineProperties(this, { log });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class ContractEventPayload extends ContractUnknownEventPayload {
  /**
   *  @_ignore:
   */
  constructor(contract, listener, filter, fragment, _log) {
    super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const BN_0$1 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
class PreparedTopicFilter {
  constructor(contract, fragment, args) {
    __privateAdd(this, _filter);
    __publicField(this, "fragment");
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    __privateSet(this, _filter, async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v) => resolveAddress(v, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    }());
  }
  getTopicFilter() {
    return __privateGet(this, _filter);
  }
}
_filter = new WeakMap();
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider$1(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_0$1, "overrides.value") === BN_0$1;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider$1(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas2 = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract,
    estimateGas: estimateGas2,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider = getProvider$1(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas2 = async function(...args) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract.interface.getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment,
    estimateGas: estimateGas2,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract.interface.getEventName(key),
    _contract: contract,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
const internal = Symbol.for("_ethersInternal_contract");
const internalValues = /* @__PURE__ */ new WeakMap();
function setInternal(contract, values) {
  internalValues.set(contract[internal], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e) => {
      if (e == null) {
        return null;
      }
      if (Array.isArray(e)) {
        return e.map(topicHashify);
      }
      return topicHashify(e);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider = getProvider$1(contract.runner);
  assert(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter = { address, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
let lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error) {
    }
    return !once;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {
  }
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
const passProperties = ["then"];
_a = internal;
const _BaseContract = class _BaseContract {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi, runner, _deployTx) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    __publicField(this, "target");
    /**
     *  The contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    __publicField(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    __publicField(this, "filters");
    /**
     *  @_ignore:
     */
    __publicField(this, _a);
    /**
     *  The fallback or receive function if any.
     */
    __publicField(this, "fallback");
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider$1(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new _BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new _BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider = getProvider$1(this.runner);
    assert(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider = getProvider$1(this.runner);
    assert(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve(this);
          }
          provider.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash2) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider = getProvider$1(this.runner);
    assert(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter)).map((log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return new Log(log, provider);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi) {
    class CustomContract extends _BaseContract {
      constructor(address, runner = null) {
        super(address, abi, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi, runner);
    return contract;
  }
};
let BaseContract = _BaseContract;
function _ContractBase() {
  return BaseContract;
}
class Contract extends _ContractBase() {
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
class MulticoinProviderPlugin {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name) {
    /**
     *  The name.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data) {
    throw new Error("unsupported coin");
  }
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
const _EnsResolver = class _EnsResolver {
  constructor(provider, address, name) {
    __privateAdd(this, _EnsResolver_instances);
    /**
     *  The connected provider.
     */
    __publicField(this, "provider");
    /**
     *  The address of the resolver.
     */
    __publicField(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    __publicField(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    __privateAdd(this, _supports2544);
    __privateAdd(this, _resolver);
    defineProperties(this, { provider, address, name });
    __privateSet(this, _supports2544, null);
    __privateSet(this, _resolver, new Contract(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (__privateGet(this, _supports2544) == null) {
      __privateSet(this, _supports2544, (async () => {
        try {
          return await __privateGet(this, _resolver).supportsInterface("0x9061b923");
        } catch (error) {
          if (isError(error, "CALL_EXCEPTION")) {
            return false;
          }
          __privateSet(this, _supports2544, null);
          throw error;
        }
      })());
    }
    return await __privateGet(this, _supports2544);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error) {
        if (isError(error, "CALL_EXCEPTION")) {
          return null;
        }
        throw error;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data2, 20)) {
        return getAddress(data2);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [coinType]);
    if (data == null || data === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data);
    if (address != null) {
      return address;
    }
    assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key) {
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "text(bytes32,string)", [key]);
    if (data == null || data === "0x") {
      return null;
    }
    return data;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "contenthash(bytes32)");
    if (data == null || data === "0x") {
      return null;
    }
    const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i = 0; i < matchers.length; i++) {
        const match = avatar.match(matchers[i]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract = new Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error2) {
                const bytes2 = response.body;
                if (bytes2) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes2) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider) {
    const network = await provider.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider, name) {
    var _a2;
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await __privateMethod(_a2 = _EnsResolver, _EnsResolver_static, getResolver_fn).call(_a2, provider, currentName);
      if (addr != null) {
        const resolver = new _EnsResolver(provider, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
};
_supports2544 = new WeakMap();
_resolver = new WeakMap();
_EnsResolver_instances = new WeakSet();
fetch_fn = async function(funcName, params) {
  params = (params || []).slice();
  const iface = __privateGet(this, _resolver).interface;
  params.unshift(namehash(this.name));
  let fragment = null;
  if (await this.supportsWildcard()) {
    fragment = iface.getFunction(funcName);
    assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
      info: { funcName }
    });
    params = [
      dnsEncode(this.name, 255),
      iface.encodeFunctionData(fragment, params)
    ];
    funcName = "resolve(bytes,bytes)";
  }
  params.push({
    enableCcipRead: true
  });
  try {
    const result = await __privateGet(this, _resolver)[funcName](...params);
    if (fragment) {
      return iface.decodeFunctionResult(fragment, result)[0];
    }
    return result;
  } catch (error) {
    if (!isError(error, "CALL_EXCEPTION")) {
      throw error;
    }
  }
  return null;
};
_EnsResolver_static = new WeakSet();
getResolver_fn = async function(provider, name) {
  const ensAddr = await _EnsResolver.getEnsAddress(provider);
  try {
    const contract = new Contract(ensAddr, [
      "function resolver(bytes32) view returns (address)"
    ], provider);
    const addr = await contract.resolver(namehash(name), {
      enableCcipRead: true
    });
    if (addr === ZeroAddress) {
      return null;
    }
    return addr;
  } catch (error) {
    throw error;
  }
  return null;
};
__privateAdd(_EnsResolver, _EnsResolver_static);
let EnsResolver = _EnsResolver;
const BN_0 = BigInt(0);
function allowNull(format, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format(value);
  };
}
function arrayOf(format, allowNull2) {
  return (array) => {
    if (allowNull2 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format(i));
  };
}
function object(format, altNames) {
  return (value) => {
    const result = {};
    for (const key in format) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format[key](value[srcKey]);
        if (nv !== void 0) {
          result[key] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
const _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
const _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
const _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
const _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_0) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object({
    hash: formatHash,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull(getNumber, void 0),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    authorizationList: allowNull(arrayOf((v) => {
      let sig;
      if (v.signature) {
        sig = v.signature;
      } else {
        let yParity = v.yParity;
        if (yParity === "0x1b") {
          yParity = 0;
        } else if (yParity === "0x1c") {
          yParity = 1;
        }
        sig = Object.assign({}, v, { yParity });
      }
      return {
        address: getAddress(v.address),
        chainId: getBigInt(v.chainId),
        nonce: getBigInt(v.nonce),
        signature: Signature.from(sig)
      };
    }, false), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature.from(value.signature);
  } else {
    result.signature = Signature.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
    result.blockHash = null;
  }
  return result;
}
const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class NetworkPlugin {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new NetworkPlugin(this.name);
  }
}
class GasCostPlugin extends NetworkPlugin {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    __publicField(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    __publicField(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    __publicField(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    __publicField(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    __publicField(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListAddress");
    const props = { effectiveBlock };
    function set(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set("txBase", 21e3);
    set("txCreate", 32e3);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}
class EnsPlugin extends NetworkPlugin {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    __publicField(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    __publicField(this, "targetNetwork");
    defineProperties(this, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}
const _FeeDataNetworkPlugin = class _FeeDataNetworkPlugin extends NetworkPlugin {
  /**
   *  Creates a new **FeeDataNetworkPlugin**.
   */
  constructor(feeDataFunc) {
    super("org.ethers.plugins.network.FeeData");
    __privateAdd(this, _feeDataFunc);
    __privateSet(this, _feeDataFunc, feeDataFunc);
  }
  /**
   *  The fee data function provided to the constructor.
   */
  get feeDataFunc() {
    return __privateGet(this, _feeDataFunc);
  }
  /**
   *  Resolves to the fee data.
   */
  async getFeeData(provider) {
    return await __privateGet(this, _feeDataFunc).call(this, provider);
  }
  clone() {
    return new _FeeDataNetworkPlugin(__privateGet(this, _feeDataFunc));
  }
};
_feeDataFunc = new WeakMap();
let FeeDataNetworkPlugin = _FeeDataNetworkPlugin;
class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    __privateAdd(this, _url2);
    __privateAdd(this, _processFunc);
    __privateSet(this, _url2, url);
    __privateSet(this, _processFunc, processFunc);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return __privateGet(this, _url2);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return __privateGet(this, _processFunc);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
_url2 = new WeakMap();
_processFunc = new WeakMap();
const Networks = /* @__PURE__ */ new Map();
const _Network = class _Network {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name, chainId) {
    __privateAdd(this, _name);
    __privateAdd(this, _chainId2);
    __privateAdd(this, _plugins);
    __privateSet(this, _name, name);
    __privateSet(this, _chainId2, getBigInt(chainId));
    __privateSet(this, _plugins, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return __privateGet(this, _name);
  }
  set name(value) {
    __privateSet(this, _name, value);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return __privateGet(this, _chainId2);
  }
  set chainId(value) {
    __privateSet(this, _chainId2, getBigInt(value, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins).set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name) {
    return __privateGet(this, _plugins).get(name) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename) {
    return this.plugins.filter((p) => p.name.split("#")[0] === basename);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new _Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i = 2; i < tx.data.length; i += 2) {
        if (tx.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return _Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new _Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom = new _Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
};
_name = new WeakMap();
_chainId2 = new WeakMap();
_plugins = new WeakMap();
let Network = _Network;
function parseUnits(_value2, decimals) {
  const value = String(_value2);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
    }
  });
}
let injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin());
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}
function copy$2(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class PollingBlockSubscriber {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _PollingBlockSubscriber_instances);
    __privateAdd(this, _provider);
    __privateAdd(this, _poller);
    __privateAdd(this, _interval);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber);
    __privateSet(this, _provider, provider);
    __privateSet(this, _poller, null);
    __privateSet(this, _interval, 4e3);
    __privateSet(this, _blockNumber, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return __privateGet(this, _interval);
  }
  set pollingInterval(value) {
    __privateSet(this, _interval, value);
  }
  start() {
    if (__privateGet(this, _poller)) {
      return;
    }
    __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
    __privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).call(this);
  }
  stop() {
    if (!__privateGet(this, _poller)) {
      return;
    }
    __privateGet(this, _provider)._clearTimeout(__privateGet(this, _poller));
    __privateSet(this, _poller, null);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider = new WeakMap();
_poller = new WeakMap();
_interval = new WeakMap();
_blockNumber = new WeakMap();
_PollingBlockSubscriber_instances = new WeakSet();
poll_fn = async function() {
  try {
    const blockNumber = await __privateGet(this, _provider).getBlockNumber();
    if (__privateGet(this, _blockNumber) === -2) {
      __privateSet(this, _blockNumber, blockNumber);
      return;
    }
    if (blockNumber !== __privateGet(this, _blockNumber)) {
      for (let b2 = __privateGet(this, _blockNumber) + 1; b2 <= blockNumber; b2++) {
        if (__privateGet(this, _poller) == null) {
          return;
        }
        await __privateGet(this, _provider).emit("block", b2);
      }
      __privateSet(this, _blockNumber, blockNumber);
    }
  } catch (error) {
  }
  if (__privateGet(this, _poller) == null) {
    return;
  }
  __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
};
class OnBlockSubscriber {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _provider2);
    __privateAdd(this, _poll);
    __privateAdd(this, _running);
    __privateSet(this, _provider2, provider);
    __privateSet(this, _running, false);
    __privateSet(this, _poll, (blockNumber) => {
      this._poll(blockNumber, __privateGet(this, _provider2));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, true);
    __privateGet(this, _poll).call(this, -2);
    __privateGet(this, _provider2).on("block", __privateGet(this, _poll));
  }
  stop() {
    if (!__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, false);
    __privateGet(this, _provider2).off("block", __privateGet(this, _poll));
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
_provider2 = new WeakMap();
_poll = new WeakMap();
_running = new WeakMap();
class PollingBlockTagSubscriber extends OnBlockSubscriber {
  constructor(provider, tag) {
    super(provider);
    __privateAdd(this, _tag);
    __privateAdd(this, _lastBlock);
    __privateSet(this, _tag, tag);
    __privateSet(this, _lastBlock, -2);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateSet(this, _lastBlock, -2);
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider) {
    const block = await provider.getBlock(__privateGet(this, _tag));
    if (block == null) {
      return;
    }
    if (__privateGet(this, _lastBlock) === -2) {
      __privateSet(this, _lastBlock, block.number);
    } else if (block.number > __privateGet(this, _lastBlock)) {
      provider.emit(__privateGet(this, _tag), block.number);
      __privateSet(this, _lastBlock, block.number);
    }
  }
}
_tag = new WeakMap();
_lastBlock = new WeakMap();
class PollingOrphanSubscriber extends OnBlockSubscriber {
  constructor(provider, filter) {
    super(provider);
    __privateAdd(this, _filter2);
    __privateSet(this, _filter2, copy$2(filter));
  }
  async _poll(blockNumber, provider) {
    throw new Error("@TODO");
  }
}
_filter2 = new WeakMap();
class PollingTransactionSubscriber extends OnBlockSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider, hash2) {
    super(provider);
    __privateAdd(this, _hash);
    __privateSet(this, _hash, hash2);
  }
  async _poll(blockNumber, provider) {
    const tx = await provider.getTransactionReceipt(__privateGet(this, _hash));
    if (tx) {
      provider.emit(__privateGet(this, _hash), tx);
    }
  }
}
_hash = new WeakMap();
class PollingEventSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider, filter) {
    __privateAdd(this, _PollingEventSubscriber_instances);
    __privateAdd(this, _provider3);
    __privateAdd(this, _filter3);
    __privateAdd(this, _poller2);
    __privateAdd(this, _running2);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber2);
    __privateSet(this, _provider3, provider);
    __privateSet(this, _filter3, copy$2(filter));
    __privateSet(this, _poller2, __privateMethod(this, _PollingEventSubscriber_instances, poll_fn2).bind(this));
    __privateSet(this, _running2, false);
    __privateSet(this, _blockNumber2, -2);
  }
  start() {
    if (__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, true);
    if (__privateGet(this, _blockNumber2) === -2) {
      __privateGet(this, _provider3).getBlockNumber().then((blockNumber) => {
        __privateSet(this, _blockNumber2, blockNumber);
      });
    }
    __privateGet(this, _provider3).on("block", __privateGet(this, _poller2));
  }
  stop() {
    if (!__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, false);
    __privateGet(this, _provider3).off("block", __privateGet(this, _poller2));
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber2, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider3 = new WeakMap();
_filter3 = new WeakMap();
_poller2 = new WeakMap();
_running2 = new WeakMap();
_blockNumber2 = new WeakMap();
_PollingEventSubscriber_instances = new WeakSet();
poll_fn2 = async function(blockNumber) {
  if (__privateGet(this, _blockNumber2) === -2) {
    return;
  }
  const filter = copy$2(__privateGet(this, _filter3));
  filter.fromBlock = __privateGet(this, _blockNumber2) + 1;
  filter.toBlock = blockNumber;
  const logs = await __privateGet(this, _provider3).getLogs(filter);
  if (logs.length === 0) {
    if (__privateGet(this, _blockNumber2) < blockNumber - 60) {
      __privateSet(this, _blockNumber2, blockNumber - 60);
    }
    return;
  }
  for (const log of logs) {
    __privateGet(this, _provider3).emit(__privateGet(this, _filter3), log);
    __privateSet(this, _blockNumber2, log.blockNumber);
  }
};
const BN_2 = BigInt(2);
const MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k, v) => {
    if (v == null) {
      return "null";
    }
    if (typeof v === "bigint") {
      return `bigint:${v.toString()}`;
    }
    if (typeof v === "string") {
      return v.toLowerCase();
    }
    if (typeof v === "object" && !Array.isArray(v)) {
      const keys = Object.keys(v);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v[key];
        return accum;
      }, {});
    }
    return v;
  });
}
class UnmanagedSubscriber {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name) {
    /**
     *  The name fof the event.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
}
function copy$1(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event2, provider) {
  if (_event2 == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event2)) {
    _event2 = { topics: _event2 };
  }
  if (typeof _event2 === "string") {
    switch (_event2) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event2, tag: _event2 };
      }
    }
  }
  if (isHexString(_event2, 32)) {
    const hash2 = _event2.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash: hash2 }), hash: hash2 };
  }
  if (_event2.orphan) {
    const event = _event2;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy$1(event) };
  }
  if (_event2.address || _event2.topics) {
    const event = _event2;
    const filter = {
      topics: (event.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter.address = concisify(addresses.map((a) => a.toLowerCase()));
    }
    return { filter, tag: getTag("event", filter), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event2);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const defaultOptions$1 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class AbstractProvider {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network3, options) {
    __privateAdd(this, _AbstractProvider_instances);
    __privateAdd(this, _subs);
    __privateAdd(this, _plugins2);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    __privateAdd(this, _pausedState);
    __privateAdd(this, _destroyed);
    __privateAdd(this, _networkPromise);
    __privateAdd(this, _anyNetwork);
    __privateAdd(this, _performCache);
    // The most recent block number if running an event or -1 if no "block" event
    __privateAdd(this, _lastBlockNumber);
    __privateAdd(this, _nextTimer);
    __privateAdd(this, _timers);
    __privateAdd(this, _disableCcipRead);
    __privateAdd(this, _options2);
    __privateSet(this, _options2, Object.assign({}, defaultOptions$1, options || {}));
    if (_network3 === "any") {
      __privateSet(this, _anyNetwork, true);
      __privateSet(this, _networkPromise, null);
    } else if (_network3) {
      const network = Network.from(_network3);
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, Promise.resolve(network));
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, null);
    }
    __privateSet(this, _lastBlockNumber, -1);
    __privateSet(this, _performCache, /* @__PURE__ */ new Map());
    __privateSet(this, _subs, /* @__PURE__ */ new Map());
    __privateSet(this, _plugins2, /* @__PURE__ */ new Map());
    __privateSet(this, _pausedState, null);
    __privateSet(this, _destroyed, false);
    __privateSet(this, _nextTimer, 1);
    __privateSet(this, _timers, /* @__PURE__ */ new Map());
    __privateSet(this, _disableCcipRead, false);
  }
  get pollingInterval() {
    return __privateGet(this, _options2).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins2).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins2).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins2).set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name) {
    return __privateGet(this, _plugins2).get(name) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return __privateGet(this, _disableCcipRead);
  }
  set disableCcipRead(value) {
    __privateSet(this, _disableCcipRead, !!value);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data = calldata.toLowerCase();
    const errorMessages = [];
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const href = url.replace("{sender}", sender).replace("{data}", data);
      const request = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request.body = { data, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
      let errorMessage = "unknown error";
      let resp;
      try {
        resp = await request.send();
      } catch (error) {
        errorMessages.push(error.message);
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error } });
        continue;
      }
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
      } catch (error) {
      }
      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network) {
    return new Block(formatBlock(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network) {
    return new Log(formatLog(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getBlockNumber" }), "%response");
    if (__privateGet(this, _lastBlockNumber) >= 0) {
      __privateSet(this, _lastBlockNumber, blockNumber);
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (__privateGet(this, _lastBlockNumber) >= 0) {
        return toQuantity(__privateGet(this, _lastBlockNumber) + blockTag);
      }
      return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        return concisify(t.map((t2) => t2.toLowerCase()));
      }
      return t.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a) => typeof a !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request2) {
    const request = copyRequest(_request2);
    const promises = [];
    ["to", "from"].forEach((key) => {
      if (request[key] == null) {
        return;
      }
      const addr = resolveAddress(request[key], this);
      if (isPromise(addr)) {
        promises.push(async function() {
          request[key] = await addr;
        }());
      } else {
        request[key] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise(blockTag)) {
        promises.push(async function() {
          request.blockTag = await blockTag;
        }());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return async function() {
        await Promise.all(promises);
        return request;
      }();
    }
    return request;
  }
  async getNetwork() {
    if (__privateGet(this, _networkPromise) == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error) {
          if (__privateGet(this, _networkPromise) === detectNetwork) {
            __privateSet(this, _networkPromise, null);
          }
          throw error;
        }
      })();
      __privateSet(this, _networkPromise, detectNetwork);
      return (await detectNetwork).clone();
    }
    const networkPromise = __privateGet(this, _networkPromise);
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (__privateGet(this, _anyNetwork)) {
        this.emit("network", actual, expected);
        if (__privateGet(this, _networkPromise) === networkPromise) {
          __privateSet(this, _networkPromise, Promise.resolve(actual));
        }
      } else {
        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties({
        _block: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, "latest", false),
        gasPrice: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getGasPrice" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getPriorityFee" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise(tx)) {
      tx = await tx;
    }
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  async getBalance(address, blockTag) {
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash2, network } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash2) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  // Queries
  async getBlock(block, prefetchTxs) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash2) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash2) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionReceipt", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash2 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash2) {
    const { result } = await resolveProperties({
      network: this.getNetwork(),
      result: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionResult", hash: hash2 })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  // Bloom-filter Queries
  async getLogs(_filter4) {
    let filter = this._getFilter(_filter4);
    if (isPromise(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getLogs", filter })
    });
    return params.map((p) => this._wrapLog(p, network));
  }
  // ENS
  _getProvider(chainId) {
    assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress(address);
    const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check = await this.resolveName(name);
      if (check !== address) {
        return null;
      }
      return name;
    } catch (error) {
      if (isError(error, "BAD_DATA") && error.value === "0x") {
        return null;
      }
      if (isError(error, "CALL_EXCEPTION")) {
        return null;
      }
      throw error;
    }
    return null;
  }
  async waitForTransaction(hash2, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash2);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash2);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error) {
          console.log("EEE", error);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = __privateGet(this, _timers).get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    __privateGet(this, _timers).delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = __privateWrapper(this, _nextTimer)._++;
    const func = () => {
      __privateGet(this, _timers).delete(timerId);
      _func();
    };
    if (this.paused) {
      __privateGet(this, _timers).set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      __privateGet(this, _timers).set(timerId, { timer, func, time: getTime() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub of __privateGet(this, _subs).values()) {
      func(sub.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub.type);
      case "event":
        return new PollingEventSubscriber(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of __privateGet(this, _subs).values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (__privateGet(this, _pausedState) != null) {
          newSub.pause(__privateGet(this, _pausedState));
        }
        break;
      }
    }
  }
  async on(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event, args);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once }) => {
      const payload = new EventPayload(this, once ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error) {
      }
      return !once;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners } of __privateGet(this, _subs).values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners } of __privateGet(this, _subs).values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
      if (started) {
        subscriber.stop();
      }
      __privateGet(this, _subs).delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of __privateGet(this, _subs)) {
        if (started) {
          subscriber.stop();
        }
        __privateGet(this, _subs).delete(tag);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return __privateGet(this, _destroyed);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of __privateGet(this, _timers).keys()) {
      this._clearTimeout(timerId);
    }
    __privateSet(this, _destroyed, true);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return __privateGet(this, _pausedState) != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    __privateSet(this, _lastBlockNumber, -1);
    if (__privateGet(this, _pausedState) != null) {
      if (__privateGet(this, _pausedState) == !!dropWhilePaused) {
        return;
      }
      assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s) => s.pause(dropWhilePaused));
    __privateSet(this, _pausedState, !!dropWhilePaused);
    for (const timer of __privateGet(this, _timers).values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (__privateGet(this, _pausedState) == null) {
      return;
    }
    this._forEachSubscriber((s) => s.resume());
    __privateSet(this, _pausedState, null);
    for (const timer of __privateGet(this, _timers).values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime();
      setTimeout(timer.func, timeout);
    }
  }
}
_subs = new WeakMap();
_plugins2 = new WeakMap();
_pausedState = new WeakMap();
_destroyed = new WeakMap();
_networkPromise = new WeakMap();
_anyNetwork = new WeakMap();
_performCache = new WeakMap();
_lastBlockNumber = new WeakMap();
_nextTimer = new WeakMap();
_timers = new WeakMap();
_disableCcipRead = new WeakMap();
_options2 = new WeakMap();
_AbstractProvider_instances = new WeakSet();
perform_fn = async function(req) {
  const timeout = __privateGet(this, _options2).cacheTimeout;
  if (timeout < 0) {
    return await this._perform(req);
  }
  const tag = getTag(req.method, req);
  let perform = __privateGet(this, _performCache).get(tag);
  if (!perform) {
    perform = this._perform(req);
    __privateGet(this, _performCache).set(tag, perform);
    setTimeout(() => {
      if (__privateGet(this, _performCache).get(tag) === perform) {
        __privateGet(this, _performCache).delete(tag);
      }
    }, timeout);
  }
  return await perform;
};
call_fn = async function(tx, blockTag, attempt) {
  assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
  });
  const transaction = copyRequest(tx);
  try {
    return hexlify(await this._perform({ method: "call", transaction, blockTag }));
  } catch (error) {
    if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
      const data = error.data;
      const txSender = await resolveAddress(transaction.to, this);
      let ccipArgs;
      try {
        ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
      } catch (error2) {
        assert(false, error2.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction,
          info: { data }
        });
      }
      assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data,
        reason: "OffchainLookup",
        transaction,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: ccipArgs.errorArgs
        }
      });
      const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
      assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction,
        info: { data: error.data, errorArgs: ccipArgs.errorArgs }
      });
      const tx2 = {
        to: txSender,
        data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
      try {
        const result = await __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx2, blockTag, attempt + 1);
        this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
        return result;
      } catch (error2) {
        this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
        throw error2;
      }
    }
    throw error;
  }
};
checkNetwork_fn = async function(promise) {
  const { value } = await resolveProperties({
    network: this.getNetwork(),
    value: promise
  });
  return value;
};
getAccountValue_fn = async function(request, _address, _blockTag) {
  let address = this._getAddress(_address);
  let blockTag = this._getBlockTag(_blockTag);
  if (typeof address !== "string" || typeof blockTag !== "string") {
    [address, blockTag] = await Promise.all([address, blockTag]);
  }
  return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, Object.assign(request, { address, blockTag })));
};
getBlock_fn = async function(block, includeTransactions) {
  if (isHexString(block, 32)) {
    return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "getBlock",
      blockHash: block,
      includeTransactions
    });
  }
  let blockTag = this._getBlockTag(block);
  if (typeof blockTag !== "string") {
    blockTag = await blockTag;
  }
  return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
    method: "getBlock",
    blockTag,
    includeTransactions
  });
};
hasSub_fn = async function(event, emitArgs) {
  let sub = await getSubscription(event, this);
  if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
    sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
  }
  return __privateGet(this, _subs).get(sub.tag) || null;
};
getSub_fn = async function(event) {
  const subscription = await getSubscription(event, this);
  const tag = subscription.tag;
  let sub = __privateGet(this, _subs).get(tag);
  if (!sub) {
    const subscriber = this._getSubscriber(subscription);
    const addressableMap = /* @__PURE__ */ new WeakMap();
    const nameMap = /* @__PURE__ */ new Map();
    sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
    __privateGet(this, _subs).set(tag, sub);
  }
  return sub;
};
function _parseString(result, start) {
  try {
    const bytes2 = _parseBytes(result, start);
    if (bytes2) {
      return toUtf8String(bytes2);
    }
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error) {
  }
  return null;
}
function numPad(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
const empty = new Uint8Array([]);
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data = getBytes(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return concat(result);
}
const zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data, 0, 32);
  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data, 32, 64));
    const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data, urlsOffset + 32);
    for (let u = 0; u < urlsLength; u++) {
      const url = _parseString(urlsData, u * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data, 96, 100);
  try {
    const extraData = _parseBytes(data, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
  return result;
}
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}
class AbstractSigner {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    /**
     *  The provider this signer is connected to.
     */
    __publicField(this, "provider");
    defineProperties(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          if (pop.authorizationList && pop.authorizationList.length) {
            pop.type = 4;
          } else {
            pop.type = 2;
          }
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async populateAuthorization(_auth) {
    const auth = Object.assign({}, _auth);
    if (auth.chainId == null) {
      auth.chainId = (await checkProvider(this, "getNetwork").getNetwork()).chainId;
    }
    if (auth.nonce == null) {
      auth.nonce = await this.getNonce();
    }
    return auth;
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
  // @TODO: in v7 move this to be abstract
  authorize(authorization) {
    assert(false, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
  }
}
const _VoidSigner = class _VoidSigner extends AbstractSigner {
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  constructor(address, provider) {
    super(provider);
    __privateAdd(this, _VoidSigner_instances);
    /**
     *  The signer address.
     */
    __publicField(this, "address");
    defineProperties(this, { address });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _VoidSigner(this.address, provider);
  }
  async signTransaction(tx) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "transactions", "signTransaction");
  }
  async signMessage(message) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "messages", "signMessage");
  }
  async signTypedData(domain, types, value) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "typed-data", "signTypedData");
  }
};
_VoidSigner_instances = new WeakSet();
throwUnsupported_fn = function(suffix, operation) {
  assert(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
};
let VoidSigner = _VoidSigner;
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _FilterIdSubscriber_instances);
    __privateAdd(this, _provider4);
    __privateAdd(this, _filterIdPromise);
    __privateAdd(this, _poller3);
    __privateAdd(this, _running3);
    __privateAdd(this, _network);
    __privateAdd(this, _hault);
    __privateSet(this, _provider4, provider);
    __privateSet(this, _filterIdPromise, null);
    __privateSet(this, _poller3, __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).bind(this));
    __privateSet(this, _running3, false);
    __privateSet(this, _network, null);
    __privateSet(this, _hault, false);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider, result) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider) {
    throw new Error("subclasses must override this");
  }
  start() {
    if (__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, true);
    __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).call(this, -2);
  }
  stop() {
    if (!__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, false);
    __privateSet(this, _hault, true);
    __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    }
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  resume() {
    this.start();
  }
}
_provider4 = new WeakMap();
_filterIdPromise = new WeakMap();
_poller3 = new WeakMap();
_running3 = new WeakMap();
_network = new WeakMap();
_hault = new WeakMap();
_FilterIdSubscriber_instances = new WeakSet();
poll_fn3 = async function(blockNumber) {
  try {
    if (__privateGet(this, _filterIdPromise) == null) {
      __privateSet(this, _filterIdPromise, this._subscribe(__privateGet(this, _provider4)));
    }
    let filterId = null;
    try {
      filterId = await __privateGet(this, _filterIdPromise);
    } catch (error) {
      if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
        throw error;
      }
    }
    if (filterId == null) {
      __privateSet(this, _filterIdPromise, null);
      __privateGet(this, _provider4)._recoverSubscriber(this, this._recover(__privateGet(this, _provider4)));
      return;
    }
    const network = await __privateGet(this, _provider4).getNetwork();
    if (!__privateGet(this, _network)) {
      __privateSet(this, _network, network);
    }
    if (__privateGet(this, _network).chainId !== network.chainId) {
      throw new Error("chaid changed");
    }
    if (__privateGet(this, _hault)) {
      return;
    }
    const result = await __privateGet(this, _provider4).send("eth_getFilterChanges", [filterId]);
    await this._emitResults(__privateGet(this, _provider4), result);
  } catch (error) {
    console.log("@TODO", error);
  }
  __privateGet(this, _provider4).once("block", __privateGet(this, _poller3));
};
teardown_fn = function() {
  const filterIdPromise = __privateGet(this, _filterIdPromise);
  if (filterIdPromise) {
    __privateSet(this, _filterIdPromise, null);
    filterIdPromise.then((filterId) => {
      if (__privateGet(this, _provider4).destroyed) {
        return;
      }
      __privateGet(this, _provider4).send("eth_uninstallFilter", [filterId]);
    });
  }
};
class FilterIdEventSubscriber extends FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider, filter) {
    super(provider);
    __privateAdd(this, _event);
    __privateSet(this, _event, copy(filter));
  }
  _recover(provider) {
    return new PollingEventSubscriber(provider, __privateGet(this, _event));
  }
  async _subscribe(provider) {
    const filterId = await provider.send("eth_newFilter", [__privateGet(this, _event)]);
    return filterId;
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit(__privateGet(this, _event), provider._wrapLog(result, provider._network));
    }
  }
}
_event = new WeakMap();
class FilterIdPendingSubscriber extends FilterIdSubscriber {
  async _subscribe(provider) {
    return await provider.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit("pending", result);
    }
  }
}
const Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall$2(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
const defaultOptions = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class JsonRpcSigner extends AbstractSigner {
  constructor(provider, address) {
    super(provider);
    __publicField(this, "address");
    address = getAddress(address);
    defineProperties(this, { address });
  }
  connect(provider) {
    assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises = [];
    if (tx.from) {
      const _from = tx.from;
      promises.push((async () => {
        const from = await resolveAddress(_from, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to2 = tx.to;
      promises.push((async () => {
        tx.to = await resolveAddress(_to2, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash2 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash2);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error) {
          if (isError(error, "CANCELLED") || isError(error, "BAD_DATA") || isError(error, "NETWORK_ERROR") || isError(error, "UNSUPPORTED_OPERATION")) {
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash2;
            reject(error);
            return;
          }
          if (isError(error, "INVALID_ARGUMENT")) {
            invalids++;
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash2;
            if (invalids > 10) {
              reject(error);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from = await resolveAddress(tx.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain, types, _value2) {
    const value = deepCopy(_value2);
    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value2) => {
      const address = await resolveAddress(value2);
      assertArgument(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
}
class JsonRpcApiProvider extends AbstractProvider {
  constructor(network, options) {
    super(network, options);
    __privateAdd(this, _JsonRpcApiProvider_instances);
    __privateAdd(this, _options3);
    // The next ID to use for the JSON-RPC ID field
    __privateAdd(this, _nextId);
    // Payloads are queued and triggered in batches using the drainTimer
    __privateAdd(this, _payloads);
    __privateAdd(this, _drainTimer);
    __privateAdd(this, _notReady);
    __privateAdd(this, _network2);
    __privateAdd(this, _pendingDetectNetwork);
    __privateSet(this, _nextId, 1);
    __privateSet(this, _options3, Object.assign({}, defaultOptions, options || {}));
    __privateSet(this, _payloads, []);
    __privateSet(this, _drainTimer, null);
    __privateSet(this, _network2, null);
    __privateSet(this, _pendingDetectNetwork, null);
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      __privateSet(this, _notReady, { promise, resolve });
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        __privateSet(this, _network2, Network.from(network));
      }
    } else if (staticNetwork) {
      assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      __privateSet(this, _network2, staticNetwork);
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key) {
    return __privateGet(this, _options3)[key];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert(__privateGet(this, _network2), "network is not available yet", "NETWORK_ERROR");
    return __privateGet(this, _network2);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (__privateGet(this, _network2)) {
          return __privateGet(this, _network2);
        }
      } else {
        return network;
      }
    }
    if (__privateGet(this, _pendingDetectNetwork)) {
      return await __privateGet(this, _pendingDetectNetwork);
    }
    if (this.ready) {
      __privateSet(this, _pendingDetectNetwork, (async () => {
        try {
          const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
          __privateSet(this, _pendingDetectNetwork, null);
          return result;
        } catch (error) {
          __privateSet(this, _pendingDetectNetwork, null);
          throw error;
        }
      })());
      return await __privateGet(this, _pendingDetectNetwork);
    }
    __privateSet(this, _pendingDetectNetwork, (async () => {
      const payload = {
        id: __privateWrapper(this, _nextId)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        __privateSet(this, _pendingDetectNetwork, null);
      } catch (error) {
        __privateSet(this, _pendingDetectNetwork, null);
        this.emit("debug", { action: "receiveRpcError", error });
        throw error;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network.from(getBigInt(result.result));
      }
      throw this.getRpcError(payload, result);
    })());
    return await __privateGet(this, _pendingDetectNetwork);
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (__privateGet(this, _notReady) == null || __privateGet(this, _notReady).resolve == null) {
      return;
    }
    __privateGet(this, _notReady).resolve();
    __privateSet(this, _notReady, null);
    (async () => {
      while (__privateGet(this, _network2) == null && !this.destroyed) {
        try {
          __privateSet(this, _network2, await this._detectNetwork());
        } catch (error) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
          await stall$2(1e3);
        }
      }
      __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (__privateGet(this, _notReady) == null) {
      return;
    }
    return await __privateGet(this, _notReady).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub.filter);
      }
      return new FilterIdEventSubscriber(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return __privateGet(this, _notReady) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result[key] = hexlify(tx[key]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h) => h.toLowerCase());
    }
    if (tx.authorizationList) {
      result["authorizationList"] = tx.authorizationList.map((_a2) => {
        const a = authorizationify(_a2);
        return {
          address: a.address,
          nonce: toQuantity(a.nonce),
          chainId: toQuantity(a.chainId),
          yParity: toQuantity(a.signature.yParity),
          r: toQuantity(a.signature.r),
          s: toQuantity(a.signature.s)
        };
      });
    }
    return result;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error2) {
    const { method } = payload;
    const { error } = _error2;
    if (method === "eth_estimateGas" && error.message) {
      const msg = error.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      } else if (msg.match(/nonce/i) && msg.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error);
      const e = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e.info = { error, payload };
      return e;
    }
    const message = JSON.stringify(spelunkMessage(error));
    if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error && error.details && error.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id2 = __privateWrapper(this, _nextId)._++;
    const promise = new Promise((resolve, reject) => {
      __privateGet(this, _payloads).push({
        resolve,
        reject,
        payload: { method, params, id: id2, jsonrpc: "2.0" }
      });
    });
    __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress(address);
    for (const account of accounts) {
      if (getAddress(account) === address) {
        return new JsonRpcSigner(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a) => new JsonRpcSigner(this, a));
  }
  destroy() {
    if (__privateGet(this, _drainTimer)) {
      clearTimeout(__privateGet(this, _drainTimer));
      __privateSet(this, _drainTimer, null);
    }
    for (const { payload, reject } of __privateGet(this, _payloads)) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    __privateSet(this, _payloads, []);
    super.destroy();
  }
}
_options3 = new WeakMap();
_nextId = new WeakMap();
_payloads = new WeakMap();
_drainTimer = new WeakMap();
_notReady = new WeakMap();
_network2 = new WeakMap();
_pendingDetectNetwork = new WeakMap();
_JsonRpcApiProvider_instances = new WeakSet();
scheduleDrain_fn = function() {
  if (__privateGet(this, _drainTimer)) {
    return;
  }
  const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  __privateSet(this, _drainTimer, setTimeout(() => {
    __privateSet(this, _drainTimer, null);
    const payloads = __privateGet(this, _payloads);
    __privateSet(this, _payloads, []);
    while (payloads.length) {
      const batch = [payloads.shift()];
      while (payloads.length) {
        if (batch.length === __privateGet(this, _options3).batchMaxCount) {
          break;
        }
        batch.push(payloads.shift());
        const bytes2 = JSON.stringify(batch.map((p) => p.payload));
        if (bytes2.length > __privateGet(this, _options3).batchMaxSize) {
          payloads.unshift(batch.pop());
          break;
        }
      }
      (async () => {
        const payload = batch.length === 1 ? batch[0].payload : batch.map((p) => p.payload);
        this.emit("debug", { action: "sendRpcPayload", payload });
        try {
          const result = await this._send(payload);
          this.emit("debug", { action: "receiveRpcResult", result });
          for (const { resolve, reject, payload: payload2 } of batch) {
            if (this.destroyed) {
              reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
              continue;
            }
            const resp = result.filter((r) => r.id === payload2.id)[0];
            if (resp == null) {
              const error = makeError("missing response for request", "BAD_DATA", {
                value: result,
                info: { payload: payload2 }
              });
              this.emit("error", error);
              reject(error);
              continue;
            }
            if ("error" in resp) {
              reject(this.getRpcError(payload2, resp));
              continue;
            }
            resolve(resp.result);
          }
        } catch (error) {
          this.emit("debug", { action: "receiveRpcError", error });
          for (const { reject } of batch) {
            reject(error);
          }
        }
      })();
    }
  }, stallTime));
};
class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
  constructor(network, options) {
    super(network, options);
    __privateAdd(this, _pollingInterval);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions.pollingInterval;
    }
    __privateSet(this, _pollingInterval, pollingInterval);
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = __privateGet(this, _pollingInterval);
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return __privateGet(this, _pollingInterval);
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    __privateSet(this, _pollingInterval, value);
    this._forEachSubscriber((sub) => {
      if (isPollable(sub)) {
        sub.pollingInterval = __privateGet(this, _pollingInterval);
      }
    });
  }
}
_pollingInterval = new WeakMap();
class JsonRpcProvider extends JsonRpcApiPollingProvider {
  constructor(url, network, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network, options);
    __privateAdd(this, _connect);
    if (typeof url === "string") {
      __privateSet(this, _connect, new FetchRequest(url));
    } else {
      __privateSet(this, _connect, url.clone());
    }
  }
  _getConnection() {
    return __privateGet(this, _connect).clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
}
_connect = new WeakMap();
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunkData(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {
    }
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage(value[key], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {
    }
  }
}
function spelunkMessage(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
}
const _BaseWallet = class _BaseWallet extends AbstractSigner {
  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  constructor(privateKey, provider) {
    super(provider);
    /**
     *  The wallet address.
     */
    __publicField(this, "address");
    __privateAdd(this, _signingKey);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    __privateSet(this, _signingKey, privateKey);
    const address = computeAddress(this.signingKey.publicKey);
    defineProperties(this, { address });
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  get signingKey() {
    return __privateGet(this, _signingKey);
  }
  /**
   *  The private key for this wallet.
   */
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _BaseWallet(__privateGet(this, _signingKey), provider);
  }
  async signTransaction(tx) {
    tx = copyRequest(tx);
    const { to, from } = await resolveProperties({
      to: tx.to ? resolveAddress(tx.to, this) : void 0,
      from: tx.from ? resolveAddress(tx.from, this) : void 0
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  // @TODO: Add a secialized signTx and signTyped sync that enforces
  // all parameters are known?
  /**
   *  Returns the signature for %%message%% signed with this wallet.
   */
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage(message)).serialized;
  }
  /**
   *  Returns the Authorization for %%auth%%.
   */
  authorizeSync(auth) {
    assertArgument(typeof auth.address === "string", "invalid address for authorizeSync", "auth.address", auth);
    const signature = this.signingKey.sign(hashAuthorization(auth));
    return Object.assign({}, {
      address: getAddress(auth.address),
      nonce: getBigInt(auth.nonce || 0),
      chainId: getBigInt(auth.chainId || 0)
    }, { signature });
  }
  /**
   *  Resolves to the Authorization for %%auth%%.
   */
  async authorize(auth) {
    auth = Object.assign({}, auth, {
      address: await resolveAddress(auth.address, this)
    });
    return this.authorizeSync(await this.populateAuthorization(auth));
  }
  async signTypedData(domain, types, value) {
    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name) => {
      assert(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name }
      });
      const address = await this.provider.resolveName(name);
      assert(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name
      });
      return address;
    });
    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;
  }
};
_signingKey = new WeakMap();
let BaseWallet = _BaseWallet;
const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
const Word = /^[a-z]*$/i;
function unfold(words2, sep) {
  let initial = 97;
  return words2.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode(data, subs) {
  for (let i = subsChrs.length - 1; i >= 0; i--) {
    data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  const clumps = [];
  const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
    if (semi) {
      for (let i = parseInt(semi); i >= 0; i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data) {
  assertArgument(data[0] === "0", "unsupported auwl data", "data", data);
  return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}
class Wordlist {
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  constructor(locale) {
    __publicField(this, "locale");
    defineProperties(this, { locale });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  /**
   *  Sub-classes may override this to provider a language-specific
   *  method for joining %%words%% into a phrase.
   *
   *  By default, %%words%% are joined by a single space.
   */
  join(words2) {
    return words2.join(" ");
  }
}
class WordlistOwl extends Wordlist {
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  constructor(locale, data, checksum2) {
    super(locale);
    __privateAdd(this, _WordlistOwl_instances);
    __privateAdd(this, _data4);
    __privateAdd(this, _checksum);
    __privateAdd(this, _words);
    __privateSet(this, _data4, data);
    __privateSet(this, _checksum, checksum2);
    __privateSet(this, _words, null);
  }
  /**
   *  The OWL-encoded data.
   */
  get _data() {
    return __privateGet(this, _data4);
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwl(__privateGet(this, _data4));
  }
  getWord(index) {
    const words2 = __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this);
    assertArgument(index >= 0 && index < words2.length, `invalid word index: ${index}`, "index", index);
    return words2[index];
  }
  getWordIndex(word) {
    return __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this).indexOf(word);
  }
}
_data4 = new WeakMap();
_checksum = new WeakMap();
_words = new WeakMap();
_WordlistOwl_instances = new WeakSet();
loadWords_fn = function() {
  if (__privateGet(this, _words) == null) {
    const words2 = this._decodeWords();
    const checksum2 = id(words2.join("\n") + "\n");
    if (checksum2 !== __privateGet(this, _checksum)) {
      throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
    }
    __privateSet(this, _words, words2);
  }
  return __privateGet(this, _words);
};
const words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
const checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
let wordlist = null;
class LangEn extends WordlistOwl {
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("en", words, checksum);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist == null) {
      wordlist = new LangEn();
    }
    return wordlist;
  }
}
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits & 255;
}
function getLowerMask(bits) {
  return (1 << bits) - 1 & 255;
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  assertNormalize("NFKD");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const words2 = wordlist2.split(mnemonic);
  assertArgument(words2.length % 3 === 0 && words2.length >= 12 && words2.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words2.length / 8));
  let offset = 0;
  for (let i = 0; i < words2.length; i++) {
    let index = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
const _guard$1 = {};
class Mnemonic {
  /**
   *  @private
   */
  constructor(guard, entropy, phrase, password, wordlist2) {
    /**
     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
     *
     *  Use the [[wordlist]] ``split`` method to get the individual words.
     */
    __publicField(this, "phrase");
    /**
     *  The password used for this mnemonic. If no password is used this
     *  is the empty string (i.e. ``""``) as per the specification.
     */
    __publicField(this, "password");
    /**
     *  The wordlist for this mnemonic.
     */
    __publicField(this, "wordlist");
    /**
     *  The underlying entropy which the mnemonic encodes.
     */
    __publicField(this, "entropy");
    if (password == null) {
      password = "";
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    assertPrivate(guard, _guard$1, "Mnemonic");
    defineProperties(this, { phrase, password, wordlist: wordlist2, entropy });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf2(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  /**
   *  Creates a new Mnemonic for the %%phrase%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromPhrase(phrase, password, wordlist2) {
    const entropy = mnemonicToEntropy(phrase, wordlist2);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist2);
    return new Mnemonic(_guard$1, entropy, phrase, password, wordlist2);
  }
  /**
   *  Create a new **Mnemonic** from the %%entropy%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromEntropy(_entropy, password, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist2);
    return new Mnemonic(_guard$1, hexlify(entropy), phrase, password, wordlist2);
  }
  /**
   *  Returns the phrase for %%mnemonic%%.
   */
  static entropyToPhrase(_entropy, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist2);
  }
  /**
   *  Returns the entropy for %%phrase%%.
   */
  static phraseToEntropy(phrase, wordlist2) {
    return mnemonicToEntropy(phrase, wordlist2);
  }
  /**
   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
   *
   *  This checks all the provided words belong to the %%wordlist%%,
   *  that the length is valid and the checksum is correct.
   */
  static isValidMnemonic(phrase, wordlist2) {
    try {
      mnemonicToEntropy(phrase, wordlist2);
      return true;
    } catch (error) {
    }
    return false;
  }
}
/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
var __classPrivateFieldGet$2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet$2 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AES_key, _AES_Kd, _AES_Ke;
const numberOfRounds = { 16: 10, 24: 12, 32: 14 };
const rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
const S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
const Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
const T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
const T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
const T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
const T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
const T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
const T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
const T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
const T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
const U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
const U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
const U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
const U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function convertToInt32(bytes2) {
  const result = [];
  for (let i = 0; i < bytes2.length; i += 4) {
    result.push(bytes2[i] << 24 | bytes2[i + 1] << 16 | bytes2[i + 2] << 8 | bytes2[i + 3]);
  }
  return result;
}
class AES {
  get key() {
    return __classPrivateFieldGet$2(this, _AES_key, "f").slice();
  }
  constructor(key) {
    _AES_key.set(this, void 0);
    _AES_Kd.set(this, void 0);
    _AES_Ke.set(this, void 0);
    if (!(this instanceof AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet$2(this, _AES_key, new Uint8Array(key), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet$2(this, _AES_Ke, [], "f");
    __classPrivateFieldSet$2(this, _AES_Kd, [], "f");
    for (let i = 0; i <= rounds; i++) {
      __classPrivateFieldGet$2(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet$2(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk = convertToInt32(this.key);
    let index;
    for (let i = 0; i < KC; i++) {
      index = i >> 2;
      __classPrivateFieldGet$2(this, _AES_Ke, "f")[index][i % 4] = tk[i];
      __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
    }
    let rconpointer = 0;
    let t = KC, tt;
    while (t < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i2 = 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      } else {
        for (let i2 = 1; i2 < KC / 2; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i2 = KC / 2 + 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      }
      let i = 0, r, c;
      while (i < KC && t < roundKeyCount) {
        r = t >> 2;
        c = t % 4;
        __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][c] = tk[i];
        __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - r][c] = tk[i++];
        t++;
      }
    }
    for (let r = 1; r < rounds; r++) {
      for (let c = 0; c < 4; c++) {
        tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c];
        __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$2(this, _AES_Ke, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(plaintext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet$2(this, _AES_Ke, "f")[0][i];
    }
    for (let r = 1; r < rounds; r++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T1[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$2(this, _AES_Ke, "f")[rounds][i];
      result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$2(this, _AES_Kd, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(ciphertext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet$2(this, _AES_Kd, "f")[0][i];
    }
    for (let r = 1; r < rounds; r++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds][i];
      result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
}
_AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();
class ModeOfOperation {
  constructor(name, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key) },
      name: { enumerable: true, value: name }
    });
  }
}
var __classPrivateFieldSet$1 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$1 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CBC_iv, _CBC_lastBlock;
class CBC extends ModeOfOperation {
  constructor(key, iv) {
    super("ECC", key, CBC);
    _CBC_iv.set(this, void 0);
    _CBC_lastBlock.set(this, void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet$1(this, _CBC_lastBlock, this.iv, "f");
  }
  get iv() {
    return new Uint8Array(__classPrivateFieldGet$1(this, _CBC_iv, "f"));
  }
  encrypt(plaintext) {
    if (plaintext.length % 16) {
      throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
    }
    const ciphertext = new Uint8Array(plaintext.length);
    for (let i = 0; i < plaintext.length; i += 16) {
      for (let j = 0; j < 16; j++) {
        __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
      }
      __classPrivateFieldSet$1(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet$1(this, _CBC_lastBlock, "f")), "f");
      ciphertext.set(__classPrivateFieldGet$1(this, _CBC_lastBlock, "f"), i);
    }
    return ciphertext;
  }
  decrypt(ciphertext) {
    if (ciphertext.length % 16) {
      throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
    }
    const plaintext = new Uint8Array(ciphertext.length);
    for (let i = 0; i < ciphertext.length; i += 16) {
      const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
      for (let j = 0; j < 16; j++) {
        plaintext[i + j] = block[j] ^ __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j];
        __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
      }
    }
    return plaintext;
  }
}
_CBC_iv = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
class CTR extends ModeOfOperation {
  constructor(key, initialValue) {
    super("CTR", key, CTR);
    _CTR_remaining.set(this, void 0);
    _CTR_remainingIndex.set(this, void 0);
    _CTR_counter.set(this, void 0);
    __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index = 15; index >= 0; --index) {
      __classPrivateFieldGet(this, _CTR_counter, "f")[index] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
  }
  increment() {
    for (let i = 15; i >= 0; i--) {
      if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
      } else {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a2, _b;
    const crypttext = new Uint8Array(plaintext);
    for (let i = 0; i < crypttext.length; i++) {
      if (__classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, "f"), _a2 = _b++, _b), "f"), _a2];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
}
_CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();
function pkcs7Strip(data) {
  if (data.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data[data.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data.length - padder;
  for (let i = 0; i < padder; i++) {
    if (data[length + i] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data.subarray(0, length));
}
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad$1(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk(object2, _path) {
  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match != null, "invalid path", "path", _path);
  const path = match[1];
  const type = match[3];
  const reqd = match[4] === "!";
  let cur = object2;
  for (const comp of path.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key in cur) {
        if (key.toLowerCase() === comp) {
          found = cur[key];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === typeof cur) {
      return cur;
    }
    assertArgument(false, `wrong type found for ${type} `, "path", path);
  }
  return cur;
}
const defaultPath$1 = "m/44'/60'/0'/0/0";
function isKeystoreJson(json) {
  try {
    const data = JSON.parse(json);
    const version2 = data.version != null ? parseInt(data.version) : 0;
    if (version2 === 3) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decrypt(data, key, ciphertext) {
  const cipher = spelunk(data, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk(data, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR(key, iv);
    return hexlify(aesCtr.decrypt(ciphertext));
  }
  assert(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount(data, _key) {
  const key = getBytes(_key);
  const ciphertext = spelunk(data, "crypto.ciphertext:data!");
  const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    assertArgument(getAddress(check) === address, "keystore address/privateKey mismatch", "address", data.address);
  }
  const account = { address, privateKey };
  const version2 = spelunk(data, "x-ethers.version:string");
  if (version2 === "0.1") {
    const mnemonicKey = key.slice(32, 64);
    const mnemonicCiphertext = spelunk(data, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk(data, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: spelunk(data, "x-ethers.path:string") || defaultPath$1,
      locale: spelunk(data, "x-ethers.locale:string") || "en",
      entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams(data) {
  const kdf = spelunk(data, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const N2 = spelunk(data, "crypto.kdfparams.n:int!");
      const r = spelunk(data, "crypto.kdfparams.r:int!");
      const p = spelunk(data, "crypto.kdfparams.p:int!");
      assertArgument(N2 > 0 && (N2 & N2 - 1) === 0, "invalid kdf.N", "kdf.N", N2);
      assertArgument(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N2, r, p, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const prf = spelunk(data, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count = spelunk(data, "crypto.kdfparams.c:int!");
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count, dkLen, algorithm };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
}
function decryptKeystoreJsonSync(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count, dkLen2, algorithm);
    return getAccount(data, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r, p, dkLen } = params;
  const key = scryptSync(password, salt, N2, r, p, dkLen);
  return getAccount(data, key);
}
function stall$1(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
async function decryptKeystoreJson(json, _password, progress) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    if (progress) {
      progress(0);
      await stall$1(0);
    }
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count, dkLen2, algorithm);
    if (progress) {
      progress(1);
      await stall$1(0);
    }
    return getAccount(data, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r, p, dkLen } = params;
  const key = await scrypt(password, salt, N2, r, p, dkLen, progress);
  return getAccount(data, key);
}
function getEncryptKdfParams(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes(32);
  let N2 = 1 << 17, r = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  assertArgument(typeof N2 === "number" && N2 > 0 && Number.isSafeInteger(N2) && (BigInt(N2) & BigInt(N2 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N2);
  assertArgument(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
  assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return { name: "scrypt", dkLen: 32, salt, N: N2, r, p };
}
function _encryptKeystore(key, kdf, account, options) {
  const privateKey = getBytes(account.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak256(concat([macPrefix, ciphertext]));
  const data = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client = options.client != null ? options.client : `ethers/${version}`;
    const path = account.mnemonic.path || defaultPath$1;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = /* @__PURE__ */ new Date();
    const timestamp = now.getUTCFullYear() + "-" + zpad$1(now.getUTCMonth() + 1, 2) + "-" + zpad$1(now.getUTCDate(), 2) + "T" + zpad$1(now.getUTCHours(), 2) + "-" + zpad$1(now.getUTCMinutes(), 2) + "-" + zpad$1(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data.address;
    data["x-ethers"] = {
      client,
      gethFilename,
      path,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data);
}
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
async function encryptKeystoreJson(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = await scrypt(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
const defaultPath = "m/44'/60'/0'/0/0";
const MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
const HardenedBit = 2147483648;
const N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const Nibbles = "0123456789abcdef";
function zpad(value, length) {
  let result = "";
  while (value) {
    result = Nibbles[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value2) {
  const value = getBytes(_value2);
  const check = dataSlice(sha256(sha256(value)), 0, 4);
  const bytes2 = concat([value, check]);
  return encodeBase58(bytes2);
}
const _guard = {};
function ser_I(index, chainCode, publicKey, privateKey) {
  const data = new Uint8Array(37);
  if (index & HardenedBit) {
    assert(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data.set(getBytes(privateKey), 1);
  } else {
    data.set(getBytes(publicKey));
  }
  for (let i = 24; i >= 0; i -= 8) {
    data[33 + (i >> 3)] = index >> 24 - i & 255;
  }
  const I = getBytes(computeHmac("sha512", chainCode, data));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath(node, path) {
  const components = path.split("/");
  assertArgument(components.length > 0, "invalid path", "path", path);
  if (components[0] === "m") {
    assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path);
    components.shift();
  }
  let result = node;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      const index = parseInt(component.substring(0, component.length - 1));
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(HardenedBit + index);
    } else if (component.match(/^[0-9]+$/)) {
      const index = parseInt(component);
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(index);
    } else {
      assertArgument(false, "invalid path component", `path[${i}]`, component);
    }
  }
  return result;
}
const _HDNodeWallet = class _HDNodeWallet extends BaseWallet {
  /**
   *  @private
   */
  constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
    super(signingKey, provider);
    __privateAdd(this, _HDNodeWallet_instances);
    /**
     *  The compressed public key.
     */
    __publicField(this, "publicKey");
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    __publicField(this, "fingerprint");
    /**
     *  The parent fingerprint.
     */
    __publicField(this, "parentFingerprint");
    /**
     *  The mnemonic used to create this HD Node, if available.
     *
     *  Sources such as extended keys do not encode the mnemonic, in
     *  which case this will be ``null``.
     */
    __publicField(this, "mnemonic");
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    __publicField(this, "chainCode");
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provide full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  encode it.
     */
    __publicField(this, "path");
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    __publicField(this, "index");
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    __publicField(this, "depth");
    assertPrivate(guard, _guard, "HDNodeWallet");
    defineProperties(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd160(sha256(this.publicKey)), 0, 4);
    defineProperties(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path,
      index,
      depth
    });
    defineProperties(this, { mnemonic });
  }
  connect(provider) {
    return new _HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    return encryptKeystoreJsonSync(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpriv`` and can be used to
   *  reconstruct this HD Node to derive its children.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488ADE4",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      concat(["0x00", this.privateKey])
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Returns a neutered HD Node, which removes the private details
   *  of an HD Node.
   *
   *  A neutered node has no private key, but can be used to derive
   *  child addresses and other public data about the HD Node.
   */
  neuter() {
    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
    const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));
    return new _HDNodeWallet(_guard, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
  }
  /**
   *  Return the HDNode for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
  /**
   *  Creates a new HD Node from %%extendedKey%%.
   *
   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
   *  or full HD Node ([[HDNodeWallet) respectively.
   */
  static fromExtendedKey(extendedKey) {
    const bytes2 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes2.length === 82 || encodeBase58Check(bytes2.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes2[4];
    const parentFingerprint = hexlify(bytes2.slice(5, 9));
    const index = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes2.slice(13, 45));
    const key = bytes2.slice(45, 78);
    switch (hexlify(bytes2.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify(key);
        return new HDNodeVoidWallet(_guard, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
      }
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new _HDNodeWallet(_guard, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  /**
   *  Creates a new random HDNode.
   */
  static createRandom(password, path, wordlist2) {
    var _a2;
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist2);
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Create an HD Node from %%mnemonic%%.
   */
  static fromMnemonic(mnemonic, path) {
    var _a2;
    if (!path) {
      path = defaultPath;
    }
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a mnemonic %%phrase%%.
   */
  static fromPhrase(phrase, password, path, wordlist2) {
    var _a2;
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist2);
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a %%seed%%.
   */
  static fromSeed(seed) {
    var _a2;
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, seed, null);
  }
};
_HDNodeWallet_instances = new WeakSet();
account_fn = function() {
  const account = { address: this.address, privateKey: this.privateKey };
  const m = this.mnemonic;
  if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
    account.mnemonic = {
      path: this.path,
      locale: "en",
      entropy: m.entropy
    };
  }
  return account;
};
_HDNodeWallet_static = new WeakSet();
fromSeed_fn = function(_seed, mnemonic) {
  assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
  const seed = getBytes(_seed, "seed");
  assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
  const I = getBytes(computeHmac("sha512", MasterSecret, seed));
  const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
  return new _HDNodeWallet(_guard, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic, null);
};
__privateAdd(_HDNodeWallet, _HDNodeWallet_static);
let HDNodeWallet = _HDNodeWallet;
class HDNodeVoidWallet extends VoidSigner {
  /**
   *  @private
   */
  constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
    super(address, provider);
    /**
     *  The compressed public key.
     */
    __publicField(this, "publicKey");
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    __publicField(this, "fingerprint");
    /**
     *  The parent node fingerprint.
     */
    __publicField(this, "parentFingerprint");
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    __publicField(this, "chainCode");
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provider full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  enocde it.
     */
    __publicField(this, "path");
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    __publicField(this, "index");
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    __publicField(this, "depth");
    assertPrivate(guard, _guard, "HDNodeVoidWallet");
    defineProperties(this, { publicKey });
    const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);
    defineProperties(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path,
      index,
      depth
    });
  }
  connect(provider) {
    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpub`` and can be used to
   *  reconstruct this neutered key to derive its children addresses.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488B21E",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
    const Ki = SigningKey.addPoints(IL, this.publicKey, true);
    const address = computeAddress(Ki);
    return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);
  }
  /**
   *  Return the signer for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
}
function getAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/${index}'/0/0`;
}
function getIndexedAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/0'/0/${index}`;
}
function isCrowdsaleJson(json) {
  try {
    const data = JSON.parse(json);
    if (data.encseed) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decryptCrowdsaleJson(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const address = getAddress(spelunk(data, "ethaddr:string!"));
  const encseed = looseArrayify(spelunk(data, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  const key = getBytes(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC(key, iv);
  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  return { address, privateKey: id(seedHex) };
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
const _Wallet = class _Wallet extends BaseWallet {
  /**
   *  Create a new wallet for the private %%key%%, optionally connected
   *  to %%provider%%.
   */
  constructor(key, provider) {
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    let signingKey = typeof key === "string" ? new SigningKey(key) : key;
    super(signingKey, provider);
  }
  connect(provider) {
    return new _Wallet(this.signingKey, provider);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    const account = { address: this.address, privateKey: this.privateKey };
    return await encryptKeystoreJson(account, password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    const account = { address: this.address, privateKey: this.privateKey };
    return encryptKeystoreJsonSync(account, password);
  }
  /**
   *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
   *  with %%password%%.
   *
   *  If %%progress%% is provided, it is called periodically during
   *  decryption so that any UI can be updated.
   */
  static async fromEncryptedJson(json, password, progress) {
    var _a2;
    let account = null;
    if (isKeystoreJson(json)) {
      account = await decryptKeystoreJson(json, password, progress);
    } else if (isCrowdsaleJson(json)) {
      if (progress) {
        progress(0);
        await stall(0);
      }
      account = decryptCrowdsaleJson(json, password);
      if (progress) {
        progress(1);
        await stall(0);
      }
    }
    return __privateMethod(_a2 = _Wallet, _Wallet_static, fromAccount_fn).call(_a2, account);
  }
  /**
   *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
   *
   *  The [[fromEncryptedJson]] method is preferred, as this method
   *  will lock up and freeze the UI during decryption, which may take
   *  some time.
   */
  static fromEncryptedJsonSync(json, password) {
    var _a2;
    let account = null;
    if (isKeystoreJson(json)) {
      account = decryptKeystoreJsonSync(json, password);
    } else if (isCrowdsaleJson(json)) {
      account = decryptCrowdsaleJson(json, password);
    } else {
      assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
    }
    return __privateMethod(_a2 = _Wallet, _Wallet_static, fromAccount_fn).call(_a2, account);
  }
  /**
   *  Creates a new random [[HDNodeWallet]] using the available
   *  [cryptographic random source](randomBytes).
   *
   *  If there is no crytographic random source, this will throw.
   */
  static createRandom(provider) {
    const wallet = HDNodeWallet.createRandom();
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
  /**
   *  Creates a [[HDNodeWallet]] for %%phrase%%.
   */
  static fromPhrase(phrase, provider) {
    const wallet = HDNodeWallet.fromPhrase(phrase);
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
};
_Wallet_static = new WeakSet();
fromAccount_fn = function(account) {
  assertArgument(account, "invalid JSON wallet", "json", "[ REDACTED ]");
  if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
    const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
    const wallet2 = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
    if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
      return wallet2;
    }
    console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
  }
  const wallet = new _Wallet(account.privateKey);
  assertArgument(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
  return wallet;
};
__privateAdd(_Wallet, _Wallet_static);
let Wallet = _Wallet;
async function save(key, data) {
  try {
    await chrome.storage.local.set({ [key]: data });
  } catch (error) {
    console.error("Error saving data:", error);
    throw new Error("Failed to save data");
  }
}
async function load(key) {
  try {
    const result = await chrome.storage.local.get(key);
    return result[key] || null;
  } catch (error) {
    console.error("Error loading data:", error);
    throw new Error("Failed to load data");
  }
}
function isValidAddress(address) {
  try {
    return isAddress(address);
  } catch {
    return false;
  }
}
function isValidMnemonic(mnemonic) {
  try {
    const cleaned = mnemonic.trim().replace(/\s+/g, " ");
    return Mnemonic.isValidMnemonic(cleaned);
  } catch {
    return false;
  }
}
function isValidPrivateKey(privateKey) {
  try {
    const key = privateKey.startsWith("0x") ? privateKey : "0x" + privateKey;
    if (!/^0x[0-9a-fA-F]{64}$/.test(key)) {
      return false;
    }
    new Wallet(key);
    return true;
  } catch {
    return false;
  }
}
function validatePasswordStrength(password) {
  const errors = [];
  if (!password || password.length < 12) {
    errors.push("Password must be at least 12 characters");
  }
  if (!/[A-Z]/.test(password)) {
    errors.push("Password must contain at least one uppercase letter");
  }
  if (!/[a-z]/.test(password)) {
    errors.push("Password must contain at least one lowercase letter");
  }
  if (!/[0-9]/.test(password)) {
    errors.push("Password must contain at least one number");
  }
  if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
    errors.push("Password must contain at least one special character (!@#$%^&*, etc.)");
  }
  return {
    valid: errors.length === 0,
    errors
  };
}
function shortenAddress(address, chars = 4) {
  if (!isValidAddress(address)) return address;
  return `${address.slice(0, chars + 2)}...${address.slice(-chars)}`;
}
const ITERATION_MILESTONES = [
  // Historical OWASP recommendations (actual data)
  { year: 2016, iterations: 1e4, source: "OWASP 2016" },
  { year: 2021, iterations: 31e4, source: "OWASP 2021" },
  { year: 2023, iterations: 6e5, source: "OWASP 2023" },
  // Projected using 35% CAGR from 2023 baseline
  { year: 2024, iterations: 81e4, source: "Projected (35% CAGR)" },
  { year: 2025, iterations: 1094e3, source: "Projected (35% CAGR)" },
  { year: 2026, iterations: 1477e3, source: "Projected (35% CAGR)" },
  { year: 2027, iterations: 1994e3, source: "Projected (35% CAGR)" },
  { year: 2028, iterations: 2692e3, source: "Projected (35% CAGR)" },
  { year: 2029, iterations: 3635e3, source: "Projected (35% CAGR)" },
  { year: 2030, iterations: 4907e3, source: "Projected (35% CAGR)" },
  { year: 2031, iterations: 5e6, source: "Capped for UX (~2sec on slow devices)" }
];
function getCurrentRecommendedIterations(year = (/* @__PURE__ */ new Date()).getFullYear()) {
  const exactMatch = ITERATION_MILESTONES.find((m) => m.year === year);
  if (exactMatch) return exactMatch.iterations;
  const before = ITERATION_MILESTONES.filter((m) => m.year < year).sort((a, b2) => b2.year - a.year)[0];
  const after = ITERATION_MILESTONES.filter((m) => m.year > year).sort((a, b2) => a.year - b2.year)[0];
  if (!before) return ITERATION_MILESTONES[0].iterations;
  if (!after) return ITERATION_MILESTONES[ITERATION_MILESTONES.length - 1].iterations;
  const yearRange = after.year - before.year;
  const iterationRatio = after.iterations / before.iterations;
  const yearProgress = (year - before.year) / yearRange;
  return Math.floor(before.iterations * Math.pow(iterationRatio, yearProgress));
}
const LEGACY_ITERATIONS = 1e5;
async function deriveEncryptionKey(password, salt, iterations) {
  const encoder = new TextEncoder();
  const passwordBuffer = encoder.encode(password);
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    passwordBuffer,
    { name: "PBKDF2" },
    false,
    ["deriveBits", "deriveKey"]
  );
  return await crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt,
      iterations,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}
async function encryptWithAES(data, password, iterations = getCurrentRecommendedIterations()) {
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(data);
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveEncryptionKey(password, salt, iterations);
  const encryptedBuffer = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    dataBuffer
  );
  const iterationBytes = new Uint8Array(4);
  new DataView(iterationBytes.buffer).setUint32(0, iterations, false);
  const combined = new Uint8Array(
    4 + salt.length + iv.length + encryptedBuffer.byteLength
  );
  combined.set(iterationBytes, 0);
  combined.set(salt, 4);
  combined.set(iv, 4 + salt.length);
  combined.set(new Uint8Array(encryptedBuffer), 4 + salt.length + iv.length);
  return btoa(String.fromCharCode(...combined));
}
async function decryptWithAES(encryptedData, password) {
  try {
    const combined = Uint8Array.from(atob(encryptedData), (c) => c.charCodeAt(0));
    let iterationCount;
    let salt, iv, encrypted;
    if (combined.length >= 4) {
      const possibleIterations = new DataView(combined.buffer, 0, 4).getUint32(0, false);
      if (possibleIterations >= 1e5 && possibleIterations <= 5e6) {
        iterationCount = possibleIterations;
        salt = combined.slice(4, 20);
        iv = combined.slice(20, 32);
        encrypted = combined.slice(32);
      } else {
        iterationCount = LEGACY_ITERATIONS;
        salt = combined.slice(0, 16);
        iv = combined.slice(16, 28);
        encrypted = combined.slice(28);
      }
    } else {
      throw new Error("Invalid encrypted data format");
    }
    const key = await deriveEncryptionKey(password, salt, iterationCount);
    const decryptedBuffer = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
    );
    const decoder = new TextDecoder();
    return decoder.decode(decryptedBuffer);
  } catch (error) {
    if (error.message === "Invalid encrypted data format") {
      throw error;
    }
    throw new Error("Decryption failed - incorrect password or corrupted data");
  }
}
function getIterationsFromEncrypted(encryptedData) {
  try {
    const combined = Uint8Array.from(atob(encryptedData), (c) => c.charCodeAt(0));
    if (combined.length >= 4) {
      const possibleIterations = new DataView(combined.buffer, 0, 4).getUint32(0, false);
      if (possibleIterations >= 1e5 && possibleIterations <= 5e6) {
        return possibleIterations;
      }
    }
    return LEGACY_ITERATIONS;
  } catch (error) {
    return LEGACY_ITERATIONS;
  }
}
const OLD_WALLET_KEY = "wallet_encrypted";
const WALLETS_KEY = "wallets_multi";
const ongoingUpgrades = /* @__PURE__ */ new Map();
async function migrateToMultiWallet() {
  try {
    const walletsData = await load(WALLETS_KEY);
    if (walletsData) {
      return false;
    }
    const oldWallet = await load(OLD_WALLET_KEY);
    if (!oldWallet) {
      return false;
    }
    const newFormat = {
      activeWalletId: "wallet_migrated_" + Date.now(),
      walletList: [{
        id: "wallet_migrated_" + Date.now(),
        nickname: "Main Wallet",
        address: null,
        // Will be populated on unlock
        encryptedKeystore: oldWallet,
        createdAt: Date.now(),
        importMethod: "migrated"
      }]
    };
    await save(WALLETS_KEY, newFormat);
    return true;
  } catch (error) {
    console.error("Error during migration:", error);
    return false;
  }
}
async function getAllWallets() {
  const walletsData = await load(WALLETS_KEY);
  if (!walletsData) {
    return {
      activeWalletId: null,
      walletList: []
    };
  }
  return walletsData;
}
async function getActiveWallet() {
  const walletsData = await getAllWallets();
  if (!walletsData.activeWalletId || walletsData.walletList.length === 0) {
    return null;
  }
  const activeWallet = walletsData.walletList.find(
    (w) => w.id === walletsData.activeWalletId
  );
  return activeWallet || null;
}
async function walletExists() {
  const walletsData = await getAllWallets();
  return walletsData.walletList.length > 0;
}
function generateWalletId() {
  const array = new Uint8Array(8);
  crypto.getRandomValues(array);
  const randomStr = Array.from(array, (byte) => byte.toString(36)).join("");
  return "wallet_" + Date.now() + "_" + randomStr;
}
async function isDuplicateAddress(address) {
  const walletsData = await getAllWallets();
  return walletsData.walletList.some(
    (w) => w.address && w.address.toLowerCase() === address.toLowerCase()
  );
}
async function generateDefaultNickname() {
  const walletsData = await getAllWallets();
  const count = walletsData.walletList.length;
  return "Wallet " + (count + 1);
}
async function addWallet(type, data, password, nickname = null) {
  const passwordCheck = validatePasswordStrength(password);
  if (!passwordCheck.valid) {
    throw new Error(passwordCheck.errors.join(", "));
  }
  let wallet;
  let mnemonic = null;
  try {
    switch (type) {
      case "create":
        wallet = Wallet.createRandom();
        mnemonic = wallet.mnemonic.phrase;
        break;
      case "mnemonic":
        if (!data.mnemonic || !isValidMnemonic(data.mnemonic)) {
          throw new Error("Invalid mnemonic phrase");
        }
        const cleanMnemonic = data.mnemonic.trim().replace(/\s+/g, " ");
        wallet = Wallet.fromPhrase(cleanMnemonic);
        break;
      case "privatekey":
        if (!data.privateKey || !isValidPrivateKey(data.privateKey)) {
          throw new Error("Invalid private key");
        }
        const key = data.privateKey.startsWith("0x") ? data.privateKey : "0x" + data.privateKey;
        wallet = new Wallet(key);
        break;
      default:
        throw new Error("Invalid wallet type: " + type);
    }
    if (await isDuplicateAddress(wallet.address)) {
      throw new Error("This wallet already exists in your wallet list");
    }
    const currentIterations = getCurrentRecommendedIterations();
    const encryptedJson = await wallet.encrypt(password);
    const doubleEncrypted = await encryptWithAES(encryptedJson, password, currentIterations);
    const finalNickname = nickname || await generateDefaultNickname();
    const walletEntry = {
      id: generateWalletId(),
      nickname: finalNickname,
      address: wallet.address,
      encryptedKeystore: doubleEncrypted,
      createdAt: Date.now(),
      importMethod: type,
      lastSecurityUpgrade: Date.now(),
      // Track when encryption was last upgraded
      currentIterations
      // Store for UI display
    };
    const walletsData = await getAllWallets();
    if (walletsData.walletList.length >= 10) {
      throw new Error("Maximum wallet limit (10) reached. Please delete a wallet to add a new one.");
    }
    walletsData.walletList.push(walletEntry);
    if (walletsData.walletList.length === 1) {
      walletsData.activeWalletId = walletEntry.id;
    }
    await save(WALLETS_KEY, walletsData);
    console.log(` Wallet created with ${currentIterations.toLocaleString()} PBKDF2 iterations`);
    return {
      id: walletEntry.id,
      address: wallet.address,
      mnemonic
      // Only set for newly created wallets
    };
  } catch (error) {
    console.error("Error adding wallet:", error);
    throw error;
  }
}
async function setActiveWallet(walletId) {
  const walletsData = await getAllWallets();
  const wallet = walletsData.walletList.find((w) => w.id === walletId);
  if (!wallet) {
    throw new Error("Wallet not found");
  }
  walletsData.activeWalletId = walletId;
  await save(WALLETS_KEY, walletsData);
  return wallet;
}
async function renameWallet(walletId, newNickname) {
  if (!newNickname || newNickname.trim().length === 0) {
    throw new Error("Nickname cannot be empty");
  }
  if (newNickname.length > 30) {
    throw new Error("Nickname too long (max 30 characters)");
  }
  const walletsData = await getAllWallets();
  const wallet = walletsData.walletList.find((w) => w.id === walletId);
  if (!wallet) {
    throw new Error("Wallet not found");
  }
  wallet.nickname = newNickname.trim();
  await save(WALLETS_KEY, walletsData);
}
async function deleteWallet(walletId, password) {
  await unlockWallet(password);
  const walletsData = await getAllWallets();
  const walletIndex = walletsData.walletList.findIndex((w) => w.id === walletId);
  if (walletIndex === -1) {
    throw new Error("Wallet not found");
  }
  walletsData.walletList.splice(walletIndex, 1);
  if (walletsData.activeWalletId === walletId) {
    walletsData.activeWalletId = walletsData.walletList.length > 0 ? walletsData.walletList[0].id : null;
  }
  await save(WALLETS_KEY, walletsData);
}
async function unlockWallet(password, options = {}) {
  const activeWallet = await getActiveWallet();
  if (!activeWallet) {
    throw new Error("No wallet found. Please create or import a wallet.");
  }
  return await unlockSpecificWallet(activeWallet.id, password, options);
}
async function unlockSpecificWallet(walletId, password, options = {}) {
  try {
    const walletsData = await getAllWallets();
    const wallet = walletsData.walletList.find((w) => w.id === walletId);
    if (!wallet) {
      throw new Error("Wallet not found");
    }
    const keystoreJson = await decryptWithAES(wallet.encryptedKeystore, password);
    const signer = await Wallet.fromEncryptedJson(
      keystoreJson,
      password
    );
    if (!wallet.address) {
      wallet.address = signer.address;
      await save(WALLETS_KEY, walletsData);
    }
    if (!options.skipUpgrade) {
      const currentIterations = getIterationsFromEncrypted(wallet.encryptedKeystore);
      const recommendedIterations = getCurrentRecommendedIterations();
      if (currentIterations < recommendedIterations) {
        if (ongoingUpgrades.has(walletId)) {
          console.log(` Wallet upgrade already in progress, waiting for completion...`);
          await ongoingUpgrades.get(walletId);
          const updatedWalletsData = await getAllWallets();
          const updatedWallet = updatedWalletsData.walletList.find((w) => w.id === walletId);
          return {
            address: signer.address,
            signer,
            upgraded: true,
            iterationsBefore: currentIterations,
            iterationsAfter: recommendedIterations,
            upgradedByConcurrentTab: true
          };
        }
        const upgradePromise = (async () => {
          try {
            const iterationsBefore = currentIterations;
            console.log(` Wallet encryption upgrade available:`);
            console.log(`   Current: ${currentIterations.toLocaleString()} iterations`);
            console.log(`   Recommended: ${recommendedIterations.toLocaleString()} iterations`);
            if (options.onUpgradeStart) {
              options.onUpgradeStart({
                currentIterations,
                recommendedIterations,
                estimatedTimeMs: Math.floor(recommendedIterations / 1e5 * 100)
                // ~100ms per 100k iterations
              });
            }
            console.log(` Upgrading wallet security...`);
            const upgradeStart = Date.now();
            const newKeystoreJson = await signer.encrypt(password);
            const newEncrypted = await encryptWithAES(
              newKeystoreJson,
              password,
              recommendedIterations
            );
            const latestWalletsData = await getAllWallets();
            const latestWallet = latestWalletsData.walletList.find((w) => w.id === walletId);
            if (!latestWallet) {
              throw new Error("Wallet not found during upgrade");
            }
            latestWallet.encryptedKeystore = newEncrypted;
            latestWallet.lastSecurityUpgrade = Date.now();
            latestWallet.currentIterations = recommendedIterations;
            await save(WALLETS_KEY, latestWalletsData);
            const upgradeTime = Date.now() - upgradeStart;
            console.log(` Wallet upgraded to ${recommendedIterations.toLocaleString()} iterations (${upgradeTime}ms)`);
            return {
              iterationsBefore,
              iterationsAfter: recommendedIterations
            };
          } finally {
            ongoingUpgrades.delete(walletId);
          }
        })();
        ongoingUpgrades.set(walletId, upgradePromise);
        const upgradeResult = await upgradePromise;
        return {
          address: signer.address,
          signer,
          upgraded: true,
          ...upgradeResult
        };
      }
    }
    return {
      address: signer.address,
      signer,
      upgraded: false
    };
  } catch (error) {
    if (error.message.includes("incorrect password") || error.message.includes("Decryption failed")) {
      throw new Error("Incorrect password");
    }
    throw new Error("Failed to unlock wallet: " + error.message);
  }
}
async function exportPrivateKey(password) {
  const { signer } = await unlockWallet(password, { skipUpgrade: true });
  return signer.privateKey;
}
async function exportMnemonic(password) {
  const { signer } = await unlockWallet(password, { skipUpgrade: true });
  return signer.mnemonic ? signer.mnemonic.phrase : null;
}
async function exportPrivateKeyForWallet(walletId, password) {
  const { signer } = await unlockSpecificWallet(walletId, password, { skipUpgrade: true });
  return signer.privateKey;
}
async function exportMnemonicForWallet(walletId, password) {
  const { signer } = await unlockSpecificWallet(walletId, password, { skipUpgrade: true });
  return signer.mnemonic ? signer.mnemonic.phrase : null;
}
async function importFromMnemonic(mnemonic, password) {
  const result = await addWallet("mnemonic", { mnemonic }, password, "Main Wallet");
  return {
    address: result.address
  };
}
async function importFromPrivateKey(privateKey, password) {
  const result = await addWallet("privatekey", { privateKey }, password, "Main Wallet");
  return {
    address: result.address
  };
}
const RPC_ENDPOINTS = {
  "pulsechainTestnet": [
    "https://rpc.v4.testnet.pulsechain.com",
    "https://rpc-testnet-pulsechain.g4mm4.io"
  ],
  "pulsechain": [
    "https://rpc.pulsechain.com",
    "https://pulsechain-rpc.publicnode.com",
    "https://rpc-pulsechain.g4mm4.io",
    "https://pulsechain.publicnode.com"
  ],
  "ethereum": [
    "https://eth.llamarpc.com",
    "https://ethereum.publicnode.com",
    "https://rpc.ankr.com/eth",
    "https://cloudflare-eth.com"
  ],
  "sepolia": [
    "https://rpc.sepolia.org",
    "https://ethereum-sepolia.publicnode.com",
    "https://rpc.ankr.com/eth_sepolia"
  ]
};
const providers = {};
const endpointHealth = /* @__PURE__ */ new Map();
const HEALTH_CONFIG = {
  MAX_FAILURES: 3,
  // Blacklist after 3 failures
  BLACKLIST_DURATION: 3e5,
  // 5 minutes blacklist
  RETRY_DELAY: 1e3
  // 1 second delay between endpoint attempts
};
function recordEndpointFailure(endpoint) {
  const health = endpointHealth.get(endpoint) || { failures: 0, lastCheck: Date.now(), blacklisted: false };
  health.failures++;
  health.lastCheck = Date.now();
  if (health.failures >= HEALTH_CONFIG.MAX_FAILURES) {
    health.blacklisted = true;
    console.warn(` RPC endpoint blacklisted after ${health.failures} failures: ${endpoint}`);
    setTimeout(() => {
      const currentHealth = endpointHealth.get(endpoint);
      if (currentHealth) {
        currentHealth.blacklisted = false;
        currentHealth.failures = 0;
        console.log(` RPC endpoint recovered from blacklist: ${endpoint}`);
      }
    }, HEALTH_CONFIG.BLACKLIST_DURATION);
  }
  endpointHealth.set(endpoint, health);
}
function recordEndpointSuccess(endpoint) {
  const health = endpointHealth.get(endpoint) || { failures: 0, lastCheck: Date.now(), blacklisted: false };
  health.failures = Math.max(0, health.failures - 1);
  health.lastCheck = Date.now();
  endpointHealth.set(endpoint, health);
}
function isEndpointBlacklisted(endpoint) {
  const health = endpointHealth.get(endpoint);
  return (health == null ? void 0 : health.blacklisted) || false;
}
async function getProvider(network) {
  const endpoints = RPC_ENDPOINTS[network];
  if (!endpoints) {
    throw new Error(`Unknown network: ${network}`);
  }
  if (providers[network]) {
    try {
      await providers[network].getBlockNumber();
      return providers[network];
    } catch (error) {
      console.warn(` Cached provider failed for ${network}, trying failover...`);
      delete providers[network];
    }
  }
  const endpointsList = Array.isArray(endpoints) ? endpoints : [endpoints];
  for (let i = 0; i < endpointsList.length; i++) {
    const endpoint = endpointsList[i];
    if (isEndpointBlacklisted(endpoint)) {
      console.warn(` Skipping blacklisted endpoint: ${endpoint}`);
      continue;
    }
    try {
      console.log(` Trying RPC endpoint (${i + 1}/${endpointsList.length}): ${endpoint}`);
      const provider = new JsonRpcProvider(endpoint);
      await provider.getBlockNumber();
      providers[network] = provider;
      recordEndpointSuccess(endpoint);
      console.log(` Connected to RPC: ${endpoint}`);
      return provider;
    } catch (error) {
      console.error(` RPC endpoint failed: ${endpoint}`, error.message);
      recordEndpointFailure(endpoint);
      if (i < endpointsList.length - 1) {
        await new Promise((resolve) => setTimeout(resolve, HEALTH_CONFIG.RETRY_DELAY));
      }
    }
  }
  throw new Error(`All RPC endpoints failed for network: ${network}. Please check your internet connection.`);
}
async function rpcCall(network, method, params = []) {
  const provider = await getProvider(network);
  return await provider.send(method, params);
}
async function getBalance(network, address) {
  return await rpcCall(network, "eth_getBalance", [address, "latest"]);
}
async function getTransactionCount(network, address) {
  return await rpcCall(network, "eth_getTransactionCount", [address, "latest"]);
}
async function getGasPrice(network) {
  return await rpcCall(network, "eth_gasPrice", []);
}
async function getBlockNumber(network) {
  return await rpcCall(network, "eth_blockNumber", []);
}
async function getBlockByNumber(network, blockNumber, includeTransactions = false) {
  return await rpcCall(network, "eth_getBlockByNumber", [blockNumber, includeTransactions]);
}
async function estimateGas(network, transaction) {
  return await rpcCall(network, "eth_estimateGas", [transaction]);
}
async function call(network, transaction) {
  return await rpcCall(network, "eth_call", [transaction, "latest"]);
}
async function sendRawTransaction(network, signedTx) {
  return await rpcCall(network, "eth_sendRawTransaction", [signedTx]);
}
async function getTransactionReceipt(network, txHash) {
  return await rpcCall(network, "eth_getTransactionReceipt", [txHash]);
}
async function getTransactionByHash(network, txHash) {
  return await rpcCall(network, "eth_getTransactionByHash", [txHash]);
}
function formatBalance(balanceWei, decimals = 4) {
  const balance = formatEther(balanceWei);
  const num = parseFloat(balance);
  return num.toFixed(decimals);
}
export {
  toTwos as $,
  getBytes as A,
  toUtf8String as B,
  Contract as C,
  deleteWallet as D,
  exportMnemonicForWallet as E,
  exportPrivateKeyForWallet as F,
  getAddress as G,
  getTransactionByHash as H,
  Interface as I,
  getTransactionReceipt as J,
  sendRawTransaction as K,
  call as L,
  getBlockByNumber as M,
  getBlockNumber as N,
  computeHmac as O,
  keccak256 as P,
  pbkdf2 as Q,
  randomBytes as R,
  ripemd160 as S,
  scrypt as T,
  scryptSync as U,
  sha256 as V,
  sha512 as W,
  assertArgument as X,
  hexlify as Y,
  concat as Z,
  toUtf8Bytes as _,
  setActiveWallet as a,
  MessagePrefix as a$,
  zeroPadValue as a0,
  toBeArray as a1,
  dataLength as a2,
  zeroPadBytes as a3,
  defineProperties as a4,
  BaseContract as a5,
  copyOverrides as a6,
  resolveArgs as a7,
  assert as a8,
  getCreateAddress as a9,
  ContractTransactionReceipt as aA,
  ContractTransactionResponse as aB,
  ContractUnknownEventPayload as aC,
  EnsPlugin as aD,
  EnsResolver as aE,
  ErrorDescription as aF,
  ErrorFragment as aG,
  EtherSymbol as aH,
  EventFragment as aI,
  EventLog as aJ,
  EventPayload as aK,
  FallbackFragment as aL,
  FeeData as aM,
  FeeDataNetworkPlugin as aN,
  FetchCancelSignal as aO,
  FetchResponse as aP,
  FetchUrlFeeDataNetworkPlugin as aQ,
  FixedNumber as aR,
  Fragment as aS,
  FunctionFragment as aT,
  GasCostPlugin as aU,
  HDNodeVoidWallet as aV,
  HDNodeWallet as aW,
  Indexed as aX,
  JsonRpcSigner as aY,
  Log as aZ,
  LogDescription as a_,
  JsonRpcProvider as aa,
  Network as ab,
  FetchRequest as ac,
  resolveProperties as ad,
  AbstractProvider as ae,
  toQuantity as af,
  accessListify as ag,
  isError as ah,
  AbiCoder as ai,
  Transaction as aj,
  NetworkPlugin as ak,
  JsonRpcApiProvider as al,
  UnmanagedSubscriber as am,
  makeError as an,
  getBigInt as ao,
  getNumber as ap,
  AbstractSigner as aq,
  JsonRpcApiPollingProvider as ar,
  isHexString as as,
  decodeOwl as at,
  WordlistOwl as au,
  LangEn as av,
  BaseWallet as aw,
  Block as ax,
  ConstructorFragment as ay,
  ContractEventPayload as az,
  getActiveWallet as b,
  toBeHex as b$,
  Mnemonic as b0,
  MulticoinProviderPlugin as b1,
  NamedFragment as b2,
  ParamType as b3,
  Result as b4,
  Signature as b5,
  SigningKey as b6,
  StructFragment as b7,
  TransactionDescription as b8,
  TransactionReceipt as b9,
  encodeBase58 as bA,
  encodeBase64 as bB,
  encodeRlp as bC,
  encryptKeystoreJson as bD,
  encryptKeystoreJsonSync as bE,
  ensNormalize as bF,
  fromTwos as bG,
  getAccountPath as bH,
  getBytesCopy as bI,
  getCreate2Address as bJ,
  getIcapAddress as bK,
  getIndexedAccountPath as bL,
  getUint as bM,
  hashAuthorization as bN,
  hashMessage as bO,
  id as bP,
  isAddressable as bQ,
  isBytesLike as bR,
  isCallException as bS,
  isCrowdsaleJson as bT,
  isKeystoreJson as bU,
  isValidName as bV,
  mask as bW,
  namehash as bX,
  recoverAddress as bY,
  resolveAddress as bZ,
  stripZerosLeft as b_,
  TransactionResponse as ba,
  Typed as bb,
  TypedDataEncoder as bc,
  UndecodedEventLog as bd,
  Utf8ErrorFuncs as be,
  VoidSigner as bf,
  Wallet as bg,
  Wordlist as bh,
  ZeroAddress as bi,
  ZeroHash as bj,
  assertArgumentCount as bk,
  assertNormalize as bl,
  assertPrivate as bm,
  authorizationify as bn,
  checkResultErrors as bo,
  computeAddress as bp,
  copyRequest as bq,
  dataSlice as br,
  decodeBase58 as bs,
  decodeBase64 as bt,
  decodeRlp as bu,
  decryptCrowdsaleJson as bv,
  decryptKeystoreJson as bw,
  decryptKeystoreJsonSync as bx,
  defaultPath as by,
  dnsEncode as bz,
  importFromMnemonic as c,
  toBigInt as c0,
  toNumber as c1,
  toUtf8CodePoints as c2,
  uuidV4 as c3,
  verifyAuthorization as c4,
  verifyMessage as c5,
  verifyTypedData as c6,
  version as c7,
  importFromPrivateKey as d,
  shortenAddress as e,
  formatUnits as f,
  getProvider as g,
  getAllWallets as h,
  isAddress as i,
  getBalance as j,
  formatBalance as k,
  load as l,
  migrateToMultiWallet as m,
  getTransactionCount as n,
  parseEther as o,
  parseUnits$1 as p,
  exportMnemonic as q,
  exportPrivateKey as r,
  save as s,
  addWallet as t,
  unlockWallet as u,
  renameWallet as v,
  walletExists as w,
  getGasPrice as x,
  estimateGas as y,
  formatEther as z
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnBjLmpzIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9lcnJvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9tYXRocy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNTguanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTY0LWJyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXZlbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3V0ZjguanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZ2V0dXJsLWJyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZmV0Y2guanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWRlY29kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ybHAtZW5jb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3VuaXRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3V1aWQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3Bia2RmMi5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2NyeXB0by1icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9obWFjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2tlY2Nhay5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9yaXBlbWQxNjAuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3JpcGVtZDE2MC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vcGJrZGYyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9yYW5kb20uanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2NyeXB0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zY3J5cHQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NoYTIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvYWRkcmVzc2VzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9oYXNoZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL3N0cmluZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25hdHVyZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2lnbmluZy1rZXkuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvY29udHJhY3QtYWRkcmVzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NoZWNrcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvdHlwZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hZGRyZXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYW5vbnltb3VzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ib29sZWFuLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYnl0ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9maXhlZC1ieXRlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL251bGwuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udW1iZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9zdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy90dXBsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hY2Nlc3NsaXN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2F1dGhvcml6YXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWRkcmVzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL2F1dGhvcml6YXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AYWRyYWZmeS9lbnMtbm9ybWFsaXplL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvbmFtZWhhc2guanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9tZXNzYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvdHlwZWQtZGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvZnJhZ21lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9hYmktY29kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3Qvd3JhcHBlcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Vucy1yZXNvbHZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZm9ybWF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wbHVnaW5zLW5ldHdvcmsuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItcG9sbGluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvYmFzZS13YWxsZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL2RlY29kZS1vd2wuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL3dvcmRsaXN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy93b3JkbGlzdC1vd2wuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL2xhbmctZW4uanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L21uZW1vbmljLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuZXNtL2Flcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuZXNtL21vZGUtY2JjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuZXNtL21vZGUtY3RyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuZXNtL3BhZGRpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9qc29uLWtleXN0b3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9oZHdhbGxldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvanNvbi1jcm93ZHNhbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L3dhbGxldC5qcyIsIi4uL3NyYy9jb3JlL3N0b3JhZ2UuanMiLCIuLi9zcmMvY29yZS92YWxpZGF0aW9uLmpzIiwiLi4vc3JjL2NvcmUvd2FsbGV0LmpzIiwiLi4vc3JjL2NvcmUvcnBjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIERvIE5PVCBtb2RpZnkgdGhpcyBmaWxlOyBzZWUgL3NyYy50cy9fYWRtaW4vdXBkYXRlLXZlcnNpb24udHMgKi9cclxuLyoqXHJcbiAqICBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIEV0aGVycy5cclxuICovXHJcbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCI2LjE1LjBcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiLyoqXHJcbiAqICBQcm9wZXJ0eSBoZWxwZXIgZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpQcm9wZXJ0aWVzICBbYWJvdXQtcHJvcGVydGllc11cclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwgbmFtZSkge1xyXG4gICAgY29uc3QgdHlwZXMgPSB0eXBlLnNwbGl0KFwifFwiKS5tYXAodCA9PiB0LnRyaW0oKSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhbnlcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxyXG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZCB2YWx1ZSBmb3IgdHlwZSAke3R5cGV9YCk7XHJcbiAgICBlcnJvci5jb2RlID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XHJcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcclxuICAgIGVycm9yLnZhbHVlID0gdmFsdWU7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxufVxyXG4vKipcclxuICogIFJlc29sdmVzIHRvIGEgbmV3IG9iamVjdCB0aGF0IGlzIGEgY29weSBvZiAlJXZhbHVlJSUsIGJ1dCB3aXRoIGFsbFxyXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGtleXMubWFwKChrKSA9PiBQcm9taXNlLnJlc29sdmUodmFsdWVba10pKSk7XHJcbiAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGFjY3VtLCB2LCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGFjY3VtW2tleXNbaW5kZXhdXSA9IHY7XHJcbiAgICAgICAgcmV0dXJuIGFjY3VtO1xyXG4gICAgfSwge30pO1xyXG59XHJcbi8qKlxyXG4gKiAgQXNzaWducyB0aGUgJSV2YWx1ZXMlJSB0byAlJXRhcmdldCUlIGFzIHJlYWQtb25seSB2YWx1ZXMuXHJcbiAqXHJcbiAqICBJdCAlJXR5cGVzJSUgaXMgc3BlY2lmaWVkLCB0aGUgdmFsdWVzIGFyZSBjaGVja2VkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCB2YWx1ZXMsIHR5cGVzKSB7XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gdmFsdWVzKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2tleV07XHJcbiAgICAgICAgY29uc3QgdHlwZSA9ICh0eXBlcyA/IHR5cGVzW2tleV0gOiBudWxsKTtcclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICBjaGVja1R5cGUodmFsdWUsIHR5cGUsIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZSwgd3JpdGFibGU6IGZhbHNlIH0pO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIiwiLyoqXHJcbiAqICBBbGwgZXJyb3JzIGluIGV0aGVycyBpbmNsdWRlIHByb3BlcnRpZXMgdG8gZW5zdXJlIHRoZXkgYXJlIGJvdGhcclxuICogIGh1bWFuLXJlYWRhYmxlIChpLmUuIGBgLm1lc3NhZ2VgYCkgYW5kIG1hY2hpbmUtcmVhZGFibGUgKGkuZS4gYGAuY29kZWBgKS5cclxuICpcclxuICogIFRoZSBbW2lzRXJyb3JdXSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGUgZXJyb3IgYGBjb2RlYGAgYW5kXHJcbiAqICBwcm92aWRlIGEgdHlwZSBndWFyZCBmb3IgdGhlIHByb3BlcnRpZXMgcHJlc2VudCBvbiB0aGF0IGVycm9yIGludGVyZmFjZS5cclxuICpcclxuICogIEBfc2VjdGlvbjogYXBpL3V0aWxzL2Vycm9yczpFcnJvcnMgIFthYm91dC1lcnJvcnNdXHJcbiAqL1xyXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uLmpzXCI7XHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgc2Vlbikge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gXCJudWxsXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoc2VlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgc2VlbiA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyXVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWVuLmFkZCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gXCJbIFwiICsgKHZhbHVlLm1hcCgodikgPT4gc3RyaW5naWZ5KHYsIHNlZW4pKSkuam9pbihcIiwgXCIpICsgXCIgXVwiO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xyXG4gICAgICAgIGNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldICYgMHhmXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKHZhbHVlLnRvSlNPTikgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUudG9KU09OKCksIHNlZW4pO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xyXG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xyXG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcclxuICAgICAgICAgICAga2V5cy5zb3J0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBcInsgXCIgKyBrZXlzLm1hcCgoaykgPT4gYCR7c3RyaW5naWZ5KGssIHNlZW4pfTogJHtzdHJpbmdpZnkodmFsdWVba10sIHNlZW4pfWApLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYFsgQ09VTEQgTk9UIFNFUklBTElaRSBdYDtcclxufVxyXG4vKipcclxuICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgJSVlcnJvciUlIG1hdGNoZXMgYW4gZXJyb3IgdGhyb3duIGJ5IGV0aGVyc1xyXG4gKiAgdGhhdCBtYXRjaGVzIHRoZSBlcnJvciAlJWNvZGUlJS5cclxuICpcclxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoYXQgJSVlcnJvciUlXHJcbiAqICBtYXRjaGVzIGFuIEV0aGVyc0Vycm9yIHR5cGUsIHdoaWNoIG1lYW5zIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIHdpbGxcclxuICogIGJlIHNldC5cclxuICpcclxuICogIEBTZWUgW0Vycm9yQ29kZXNdKGFwaTpFcnJvckNvZGUpXHJcbiAqICBAZXhhbXBsZVxyXG4gKiAgICB0cnkge1xyXG4gKiAgICAgIC8vIGNvZGUuLi4uXHJcbiAqICAgIH0gY2F0Y2ggKGUpIHtcclxuICogICAgICBpZiAoaXNFcnJvcihlLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XHJcbiAqICAgICAgICAgIC8vIFRoZSBUeXBlIEd1YXJkIGhhcyB2YWxpZGF0ZWQgdGhpcyBvYmplY3RcclxuICogICAgICAgICAgY29uc29sZS5sb2coZS5kYXRhKTtcclxuICogICAgICB9XHJcbiAqICAgIH1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yKGVycm9yLCBjb2RlKSB7XHJcbiAgICByZXR1cm4gKGVycm9yICYmIGVycm9yLmNvZGUgPT09IGNvZGUpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlZXJyb3IlJSBpcyBhIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpIHtcclxuICAgIHJldHVybiBpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyBhIG5ldyBFcnJvciBjb25maWd1cmVkIHRvIHRoZSBmb3JtYXQgZXRoZXJzIGVtaXRzIGVycm9ycywgd2l0aFxyXG4gKiAgdGhlICUlbWVzc2FnZSUlLCBbW2FwaTpFcnJvckNvZGVdXSAlJWNvZGUlJSBhbmQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXHJcbiAqICBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgRXRoZXJzRXJyb3IuXHJcbiAqXHJcbiAqICBFYWNoIGVycm9yIGluIGV0aGVycyBpbmNsdWRlcyB0aGUgdmVyc2lvbiBvZiBldGhlcnMsIGFcclxuICogIG1hY2hpbmUtcmVhZGFibGUgW1tFcnJvckNvZGVdXSwgYW5kIGRlcGVuZGluZyBvbiAlJWNvZGUlJSwgYWRkaXRpb25hbFxyXG4gKiAgcmVxdWlyZWQgcHJvcGVydGllcy4gVGhlIGVycm9yIG1lc3NhZ2Ugd2lsbCBhbHNvIGluY2x1ZGUgdGhlICUlbWVzc2FnZSUlLFxyXG4gKiAgZXRoZXJzIHZlcnNpb24sICUlY29kZSUlIGFuZCBhbGwgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLCBzZXJpYWxpemVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XHJcbiAgICBsZXQgc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcclxuICAgIHtcclxuICAgICAgICBjb25zdCBkZXRhaWxzID0gW107XHJcbiAgICAgICAgaWYgKGluZm8pIHtcclxuICAgICAgICAgICAgaWYgKFwibWVzc2FnZVwiIGluIGluZm8gfHwgXCJjb2RlXCIgaW4gaW5mbyB8fCBcIm5hbWVcIiBpbiBpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHdpbGwgb3ZlcndyaXRlIHBvcHVsYXRlZCB2YWx1ZXM6ICR7c3RyaW5naWZ5KGluZm8pfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZm8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwic2hvcnRNZXNzYWdlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGluZm9ba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgc3RyaW5naWZ5KHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1NTVwiLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9W2NvdWxkIG5vdCBzZXJpYWxpemUgb2JqZWN0XVwiKTtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO1xyXG4gICAgICAgIGRldGFpbHMucHVzaChgdmVyc2lvbj0ke3ZlcnNpb259YCk7XHJcbiAgICAgICAgaWYgKGRldGFpbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgZGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgZXJyb3I7XHJcbiAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICBjYXNlIFwiSU5WQUxJRF9BUkdVTUVOVFwiOlxyXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJOVU1FUklDX0ZBVUxUXCI6XHJcbiAgICAgICAgY2FzZSBcIkJVRkZFUl9PVkVSUlVOXCI6XHJcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBjb2RlIH0pO1xyXG4gICAgaWYgKGluZm8pIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKGVycm9yLCBpbmZvKTtcclxuICAgIH1cclxuICAgIGlmIChlcnJvci5zaG9ydE1lc3NhZ2UgPT0gbnVsbCkge1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgc2hvcnRNZXNzYWdlIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVycm9yO1xyXG59XHJcbi8qKlxyXG4gKiAgVGhyb3dzIGFuIEV0aGVyc0Vycm9yIHdpdGggJSVtZXNzYWdlJSUsICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIGVycm9yXHJcbiAqICAlJWluZm8lJSB3aGVuICUlY2hlY2slJSBpcyBmYWxzaXNoLi5cclxuICpcclxuICogIEBzZWUgW1thcGk6bWFrZUVycm9yXV1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcclxuICAgIGlmICghY2hlY2spIHtcclxuICAgICAgICB0aHJvdyBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBIHNpbXBsZSBoZWxwZXIgdG8gc2ltcGx5IGVuc3VyaW5nIHByb3ZpZGVkIGFyZ3VtZW50cyBtYXRjaCBleHBlY3RlZFxyXG4gKiAgY29uc3RyYWludHMsIHRocm93aW5nIGlmIG5vdC5cclxuICpcclxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGUgJSVjaGVjayUlIGhhcyBiZWVuIGFzc2VydGVkIHRydWUsIHNvXHJcbiAqICBhbnkgZnVydGhlciBjb2RlIGRvZXMgbm90IG5lZWQgYWRkaXRpb25hbCBjb21waWxlLXRpbWUgY2hlY2tzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XHJcbiAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XHJcbiAgICAgICAgbWVzc2FnZSA9IFwiXCI7XHJcbiAgICB9XHJcbiAgICBpZiAobWVzc2FnZSkge1xyXG4gICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0KGNvdW50ID49IGV4cGVjdGVkQ291bnQsIFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgXCJNSVNTSU5HX0FSR1VNRU5UXCIsIHtcclxuICAgICAgICBjb3VudDogY291bnQsXHJcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxyXG4gICAgfSk7XHJcbiAgICBhc3NlcnQoY291bnQgPD0gZXhwZWN0ZWRDb3VudCwgXCJ0b28gbWFueSBhcmd1bWVudHNcIiArIG1lc3NhZ2UsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7XHJcbiAgICAgICAgY291bnQ6IGNvdW50LFxyXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcclxuICAgIH0pO1xyXG59XHJcbmNvbnN0IF9ub3JtYWxpemVGb3JtcyA9IFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLnJlZHVjZSgoYWNjdW0sIGZvcm0pID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gR2VuZXJhbCB0ZXN0IGZvciBub3JtYWxpemVcclxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cclxuICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xyXG4gICAgICAgIGlmIChmb3JtID09PSBcIk5GRFwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpO1xyXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cclxuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBleHBlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjY3VtLnB1c2goZm9ybSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgcmV0dXJuIGFjY3VtO1xyXG59LCBbXSk7XHJcbi8qKlxyXG4gKiAgVGhyb3dzIGlmIHRoZSBub3JtYWxpemF0aW9uICUlZm9ybSUlIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm9ybWFsaXplKGZvcm0pIHtcclxuICAgIGFzc2VydChfbm9ybWFsaXplRm9ybXMuaW5kZXhPZihmb3JtKSA+PSAwLCBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBpbmZvOiB7IGZvcm0gfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqICBNYW55IGNsYXNzZXMgdXNlIGZpbGUtc2NvcGVkIHZhbHVlcyB0byBndWFyZCB0aGUgY29uc3RydWN0b3IsXHJcbiAqICBtYWtpbmcgaXQgZWZmZWN0aXZlbHkgcHJpdmF0ZS4gVGhpcyBmYWNpbGl0YXRlcyB0aGF0IHBhdHRlcm5cclxuICogIGJ5IGVuc3VyaW5nIHRoZSAlJWdpdmVuR2F1cmQlJSBtYXRjaGVzIHRoZSBmaWxlLXNjb3BlZCAlJWd1YXJkJSUsXHJcbiAqICB0aHJvd2luZyBpZiBub3QsIGluZGljYXRpbmcgdGhlICUlY2xhc3NOYW1lJSUgaWYgcHJvdmlkZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZShnaXZlbkd1YXJkLCBndWFyZCwgY2xhc3NOYW1lKSB7XHJcbiAgICBpZiAoY2xhc3NOYW1lID09IG51bGwpIHtcclxuICAgICAgICBjbGFzc05hbWUgPSBcIlwiO1xyXG4gICAgfVxyXG4gICAgaWYgKGdpdmVuR3VhcmQgIT09IGd1YXJkKSB7XHJcbiAgICAgICAgbGV0IG1ldGhvZCA9IGNsYXNzTmFtZSwgb3BlcmF0aW9uID0gXCJuZXdcIjtcclxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIG1ldGhvZCArPSBcIi5cIjtcclxuICAgICAgICAgICAgb3BlcmF0aW9uICs9IFwiIFwiICsgY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBwcml2YXRlIGNvbnN0cnVjdG9yOyB1c2UgJHttZXRob2R9ZnJvbSogbWV0aG9kc2AsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIi8qKlxyXG4gKiAgU29tZSBkYXRhIGhlbHBlcnMuXHJcbiAqXHJcbiAqXHJcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOkRhdGEgSGVscGVycyAgW2Fib3V0LWRhdGFdXHJcbiAqL1xyXG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XHJcbmZ1bmN0aW9uIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgY29weSkge1xyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xyXG4gICAgICAgIGlmIChjb3B5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tYXRjaCgvXjB4KD86WzAtOWEtZl1bMC05YS1mXSkqJC9pKSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSAyO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCeXRlc0xpa2UgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcclxufVxyXG4vKipcclxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJS4gSWYgYWxyZWFkeSBhIFVpbnQ4QXJyYXlcclxuICogIHRoZSBvcmlnaW5hbCAlJXZhbHVlJSUgaXMgcmV0dXJuZWQ7IGlmIGEgY29weSBpcyByZXF1aXJlZCB1c2VcclxuICogIFtbZ2V0Qnl0ZXNDb3B5XV0uXHJcbiAqXHJcbiAqICBAc2VlOiBnZXRCeXRlc0NvcHlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZSwgbmFtZSkge1xyXG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgZmFsc2UpO1xyXG59XHJcbi8qKlxyXG4gKiAgR2V0IGEgdHlwZWQgVWludDhBcnJheSBmb3IgJSV2YWx1ZSUlLCBjcmVhdGluZyBhIGNvcHkgaWYgbmVjZXNzYXJ5XHJcbiAqICB0byBwcmV2ZW50IGFueSBtb2RpZmljYXRpb25zIG9mIHRoZSByZXR1cm5lZCB2YWx1ZSBmcm9tIGJlaW5nXHJcbiAqICByZWZsZWN0ZWQgZWxzZXdoZXJlLlxyXG4gKlxyXG4gKiAgQHNlZTogZ2V0Qnl0ZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlc0NvcHkodmFsdWUsIG5hbWUpIHtcclxuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIHRydWUpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIFtbSGV4U3RyaW5nXV0uXHJcbiAqXHJcbiAqICBJZiAlJWxlbmd0aCUlIGlzIGBgdHJ1ZWBgIG9yIGEgLy9udW1iZXIvLywgaXQgYWxzbyBjaGVja3MgdGhhdFxyXG4gKiAgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVsZW5ndGglJSAoaWYgYSAvL251bWJlci8vKVxyXG4gKiAgYnl0ZXMgb2YgZGF0YSAoZS5nLiBgYDB4MTIzNGBgIGlzIDIgYnl0ZXMpLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcclxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgKGxlbmd0aCkgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChsZW5ndGggPT09IHRydWUgJiYgKHZhbHVlLmxlbmd0aCAlIDIpICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYXJiaXRyYXJ5XHJcbiAqICBkYXRhIChpLmUuIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb3IgYSBVaW50OEFycmF5KS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIChpc0hleFN0cmluZyh2YWx1ZSwgdHJ1ZSkgfHwgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkpO1xyXG59XHJcbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcclxuLyoqXHJcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gcmVwcmVzZW50YXRpb24gb2YgJSVkYXRhJSUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGV4bGlmeShkYXRhKSB7XHJcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xyXG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB2ID0gYnl0ZXNbaV07XHJcbiAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSBieSBjb25jYXRlbmF0aW5nIGFsbCB2YWx1ZXNcclxuICogIHdpdGhpbiAlJWRhdGElJS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoZGF0YXMpIHtcclxuICAgIHJldHVybiBcIjB4XCIgKyBkYXRhcy5tYXAoKGQpID0+IGhleGxpZnkoZCkuc3Vic3RyaW5nKDIpKS5qb2luKFwiXCIpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLCBpbiBieXRlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkYXRhTGVuZ3RoKGRhdGEpIHtcclxuICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCB0cnVlKSkge1xyXG4gICAgICAgIHJldHVybiAoZGF0YS5sZW5ndGggLSAyKSAvIDI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSkubGVuZ3RoO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IHNsaWNpbmcgJSVkYXRhJSUgZnJvbSB0aGUgJSVzdGFydCUlXHJcbiAqICBvZmZzZXQgdG8gdGhlICUlZW5kJSUgb2Zmc2V0LlxyXG4gKlxyXG4gKiAgQnkgZGVmYXVsdCAlJXN0YXJ0JSUgaXMgMCBhbmQgJSVlbmQlJSBpcyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRhdGFTbGljZShkYXRhLCBzdGFydCwgZW5kKSB7XHJcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xyXG4gICAgaWYgKGVuZCAhPSBudWxsICYmIGVuZCA+IGJ5dGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3Qgc2xpY2UgYmV5b25kIGRhdGEgYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xyXG4gICAgICAgICAgICBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IGJ5dGVzLmxlbmd0aCwgb2Zmc2V0OiBlbmRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzLnNsaWNlKChzdGFydCA9PSBudWxsKSA/IDAgOiBzdGFydCwgKGVuZCA9PSBudWxsKSA/IGJ5dGVzLmxlbmd0aCA6IGVuZCkpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSByZXN1bHQgYnkgc3RyaXBwaW5nIGFsbCAqKmxlYWRpbmcqKlxyXG4gKiogemVybyBieXRlcyBmcm9tICUlZGF0YSUlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3NMZWZ0KGRhdGEpIHtcclxuICAgIGxldCBieXRlcyA9IGhleGxpZnkoZGF0YSkuc3Vic3RyaW5nKDIpO1xyXG4gICAgd2hpbGUgKGJ5dGVzLnN0YXJ0c1dpdGgoXCIwMFwiKSkge1xyXG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKDIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiMHhcIiArIGJ5dGVzO1xyXG59XHJcbmZ1bmN0aW9uIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBsZWZ0KSB7XHJcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xyXG4gICAgYXNzZXJ0KGxlbmd0aCA+PSBieXRlcy5sZW5ndGgsIFwicGFkZGluZyBleGNlZWRzIGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xyXG4gICAgICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLFxyXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxyXG4gICAgICAgIG9mZnNldDogbGVuZ3RoICsgMVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xyXG4gICAgcmVzdWx0LmZpbGwoMCk7XHJcbiAgICBpZiAobGVmdCkge1xyXG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIGxlbmd0aCAtIGJ5dGVzLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXN1bHQuc2V0KGJ5dGVzLCAwKTtcclxuICAgIH1cclxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIG9mICUlZGF0YSUlIHBhZGRlZCBvbiB0aGUgKipsZWZ0KipcclxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXHJcbiAqXHJcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXHJcbiAqICB0aHJvd24uXHJcbiAqXHJcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKnZhbHVlcyoqIGFyZSBpbiBTb2xpZGl0eVxyXG4gKiAgKGUuZy4gYGB1aW50MTI4YGApLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWRWYWx1ZShkYXRhLCBsZW5ndGgpIHtcclxuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgdHJ1ZSk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIG9mICUlZGF0YSUlIHBhZGRlZCBvbiB0aGUgKipyaWdodCoqXHJcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxyXG4gKlxyXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xyXG4gKiAgdGhyb3duLlxyXG4gKlxyXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKipieXRlcyoqIGFyZSBpbiBTb2xpZGl0eVxyXG4gKiAgKGUuZy4gYGBieXRlczE2YGApLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWRCeXRlcyhkYXRhLCBsZW5ndGgpIHtcclxuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgZmFsc2UpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEuanMubWFwIiwiLyoqXHJcbiAqICBTb21lIG1hdGhlbWF0aWMgb3BlcmF0aW9ucy5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOk1hdGggSGVscGVycyAgW2Fib3V0LW1hdGhzXVxyXG4gKi9cclxuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlc0xpa2UgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XHJcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcclxuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcclxuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcclxuLy9jb25zdCBCTl9NYXgyNTYgPSAoQk5fMSA8PCBCaWdJbnQoMjU2KSkgLSBCTl8xO1xyXG4vLyBJRUVFIDc1NCBzdXBwb3J0IDUzLWJpdHMgb2YgbWFudGlzc2FcclxuY29uc3QgbWF4VmFsdWUgPSAweDFmZmZmZmZmZmZmZmZmO1xyXG4vKipcclxuICogIENvbnZlcnQgJSV2YWx1ZSUlIGZyb20gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2YgJSV3aWR0aCUlXHJcbiAqICBiaXRzIHRvIGl0cyB2YWx1ZS5cclxuICpcclxuICogIElmIHRoZSBoaWdoZXN0IGJpdCBpcyBgYDFgYCwgdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xyXG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKSk7XHJcbiAgICBhc3NlcnQoKHZhbHVlID4+IHdpZHRoKSA9PT0gQk5fMCwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xyXG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXHJcbiAgICB9KTtcclxuICAgIC8vIFRvcCBiaXQgc2V0OyB0cmVhdCBhcyBhIG5lZ2F0aXZlIHZhbHVlXHJcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcclxuICAgICAgICBjb25zdCBtYXNrID0gKEJOXzEgPDwgd2lkdGgpIC0gQk5fMTtcclxuICAgICAgICByZXR1cm4gLSgoKH52YWx1ZSkgJiBtYXNrKSArIEJOXzEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiAgQ29udmVydCAlJXZhbHVlJSUgdG8gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2ZcclxuICogICUld2lkdGglJSBiaXRzLlxyXG4gKlxyXG4gKiAgVGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBwb3NpdGl2ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1R3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcclxuICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XHJcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcclxuICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xyXG4gICAgaWYgKHZhbHVlIDwgQk5fMCkge1xyXG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xyXG4gICAgICAgIGFzc2VydCh2YWx1ZSA8PSBsaW1pdCwgXCJ0b28gbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xyXG4gICAgICAgIHJldHVybiAoKH52YWx1ZSkgJiBtYXNrKSArIEJOXzE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnQodmFsdWUgPCBsaW1pdCwgXCJ0b28gaGlnaFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4vKipcclxuICogIE1hc2sgJSV2YWx1ZSUlIHdpdGggYSBiaXRtYXNrIG9mICUlYml0cyUlIG9uZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFzayhfdmFsdWUsIF9iaXRzKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xyXG4gICAgY29uc3QgYml0cyA9IEJpZ0ludChnZXROdW1iZXIoX2JpdHMsIFwiYml0c1wiKSk7XHJcbiAgICByZXR1cm4gdmFsdWUgJiAoKEJOXzEgPDwgYml0cykgLSBCTl8xKTtcclxufVxyXG4vKipcclxuICogIEdldHMgYSBCaWdJbnQgZnJvbSAlJXZhbHVlJSUuIElmIGl0IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yXHJcbiAqICBhIEJpZ0ludCwgdGhlbiBhbiBBcmd1bWVudEVycm9yIHdpbGwgYmUgdGhyb3duIGZvciAlJW5hbWUlJS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCaWdJbnQodmFsdWUsIG5hbWUpIHtcclxuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcclxuICAgICAgICBjYXNlIFwiYmlnaW50XCI6IHJldHVybiB2YWx1ZTtcclxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIiAmJiB2YWx1ZVsxXSAhPT0gXCItXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLUJpZ0ludCh2YWx1ZS5zdWJzdHJpbmcoMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBCaWdOdW1iZXJpc2ggc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIEJpZ051bWJlcmlzaCB2YWx1ZVwiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyAlJXZhbHVlJSUgYXMgYSBiaWdpbnQsIHZhbGlkYXRpbmcgaXQgaXMgdmFsaWQgYXMgYSBiaWdpbnRcclxuICogIHZhbHVlIGFuZCB0aGF0IGl0IGlzIHBvc2l0aXZlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFVpbnQodmFsdWUsIG5hbWUpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGdldEJpZ0ludCh2YWx1ZSwgbmFtZSk7XHJcbiAgICBhc3NlcnQocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgb3BlcmF0aW9uOiBcImdldFVpbnRcIiwgdmFsdWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XHJcbi8qXHJcbiAqIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZ0ludC4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcclxuICogaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdJbnQodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcclxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiA+PiA0XTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQmlnSW50KHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlKTtcclxufVxyXG4vKipcclxuICogIEdldHMgYSAvL251bWJlci8vIGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxyXG4gKiAgYSAvL251bWJlci8vLCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE51bWJlcih2YWx1ZSwgbmFtZSkge1xyXG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xyXG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcihCaWdJbnQodmFsdWUpLCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIG51bWVyaWMgc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcclxufVxyXG4vKipcclxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIG51bWJlci4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcclxuICogIGlzIHRyZWF0ZWQgYXMgQmlnIEVuZGlhbiBkYXRhLiBUaHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCBzYWZlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZ2V0TnVtYmVyKHRvQmlnSW50KHZhbHVlKSk7XHJcbn1cclxuLyoqXHJcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIGhleHN0cmluZywgb3B0aW9uYWxseSBwYWRkZWQgdG9cclxuICogICUld2lkdGglJSBieXRlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JlSGV4KF92YWx1ZSwgX3dpZHRoKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xyXG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcclxuICAgIGlmIChfd2lkdGggPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgdmFsdWUgaXMgb2YgZXZlbiBsZW5ndGhcclxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpO1xyXG4gICAgICAgIGFzc2VydCh3aWR0aCAqIDIgPj0gcmVzdWx0Lmxlbmd0aCwgYHZhbHVlIGV4Y2VlZHMgd2lkdGggKCR7d2lkdGh9IGJ5dGVzKWAsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b0JlSGV4XCIsXHJcbiAgICAgICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBQYWQgdGhlIHZhbHVlIHRvIHRoZSByZXF1aXJlZCB3aWR0aFxyXG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgKHdpZHRoICogMikpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gVWludDhBcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JlQXJyYXkoX3ZhbHVlKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xyXG4gICAgaWYgKHZhbHVlID09PSBCTl8wKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtdKTtcclxuICAgIH1cclxuICAgIGxldCBoZXggPSB2YWx1ZS50b1N0cmluZygxNik7XHJcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcclxuICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDI7XHJcbiAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyBhIFtbSGV4U3RyaW5nXV0gZm9yICUldmFsdWUlJSBzYWZlIHRvIHVzZSBhcyBhIC8vUXVhbnRpdHkvLy5cclxuICpcclxuICogIEEgLy9RdWFudGl0eS8vIGRvZXMgbm90IGhhdmUgYW5kIGxlYWRpbmcgMCB2YWx1ZXMgdW5sZXNzIHRoZSB2YWx1ZSBpc1xyXG4gKiAgdGhlIGxpdGVyYWwgdmFsdWUgYDB4MGAuIFRoaXMgaXMgbW9zdCBjb21tb25seSB1c2VkIGZvciBKU1NPTi1SUENcclxuICogIG51bWVyaWMgdmFsdWVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvUXVhbnRpdHkodmFsdWUpIHtcclxuICAgIGxldCByZXN1bHQgPSBoZXhsaWZ5KGlzQnl0ZXNMaWtlKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xyXG4gICAgd2hpbGUgKHJlc3VsdC5zdGFydHNXaXRoKFwiMFwiKSkge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMSk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVzdWx0ID09PSBcIlwiKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gXCIwXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhzLmpzLm1hcCIsIi8qKlxyXG4gKiAgVGhlIFtCYXNlNTggRW5jb2RpbmddKGxpbmstYmFzZTU4KSBzY2hlbWUgYWxsb3dzIGEgKipudW1lcmljKiogdmFsdWVcclxuICogIHRvIGJlIGVuY29kZWQgYXMgYSBjb21wYWN0IHN0cmluZyB1c2luZyBhIHJhZGl4IG9mIDU4IHVzaW5nIG9ubHlcclxuICogIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy4gQ29uZnVzaW5nbHkgc2ltaWxhciBjaGFyYWN0ZXJzIGFyZSBvbWl0dGVkXHJcbiAqICAoaS5lLiBgYFwibDBPXCJgYCkuXHJcbiAqXHJcbiAqICBOb3RlIHRoYXQgQmFzZTU4IGVuY29kZXMgYSAqKm51bWVyaWMqKiB2YWx1ZSwgbm90IGFyYml0cmFyeSBieXRlcyxcclxuICogIHNpbmNlIGFueSB6ZXJvLWJ5dGVzIG9uIHRoZSBsZWZ0IHdvdWxkIGdldCByZW1vdmVkLiBUbyBtaXRpZ2F0ZSB0aGlzXHJcbiAqICBpc3N1ZSBtb3N0IHNjaGVtZXMgdGhhdCB1c2UgQmFzZTU4IGNob29zZSBzcGVjaWZpYyBoaWdoLW9yZGVyIHZhbHVlc1xyXG4gKiAgdG8gZW5zdXJlIG5vbi16ZXJvIHByZWZpeGVzLlxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6QmFzZTU4IEVuY29kaW5nIFthYm91dC1iYXNlNThdXHJcbiAqL1xyXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcclxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcclxuaW1wb3J0IHsgdG9CaWdJbnQgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xyXG5jb25zdCBBbHBoYWJldCA9IFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiO1xyXG5sZXQgTG9va3VwID0gbnVsbDtcclxuZnVuY3Rpb24gZ2V0QWxwaGEobGV0dGVyKSB7XHJcbiAgICBpZiAoTG9va3VwID09IG51bGwpIHtcclxuICAgICAgICBMb29rdXAgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIExvb2t1cFtBbHBoYWJldFtpXV0gPSBCaWdJbnQoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gTG9va3VwW2xldHRlcl07XHJcbiAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQgIT0gbnVsbCwgYGludmFsaWQgYmFzZTU4IHZhbHVlYCwgXCJsZXR0ZXJcIiwgbGV0dGVyKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcclxuY29uc3QgQk5fNTggPSBCaWdJbnQoNTgpO1xyXG4vKipcclxuICogIEVuY29kZSAlJXZhbHVlJSUgYXMgYSBCYXNlNTgtZW5jb2RlZCBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTU4KF92YWx1ZSkge1xyXG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhfdmFsdWUpO1xyXG4gICAgbGV0IHZhbHVlID0gdG9CaWdJbnQoYnl0ZXMpO1xyXG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XHJcbiAgICB3aGlsZSAodmFsdWUpIHtcclxuICAgICAgICByZXN1bHQgPSBBbHBoYWJldFtOdW1iZXIodmFsdWUgJSBCTl81OCldICsgcmVzdWx0O1xyXG4gICAgICAgIHZhbHVlIC89IEJOXzU4O1xyXG4gICAgfVxyXG4gICAgLy8gQWNjb3VudCBmb3IgbGVhZGluZyBwYWRkaW5nIHplcm9zXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGJ5dGVzW2ldKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgPSBBbHBoYWJldFswXSArIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqICBEZWNvZGUgdGhlIEJhc2U1OC1lbmNvZGVkICUldmFsdWUlJS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNTgodmFsdWUpIHtcclxuICAgIGxldCByZXN1bHQgPSBCTl8wO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHJlc3VsdCAqPSBCTl81ODtcclxuICAgICAgICByZXN1bHQgKz0gZ2V0QWxwaGEodmFsdWVbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNTguanMubWFwIiwiLy8gdXRpbHMvYmFzZTY0LWJyb3dzZXJcclxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNjQodGV4dERhdGEpIHtcclxuICAgIHRleHREYXRhID0gYXRvYih0ZXh0RGF0YSk7XHJcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dERhdGEubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dERhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBkYXRhW2ldID0gdGV4dERhdGEuY2hhckNvZGVBdChpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRCeXRlcyhkYXRhKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTY0KF9kYXRhKSB7XHJcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEpO1xyXG4gICAgbGV0IHRleHREYXRhID0gXCJcIjtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRleHREYXRhICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVtpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnRvYSh0ZXh0RGF0YSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LWJyb3dzZXIuanMubWFwIiwiLyoqXHJcbiAqICBFdmVudHMgYWxsb3cgZm9yIGFwcGxpY2F0aW9ucyB0byB1c2UgdGhlIG9ic2VydmVyIHBhdHRlcm4sIHdoaWNoXHJcbiAqICBhbGxvd3Mgc3Vic2NyaWJpbmcgYW5kIHB1Ymxpc2hpbmcgZXZlbnRzLCBvdXRzaWRlIHRoZSBub3JtYWxcclxuICogIGV4ZWN1dGlvbiBwYXRocy5cclxuICpcclxuICogIEBfc2VjdGlvbiBhcGkvdXRpbHMvZXZlbnRzOkV2ZW50cyAgW2Fib3V0LWV2ZW50c11cclxuICovXHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XHJcbi8qKlxyXG4gKiAgV2hlbiBhbiBbW0V2ZW50RW1pdHRlcmFibGVdXSB0cmlnZ2VycyBhIFtbTGlzdGVuZXJdXSwgdGhlXHJcbiAqICBjYWxsYmFjayBhbHdheXMgYWhhcyBvbmUgYWRkaXRpb25hbCBhcmd1bWVudCBwYXNzZWQsIHdoaWNoIGlzXHJcbiAqICBhbiAqKkV2ZW50UGF5bG9hZCoqLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEV2ZW50UGF5bG9hZCB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZXZlbnQgZmlsdGVyLlxyXG4gICAgICovXHJcbiAgICBmaWx0ZXI7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgKipFdmVudEVtaXR0ZXJhYmxlKiouXHJcbiAgICAgKi9cclxuICAgIGVtaXR0ZXI7XHJcbiAgICAjbGlzdGVuZXI7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBuZXcgKipFdmVudFBheWxvYWQqKiBmb3IgJSVlbWl0dGVyJSUgd2l0aFxyXG4gICAgICogIHRoZSAlJWxpc3RlbmVyJSUgYW5kIGZvciAlJWZpbHRlciUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyLCBsaXN0ZW5lciwgZmlsdGVyKSB7XHJcbiAgICAgICAgdGhpcy4jbGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZW1pdHRlciwgZmlsdGVyIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVW5yZWdpc3RlciB0aGUgdHJpZ2dlcmVkIGxpc3RlbmVyIGZvciBmdXR1cmUgZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcigpIHtcclxuICAgICAgICBpZiAodGhpcy4jbGlzdGVuZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHRoaXMuZW1pdHRlci5vZmYodGhpcy5maWx0ZXIsIHRoaXMuI2xpc3RlbmVyKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudHMuanMubWFwIiwiLyoqXHJcbiAqICBVc2luZyBzdHJpbmdzIGluIEV0aGVyZXVtIChvciBhbnkgc2VjdXJpdHktYmFzZCBzeXN0ZW0pIHJlcXVpcmVzXHJcbiAqICBhZGRpdGlvbmFsIGNhcmUuIFRoZXNlIHV0aWxpdGllcyBhdHRlbXB0IHRvIG1pdGlnYXRlIHNvbWUgb2YgdGhlXHJcbiAqICBzYWZldHkgaXNzdWVzIGFzIHdlbGwgYXMgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byByZWNvdmVyIGFuZCBhbmFseXNlXHJcbiAqICBzdHJpbmdzLlxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpTdHJpbmdzIGFuZCBVVEYtOCAgW2Fib3V0LXN0cmluZ3NdXHJcbiAqL1xyXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcclxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIGFzc2VydE5vcm1hbGl6ZSB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xyXG5mdW5jdGlvbiBlcnJvckZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLCBcImJ5dGVzXCIsIGJ5dGVzKTtcclxufVxyXG5mdW5jdGlvbiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcclxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGludmFsaWQgcHJlZml4IChpbmNsdWRpbmcgc3RyYXkgY29udGludWF0aW9uKSwgc2tpcCBhbnkgYWRkaXRpb25hbCBjb250aW51YXRpb24gYnl0ZXNcclxuICAgIGlmIChyZWFzb24gPT09IFwiQkFEX1BSRUZJWFwiIHx8IHJlYXNvbiA9PT0gXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIpIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgbyA9IG9mZnNldCArIDE7IG8gPCBieXRlcy5sZW5ndGg7IG8rKykge1xyXG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaTtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgYnl0ZSBydW5zIHVzIHBhc3QgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzbyBqdXN0IGp1bXAgdG8gdGhlIGVuZFxyXG4gICAgLy8gKGJ1dCB0aGUgZmlyc3QgYnl0ZSB3YXMgcmVhZCBhbHJlYWR5IHJlYWQgYW5kIHRoZXJlZm9yZSBza2lwcGVkKVxyXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSUlVOXCIpIHtcclxuICAgICAgICByZXR1cm4gYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0IC0gMTtcclxuICAgIH1cclxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xyXG4gICAgLy8gT3ZlcmxvbmcgcmVwcmVzZW50YXRpb25zIGFyZSBvdGhlcndpc2UgXCJ2YWxpZFwiIGNvZGUgcG9pbnRzOyBqdXN0IG5vbi1kZWlzdGluZ3Rpc2hlZFxyXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSTE9OR1wiKSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChiYWRDb2RlcG9pbnQpID09PSBcIm51bWJlclwiLCBcImludmFsaWQgYmFkIGNvZGUgcG9pbnQgZm9yIHJlcGxhY2VtZW50XCIsIFwiYmFkQ29kZXBvaW50XCIsIGJhZENvZGVwb2ludCk7XHJcbiAgICAgICAgb3V0cHV0LnB1c2goYmFkQ29kZXBvaW50KTtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8vIFB1dCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGludG8gdGhlIG91dHB1dFxyXG4gICAgb3V0cHV0LnB1c2goMHhmZmZkKTtcclxuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBhcyBpZiBpZ25vcmluZyBlcnJvcnNcclxuICAgIHJldHVybiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpO1xyXG59XHJcbi8qKlxyXG4gKiAgQSBoYW5kZnVsIG9mIHBvcHVsYXIsIGJ1aWx0LWluIFVURi04IGVycm9yIGhhbmRsaW5nIHN0cmF0ZWdpZXMuXHJcbiAqXHJcbiAqICAqKmBgXCJlcnJvclwiYGAqKiAtIHRocm93cyBvbiBBTlkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSBvclxyXG4gKiAgbm9uLWNhbm9uaWNhbCAob3ZlcmxvbmcpIGNvZGVwb2ludHMgKHRoaXMgaXMgdGhlIGRlZmF1bHQpXHJcbiAqXHJcbiAqICAqKmBgXCJpZ25vcmVcImBgKiogLSBzaWxlbnRseSBkcm9wcyBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZVxyXG4gKiAgYW5kIGFjY2VwdHMgbm9uLWNhbm9uaWNhbCAob3ZlcmxvbmcpIGNvZGVwb2ludHNcclxuICpcclxuICogICoqYGBcInJlcGxhY2VcImBgKiogLSByZXBsYWNlIGFueSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlIHdpdGggdGhlXHJcbiAqICBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKGkuZS4gYGBcIlxcXFx1ZmZmZFwiYGApIGFuZCBhY2NlcHRzXHJcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xyXG4gKlxyXG4gKiAgQHJldHVybnM6IFJlY29yZDxcImVycm9yXCIgfCBcImlnbm9yZVwiIHwgXCJyZXBsYWNlXCIsIFV0ZjhFcnJvckZ1bmM+XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVXRmOEVycm9yRnVuY3MgPSBPYmplY3QuZnJlZXplKHtcclxuICAgIGVycm9yOiBlcnJvckZ1bmMsXHJcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXHJcbiAgICByZXBsYWNlOiByZXBsYWNlRnVuY1xyXG59KTtcclxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XHJcbmZ1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKF9ieXRlcywgb25FcnJvcikge1xyXG4gICAgaWYgKG9uRXJyb3IgPT0gbnVsbCkge1xyXG4gICAgICAgIG9uRXJyb3IgPSBVdGY4RXJyb3JGdW5jcy5lcnJvcjtcclxuICAgIH1cclxuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoX2J5dGVzLCBcImJ5dGVzXCIpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICAvLyBJbnZhbGlkIGJ5dGVzIGFyZSBpZ25vcmVkXHJcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xyXG4gICAgICAgIC8vIDB4eHggeHh4eFxyXG4gICAgICAgIGlmIChjID4+IDcgPT09IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xyXG4gICAgICAgIGxldCBleHRyYUxlbmd0aCA9IG51bGw7XHJcbiAgICAgICAgbGV0IG92ZXJsb25nTWFzayA9IG51bGw7XHJcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxyXG4gICAgICAgIGlmICgoYyAmIDB4ZTApID09PSAweGMwKSB7XHJcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMTtcclxuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcclxuICAgICAgICAgICAgLy8gMTExMCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xyXG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDI7XHJcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2ZmO1xyXG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGY4KSA9PT0gMHhmMCkge1xyXG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XHJcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4ZmZmZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICgoYyAmIDB4YzApID09PSAweDgwKSB7XHJcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIkJBRF9QUkVGSVhcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cclxuICAgICAgICBpZiAoaSAtIDEgKyBleHRyYUxlbmd0aCA+PSBieXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1ZFUlJVTlwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGV4dHJhTGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXNbaV07XHJcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcclxuICAgICAgICAgICAgaWYgKChuZXh0Q2hhciAmIDB4YzApICE9IDB4ODApIHtcclxuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk1JU1NJTkdfQ09OVElOVUVcIiwgaSwgYnl0ZXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICByZXMgPSAocmVzIDw8IDYpIHwgKG5leHRDaGFyICYgMHgzZik7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2VlIGFib3ZlIGxvb3AgZm9yIGludmFsaWQgY29udGludWF0aW9uIGJ5dGVcclxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNYXhpbXVtIGNvZGUgcG9pbnRcclxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcclxuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1VUX09GX1JBTkdFXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXNlcnZlZCBmb3IgVVRGLTE2IHN1cnJvZ2F0ZSBoYWx2ZXNcclxuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XHJcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVURjE2X1NVUlJPR0FURVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcclxuICAgICAgICBpZiAocmVzIDw9IG92ZXJsb25nTWFzaykge1xyXG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSTE9OR1wiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggYnl0ZSByZXByZXNlbnRhdGlvbiBvZiAlJXN0ciUlLlxyXG4gKlxyXG4gKiAgSWYgJSVmb3JtJSUgaXMgc3BlY2lmaWVkLCB0aGUgc3RyaW5nIGlzIG5vcm1hbGl6ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSB7XHJcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHN0cikgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBzdHJpbmcgdmFsdWVcIiwgXCJzdHJcIiwgc3RyKTtcclxuICAgIGlmIChmb3JtICE9IG51bGwpIHtcclxuICAgICAgICBhc3NlcnROb3JtYWxpemUoZm9ybSk7XHJcbiAgICAgICAgc3RyID0gc3RyLm5vcm1hbGl6ZShmb3JtKTtcclxuICAgIH1cclxuICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDYpIHwgMHhjMCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09IDB4ZDgwMCkge1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGkgPCBzdHIubGVuZ3RoICYmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApLCBcImludmFsaWQgc3Vycm9nYXRlIHBhaXJcIiwgXCJzdHJcIiwgc3RyKTtcclxuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcclxuICAgICAgICAgICAgY29uc3QgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyID4+IDE4KSB8IDB4ZjApO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgJiAweDNmKSB8IDB4ODApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gMTIpIHwgMHhlMCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcclxufVxyXG47XHJcbi8vZXhwb3J0IFxyXG5mdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpIHtcclxuICAgIHJldHVybiBjb2RlUG9pbnRzLm1hcCgoY29kZVBvaW50KSA9PiB7XHJcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCksICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSk7XHJcbiAgICB9KS5qb2luKFwiXCIpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5IHRoZSBVVEYtOCBkYXRhICUlYnl0ZXMlJS5cclxuICpcclxuICogIFdoZW4gJSVvbkVycm9yJSUgZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCBpcyBjYWxsZWQgb24gVVRGLThcclxuICogIGVycm9ycyBhbGxvd2luZyByZWNvdmVyeSB1c2luZyB0aGUgW1tVdGY4RXJyb3JGdW5jXV0gQVBJLlxyXG4gKiAgKGRlZmF1bHQ6IFtlcnJvcl0oVXRmOEVycm9yRnVuY3MpKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xyXG4gICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcclxufVxyXG4vKipcclxuICogIFJldHVybnMgdGhlIFVURi04IGNvZGUtcG9pbnRzIGZvciAlJXN0ciUlLlxyXG4gKlxyXG4gKiAgSWYgJSVmb3JtJSUgaXMgc3BlY2lmaWVkLCB0aGUgc3RyaW5nIGlzIG5vcm1hbGl6ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Q29kZVBvaW50cyhzdHIsIGZvcm0pIHtcclxuICAgIHJldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCwgbWFrZUVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHZXRVcmwob3B0aW9ucykge1xyXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgX3NpZ25hbCkge1xyXG4gICAgICAgIGFzc2VydChfc2lnbmFsID09IG51bGwgfHwgIV9zaWduYWwuY2FuY2VsbGVkLCBcInJlcXVlc3QgY2FuY2VsbGVkIGJlZm9yZSBzZW5kaW5nXCIsIFwiQ0FOQ0VMTEVEXCIpO1xyXG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gcmVxLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBhc3NlcnQocHJvdG9jb2wgPT09IFwiaHR0cFwiIHx8IHByb3RvY29sID09PSBcImh0dHBzXCIsIGB1bnN1cHBvcnRlZCBwcm90b2NvbCAke3Byb3RvY29sfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgaW5mbzogeyBwcm90b2NvbCB9LFxyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXNzZXJ0KHByb3RvY29sID09PSBcImh0dHBzXCIgfHwgIXJlcS5jcmVkZW50aWFscyB8fCByZXEuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uLCBcImluc2VjdXJlIGF1dGhvcml6ZWQgY29ubmVjdGlvbnMgdW5zdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcclxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGVycm9yID0gbWFrZUVycm9yKFwicmVxdWVzdCB0aW1lb3V0XCIsIFwiVElNRU9VVFwiKTtcclxuICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xyXG4gICAgICAgIH0sIHJlcS50aW1lb3V0KTtcclxuICAgICAgICBpZiAoX3NpZ25hbCkge1xyXG4gICAgICAgICAgICBfc2lnbmFsLmFkZExpc3RlbmVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gbWFrZUVycm9yKFwicmVxdWVzdCBjYW5jZWxsZWRcIiwgXCJDQU5DRUxMRURcIik7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbml0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKEFycmF5LmZyb20ocmVxKSksXHJcbiAgICAgICAgICAgIGJvZHk6IHJlcS5ib2R5IHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCByZXNwO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3AgPSBhd2FpdCBmZXRjaChyZXEudXJsLCBpbml0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IF9lcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XHJcbiAgICAgICAgcmVzcC5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCByZXNwQm9keSA9IGF3YWl0IHJlc3AuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgICBjb25zdCBib2R5ID0gKHJlc3BCb2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHJlc3BCb2R5KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwLnN0YXR1cyxcclxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcC5zdGF0dXNUZXh0LFxyXG4gICAgICAgICAgICBoZWFkZXJzLCBib2R5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRVcmw7XHJcbn1cclxuLy8gQFRPRE86IHJlbW92ZSBpbiB2NzsgcHJvdmlkZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRcclxuY29uc3QgZGVmYXVsdEdldFVybCA9IGNyZWF0ZUdldFVybCh7fSk7XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVcmwocmVxLCBfc2lnbmFsKSB7XHJcbiAgICByZXR1cm4gZGVmYXVsdEdldFVybChyZXEsIF9zaWduYWwpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHVybC1icm93c2VyLmpzLm1hcCIsIi8qKlxyXG4gKiAgRmV0Y2hpbmcgY29udGVudCBmcm9tIHRoZSB3ZWIgaXMgZW52aXJvbm1lbnQtc3BlY2lmaWMsIHNvIEV0aGVyc1xyXG4gKiAgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gdGhhdCBlYWNoIGVudmlyb25tZW50IGNhbiBpbXBsZW1lbnQgdG8gcHJvdmlkZVxyXG4gKiAgdGhpcyBzZXJ2aWNlLlxyXG4gKlxyXG4gKiAgT24gW05vZGUuanNdKGxpbmstbm9kZSksIHRoZSBgYGh0dHBgYCBhbmQgYGBodHRwc2BgIGxpYnMgYXJlIHVzZWQgdG9cclxuICogIGNyZWF0ZSBhIHJlcXVlc3Qgb2JqZWN0LCByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgYW5kIHByb2Nlc3MgZGF0YVxyXG4gKiAgYW5kIHBvcHVsYXRlIHRoZSBbW0ZldGNoUmVzcG9uc2VdXS5cclxuICpcclxuICogIEluIGEgYnJvd3NlciwgdGhlIFtET00gZmV0Y2hdKGxpbmstanMtZmV0Y2gpIGlzIHVzZWQsIGFuZCB0aGUgcmVzdWx0aW5nXHJcbiAqICBgYFByb21pc2VgYCBpcyB3YWl0ZWQgb24gdG8gcmV0cmlldmUgdGhlIHBheWxvYWQuXHJcbiAqXHJcbiAqICBUaGUgW1tGZXRjaFJlcXVlc3RdXSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgbWFueSBjb21tb24gc2l0dWF0aW9ucyxcclxuICogIHN1Y2ggYXMgcmVkaXJlY3RzLCBzZXJ2ZXIgdGhyb3R0bGluZywgYXV0aGVudGljYXRpb24sIGV0Yy5cclxuICpcclxuICogIEl0IGFsc28gaGFuZGxlcyBjb21tb24gZ2F0ZXdheXMsIHN1Y2ggYXMgSVBGUyBhbmQgZGF0YSBVUklzLlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlscy9mZXRjaGluZzpGZXRjaGluZyBXZWIgQ29udGVudCAgW2Fib3V0LWZldGNoXVxyXG4gKi9cclxuaW1wb3J0IHsgZGVjb2RlQmFzZTY0LCBlbmNvZGVCYXNlNjQgfSBmcm9tIFwiLi9iYXNlNjQuanNcIjtcclxuaW1wb3J0IHsgaGV4bGlmeSB9IGZyb20gXCIuL2RhdGEuanNcIjtcclxuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xyXG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIi4vdXRmOC5qc1wiO1xyXG5pbXBvcnQgeyBjcmVhdGVHZXRVcmwgfSBmcm9tIFwiLi9nZXR1cmwuanNcIjtcclxuY29uc3QgTUFYX0FUVEVNUFRTID0gMTI7XHJcbmNvbnN0IFNMT1RfSU5URVJWQUwgPSAyNTA7XHJcbi8vIFRoZSBnbG9iYWwgRmV0Y2hHZXRVcmxGdW5jIGltcGxlbWVudGF0aW9uLlxyXG5sZXQgZGVmYXVsdEdldFVybEZ1bmMgPSBjcmVhdGVHZXRVcmwoKTtcclxuY29uc3QgcmVEYXRhID0gbmV3IFJlZ0V4cChcIl5kYXRhOihbXjs6XSopPyg7YmFzZTY0KT8sKC4qKSRcIiwgXCJpXCIpO1xyXG5jb25zdCByZUlwZnMgPSBuZXcgUmVnRXhwKFwiXmlwZnM6L1xcLyhpcGZzLyk/KC4qKSRcIiwgXCJpXCIpO1xyXG4vLyBJZiBsb2NrZWQsIG5ldyBHYXRld2F5cyBjYW5ub3QgYmUgYWRkZWRcclxubGV0IGxvY2tlZCA9IGZhbHNlO1xyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJMc1xyXG5hc3luYyBmdW5jdGlvbiBkYXRhR2F0ZXdheUZ1bmModXJsLCBzaWduYWwpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVEYXRhKTtcclxuICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDIwMCwgXCJPS1wiLCB7XHJcbiAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IChtYXRjaFsxXSB8fCBcInRleHQvcGxhaW5cIiksXHJcbiAgICAgICAgfSwgKG1hdGNoWzJdID8gZGVjb2RlQmFzZTY0KG1hdGNoWzNdKSA6IHVucGVyY2VudChtYXRjaFszXSkpKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIFwiQkFEIFJFUVVFU1QgKGludmFsaWQgZGF0YTogVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIFJldHVybnMgYSBbW0ZldGNoR2F0ZXdheUZ1bmNdXSBmb3IgZmV0Y2hpbmcgY29udGVudCBmcm9tIGEgc3RhbmRhcmRcclxuICogIElQRlMgZ2F0ZXdheSBob3N0ZWQgYXQgJSViYXNlVXJsJSUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCkge1xyXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2F0ZXdheUlwZnModXJsLCBzaWduYWwpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZUlwZnMpO1xyXG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGxpbmtcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlcXVlc3QoYCR7YmFzZVVybH0ke21hdGNoWzJdfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgXCJCQUQgUkVRVUVTVCAoaW52YWxpZCBJUEZTIFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdhdGV3YXlJcGZzO1xyXG59XHJcbmNvbnN0IEdhdGV3YXlzID0ge1xyXG4gICAgXCJkYXRhXCI6IGRhdGFHYXRld2F5RnVuYyxcclxuICAgIFwiaXBmc1wiOiBnZXRJcGZzR2F0ZXdheUZ1bmMoXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCIpXHJcbn07XHJcbmNvbnN0IGZldGNoU2lnbmFscyA9IG5ldyBXZWFrTWFwKCk7XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBGZXRjaENhbmNlbFNpZ25hbCB7XHJcbiAgICAjbGlzdGVuZXJzO1xyXG4gICAgI2NhbmNlbGxlZDtcclxuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcclxuICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgICAgICBmZXRjaFNpZ25hbHMuc2V0KHJlcXVlc3QsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuI2NhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgbGlzdGVuZXIoKTsgfSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIGFzc2VydCghdGhpcy4jY2FuY2VsbGVkLCBcInNpbmdhbCBhbHJlYWR5IGNhbmNlbGxlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmZXRjaENhbmNlbFNpZ25hbC5hZGRDYW5jZWxMaXN0ZW5lclwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNhbmNlbGxlZCgpIHsgcmV0dXJuIHRoaXMuI2NhbmNlbGxlZDsgfVxyXG4gICAgY2hlY2tTaWduYWwoKSB7XHJcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmNhbmNlbGxlZCwgXCJjYW5jZWxsZWRcIiwgXCJDQU5DRUxMRURcIiwge30pO1xyXG4gICAgfVxyXG59XHJcbi8vIENoZWNrIHRoZSBzaWduYWwsIHRocm93aW5nIGlmIGl0IGlzIGNhbmNlbGxlZFxyXG5mdW5jdGlvbiBjaGVja1NpZ25hbChzaWduYWwpIHtcclxuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgc2lnbmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcclxuICAgIH1cclxuICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xyXG4gICAgcmV0dXJuIHNpZ25hbDtcclxufVxyXG4vKipcclxuICogIFJlcHJlc2VudHMgYSByZXF1ZXN0IGZvciBhIHJlc291cmNlIHVzaW5nIGEgVVJJLlxyXG4gKlxyXG4gKiAgQnkgZGVmYXVsdCwgdGhlIHN1cHBvcnRlZCBzY2hlbWVzIGFyZSBgYEhUVFBgYCwgYGBIVFRQU2BgLCBgYGRhdGE6YGAsXHJcbiAqICBhbmQgYGBJUEZTOmBgLlxyXG4gKlxyXG4gKiAgQWRkaXRpb25hbCBzY2hlbWVzIGNhbiBiZSBhZGRlZCBnbG9iYWxseSB1c2luZyBbW3JlZ2lzdGVyR2F0ZXdheV1dLlxyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QoXCJodHRwczovL3d3dy5yaWNtb28uY29tXCIpXHJcbiAqICAgIHJlc3AgPSBhd2FpdCByZXEuc2VuZCgpXHJcbiAqICAgIHJlc3AuYm9keS5sZW5ndGhcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZldGNoUmVxdWVzdCB7XHJcbiAgICAjYWxsb3dJbnNlY3VyZTtcclxuICAgICNnemlwO1xyXG4gICAgI2hlYWRlcnM7XHJcbiAgICAjbWV0aG9kO1xyXG4gICAgI3RpbWVvdXQ7XHJcbiAgICAjdXJsO1xyXG4gICAgI2JvZHk7XHJcbiAgICAjYm9keVR5cGU7XHJcbiAgICAjY3JlZHM7XHJcbiAgICAvLyBIb29rc1xyXG4gICAgI3ByZWZsaWdodDtcclxuICAgICNwcm9jZXNzO1xyXG4gICAgI3JldHJ5O1xyXG4gICAgI3NpZ25hbDtcclxuICAgICN0aHJvdHRsZTtcclxuICAgICNnZXRVcmxGdW5jO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZldGNoIFVSTCB0byByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBnZXQgdXJsKCkgeyByZXR1cm4gdGhpcy4jdXJsOyB9XHJcbiAgICBzZXQgdXJsKHVybCkge1xyXG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZldGNoIGJvZHksIGlmIGFueSwgdG8gc2VuZCBhcyB0aGUgcmVxdWVzdCBib2R5LiAvLyhkZWZhdWx0OiBudWxsKS8vXHJcbiAgICAgKlxyXG4gICAgICogIFdoZW4gc2V0dGluZyBhIGJvZHksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBhdXRvbWF0aWNhbGx5XHJcbiAgICAgKiAgc2V0IGFuZCB3aWxsIGJlIHVzZWQgaWYgKipub3Qgb3ZlcnJpZGRlbioqIGJ5IHNldHRpbmcgYSBjdXN0b21cclxuICAgICAqICBoZWFkZXIuXHJcbiAgICAgKlxyXG4gICAgICogIElmICUlYm9keSUlIGlzIG51bGwsIHRoZSBib2R5IGlzIGNsZWFyZWQgKGFsb25nIHdpdGggdGhlXHJcbiAgICAgKiAgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGApLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIHN0cmluZywgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIHNldCB0b1xyXG4gICAgICogIGBgdGV4dC9wbGFpbmBgLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIFVpbnQ4QXJyYXksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cclxuICAgICAqICBgYGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbWBgLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhbnkgb3RoZXIgb2JqZWN0LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXNcclxuICAgICAqICBzZXQgdG8gYGBhcHBsaWNhdGlvbi9qc29uYGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBib2R5KCkge1xyXG4gICAgICAgIGlmICh0aGlzLiNib2R5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcclxuICAgIH1cclxuICAgIHNldCBib2R5KGJvZHkpIHtcclxuICAgICAgICBpZiAoYm9keSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhib2R5KTtcclxuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcInRleHQvcGxhaW5cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICAgICAgdGhpcy4jYm9keSA9IGJvZHk7XHJcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChib2R5KSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoSlNPTi5zdHJpbmdpZnkoYm9keSkpO1xyXG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib2R5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBoYXMgYSBib2R5LlxyXG4gICAgICovXHJcbiAgICBoYXNCb2R5KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSAhPSBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBIVFRQIG1ldGhvZCB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHRoZSBVUkkuIElmIG5vIG1ldGhvZFxyXG4gICAgICogIGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0LCB0aGVuIGBgR0VUYGAgaXMgdXNlZCBpZiB0aGUgYm9keSBpc1xyXG4gICAgICogIG51bGwgYW5kIGBgUE9TVGBgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IG1ldGhvZCgpIHtcclxuICAgICAgICBpZiAodGhpcy4jbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtZXRob2Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhhc0JvZHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJQT1NUXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIkdFVFwiO1xyXG4gICAgfVxyXG4gICAgc2V0IG1ldGhvZChtZXRob2QpIHtcclxuICAgICAgICBpZiAobWV0aG9kID09IG51bGwpIHtcclxuICAgICAgICAgICAgbWV0aG9kID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBBbGxcclxuICAgICAqICBrZXlzIGFyZSBsb3dlci1jYXNlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIG9iamVjdCBpcyBhIGNvcHksIHNvIGFueSBjaGFuZ2VzIHdpbGwgKipOT1QqKiBiZSByZWZsZWN0ZWRcclxuICAgICAqICBpbiB0aGUgYGBGZXRjaFJlcXVlc3RgYC5cclxuICAgICAqXHJcbiAgICAgKiAgVG8gc2V0IGEgaGVhZGVyIGVudHJ5LCB1c2UgdGhlIGBgc2V0SGVhZGVyYGAgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBnZXQgaGVhZGVycygpIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XHJcbiAgICAgICAgaWYgKHRoaXMuI2NyZWRzKSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJhc2ljICR7ZW5jb2RlQmFzZTY0KHRvVXRmOEJ5dGVzKHRoaXMuI2NyZWRzKSl9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgICAgIGlmICh0aGlzLmFsbG93R3ppcCkge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdID0gXCJnemlwXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwgJiYgdGhpcy4jYm9keVR5cGUpIHtcclxuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHRoaXMuI2JvZHlUeXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5ib2R5KSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IFN0cmluZyh0aGlzLmJvZHkubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSwgaWdub3JpbmcgY2FzZS5cclxuICAgICAqL1xyXG4gICAgZ2V0SGVhZGVyKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU2V0IHRoZSBoZWFkZXIgZm9yICUla2V5JSUgdG8gJSV2YWx1ZSUlLiBBbGwgdmFsdWVzIGFyZSBjb2VyY2VkXHJcbiAgICAgKiAgdG8gYSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4jaGVhZGVyc1tTdHJpbmcoa2V5KS50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDbGVhciBhbGwgaGVhZGVycywgcmVzZXR0aW5nIGFsbCBpbnRyaW5zaWMgaGVhZGVycy5cclxuICAgICAqL1xyXG4gICAgY2xlYXJIZWFkZXJzKCkge1xyXG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcclxuICAgIH1cclxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2luZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHZhbHVlIHRoYXQgd2lsbCBiZSBzZW50IGZvciB0aGUgYGBBdXRob3JpemF0aW9uYGAgaGVhZGVyLlxyXG4gICAgICpcclxuICAgICAqICBUbyBzZXQgdGhlIGNyZWRlbnRpYWxzLCB1c2UgdGhlIGBgc2V0Q3JlZGVudGlhbHNgYCBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIGdldCBjcmVkZW50aWFscygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jY3JlZHMgfHwgbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFNldHMgYW4gYGBBdXRob3JpemF0aW9uYGAgZm9yICUldXNlcm5hbWUlJSB3aXRoICUlcGFzc3dvcmQlJS5cclxuICAgICAqL1xyXG4gICAgc2V0Q3JlZGVudGlhbHModXNlcm5hbWUsIHBhc3N3b3JkKSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXVzZXJuYW1lLm1hdGNoKC86LyksIFwiaW52YWxpZCBiYXNpYyBhdXRoZW50aWNhdGlvbiB1c2VybmFtZVwiLCBcInVzZXJuYW1lXCIsIFwiW1JFREFDVEVEXVwiKTtcclxuICAgICAgICB0aGlzLiNjcmVkcyA9IGAke3VzZXJuYW1lfToke3Bhc3N3b3JkfWA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBFbmFibGUgYW5kIHJlcXVlc3QgZ3ppcC1lbmNvZGVkIHJlc3BvbnNlcy4gVGhlIHJlc3BvbnNlIHdpbGxcclxuICAgICAqICBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC4gLy8oZGVmYXVsdDogdHJ1ZSkvL1xyXG4gICAgICovXHJcbiAgICBnZXQgYWxsb3dHemlwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNnemlwO1xyXG4gICAgfVxyXG4gICAgc2V0IGFsbG93R3ppcCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI2d6aXAgPSAhIXZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQWxsb3cgYGBBdXRoZW50aWNhdGlvbmBgIGNyZWRlbnRpYWxzIHRvIGJlIHNlbnQgb3ZlciBpbnNlY3VyZVxyXG4gICAgICogIGNoYW5uZWxzLiAvLyhkZWZhdWx0OiBmYWxzZSkvL1xyXG4gICAgICovXHJcbiAgICBnZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuI2FsbG93SW5zZWN1cmU7XHJcbiAgICB9XHJcbiAgICBzZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4jYWxsb3dJbnNlY3VyZSA9ICEhdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKSB0byB3YWl0IGZvciBhIGNvbXBsZXRlIHJlc3BvbnNlLlxyXG4gICAgICogIC8vKGRlZmF1bHQ6IDUgbWludXRlcykvL1xyXG4gICAgICovXHJcbiAgICBnZXQgdGltZW91dCgpIHsgcmV0dXJuIHRoaXMuI3RpbWVvdXQ7IH1cclxuICAgIHNldCB0aW1lb3V0KHRpbWVvdXQpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aW1lb3V0ID49IDAsIFwidGltZW91dCBtdXN0IGJlIG5vbi16ZXJvXCIsIFwidGltZW91dFwiLCB0aW1lb3V0KTtcclxuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHByaW9yIHRvIGVhY2ggcmVxdWVzdCwgZm9yIGV4YW1wbGVcclxuICAgICAqICBkdXJpbmcgYSByZWRpcmVjdGlvbiBvciByZXRyeSBpbiBjYXNlIG9mIHNlcnZlciB0aHJvdHRsaW5nLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIG9mZmVycyBhbiBvcHBvcnR1bml0eSB0byBwb3B1bGF0ZSBoZWFkZXJzIG9yIHVwZGF0ZVxyXG4gICAgICogIGNvbnRlbnQgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBnZXQgcHJlZmxpZ2h0RnVuYygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jcHJlZmxpZ2h0IHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBzZXQgcHJlZmxpZ2h0RnVuYyhwcmVmbGlnaHQpIHtcclxuICAgICAgICB0aGlzLiNwcmVmbGlnaHQgPSBwcmVmbGlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciBlYWNoIHJlc3BvbnNlLCBvZmZlcmluZyBhblxyXG4gICAgICogIG9wcG9ydHVuaXR5IHRvIHByb3ZpZGUgY2xpZW50LWxldmVsIHRocm90dGxpbmcgb3IgdXBkYXRpbmdcclxuICAgICAqICByZXNwb25zZSBkYXRhLlxyXG4gICAgICpcclxuICAgICAqICBBbnkgZXJyb3IgdGhyb3duIGluIHRoaXMgY2F1c2VzIHRoZSBgYHNlbmQoKWBgIHRvIHRocm93LlxyXG4gICAgICpcclxuICAgICAqICBUbyBzY2hlZHVsZSBhIHJldHJ5IGF0dGVtcHQgKGFzc3VtaW5nIHRoZSBtYXhpbXVtIHJldHJ5IGxpbWl0XHJcbiAgICAgKiAgaGFzIG5vdCBiZWVuIHJlYWNoZWQpLCB1c2UgW1tyZXNwb25zZS50aHJvd1Rocm90dGxlRXJyb3JdXS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHByb2Nlc3NGdW5jKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9jZXNzIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBzZXQgcHJvY2Vzc0Z1bmMocHJvY2Vzcykge1xyXG4gICAgICAgIHRoaXMuI3Byb2Nlc3MgPSBwcm9jZXNzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCByZXRyeSBhdHRlbXB0LlxyXG4gICAgICovXHJcbiAgICBnZXQgcmV0cnlGdW5jKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNyZXRyeSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0IHJldHJ5RnVuYyhyZXRyeSkge1xyXG4gICAgICAgIHRoaXMuI3JldHJ5ID0gcmV0cnk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBmZXRjaCBjb250ZW50IGZyb20gSFRUUCBhbmRcclxuICAgICAqICBIVFRQUyBVUkxzIGFuZCBpcyBwbGF0Zm9ybSBzcGVjaWZpYyAoZS5nLiBub2RlanMgdnNcclxuICAgICAqICBicm93c2VycykuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgYnkgZGVmYXVsdCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybFxyXG4gICAgICogIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgY2hhbmdlZCB1c2luZyBbW3JlZ2lzdGVyR2V0VXJsXV0uXHJcbiAgICAgKiAgSWYgdGhpcyBoYXMgYmVlbiBzZXQsIHNldHRpbmcgaXMgdG8gYGBudWxsYGAgd2lsbCBjYXVzZVxyXG4gICAgICogIHRoaXMgRmV0Y2hSZXF1ZXN0IChhbmQgYW55IGZ1dHVyZSBjbG9uZXMpIHRvIHJldmVydCBiYWNrIHRvXHJcbiAgICAgKiAgdXNpbmcgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIGdsb2JhbCBnZXRVcmwgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIFNldHRpbmcgdGhpcyBpcyBnZW5lcmFsbHkgbm90IG5lY2Vzc2FyeSwgYnV0IG1heSBiZSB1c2VmdWxcclxuICAgICAqICBmb3IgZGV2ZWxvcGVycyB0aGF0IHdpc2ggdG8gaW50ZXJjZXB0IHJlcXVlc3RzIG9yIHRvXHJcbiAgICAgKiAgY29uZmlndXJlZ2UgYSBwcm94eSBvciBvdGhlciBhZ2VudC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGdldFVybEZ1bmMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFVybEZ1bmMgfHwgZGVmYXVsdEdldFVybEZ1bmM7XHJcbiAgICB9XHJcbiAgICBzZXQgZ2V0VXJsRnVuYyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyBGZXRjaFJlcXVlc3QgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiAgT25jZSBjcmVhdGVkLCBlYWNoIHByb3BlcnR5IG1heSBiZSBzZXQgYmVmb3JlIGlzc3VpbmcgYVxyXG4gICAgICogIGBgLnNlbmQoKWBgIHRvIG1ha2UgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHVybCkge1xyXG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xyXG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLiNnemlwID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLiNoZWFkZXJzID0ge307XHJcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gXCJcIjtcclxuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gMzAwMDAwO1xyXG4gICAgICAgIHRoaXMuI3Rocm90dGxlID0ge1xyXG4gICAgICAgICAgICBzbG90SW50ZXJ2YWw6IFNMT1RfSU5URVJWQUwsXHJcbiAgICAgICAgICAgIG1heEF0dGVtcHRzOiBNQVhfQVRURU1QVFNcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXF1ZXN0IG1ldGhvZD0ke0pTT04uc3RyaW5naWZ5KHRoaXMubWV0aG9kKX0gdXJsPSR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSBoZWFkZXJzPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKX0gYm9keT0ke3RoaXMuI2JvZHkgPyBoZXhsaWZ5KHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBVcGRhdGUgdGhlIHRocm90dGxlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXRlcm1pbmUgbWF4aW11bVxyXG4gICAgICogIGF0dGVtcHRzIGFuZCBleHBvbmVudGlhbC1iYWNrb2ZmIHByb3BlcnRpZXMuXHJcbiAgICAgKi9cclxuICAgIHNldFRocm90dGxlUGFyYW1zKHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMuc2xvdEludGVydmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsID0gcGFyYW1zLnNsb3RJbnRlcnZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcmFtcy5tYXhBdHRlbXB0cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzID0gcGFyYW1zLm1heEF0dGVtcHRzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jICNzZW5kKGF0dGVtcHQsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgX3Jlc3BvbnNlKSB7XHJcbiAgICAgICAgaWYgKGF0dGVtcHQgPj0gdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJleGNlZWRlZCBtYXhpbXVtIHJldHJ5IGxpbWl0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQoZ2V0VGltZSgpIDw9IGV4cGlyZXMsIFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdC5zZW5kXCIsIHJlYXNvbjogXCJ0aW1lb3V0XCIsIHJlcXVlc3Q6IF9yZXF1ZXN0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xyXG4gICAgICAgICAgICBhd2FpdCB3YWl0KGRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlcSA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICBjb25zdCBzY2hlbWUgPSAocmVxLnVybC5zcGxpdChcIjpcIilbMF0gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAvLyBQcm9jZXNzIGFueSBHYXRld2F5c1xyXG4gICAgICAgIGlmIChzY2hlbWUgaW4gR2F0ZXdheXMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgR2F0ZXdheXNbc2NoZW1lXShyZXEudXJsLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGZXRjaFJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzRnVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzRnVuYyhyZXEsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBwcm9jZXNzaW5nOyB0aHJvdyBhIDV4eCBzZXJ2ZXIgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhyb3R0bGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXEgPSByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGhhdmUgYSBwcmVmbGlnaHQgZnVuY3Rpb247IHVwZGF0ZSB0aGUgcmVxdWVzdFxyXG4gICAgICAgIGlmICh0aGlzLnByZWZsaWdodEZ1bmMpIHtcclxuICAgICAgICAgICAgcmVxID0gYXdhaXQgdGhpcy5wcmVmbGlnaHRGdW5jKHJlcSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmdldFVybEZ1bmMocmVxLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEZldGNoUmVzcG9uc2UocmVzcC5zdGF0dXNDb2RlLCByZXNwLnN0YXR1c01lc3NhZ2UsIHJlc3AuaGVhZGVycywgcmVzcC5ib2R5LCBfcmVxdWVzdCk7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpIHtcclxuICAgICAgICAgICAgLy8gUmVkaXJlY3RcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiB8fCBcIlwiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5yZWRpcmVjdChsb2NhdGlvbikuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIDAsIF9yZXF1ZXN0LCByZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICAgICAgLy8gVGhpbmdzIHdvbid0IGdldCBhbnkgYmV0dGVyIG9uIGFub3RoZXIgYXR0ZW1wdDsgYWJvcnRcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcclxuICAgICAgICAgICAgLy8gVGhyb3R0bGVcclxuICAgICAgICAgICAgaWYgKHRoaXMucmV0cnlGdW5jID09IG51bGwgfHwgKGF3YWl0IHRoaXMucmV0cnlGdW5jKHJlcSwgcmVzcG9uc2UsIGF0dGVtcHQpKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcclxuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCAqIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5QWZ0ZXIpID09PSBcInN0cmluZ1wiICYmIHJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gcGFyc2VJbnQocmV0cnlBZnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKCkuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XHJcbiAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJlcnJvciBpbiBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb25cIiwgZXJyb3IpLmFzc2VydE9rKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaHJvdHRsZVxyXG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsICogTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpO1xyXG4gICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnN0YWxsID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IGVycm9yLnN0YWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSgpLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgYnkgc2VuZGluZyB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgc2VuZCgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy4jc2lnbmFsID09IG51bGwsIFwicmVxdWVzdCBhbHJlYWR5IHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LnNlbmRcIiB9KTtcclxuICAgICAgICB0aGlzLiNzaWduYWwgPSBuZXcgRmV0Y2hDYW5jZWxTaWduYWwodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI3NlbmQoMCwgZ2V0VGltZSgpICsgdGhpcy50aW1lb3V0LCAwLCB0aGlzLCBuZXcgRmV0Y2hSZXNwb25zZSgwLCBcIlwiLCB7fSwgbnVsbCwgdGhpcykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ2FuY2VscyB0aGUgaW5mbGlnaHQgcmVzcG9uc2UsIGNhdXNpbmcgYSBgYENBTkNFTExFRGBgXHJcbiAgICAgKiAgZXJyb3IgdG8gYmUgcmVqZWN0ZWQgZnJvbSB0aGUgW1tzZW5kXV0uXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy4jc2lnbmFsICE9IG51bGwsIFwicmVxdWVzdCBoYXMgbm90IGJlZW4gc2VudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmZXRjaFJlcXVlc3QuY2FuY2VsXCIgfSk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gZmV0Y2hTaWduYWxzLmdldCh0aGlzKTtcclxuICAgICAgICBpZiAoIXNpZ25hbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNpZ25hbCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZldGNoUmVxdWVzdF1dIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVkaXJlY3Rpb25cclxuICAgICAqICB0byAlJWxvY2F0aW9uJSUuXHJcbiAgICAgKi9cclxuICAgIHJlZGlyZWN0KGxvY2F0aW9uKSB7XHJcbiAgICAgICAgLy8gUmVkaXJlY3Rpb247IGZvciBub3cgd2Ugb25seSBzdXBwb3J0IGFic29sdXRlIGxvY2F0aW9uc1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhdGlvbi5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAvLyBEb24ndCBhbGxvdyByZWRpcmVjdGluZzpcclxuICAgICAgICAvLyAtIG5vbi1HRVQgcmVxdWVzdHNcclxuICAgICAgICAvLyAtIGRvd25ncmFkaW5nIHRoZSBzZWN1cml0eSAoZS5nLiBodHRwcyA9PiBodHRwKVxyXG4gICAgICAgIC8vIC0gdG8gbm9uLUhUVFAgKG9yIG5vbi1IVFRQUykgcHJvdG9jb2xzIFt0aGlzIGNvdWxkIGJlIHJlbGF4ZWQ/XVxyXG4gICAgICAgIGFzc2VydCh0aGlzLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiAoY3VycmVudCAhPT0gXCJodHRwc1wiIHx8IHRhcmdldCAhPT0gXCJodHRwXCIpICYmIGxvY2F0aW9uLm1hdGNoKC9eaHR0cHM/Oi8pLCBgdW5zdXBwb3J0ZWQgcmVkaXJlY3RgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlZGlyZWN0KCR7dGhpcy5tZXRob2R9ICR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSA9PiAke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0pYFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyByZXF1ZXN0LCB3aXRoIGEgbmV3IFVSTFxyXG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QobG9jYXRpb24pO1xyXG4gICAgICAgIHJlcS5tZXRob2QgPSBcIkdFVFwiO1xyXG4gICAgICAgIHJlcS5hbGxvd0d6aXAgPSB0aGlzLmFsbG93R3ppcDtcclxuICAgICAgICByZXEudGltZW91dCA9IHRoaXMudGltZW91dDtcclxuICAgICAgICByZXEuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcclxuICAgICAgICBpZiAodGhpcy4jYm9keSkge1xyXG4gICAgICAgICAgICByZXEuI2JvZHkgPSBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVxLiNib2R5VHlwZSA9IHRoaXMuI2JvZHlUeXBlO1xyXG4gICAgICAgIC8vIERvIG5vdCBmb3J3YXJkIGNyZWRlbnRpYWxzIHVubGVzcyBvbiB0aGUgc2FtZSBkb21haW47IG9ubHkgYWJzb2x1dGVcclxuICAgICAgICAvL3JlcS5hbGxvd0luc2VjdXJlID0gZmFsc2U7XHJcbiAgICAgICAgLy8gcGF0aHMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQ7IG1heSB3YW50IGEgd2F5IHRvIHNwZWNpZnkgdG8gZm9yd2FyZD9cclxuICAgICAgICAvL3NldFN0b3JlKHJlcS4jcHJvcHMsIFwiY3JlZHNcIiwgZ2V0U3RvcmUodGhpcy4jcHJvcywgXCJjcmVkc1wiKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyBjb3B5IG9mIHRoaXMgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgRmV0Y2hSZXF1ZXN0KHRoaXMudXJsKTtcclxuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgbWV0aG9kXCIgKGkuZS4gbnVsbClcclxuICAgICAgICBjbG9uZS4jbWV0aG9kID0gdGhpcy4jbWV0aG9kO1xyXG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBib2R5XCIgd2l0aCB0eXBlLCBjb3B5aW5nIHRoZSBVaW50OEFycmF5IGlzIHByZXNlbnRcclxuICAgICAgICBpZiAodGhpcy4jYm9keSkge1xyXG4gICAgICAgICAgICBjbG9uZS4jYm9keSA9IHRoaXMuI2JvZHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsb25lLiNib2R5VHlwZSA9IHRoaXMuI2JvZHlUeXBlO1xyXG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBoZWFkZXJzXCJcclxuICAgICAgICBjbG9uZS4jaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xyXG4gICAgICAgIC8vIENyZWRlbnRpYWxzIGlzIHJlYWRvbmx5LCBzbyB3ZSBjb3B5IGludGVybmFsbHlcclxuICAgICAgICBjbG9uZS4jY3JlZHMgPSB0aGlzLiNjcmVkcztcclxuICAgICAgICBpZiAodGhpcy5hbGxvd0d6aXApIHtcclxuICAgICAgICAgICAgY2xvbmUuYWxsb3dHemlwID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xvbmUudGltZW91dCA9IHRoaXMudGltZW91dDtcclxuICAgICAgICBpZiAodGhpcy5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24pIHtcclxuICAgICAgICAgICAgY2xvbmUuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xvbmUuI3ByZWZsaWdodCA9IHRoaXMuI3ByZWZsaWdodDtcclxuICAgICAgICBjbG9uZS4jcHJvY2VzcyA9IHRoaXMuI3Byb2Nlc3M7XHJcbiAgICAgICAgY2xvbmUuI3JldHJ5ID0gdGhpcy4jcmV0cnk7XHJcbiAgICAgICAgY2xvbmUuI3Rocm90dGxlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jdGhyb3R0bGUpO1xyXG4gICAgICAgIGNsb25lLiNnZXRVcmxGdW5jID0gdGhpcy4jZ2V0VXJsRnVuYztcclxuICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBMb2NrcyBhbGwgc3RhdGljIGNvbmZpZ3VyYXRpb24gZm9yIGdhdGV3YXlzIGFuZCBGZXRjaEdldFVybEZ1bmNcclxuICAgICAqICByZWdpc3RyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBsb2NrQ29uZmlnKCkge1xyXG4gICAgICAgIGxvY2tlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgdGhlIGN1cnJlbnQgR2F0ZXdheSBmdW5jdGlvbiBmb3IgJSVzY2hlbWUlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEdhdGV3YXkoc2NoZW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIEdhdGV3YXlzW3NjaGVtZS50b0xvd2VyQ2FzZSgpXSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVXNlIHRoZSAlJWZ1bmMlJSB3aGVuIGZldGNoaW5nIFVSSXMgdXNpbmcgJSVzY2hlbWUlJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBtZXRob2QgYWZmZWN0cyBhbGwgcmVxdWVzdHMgZ2xvYmFsbHkuXHJcbiAgICAgKlxyXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcclxuICAgICAqICB0aHJvd3MuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZWdpc3RlckdhdGV3YXkoc2NoZW1lLCBmdW5jKSB7XHJcbiAgICAgICAgc2NoZW1lID0gc2NoZW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJodHRwXCIgfHwgc2NoZW1lID09PSBcImh0dHBzXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgaW50ZXJjZXB0ICR7c2NoZW1lfTsgdXNlIHJlZ2lzdGVyR2V0VXJsYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb2NrZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBHYXRld2F5c1tzY2hlbWVdID0gZnVuYztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFVzZSAlJWdldFVybCUlIHdoZW4gZmV0Y2hpbmcgVVJJcyBvdmVyIEhUVFAgYW5kIEhUVFBTIHJlcXVlc3RzLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIG1ldGhvZCBhZmZlY3RzIGFsbCByZXF1ZXN0cyBnbG9iYWxseS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgW1tsb2NrQ29uZmlnXV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjaGFuZ2UgaXMgbWFkZSBhbmQgdGhpc1xyXG4gICAgICogIHRocm93cy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlZ2lzdGVyR2V0VXJsKGdldFVybCkge1xyXG4gICAgICAgIGlmIChsb2NrZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0R2V0VXJsRnVuYyA9IGdldFVybDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBnZXRVcmwgZnVuY3Rpb24gdGhhdCBmZXRjaGVzIGNvbnRlbnQgZnJvbSBIVFRQIGFuZFxyXG4gICAgICogIEhUVFBTIFVSTHMuXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSBhdmFpbGFibGUgJSVvcHRpb25zJSUgYXJlIGRlcGVuZGVudCBvbiB0aGUgcGxhdGZvcm1cclxuICAgICAqICBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGVmYXVsdCBnZXRVcmwgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgbm90IGdlbmVyYWxseSBzb21ldGhpbmcgdGhhdCBpcyBuZWVkZWQsIGJ1dCBpcyB1c2VmdWxcclxuICAgICAqICB3aGVuIHRyeWluZyB0byBjdXN0b21pemUgc2ltcGxlIGJlaGF2aW91ciB3aGVuIGZldGNoaW5nIEhUVFBcclxuICAgICAqICBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlR2V0VXJsRnVuYyhvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUdldFVybChvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBcImZldGNoXCIgZGF0YSBVUklzLlxyXG4gICAgICpcclxuICAgICAqICBOb3RlIHRoYXQgdGhpcyBpcyBhdXRvbWF0aWNhbGx5IGRvbmUgaW50ZXJuYWxseSB0byBzdXBwb3J0XHJcbiAgICAgKiAgZGF0YSBVUklzLCBzbyBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHJlZ2lzdGVyIGl0LlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgbWF5XHJcbiAgICAgKiAgYmUgdXNlZnVsIGluIGEgd3JhcHBlciB0byBwZXJmb20gY3VzdG9tIGRhdGEgVVJJIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVEYXRhR2F0ZXdheSgpIHtcclxuICAgICAgICByZXR1cm4gZGF0YUdhdGV3YXlGdW5jO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBmZXRjaCBJUEZTICh1bnZhbGlkYXRlZCkgZnJvbVxyXG4gICAgICogIGEgY3VzdG9tIGdhdGV3YXkgYmFzZVVybC5cclxuICAgICAqXHJcbiAgICAgKiAgVGhlIGRlZmF1bHQgSVBGUyBnYXRld2F5IHVzZWQgaW50ZXJuYWxseSBpc1xyXG4gICAgICogIGBgXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCJgYC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUlwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldElwZnNHYXRld2F5RnVuYyhiYXNlVXJsKTtcclxuICAgIH1cclxufVxyXG47XHJcbi8qKlxyXG4gKiAgVGhlIHJlc3BvbnNlIGZvciBhIEZldGNoUmVxdWVzdC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBGZXRjaFJlc3BvbnNlIHtcclxuICAgICNzdGF0dXNDb2RlO1xyXG4gICAgI3N0YXR1c01lc3NhZ2U7XHJcbiAgICAjaGVhZGVycztcclxuICAgICNib2R5O1xyXG4gICAgI3JlcXVlc3Q7XHJcbiAgICAjZXJyb3I7XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYDxGZXRjaFJlc3BvbnNlIHN0YXR1cz0ke3RoaXMuc3RhdHVzQ29kZX0gYm9keT0ke3RoaXMuI2JvZHkgPyBoZXhsaWZ5KHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXHJcbiAgICAgKi9cclxuICAgIGdldCBzdGF0dXNDb2RlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzQ29kZTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBnZXQgc3RhdHVzTWVzc2FnZSgpIHsgcmV0dXJuIHRoaXMuI3N0YXR1c01lc3NhZ2U7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSByZXNwb25zZSBoZWFkZXJzLiBBbGwga2V5cyBhcmUgbG93ZXItY2FzZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhlYWRlcnMoKSB7IHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHksIG9yIGBgbnVsbGBgIGlmIHRoZXJlIHdhcyBubyBib2R5LlxyXG4gICAgICovXHJcbiAgICBnZXQgYm9keSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgPT0gbnVsbCkgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSBhcyBhIFVURi04IGVuY29kZWQgc3RyaW5nLCBvciB0aGUgZW1wdHlcclxuICAgICAqICBzdHJpbmcgKGkuZS4gYGBcIlwiYGApIGlmIHRoZXJlIHdhcyBubyBib2R5LlxyXG4gICAgICpcclxuICAgICAqICBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGJvZHkgaXMgaW52YWxpZCBVVEYtOCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBnZXQgYm9keVRleHQoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gXCJcIiA6IHRvVXRmOFN0cmluZyh0aGlzLiNib2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBVVEYtOCBkYXRhXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5VGV4dFwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHksIGRlY29kZWQgYXMgSlNPTi5cclxuICAgICAqXHJcbiAgICAgKiAgQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBib2R5IGlzIGludmFsaWQgSlNPTi1lbmNvZGVkIGRhdGFcclxuICAgICAqICBvciBpZiB0aGVyZSB3YXMgbm8gYm9keS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGJvZHlKc29uKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYm9keVRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIEpTT05cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImJvZHlKc29uXCIsIGluZm86IHsgcmVzcG9uc2U6IHRoaXMgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2tleSwgaGVhZGVyc1trZXldXSwgZG9uZTogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHksIHJlcXVlc3QpIHtcclxuICAgICAgICB0aGlzLiNzdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcclxuICAgICAgICB0aGlzLiNzdGF0dXNNZXNzYWdlID0gc3RhdHVzTWVzc2FnZTtcclxuICAgICAgICB0aGlzLiNoZWFkZXJzID0gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChhY2N1bSwgaykgPT4ge1xyXG4gICAgICAgICAgICBhY2N1bVtrLnRvTG93ZXJDYXNlKCldID0gU3RyaW5nKGhlYWRlcnNba10pO1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgICAgIHRoaXMuI2JvZHkgPSAoKGJvZHkgPT0gbnVsbCkgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkoYm9keSkpO1xyXG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSAocmVxdWVzdCB8fCBudWxsKTtcclxuICAgICAgICB0aGlzLiNlcnJvciA9IHsgbWVzc2FnZTogXCJcIiB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgUmVzcG9uc2Ugd2l0aCBtYXRjaGluZyBoZWFkZXJzIGFuZCBib2R5LCBidXQgd2l0aFxyXG4gICAgICogIGFuIGVycm9yIHN0YXR1cyBjb2RlIChpLmUuIDU5OSkgYW5kICUlbWVzc2FnZSUlIHdpdGggYW5cclxuICAgICAqICBvcHRpb25hbCAlJWVycm9yJSUuXHJcbiAgICAgKi9cclxuICAgIG1ha2VTZXJ2ZXJFcnJvcihtZXNzYWdlLCBlcnJvcikge1xyXG4gICAgICAgIGxldCBzdGF0dXNNZXNzYWdlO1xyXG4gICAgICAgIGlmICghbWVzc2FnZSkge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gYCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gO1xyXG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke21lc3NhZ2V9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9OyAke21lc3NhZ2V9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBzdGF0dXNNZXNzYWdlLCB0aGlzLmhlYWRlcnMsIHRoaXMuYm9keSwgdGhpcy4jcmVxdWVzdCB8fCB1bmRlZmluZWQpO1xyXG4gICAgICAgIHJlc3BvbnNlLiNlcnJvciA9IHsgbWVzc2FnZSwgZXJyb3IgfTtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBJZiBjYWxsZWQgd2l0aGluIGEgW3JlcXVlc3QucHJvY2Vzc0Z1bmNdKEZldGNoUmVxdWVzdC1wcm9jZXNzRnVuYylcclxuICAgICAqICBjYWxsLCBjYXVzZXMgdGhlIHJlcXVlc3QgdG8gcmV0cnkgYXMgaWYgdGhyb3R0bGVkIGZvciAlJXN0YWxsJSVcclxuICAgICAqICBtaWxsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIHRocm93VGhyb3R0bGVFcnJvcihtZXNzYWdlLCBzdGFsbCkge1xyXG4gICAgICAgIGlmIChzdGFsbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YWxsID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YWxsKSAmJiBzdGFsbCA+PSAwLCBcImludmFsaWQgc3RhbGwgdGltZW91dFwiLCBcInN0YWxsXCIsIHN0YWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSB8fCBcInRocm90dGxpbmcgcmVxdWVzdHNcIik7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzdGFsbCwgdGhyb3R0bGU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgdGhlIGhlYWRlciB2YWx1ZSBmb3IgJSVrZXklJSwgaWdub3JpbmcgY2FzZS5cclxuICAgICAqL1xyXG4gICAgZ2V0SGVhZGVyKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSByZXNwb25zZSBoYXMgYSBib2R5LlxyXG4gICAgICovXHJcbiAgICBoYXNCb2R5KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSAhPSBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSByZXF1ZXN0IG1hZGUgZm9yIHRoaXMgcmVzcG9uc2UuXHJcbiAgICAgKi9cclxuICAgIGdldCByZXF1ZXN0KCkgeyByZXR1cm4gdGhpcy4jcmVxdWVzdDsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVzcG9uc2Ugd2FzIGEgc3VjY2VzcyBzdGF0dXNDb2RlLlxyXG4gICAgICovXHJcbiAgICBvaygpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuI2Vycm9yLm1lc3NhZ2UgPT09IFwiXCIgJiYgdGhpcy5zdGF0dXNDb2RlID49IDIwMCAmJiB0aGlzLnN0YXR1c0NvZGUgPCAzMDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhyb3dzIGEgYGBTRVJWRVJfRVJST1JgYCBpZiB0aGlzIHJlc3BvbnNlIGlzIG5vdCBvay5cclxuICAgICAqL1xyXG4gICAgYXNzZXJ0T2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub2soKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IG1lc3NhZ2UsIGVycm9yIH0gPSB0aGlzLiNlcnJvcjtcclxuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gYHNlcnZlciByZXNwb25zZSAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlcXVlc3RVcmwgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcclxuICAgICAgICAgICAgcmVxdWVzdFVybCA9IHRoaXMucmVxdWVzdC51cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXNwb25zZUJvZHkgPSBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLiNib2R5KSB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZUJvZHkgPSB0b1V0ZjhTdHJpbmcodGhpcy4jYm9keSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgIGFzc2VydChmYWxzZSwgbWVzc2FnZSwgXCJTRVJWRVJfRVJST1JcIiwge1xyXG4gICAgICAgICAgICByZXF1ZXN0OiAodGhpcy5yZXF1ZXN0IHx8IFwidW5rbm93biByZXF1ZXN0XCIpLCByZXNwb25zZTogdGhpcywgZXJyb3IsXHJcbiAgICAgICAgICAgIGluZm86IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RVcmwsIHJlc3BvbnNlQm9keSxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlU3RhdHVzOiBgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XHJcbmZ1bmN0aW9uIHVucGVyY2VudCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRvVXRmOEJ5dGVzKHZhbHVlLnJlcGxhY2UoLyUoWzAtOWEtZl1bMC05YS1mXSkvZ2ksIChhbGwsIGNvZGUpID0+IHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjb2RlLCAxNikpO1xyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCIsIi8qKlxyXG4gKiAgVGhlICoqRml4ZWROdW1iZXIqKiBjbGFzcyBwZXJtaXRzIHVzaW5nIHZhbHVlcyB3aXRoIGRlY2ltYWwgcGxhY2VzLFxyXG4gKiAgdXNpbmcgZml4ZWQtcG9udCBtYXRoLlxyXG4gKlxyXG4gKiAgRml4ZWQtcG9pbnQgbWF0aCBpcyBzdGlsbCBiYXNlZCBvbiBpbnRlZ2VycyB1bmRlci10aGUtaG9vZCwgYnV0IHVzZXMgYW5cclxuICogIGludGVybmFsIG9mZnNldCB0byBzdG9yZSBmcmFjdGlvbmFsIGNvbXBvbmVudHMgYmVsb3csIGFuZCBlYWNoIG9wZXJhdGlvblxyXG4gKiAgY29ycmVjdHMgZm9yIHRoaXMgYWZ0ZXIgZWFjaCBvcGVyYXRpb24uXHJcbiAqXHJcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9maXhlZC1wb2ludC1tYXRoOkZpeGVkLVBvaW50IE1hdGhzICBbYWJvdXQtZml4ZWQtcG9pbnQtbWF0aF1cclxuICovXHJcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xyXG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XHJcbmltcG9ydCB7IGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBmcm9tVHdvcywgbWFzaywgdG9CaWdJbnQgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xyXG5jb25zdCBCTl9OMSA9IEJpZ0ludCgtMSk7XHJcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XHJcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XHJcbmNvbnN0IEJOXzUgPSBCaWdJbnQoNSk7XHJcbmNvbnN0IF9ndWFyZCA9IHt9O1xyXG4vLyBDb25zdGFudCB0byBwdWxsIHplcm9zIGZyb20gZm9yIG11bHRpcGxpZXJzXHJcbmxldCBaZXJvcyA9IFwiMDAwMFwiO1xyXG53aGlsZSAoWmVyb3MubGVuZ3RoIDwgODApIHtcclxuICAgIFplcm9zICs9IFplcm9zO1xyXG59XHJcbi8vIFJldHVybnMgYSBzdHJpbmcgXCIxXCIgZm9sbG93ZWQgYnkgZGVjaW1hbCBcIjBcInNcclxuZnVuY3Rpb24gZ2V0VGVucyhkZWNpbWFscykge1xyXG4gICAgbGV0IHJlc3VsdCA9IFplcm9zO1xyXG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBkZWNpbWFscykge1xyXG4gICAgICAgIHJlc3VsdCArPSByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQmlnSW50KFwiMVwiICsgcmVzdWx0LnN1YnN0cmluZygwLCBkZWNpbWFscykpO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrVmFsdWUodmFsLCBmb3JtYXQsIHNhZmVPcCkge1xyXG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZm9ybWF0LndpZHRoKTtcclxuICAgIGlmIChmb3JtYXQuc2lnbmVkKSB7XHJcbiAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XHJcbiAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gLWxpbWl0ICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IHNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh2YWwgPiBCTl8wKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IGZyb21Ud29zKG1hc2sodmFsLCB3aWR0aCksIHdpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbCA9IC1mcm9tVHdvcyhtYXNrKC12YWwsIHdpZHRoKSwgd2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgd2lkdGgpO1xyXG4gICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IDAgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFsID0gKCgodmFsICUgbGltaXQpICsgbGltaXQpICUgbGltaXQpICYgKGxpbWl0IC0gQk5fMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIGdldEZvcm1hdCh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgdmFsdWUgPSBgZml4ZWQxMjh4JHt2YWx1ZX1gO1xyXG4gICAgfVxyXG4gICAgbGV0IHNpZ25lZCA9IHRydWU7XHJcbiAgICBsZXQgd2lkdGggPSAxMjg7XHJcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcclxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIC8vIFBhcnNlIHRoZSBmb3JtYXQgc3RyaW5nXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBcImZpeGVkXCIpIHtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdHMuLi5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwidWZpeGVkXCIpIHtcclxuICAgICAgICAgICAgc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKHU/KWZpeGVkKFswLTldKyl4KFswLTldKykkLyk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoLCBcImludmFsaWQgZml4ZWQgZm9ybWF0XCIsIFwiZm9ybWF0XCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgc2lnbmVkID0gKG1hdGNoWzFdICE9PSBcInVcIik7XHJcbiAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xyXG4gICAgICAgICAgICBkZWNpbWFscyA9IHBhcnNlSW50KG1hdGNoWzNdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHZhbHVlcyBmcm9tIHRoZSBvYmplY3RcclxuICAgICAgICBjb25zdCB2ID0gdmFsdWU7XHJcbiAgICAgICAgY29uc3QgY2hlY2sgPSAoa2V5LCB0eXBlLCBkZWZhdWx0VmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHZba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodltrZXldKSA9PT0gdHlwZSwgXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCAoXCIgKyBrZXkgKyBcIiBub3QgXCIgKyB0eXBlICsgXCIpXCIsIFwiZm9ybWF0LlwiICsga2V5LCB2W2tleV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdltrZXldO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2lnbmVkID0gY2hlY2soXCJzaWduZWRcIiwgXCJib29sZWFuXCIsIHNpZ25lZCk7XHJcbiAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcclxuICAgICAgICBkZWNpbWFscyA9IGNoZWNrKFwiZGVjaW1hbHNcIiwgXCJudW1iZXJcIiwgZGVjaW1hbHMpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoKHdpZHRoICUgOCkgPT09IDAsIFwiaW52YWxpZCBGaXhlZE51bWJlciB3aWR0aCAobm90IGJ5dGUgYWxpZ25lZClcIiwgXCJmb3JtYXQud2lkdGhcIiwgd2lkdGgpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoZGVjaW1hbHMgPD0gODAsIFwiaW52YWxpZCBGaXhlZE51bWJlciBkZWNpbWFscyAodG9vIGxhcmdlKVwiLCBcImZvcm1hdC5kZWNpbWFsc1wiLCBkZWNpbWFscyk7XHJcbiAgICBjb25zdCBuYW1lID0gKHNpZ25lZCA/IFwiXCIgOiBcInVcIikgKyBcImZpeGVkXCIgKyBTdHJpbmcod2lkdGgpICsgXCJ4XCIgKyBTdHJpbmcoZGVjaW1hbHMpO1xyXG4gICAgcmV0dXJuIHsgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMsIG5hbWUgfTtcclxufVxyXG5mdW5jdGlvbiB0b1N0cmluZyh2YWwsIGRlY2ltYWxzKSB7XHJcbiAgICBsZXQgbmVnYXRpdmUgPSBcIlwiO1xyXG4gICAgaWYgKHZhbCA8IEJOXzApIHtcclxuICAgICAgICBuZWdhdGl2ZSA9IFwiLVwiO1xyXG4gICAgICAgIHZhbCAqPSBCTl9OMTtcclxuICAgIH1cclxuICAgIGxldCBzdHIgPSB2YWwudG9TdHJpbmcoKTtcclxuICAgIC8vIE5vIGRlY2ltYWwgcG9pbnQgZm9yIHdob2xlIHZhbHVlc1xyXG4gICAgaWYgKGRlY2ltYWxzID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XHJcbiAgICB9XHJcbiAgICAvLyBQYWQgb3V0IHRvIHRoZSB3aG9sZSBjb21wb25lbnQgKGluY2x1ZGluZyBhIHdob2xlIGRpZ2l0KVxyXG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPD0gZGVjaW1hbHMpIHtcclxuICAgICAgICBzdHIgPSBaZXJvcyArIHN0cjtcclxuICAgIH1cclxuICAgIC8vIEluc2VydCB0aGUgZGVjaW1hbCBwb2ludFxyXG4gICAgY29uc3QgaW5kZXggPSBzdHIubGVuZ3RoIC0gZGVjaW1hbHM7XHJcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGluZGV4KSArIFwiLlwiICsgc3RyLnN1YnN0cmluZyhpbmRleCk7XHJcbiAgICAvLyBUcmltIHRoZSB3aG9sZSBjb21wb25lbnQgKGxlYXZpbmcgYXQgbGVhc3Qgb25lIDApXHJcbiAgICB3aGlsZSAoc3RyWzBdID09PSBcIjBcIiAmJiBzdHJbMV0gIT09IFwiLlwiKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygxKTtcclxuICAgIH1cclxuICAgIC8vIFRyaW0gdGhlIGRlY2ltYWwgY29tcG9uZW50IChsZWF2aW5nIGF0IGxlYXN0IG9uZSAwKVxyXG4gICAgd2hpbGUgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09IFwiMFwiICYmIHN0cltzdHIubGVuZ3RoIC0gMl0gIT09IFwiLlwiKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKG5lZ2F0aXZlICsgc3RyKTtcclxufVxyXG4vKipcclxuICogIEEgRml4ZWROdW1iZXIgcmVwcmVzZW50cyBhIHZhbHVlIG92ZXIgaXRzIFtbRml4ZWRGb3JtYXRdXVxyXG4gKiAgYXJpdGhtZXRpYyBmaWVsZC5cclxuICpcclxuICogIEEgRml4ZWROdW1iZXIgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBtYXRoLCBsb3NzbGVzc2x5LCBvblxyXG4gKiAgdmFsdWVzIHdoaWNoIGhhdmUgZGVjbWlhbCBwbGFjZXMuXHJcbiAqXHJcbiAqICBBIEZpeGVkTnVtYmVyIGhhcyBhIGZpeGVkIGJpdC13aWR0aCB0byBzdG9yZSB2YWx1ZXMgaW4sIGFuZCBzdG9yZXMgYWxsXHJcbiAqICB2YWx1ZXMgaW50ZXJuYWxseSBieSBtdWx0aXBseWluZyB0aGUgdmFsdWUgYnkgMTAgcmFpc2VkIHRvIHRoZSBwb3dlciBvZlxyXG4gKiAgJSVkZWNpbWFscyUlLlxyXG4gKlxyXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBncm93IHRvbyBoaWdoIChjbG9zZSB0b1xyXG4gKiAgcG9zaXRpdmUgaW5maW5pdHkpIG9yIHRvbyBsb3cgKGNsb3NlIHRvIG5lZ2F0aXZlIGluZmluaXR5KSwgdGhlIHZhbHVlXHJcbiAqICBpcyBzYWlkIHRvIC8vb3ZlcmZsb3cvLy5cclxuICpcclxuICogIEZvciBleGFtcGxlLCBhbiA4LWJpdCBzaWduZWQgdmFsdWUsIHdpdGggMCBkZWNpbWFscyBtYXkgb25seSBiZSB3aXRoaW5cclxuICogIHRoZSByYW5nZSBgYC0xMjhgYCB0byBgYDEyN2BgOyBzbyBgYC0xMjggLSAxYGAgd2lsbCBvdmVyZmxvdyBhbmQgYmVjb21lXHJcbiAqICBgYDEyN2BgLiBMaWtld2lzZSwgYGAxMjcgKyAxYGAgd2lsbCBvdmVyZmxvdyBhbmQgYmVjb21lIGBgLTEyN2BgLlxyXG4gKlxyXG4gKiAgTWFueSBvcGVyYXRpb24gaGF2ZSBhIG5vcm1hbCBhbmQgLy91bnNhZmUvLyB2YXJpYW50LiBUaGUgbm9ybWFsIHZhcmlhbnRcclxuICogIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gYW55IG92ZXJmbG93LCB3aGlsZSB0aGUgLy91bnNhZmUvL1xyXG4gKiAgdmFyaWFudCB3aWxsIHNpbGVudGx5IGFsbG93IG92ZXJmbG93LCBjb3JydXB0aW5nIGl0cyB2YWx1ZSB2YWx1ZS5cclxuICpcclxuICogIElmIG9wZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCB0aGF0IGNhdXNlIGEgdmFsdWUgdG8gYmVjb21lIHRvbyBzbWFsbFxyXG4gKiAgKGNsb3NlIHRvIHplcm8pLCB0aGUgdmFsdWUgbG9zZXMgcHJlY2lzb24gYW5kIGlzIHNhaWQgdG8gLy91bmRlcmZsb3cvLy5cclxuICpcclxuICogIEZvciBleGFtcGxlLCBhIHZhbHVlIHdpdGggMSBkZWNpbWFsIHBsYWNlIG1heSBzdG9yZSBhIG51bWJlciBhcyBzbWFsbFxyXG4gKiAgYXMgYGAwLjFgYCwgYnV0IHRoZSB2YWx1ZSBvZiBgYDAuMSAvIDJgYCBpcyBgYDAuMDVgYCwgd2hpY2ggY2Fubm90IGZpdFxyXG4gKiAgaW50byAxIGRlY2ltYWwgcGxhY2UsIHNvIHVuZGVyZmxvdyBvY2N1cnMgd2hpY2ggbWVhbnMgcHJlY2lzaW9uIGlzIGxvc3RcclxuICogIGFuZCB0aGUgdmFsdWUgYmVjb21lcyBgYDBgYC5cclxuICpcclxuICogIFNvbWUgb3BlcmF0aW9ucyBoYXZlIGEgbm9ybWFsIGFuZCAvL3NpZ25hbGxpbmcvLyB2YXJpYW50LiBUaGUgbm9ybWFsXHJcbiAqICB2YXJpYW50IHdpbGwgc2lsZW50bHkgaWdub3JlIHVuZGVyZmxvdywgd2hpbGUgdGhlIC8vc2lnbmFsbGluZy8vIHZhcmlhbnRcclxuICogIHdpbGwgdGhvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiB1bmRlcmZsb3cuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRml4ZWROdW1iZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHNwZWNpZmljIGZpeGVkLXBvaW50IGFyaXRobWV0aWMgZmllbGQgZm9yIHRoaXMgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdDtcclxuICAgICNmb3JtYXQ7XHJcbiAgICAvLyBUaGUgYWN0dWFsIHZhbHVlIChhY2NvdW50aW5nIGZvciBkZWNpbWFscylcclxuICAgICN2YWw7XHJcbiAgICAvLyBBIGJhc2UtMTAgdmFsdWUgdG8gbXVsdGlwbGUgdmFsdWVzIGJ5IHRvIG1haW50YWluIHRoZSBtYWduaXR1ZGVcclxuICAgICN0ZW5zO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhpcyBpcyBhIHByb3BlcnR5IHNvIGNvbnNvbGUubG9nIHNob3dzIGEgaHVtYW4tbWVhbmluZ2Z1bCB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3ZhbHVlO1xyXG4gICAgLy8gVXNlIHRoaXMgd2hlbiBjaGFuZ2luZyB0aGlzIGZpbGUgdG8gZ2V0IHNvbWUgdHlwaW5nIGluZm8sXHJcbiAgICAvLyBidXQgdGhlbiBzd2l0Y2ggdG8gYW55IHRvIG1hc2sgdGhlIGludGVybmFsIHR5cGVcclxuICAgIC8vY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgdmFsdWU6IGJpZ2ludCwgZm9ybWF0OiBfRml4ZWRGb3JtYXQpIHtcclxuICAgIC8qKlxyXG4gICAgICogIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB2YWx1ZSwgZm9ybWF0KSB7XHJcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIkZpeGVkTnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuI3ZhbCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuI2Zvcm1hdCA9IGZvcm1hdDtcclxuICAgICAgICBjb25zdCBfdmFsdWUgPSB0b1N0cmluZyh2YWx1ZSwgZm9ybWF0LmRlY2ltYWxzKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZm9ybWF0OiBmb3JtYXQubmFtZSwgX3ZhbHVlIH0pO1xyXG4gICAgICAgIHRoaXMuI3RlbnMgPSBnZXRUZW5zKGZvcm1hdC5kZWNpbWFscyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBJZiB0cnVlLCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIHBlcm1pdHRlZCwgb3RoZXJ3aXNlIG9ubHlcclxuICAgICAqICBwb3NpdGl2ZSB2YWx1ZXMgYW5kIHplcm8gYXJlIGFsbG93ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldCBzaWduZWQoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQuc2lnbmVkOyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbnVtYmVyIG9mIGJpdHMgYXZhaWxhYmxlIHRvIHN0b3JlIHRoZSB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LndpZHRoOyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGluIHRoZSBmaXhlZC1wb2ludCBhcml0aG1lbnQgZmllbGQuXHJcbiAgICAgKi9cclxuICAgIGdldCBkZWNpbWFscygpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC5kZWNpbWFsczsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHZhbHVlIGFzIGFuIGludGVnZXIsIGJhc2VkIG9uIHRoZSBzbWFsbGVzdCB1bml0IHRoZVxyXG4gICAgICogIFtbZGVjaW1hbHNdXSBhbGxvdy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy4jdmFsOyB9XHJcbiAgICAjY2hlY2tGb3JtYXQob3RoZXIpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aGlzLmZvcm1hdCA9PT0gb3RoZXIuZm9ybWF0LCBcImluY29tcGF0aWJsZSBmb3JtYXQ7IHVzZSBmaXhlZE51bWJlci50b0Zvcm1hdFwiLCBcIm90aGVyXCIsIG90aGVyKTtcclxuICAgIH1cclxuICAgICNjaGVja1ZhbHVlKHZhbCwgc2FmZU9wKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KHRoaXMud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gLWxpbWl0ICAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPiBCTl8wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZyb21Ud29zKG1hc2sodmFsLCB3aWR0aCksIHdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAtZnJvbVR3b3MobWFzaygtdmFsLCB3aWR0aCksIHdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hc2tlZCA9IG1hc2sodmFsLCB3aWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gMCAmJiB2YWwgPT09IG1hc2tlZCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG1hc2tlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAqL1xyXG4gICAgICAgIHZhbCA9IGNoZWNrVmFsdWUodmFsLCB0aGlzLiNmb3JtYXQsIHNhZmVPcCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbCwgdGhpcy4jZm9ybWF0KTtcclxuICAgIH1cclxuICAgICNhZGQobywgc2FmZU9wKSB7XHJcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodGhpcy4jdmFsICsgby4jdmFsLCBzYWZlT3ApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGFkZGVkXHJcbiAgICAgKiAgdG8gJSVvdGhlciUlLCBpZ25vcmluZyBvdmVyZmxvdy5cclxuICAgICAqL1xyXG4gICAgYWRkVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNhZGQob3RoZXIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgYWRkZWRcclxuICAgICAqICB0byAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xyXG4gICAgICogIG9jY3Vycy5cclxuICAgICAqL1xyXG4gICAgYWRkKG90aGVyKSB7IHJldHVybiB0aGlzLiNhZGQob3RoZXIsIFwiYWRkXCIpOyB9XHJcbiAgICAjc3ViKG8sIHNhZmVPcCkge1xyXG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHRoaXMuI3ZhbCAtIG8uI3ZhbCwgc2FmZU9wKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxyXG4gICAgICogIGZyb20gJSV0aGlzJSUsIGlnbm9yaW5nIG92ZXJmbG93LlxyXG4gICAgICovXHJcbiAgICBzdWJVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI3N1YihvdGhlcik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxyXG4gICAgICogIGZyb20gJSV0aGlzJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xyXG4gICAgICogIG9jY3Vycy5cclxuICAgICAqL1xyXG4gICAgc3ViKG90aGVyKSB7IHJldHVybiB0aGlzLiNzdWIob3RoZXIsIFwic3ViXCIpOyB9XHJcbiAgICAjbXVsKG8sIHNhZmVPcCkge1xyXG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKCh0aGlzLiN2YWwgKiBvLiN2YWwpIC8gdGhpcy4jdGVucywgc2FmZU9wKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBtdWx0aXBsaWVkXHJcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyBvdmVyZmxvdyBhbmQgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuXHJcbiAgICAgKi9cclxuICAgIG11bFVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jbXVsKG90aGVyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcclxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xyXG4gICAgICogIG9jY3Vycy5cclxuICAgICAqL1xyXG4gICAgbXVsKG90aGVyKSB7IHJldHVybiB0aGlzLiNtdWwob3RoZXIsIFwibXVsXCIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxyXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XHJcbiAgICAgKiAgb2NjdXJzIG9yIGlmIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpIG9jY3Vycy5cclxuICAgICAqL1xyXG4gICAgbXVsU2lnbmFsKG90aGVyKSB7XHJcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQob3RoZXIpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmFsICogb3RoZXIuI3ZhbDtcclxuICAgICAgICBhc3NlcnQoKHZhbHVlICUgdGhpcy4jdGVucykgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgbXVsXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJtdWxTaWduYWxcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiB0aGlzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyB0aGlzLiN0ZW5zLCBcIm11bFNpZ25hbFwiKTtcclxuICAgIH1cclxuICAgICNkaXYobywgc2FmZU9wKSB7XHJcbiAgICAgICAgYXNzZXJ0KG8uI3ZhbCAhPT0gQk5fMCwgXCJkaXZpc2lvbiBieSB6ZXJvXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkaXZcIiwgZmF1bHQ6IFwiZGl2aWRlLWJ5LXplcm9cIiwgdmFsdWU6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcclxuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSgodGhpcy4jdmFsICogdGhpcy4jdGVucykgLyBvLiN2YWwsIHNhZmVPcCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxyXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcclxuICAgICAqICBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93IG9jY3Vycy5cclxuICAgICAqL1xyXG4gICAgZGl2VW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxyXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcclxuICAgICAqICBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93IG9jY3Vycy5cclxuICAgICAqL1xyXG4gICAgZGl2KG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIsIFwiZGl2XCIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxyXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIHVuZGVyZmxvd1xyXG4gICAgICogIChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxyXG4gICAgICovXHJcbiAgICBkaXZTaWduYWwob3RoZXIpIHtcclxuICAgICAgICBhc3NlcnQob3RoZXIuI3ZhbCAhPT0gQk5fMCwgXCJkaXZpc2lvbiBieSB6ZXJvXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkaXZcIiwgZmF1bHQ6IFwiZGl2aWRlLWJ5LXplcm9cIiwgdmFsdWU6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSAodGhpcy4jdmFsICogdGhpcy4jdGVucyk7XHJcbiAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIG90aGVyLiN2YWwpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIGRpdlwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2U2lnbmFsXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogdGhpc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gb3RoZXIuI3ZhbCwgXCJkaXZTaWduYWxcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgY29tcGFyaXNvbiByZXN1bHQgYmV0d2VlbiAlJXRoaXMlJSBhbmQgJSVvdGhlciUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIHN1aXRhYmxlIGZvciB1c2UgaW4gc29ydGluZywgd2hlcmUgYGAtMWBgIGltcGxpZXMgJSV0aGlzJSVcclxuICAgICAqICBpcyBzbWFsbGVyLCBgYDFgYCBpbXBsaWVzICUldGhpcyUlIGlzIGxhcmdlciBhbmQgYGAwYGAgaW1wbGllc1xyXG4gICAgICogIGJvdGggYXJlIGVxdWFsLlxyXG4gICAgICovXHJcbiAgICBjbXAob3RoZXIpIHtcclxuICAgICAgICBsZXQgYSA9IHRoaXMudmFsdWUsIGIgPSBvdGhlci52YWx1ZTtcclxuICAgICAgICAvLyBDb2VyY2UgYSBhbmQgYiB0byB0aGUgc2FtZSBtYWduaXR1ZGVcclxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBvdGhlci5kZWNpbWFscztcclxuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XHJcbiAgICAgICAgICAgIGIgKj0gZ2V0VGVucyhkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xyXG4gICAgICAgICAgICBhICo9IGdldFRlbnMoLWRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29tbnBhcmVcclxuICAgICAgICBpZiAoYSA8IGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYSA+IGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBlcXVhbCB0byAlJXRoaXMlJS5cclxuICAgICAqL1xyXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA9PT0gMDsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gdG8gJSV0aGlzJSUuXHJcbiAgICAgKi9cclxuICAgIGx0KG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPCAwOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cclxuICAgICAqL1xyXG4gICAgbHRlKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPD0gMDsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBncmVhdGVyIHRoYW4gdG8gJSV0aGlzJSUuXHJcbiAgICAgKi9cclxuICAgIGd0KG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPiAwOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cclxuICAgICAqL1xyXG4gICAgZ3RlKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPj0gMDsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIGxhcmdlc3QgKippbnRlZ2VyKipcclxuICAgICAqICB0aGF0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhlIGRlY2ltYWwgY29tcG9uZW50IG9mIHRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgYGAwYGAuXHJcbiAgICAgKi9cclxuICAgIGZsb29yKCkge1xyXG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XHJcbiAgICAgICAgaWYgKHRoaXMuI3ZhbCA8IEJOXzApIHtcclxuICAgICAgICAgICAgdmFsIC09IHRoaXMuI3RlbnMgLSBCTl8xO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWwgPSAodGhpcy4jdmFsIC8gdGhpcy4jdGVucykgKiB0aGlzLiN0ZW5zO1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJmbG9vclwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBzbWFsbGVzdCAqKmludGVnZXIqKlxyXG4gICAgICogIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGUgZGVjaW1hbCBjb21wb25lbnQgb2YgdGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBgYDBgYC5cclxuICAgICAqL1xyXG4gICAgY2VpbGluZygpIHtcclxuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xyXG4gICAgICAgIGlmICh0aGlzLiN2YWwgPiBCTl8wKSB7XHJcbiAgICAgICAgICAgIHZhbCArPSB0aGlzLiN0ZW5zIC0gQk5fMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsID0gKHRoaXMuI3ZhbCAvIHRoaXMuI3RlbnMpICogdGhpcy4jdGVucztcclxuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh2YWwsIFwiY2VpbGluZ1wiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIGRlY2ltYWwgY29tcG9uZW50XHJcbiAgICAgKiAgcm91bmRlZCB1cCBvbiB0aWVzIGF0ICUlZGVjaW1hbHMlJSBwbGFjZXMuXHJcbiAgICAgKi9cclxuICAgIHJvdW5kKGRlY2ltYWxzKSB7XHJcbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3QgZW5vdWdoIHByZWNpc2lvbiB0byBub3QgYWxyZWFkeSBiZSByb3VuZGVkXHJcbiAgICAgICAgaWYgKGRlY2ltYWxzID49IHRoaXMuZGVjaW1hbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIGRlY2ltYWxzO1xyXG4gICAgICAgIGNvbnN0IGJ1bXAgPSBCTl81ICogZ2V0VGVucyhkZWx0YSAtIDEpO1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWUgKyBidW1wO1xyXG4gICAgICAgIGNvbnN0IHRlbnMgPSBnZXRUZW5zKGRlbHRhKTtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAvIHRlbnMpICogdGVucztcclxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCB0aGlzLiNmb3JtYXQsIFwicm91bmRcIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCB0aGlzLiNmb3JtYXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGVxdWFsIHRvIGBgMGBgLlxyXG4gICAgICovXHJcbiAgICBpc1plcm8oKSB7IHJldHVybiAodGhpcy4jdmFsID09PSBCTl8wKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGxlc3MgdGhhbiBgYDBgYC5cclxuICAgICAqL1xyXG4gICAgaXNOZWdhdGl2ZSgpIHsgcmV0dXJuICh0aGlzLiN2YWwgPCBCTl8wKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mICUldGhpcyUlLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgZmxvYXQgYXBwcm94aW1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiAgRHVlIHRvIElFRUUgNzU0IHByZWNpc3Npb24gKG9yIGxhY2sgdGhlcmVvZiksIHRoaXMgZnVuY3Rpb25cclxuICAgICAqICBjYW4gb25seSByZXR1cm4gYW4gYXBwcm94aW1hdGlvbiBhbmQgbW9zdCB2YWx1ZXMgd2lsbCBjb250YWluXHJcbiAgICAgKiAgcm91bmRpbmcgZXJyb3JzLlxyXG4gICAgICovXHJcbiAgICB0b1Vuc2FmZUZsb2F0KCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnRvU3RyaW5nKCkpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHNhbWUgdmFsdWUgYnV0IGhhcyBoYWRcclxuICAgICAqICBpdHMgZmllbGQgc2V0IHRvICUlZm9ybWF0JSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGUgdmFsdWUgY2Fubm90IGZpdCBpbnRvICUlZm9ybWF0JSUuXHJcbiAgICAgKi9cclxuICAgIHRvRm9ybWF0KGZvcm1hdCkge1xyXG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHRoaXMudG9TdHJpbmcoKSwgZm9ybWF0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIGZvciAlJXZhbHVlJSUgZGl2aWRlZCBieVxyXG4gICAgICogICUlZGVjaW1hbCUlIHBsYWNlcyB3aXRoICUlZm9ybWF0JSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgKG9uY2UgYWRqdXN0ZWRcclxuICAgICAqICBmb3IgJSVkZWNpbWFscyUlKSBjYW5ub3QgZml0IGluICUlZm9ybWF0JSUsIGVpdGhlciBkdWUgdG8gb3ZlcmZsb3dcclxuICAgICAqICBvciB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21WYWx1ZShfdmFsdWUsIF9kZWNpbWFscywgX2Zvcm1hdCkge1xyXG4gICAgICAgIGNvbnN0IGRlY2ltYWxzID0gKF9kZWNpbWFscyA9PSBudWxsKSA/IDAgOiBnZXROdW1iZXIoX2RlY2ltYWxzKTtcclxuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcclxuICAgICAgICBjb25zdCBkZWx0YSA9IGRlY2ltYWxzIC0gZm9ybWF0LmRlY2ltYWxzO1xyXG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgdGVucyA9IGdldFRlbnMoZGVsdGEpO1xyXG4gICAgICAgICAgICBhc3NlcnQoKHZhbHVlICUgdGVucykgPT09IEJOXzAsIFwidmFsdWUgbG9zZXMgcHJlY2lzaW9uIGZvciBmb3JtYXRcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVmFsdWVcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhbHVlIC89IHRlbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xyXG4gICAgICAgICAgICB2YWx1ZSAqPSBnZXRUZW5zKC1kZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tVmFsdWVcIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gZm9yICUldmFsdWUlJSB3aXRoICUlZm9ybWF0JSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgY2Fubm90IGZpdFxyXG4gICAgICogIGluICUlZm9ybWF0JSUsIGVpdGhlciBkdWUgdG8gb3ZlcmZsb3cgb3IgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKF92YWx1ZSwgX2Zvcm1hdCkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gX3ZhbHVlLm1hdGNoKC9eKC0/KShbMC05XSopXFwuPyhbMC05XSopJC8pO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoICYmIChtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGgpID4gMCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHN0cmluZyB2YWx1ZVwiLCBcInZhbHVlXCIsIF92YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xyXG4gICAgICAgIGxldCB3aG9sZSA9IChtYXRjaFsyXSB8fCBcIjBcIiksIGRlY2ltYWwgPSAobWF0Y2hbM10gfHwgXCJcIik7XHJcbiAgICAgICAgLy8gUGFkIG91dCB0aGUgZGVjaW1hbHNcclxuICAgICAgICB3aGlsZSAoZGVjaW1hbC5sZW5ndGggPCBmb3JtYXQuZGVjaW1hbHMpIHtcclxuICAgICAgICAgICAgZGVjaW1hbCArPSBaZXJvcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgcHJlY2lzaW9uIGlzIHNhZmVcclxuICAgICAgICBhc3NlcnQoZGVjaW1hbC5zdWJzdHJpbmcoZm9ybWF0LmRlY2ltYWxzKS5tYXRjaCgvXjAqJC8pLCBcInRvbyBtYW55IGRlY2ltYWxzIGZvciBmb3JtYXRcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyb21TdHJpbmdcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBSZW1vdmUgZXh0cmEgcGFkZGluZ1xyXG4gICAgICAgIGRlY2ltYWwgPSBkZWNpbWFsLnN1YnN0cmluZygwLCBmb3JtYXQuZGVjaW1hbHMpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KG1hdGNoWzFdICsgd2hvbGUgKyBkZWNpbWFsKTtcclxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbVN0cmluZ1wiKTtcclxuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBiaWctZW5kaWFuIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKiAgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSBjYW5ub3QgZml0XHJcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSBkdWUgdG8gb3ZlcmZsb3cuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoX3ZhbHVlLCBfZm9ybWF0KSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gdG9CaWdJbnQoZ2V0Qnl0ZXMoX3ZhbHVlLCBcInZhbHVlXCIpKTtcclxuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XHJcbiAgICAgICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBmcm9tVHdvcyh2YWx1ZSwgZm9ybWF0LndpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21CeXRlc1wiKTtcclxuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XHJcbiAgICB9XHJcbn1cclxuLy9jb25zdCBmMSA9IEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoXCIxMi41NlwiLCBcImZpeGVkMTZ4MlwiKTtcclxuLy9jb25zdCBmMiA9IEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoXCIwLjNcIiwgXCJmaXhlZDE2eDJcIik7XHJcbi8vY29uc29sZS5sb2coZjEuZGl2U2lnbmFsKGYyKSk7XHJcbi8vY29uc3QgQlVNUCA9IEZpeGVkTnVtYmVyLmZyb20oXCIwLjVcIik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkbnVtYmVyLmpzLm1hcCIsIi8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxyXG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xyXG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XHJcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xyXG5mdW5jdGlvbiBoZXhsaWZ5Qnl0ZSh2YWx1ZSkge1xyXG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcclxuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgMikge1xyXG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBjaGlsZE9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCBjaGlsZE9mZnNldCk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xyXG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XHJcbiAgICAgICAgYXNzZXJ0KGNoaWxkT2Zmc2V0IDw9IG9mZnNldCArIDEgKyBsZW5ndGgsIFwiY2hpbGQgZGF0YSB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoLCBvZmZzZXRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XHJcbn1cclxuLy8gcmV0dXJucyB7IGNvbnN1bWVkOiBudW1iZXIsIHJlc3VsdDogT2JqZWN0IH1cclxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcclxuICAgIGFzc2VydChkYXRhLmxlbmd0aCAhPT0gMCwgXCJkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcclxuICAgICAgICBidWZmZXI6IGRhdGEsIGxlbmd0aDogMCwgb2Zmc2V0OiAxXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNoZWNrT2Zmc2V0ID0gKG9mZnNldCkgPT4ge1xyXG4gICAgICAgIGFzc2VydChvZmZzZXQgPD0gZGF0YS5sZW5ndGgsIFwiZGF0YSBzaG9ydCBzZWdtZW50IHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcclxuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IGRhdGEubGVuZ3RoLCBvZmZzZXRcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBBcnJheSB3aXRoIGV4dHJhIGxlbmd0aCBwcmVmaXhcclxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Zjc7XHJcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcclxuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGMwKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcclxuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSwgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhiNztcclxuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xyXG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XHJcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcclxuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBoZXhsaWZ5KGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMSArIGxlbmd0aCkpO1xyXG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBjb25zdW1lZDogMSwgcmVzdWx0OiBoZXhsaWZ5Qnl0ZShkYXRhW29mZnNldF0pIH07XHJcbn1cclxuLyoqXHJcbiAqICBEZWNvZGVzICUlZGF0YSUlIGludG8gdGhlIHN0cnVjdHVyZWQgZGF0YSBpdCByZXByZXNlbnRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVJscChfZGF0YSkge1xyXG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XHJcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCAwKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KGRlY29kZWQuY29uc3VtZWQgPT09IGRhdGEubGVuZ3RoLCBcInVuZXhwZWN0ZWQganVuayBhZnRlciBybHAgcGF5bG9hZFwiLCBcImRhdGFcIiwgX2RhdGEpO1xyXG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJscC1kZWNvZGUuanMubWFwIiwiLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXHJcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xyXG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgd2hpbGUgKHZhbHVlKSB7XHJcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcclxuICAgICAgICB2YWx1ZSA+Pj0gODtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcclxuICAgICAgICBsZXQgcGF5bG9hZCA9IFtdO1xyXG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5jb25jYXQoX2VuY29kZShjaGlsZCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8PSA1NSkge1xyXG4gICAgICAgICAgICBwYXlsb2FkLnVuc2hpZnQoMHhjMCArIHBheWxvYWQubGVuZ3RoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkLmxlbmd0aCk7XHJcbiAgICAgICAgbGVuZ3RoLnVuc2hpZnQoMHhmNyArIGxlbmd0aC5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGdldEJ5dGVzKG9iamVjdCwgXCJvYmplY3RcIikpO1xyXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0gPD0gMHg3Zikge1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPD0gNTUpIHtcclxuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XHJcbiAgICBsZW5ndGgudW5zaGlmdCgweGI3ICsgbGVuZ3RoLmxlbmd0aCk7XHJcbiAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChkYXRhKTtcclxufVxyXG5jb25zdCBuaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XHJcbi8qKlxyXG4gKiAgRW5jb2RlcyAlJW9iamVjdCUlIGFzIGFuIFJMUC1lbmNvZGVkIFtbRGF0YUhleFN0cmluZ11dLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJscChvYmplY3QpIHtcclxuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XHJcbiAgICBmb3IgKGNvbnN0IHYgb2YgX2VuY29kZShvYmplY3QpKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiA+PiA0XTtcclxuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ICYgMHhmXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmxwLWVuY29kZS5qcy5tYXAiLCIvKipcclxuICogIE1vc3QgaW50ZXJhY3Rpb25zIHdpdGggRXRoZXJldW0gcmVxdWlyZXMgaW50ZWdlciB2YWx1ZXMsIHdoaWNoIHVzZVxyXG4gKiAgdGhlIHNtYWxsZXN0IG1hZ25pdHVkZSB1bml0LlxyXG4gKlxyXG4gKiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgZGVhbGluZyB3aXRoIGRvbGxhcnMgYW5kIGNlbnRzLiBTaW5jZSBkb2xsYXJzXHJcbiAqICBhcmUgZGl2aXNpYmxlLCBub24taW50ZWdlciB2YWx1ZXMgYXJlIHBvc3NpYmxlLCBzdWNoIGFzIGBgJDEwLjc3YGAuXHJcbiAqICBCeSB1c2luZyB0aGUgc21hbGxlc3QgaW5kaXZpc2libGUgdW5pdCAoaS5lLiBjZW50cyksIHRoZSB2YWx1ZSBjYW5cclxuICogIGJlIGtlcHQgYXMgdGhlIGludGVnZXIgYGAxMDc3YGAuXHJcbiAqXHJcbiAqICBXaGVuIHJlY2VpdmluZyBkZWNpbWFsIGlucHV0IGZyb20gdGhlIHVzZXIgKGFzIGEgZGVjaW1hbCBzdHJpbmcpLFxyXG4gKiAgdGhlIHZhbHVlIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBhbmQgd2hlbiBzaG93aW5nIGEgdXNlclxyXG4gKiAgYSB2YWx1ZSwgdGhlIGludGVnZXIgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIGRlY2ltYWwgc3RyaW5nLlxyXG4gKlxyXG4gKiAgVGhpcyBjcmVhdGVzIGEgY2xlYXIgZGlzdGluY3Rpb24sIGJldHdlZW4gdmFsdWVzIHRvIGJlIHVzZWQgYnkgY29kZVxyXG4gKiAgKGludGVnZXJzKSBhbmQgdmFsdWVzIHVzZWQgZm9yIGRpc3BsYXkgbG9naWMgdG8gdXNlcnMgKGRlY2ltYWxzKS5cclxuICpcclxuICogIFRoZSBuYXRpdmUgdW5pdCBpbiBFdGhlcmV1bSwgLy9ldGhlci8vIGlzIGRpdmlzaWJsZSB0byAxOCBkZWNpbWFsIHBsYWNlcyxcclxuICogIHdoZXJlIGVhY2ggaW5kaXZpZHVhbCB1bml0IGlzIGNhbGxlZCBhIC8vd2VpLy8uXHJcbiAqXHJcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlVuaXQgQ29udmVyc2lvbiAgW2Fib3V0LXVuaXRzXVxyXG4gKi9cclxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcclxuaW1wb3J0IHsgRml4ZWROdW1iZXIgfSBmcm9tIFwiLi9maXhlZG51bWJlci5qc1wiO1xyXG5pbXBvcnQgeyBnZXROdW1iZXIgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xyXG5jb25zdCBuYW1lcyA9IFtcclxuICAgIFwid2VpXCIsXHJcbiAgICBcImt3ZWlcIixcclxuICAgIFwibXdlaVwiLFxyXG4gICAgXCJnd2VpXCIsXHJcbiAgICBcInN6YWJvXCIsXHJcbiAgICBcImZpbm5leVwiLFxyXG4gICAgXCJldGhlclwiLFxyXG5dO1xyXG4vKipcclxuICogIENvbnZlcnRzICUldmFsdWUlJSBpbnRvIGEgLy9kZWNpbWFsIHN0cmluZy8vLCBhc3N1bWluZyAlJXVuaXQlJSBkZWNpbWFsXHJcbiAqICBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgYmUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvciB0aGUgbmFtZSBvZlxyXG4gKiAgYSB1bml0IChlLmcuIGBgXCJnd2VpXCJgYCBmb3IgOSBkZWNpbWFsIHBsYWNlcykuXHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VW5pdHModmFsdWUsIHVuaXQpIHtcclxuICAgIGxldCBkZWNpbWFscyA9IDE4O1xyXG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdCk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xyXG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XHJcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwgZGVjaW1hbHMsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudG9TdHJpbmcoKTtcclxufVxyXG4vKipcclxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSV2YWx1ZSUlIHRvIGEgQmlnSW50LCBhc3N1bWluZ1xyXG4gKiAgJSV1bml0JSUgZGVjaW1hbCBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xyXG4gKiAgb3IgdGhlIG5hbWUgb2YgYSB1bml0IChlLmcuIGBgXCJnd2VpXCJgYCBmb3IgOSBkZWNpbWFsIHBsYWNlcykuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgdW5pdCkge1xyXG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIsIFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgIGxldCBkZWNpbWFscyA9IDE4O1xyXG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdCk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xyXG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XHJcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodmFsdWUsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgaW50byBhIC8vZGVjaW1hbCBzdHJpbmcvLyB1c2luZyAxOCBkZWNpbWFsIHBsYWNlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRFdGhlcih3ZWkpIHtcclxuICAgIHJldHVybiBmb3JtYXRVbml0cyh3ZWksIDE4KTtcclxufVxyXG4vKipcclxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSVldGhlciUlIHRvIGEgQmlnSW50LCB1c2luZyAxOFxyXG4gKiAgZGVjaW1hbCBwbGFjZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdGhlcihldGhlcikge1xyXG4gICAgcmV0dXJuIHBhcnNlVW5pdHMoZXRoZXIsIDE4KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11bml0cy5qcy5tYXAiLCIvKipcclxuICogIEV4cGxhaW4gVVVJRCBhbmQgbGluayB0byBSRkMgaGVyZS5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOlVVSUQgIFthYm91dC11dWlkXVxyXG4gKi9cclxuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0aGUgdmVyc2lvbiA0IFtbbGluay11dWlkXV0gZm9yIHRoZSAlJXJhbmRvbUJ5dGVzJSUuXHJcbiAqXHJcbiAqICBAc2VlOiBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHQgKFNlY3Rpb24gNC40KVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHV1aWRWNChyYW5kb21CeXRlcykge1xyXG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhyYW5kb21CeXRlcywgXCJyYW5kb21CeXRlc1wiKTtcclxuICAgIC8vIFNlY3Rpb246IDQuMS4zOlxyXG4gICAgLy8gLSB0aW1lX2hpX2FuZF92ZXJzaW9uWzEyOjE2XSA9IDBiMDEwMFxyXG4gICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7XHJcbiAgICAvLyBTZWN0aW9uIDQuNFxyXG4gICAgLy8gLSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkWzZdID0gMGIwXHJcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbN10gPSAwYjFcclxuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xyXG4gICAgY29uc3QgdmFsdWUgPSBoZXhsaWZ5KGJ5dGVzKTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDIsIDEwKSxcclxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTAsIDE0KSxcclxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTQsIDE4KSxcclxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTgsIDIyKSxcclxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMjIsIDM0KSxcclxuICAgIF0uam9pbihcIi1cIik7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXVpZC5qcy5tYXAiLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBjb25jYXQsIGdldEJ5dGVzQ29weSwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b051bWJlciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudFxyXG4vKiwgaXNFcnJvciovXHJcbiB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xyXG4vKipcclxuICogQF9pZ25vcmU6XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgV29yZFNpemUgPSAzMjtcclxuY29uc3QgUGFkZGluZyA9IG5ldyBVaW50OEFycmF5KFdvcmRTaXplKTtcclxuLy8gUHJvcGVydGllcyB1c2VkIHRvIGltbWVkaWF0ZSBwYXNzIHRocm91Z2ggdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0XHJcbi8vIC0gYHRoZW5gIGlzIHVzZWQgdG8gZGV0ZWN0IGlmIGFuIG9iamVjdCBpcyBhIFByb21pc2UgZm9yIGF3YWl0XHJcbmNvbnN0IHBhc3NQcm9wZXJ0aWVzID0gW1widGhlblwiXTtcclxuY29uc3QgX2d1YXJkID0ge307XHJcbmNvbnN0IHJlc3VsdE5hbWVzID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gZ2V0TmFtZXMocmVzdWx0KSB7XHJcbiAgICByZXR1cm4gcmVzdWx0TmFtZXMuZ2V0KHJlc3VsdCk7XHJcbn1cclxuZnVuY3Rpb24gc2V0TmFtZXMocmVzdWx0LCBuYW1lcykge1xyXG4gICAgcmVzdWx0TmFtZXMuc2V0KHJlc3VsdCwgbmFtZXMpO1xyXG59XHJcbmZ1bmN0aW9uIHRocm93RXJyb3IobmFtZSwgZXJyb3IpIHtcclxuICAgIGNvbnN0IHdyYXBwZWQgPSBuZXcgRXJyb3IoYGRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyAke25hbWV9YCk7XHJcbiAgICB3cmFwcGVkLmVycm9yID0gZXJyb3I7XHJcbiAgICB0aHJvdyB3cmFwcGVkO1xyXG59XHJcbmZ1bmN0aW9uIHRvT2JqZWN0KG5hbWVzLCBpdGVtcywgZGVlcCkge1xyXG4gICAgaWYgKG5hbWVzLmluZGV4T2YobnVsbCkgPj0gMCkge1xyXG4gICAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9PYmplY3QoZ2V0TmFtZXMoaXRlbSksIGl0ZW0sIGRlZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgbGV0IGl0ZW0gPSBpdGVtcy5nZXRWYWx1ZShuYW1lKTtcclxuICAgICAgICBpZiAoIShuYW1lIGluIGFjY3VtKSkge1xyXG4gICAgICAgICAgICBpZiAoZGVlcCAmJiBpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtID0gdG9PYmplY3QoZ2V0TmFtZXMoaXRlbSksIGl0ZW0sIGRlZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjY3VtW25hbWVdID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFjY3VtO1xyXG4gICAgfSwge30pO1xyXG59XHJcbi8qKlxyXG4gKiAgQSBbW1Jlc3VsdF1dIGlzIGEgc3ViLWNsYXNzIG9mIEFycmF5LCB3aGljaCBhbGxvd3MgYWNjZXNzaW5nIGFueVxyXG4gKiAgb2YgaXRzIHZhbHVlcyBlaXRoZXIgcG9zaXRpb25hbGx5IGJ5IGl0cyBpbmRleCBvciwgaWYga2V5cyBhcmVcclxuICogIHByb3ZpZGVkIGJ5IGl0cyBuYW1lLlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9hYmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZXN1bHQgZXh0ZW5kcyBBcnJheSB7XHJcbiAgICAvLyBObyBsb25nZXIgdXNlZDsgYnV0IGNhbm5vdCBiZSByZW1vdmVkIGFzIGl0IHdpbGwgcmVtb3ZlIHRoZVxyXG4gICAgLy8gI3ByaXZhdGUgZmllbGQgZnJvbSB0aGUgLmQudHMgd2hpY2ggbWF5IGJyZWFrIGJhY2t3YXJkc1xyXG4gICAgLy8gY29tcGF0aWJpbGl0eVxyXG4gICAgI25hbWVzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xyXG4gICAgICAgIC8vIFRvIHByb3Blcmx5IHN1Yi1jbGFzcyBBcnJheSBzbyB0aGUgb3RoZXIgYnVpbHQtaW5cclxuICAgICAgICAvLyBmdW5jdGlvbnMgd29yaywgdGhlIGNvbnN0cnVjdG9yIGhhcyB0byBiZWhhdmUgZmFpcmx5XHJcbiAgICAgICAgLy8gd2VsbC4gU28sIGluIHRoZSBldmVudCB3ZSBhcmUgY3JlYXRlZCB2aWEgZnJvbUl0ZW1zKClcclxuICAgICAgICAvLyB3ZSBidWlsZCB0aGUgcmVhZC1vbmx5IFJlc3VsdCBvYmplY3Qgd2Ugd2FudCwgYnV0IG9uXHJcbiAgICAgICAgLy8gYW55IG90aGVyIGlucHV0LCB3ZSB1c2UgdGhlIGRlZmF1bHQgY29uc3RydWN0b3JcclxuICAgICAgICAvLyBjb25zdHJ1Y3RvcihndWFyZDogYW55LCBpdGVtczogQXJyYXk8YW55Piwga2V5cz86IEFycmF5PG51bGwgfCBzdHJpbmc+KTtcclxuICAgICAgICBjb25zdCBndWFyZCA9IGFyZ3NbMF07XHJcbiAgICAgICAgbGV0IGl0ZW1zID0gYXJnc1sxXTtcclxuICAgICAgICBsZXQgbmFtZXMgPSAoYXJnc1syXSB8fCBbXSkuc2xpY2UoKTtcclxuICAgICAgICBsZXQgd3JhcCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGd1YXJkICE9PSBfZ3VhcmQpIHtcclxuICAgICAgICAgICAgaXRlbXMgPSBhcmdzO1xyXG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xyXG4gICAgICAgICAgICB3cmFwID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbid0IGp1c3QgcGFzcyBpbiAuLi5pdGVtcyBzaW5jZSBhbiBhcnJheSBvZiBsZW5ndGggMVxyXG4gICAgICAgIC8vIGlzIGEgc3BlY2lhbCBjYXNlIGluIHRoZSBzdXBlci5cclxuICAgICAgICBzdXBlcihpdGVtcy5sZW5ndGgpO1xyXG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7IHRoaXNbaW5kZXhdID0gaXRlbTsgfSk7XHJcbiAgICAgICAgLy8gRmluZCBhbGwgdW5pcXVlIGtleXNcclxuICAgICAgICBjb25zdCBuYW1lQ291bnRzID0gbmFtZXMucmVkdWNlKChhY2N1bSwgbmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgYWNjdW0uc2V0KG5hbWUsIChhY2N1bS5nZXQobmFtZSkgfHwgMCkgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICAgICAgfSwgKG5ldyBNYXAoKSkpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBhbnkga2V5IHRoYXRzIG5vdCB1bmlxdWVcclxuICAgICAgICBzZXROYW1lcyh0aGlzLCBPYmplY3QuZnJlZXplKGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lQ291bnRzLmdldChuYW1lKSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSkpKTtcclxuICAgICAgICAvLyBEdW1teSBvcGVyYXRpb25zIHRvIHByZXZlbnQgVHlwZVNjcmlwdCBmcm9tIGNvbXBsYWluaW5nXHJcbiAgICAgICAgdGhpcy4jbmFtZXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy4jbmFtZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2b2lkICh0aGlzLiNuYW1lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghd3JhcCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEEgd3JhcHBlZCBSZXN1bHQgaXMgaW1tdXRhYmxlXHJcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcclxuICAgICAgICAvLyBQcm94eSBpbmRpY2VzIGFuZCBuYW1lcyBzbyB3ZSBjYW4gdHJhcCBkZWZlcnJlZCBlcnJvcnNcclxuICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0aGlzLCB7XHJcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kZXggYWNjZXNzb3JcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5tYXRjaCgvXlswLTldKyQvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihwcm9wLCBcIiVpbmRleFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmVzdWx0IHJhbmdlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXRbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBmdW5jdGlvbnMgd29yayB3aXRoIHByaXZhdGUgdmFyaWFibGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkjbm9fcHJpdmF0ZV9wcm9wZXJ0eV9mb3J3YXJkaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIShwcm9wIGluIHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libGUgbmFtZSBhY2Nlc3NvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldFZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNldE5hbWVzKHByb3h5LCBnZXROYW1lcyh0aGlzKSk7XHJcbiAgICAgICAgcmV0dXJuIHByb3h5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgUmVzdWx0IGFzIGEgbm9ybWFsIEFycmF5LiBJZiAlJWRlZXAlJSwgYW55IGNoaWxkcmVuXHJcbiAgICAgKiAgd2hpY2ggYXJlIFJlc3VsdCBvYmplY3RzIGFyZSBhbHNvIGNvbnZlcnRlZCB0byBhIG5vcm1hbCBBcnJheS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZXJlIGFyZSBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWRcclxuICAgICAqICBlcnJvcnMuXHJcbiAgICAgKi9cclxuICAgIHRvQXJyYXkoZGVlcCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpbmRleH1gLCBpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVlcCAmJiBpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS50b0FycmF5KGRlZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYW4gT2JqZWN0IHdpdGggZWFjaCBuYW1lLXZhbHVlIHBhaXIuIElmXHJcbiAgICAgKiAgJSVkZWVwJSUsIGFueSBjaGlsZHJlbiB3aGljaCBhcmUgUmVzdWx0IG9iamVjdHMgYXJlIGFsc29cclxuICAgICAqICBjb252ZXJ0ZWQgdG8gYW4gT2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgaWYgYW55IHZhbHVlIGlzIHVubmFtZWQsIG9yIGlmIHRoZXJlIGFyZVxyXG4gICAgICogIGFueSBvdXRzdGFuZGluZyBkZWZlcnJlZCBlcnJvcnMuXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0KGRlZXApIHtcclxuICAgICAgICBjb25zdCBuYW1lcyA9IGdldE5hbWVzKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBhc3NlcnQobmFtZSAhPSBudWxsLCBgdmFsdWUgYXQgaW5kZXggJHtpbmRleH0gdW5uYW1lZGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b09iamVjdCgpXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0b09iamVjdChuYW1lcywgdGhpcywgZGVlcCk7XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmVcclxuICAgICAqL1xyXG4gICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xyXG4gICAgICAgICAgICBzdGFydCArPSB0aGlzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZCA8IDApIHtcclxuICAgICAgICAgICAgZW5kICs9IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoZW5kIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IF9uYW1lcyA9IGdldE5hbWVzKHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXNbaV0pO1xyXG4gICAgICAgICAgICBuYW1lcy5wdXNoKF9uYW1lc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZVxyXG4gICAgICovXHJcbiAgICBmaWx0ZXIoY2FsbGJhY2ssIHRoaXNBcmcpIHtcclxuICAgICAgICBjb25zdCBfbmFtZXMgPSBnZXROYW1lcyh0aGlzKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXNbaV07XHJcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aX1gLCBpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKF9uYW1lc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCByZXN1bHQsIG5hbWVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1hcChjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpfWAsIGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlbSwgaSwgdGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgZm9yICUlbmFtZSUlLlxyXG4gICAgICpcclxuICAgICAqICBTaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGEga2V5IHdob3NlIG5hbWUgY29uZmxpY3RzIHdpdGhcclxuICAgICAqICBhIG1ldGhvZCBvbiBhIFtbUmVzdWx0XV0gb3IgaXRzIHN1cGVyY2xhc3MgQXJyYXksIG9yIGFueVxyXG4gICAgICogIEphdmFTY3JpcHQga2V5d29yZCwgdGhpcyBlbnN1cmVzIGFsbCBuYW1lZCB2YWx1ZXMgYXJlIHN0aWxsXHJcbiAgICAgKiAgYWNjZXNzaWJsZSBieSBuYW1lLlxyXG4gICAgICovXHJcbiAgICBnZXRWYWx1ZShuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXROYW1lcyh0aGlzKS5pbmRleE9mKG5hbWUpO1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2luZGV4XTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIHZhbHVlLmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW1Jlc3VsdF1dIGZvciAlJWl0ZW1zJSUgd2l0aCBlYWNoIGVudHJ5XHJcbiAgICAgKiAgYWxzbyBhY2Nlc3NpYmxlIGJ5IGl0cyBjb3JyZXNwb25kaW5nIG5hbWUgaW4gJSVrZXlzJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tSXRlbXMoaXRlbXMsIGtleXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIGl0ZW1zLCBrZXlzKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIFJldHVybnMgYWxsIGVycm9ycyBmb3VuZCBpbiBhIFtbUmVzdWx0XV0uXHJcbiAqXHJcbiAqICBTaW5jZSBjZXJ0YWluIGVycm9ycyBlbmNvdW50ZXJlZCB3aGVuIGNyZWF0aW5nIGEgW1tSZXN1bHRdXSBkb1xyXG4gKiAgbm90IGltcGFjdCB0aGUgYWJpbGl0eSB0byBjb250aW51ZSBwYXJzaW5nIGRhdGEsIHRoZXkgYXJlXHJcbiAqICBkZWZlcnJlZCB1bnRpbCB0aGV5IGFyZSBhY3R1YWxseSBhY2Nlc3NlZC4gSGVuY2UgYSBmYXVsdHkgc3RyaW5nXHJcbiAqICBpbiBhbiBFdmVudCB0aGF0IGlzIG5ldmVyIHVzZWQgZG9lcyBub3QgaW1wYWN0IHRoZSBwcm9ncmFtIGZsb3cuXHJcbiAqXHJcbiAqICBIb3dldmVyLCBzb21ldGltZXMgaXQgbWF5IGJlIHVzZWZ1bCB0byBhY2Nlc3MsIGlkZW50aWZ5IG9yXHJcbiAqICB2YWxpZGF0ZSBjb3JyZWN0bmVzcyBvZiBhIFtbUmVzdWx0XV0uXHJcbiAqXHJcbiAqICBAX2RvY2xvYyBhcGkvYWJpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XHJcbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBlcnJvciAoaWYgYW55KVxyXG4gICAgY29uc3QgZXJyb3JzID0gW107XHJcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xyXG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIGVycm9ycztcclxufVxyXG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xyXG4gICAgbGV0IGJ5dGVzID0gdG9CZUFycmF5KHZhbHVlKTtcclxuICAgIGFzc2VydChieXRlcy5sZW5ndGggPD0gV29yZFNpemUsIFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBXb3JkU2l6ZSwgb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XHJcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBXb3JkU2l6ZSkge1xyXG4gICAgICAgIGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbUGFkZGluZy5zbGljZShieXRlcy5sZW5ndGggJSBXb3JkU2l6ZSksIGJ5dGVzXSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ5dGVzO1xyXG59XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb2RlciB7XHJcbiAgICAvLyBUaGUgY29kZXIgbmFtZTpcclxuICAgIC8vICAgLSBhZGRyZXNzLCB1aW50MjU2LCB0dXBsZSwgYXJyYXksIGV0Yy5cclxuICAgIG5hbWU7XHJcbiAgICAvLyBUaGUgZnVsbHkgZXhwYW5kZWQgdHlwZSwgaW5jbHVkaW5nIGNvbXBvc2l0ZSB0eXBlczpcclxuICAgIC8vICAgLSBhZGRyZXNzLCB1aW50MjU2LCB0dXBsZShhZGRyZXNzLGJ5dGVzKSwgdWludDI1NlszXVs0XVtdLCAgZXRjLlxyXG4gICAgdHlwZTtcclxuICAgIC8vIFRoZSBsb2NhbE5hbWUgYm91bmQgaW4gdGhlIHNpZ25hdHVyZSwgaW4gdGhpcyBleGFtcGxlIGl0IGlzIFwiYmF6XCI6XHJcbiAgICAvLyAgIC0gdHVwbGUoYWRkcmVzcyBmb28sIHVpbnQgYmFyKSBiYXpcclxuICAgIGxvY2FsTmFtZTtcclxuICAgIC8vIFdoZXRoZXIgdGhpcyB0eXBlIGlzIGR5bmFtaWM6XHJcbiAgICAvLyAgLSBEeW5hbWljOiBieXRlcywgc3RyaW5nLCBhZGRyZXNzW10sIHR1cGxlKGJvb2xlYW5bXSksIGV0Yy5cclxuICAgIC8vICAtIE5vdCBEeW5hbWljOiBhZGRyZXNzLCB1aW50MjU2LCBib29sZWFuWzNdLCB0dXBsZShhZGRyZXNzLCB1aW50OClcclxuICAgIGR5bmFtaWM7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpIHtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljIH0sIHtcclxuICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIiwgdHlwZTogXCJzdHJpbmdcIiwgbG9jYWxOYW1lOiBcInN0cmluZ1wiLCBkeW5hbWljOiBcImJvb2xlYW5cIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3Rocm93RXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgbWVzc2FnZSwgdGhpcy5sb2NhbE5hbWUsIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV3JpdGVyIHtcclxuICAgIC8vIEFuIGFycmF5IG9mIFdvcmRTaXplIGxlbmd0aGVkIG9iamVjdHMgdG8gY29uY2F0ZW5hdGlvblxyXG4gICAgI2RhdGE7XHJcbiAgICAjZGF0YUxlbmd0aDtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuI2RhdGEgPSBbXTtcclxuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIGdldCBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiBjb25jYXQodGhpcy4jZGF0YSk7XHJcbiAgICB9XHJcbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YUxlbmd0aDsgfVxyXG4gICAgI3dyaXRlRGF0YShkYXRhKSB7XHJcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKGRhdGEpO1xyXG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgYXBwZW5kV3JpdGVyKHdyaXRlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0Qnl0ZXNDb3B5KHdyaXRlci5kYXRhKSk7XHJcbiAgICB9XHJcbiAgICAvLyBBcnJheWlzaCBpdGVtOyBwYWQgb24gdGhlIHJpZ2h0IHRvICpuZWFyZXN0KiBXb3JkU2l6ZVxyXG4gICAgd3JpdGVCeXRlcyh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBieXRlcyA9IGdldEJ5dGVzQ29weSh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ09mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplO1xyXG4gICAgICAgIGlmIChwYWRkaW5nT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbYnl0ZXMsIFBhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoYnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgLy8gTnVtZXJpYyBpdGVtOyBwYWQgb24gdGhlIGxlZnQgKnRvKiBXb3JkU2l6ZVxyXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0VmFsdWUodmFsdWUpKTtcclxuICAgIH1cclxuICAgIC8vIEluc2VydHMgYSBudW1lcmljIHBsYWNlLWhvbGRlciwgcmV0dXJuaW5nIGEgY2FsbGJhY2sgdGhhdCBjYW5cclxuICAgIC8vIGJlIHVzZWQgdG8gYXNqdXN0IHRoZSB2YWx1ZSBsYXRlclxyXG4gICAgd3JpdGVVcGRhdGFibGVWYWx1ZSgpIHtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLiNkYXRhLmxlbmd0aDtcclxuICAgICAgICB0aGlzLiNkYXRhLnB1c2goUGFkZGluZyk7XHJcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCArPSBXb3JkU2l6ZTtcclxuICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuI2RhdGFbb2Zmc2V0XSA9IGdldFZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZWFkZXIge1xyXG4gICAgLy8gQWxsb3dzIGluY29tcGxldGUgdW5wYWRkZWQgZGF0YSB0byBiZSByZWFkOyBvdGhlcndpc2UgYW4gZXJyb3JcclxuICAgIC8vIGlzIHJhaXNlZCBpZiBhdHRlbXB0aW5nIHRvIG92ZXJydW4gdGhlIGJ1ZmZlci4gVGhpcyBpcyByZXF1aXJlZFxyXG4gICAgLy8gdG8gZGVhbCB3aXRoIGFuIG9sZCBTb2xpZGl0eSBidWcsIGluIHdoaWNoIGV2ZW50IGRhdGEgZm9yXHJcbiAgICAvLyBleHRlcm5hbCAobm90IHB1YmxpYyB0aG9ndWgpIHdhcyB0aWdodGx5IHBhY2tlZC5cclxuICAgIGFsbG93TG9vc2U7XHJcbiAgICAjZGF0YTtcclxuICAgICNvZmZzZXQ7XHJcbiAgICAjYnl0ZXNSZWFkO1xyXG4gICAgI3BhcmVudDtcclxuICAgICNtYXhJbmZsYXRpb247XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBhbGxvd0xvb3NlLCBtYXhJbmZsYXRpb24pIHtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWxsb3dMb29zZTogISFhbGxvd0xvb3NlIH0pO1xyXG4gICAgICAgIHRoaXMuI2RhdGEgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XHJcbiAgICAgICAgdGhpcy4jYnl0ZXNSZWFkID0gMDtcclxuICAgICAgICB0aGlzLiNwYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI21heEluZmxhdGlvbiA9IChtYXhJbmZsYXRpb24gIT0gbnVsbCkgPyBtYXhJbmZsYXRpb24gOiAxMDI0O1xyXG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgZGF0YSgpIHsgcmV0dXJuIGhleGxpZnkodGhpcy4jZGF0YSk7IH1cclxuICAgIGdldCBkYXRhTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YS5sZW5ndGg7IH1cclxuICAgIGdldCBjb25zdW1lZCgpIHsgcmV0dXJuIHRoaXMuI29mZnNldDsgfVxyXG4gICAgZ2V0IGJ5dGVzKCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jZGF0YSk7IH1cclxuICAgICNpbmNyZW1lbnRCeXRlc1JlYWQoY291bnQpIHtcclxuICAgICAgICBpZiAodGhpcy4jcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwYXJlbnQuI2luY3JlbWVudEJ5dGVzUmVhZChjb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI2J5dGVzUmVhZCArPSBjb3VudDtcclxuICAgICAgICAvLyBDaGVjayBmb3IgZXhjZXNzaXZlIGluZmxhdGlvbiAoc2VlOiAjNDUzNylcclxuICAgICAgICBhc3NlcnQodGhpcy4jbWF4SW5mbGF0aW9uIDwgMSB8fCB0aGlzLiNieXRlc1JlYWQgPD0gdGhpcy4jbWF4SW5mbGF0aW9uICogdGhpcy5kYXRhTGVuZ3RoLCBgY29tcHJlc3NlZCBBQkkgZGF0YSBleGNlZWRzIGluZmxhdGlvbiByYXRpbyBvZiAke3RoaXMuI21heEluZmxhdGlvbn0gKCBzZWU6IGh0dHBzOi9cXC9naXRodWIuY29tL2V0aGVycy1pby9ldGhlcnMuanMvaXNzdWVzLzQ1MzcgKWAsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xyXG4gICAgICAgICAgICBidWZmZXI6IGdldEJ5dGVzQ29weSh0aGlzLiNkYXRhKSwgb2Zmc2V0OiB0aGlzLiNvZmZzZXQsXHJcbiAgICAgICAgICAgIGxlbmd0aDogY291bnQsIGluZm86IHtcclxuICAgICAgICAgICAgICAgIGJ5dGVzUmVhZDogdGhpcy4jYnl0ZXNSZWFkLFxyXG4gICAgICAgICAgICAgICAgZGF0YUxlbmd0aDogdGhpcy5kYXRhTGVuZ3RoXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgICNwZWVrQnl0ZXMob2Zmc2V0LCBsZW5ndGgsIGxvb3NlKSB7XHJcbiAgICAgICAgbGV0IGFsaWduZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gV29yZFNpemUpICogV29yZFNpemU7XHJcbiAgICAgICAgaWYgKHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLiNkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd0xvb3NlICYmIGxvb3NlICYmIHRoaXMuI29mZnNldCArIGxlbmd0aCA8PSB0aGlzLiNkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBnZXRCeXRlc0NvcHkodGhpcy4jZGF0YSksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLiNkYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGhcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLiNkYXRhLnNsaWNlKHRoaXMuI29mZnNldCwgdGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGUgYSBzdWItcmVhZGVyIHdpdGggdGhlIHNhbWUgdW5kZXJseWluZyBkYXRhLCBidXQgb2Zmc2V0XHJcbiAgICBzdWJSZWFkZXIob2Zmc2V0KSB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IFJlYWRlcih0aGlzLiNkYXRhLnNsaWNlKHRoaXMuI29mZnNldCArIG9mZnNldCksIHRoaXMuYWxsb3dMb29zZSwgdGhpcy4jbWF4SW5mbGF0aW9uKTtcclxuICAgICAgICByZWFkZXIuI3BhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcclxuICAgIH1cclxuICAgIC8vIFJlYWQgYnl0ZXNcclxuICAgIHJlYWRCeXRlcyhsZW5ndGgsIGxvb3NlKSB7XHJcbiAgICAgICAgbGV0IGJ5dGVzID0gdGhpcy4jcGVla0J5dGVzKDAsIGxlbmd0aCwgISFsb29zZSk7XHJcbiAgICAgICAgdGhpcy4jaW5jcmVtZW50Qnl0ZXNSZWFkKGxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy4jb2Zmc2V0ICs9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgICAvLyBAVE9ETzogTWFrZSBzdXJlIHRoZSBsZW5ndGguLmVuZCBieXRlcyBhcmUgYWxsIDA/XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvLyBSZWFkIGEgbnVtZXJpYyB2YWx1ZXNcclxuICAgIHJlYWRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdG9CaWdJbnQodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcclxuICAgIH1cclxuICAgIHJlYWRJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdG9OdW1iZXIodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiLCJmdW5jdGlvbiBudW1iZXIobikge1xyXG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcclxufVxyXG5mdW5jdGlvbiBib29sKGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcclxufVxyXG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XHJcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XHJcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcclxufVxyXG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcclxuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xyXG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcclxuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcclxufVxyXG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcclxuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xyXG59XHJcbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XHJcbiAgICBieXRlcyhvdXQpO1xyXG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xyXG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XHJcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcclxuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCIsImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIiwiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xyXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cclxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxyXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcclxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cclxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXHJcbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXHJcbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcclxuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xyXG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXHJcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XHJcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XHJcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xyXG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xyXG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcclxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xyXG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcclxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cclxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xyXG5pZiAoIWlzTEUpXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcclxuLyoqXHJcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XHJcbiAgICBpZiAoIXU4YShieXRlcykpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XHJcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcclxuICAgIGxldCBoZXggPSAnJztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhleDtcclxufVxyXG4vKipcclxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XHJcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xyXG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcclxuICAgIGlmIChsZW4gJSAyKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xyXG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBqID0gaSAqIDI7XHJcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XHJcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XHJcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcclxuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbn1cclxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cclxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXHJcbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cclxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xyXG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XHJcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XHJcbiAgICAgICAgY2IoaSk7XHJcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cclxuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xyXG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XHJcbiAgICAgICAgdHMgKz0gZGlmZjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcclxuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcclxufVxyXG4vKipcclxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cclxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXHJcbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xyXG4gICAgaWYgKCF1OGEoZGF0YSkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcclxuICAgIHJldHVybiBkYXRhO1xyXG59XHJcbi8qKlxyXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcclxuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XHJcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxyXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcclxuICAgICAgICBpZiAoIXU4YShhKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XHJcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcclxuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByO1xyXG59XHJcbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXHJcbmV4cG9ydCBjbGFzcyBIYXNoIHtcclxuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XHJcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcclxuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XHJcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcclxuICAgIHJldHVybiBtZXJnZWQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xyXG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xyXG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcclxuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XHJcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcclxuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XHJcbiAgICByZXR1cm4gaGFzaEM7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XHJcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xyXG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xyXG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcclxuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xyXG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xyXG4gICAgcmV0dXJuIGhhc2hDO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xyXG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcclxuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcclxuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XHJcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcclxuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcclxuICAgIHJldHVybiBoYXNoQztcclxufVxyXG4vKipcclxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xyXG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBieXRlcyBhcyBhc3NlcnRCeXRlcywgZXhpc3RzIGFzIGFzc2VydEV4aXN0cyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XHJcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcclxuLy8gSE1BQyAoUkZDIDIxMDQpXHJcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XHJcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcclxuICAgICAgICBhc3NlcnRIYXNoKGhhc2gpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XHJcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcclxuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcclxuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xyXG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcclxuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XHJcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxyXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xyXG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XHJcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxyXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xyXG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XHJcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcclxuICAgICAgICBwYWQuZmlsbCgwKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShidWYpIHtcclxuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XHJcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGRpZ2VzdEludG8ob3V0KSB7XHJcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xyXG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xyXG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xyXG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XHJcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xyXG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgICBfY2xvbmVJbnRvKHRvKSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXHJcbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XHJcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XHJcbiAgICAgICAgdG8gPSB0bztcclxuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xyXG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcclxuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xyXG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcclxuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xyXG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxyXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxyXG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcclxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcclxuICovXHJcbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XHJcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiLCJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIG51bWJlciBhcyBhc3NlcnROdW1iZXIgfSBmcm9tICcuL19hc3NlcnQuanMnO1xyXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLmpzJztcclxuaW1wb3J0IHsgY3JlYXRlVmlldywgdG9CeXRlcywgY2hlY2tPcHRzLCBhc3luY0xvb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcclxuLy8gQ29tbW9uIHByb2xvZ3VlIGFuZCBlcGlsb2d1ZSBmb3Igc3luYy9hc3luYyBmdW5jdGlvbnNcclxuZnVuY3Rpb24gcGJrZGYySW5pdChoYXNoLCBfcGFzc3dvcmQsIF9zYWx0LCBfb3B0cykge1xyXG4gICAgYXNzZXJ0SGFzaChoYXNoKTtcclxuICAgIGNvbnN0IG9wdHMgPSBjaGVja09wdHMoeyBka0xlbjogMzIsIGFzeW5jVGljazogMTAgfSwgX29wdHMpO1xyXG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrIH0gPSBvcHRzO1xyXG4gICAgYXNzZXJ0TnVtYmVyKGMpO1xyXG4gICAgYXNzZXJ0TnVtYmVyKGRrTGVuKTtcclxuICAgIGFzc2VydE51bWJlcihhc3luY1RpY2spO1xyXG4gICAgaWYgKGMgPCAxKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUEJLREYyOiBpdGVyYXRpb25zIChjKSBzaG91bGQgYmUgPj0gMScpO1xyXG4gICAgY29uc3QgcGFzc3dvcmQgPSB0b0J5dGVzKF9wYXNzd29yZCk7XHJcbiAgICBjb25zdCBzYWx0ID0gdG9CeXRlcyhfc2FsdCk7XHJcbiAgICAvLyBESyA9IFBCS0RGMihQUkYsIFBhc3N3b3JkLCBTYWx0LCBjLCBka0xlbik7XHJcbiAgICBjb25zdCBESyA9IG5ldyBVaW50OEFycmF5KGRrTGVuKTtcclxuICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxyXG4gICAgY29uc3QgUFJGID0gaG1hYy5jcmVhdGUoaGFzaCwgcGFzc3dvcmQpO1xyXG4gICAgY29uc3QgUFJGU2FsdCA9IFBSRi5fY2xvbmVJbnRvKCkudXBkYXRlKHNhbHQpO1xyXG4gICAgcmV0dXJuIHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9O1xyXG59XHJcbmZ1bmN0aW9uIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KSB7XHJcbiAgICBQUkYuZGVzdHJveSgpO1xyXG4gICAgUFJGU2FsdC5kZXN0cm95KCk7XHJcbiAgICBpZiAocHJmVylcclxuICAgICAgICBwcmZXLmRlc3Ryb3koKTtcclxuICAgIHUuZmlsbCgwKTtcclxuICAgIHJldHVybiBESztcclxufVxyXG4vKipcclxuICogUEJLREYyLUhNQUM6IFJGQyAyODk4IGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcclxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc3dvcmQgZnJvbSB3aGljaCBhIGRlcml2ZWQga2V5IGlzIGdlbmVyYXRlZFxyXG4gKiBAcGFyYW0gc2FsdCAtIGNyeXB0b2dyYXBoaWMgc2FsdFxyXG4gKiBAcGFyYW0gb3B0cyAtIHtjLCBka0xlbn0gd2hlcmUgYyBpcyB3b3JrIGZhY3RvciBhbmQgZGtMZW4gaXMgb3V0cHV0IG1lc3NhZ2Ugc2l6ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMihoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xyXG4gICAgY29uc3QgeyBjLCBka0xlbiwgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XHJcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XHJcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcclxuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGFycik7XHJcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XHJcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxyXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcclxuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXHJcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xyXG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcclxuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xyXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxyXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xyXG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xyXG4gICAgICAgIGZvciAobGV0IHVpID0gMTsgdWkgPCBjOyB1aSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY+KIkjEpXHJcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgVGlbaV0gXj0gdVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYmtkZjJBc3luYyhoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xyXG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcclxuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcclxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xyXG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcclxuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcclxuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXHJcbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xyXG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcclxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XHJcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xyXG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXHJcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXHJcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XHJcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XHJcbiAgICAgICAgYXdhaXQgYXN5bmNMb29wKGMgLSAxLCBhc3luY1RpY2ssICgpID0+IHtcclxuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcclxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYmtkZjIuanMubWFwIiwiaW1wb3J0IHsgZXhpc3RzLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xyXG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XHJcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcclxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XHJcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XHJcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcclxuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xyXG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xyXG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XHJcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xyXG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcclxuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XHJcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xyXG59XHJcbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXHJcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XHJcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcclxuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcclxuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcclxuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xyXG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZGF0YSkge1xyXG4gICAgICAgIGV4aXN0cyh0aGlzKTtcclxuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XHJcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xyXG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcclxuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXHJcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XHJcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XHJcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBkaWdlc3RJbnRvKG91dCkge1xyXG4gICAgICAgIGV4aXN0cyh0aGlzKTtcclxuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcclxuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICAvLyBQYWRkaW5nXHJcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcclxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXHJcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xyXG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcclxuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcclxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcclxuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XHJcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxyXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcclxuICAgICAgICAgICAgcG9zID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXHJcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XHJcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XHJcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXHJcbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxyXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XHJcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XHJcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcclxuICAgICAgICBpZiAobGVuICUgNClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XHJcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcclxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XHJcbiAgICB9XHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcclxuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcclxuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgX2Nsb25lSW50byh0bykge1xyXG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xyXG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcclxuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xyXG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICB0by5wb3MgPSBwb3M7XHJcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcclxuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XHJcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxyXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCIsImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcclxuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XHJcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cclxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxyXG4vLyBDaG9pY2U6IGEgPyBiIDogY1xyXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xyXG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXHJcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XHJcbi8vIFJvdW5kIGNvbnN0YW50czpcclxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcclxuLy8gcHJldHRpZXItaWdub3JlXHJcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXHJcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxyXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcclxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXHJcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxyXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcclxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXHJcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxyXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxyXG5dKTtcclxuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xyXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxyXG5dKTtcclxuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXHJcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxyXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xyXG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xyXG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcclxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXHJcbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xyXG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcclxuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XHJcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xyXG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcclxuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XHJcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xyXG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcclxuICAgIH1cclxuICAgIGdldCgpIHtcclxuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcclxuICAgIH1cclxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcclxuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcclxuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcclxuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcclxuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcclxuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcclxuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcclxuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcclxuICAgICAgICB0aGlzLkggPSBIIHwgMDtcclxuICAgIH1cclxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XHJcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcclxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XHJcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xyXG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcclxuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcclxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcclxuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcclxuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcclxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XHJcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xyXG4gICAgICAgICAgICBIID0gRztcclxuICAgICAgICAgICAgRyA9IEY7XHJcbiAgICAgICAgICAgIEYgPSBFO1xyXG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xyXG4gICAgICAgICAgICBEID0gQztcclxuICAgICAgICAgICAgQyA9IEI7XHJcbiAgICAgICAgICAgIEIgPSBBO1xyXG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcclxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcclxuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcclxuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcclxuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcclxuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcclxuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcclxuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcclxuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcclxuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcclxuICAgIH1cclxuICAgIHJvdW5kQ2xlYW4oKSB7XHJcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcclxuICAgIH1cclxufVxyXG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXHJcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xyXG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xyXG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xyXG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xyXG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xyXG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xyXG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xyXG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xyXG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cclxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xyXG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIiwiY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xyXG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XHJcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcclxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAobGUpXHJcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcclxuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcclxufVxyXG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcclxuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcclxuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xyXG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtBaCwgQWxdO1xyXG59XHJcbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XHJcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXHJcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xyXG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XHJcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxyXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xyXG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xyXG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXHJcbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xyXG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcclxuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcclxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcclxuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcclxuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcclxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcclxuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcclxuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXHJcbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xyXG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcclxuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XHJcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXHJcbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xyXG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xyXG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XHJcbn1cclxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xyXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XHJcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xyXG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcclxuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XHJcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XHJcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuZXhwb3J0IHsgZnJvbUJpZywgc3BsaXQsIHRvQmlnLCBzaHJTSCwgc2hyU0wsIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCwgcm90cjMySCwgcm90cjMyTCwgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLCBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsIH07XHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG5jb25zdCB1NjQgPSB7XHJcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXHJcbiAgICBzaHJTSCwgc2hyU0wsXHJcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXHJcbiAgICByb3RyMzJILCByb3RyMzJMLFxyXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxyXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxyXG59O1xyXG5leHBvcnQgZGVmYXVsdCB1NjQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIiwiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xyXG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XHJcbmltcG9ydCB7IHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xyXG4vLyBSb3VuZCBjb250YW50cyAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOSk6XHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG5jb25zdCBbU0hBNTEyX0toLCBTSEE1MTJfS2xdID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB1NjQuc3BsaXQoW1xyXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXHJcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcclxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxyXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXHJcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcclxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxyXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXHJcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcclxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxyXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXHJcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcclxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxyXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXHJcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcclxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxyXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXHJcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcclxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxyXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXHJcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xyXG5dLm1hcChuID0+IEJpZ0ludChuKSkpKSgpO1xyXG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcclxuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xyXG5jb25zdCBTSEE1MTJfV19MID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XHJcbmV4cG9ydCBjbGFzcyBTSEE1MTIgZXh0ZW5kcyBTSEEyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKDEyOCwgNjQsIDE2LCBmYWxzZSk7XHJcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZSB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXHJcbiAgICAgICAgLy8gQWxzbyBsb29rcyBjbGVhbmVyIGFuZCBlYXNpZXIgdG8gdmVyaWZ5IHdpdGggc3BlYy5cclxuICAgICAgICAvLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcclxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xyXG4gICAgICAgIHRoaXMuQWggPSAweDZhMDllNjY3IHwgMDtcclxuICAgICAgICB0aGlzLkFsID0gMHhmM2JjYzkwOCB8IDA7XHJcbiAgICAgICAgdGhpcy5CaCA9IDB4YmI2N2FlODUgfCAwO1xyXG4gICAgICAgIHRoaXMuQmwgPSAweDg0Y2FhNzNiIHwgMDtcclxuICAgICAgICB0aGlzLkNoID0gMHgzYzZlZjM3MiB8IDA7XHJcbiAgICAgICAgdGhpcy5DbCA9IDB4ZmU5NGY4MmIgfCAwO1xyXG4gICAgICAgIHRoaXMuRGggPSAweGE1NGZmNTNhIHwgMDtcclxuICAgICAgICB0aGlzLkRsID0gMHg1ZjFkMzZmMSB8IDA7XHJcbiAgICAgICAgdGhpcy5FaCA9IDB4NTEwZTUyN2YgfCAwO1xyXG4gICAgICAgIHRoaXMuRWwgPSAweGFkZTY4MmQxIHwgMDtcclxuICAgICAgICB0aGlzLkZoID0gMHg5YjA1Njg4YyB8IDA7XHJcbiAgICAgICAgdGhpcy5GbCA9IDB4MmIzZTZjMWYgfCAwO1xyXG4gICAgICAgIHRoaXMuR2ggPSAweDFmODNkOWFiIHwgMDtcclxuICAgICAgICB0aGlzLkdsID0gMHhmYjQxYmQ2YiB8IDA7XHJcbiAgICAgICAgdGhpcy5IaCA9IDB4NWJlMGNkMTkgfCAwO1xyXG4gICAgICAgIHRoaXMuSGwgPSAweDEzN2UyMTc5IHwgMDtcclxuICAgIH1cclxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgZ2V0KCkge1xyXG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XHJcbiAgICB9XHJcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xyXG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XHJcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcclxuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xyXG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XHJcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcclxuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xyXG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XHJcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcclxuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xyXG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XHJcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcclxuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xyXG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XHJcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcclxuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xyXG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xyXG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcclxuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XHJcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcclxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xyXG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcclxuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XHJcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXHJcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcclxuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xyXG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xyXG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xyXG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xyXG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcclxuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XHJcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcclxuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcclxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XHJcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcclxuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XHJcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xyXG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXHJcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xyXG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQuYWRkNUgoVDFsbCwgSGgsIHNpZ21hMWgsIENISWgsIFNIQTUxMl9LaFtpXSwgU0hBNTEyX1dfSFtpXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xyXG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGggPSB1NjQucm90clNIKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzOSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XHJcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XHJcbiAgICAgICAgICAgIGNvbnN0IE1BSmwgPSAoQWwgJiBCbCkgXiAoQWwgJiBDbCkgXiAoQmwgJiBDbCk7XHJcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xyXG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcclxuICAgICAgICAgICAgR2ggPSBGaCB8IDA7XHJcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xyXG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcclxuICAgICAgICAgICAgRmwgPSBFbCB8IDA7XHJcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xyXG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcclxuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XHJcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xyXG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcclxuICAgICAgICAgICAgQmggPSBBaCB8IDA7XHJcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xyXG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcclxuICAgICAgICAgICAgQWggPSB1NjQuYWRkM0goQWxsLCBUMWgsIHNpZ21hMGgsIE1BSmgpO1xyXG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXHJcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcclxuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xyXG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XHJcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcclxuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xyXG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XHJcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcclxuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xyXG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcclxuICAgIH1cclxuICAgIHJvdW5kQ2xlYW4oKSB7XHJcbiAgICAgICAgU0hBNTEyX1dfSC5maWxsKDApO1xyXG4gICAgICAgIFNIQTUxMl9XX0wuZmlsbCgwKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcclxuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcclxuICAgICAgICB0aGlzLkFoID0gMHg4YzNkMzdjOCB8IDA7XHJcbiAgICAgICAgdGhpcy5BbCA9IDB4MTk1NDRkYTIgfCAwO1xyXG4gICAgICAgIHRoaXMuQmggPSAweDczZTE5OTY2IHwgMDtcclxuICAgICAgICB0aGlzLkJsID0gMHg4OWRjZDRkNiB8IDA7XHJcbiAgICAgICAgdGhpcy5DaCA9IDB4MWRmYWI3YWUgfCAwO1xyXG4gICAgICAgIHRoaXMuQ2wgPSAweDMyZmY5YzgyIHwgMDtcclxuICAgICAgICB0aGlzLkRoID0gMHg2NzlkZDUxNCB8IDA7XHJcbiAgICAgICAgdGhpcy5EbCA9IDB4NTgyZjlmY2YgfCAwO1xyXG4gICAgICAgIHRoaXMuRWggPSAweDBmNmQyYjY5IHwgMDtcclxuICAgICAgICB0aGlzLkVsID0gMHg3YmQ0NGRhOCB8IDA7XHJcbiAgICAgICAgdGhpcy5GaCA9IDB4NzdlMzZmNzMgfCAwO1xyXG4gICAgICAgIHRoaXMuRmwgPSAweDA0YzQ4OTQyIHwgMDtcclxuICAgICAgICB0aGlzLkdoID0gMHgzZjlkODVhOCB8IDA7XHJcbiAgICAgICAgdGhpcy5HbCA9IDB4NmExZDM2YzggfCAwO1xyXG4gICAgICAgIHRoaXMuSGggPSAweDExMTJlNmFkIHwgMDtcclxuICAgICAgICB0aGlzLkhsID0gMHg5MWQ2OTJhMSB8IDA7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcclxuICAgIH1cclxufVxyXG5jbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcclxuICAgICAgICB0aGlzLkFoID0gMHgyMjMxMjE5NCB8IDA7XHJcbiAgICAgICAgdGhpcy5BbCA9IDB4ZmMyYmY3MmMgfCAwO1xyXG4gICAgICAgIHRoaXMuQmggPSAweDlmNTU1ZmEzIHwgMDtcclxuICAgICAgICB0aGlzLkJsID0gMHhjODRjNjRjMiB8IDA7XHJcbiAgICAgICAgdGhpcy5DaCA9IDB4MjM5M2I4NmIgfCAwO1xyXG4gICAgICAgIHRoaXMuQ2wgPSAweDZmNTNiMTUxIHwgMDtcclxuICAgICAgICB0aGlzLkRoID0gMHg5NjM4NzcxOSB8IDA7XHJcbiAgICAgICAgdGhpcy5EbCA9IDB4NTk0MGVhYmQgfCAwO1xyXG4gICAgICAgIHRoaXMuRWggPSAweDk2MjgzZWUyIHwgMDtcclxuICAgICAgICB0aGlzLkVsID0gMHhhODhlZmZlMyB8IDA7XHJcbiAgICAgICAgdGhpcy5GaCA9IDB4YmU1ZTFlMjUgfCAwO1xyXG4gICAgICAgIHRoaXMuRmwgPSAweDUzODYzOTkyIHwgMDtcclxuICAgICAgICB0aGlzLkdoID0gMHgyYjAxOTlmYyB8IDA7XHJcbiAgICAgICAgdGhpcy5HbCA9IDB4MmM4NWI4YWEgfCAwO1xyXG4gICAgICAgIHRoaXMuSGggPSAweDBlYjcyZGRjIHwgMDtcclxuICAgICAgICB0aGlzLkhsID0gMHg4MWM1MmNhMiB8IDA7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAzMjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xyXG4gICAgICAgIHRoaXMuQWggPSAweGNiYmI5ZDVkIHwgMDtcclxuICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XHJcbiAgICAgICAgdGhpcy5CaCA9IDB4NjI5YTI5MmEgfCAwO1xyXG4gICAgICAgIHRoaXMuQmwgPSAweDM2N2NkNTA3IHwgMDtcclxuICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XHJcbiAgICAgICAgdGhpcy5DbCA9IDB4MzA3MGRkMTcgfCAwO1xyXG4gICAgICAgIHRoaXMuRGggPSAweDE1MmZlY2Q4IHwgMDtcclxuICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XHJcbiAgICAgICAgdGhpcy5FaCA9IDB4NjczMzI2NjcgfCAwO1xyXG4gICAgICAgIHRoaXMuRWwgPSAweGZmYzAwYjMxIHwgMDtcclxuICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XHJcbiAgICAgICAgdGhpcy5GbCA9IDB4Njg1ODE1MTEgfCAwO1xyXG4gICAgICAgIHRoaXMuR2ggPSAweGRiMGMyZTBkIHwgMDtcclxuICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XHJcbiAgICAgICAgdGhpcy5IaCA9IDB4NDdiNTQ4MWQgfCAwO1xyXG4gICAgICAgIHRoaXMuSGwgPSAweGJlZmE0ZmE0IHwgMDtcclxuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjb25zdCBzaGE1MTIgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTIoKSk7XHJcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcclxuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xyXG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGE1MTIuanMubWFwIiwiLyogQnJvd3NlciBDcnlwdG8gU2hpbXMgKi9cclxuaW1wb3J0IHsgaG1hYyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2htYWNcIjtcclxuaW1wb3J0IHsgcGJrZGYyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvcGJrZGYyXCI7XHJcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xyXG5pbXBvcnQgeyBzaGE1MTIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGE1MTJcIjtcclxuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XHJcbn1cclxuO1xyXG5jb25zdCBhbnlHbG9iYWwgPSBnZXRHbG9iYWwoKTtcclxuY29uc3QgY3J5cHRvID0gYW55R2xvYmFsLmNyeXB0byB8fCBhbnlHbG9iYWwubXNDcnlwdG87XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoKGFsZ28pIHtcclxuICAgIHN3aXRjaCAoYWxnbykge1xyXG4gICAgICAgIGNhc2UgXCJzaGEyNTZcIjogcmV0dXJuIHNoYTI1Ni5jcmVhdGUoKTtcclxuICAgICAgICBjYXNlIFwic2hhNTEyXCI6IHJldHVybiBzaGE1MTIuY3JlYXRlKCk7XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGhhc2hpbmcgYWxnb3JpdGhtIG5hbWVcIiwgXCJhbGdvcml0aG1cIiwgYWxnbyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWMoX2FsZ28sIGtleSkge1xyXG4gICAgY29uc3QgYWxnbyA9ICh7IHNoYTI1Niwgc2hhNTEyIH1bX2FsZ29dKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KGFsZ28gIT0gbnVsbCwgXCJpbnZhbGlkIGhtYWMgYWxnb3JpdGhtXCIsIFwiYWxnb3JpdGhtXCIsIF9hbGdvKTtcclxuICAgIHJldHVybiBobWFjLmNyZWF0ZShhbGdvLCBrZXkpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBwYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIF9hbGdvKSB7XHJcbiAgICBjb25zdCBhbGdvID0gKHsgc2hhMjU2LCBzaGE1MTIgfVtfYWxnb10pO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoYWxnbyAhPSBudWxsLCBcImludmFsaWQgcGJrZGYyIGFsZ29yaXRobVwiLCBcImFsZ29yaXRobVwiLCBfYWxnbyk7XHJcbiAgICByZXR1cm4gcGJrZGYyKGFsZ28sIHBhc3N3b3JkLCBzYWx0LCB7IGM6IGl0ZXJhdGlvbnMsIGRrTGVuOiBrZXlsZW4gfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGxlbmd0aCkge1xyXG4gICAgYXNzZXJ0KGNyeXB0byAhPSBudWxsLCBcInBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgc2VjdXJlIHJhbmRvbSBudW1iZXJzXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICBvcGVyYXRpb246IFwicmFuZG9tQnl0ZXNcIlxyXG4gICAgfSk7XHJcbiAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkgJiYgbGVuZ3RoID4gMCAmJiBsZW5ndGggPD0gMTAyNCwgXCJpbnZhbGlkIGxlbmd0aFwiLCBcImxlbmd0aFwiLCBsZW5ndGgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcclxuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLWJyb3dzZXIuanMubWFwIiwiLyoqXHJcbiAqICBBbiAqKkhNQUMqKiBlbmFibGVzIHZlcmlmaWNhdGlvbiB0aGF0IGEgZ2l2ZW4ga2V5IHdhcyB1c2VkXHJcbiAqICB0byBhdXRoZW50aWNhdGUgYSBwYXlsb2FkLlxyXG4gKlxyXG4gKiAgU2VlOiBbW2xpbmstd2lraS1obWFjXV1cclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpITUFDICBbYWJvdXQtaG1hY11cclxuICovXHJcbmltcG9ydCB7IGNyZWF0ZUhtYWMgfSBmcm9tIFwiLi9jcnlwdG8uanNcIjtcclxuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxubGV0IGxvY2tlZCA9IGZhbHNlO1xyXG5jb25zdCBfY29tcHV0ZUhtYWMgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgIHJldHVybiBjcmVhdGVIbWFjKGFsZ29yaXRobSwga2V5KS51cGRhdGUoZGF0YSkuZGlnZXN0KCk7XHJcbn07XHJcbmxldCBfX2NvbXB1dGVIbWFjID0gX2NvbXB1dGVIbWFjO1xyXG4vKipcclxuICogIFJldHVybiB0aGUgSE1BQyBmb3IgJSVkYXRhJSUgdXNpbmcgdGhlICUla2V5JSUga2V5IHdpdGggdGhlIHVuZGVybHlpbmdcclxuICogICUlYWxnbyUlIHVzZWQgZm9yIGNvbXByZXNzaW9uLlxyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIGtleSA9IGlkKFwic29tZS1zZWNyZXRcIilcclxuICpcclxuICogICAgLy8gQ29tcHV0ZSB0aGUgSE1BQ1xyXG4gKiAgICBjb21wdXRlSG1hYyhcInNoYTI1NlwiLCBrZXksIFwiMHgxMzM3XCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgLy8gVG8gY29tcHV0ZSB0aGUgSE1BQyBvZiBVVEYtOCBkYXRhLCB0aGUgZGF0YSBtdXN0IGJlXHJcbiAqICAgIC8vIGNvbnZlcnRlZCB0byBVVEYtOCBieXRlc1xyXG4gKiAgICBjb21wdXRlSG1hYyhcInNoYTI1NlwiLCBrZXksIHRvVXRmOEJ5dGVzKFwiSGVsbG8gV29ybGRcIikpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSG1hYyhhbGdvcml0aG0sIF9rZXksIF9kYXRhKSB7XHJcbiAgICBjb25zdCBrZXkgPSBnZXRCeXRlcyhfa2V5LCBcImtleVwiKTtcclxuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xyXG4gICAgcmV0dXJuIGhleGxpZnkoX19jb21wdXRlSG1hYyhhbGdvcml0aG0sIGtleSwgZGF0YSkpO1xyXG59XHJcbmNvbXB1dGVIbWFjLl8gPSBfY29tcHV0ZUhtYWM7XHJcbmNvbXB1dGVIbWFjLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XHJcbmNvbXB1dGVIbWFjLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgIGlmIChsb2NrZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wdXRlSG1hYyBpcyBsb2NrZWRcIik7XHJcbiAgICB9XHJcbiAgICBfX2NvbXB1dGVIbWFjID0gZnVuYztcclxufTtcclxuT2JqZWN0LmZyZWV6ZShjb21wdXRlSG1hYyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIiwiaW1wb3J0IHsgYnl0ZXMsIGV4aXN0cywgbnVtYmVyLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xyXG5pbXBvcnQgeyByb3RsQkgsIHJvdGxCTCwgcm90bFNILCByb3RsU0wsIHNwbGl0IH0gZnJvbSAnLi9fdTY0LmpzJztcclxuaW1wb3J0IHsgSGFzaCwgdTMyLCB0b0J5dGVzLCB3cmFwQ29uc3RydWN0b3IsIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzLCB9IGZyb20gJy4vdXRpbHMuanMnO1xyXG4vLyBTSEEzIChrZWNjYWspIGlzIGJhc2VkIG9uIGEgbmV3IGRlc2lnbjogYmFzaWNhbGx5LCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXHJcbi8vIEl0J3MgY2FsbGVkIGEgc3BvbmdlIGZ1bmN0aW9uLlxyXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXHJcbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xyXG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xyXG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xyXG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xyXG5jb25zdCBfN24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpO1xyXG5jb25zdCBfMjU2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcclxuY29uc3QgXzB4NzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgweDcxKTtcclxuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcclxuICAgIC8vIFBpXHJcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XHJcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcclxuICAgIC8vIFJvdGF0aW9uYWxcclxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcclxuICAgIC8vIElvdGFcclxuICAgIGxldCB0ID0gXzBuO1xyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcclxuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XHJcbiAgICAgICAgaWYgKFIgJiBfMm4pXHJcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcclxuICAgIH1cclxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcclxufVxyXG5jb25zdCBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IC8qIEBfX1BVUkVfXyAqLyBzcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcclxuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXHJcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xyXG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJMKGgsIGwsIHMpIDogcm90bFNMKGgsIGwsIHMpKTtcclxuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXHJcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XHJcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcclxuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcclxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcclxuICAgICAgICAvLyBUaGV0YSDOuFxyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcclxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XHJcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcclxuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcclxuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcclxuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcclxuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xyXG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXHJcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xyXG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcclxuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XHJcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xyXG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcclxuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xyXG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XHJcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XHJcbiAgICAgICAgICAgIHNbUEldID0gVGg7XHJcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGkgKM+HKVxyXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxyXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXHJcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJb3RhICjOuSlcclxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcclxuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcclxuICAgIH1cclxuICAgIEIuZmlsbCgwKTtcclxufVxyXG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XHJcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxyXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcclxuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcclxuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcclxuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcclxuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcclxuICAgICAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xyXG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXHJcbiAgICAgICAgbnVtYmVyKG91dHB1dExlbik7XHJcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xyXG4gICAgICAgIGlmICgwID49IHRoaXMuYmxvY2tMZW4gfHwgdGhpcy5ibG9ja0xlbiA+PSAyMDApXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xyXG4gICAgICAgIHRoaXMuc3RhdGUzMiA9IHUzMih0aGlzLnN0YXRlKTtcclxuICAgIH1cclxuICAgIGtlY2NhaygpIHtcclxuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xyXG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcclxuICAgICAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZGF0YSkge1xyXG4gICAgICAgIGV4aXN0cyh0aGlzKTtcclxuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcclxuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcclxuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcclxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBmaW5pc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XHJcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcclxuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcclxuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxyXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xyXG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcclxuICAgICAgICB0aGlzLmtlY2NhaygpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbnRvKG91dCkge1xyXG4gICAgICAgIGV4aXN0cyh0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgYnl0ZXMob3V0KTtcclxuICAgICAgICB0aGlzLmZpbmlzaCgpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcclxuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcclxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xyXG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcclxuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcclxuICAgICAgICAgICAgcG9zICs9IHRha2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgICB4b2ZJbnRvKG91dCkge1xyXG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcclxuICAgIH1cclxuICAgIHhvZihieXRlcykge1xyXG4gICAgICAgIG51bWJlcihieXRlcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xyXG4gICAgfVxyXG4gICAgZGlnZXN0SW50byhvdXQpIHtcclxuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcclxuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xyXG4gICAgfVxyXG4gICAgX2Nsb25lSW50byh0bykge1xyXG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcclxuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcclxuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xyXG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xyXG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xyXG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcclxuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XHJcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXHJcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xyXG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcclxuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XHJcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xyXG5leHBvcnQgY29uc3Qgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCk7XHJcbi8qKlxyXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcclxuICovXHJcbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcclxuZXhwb3J0IGNvbnN0IHNoYTNfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMDQsIDM4NCAvIDgpO1xyXG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcclxuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XHJcbi8qKlxyXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxyXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcclxuZXhwb3J0IGNvbnN0IGtlY2Nha18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XHJcbmV4cG9ydCBjb25zdCBrZWNjYWtfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCA3MiwgNTEyIC8gOCk7XHJcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XHJcbmV4cG9ydCBjb25zdCBzaGFrZTEyOCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpO1xyXG5leHBvcnQgY29uc3Qgc2hha2UyNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiLCIvKipcclxuICogIENyeXB0b2dyYXBoaWMgaGFzaGluZyBmdW5jdGlvbnNcclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9ucyBbYWJvdXQtY3J5cHRvLWhhc2hpbmddXHJcbiAqL1xyXG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhM1wiO1xyXG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5sZXQgbG9ja2VkID0gZmFsc2U7XHJcbmNvbnN0IF9rZWNjYWsyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgcmV0dXJuIGtlY2Nha18yNTYoZGF0YSk7XHJcbn07XHJcbmxldCBfX2tlY2NhazI1NiA9IF9rZWNjYWsyNTY7XHJcbi8qKlxyXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBLRUNDQUsyNTYgaGFzaCBvZiAlJWRhdGElJS5cclxuICpcclxuICogIFRoZSAlJWRhdGElJSAqKm11c3QqKiBiZSBhIGRhdGEgcmVwcmVzZW50YXRpb24sIHRvIGNvbXB1dGUgdGhlXHJcbiAqICBoYXNoIG9mIFVURi04IGRhdGEgdXNlIHRoZSBbW2lkXV0gZnVuY3Rpb24uXHJcbiAqXHJcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXHJcbiAqICBAZXhhbXBsZTpcclxuICogICAga2VjY2FrMjU2KFwiMHhcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICBrZWNjYWsyNTYoXCIweDEzMzdcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICBrZWNjYWsyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIFN0cmluZ3MgYXJlIGFzc3VtZWQgdG8gYmUgRGF0YUhleFN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGxcclxuICogICAgLy8gdGhyb3cuIFRvIGhhc2ggVVRGLTggZGF0YSwgc2VlIHRoZSBub3RlIGFib3ZlLlxyXG4gKiAgICBrZWNjYWsyNTYoXCJIZWxsbyBXb3JsZFwiKVxyXG4gKiAgICAvL19lcnJvcjpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoX2RhdGEpIHtcclxuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xyXG4gICAgcmV0dXJuIGhleGxpZnkoX19rZWNjYWsyNTYoZGF0YSkpO1xyXG59XHJcbmtlY2NhazI1Ni5fID0gX2tlY2NhazI1Njtcclxua2VjY2FrMjU2LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XHJcbmtlY2NhazI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICBpZiAobG9ja2VkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtlY2NhazI1NiBpcyBsb2NrZWRcIik7XHJcbiAgICB9XHJcbiAgICBfX2tlY2NhazI1NiA9IGZ1bmM7XHJcbn07XHJcbk9iamVjdC5mcmVlemUoa2VjY2FrMjU2KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2VjY2FrLmpzLm1hcCIsImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcclxuaW1wb3J0IHsgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XHJcbi8vIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwLmh0bWxcclxuLy8gaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAvcGRmL0FCLTk2MDEvQUItOTYwMS5wZGZcclxuY29uc3QgUmhvID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50OEFycmF5KFs3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4XSk7XHJcbmNvbnN0IElkID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbSh7IGxlbmd0aDogMTYgfSwgKF8sIGkpID0+IGkpO1xyXG5jb25zdCBQaSA9IC8qIEBfX1BVUkVfXyAqLyBJZC5tYXAoKGkpID0+ICg5ICogaSArIDUpICUgMTYpO1xyXG5sZXQgaWR4TCA9IFtJZF07XHJcbmxldCBpZHhSID0gW1BpXTtcclxuZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspXHJcbiAgICBmb3IgKGxldCBqIG9mIFtpZHhMLCBpZHhSXSlcclxuICAgICAgICBqLnB1c2goaltpXS5tYXAoKGspID0+IFJob1trXSkpO1xyXG5jb25zdCBzaGlmdHMgPSAvKiBAX19QVVJFX18gKi8gW1xyXG4gICAgWzExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOF0sXHJcbiAgICBbMTIsIDEzLCAxMSwgMTUsIDYsIDksIDksIDcsIDEyLCAxNSwgMTEsIDEzLCA3LCA4LCA3LCA3XSxcclxuICAgIFsxMywgMTUsIDE0LCAxMSwgNywgNywgNiwgOCwgMTMsIDE0LCAxMywgMTIsIDUsIDUsIDYsIDldLFxyXG4gICAgWzE0LCAxMSwgMTIsIDE0LCA4LCA2LCA1LCA1LCAxNSwgMTIsIDE1LCAxNCwgOSwgOSwgOCwgNl0sXHJcbiAgICBbMTUsIDEyLCAxMywgMTMsIDksIDUsIDgsIDYsIDE0LCAxMSwgMTIsIDExLCA4LCA2LCA1LCA1XSxcclxuXS5tYXAoKGkpID0+IG5ldyBVaW50OEFycmF5KGkpKTtcclxuY29uc3Qgc2hpZnRzTCA9IC8qIEBfX1BVUkVfXyAqLyBpZHhMLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHNbaV1bal0pKTtcclxuY29uc3Qgc2hpZnRzUiA9IC8qIEBfX1BVUkVfXyAqLyBpZHhSLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHNbaV1bal0pKTtcclxuY29uc3QgS2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcclxuICAgIDB4MDAwMDAwMDAsIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4YTk1M2ZkNGUsXHJcbl0pO1xyXG5jb25zdCBLciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xyXG4gICAgMHg1MGEyOGJlNiwgMHg1YzRkZDEyNCwgMHg2ZDcwM2VmMywgMHg3YTZkNzZlOSwgMHgwMDAwMDAwMCxcclxuXSk7XHJcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcclxuY29uc3Qgcm90bCA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgc2hpZnQpIHwgKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSk7XHJcbi8vIEl0J3MgY2FsbGVkIGYoKSBpbiBzcGVjLlxyXG5mdW5jdGlvbiBmKGdyb3VwLCB4LCB5LCB6KSB7XHJcbiAgICBpZiAoZ3JvdXAgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHggXiB5IF4gejtcclxuICAgIGVsc2UgaWYgKGdyb3VwID09PSAxKVxyXG4gICAgICAgIHJldHVybiAoeCAmIHkpIHwgKH54ICYgeik7XHJcbiAgICBlbHNlIGlmIChncm91cCA9PT0gMilcclxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xyXG4gICAgZWxzZSBpZiAoZ3JvdXAgPT09IDMpXHJcbiAgICAgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmIH56KTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4geCBeICh5IHwgfnopO1xyXG59XHJcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xyXG5jb25zdCBCVUYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcclxuZXhwb3J0IGNsYXNzIFJJUEVNRDE2MCBleHRlbmRzIFNIQTIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoNjQsIDIwLCA4LCB0cnVlKTtcclxuICAgICAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMSB8IDA7XHJcbiAgICAgICAgdGhpcy5oMSA9IDB4ZWZjZGFiODkgfCAwO1xyXG4gICAgICAgIHRoaXMuaDIgPSAweDk4YmFkY2ZlIHwgMDtcclxuICAgICAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NiB8IDA7XHJcbiAgICAgICAgdGhpcy5oNCA9IDB4YzNkMmUxZjAgfCAwO1xyXG4gICAgfVxyXG4gICAgZ2V0KCkge1xyXG4gICAgICAgIGNvbnN0IHsgaDAsIGgxLCBoMiwgaDMsIGg0IH0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBbaDAsIGgxLCBoMiwgaDMsIGg0XTtcclxuICAgIH1cclxuICAgIHNldChoMCwgaDEsIGgyLCBoMywgaDQpIHtcclxuICAgICAgICB0aGlzLmgwID0gaDAgfCAwO1xyXG4gICAgICAgIHRoaXMuaDEgPSBoMSB8IDA7XHJcbiAgICAgICAgdGhpcy5oMiA9IGgyIHwgMDtcclxuICAgICAgICB0aGlzLmgzID0gaDMgfCAwO1xyXG4gICAgICAgIHRoaXMuaDQgPSBoNCB8IDA7XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXHJcbiAgICAgICAgICAgIEJVRltpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XHJcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgICAgbGV0IGFsID0gdGhpcy5oMCB8IDAsIGFyID0gYWwsIGJsID0gdGhpcy5oMSB8IDAsIGJyID0gYmwsIGNsID0gdGhpcy5oMiB8IDAsIGNyID0gY2wsIGRsID0gdGhpcy5oMyB8IDAsIGRyID0gZGwsIGVsID0gdGhpcy5oNCB8IDAsIGVyID0gZWw7XHJcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBpdGVyYXRpbmcgMCB0byA4MCwgd2Ugc3BsaXQgaXQgaW50byA1IGdyb3Vwc1xyXG4gICAgICAgIC8vIEFuZCB1c2UgdGhlIGdyb3VwcyBpbiBjb25zdGFudHMsIGZ1bmN0aW9ucywgZXRjLiBNdWNoIHNpbXBsZXJcclxuICAgICAgICBmb3IgKGxldCBncm91cCA9IDA7IGdyb3VwIDwgNTsgZ3JvdXArKykge1xyXG4gICAgICAgICAgICBjb25zdCByR3JvdXAgPSA0IC0gZ3JvdXA7XHJcbiAgICAgICAgICAgIGNvbnN0IGhibCA9IEtsW2dyb3VwXSwgaGJyID0gS3JbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgICAgICAgICAgY29uc3QgcmwgPSBpZHhMW2dyb3VwXSwgcnIgPSBpZHhSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgICAgICAgIGNvbnN0IHNsID0gc2hpZnRzTFtncm91cF0sIHNyID0gc2hpZnRzUltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRsID0gKHJvdGwoYWwgKyBmKGdyb3VwLCBibCwgY2wsIGRsKSArIEJVRltybFtpXV0gKyBoYmwsIHNsW2ldKSArIGVsKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBhbCA9IGVsLCBlbCA9IGRsLCBkbCA9IHJvdGwoY2wsIDEwKSB8IDAsIGNsID0gYmwsIGJsID0gdGw7IC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDIgbG9vcHMgYXJlIDEwJSBmYXN0ZXJcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ciA9IChyb3RsKGFyICsgZihyR3JvdXAsIGJyLCBjciwgZHIpICsgQlVGW3JyW2ldXSArIGhiciwgc3JbaV0pICsgZXIpIHwgMDtcclxuICAgICAgICAgICAgICAgIGFyID0gZXIsIGVyID0gZHIsIGRyID0gcm90bChjciwgMTApIHwgMCwgY3IgPSBiciwgYnIgPSB0cjsgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcclxuICAgICAgICB0aGlzLnNldCgodGhpcy5oMSArIGNsICsgZHIpIHwgMCwgKHRoaXMuaDIgKyBkbCArIGVyKSB8IDAsICh0aGlzLmgzICsgZWwgKyBhcikgfCAwLCAodGhpcy5oNCArIGFsICsgYnIpIHwgMCwgKHRoaXMuaDAgKyBibCArIGNyKSB8IDApO1xyXG4gICAgfVxyXG4gICAgcm91bmRDbGVhbigpIHtcclxuICAgICAgICBCVUYuZmlsbCgwKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XHJcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJJUEVNRC0xNjAgLSBhIGhhc2ggZnVuY3Rpb24gZnJvbSAxOTkwcy5cclxuICogQHBhcmFtIG1lc3NhZ2UgLSBtc2cgdGhhdCB3b3VsZCBiZSBoYXNoZWRcclxuICovXHJcbmV4cG9ydCBjb25zdCByaXBlbWQxNjAgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBSSVBFTUQxNjAoKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpcGVtZDE2MC5qcy5tYXAiLCJpbXBvcnQgeyByaXBlbWQxNjAgYXMgbm9ibGVfcmlwZW1kMTYwIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvcmlwZW1kMTYwXCI7XHJcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmxldCBsb2NrZWQgPSBmYWxzZTtcclxuY29uc3QgX3JpcGVtZDE2MCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gbm9ibGVfcmlwZW1kMTYwKGRhdGEpO1xyXG59O1xyXG5sZXQgX19yaXBlbWQxNjAgPSBfcmlwZW1kMTYwO1xyXG4vKipcclxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgUklQRU1ELTE2MCBoYXNoIG9mICUlZGF0YSUlLlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnNcclxuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICByaXBlbWQxNjAoXCIweFwiKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIHJpcGVtZDE2MChcIjB4MTMzN1wiKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIHJpcGVtZDE2MChuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByaXBlbWQxNjAoX2RhdGEpIHtcclxuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xyXG4gICAgcmV0dXJuIGhleGxpZnkoX19yaXBlbWQxNjAoZGF0YSkpO1xyXG59XHJcbnJpcGVtZDE2MC5fID0gX3JpcGVtZDE2MDtcclxucmlwZW1kMTYwLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XHJcbnJpcGVtZDE2MC5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICBpZiAobG9ja2VkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJpcGVtZDE2MCBpcyBsb2NrZWRcIik7XHJcbiAgICB9XHJcbiAgICBfX3JpcGVtZDE2MCA9IGZ1bmM7XHJcbn07XHJcbk9iamVjdC5mcmVlemUocmlwZW1kMTYwKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlwZW1kMTYwLmpzLm1hcCIsIi8qKlxyXG4gKiAgQSAqKlBhc3N3b3JkLUJhc2VkIEtleS1EZXJpdmF0aW9uIEZ1bmN0aW9uKiogaXMgZGVzaWduZWQgdG8gY3JlYXRlXHJcbiAqICBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN1aXRpYmxlIGFzIGEgKiprZXkqKiBmcm9tIGEgaHVtYW4tcmVtZW1iZXJhYmxlXHJcbiAqICBwYXNzd29yZC5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpQYXNzd29yZHMgIFthYm91dC1wYmtkZl1cclxuICovXHJcbmltcG9ydCB7IHBia2RmMlN5bmMgfSBmcm9tIFwiLi9jcnlwdG8uanNcIjtcclxuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxubGV0IGxvY2tlZCA9IGZhbHNlO1xyXG5jb25zdCBfcGJrZGYyID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pIHtcclxuICAgIHJldHVybiBwYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pO1xyXG59O1xyXG5sZXQgX19wYmtkZjIgPSBfcGJrZGYyO1xyXG4vKipcclxuICogIFJldHVybiB0aGUgW1tsaW5rLXBia2RmMl1dIGZvciAlJWtleWxlbiUlIGJ5dGVzIGZvciAlJXBhc3N3b3JkJSUgdXNpbmdcclxuICogIHRoZSAlJXNhbHQlJSBhbmQgdXNpbmcgJSVpdGVyYXRpb25zJSUgb2YgJSVhbGdvJSUuXHJcbiAqXHJcbiAqICBUaGlzIFBCS0RGIGlzIG91dGRhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgaW4gbmV3IHByb2plY3RzLCBidXQgaXNcclxuICogIHJlcXVpcmVkIHRvIGRlY3J5cHQgb2xkZXIgZmlsZXMuXHJcbiAqXHJcbiAqICBAZXhhbXBsZTpcclxuICogICAgLy8gVGhlIHBhc3N3b3JkIG11c3QgYmUgY29udmVydGVkIHRvIGJ5dGVzLCBhbmQgaXQgaXMgZ2VuZXJhbGx5XHJcbiAqICAgIC8vIGJlc3QgcHJhY3RpY2VzIHRvIGVuc3VyZSB0aGUgc3RyaW5nIGhhcyBiZWVuIG5vcm1hbGl6ZWQuIE1hbnlcclxuICogICAgLy8gZm9ybWF0cyBleHBsaWNpdGx5IGluZGljYXRlIHRoZSBub3JtYWxpemF0aW9uIGZvcm0gdG8gdXNlLlxyXG4gKiAgICBwYXNzd29yZCA9IFwiaGVsbG9cIlxyXG4gKiAgICBwYXNzd29yZEJ5dGVzID0gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFwiTkZLQ1wiKVxyXG4gKlxyXG4gKiAgICBzYWx0ID0gaWQoXCJzb21lLXNhbHRcIilcclxuICpcclxuICogICAgLy8gQ29tcHV0ZSB0aGUgUEJLREYyXHJcbiAqICAgIHBia2RmMihwYXNzd29yZEJ5dGVzLCBzYWx0LCAxMDI0LCAxNiwgXCJzaGEyNTZcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMihfcGFzc3dvcmQsIF9zYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pIHtcclxuICAgIGNvbnN0IHBhc3N3b3JkID0gZ2V0Qnl0ZXMoX3Bhc3N3b3JkLCBcInBhc3N3b3JkXCIpO1xyXG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XHJcbiAgICByZXR1cm4gaGV4bGlmeShfX3Bia2RmMihwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBhbGdvKSk7XHJcbn1cclxucGJrZGYyLl8gPSBfcGJrZGYyO1xyXG5wYmtkZjIubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcclxucGJrZGYyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgIGlmIChsb2NrZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYmtkZjIgaXMgbG9ja2VkXCIpO1xyXG4gICAgfVxyXG4gICAgX19wYmtkZjIgPSBmdW5jO1xyXG59O1xyXG5PYmplY3QuZnJlZXplKHBia2RmMik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiLCIvKipcclxuICogIEEgKipDcnlwdG9ncmFwaGljYWxseSBTZWN1cmUgUmFuZG9tIFZhbHVlKiogaXMgb25lIHRoYXQgaGFzIGJlZW5cclxuICogIGdlbmVyYXRlZCB3aXRoIGFkZGl0aW9uYWwgY2FyZSB0YWtlIHRvIHByZXZlbnQgc2lkZS1jaGFubmVsc1xyXG4gKiAgZnJvbSBhbGxvd2luZyBvdGhlcnMgdG8gZGV0ZWN0IGl0IGFuZCBwcmV2ZW50IG90aGVycyBmcm9tIHRocm91Z2hcclxuICogIGNvaW5jaWRlbmNlIGdlbmVyYXRlIHRoZSBzYW1lIHZhbHVlcy5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpSYW5kb20gVmFsdWVzICBbYWJvdXQtY3J5cHRvLXJhbmRvbV1cclxuICovXHJcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIGFzIGNyeXB0b19yYW5kb20gfSBmcm9tIFwiLi9jcnlwdG8uanNcIjtcclxubGV0IGxvY2tlZCA9IGZhbHNlO1xyXG5jb25zdCBfcmFuZG9tQnl0ZXMgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3JhbmRvbShsZW5ndGgpKTtcclxufTtcclxubGV0IF9fcmFuZG9tQnl0ZXMgPSBfcmFuZG9tQnl0ZXM7XHJcbi8qKlxyXG4gKiAgUmV0dXJuICUlbGVuZ3RoJSUgYnl0ZXMgb2YgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbSBkYXRhLlxyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIHJhbmRvbUJ5dGVzKDgpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGgpIHtcclxuICAgIHJldHVybiBfX3JhbmRvbUJ5dGVzKGxlbmd0aCk7XHJcbn1cclxucmFuZG9tQnl0ZXMuXyA9IF9yYW5kb21CeXRlcztcclxucmFuZG9tQnl0ZXMubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcclxucmFuZG9tQnl0ZXMucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgaWYgKGxvY2tlZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhbmRvbUJ5dGVzIGlzIGxvY2tlZFwiKTtcclxuICAgIH1cclxuICAgIF9fcmFuZG9tQnl0ZXMgPSBmdW5jO1xyXG59O1xyXG5PYmplY3QuZnJlZXplKHJhbmRvbUJ5dGVzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLmpzLm1hcCIsImltcG9ydCB7IG51bWJlciBhcyBhc3NlcnROdW1iZXIgfSBmcm9tICcuL19hc3NlcnQuanMnO1xyXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICcuL3NoYTI1Ni5qcyc7XHJcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gJy4vcGJrZGYyLmpzJztcclxuaW1wb3J0IHsgYXN5bmNMb29wLCBjaGVja09wdHMsIHUzMiB9IGZyb20gJy4vdXRpbHMuanMnO1xyXG4vLyBSRkMgNzkxNCBTY3J5cHQgS0RGXHJcbi8vIExlZnQgcm90YXRlIGZvciB1aW50MzJcclxuY29uc3Qgcm90bCA9IChhLCBiKSA9PiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSk7XHJcbi8vIFRoZSBtYWluIFNjcnlwdCBsb29wOiB1c2VzIFNhbHNhIGV4dGVuc2l2ZWx5LlxyXG4vLyBTaXggdmVyc2lvbnMgb2YgdGhlIGZ1bmN0aW9uIHdlcmUgdHJpZWQsIHRoaXMgaXMgdGhlIGZhc3Rlc3Qgb25lLlxyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuZnVuY3Rpb24gWG9yQW5kU2Fsc2EocHJldiwgcGksIGlucHV0LCBpaSwgb3V0LCBvaSkge1xyXG4gICAgLy8gQmFzZWQgb24gaHR0cHM6Ly9jci55cC50by9zYWxzYTIwLmh0bWxcclxuICAgIC8vIFhvciBibG9ja3NcclxuICAgIGxldCB5MDAgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwMSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MDIgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwMyA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MDQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MDYgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwNyA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MDggPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwOSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MTAgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxMSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MTIgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxMyA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIGxldCB5MTQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcclxuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlcyAoc2Fsc2EpXHJcbiAgICBsZXQgeDAwID0geTAwLCB4MDEgPSB5MDEsIHgwMiA9IHkwMiwgeDAzID0geTAzLCB4MDQgPSB5MDQsIHgwNSA9IHkwNSwgeDA2ID0geTA2LCB4MDcgPSB5MDcsIHgwOCA9IHkwOCwgeDA5ID0geTA5LCB4MTAgPSB5MTAsIHgxMSA9IHkxMSwgeDEyID0geTEyLCB4MTMgPSB5MTMsIHgxNCA9IHkxNCwgeDE1ID0geTE1O1xyXG4gICAgLy8gTWFpbiBsb29wIChzYWxzYSlcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XHJcbiAgICAgICAgeDA0IF49IHJvdGwoeDAwICsgeDEyIHwgMCwgNyk7XHJcbiAgICAgICAgeDA4IF49IHJvdGwoeDA0ICsgeDAwIHwgMCwgOSk7XHJcbiAgICAgICAgeDEyIF49IHJvdGwoeDA4ICsgeDA0IHwgMCwgMTMpO1xyXG4gICAgICAgIHgwMCBePSByb3RsKHgxMiArIHgwOCB8IDAsIDE4KTtcclxuICAgICAgICB4MDkgXj0gcm90bCh4MDUgKyB4MDEgfCAwLCA3KTtcclxuICAgICAgICB4MTMgXj0gcm90bCh4MDkgKyB4MDUgfCAwLCA5KTtcclxuICAgICAgICB4MDEgXj0gcm90bCh4MTMgKyB4MDkgfCAwLCAxMyk7XHJcbiAgICAgICAgeDA1IF49IHJvdGwoeDAxICsgeDEzIHwgMCwgMTgpO1xyXG4gICAgICAgIHgxNCBePSByb3RsKHgxMCArIHgwNiB8IDAsIDcpO1xyXG4gICAgICAgIHgwMiBePSByb3RsKHgxNCArIHgxMCB8IDAsIDkpO1xyXG4gICAgICAgIHgwNiBePSByb3RsKHgwMiArIHgxNCB8IDAsIDEzKTtcclxuICAgICAgICB4MTAgXj0gcm90bCh4MDYgKyB4MDIgfCAwLCAxOCk7XHJcbiAgICAgICAgeDAzIF49IHJvdGwoeDE1ICsgeDExIHwgMCwgNyk7XHJcbiAgICAgICAgeDA3IF49IHJvdGwoeDAzICsgeDE1IHwgMCwgOSk7XHJcbiAgICAgICAgeDExIF49IHJvdGwoeDA3ICsgeDAzIHwgMCwgMTMpO1xyXG4gICAgICAgIHgxNSBePSByb3RsKHgxMSArIHgwNyB8IDAsIDE4KTtcclxuICAgICAgICB4MDEgXj0gcm90bCh4MDAgKyB4MDMgfCAwLCA3KTtcclxuICAgICAgICB4MDIgXj0gcm90bCh4MDEgKyB4MDAgfCAwLCA5KTtcclxuICAgICAgICB4MDMgXj0gcm90bCh4MDIgKyB4MDEgfCAwLCAxMyk7XHJcbiAgICAgICAgeDAwIF49IHJvdGwoeDAzICsgeDAyIHwgMCwgMTgpO1xyXG4gICAgICAgIHgwNiBePSByb3RsKHgwNSArIHgwNCB8IDAsIDcpO1xyXG4gICAgICAgIHgwNyBePSByb3RsKHgwNiArIHgwNSB8IDAsIDkpO1xyXG4gICAgICAgIHgwNCBePSByb3RsKHgwNyArIHgwNiB8IDAsIDEzKTtcclxuICAgICAgICB4MDUgXj0gcm90bCh4MDQgKyB4MDcgfCAwLCAxOCk7XHJcbiAgICAgICAgeDExIF49IHJvdGwoeDEwICsgeDA5IHwgMCwgNyk7XHJcbiAgICAgICAgeDA4IF49IHJvdGwoeDExICsgeDEwIHwgMCwgOSk7XHJcbiAgICAgICAgeDA5IF49IHJvdGwoeDA4ICsgeDExIHwgMCwgMTMpO1xyXG4gICAgICAgIHgxMCBePSByb3RsKHgwOSArIHgwOCB8IDAsIDE4KTtcclxuICAgICAgICB4MTIgXj0gcm90bCh4MTUgKyB4MTQgfCAwLCA3KTtcclxuICAgICAgICB4MTMgXj0gcm90bCh4MTIgKyB4MTUgfCAwLCA5KTtcclxuICAgICAgICB4MTQgXj0gcm90bCh4MTMgKyB4MTIgfCAwLCAxMyk7XHJcbiAgICAgICAgeDE1IF49IHJvdGwoeDE0ICsgeDEzIHwgMCwgMTgpO1xyXG4gICAgfVxyXG4gICAgLy8gV3JpdGUgb3V0cHV0IChzYWxzYSlcclxuICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDEgKyB4MDEpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDIgKyB4MDIpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDQgKyB4MDQpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDUgKyB4MDUpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDcgKyB4MDcpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDggKyB4MDgpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTAgKyB4MTApIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTEgKyB4MTEpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTMgKyB4MTMpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTQgKyB4MTQpIHwgMDtcclxuICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcclxufVxyXG5mdW5jdGlvbiBCbG9ja01peChpbnB1dCwgaWksIG91dCwgb2ksIHIpIHtcclxuICAgIC8vIFRoZSBibG9jayBCIGlzIHIgMTI4LWJ5dGUgY2h1bmtzICh3aGljaCBpcyBlcXVpdmFsZW50IG9mIDJyIDY0LWJ5dGUgY2h1bmtzKVxyXG4gICAgbGV0IGhlYWQgPSBvaSArIDA7XHJcbiAgICBsZXQgdGFpbCA9IG9pICsgMTYgKiByO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKVxyXG4gICAgICAgIG91dFt0YWlsICsgaV0gPSBpbnB1dFtpaSArICgyICogciAtIDEpICogMTYgKyBpXTsgLy8gWCDihpAgQlsycuKIkjFdXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHI7IGkrKywgaGVhZCArPSAxNiwgaWkgKz0gMTYpIHtcclxuICAgICAgICAvLyBXZSB3cml0ZSBvZGQgJiBldmVuIFlpIGF0IHNhbWUgdGltZS4gRXZlbjogMGJYWFhYWDAgT2RkOiAgMGJYWFhYWDFcclxuICAgICAgICBYb3JBbmRTYWxzYShvdXQsIHRhaWwsIGlucHV0LCBpaSwgb3V0LCBoZWFkKTsgLy8gaGVhZFtpXSA9IFNhbHNhKGJsb2NrSW5bMippXSBeIHRhaWxbaS0xXSlcclxuICAgICAgICBpZiAoaSA+IDApXHJcbiAgICAgICAgICAgIHRhaWwgKz0gMTY7IC8vIEZpcnN0IGl0ZXJhdGlvbiBvdmVyd3JpdGVzIHRtcCB2YWx1ZSBpbiB0YWlsXHJcbiAgICAgICAgWG9yQW5kU2Fsc2Eob3V0LCBoZWFkLCBpbnB1dCwgKGlpICs9IDE2KSwgb3V0LCB0YWlsKTsgLy8gdGFpbFtpXSA9IFNhbHNhKGJsb2NrSW5bMippKzFdIF4gaGVhZFtpXSlcclxuICAgIH1cclxufVxyXG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xyXG5mdW5jdGlvbiBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBfb3B0cykge1xyXG4gICAgLy8gTWF4bWVtIC0gMUdCKzFLQiBieSBkZWZhdWx0XHJcbiAgICBjb25zdCBvcHRzID0gY2hlY2tPcHRzKHtcclxuICAgICAgICBka0xlbjogMzIsXHJcbiAgICAgICAgYXN5bmNUaWNrOiAxMCxcclxuICAgICAgICBtYXhtZW06IDEwMjQgKiogMyArIDEwMjQsXHJcbiAgICB9LCBfb3B0cyk7XHJcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBhc3luY1RpY2ssIG1heG1lbSwgb25Qcm9ncmVzcyB9ID0gb3B0cztcclxuICAgIGFzc2VydE51bWJlcihOKTtcclxuICAgIGFzc2VydE51bWJlcihyKTtcclxuICAgIGFzc2VydE51bWJlcihwKTtcclxuICAgIGFzc2VydE51bWJlcihka0xlbik7XHJcbiAgICBhc3NlcnROdW1iZXIoYXN5bmNUaWNrKTtcclxuICAgIGFzc2VydE51bWJlcihtYXhtZW0pO1xyXG4gICAgaWYgKG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb25Qcm9ncmVzcyAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2dyZXNzQ2Igc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XHJcbiAgICBjb25zdCBibG9ja1NpemUgPSAxMjggKiByO1xyXG4gICAgY29uc3QgYmxvY2tTaXplMzIgPSBibG9ja1NpemUgLyA0O1xyXG4gICAgaWYgKE4gPD0gMSB8fCAoTiAmIChOIC0gMSkpICE9PSAwIHx8IE4gPj0gMiAqKiAoYmxvY2tTaXplIC8gOCkgfHwgTiA+IDIgKiogMzIpIHtcclxuICAgICAgICAvLyBOT1RFOiB3ZSBsaW1pdCBOIHRvIGJlIGxlc3MgdGhhbiAyKiozMiBiZWNhdXNlIG9mIDMyIGJpdCB2YXJpYW50IG9mIEludGVncmlmeSBmdW5jdGlvblxyXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIEpTIGVuZ2luZXMgdGhhdCBhbGxvd3MgYWxvY2F0ZSBtb3JlIHRoYW4gNEdCIHBlciBzaW5nbGUgVWludDhBcnJheSBmb3Igbm93LCBidXQgY2FuIGNoYW5nZSBpbiBmdXR1cmUuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY3J5cHQ6IE4gbXVzdCBiZSBsYXJnZXIgdGhhbiAxLCBhIHBvd2VyIG9mIDIsIGxlc3MgdGhhbiAyXigxMjggKiByIC8gOCkgYW5kIGxlc3MgdGhhbiAyXjMyJyk7XHJcbiAgICB9XHJcbiAgICBpZiAocCA8IDAgfHwgcCA+ICgoMiAqKiAzMiAtIDEpICogMzIpIC8gYmxvY2tTaXplKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY3J5cHQ6IHAgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICgoMl4zMiAtIDEpICogMzIpIC8gKDEyOCAqIHIpJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGtMZW4gPCAwIHx8IGRrTGVuID4gKDIgKiogMzIgLSAxKSAqIDMyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY3J5cHQ6IGRrTGVuIHNob3VsZCBiZSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiBvciBlcXVhbCB0byAoMl4zMiAtIDEpICogMzInKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1lbVVzZWQgPSBibG9ja1NpemUgKiAoTiArIHApO1xyXG4gICAgaWYgKG1lbVVzZWQgPiBtYXhtZW0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjcnlwdDogcGFyYW1ldGVycyB0b28gbGFyZ2UsICR7bWVtVXNlZH0gKDEyOCAqIHIgKiAoTiArIHApKSA+ICR7bWF4bWVtfSAobWF4bWVtKWApO1xyXG4gICAgfVxyXG4gICAgLy8gW0IwLi4uQnDiiJIxXSDihpAgUEJLREYySE1BQy1TSEEyNTYoUGFzc3BocmFzZSwgU2FsdCwgMSwgYmxvY2tTaXplKlBhcmFsbGVsaXphdGlvbkZhY3RvcilcclxuICAgIC8vIFNpbmNlIGl0IGhhcyBvbmx5IG9uZSBpdGVyYXRpb24gdGhlcmUgaXMgbm8gcmVhc29uIHRvIHVzZSBhc3luYyB2YXJpYW50XHJcbiAgICBjb25zdCBCID0gcGJrZGYyKHNoYTI1NiwgcGFzc3dvcmQsIHNhbHQsIHsgYzogMSwgZGtMZW46IGJsb2NrU2l6ZSAqIHAgfSk7XHJcbiAgICBjb25zdCBCMzIgPSB1MzIoQik7XHJcbiAgICAvLyBSZS11c2VkIGJldHdlZW4gcGFyYWxsZWwgaXRlcmF0aW9ucy4gQXJyYXkoaXRlcmF0aW9ucykgb2YgQlxyXG4gICAgY29uc3QgViA9IHUzMihuZXcgVWludDhBcnJheShibG9ja1NpemUgKiBOKSk7XHJcbiAgICBjb25zdCB0bXAgPSB1MzIobmV3IFVpbnQ4QXJyYXkoYmxvY2tTaXplKSk7XHJcbiAgICBsZXQgYmxvY2tNaXhDYiA9ICgpID0+IHsgfTtcclxuICAgIGlmIChvblByb2dyZXNzKSB7XHJcbiAgICAgICAgY29uc3QgdG90YWxCbG9ja01peCA9IDIgKiBOICogcDtcclxuICAgICAgICAvLyBJbnZva2UgY2FsbGJhY2sgaWYgcHJvZ3Jlc3MgY2hhbmdlcyBmcm9tIDEwLjAxIHRvIDEwLjAyXHJcbiAgICAgICAgLy8gQWxsb3dzIHRvIGRyYXcgc21vb3RoIHByb2dyZXNzIGJhciBvbiB1cCB0byA4SyBzY3JlZW5cclxuICAgICAgICBjb25zdCBjYWxsYmFja1BlciA9IE1hdGgubWF4KE1hdGguZmxvb3IodG90YWxCbG9ja01peCAvIDEwMDAwKSwgMSk7XHJcbiAgICAgICAgbGV0IGJsb2NrTWl4Q250ID0gMDtcclxuICAgICAgICBibG9ja01peENiID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBibG9ja01peENudCsrO1xyXG4gICAgICAgICAgICBpZiAob25Qcm9ncmVzcyAmJiAoIShibG9ja01peENudCAlIGNhbGxiYWNrUGVyKSB8fCBibG9ja01peENudCA9PT0gdG90YWxCbG9ja01peCkpXHJcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKGJsb2NrTWl4Q250IC8gdG90YWxCbG9ja01peCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9O1xyXG59XHJcbmZ1bmN0aW9uIHNjcnlwdE91dHB1dChwYXNzd29yZCwgZGtMZW4sIEIsIFYsIHRtcCkge1xyXG4gICAgY29uc3QgcmVzID0gcGJrZGYyKHNoYTI1NiwgcGFzc3dvcmQsIEIsIHsgYzogMSwgZGtMZW4gfSk7XHJcbiAgICBCLmZpbGwoMCk7XHJcbiAgICBWLmZpbGwoMCk7XHJcbiAgICB0bXAuZmlsbCgwKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLyoqXHJcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC5cclxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc1xyXG4gKiBAcGFyYW0gc2FsdCAtIHNhbHRcclxuICogQHBhcmFtIG9wdHMgLSBwYXJhbWV0ZXJzXHJcbiAqIC0gYE5gIGlzIGNwdS9tZW0gd29yayBmYWN0b3IgKHBvd2VyIG9mIDIgZS5nLiAyKioxOClcclxuICogLSBgcmAgaXMgYmxvY2sgc2l6ZSAoOCBpcyBjb21tb24pLCBmaW5lLXR1bmVzIHNlcXVlbnRpYWwgbWVtb3J5IHJlYWQgc2l6ZSBhbmQgcGVyZm9ybWFuY2VcclxuICogLSBgcGAgaXMgcGFyYWxsZWxpemF0aW9uIGZhY3RvciAoMSBpcyBjb21tb24pXHJcbiAqIC0gYGRrTGVuYCBpcyBvdXRwdXQga2V5IGxlbmd0aCBpbiBieXRlcyBlLmcuIDMyLlxyXG4gKiAtIGBhc3luY1RpY2tgIC0gKGRlZmF1bHQ6IDEwKSBtYXggdGltZSBpbiBtcyBmb3Igd2hpY2ggYXN5bmMgZnVuY3Rpb24gY2FuIGJsb2NrIGV4ZWN1dGlvblxyXG4gKiAtIGBtYXhtZW1gIC0gKGRlZmF1bHQ6IGAxMDI0ICoqIDMgKyAxMDI0YCBha2EgMUdCKzFLQikuIEEgbGltaXQgdGhhdCB0aGUgYXBwIGNvdWxkIHVzZSBmb3Igc2NyeXB0XHJcbiAqIC0gYG9uUHJvZ3Jlc3NgIC0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSBleGVjdXRlZCBmb3IgcHJvZ3Jlc3MgcmVwb3J0XHJcbiAqIEByZXR1cm5zIERlcml2ZWQga2V5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XHJcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IgfSA9IHNjcnlwdEluaXQocGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xyXG4gICAgZm9yIChsZXQgcGkgPSAwOyBwaSA8IHA7IHBpKyspIHtcclxuICAgICAgICBjb25zdCBQaSA9IGJsb2NrU2l6ZTMyICogcGk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemUzMjsgaSsrKVxyXG4gICAgICAgICAgICBWW2ldID0gQjMyW1BpICsgaV07IC8vIFZbMF0gPSBCW2ldXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBOIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIEJsb2NrTWl4KFYsIHBvcywgViwgKHBvcyArPSBibG9ja1NpemUzMiksIHIpOyAvLyBWW2ldID0gQmxvY2tNaXgoVltpLTFdKTtcclxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBCbG9ja01peChWLCAoTiAtIDEpICogYmxvY2tTaXplMzIsIEIzMiwgUGksIHIpOyAvLyBQcm9jZXNzIGxhc3QgZWxlbWVudFxyXG4gICAgICAgIGJsb2NrTWl4Q2IoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCB1MzIgb2YgdGhlIGxhc3QgNjQtYnl0ZSBibG9jayAodTMyIGlzIExFKVxyXG4gICAgICAgICAgICBjb25zdCBqID0gQjMyW1BpICsgYmxvY2tTaXplMzIgLSAxNl0gJSBOOyAvLyBqID0gSW50ZWdyaWZ5KFgpICUgaXRlcmF0aW9uc1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGJsb2NrU2l6ZTMyOyBrKyspXHJcbiAgICAgICAgICAgICAgICB0bXBba10gPSBCMzJbUGkgKyBrXSBeIFZbaiAqIGJsb2NrU2l6ZTMyICsga107IC8vIHRtcCA9IEIgXiBWW2pdXHJcbiAgICAgICAgICAgIEJsb2NrTWl4KHRtcCwgMCwgQjMyLCBQaSwgcik7IC8vIEIgPSBCbG9ja01peChCIF4gVltqXSlcclxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xyXG59XHJcbi8qKlxyXG4gKiBTY3J5cHQgS0RGIGZyb20gUkZDIDc5MTQuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2NyeXB0QXN5bmMocGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcclxuICAgIGNvbnN0IHsgTiwgciwgcCwgZGtMZW4sIGJsb2NrU2l6ZTMyLCBWLCBCMzIsIEIsIHRtcCwgYmxvY2tNaXhDYiwgYXN5bmNUaWNrIH0gPSBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcclxuICAgIGZvciAobGV0IHBpID0gMDsgcGkgPCBwOyBwaSsrKSB7XHJcbiAgICAgICAgY29uc3QgUGkgPSBibG9ja1NpemUzMiAqIHBpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplMzI7IGkrKylcclxuICAgICAgICAgICAgVltpXSA9IEIzMltQaSArIGldOyAvLyBWWzBdID0gQltpXVxyXG4gICAgICAgIGxldCBwb3MgPSAwO1xyXG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChOIC0gMSwgYXN5bmNUaWNrLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIEJsb2NrTWl4KFYsIHBvcywgViwgKHBvcyArPSBibG9ja1NpemUzMiksIHIpOyAvLyBWW2ldID0gQmxvY2tNaXgoVltpLTFdKTtcclxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIEJsb2NrTWl4KFYsIChOIC0gMSkgKiBibG9ja1NpemUzMiwgQjMyLCBQaSwgcik7IC8vIFByb2Nlc3MgbGFzdCBlbGVtZW50XHJcbiAgICAgICAgYmxvY2tNaXhDYigpO1xyXG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChOLCBhc3luY1RpY2ssICgpID0+IHtcclxuICAgICAgICAgICAgLy8gRmlyc3QgdTMyIG9mIHRoZSBsYXN0IDY0LWJ5dGUgYmxvY2sgKHUzMiBpcyBMRSlcclxuICAgICAgICAgICAgY29uc3QgaiA9IEIzMltQaSArIGJsb2NrU2l6ZTMyIC0gMTZdICUgTjsgLy8gaiA9IEludGVncmlmeShYKSAlIGl0ZXJhdGlvbnNcclxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBibG9ja1NpemUzMjsgaysrKVxyXG4gICAgICAgICAgICAgICAgdG1wW2tdID0gQjMyW1BpICsga10gXiBWW2ogKiBibG9ja1NpemUzMiArIGtdOyAvLyB0bXAgPSBCIF4gVltqXVxyXG4gICAgICAgICAgICBCbG9ja01peCh0bXAsIDAsIEIzMiwgUGksIHIpOyAvLyBCID0gQmxvY2tNaXgoQiBeIFZbal0pXHJcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcnlwdC5qcy5tYXAiLCJpbXBvcnQgeyBzY3J5cHQgYXMgX25vYmxlU3luYywgc2NyeXB0QXN5bmMgYXMgX25vYmxlQXN5bmMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zY3J5cHRcIjtcclxuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgYXMgSCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5sZXQgbG9ja2VkU3luYyA9IGZhbHNlLCBsb2NrZWRBc3luYyA9IGZhbHNlO1xyXG5jb25zdCBfc2NyeXB0QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAocGFzc3dkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgb25Qcm9ncmVzcykge1xyXG4gICAgcmV0dXJuIGF3YWl0IF9ub2JsZUFzeW5jKHBhc3N3ZCwgc2FsdCwgeyBOLCByLCBwLCBka0xlbiwgb25Qcm9ncmVzcyB9KTtcclxufTtcclxuY29uc3QgX3NjcnlwdFN5bmMgPSBmdW5jdGlvbiAocGFzc3dkLCBzYWx0LCBOLCByLCBwLCBka0xlbikge1xyXG4gICAgcmV0dXJuIF9ub2JsZVN5bmMocGFzc3dkLCBzYWx0LCB7IE4sIHIsIHAsIGRrTGVuIH0pO1xyXG59O1xyXG5sZXQgX19zY3J5cHRBc3luYyA9IF9zY3J5cHRBc3luYztcclxubGV0IF9fc2NyeXB0U3luYyA9IF9zY3J5cHRTeW5jO1xyXG4vKipcclxuICogIFRoZSBbW2xpbmstd2lraS1zY3J5cHRdXSB1c2VzIGEgbWVtb3J5IGFuZCBjcHUgaGFyZCBtZXRob2Qgb2ZcclxuICogIGRlcml2YXRpb24gdG8gaW5jcmVhc2UgdGhlIHJlc291cmNlIGNvc3QgdG8gYnJ1dGUtZm9yY2UgYSBwYXNzd29yZFxyXG4gKiAgZm9yIGEgZ2l2ZW4ga2V5LlxyXG4gKlxyXG4gKiAgVGhpcyBtZWFucyB0aGlzIGFsZ29yaXRobSBpcyBpbnRlbnRpb25hbGx5IHNsb3csIGFuZCBjYW4gYmUgdHVuZWQgdG9cclxuICogIGJlY29tZSBzbG93ZXIuIEFzIGNvbXB1dGF0aW9uIGFuZCBtZW1vcnkgc3BlZWQgaW1wcm92ZSBvdmVyIHRpbWUsXHJcbiAqICBpbmNyZWFzaW5nIHRoZSBkaWZmaWN1bHR5IG1haW50YWlucyB0aGUgY29zdCBvZiBhbiBhdHRhY2tlci5cclxuICpcclxuICogIEZvciBleGFtcGxlLCBpZiBhIHRhcmdldCB0aW1lIG9mIDUgc2Vjb25kcyBpcyB1c2VkLCBhIGxlZ2l0aW1hdGUgdXNlclxyXG4gKiAgd2hpY2gga25vd3MgdGhlaXIgcGFzc3dvcmQgcmVxdWlyZXMgb25seSA1IHNlY29uZHMgdG8gdW5sb2NrIHRoZWlyXHJcbiAqICBhY2NvdW50LiBBIDYgY2hhcmFjdGVyIHBhc3N3b3JkIGhhcyA2OCBiaWxsaW9uIHBvc3NpYmlsaXRpZXMsIHdoaWNoXHJcbiAqICB3b3VsZCByZXF1aXJlIGFuIGF0dGFja2VyIHRvIGludmVzdCBvdmVyIDEwLDAwMCB5ZWFycyBvZiBDUFUgdGltZS4gVGhpc1xyXG4gKiAgaXMgb2YgY291cnNlIGEgY3J1ZGUgZXhhbXBsZSAoYXMgcGFzc3dvcmQgZ2VuZXJhbGx5IGFyZW4ndCByYW5kb20pLFxyXG4gKiAgYnV0IGRlbW9uc3RyYXRlcyB0byB2YWx1ZSBvZiBpbXBvc2luZyBsYXJnZSBjb3N0cyB0byBkZWNyeXB0aW9uLlxyXG4gKlxyXG4gKiAgRm9yIHRoaXMgcmVhc29uLCBpZiBidWlsZGluZyBhIFVJIHdoaWNoIGludm9sdmVkIGRlY3J5cHRpbmcgb3JcclxuICogIGVuY3J5cHRpbmcgZGF0c2EgdXNpbmcgc2NyeXB0LCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYVxyXG4gKiAgW1tQcm9ncmVzc0NhbGxiYWNrXV0gKGFzIGV2ZW50IHNob3J0IHBlcmlvZHMgY2FuIHNlZW0gbGlrIGFuIGV0ZXJuaXR5XHJcbiAqICBpZiB0aGUgVUkgZnJlZXplcykuIEluY2x1ZGluZyB0aGUgcGhyYXNlIC8vXCJkZWNyeXB0aW5nXCIvLyBpbiB0aGUgVUlcclxuICogIGNhbiBhbHNvIGhlbHAsIGFzc3VyaW5nIHRoZSB1c2VyIHRoZWlyIHdhaXRpbmcgaXMgZm9yIGEgZ29vZCByZWFzb24uXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpQYXNzd29yZHNcclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICAvLyBUaGUgcGFzc3dvcmQgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMsIGFuZCBpdCBpcyBnZW5lcmFsbHlcclxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxyXG4gKiAgICAvLyBmb3JtYXRzIGV4cGxpY2l0bHkgaW5kaWNhdGUgdGhlIG5vcm1hbGl6YXRpb24gZm9ybSB0byB1c2UuXHJcbiAqICAgIHBhc3N3b3JkID0gXCJoZWxsb1wiXHJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXHJcbiAqXHJcbiAqICAgIHNhbHQgPSBpZChcInNvbWUtc2FsdFwiKVxyXG4gKlxyXG4gKiAgICAvLyBDb21wdXRlIHRoZSBzY3J5cHRcclxuICogICAgc2NyeXB0KHBhc3N3b3JkQnl0ZXMsIHNhbHQsIDEwMjQsIDgsIDEsIDE2KVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2NyeXB0KF9wYXNzd2QsIF9zYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3MpIHtcclxuICAgIGNvbnN0IHBhc3N3ZCA9IGdldEJ5dGVzKF9wYXNzd2QsIFwicGFzc3dkXCIpO1xyXG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XHJcbiAgICByZXR1cm4gSChhd2FpdCBfX3NjcnlwdEFzeW5jKHBhc3N3ZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIHByb2dyZXNzKSk7XHJcbn1cclxuc2NyeXB0Ll8gPSBfc2NyeXB0QXN5bmM7XHJcbnNjcnlwdC5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWRBc3luYyA9IHRydWU7IH07XHJcbnNjcnlwdC5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICBpZiAobG9ja2VkQXN5bmMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY3J5cHQgaXMgbG9ja2VkXCIpO1xyXG4gICAgfVxyXG4gICAgX19zY3J5cHRBc3luYyA9IGZ1bmM7XHJcbn07XHJcbk9iamVjdC5mcmVlemUoc2NyeXB0KTtcclxuLyoqXHJcbiAqICBQcm92aWRlcyBhIHN5bmNocm9ub3VzIHZhcmlhbnQgb2YgW1tzY3J5cHRdXS5cclxuICpcclxuICogIFRoaXMgd2lsbCBjb21wbGV0ZWx5IGxvY2sgdXAgYW5kIGZyZWV6ZSB0aGUgVUkgaW4gYSBicm93c2VyIGFuZCB3aWxsXHJcbiAqICBwcmV2ZW50IGFueSBldmVudCBsb29wIGZyb20gcHJvZ3Jlc3NpbmcuIEZvciB0aGlzIHJlYXNvbiwgaXQgaXNcclxuICogIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2YXJpYW50XShzY3J5cHQpLlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86UGFzc3dvcmRzXHJcbiAqXHJcbiAqICBAZXhhbXBsZTpcclxuICogICAgLy8gVGhlIHBhc3N3b3JkIG11c3QgYmUgY29udmVydGVkIHRvIGJ5dGVzLCBhbmQgaXQgaXMgZ2VuZXJhbGx5XHJcbiAqICAgIC8vIGJlc3QgcHJhY3RpY2VzIHRvIGVuc3VyZSB0aGUgc3RyaW5nIGhhcyBiZWVuIG5vcm1hbGl6ZWQuIE1hbnlcclxuICogICAgLy8gZm9ybWF0cyBleHBsaWNpdGx5IGluZGljYXRlIHRoZSBub3JtYWxpemF0aW9uIGZvcm0gdG8gdXNlLlxyXG4gKiAgICBwYXNzd29yZCA9IFwiaGVsbG9cIlxyXG4gKiAgICBwYXNzd29yZEJ5dGVzID0gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFwiTkZLQ1wiKVxyXG4gKlxyXG4gKiAgICBzYWx0ID0gaWQoXCJzb21lLXNhbHRcIilcclxuICpcclxuICogICAgLy8gQ29tcHV0ZSB0aGUgc2NyeXB0XHJcbiAqICAgIHNjcnlwdFN5bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgOCwgMSwgMTYpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzY3J5cHRTeW5jKF9wYXNzd2QsIF9zYWx0LCBOLCByLCBwLCBka0xlbikge1xyXG4gICAgY29uc3QgcGFzc3dkID0gZ2V0Qnl0ZXMoX3Bhc3N3ZCwgXCJwYXNzd2RcIik7XHJcbiAgICBjb25zdCBzYWx0ID0gZ2V0Qnl0ZXMoX3NhbHQsIFwic2FsdFwiKTtcclxuICAgIHJldHVybiBIKF9fc2NyeXB0U3luYyhwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKSk7XHJcbn1cclxuc2NyeXB0U3luYy5fID0gX3NjcnlwdFN5bmM7XHJcbnNjcnlwdFN5bmMubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkU3luYyA9IHRydWU7IH07XHJcbnNjcnlwdFN5bmMucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgaWYgKGxvY2tlZFN5bmMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY3J5cHRTeW5jIGlzIGxvY2tlZFwiKTtcclxuICAgIH1cclxuICAgIF9fc2NyeXB0U3luYyA9IGZ1bmM7XHJcbn07XHJcbk9iamVjdC5mcmVlemUoc2NyeXB0U3luYyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcnlwdC5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XHJcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmNvbnN0IF9zaGEyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xyXG59O1xyXG5jb25zdCBfc2hhNTEyID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHJldHVybiBjcmVhdGVIYXNoKFwic2hhNTEyXCIpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcclxufTtcclxubGV0IF9fc2hhMjU2ID0gX3NoYTI1NjtcclxubGV0IF9fc2hhNTEyID0gX3NoYTUxMjtcclxubGV0IGxvY2tlZDI1NiA9IGZhbHNlLCBsb2NrZWQ1MTIgPSBmYWxzZTtcclxuLyoqXHJcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFNIQTItMjU2IGhhc2ggb2YgJSVkYXRhJSUuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xyXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIHNoYTI1NihcIjB4XCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgc2hhMjU2KFwiMHgxMzM3XCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgc2hhMjU2KG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNoYTI1NihfZGF0YSkge1xyXG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XHJcbiAgICByZXR1cm4gaGV4bGlmeShfX3NoYTI1NihkYXRhKSk7XHJcbn1cclxuc2hhMjU2Ll8gPSBfc2hhMjU2O1xyXG5zaGEyNTYubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkMjU2ID0gdHJ1ZTsgfTtcclxuc2hhMjU2LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgIGlmIChsb2NrZWQyNTYpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGEyNTYgaXMgbG9ja2VkXCIpO1xyXG4gICAgfVxyXG4gICAgX19zaGEyNTYgPSBmdW5jO1xyXG59O1xyXG5PYmplY3QuZnJlZXplKHNoYTI1Nik7XHJcbi8qKlxyXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBTSEEyLTUxMiBoYXNoIG9mICUlZGF0YSUlLlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnNcclxuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICBzaGE1MTIoXCIweFwiKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIHNoYTUxMihcIjB4MTMzN1wiKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIHNoYTUxMihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaGE1MTIoX2RhdGEpIHtcclxuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xyXG4gICAgcmV0dXJuIGhleGxpZnkoX19zaGE1MTIoZGF0YSkpO1xyXG59XHJcbnNoYTUxMi5fID0gX3NoYTUxMjtcclxuc2hhNTEyLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZDUxMiA9IHRydWU7IH07XHJcbnNoYTUxMi5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICBpZiAobG9ja2VkNTEyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hhNTEyIGlzIGxvY2tlZFwiKTtcclxuICAgIH1cclxuICAgIF9fc2hhNTEyID0gZnVuYztcclxufTtcclxuT2JqZWN0LmZyZWV6ZShzaGEyNTYpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCIsIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cclxuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cclxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cclxuLy8gVXNlciBtYXkgb3B0LWluIGludG8gdXNpbmcgZGlmZmVyZW50IGhhc2hpbmcgbGlicmFyeS4gVGhpcyB3YXksIG5vYmxlLWhhc2hlc1xyXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cclxuY29uc3QgXzBuID0gQmlnSW50KDApO1xyXG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XHJcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcclxuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xyXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xyXG4vKipcclxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcclxuICAgIGlmICghdThhKGJ5dGVzKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcclxuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxyXG4gICAgbGV0IGhleCA9ICcnO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGV4O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xyXG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcclxuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XHJcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xyXG4gICAgLy8gQmlnIEVuZGlhblxyXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XHJcbn1cclxuLyoqXHJcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xyXG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcclxuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XHJcbiAgICBpZiAobGVuICUgMilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcclxuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xyXG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xyXG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xyXG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XHJcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59XHJcbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxyXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XHJcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcclxuICAgIGlmICghdThhKGJ5dGVzKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcclxuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcclxuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XHJcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xyXG59XHJcbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxyXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcclxuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXHJcbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxyXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cclxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcclxuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcclxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcclxuICAgIGxldCByZXM7XHJcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xyXG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XHJcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xyXG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8qKlxyXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcclxuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XHJcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxyXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcclxuICAgICAgICBpZiAoIXU4YShhKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XHJcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcclxuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xyXG4gICAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCB0aW1pbmcgYXR0YWNrcyBoZXJlXHJcbiAgICBpZiAoYjEubGVuZ3RoICE9PSBiMi5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKylcclxuICAgICAgICBpZiAoYjFbaV0gIT09IGIyW2ldKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcclxuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcclxufVxyXG4vLyBCaXQgb3BlcmF0aW9uc1xyXG4vKipcclxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cclxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcclxuICAgIGxldCBsZW47XHJcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXHJcbiAgICAgICAgO1xyXG4gICAgcmV0dXJuIGxlbjtcclxufVxyXG4vKipcclxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxyXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXHJcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xyXG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcclxufVxyXG4vKipcclxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XHJcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcclxufTtcclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cclxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcclxuICovXHJcbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XHJcbi8vIERSQkdcclxuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcclxuY29uc3QgdThmciA9IChhcnIpID0+IFVpbnQ4QXJyYXkuZnJvbShhcnIpOyAvLyBhbm90aGVyIHNob3J0Y3V0XHJcbi8qKlxyXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXHJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcclxuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XHJcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XHJcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XHJcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcclxuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxyXG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxyXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxyXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcclxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xyXG4gICAgICAgIHYuZmlsbCgxKTtcclxuICAgICAgICBrLmZpbGwoMCk7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxyXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oKSkgPT4ge1xyXG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXHJcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcclxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXHJcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcclxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xyXG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXHJcbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XHJcbiAgICAgICAgbGV0IGxlbiA9IDA7XHJcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XHJcbiAgICAgICAgICAgIHYgPSBoKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xyXG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XHJcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xyXG4gICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcclxuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cclxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXHJcbiAgICAgICAgICAgIHJlc2VlZCgpO1xyXG4gICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gZ2VuVW50aWw7XHJcbn1cclxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xyXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XHJcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxyXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXHJcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXHJcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxyXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxyXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcclxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXHJcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxyXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcclxufTtcclxuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xyXG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcclxuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcclxuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xyXG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xyXG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcclxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xyXG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcclxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gb2JqZWN0O1xyXG59XHJcbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcclxuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcclxuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcclxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xyXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xyXG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcclxuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XHJcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXHJcbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xyXG5pbXBvcnQgeyBiaXRNYXNrLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tICcuL3V0aWxzLmpzJztcclxuLy8gcHJldHRpZXItaWdub3JlXHJcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcclxuLy8gcHJldHRpZXItaWdub3JlXHJcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xyXG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcclxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcclxuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxyXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXHJcbiAqIEBleGFtcGxlXHJcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXHJcbiAqL1xyXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcclxuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcclxuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xyXG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxyXG4gICAgICAgIHJldHVybiBfMG47XHJcbiAgICBsZXQgcmVzID0gXzFuO1xyXG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XHJcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxyXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcclxuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcclxuICAgICAgICBwb3dlciA+Pj0gXzFuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXHJcbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcclxuICAgIGxldCByZXMgPSB4O1xyXG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcclxuICAgICAgICByZXMgKj0gcmVzO1xyXG4gICAgICAgIHJlcyAlPSBtb2R1bG87XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xyXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XHJcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcclxuICAgIH1cclxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cclxuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxyXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xyXG4gICAgbGV0IGIgPSBtb2R1bG87XHJcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xyXG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xyXG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XHJcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xyXG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XHJcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcclxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZ2NkID0gYjtcclxuICAgIGlmIChnY2QgIT09IF8xbilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcclxuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcclxufVxyXG4vKipcclxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cclxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxyXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcclxuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxyXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XHJcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXHJcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxyXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcclxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxyXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcclxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcclxuICAgIGxldCBRLCBTLCBaO1xyXG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXHJcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXHJcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxyXG4gICAgICAgIDtcclxuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXHJcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspXHJcbiAgICAgICAgO1xyXG4gICAgLy8gRmFzdC1wYXRoXHJcbiAgICBpZiAoUyA9PT0gMSkge1xyXG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcclxuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xyXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gU2xvdy1wYXRoXHJcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcclxuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcclxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XHJcbiAgICAgICAgbGV0IHIgPSBTO1xyXG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXHJcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcclxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcclxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxyXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcclxuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcclxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxyXG4gICAgICAgICAgICBsZXQgbSA9IDE7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XHJcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXHJcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxyXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxyXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcclxuICAgICAgICAgICAgciA9IG07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcclxuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cclxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxyXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXHJcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcclxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcclxuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxyXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cclxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcclxuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XHJcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcclxuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xyXG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cclxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXHJcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XHJcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xyXG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xyXG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xyXG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcclxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcclxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XHJcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxyXG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXHJcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcclxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXHJcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xyXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xyXG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XHJcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXHJcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXHJcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXHJcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcclxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxyXG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XHJcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcclxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxyXG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxyXG4gICAgICAgIC8vIH1cclxuICAgIH1cclxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cclxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xyXG59XHJcbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xyXG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcclxuLy8gcHJldHRpZXItaWdub3JlXHJcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcclxuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXHJcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxyXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXHJcbl07XHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XHJcbiAgICBjb25zdCBpbml0aWFsID0ge1xyXG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcclxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcclxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxyXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcclxuICAgIH07XHJcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcclxuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XHJcbiAgICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH0sIGluaXRpYWwpO1xyXG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcclxufVxyXG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xyXG4vKipcclxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cclxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcclxuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXHJcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXHJcbiAgICBpZiAocG93ZXIgPCBfMG4pXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcclxuICAgIGlmIChwb3dlciA9PT0gXzBuKVxyXG4gICAgICAgIHJldHVybiBmLk9ORTtcclxuICAgIGlmIChwb3dlciA9PT0gXzFuKVxyXG4gICAgICAgIHJldHVybiBudW07XHJcbiAgICBsZXQgcCA9IGYuT05FO1xyXG4gICAgbGV0IGQgPSBudW07XHJcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcclxuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXHJcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcclxuICAgICAgICBkID0gZi5zcXIoZCk7XHJcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcclxuICAgIH1cclxuICAgIHJldHVybiBwO1xyXG59XHJcbi8qKlxyXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXHJcbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcclxuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XHJcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXHJcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xyXG4gICAgICAgIGlmIChmLmlzMChudW0pKVxyXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgIHRtcFtpXSA9IGFjYztcclxuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xyXG4gICAgfSwgZi5PTkUpO1xyXG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxyXG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XHJcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXHJcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xyXG4gICAgICAgIGlmIChmLmlzMChudW0pKVxyXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcclxuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xyXG4gICAgfSwgaW52ZXJ0ZWQpO1xyXG4gICAgcmV0dXJuIHRtcDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcclxuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcclxufVxyXG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cclxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xyXG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXHJcbiAgICByZXR1cm4gKHgpID0+IHtcclxuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XHJcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xyXG4gICAgfTtcclxufVxyXG4vLyBDVVJWRS5uIGxlbmd0aHNcclxuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xyXG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXHJcbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcclxuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XHJcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcclxufVxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXHJcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cclxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcclxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcclxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXHJcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxyXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XHJcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcclxuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cclxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcclxuICAgIGlmIChPUkRFUiA8PSBfMG4pXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xyXG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XHJcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcclxuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICBPUkRFUixcclxuICAgICAgICBCSVRTLFxyXG4gICAgICAgIEJZVEVTLFxyXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXHJcbiAgICAgICAgWkVSTzogXzBuLFxyXG4gICAgICAgIE9ORTogXzFuLFxyXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxyXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXHJcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXHJcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxyXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcclxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcclxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxyXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXHJcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcclxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcclxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxyXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxyXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcclxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcclxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcclxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcclxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcclxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8ICgobikgPT4gc3FydFAoZiwgbikpLFxyXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXHJcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cclxuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXHJcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxyXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcclxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xyXG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xyXG4gICAgaWYgKCFGcC5pc09kZClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xyXG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcclxuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xyXG4gICAgaWYgKCFGcC5pc09kZClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xyXG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcclxuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XHJcbn1cclxuLyoqXHJcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cclxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cclxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxyXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFwS2V5VG9GaWVsZCBpbnN0ZWFkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcclxuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcclxuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcclxuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xyXG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7aGFzaExlbn1gKTtcclxuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XHJcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxyXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXHJcbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXHJcbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XHJcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcclxuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxyXG4gKiBieSBmaWVsZCBvcmRlci5cclxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXHJcbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXHJcbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XHJcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xyXG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcclxufVxyXG4vKipcclxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxyXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXHJcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cclxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXHJcbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xyXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxyXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XHJcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cclxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxyXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cclxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcclxuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcclxuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XHJcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXHJcbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xyXG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJCRShrZXkpIDogYnl0ZXNUb051bWJlckxFKGtleSk7XHJcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXHJcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XHJcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xyXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xyXG5pbXBvcnQgeyB2YWxpZGF0ZUZpZWxkLCBuTGVuZ3RoIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcclxuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcclxuY29uc3QgXzBuID0gQmlnSW50KDApO1xyXG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XHJcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cclxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXHJcbi8vIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxyXG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcclxuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxyXG4vLyAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXHJcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxyXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXHJcbi8vIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXHJcbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xyXG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXHJcbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcclxuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcclxuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xyXG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcclxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xyXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcclxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XHJcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xyXG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcclxuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcclxuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxyXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxyXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcclxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcclxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXHJcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxyXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cclxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgbGV0IHAgPSBlbG07XHJcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcclxuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcclxuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cclxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxyXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcclxuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxyXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcclxuICAgICAgICAgKi9cclxuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxyXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXHJcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcclxuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XHJcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xyXG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxyXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xyXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXHJcbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xyXG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cclxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxyXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcclxuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcclxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cclxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxyXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXHJcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXHJcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxyXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cclxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcclxuICAgICAgICAgICAgaWYgKCFjb21wKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XHJcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcclxuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XHJcbiAgICAgICAgbjogJ2JpZ2ludCcsXHJcbiAgICAgICAgaDogJ2JpZ2ludCcsXHJcbiAgICAgICAgR3g6ICdmaWVsZCcsXHJcbiAgICAgICAgR3k6ICdmaWVsZCcsXHJcbiAgICB9LCB7XHJcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxyXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXHJcbiAgICB9KTtcclxuICAgIC8vIFNldCBkZWZhdWx0c1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXHJcbiAgICAgICAgLi4uY3VydmUsXHJcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xyXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxyXG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcclxuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XHJcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XHJcbmltcG9ydCB7IHdOQUYsIHZhbGlkYXRlQmFzaWMgfSBmcm9tICcuL2N1cnZlLmpzJztcclxuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcclxuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcclxuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcclxuICAgICAgICBhOiAnZmllbGQnLFxyXG4gICAgICAgIGI6ICdmaWVsZCcsXHJcbiAgICB9LCB7XHJcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxyXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXHJcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcclxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxyXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxyXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcclxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xyXG4gICAgaWYgKGVuZG8pIHtcclxuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcclxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcclxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcclxufVxyXG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXHJcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XHJcbmV4cG9ydCBjb25zdCBERVIgPSB7XHJcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcclxuICAgIEVycjogY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xyXG4gICAgICAgICAgICBzdXBlcihtKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcclxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YVsxXTtcclxuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xyXG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aCcpO1xyXG4gICAgICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxyXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XHJcbiAgICAgICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xyXG4gICAgICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcclxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XHJcbiAgICAgICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiAhKHJlc1sxXSAmIDBiMTAwMDAwMDApKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XHJcbiAgICAgICAgcmV0dXJuIHsgZDogYjJuKHJlcyksIGw6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTsgLy8gZCBpcyBkYXRhLCBsIGlzIGxlZnRcclxuICAgIH0sXHJcbiAgICB0b1NpZyhoZXgpIHtcclxuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXHJcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcclxuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcclxuICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndWk4YSBleHBlY3RlZCcpO1xyXG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIHRhZycpO1xyXG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XHJcbiAgICAgICAgY29uc3QgeyBkOiByLCBsOiBzQnl0ZXMgfSA9IERFUi5fcGFyc2VJbnQoZGF0YS5zdWJhcnJheSgyKSk7XHJcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XHJcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xyXG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcclxuICAgIH0sXHJcbiAgICBoZXhGcm9tU2lnKHNpZykge1xyXG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xyXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcclxuICAgICAgICBjb25zdCBoID0gKG51bSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xyXG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xyXG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XHJcbiAgICAgICAgY29uc3Qgc2hsID0gcy5sZW5ndGggLyAyO1xyXG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcclxuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcclxuICAgICAgICBjb25zdCBybCA9IGgocmhsKTtcclxuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xyXG4gICAgfSxcclxufTtcclxuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcclxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcclxuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XHJcbiAgICBjb25zdCB7IEZwIH0gPSBDVVJWRTsgLy8gQWxsIGN1cnZlcyBoYXMgc2FtZSBmaWVsZCAvIGdyb3VwIGxlbmd0aCBhcyBmb3Igbm93LCBidXQgdGhleSBjYW4gZGlmZmVyXHJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxyXG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcclxuICAgICAgICB9KTtcclxuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxyXG4gICAgICAgICgoYnl0ZXMpID0+IHtcclxuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xyXG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XHJcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xyXG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxyXG4gICAgICogQHJldHVybnMgecKyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xyXG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XHJcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XHJcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcclxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXHJcbiAgICB9XHJcbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cclxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXHJcbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cclxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxyXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xyXG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxyXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xyXG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xyXG4gICAgfVxyXG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXHJcbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXHJcbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xyXG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG4gfSA9IENVUlZFO1xyXG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxyXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcclxuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG51bTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBudW0gPVxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcclxuICAgICAgICAgICAgICAgICAgICA/IGtleVxyXG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJpdmF0ZSBrZXkgbXVzdCBiZSAke25CeXRlTGVuZ3RofSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIGtleX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxyXG4gICAgICAgICAgICBudW0gPSBtb2QubW9kKG51bSwgbik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xyXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxyXG4gICAgICAgIHJldHVybiBudW07XHJcbiAgICB9XHJcbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcclxuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxyXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXHJcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIGNsYXNzIFBvaW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcclxuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xyXG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XHJcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xyXG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cclxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXHJcbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XHJcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcclxuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xyXG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xyXG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXHJcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IHgoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IHkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcclxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxyXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxyXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xyXG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXHJcbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xyXG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xyXG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBQO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxyXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxyXG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xyXG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cclxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXHJcbiAgICAgICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxyXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxyXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcclxuICAgICAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXHJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RvcnNpb25GcmVlKCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhc0V2ZW5ZKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcclxuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcclxuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcclxuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIFUxICYmIFUyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBuZWdhdGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5weCwgRnAubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXHJcbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcclxuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxyXG4gICAgICAgIGRvdWJsZSgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcclxuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcclxuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcclxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XHJcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xyXG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcclxuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XHJcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XHJcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XHJcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcclxuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcclxuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxyXG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xyXG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xyXG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xyXG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xyXG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XHJcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcclxuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcclxuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xyXG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xyXG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXHJcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XHJcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XHJcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XHJcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XHJcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcclxuICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcclxuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcclxuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcclxuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcclxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxyXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cclxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxyXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxyXG4gICAgICAgIGFkZChvdGhlcikge1xyXG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcclxuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcclxuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcclxuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxyXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcclxuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XHJcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xyXG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XHJcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XHJcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XHJcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XHJcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XHJcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXHJcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XHJcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XHJcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XHJcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XHJcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcclxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcclxuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcclxuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcclxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xyXG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXHJcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XHJcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XHJcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XHJcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XHJcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcclxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcclxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xyXG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xyXG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xyXG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXHJcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcclxuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcclxuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcclxuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcclxuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxyXG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xyXG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xyXG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xyXG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xyXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlzMCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3TkFGKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChjb21wLm1hcCgocCkgPT4gcC5weikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxyXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XHJcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBtdWx0aXBseVVuc2FmZShuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xyXG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XHJcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcclxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xyXG4gICAgICAgICAgICBpZiAoIWVuZG8pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgbik7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxyXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcclxuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XHJcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xyXG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxyXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXHJcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcclxuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcclxuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGsxbmVnKVxyXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICBpZiAoazJuZWcpXHJcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XHJcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXHJcbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxyXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cclxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxyXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cclxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXHJcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XHJcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XHJcbiAgICAgICAgICAgIGxldCBuID0gc2NhbGFyO1xyXG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcclxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcclxuICAgICAgICAgICAgaWYgKGVuZG8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcclxuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIpO1xyXG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XHJcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcclxuICAgICAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcclxuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcclxuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cclxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxyXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cclxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcclxuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxyXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcclxuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXHJcbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxyXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgaXMwID0gdGhpcy5pczAoKTtcclxuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXHJcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXHJcbiAgICAgICAgICAgIGlmIChpeiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XHJcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcclxuICAgICAgICAgICAgY29uc3QgYXkgPSBGcC5tdWwoeSwgaXopO1xyXG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XHJcbiAgICAgICAgICAgIGlmIChpczApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XHJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcclxuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXHJcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcclxuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXHJcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xyXG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xyXG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xyXG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcclxuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBDVVJWRSxcclxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxyXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXHJcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcclxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xyXG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xyXG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xyXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcclxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxyXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxyXG4gICAgfSwge1xyXG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxyXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXHJcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XHJcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XHJcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XHJcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcclxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XHJcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW52TihhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XHJcbiAgICAgICAgLi4uQ1VSVkUsXHJcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xyXG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcclxuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcclxuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XHJcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcclxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcclxuICAgICAgICAgICAgICAgIC8vIEVDRFNBXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2ludCBvZiBsZW5ndGggJHtsZW59IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2NvbXByZXNzZWRMZW59IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHt1bmNvbXByZXNzZWRMZW59IHVuY29tcHJlc3NlZCBieXRlc2ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcclxuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcclxuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcclxuICAgIH1cclxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxyXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxyXG4gICAgICovXHJcbiAgICBjbGFzcyBTaWduYXR1cmUge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcclxuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxyXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcclxuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxyXG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhlbnN1cmVCeXRlcygnREVSJywgaGV4KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcclxuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXHJcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3IgbXVzdCBiZSAwIDwgciA8IENVUlZFLm4nKTtcclxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcclxuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxyXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xyXG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcclxuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XHJcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xyXG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcclxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcclxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXHJcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxyXG4gICAgICAgICAgICBpZiAoIVEpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXHJcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIFE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cclxuICAgICAgICBoYXNIaWdoUygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub3JtYWxpemVTKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gREVSLWVuY29kZWRcclxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b0RFUkhleCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXHJcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1Ub05CeXRlU3RyKHRoaXMucikgKyBudW1Ub05CeXRlU3RyKHRoaXMucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgdXRpbHMgPSB7XHJcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXHJcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZC5tYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxyXG4gICAgICAgICAqIEFsbG93cyB0byBtYXNzaXZlbHkgc3BlZWQtdXAgYHBvaW50Lm11bHRpcGx5KHNjYWxhcilgLlxyXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogY29uc3QgZmFzdCA9IHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoc29tZW9uZXNQdWJLZXkpKTtcclxuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xyXG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcclxuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cclxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XHJcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxyXG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xyXG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcclxuICAgICAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGFycilcclxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcclxuICAgICAgICBpZiAoc3RyKVxyXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XHJcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXHJcbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxyXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxyXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxyXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XHJcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxyXG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcclxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XHJcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcclxuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXHJcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcclxuICAgIH1cclxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXHJcbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cclxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cclxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXHJcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxyXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cclxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxyXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBDVVJWRS5uQml0TGVuZ3RoOyAvLyB0cnVuY2F0ZSB0byBuQml0TGVuZ3RoIGxlZnRtb3N0IGJpdHNcclxuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xyXG4gICAgICAgIH07XHJcbiAgICBjb25zdCBiaXRzMmludF9tb2ROID0gQ1VSVkUuYml0czJpbnRfbW9kTiB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcclxuICAgICAgICB9O1xyXG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXHJcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcclxuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XHJcbiAgICAgICAgaWYgKCEoXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUl9NQVNLKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcclxuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXHJcbiAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcclxuICAgIH1cclxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcclxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxyXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXHJcbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxyXG4gICAgLy8gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XHJcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xyXG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XHJcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcclxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxyXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXHJcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XHJcbiAgICAgICAgaWYgKHByZWhhc2gpXHJcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcclxuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcclxuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cclxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXHJcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xyXG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcclxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XHJcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxyXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcclxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcclxuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXHJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcclxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxyXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xyXG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcclxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcclxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxyXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cclxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cclxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xyXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XHJcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxyXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXHJcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcclxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcclxuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XHJcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXHJcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xyXG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XHJcbiAgICAvKipcclxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXHJcbiAgICAgKiBgYGBcclxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcclxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXHJcbiAgICAgKiAgIHIgPSB4IG1vZCBuXHJcbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cclxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XHJcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXHJcbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xyXG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXHJcbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xyXG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xyXG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xyXG4gICAgfVxyXG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxyXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcclxuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXHJcbiAgICAvKipcclxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxyXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXHJcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxyXG4gICAgICpcclxuICAgICAqIGBgYFxyXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXHJcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cclxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxyXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXHJcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xyXG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xyXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xyXG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xyXG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcclxuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XHJcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IFA7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgc2cgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXHJcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xyXG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChwcmVoYXNoKVxyXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcclxuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XHJcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcclxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcclxuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxyXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXHJcbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxyXG4gICAgICAgIGlmICghUilcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XHJcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIENVUlZFLFxyXG4gICAgICAgIGdldFB1YmxpY0tleSxcclxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXHJcbiAgICAgICAgc2lnbixcclxuICAgICAgICB2ZXJpZnksXHJcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcclxuICAgICAgICBTaWduYXR1cmUsXHJcbiAgICAgICAgdXRpbHMsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cclxuICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxyXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxyXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXHJcbiAqIEBwYXJhbSBGcFxyXG4gKiBAcGFyYW0gWlxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XHJcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXHJcbiAgICBjb25zdCBxID0gRnAuT1JERVI7XHJcbiAgICBsZXQgbCA9IF8wbjtcclxuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxyXG4gICAgICAgIGwgKz0gXzFuO1xyXG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxyXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxyXG4gICAgLy8gMm4gKiogYzEgPT0gMm4gPDwgKGMxLTEpXHJcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcclxuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XHJcbiAgICBjb25zdCBjMiA9IChxIC0gXzFuKSAvIF8ybl9wb3dfYzE7IC8vIDIuIGMyID0gKHEgLSAxKSAvICgyXmMxKSAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcclxuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xyXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXHJcbiAgICBjb25zdCBjNSA9IF8ybl9wb3dfYzFfMTsgLy8gNS4gYzUgPSAyXihjMSAtIDEpICAgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcclxuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXHJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXHJcbiAgICBsZXQgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcclxuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XHJcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcclxuICAgICAgICBsZXQgdHYzID0gRnAuc3FyKHR2Mik7IC8vIDMuIHR2MyA9IHR2Ml4yXHJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcclxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcclxuICAgICAgICB0djUgPSBGcC5wb3codHY1LCBjMyk7IC8vIDYuIHR2NSA9IHR2NV5jM1xyXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XHJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2NSwgdSk7IC8vIDkuIHR2MyA9IHR2NSAqIHVcclxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxyXG4gICAgICAgIGxldCBpc1FSID0gRnAuZXFsKHR2NSwgRnAuT05FKTsgLy8gMTIuIGlzUVIgPSB0djUgPT0gMVxyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XHJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxyXG4gICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGlzUVIpOyAvLyAxNS4gdHYzID0gQ01PVih0djIsIHR2MywgaXNRUilcclxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXHJcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxyXG4gICAgICAgIGZvciAobGV0IGkgPSBjMTsgaSA+IF8xbjsgaS0tKSB7XHJcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcclxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcclxuICAgICAgICAgICAgbGV0IHR2djUgPSBGcC5wb3codHY0LCB0djUpOyAvLyAyMC4gICAgdHY1ID0gdHY0XnR2NVxyXG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxyXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXHJcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2MSk7IC8vIDIzLiAgICB0djEgPSB0djEgKiB0djFcclxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcclxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXHJcbiAgICAgICAgICAgIHR2NCA9IEZwLmNtb3YodHZ2NSwgdHY0LCBlMSk7IC8vIDI2LiAgICB0djQgPSBDTU9WKHR2NSwgdHY0LCBlMSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xyXG4gICAgfTtcclxuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XHJcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxyXG4gICAgICAgIGNvbnN0IGMxID0gKEZwLk9SREVSIC0gXzNuKSAvIF80bjsgLy8gMS4gYzEgPSAocSAtIDMpIC8gNCAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcclxuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxyXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0djEgPSBGcC5zcXIodik7IC8vIDEuIHR2MSA9IHZeMlxyXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XHJcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxyXG4gICAgICAgICAgICBsZXQgeTEgPSBGcC5wb3codHYxLCBjMSk7IC8vIDQuIHkxID0gdHYxXmMxXHJcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXHJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxyXG4gICAgICAgICAgICBjb25zdCB0djMgPSBGcC5tdWwoRnAuc3FyKHkxKSwgdik7IC8vIDcuIHR2MyA9IHkxXjI7IDguIHR2MyA9IHR2MyAqIHZcclxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcclxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXHJcbiAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB5IH07IC8vIDExLiByZXR1cm4gKGlzUVIsIHkpIGlzUVIgPyB5IDogeSpjMlxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBObyBjdXJ2ZXMgdXNlcyB0aGF0XHJcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxyXG4gICAgcmV0dXJuIHNxcnRSYXRpbztcclxufVxyXG4vKipcclxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcclxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi02LjYuMlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcclxuICAgIG1vZC52YWxpZGF0ZUZpZWxkKEZwKTtcclxuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xyXG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XHJcbiAgICBpZiAoIUZwLmlzT2RkKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xyXG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cclxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXHJcbiAgICByZXR1cm4gKHUpID0+IHtcclxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcclxuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcclxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxyXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcclxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXHJcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcclxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xyXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXHJcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcclxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXHJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxyXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XHJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcclxuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XHJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcclxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XHJcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcclxuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXHJcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXHJcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcclxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXHJcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcclxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxyXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXHJcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxyXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xyXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcclxuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XHJcbmltcG9ydCB7IHdlaWVyc3RyYXNzIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XHJcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcclxuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoYXNoLFxyXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXHJcbiAgICAgICAgcmFuZG9tQnl0ZXMsXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZiwgZGVmSGFzaCkge1xyXG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xyXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XHJcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XHJcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xyXG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XHJcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUgfSBmcm9tICcuL2Fic3RyYWN0L3V0aWxzLmpzJztcclxuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcclxuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tICcuL19zaG9ydHdfdXRpbHMuanMnO1xyXG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcclxuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XHJcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcclxuY29uc3QgXzJuID0gQmlnSW50KDIpO1xyXG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xyXG4vKipcclxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cclxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxyXG4gKi9cclxuZnVuY3Rpb24gc3FydE1vZCh5KSB7XHJcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcclxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcclxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcclxuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXHJcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcclxuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xyXG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XHJcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XHJcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XHJcbiAgICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XHJcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XHJcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xyXG4gICAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XHJcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XHJcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XHJcbiAgICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4sIFApICogYjIpICUgUDtcclxuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xyXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCB5KSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XHJcbiAgICByZXR1cm4gcm9vdDtcclxufVxyXG5jb25zdCBGcCA9IEZpZWxkKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XHJcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XHJcbiAgICBhOiBCaWdJbnQoMCksXHJcbiAgICBiOiBCaWdJbnQoNyksXHJcbiAgICBGcCxcclxuICAgIG46IHNlY3AyNTZrMU4sXHJcbiAgICAvLyBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50XHJcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxyXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcclxuICAgIGg6IEJpZ0ludCgxKSxcclxuICAgIGxvd1M6IHRydWUsXHJcbiAgICAvKipcclxuICAgICAqIHNlY3AyNTZrMSBiZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHkgY29tcHV0YWJsZSBlbmRvbW9ycGhpc20uXHJcbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cclxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cclxuICAgICAqIEV4cGxhbmF0aW9uOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsbWlsbHIvZWI2NzA4MDY3OTNlODRkZjYyOGE3YzQzNGE4NzMwNjZcclxuICAgICAqL1xyXG4gICAgZW5kbzoge1xyXG4gICAgICAgIGJldGE6IEJpZ0ludCgnMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyksXHJcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xyXG4gICAgICAgICAgICBjb25zdCBhMSA9IEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpO1xyXG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcclxuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGIyID0gYTE7XHJcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcclxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gZGl2TmVhcmVzdCgtYjEgKiBrLCBuKTtcclxuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XHJcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xyXG4gICAgICAgICAgICBjb25zdCBrMW5lZyA9IGsxID4gUE9XXzJfMTI4O1xyXG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xyXG4gICAgICAgICAgICBpZiAoazFuZWcpXHJcbiAgICAgICAgICAgICAgICBrMSA9IG4gLSBrMTtcclxuICAgICAgICAgICAgaWYgKGsybmVnKVxyXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XHJcbiAgICAgICAgICAgIGlmIChrMSA+IFBPV18yXzEyOCB8fCBrMiA+IFBPV18yXzEyOCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxufSwgc2hhMjU2KTtcclxuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcclxuY29uc3QgXzBuID0gQmlnSW50KDApO1xyXG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcclxuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMU47XHJcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cclxuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcclxuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XHJcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XHJcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XHJcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xyXG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xyXG59XHJcbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xyXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XHJcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XHJcbmNvbnN0IG1vZFAgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMVApO1xyXG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcclxuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xyXG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XHJcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xyXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcclxuICAgIGxldCBkXyA9IHNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxyXG4gICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcclxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xyXG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcclxufVxyXG4vKipcclxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxyXG4gKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxyXG4gKi9cclxuZnVuY3Rpb24gbGlmdF94KHgpIHtcclxuICAgIGlmICghZmUoeCkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxyXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcclxuICAgIGNvbnN0IGMgPSBtb2RQKHh4ICogeCArIEJpZ0ludCg3KSk7IC8vIExldCBjID0geMKzICsgNyBtb2QgcC5cclxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXHJcbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxyXG4gICAgICAgIHkgPSBtb2RQKC15KTsgLy8gUmV0dXJuIHRoZSB1bmlxdWUgcG9pbnQgUCBzdWNoIHRoYXQgeChQKSA9IHggYW5kXHJcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxyXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xyXG4gICAgcmV0dXJuIHA7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSB0YWdnZWQgaGFzaCwgY29udmVydCBpdCB0byBiaWdpbnQsIHJlZHVjZSBtb2R1bG8tbi5cclxuICovXHJcbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gbW9kTihieXRlc1RvTnVtYmVyQkUodGFnZ2VkSGFzaCgnQklQMDM0MC9jaGFsbGVuZ2UnLCAuLi5hcmdzKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBTY2hub3JyIHB1YmxpYyBrZXkgaXMganVzdCBgeGAgY29vcmRpbmF0ZSBvZiBQb2ludCBhcyBwZXIgQklQMzQwLlxyXG4gKi9cclxuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XHJcbiAgICByZXR1cm4gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KS5ieXRlczsgLy8gZCc9aW50KHNrKS4gRmFpbCBpZiBkJz0wIG9yIGQn4omlbi4gUmV0IGJ5dGVzKGQn4ouFRylcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBTY2hub3JyIHNpZ25hdHVyZSBhcyBwZXIgQklQMzQwLiBWZXJpZmllcyBpdHNlbGYgYmVmb3JlIHJldHVybmluZyBhbnl0aGluZy5cclxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2Nobm9yclNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgYXV4UmFuZCA9IHJhbmRvbUJ5dGVzKDMyKSkge1xyXG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XHJcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxyXG4gICAgY29uc3QgYSA9IGVuc3VyZUJ5dGVzKCdhdXhSYW5kJywgYXV4UmFuZCwgMzIpOyAvLyBBdXhpbGlhcnkgcmFuZG9tIGRhdGEgYTogYSAzMi1ieXRlIGFycmF5XHJcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxyXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXHJcbiAgICBjb25zdCBrXyA9IG1vZE4oYnl0ZXNUb051bWJlckJFKHJhbmQpKTsgLy8gTGV0IGsnID0gaW50KHJhbmQpIG1vZCBuXHJcbiAgICBpZiAoa18gPT09IF8wbilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXHJcbiAgICBjb25zdCB7IGJ5dGVzOiByeCwgc2NhbGFyOiBrIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KGtfKTsgLy8gTGV0IFIgPSBrJ+KLhUcuXHJcbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cclxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cclxuICAgIHNpZy5zZXQocngsIDApO1xyXG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XHJcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxyXG4gICAgaWYgKCFzY2hub3JyVmVyaWZ5KHNpZywgbSwgcHgpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcclxuICAgIHJldHVybiBzaWc7XHJcbn1cclxuLyoqXHJcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxyXG4gKiBXaWxsIHN3YWxsb3cgZXJyb3JzICYgcmV0dXJuIGZhbHNlIGV4Y2VwdCBmb3IgaW5pdGlhbCB0eXBlIHZhbGlkYXRpb24gb2YgYXJndW1lbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xyXG4gICAgY29uc3Qgc2lnID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xyXG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XHJcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcclxuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXHJcbiAgICAgICAgaWYgKCFmZShyKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxyXG4gICAgICAgIGlmICghZ2UocykpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cclxuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXHJcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjb25zdCBzY2hub3JyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoe1xyXG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxyXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXHJcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXHJcbiAgICB1dGlsczoge1xyXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxyXG4gICAgICAgIGxpZnRfeCxcclxuICAgICAgICBwb2ludFRvQnl0ZXMsXHJcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFLFxyXG4gICAgICAgIGJ5dGVzVG9OdW1iZXJCRSxcclxuICAgICAgICB0YWdnZWRIYXNoLFxyXG4gICAgICAgIG1vZCxcclxuICAgIH0sXHJcbn0pKSgpO1xyXG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlzb2dlbnlNYXAoRnAsIFtcclxuICAgIC8vIHhOdW1cclxuICAgIFtcclxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcclxuICAgICAgICAnMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODEnLFxyXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxyXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxyXG4gICAgXSxcclxuICAgIC8vIHhEZW5cclxuICAgIFtcclxuICAgICAgICAnMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliJyxcclxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcclxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXHJcbiAgICBdLFxyXG4gICAgLy8geU51bVxyXG4gICAgW1xyXG4gICAgICAgICcweDRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiOGUzOGUyM2MnLFxyXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxyXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxyXG4gICAgICAgICcweDJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmMzhlMzhkODQnLFxyXG4gICAgXSxcclxuICAgIC8vIHlEZW5cclxuICAgIFtcclxuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcclxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcclxuICAgICAgICAnMHg2NDg0YWE3MTY1NDVjYTJjZjNhNzBjM2ZhOGZlMzM3ZTBhM2QyMTE2MmYwZDYyOTlhN2JmODE5MmJmZDJhNzZmJyxcclxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXHJcbiAgICBdLFxyXG5dLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IEJpZ0ludChqKSkpKSkoKTtcclxuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XHJcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxyXG4gICAgQjogQmlnSW50KCcxNzcxJyksXHJcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXHJcbn0pKSgpO1xyXG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xyXG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcclxuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XHJcbn0sIHtcclxuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXHJcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxyXG4gICAgcDogRnAuT1JERVIsXHJcbiAgICBtOiAxLFxyXG4gICAgazogMTI4LFxyXG4gICAgZXhwYW5kOiAneG1kJyxcclxuICAgIGhhc2g6IHNoYTI1NixcclxufSkpKCk7XHJcbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xyXG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiLCIvKipcclxuICogIEEgY29uc3RhbnQgZm9yIHRoZSB6ZXJvIGFkZHJlc3MuXHJcbiAqXHJcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgWmVyb0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIiwiLyoqXHJcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgemVybyBoYXNoLlxyXG4gKlxyXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFplcm9IYXNoID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVzLmpzLm1hcCIsIi8vIE5GS0MgKGNvbXBvc2VkKSAgICAgICAgICAgICAvLyAoZGVjb21wb3NlZClcclxuLyoqXHJcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgZXRoZXIgc3ltYm9sIChub3JtYWxpemVkIHVzaW5nIE5GS0MpLlxyXG4gKlxyXG4gKiAgKCoqaS5lLioqIGBgXCJcXFxcdTAzOWVcImBgKVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEV0aGVyU3ltYm9sID0gXCJcXHUwMzllXCI7IC8vIFwiXFx1RDgzNVxcdURGNjNcIjtcclxuLyoqXHJcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgW1tsaW5rLWVpcC0xOTFdXSBwZXJzb25hbCBtZXNzYWdlIHByZWZpeC5cclxuICpcclxuICogICgqKmkuZS4qKiBgYFwiXFxcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcXFxuXCJgYClcclxuICovXHJcbmV4cG9ydCBjb25zdCBNZXNzYWdlUHJlZml4ID0gXCJcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcblwiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdzLmpzLm1hcCIsImltcG9ydCB7IFplcm9IYXNoIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBjb25jYXQsIGRhdGFMZW5ndGgsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGdldE51bWJlciwgaGV4bGlmeSwgdG9CZUFycmF5LCBpc0hleFN0cmluZywgemVyb1BhZFZhbHVlLCBhc3NlcnRBcmd1bWVudCwgYXNzZXJ0UHJpdmF0ZSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG4vLyBDb25zdGFudHNcclxuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcclxuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcclxuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcclxuY29uc3QgQk5fMjcgPSBCaWdJbnQoMjcpO1xyXG5jb25zdCBCTl8yOCA9IEJpZ0ludCgyOCk7XHJcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcclxuY29uc3QgX2d1YXJkID0ge307XHJcbmZ1bmN0aW9uIHRvVWludDI1Nih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHplcm9QYWRWYWx1ZSh0b0JlQXJyYXkodmFsdWUpLCAzMik7XHJcbn1cclxuLyoqXHJcbiAqICBBIFNpZ25hdHVyZSAgQFRPRE9cclxuICpcclxuICpcclxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlNpZ25pbmdcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTaWduYXR1cmUge1xyXG4gICAgI3I7XHJcbiAgICAjcztcclxuICAgICN2O1xyXG4gICAgI25ldHdvcmtWO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGBgcmBgIHZhbHVlIGZvciBhIHNpZ25hdHVyZS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyByZXByZXNlbnRzIHRoZSBgYHhgYCBjb29yZGluYXRlIG9mIGEgXCJyZWZlcmVuY2VcIiBvclxyXG4gICAgICogIGNoYWxsZW5nZSBwb2ludCwgZnJvbSB3aGljaCB0aGUgYGB5YGAgY2FuIGJlIGNvbXB1dGVkLlxyXG4gICAgICovXHJcbiAgICBnZXQgcigpIHsgcmV0dXJuIHRoaXMuI3I7IH1cclxuICAgIHNldCByKHZhbHVlKSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aCh2YWx1ZSkgPT09IDMyLCBcImludmFsaWQgclwiLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICB0aGlzLiNyID0gaGV4bGlmeSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYGBzYGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxyXG4gICAgICovXHJcbiAgICBnZXQgcygpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChwYXJzZUludCh0aGlzLiNzLnN1YnN0cmluZygwLCAzKSkgPCA4LCBcIm5vbi1jYW5vbmljYWwgczsgdXNlIC5fc1wiLCBcInNcIiwgdGhpcy4jcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI3M7XHJcbiAgICB9XHJcbiAgICBzZXQgcyhfdmFsdWUpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKF92YWx1ZSkgPT09IDMyLCBcImludmFsaWQgc1wiLCBcInZhbHVlXCIsIF92YWx1ZSk7XHJcbiAgICAgICAgdGhpcy4jcyA9IGhleGxpZnkoX3ZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgcyB2YWx1ZSwgdW5jaGVja2VkIGZvciBFSVAtMiBjb21wbGlhbmNlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQgYW5kIGlzIGZvciBzaXR1YXRpb25zIHdoZXJlXHJcbiAgICAgKiAgYSBub24tY2Fub25pY2FsIFMgdmFsdWUgbWlnaHQgYmUgcmVsZXZhbnQsIHN1Y2ggYXMgRnJvbnRpZXIgYmxvY2tzXHJcbiAgICAgKiAgdGhhdCB3ZXJlIG1pbmVkIHByaW9yIHRvIEVJUC0yIG9yIGludmFsaWQgQXV0aG9yaXphdGlvbiBMaXN0XHJcbiAgICAgKiAgc2lnbmF0dXJlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IF9zKCkgeyByZXR1cm4gdGhpcy4jczsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSBTaWduYXR1cmUgaXMgdmFsaWQgZm9yIFtbbGluay1laXAtMl1dIHNpZ25hdHVyZXMuXHJcbiAgICAgKi9cclxuICAgIGlzVmFsaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIChwYXJzZUludCh0aGlzLiNzLnN1YnN0cmluZygwLCAzKSkgPCA4KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBgYHZgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXHJcbiAgICAgKlxyXG4gICAgICogIFNpbmNlIGEgZ2l2ZW4gYGB4YGAgdmFsdWUgZm9yIGBgcmBgIGhhcyB0d28gcG9zc2libGUgdmFsdWVzIGZvclxyXG4gICAgICogIGl0cyBjb3JyZXNwb25kaW4gYGB5YGAsIHRoZSBgYHZgYCBpbmRpY2F0ZXMgd2hpY2ggb2YgdGhlIHR3byBgYHlgYFxyXG4gICAgICogIHZhbHVlcyB0byB1c2UuXHJcbiAgICAgKlxyXG4gICAgICogIEl0IGlzIG5vcm1hbGl6ZWQgdG8gdGhlIHZhbHVlcyBgYDI3YGAgb3IgYGAyOGBgIGZvciBsZWdhY3lcclxuICAgICAqICBwdXJwb3Nlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHYoKSB7IHJldHVybiB0aGlzLiN2OyB9XHJcbiAgICBzZXQgdih2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHYgPSBnZXROdW1iZXIodmFsdWUsIFwidmFsdWVcIik7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodiA9PT0gMjcgfHwgdiA9PT0gMjgsIFwiaW52YWxpZCB2XCIsIFwidlwiLCB2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy4jdiA9IHY7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgRUlQLTE1NSBgYHZgYCBmb3IgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcclxuICAgICAqICB0cmFuc2FjdGlvbnMsIHRoaXMgdmFsdWUgaXMgYGBudWxsYGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBuZXR3b3JrVigpIHsgcmV0dXJuIHRoaXMuI25ldHdvcmtWOyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY2hhaW4gSUQgZm9yIEVJUC0xNTUgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcclxuICAgICAqICB0cmFuc2FjdGlvbnMsIHRoaXMgdmFsdWUgaXMgYGBudWxsYGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBsZWdhY3lDaGFpbklkKCkge1xyXG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLm5ldHdvcmtWO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZ2V0Q2hhaW5JZCh2KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBgYHlQYXJpdHlgYCBmb3IgdGhlIHNpZ25hdHVyZS5cclxuICAgICAqXHJcbiAgICAgKiAgU2VlIGBgdmBgIGZvciBtb3JlIGRldGFpbHMgb24gaG93IHRoaXMgdmFsdWUgaXMgdXNlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHlQYXJpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnYgPT09IDI3KSA/IDAgOiAxO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjA5OF1dIGNvbXBhY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBgeVBhcml0eWBgXHJcbiAgICAgKiAgYW5kIGBgc2BgIGNvbXBhY3RlZCBpbnRvIGEgc2luZ2xlIGBgYnl0ZXMzMmBgLlxyXG4gICAgICovXHJcbiAgICBnZXQgeVBhcml0eUFuZFMoKSB7XHJcbiAgICAgICAgLy8gVGhlIEVJUC0yMDk4IGNvbXBhY3QgcmVwcmVzZW50YXRpb25cclxuICAgICAgICBjb25zdCB5UGFyaXR5QW5kUyA9IGdldEJ5dGVzKHRoaXMucyk7XHJcbiAgICAgICAgaWYgKHRoaXMueVBhcml0eSkge1xyXG4gICAgICAgICAgICB5UGFyaXR5QW5kU1swXSB8PSAweDgwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGV4bGlmeSh5UGFyaXR5QW5kUyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yMDk4XV0gY29tcGFjdCByZXByZXNlbnRhdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IGNvbXBhY3RTZXJpYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiBjb25jYXQoW3RoaXMuciwgdGhpcy55UGFyaXR5QW5kU10pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBzZXJpYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiBjb25jYXQoW3RoaXMuciwgdGhpcy5zLCAodGhpcy55UGFyaXR5ID8gXCIweDFjXCIgOiBcIjB4MWJcIildKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCByLCBzLCB2KSB7XHJcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIlNpZ25hdHVyZVwiKTtcclxuICAgICAgICB0aGlzLiNyID0gcjtcclxuICAgICAgICB0aGlzLiNzID0gcztcclxuICAgICAgICB0aGlzLiN2ID0gdjtcclxuICAgICAgICB0aGlzLiNuZXR3b3JrViA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XHJcbiAgICAgICAgcmV0dXJuIGBTaWduYXR1cmUgeyByOiBcIiR7dGhpcy5yfVwiLCBzOiBcIiR7dGhpcy5fc31cIiR7dGhpcy5pc1ZhbGlkKCkgPyBcIlwiIDogJywgdmFsaWQ6IFwiZmFsc2VcIid9LCB5UGFyaXR5OiAke3RoaXMueVBhcml0eX0sIG5ldHdvcmtWOiAke3RoaXMubmV0d29ya1Z9IH1gO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBpZGVudGljYWwgW1tTaWduYXR1cmVdXS5cclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgdGhpcy5yLCB0aGlzLl9zLCB0aGlzLnYpO1xyXG4gICAgICAgIGlmICh0aGlzLm5ldHdvcmtWKSB7XHJcbiAgICAgICAgICAgIGNsb25lLiNuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBgYEpTT04uc3RyaW5naWZ5YGAuXHJcbiAgICAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgX3R5cGU6IFwic2lnbmF0dXJlXCIsXHJcbiAgICAgICAgICAgIG5ldHdvcmtWOiAoKG5ldHdvcmtWICE9IG51bGwpID8gbmV0d29ya1YudG9TdHJpbmcoKSA6IG51bGwpLFxyXG4gICAgICAgICAgICByOiB0aGlzLnIsIHM6IHRoaXMuX3MsIHY6IHRoaXMudixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ29tcHV0ZSB0aGUgY2hhaW4gSUQgZnJvbSB0aGUgYGB2YGAgaW4gYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogIEBleGFtcGxlOlxyXG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDUpXHJcbiAgICAgKiAgICAvL19yZXN1bHQ6XHJcbiAgICAgKlxyXG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDYpXHJcbiAgICAgKiAgICAvL19yZXN1bHQ6XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRDaGFpbklkKHYpIHtcclxuICAgICAgICBjb25zdCBidiA9IGdldEJpZ0ludCh2LCBcInZcIik7XHJcbiAgICAgICAgLy8gVGhlIHYgaXMgbm90IGFuIEVJUC0xNTUgdiwgc28gaXQgaXMgdGhlIHVuc3BlY2lmaWVkIGNoYWluIElEXHJcbiAgICAgICAgaWYgKChidiA9PSBCTl8yNykgfHwgKGJ2ID09IEJOXzI4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQmFkIHZhbHVlIGZvciBhbiBFSVAtMTU1IHZcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChidiA+PSBCTl8zNSwgXCJpbnZhbGlkIEVJUC0xNTUgdlwiLCBcInZcIiwgdik7XHJcbiAgICAgICAgcmV0dXJuIChidiAtIEJOXzM1KSAvIEJOXzI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDb21wdXRlIHRoZSBgYHZgYCBmb3IgYSBjaGFpbiBJRCBmb3IgYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogIExlZ2FjeSB0cmFuc2FjdGlvbnMgd2hpY2ggdXNlIFtbbGluay1laXAtMTU1XV0gaGlqYWNrIHRoZSBgYHZgYFxyXG4gICAgICogIHByb3BlcnR5IHRvIGluY2x1ZGUgdGhlIGNoYWluIElELlxyXG4gICAgICpcclxuICAgICAqICBAZXhhbXBsZTpcclxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyNylcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqXHJcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoNSwgMjgpXHJcbiAgICAgKiAgICAvL19yZXN1bHQ6XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgdikge1xyXG4gICAgICAgIHJldHVybiAoZ2V0QmlnSW50KGNoYWluSWQpICogQk5fMikgKyBCaWdJbnQoMzUgKyB2IC0gMjcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ29tcHV0ZSB0aGUgbm9ybWFsaXplZCBsZWdhY3kgdHJhbnNhY3Rpb24gYGB2YGAgZnJvbSBhIGBgeVBhcmlydHlgYCxcclxuICAgICAqICBhIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBvciBhIGxlZ2FjeSBbW2xpbmstZWlwLTE1NV1dIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqICBAZXhhbXBsZTpcclxuICAgICAqICAgIC8vIFRoZSB2YWx1ZXMgMCBhbmQgMSBpbXBseSB2IGlzIGFjdHVhbGx5IHlQYXJpdHlcclxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigwKVxyXG4gICAgICogICAgLy9fcmVzdWx0OlxyXG4gICAgICpcclxuICAgICAqICAgIC8vIExlZ2FjeSBub24tRUlQLTE1NTkgdHJhbnNhY3Rpb24gKGkuZS4gMjcgb3IgMjgpXHJcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoMjcpXHJcbiAgICAgKiAgICAvL19yZXN1bHQ6XHJcbiAgICAgKlxyXG4gICAgICogICAgLy8gTGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb24gKGkuZS4gPj0gMzUpXHJcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoNDYpXHJcbiAgICAgKiAgICAvL19yZXN1bHQ6XHJcbiAgICAgKlxyXG4gICAgICogICAgLy8gSW52YWxpZCB2YWx1ZXMgdGhyb3dcclxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig1KVxyXG4gICAgICogICAgLy9fZXJyb3I6XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXROb3JtYWxpemVkVih2KSB7XHJcbiAgICAgICAgY29uc3QgYnYgPSBnZXRCaWdJbnQodik7XHJcbiAgICAgICAgaWYgKGJ2ID09PSBCTl8wIHx8IGJ2ID09PSBCTl8yNykge1xyXG4gICAgICAgICAgICByZXR1cm4gMjc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChidiA9PT0gQk5fMSB8fCBidiA9PT0gQk5fMjgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChidiA+PSBCTl8zNSwgXCJpbnZhbGlkIHZcIiwgXCJ2XCIsIHYpO1xyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgRUlQLTE1NSB2IG1lYW5zIG9kZCBpcyAyNyBhbmQgZXZlbiBpcyAyOFxyXG4gICAgICAgIHJldHVybiAoYnYgJiBCTl8xKSA/IDI3IDogMjg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbU2lnbmF0dXJlXV0uXHJcbiAgICAgKlxyXG4gICAgICogIElmIG5vICUlc2lnJSUgaXMgcHJvdmlkZWQsIGEgbmV3IFtbU2lnbmF0dXJlXV0gaXMgY3JlYXRlZFxyXG4gICAgICogIHdpdGggZGVmYXVsdCB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogIElmICUlc2lnJSUgaXMgYSBzdHJpbmcsIGl0IGlzIHBhcnNlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20oc2lnKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0RXJyb3IoY2hlY2ssIG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoY2hlY2ssIG1lc3NhZ2UsIFwic2lnbmF0dXJlXCIsIHNpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICBpZiAoc2lnID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCBaZXJvSGFzaCwgWmVyb0hhc2gsIDI3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoc2lnKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHNpZywgXCJzaWduYXR1cmVcIik7XHJcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGJ5dGVzLnNsaWNlKDMyLCA2NCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gKHNbMF0gJiAweDgwKSA/IDI4IDogMjc7XHJcbiAgICAgICAgICAgICAgICBzWzBdICY9IDB4N2Y7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIGhleGxpZnkocyksIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKGJ5dGVzWzY0XSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIHMsIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcImludmFsaWQgcmF3IHNpZ25hdHVyZSBsZW5ndGhcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaWcgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpZy5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZXQgclxyXG4gICAgICAgIGNvbnN0IF9yID0gc2lnLnI7XHJcbiAgICAgICAgYXNzZXJ0RXJyb3IoX3IgIT0gbnVsbCwgXCJtaXNzaW5nIHJcIik7XHJcbiAgICAgICAgY29uc3QgciA9IHRvVWludDI1Nihfcik7XHJcbiAgICAgICAgLy8gR2V0IHM7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxyXG4gICAgICAgIGNvbnN0IHMgPSAoZnVuY3Rpb24gKHMsIHlQYXJpdHlBbmRTKSB7XHJcbiAgICAgICAgICAgIGlmIChzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b1VpbnQyNTYocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGlzSGV4U3RyaW5nKHlQYXJpdHlBbmRTLCAzMiksIFwiaW52YWxpZCB5UGFyaXR5QW5kU1wiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoeVBhcml0eUFuZFMpO1xyXG4gICAgICAgICAgICAgICAgYnl0ZXNbMF0gJj0gMHg3ZjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJtaXNzaW5nIHNcIik7XHJcbiAgICAgICAgfSkoc2lnLnMsIHNpZy55UGFyaXR5QW5kUyk7XHJcbiAgICAgICAgLy8gR2V0IHY7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxyXG4gICAgICAgIGNvbnN0IHsgbmV0d29ya1YsIHYgfSA9IChmdW5jdGlvbiAoX3YsIHlQYXJpdHlBbmRTLCB5UGFyaXR5KSB7XHJcbiAgICAgICAgICAgIGlmIChfdiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gZ2V0QmlnSW50KF92KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Y6ICgodiA+PSBCTl8zNSkgPyB2IDogdW5kZWZpbmVkKSxcclxuICAgICAgICAgICAgICAgICAgICB2OiBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYodilcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGlzSGV4U3RyaW5nKHlQYXJpdHlBbmRTLCAzMiksIFwiaW52YWxpZCB5UGFyaXR5QW5kU1wiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHY6ICgoZ2V0Qnl0ZXMoeVBhcml0eUFuZFMpWzBdICYgMHg4MCkgPyAyOCA6IDI3KSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh5UGFyaXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZ2V0TnVtYmVyKHlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiB7IHY6IDI3IH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4geyB2OiAyOCB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCB5UGFyaXR5XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3NpbmcgdlwiKTtcclxuICAgICAgICB9KShzaWcudiwgc2lnLnlQYXJpdHlBbmRTLCBzaWcueVBhcml0eSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIHMsIHYpO1xyXG4gICAgICAgIGlmIChuZXR3b3JrVikge1xyXG4gICAgICAgICAgICByZXN1bHQuI25ldHdvcmtWID0gbmV0d29ya1Y7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIG11bHRpcGxlIG9mIHYsIHlQYXJpdHksIHlQYXJpdHlBbmRTIHdlIGdpdmVuLCBjaGVjayB0aGV5IG1hdGNoXHJcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHkgPT0gbnVsbCB8fCBnZXROdW1iZXIoc2lnLnlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikgPT09IHJlc3VsdC55UGFyaXR5LCBcInlQYXJpdHkgbWlzbWF0Y2hcIik7XHJcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHlBbmRTID09IG51bGwgfHwgc2lnLnlQYXJpdHlBbmRTID09PSByZXN1bHQueVBhcml0eUFuZFMsIFwieVBhcml0eUFuZFMgbWlzbWF0Y2hcIik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIiwiLyoqXHJcbiAqICBBZGQgZGV0YWlscyBhYm91dCBzaWduaW5nIGhlcmUuXHJcbiAqXHJcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86U2lnbmluZyAgW2Fib3V0LXNpZ25pbmddXHJcbiAqL1xyXG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcclxuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5LCB0b0JlSGV4LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi9zaWduYXR1cmUuanNcIjtcclxuLyoqXHJcbiAqICBBICoqU2lnbmluZ0tleSoqIHByb3ZpZGVzIGhpZ2gtbGV2ZWwgYWNjZXNzIHRvIHRoZSBlbGxpcHRpYyBjdXJ2ZVxyXG4gKiAgY3J5cHRvZ3JhcGh5IChFQ0MpIG9wZXJhdGlvbnMgYW5kIGtleSBtYW5hZ2VtZW50LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNpZ25pbmdLZXkge1xyXG4gICAgI3ByaXZhdGVLZXk7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqU2lnbmluZ0tleSoqIGZvciAlJXByaXZhdGVLZXklJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZUtleSkge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgocHJpdmF0ZUtleSkgPT09IDMyLCBcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcclxuICAgICAgICB0aGlzLiNwcml2YXRlS2V5ID0gaGV4bGlmeShwcml2YXRlS2V5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwcml2YXRlIGtleS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7IHJldHVybiB0aGlzLiNwcml2YXRlS2V5OyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGAweDA0YGAgYW5kIGJlIDEzMlxyXG4gICAgICogY2hhcmFjdGVycyBsb25nICh0aGUgYGAweGBgIHByZWZpeCBhbmQgMTMwIGhleGFkZWNpbWFsIG5pYmJsZXMpLlxyXG4gICAgICovXHJcbiAgICBnZXQgcHVibGljS2V5KCkgeyByZXR1cm4gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXkpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHdpbGwgYWx3YXlzIGJlZ2luIHdpdGggZWl0aGVyIHRoZSBwcmVmaXggYGAweDAyYGAgb3IgYGAweDAzYGBcclxuICAgICAqICBhbmQgYmUgNjggY2hhcmFjdGVycyBsb25nICh0aGUgYGAweGBgIHByZWZpeCBhbmQgMzMgaGV4YWRlY2ltYWxcclxuICAgICAqICBuaWJibGVzKVxyXG4gICAgICovXHJcbiAgICBnZXQgY29tcHJlc3NlZFB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5LCB0cnVlKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCAlJWRpZ2VzdCUlLlxyXG4gICAgICovXHJcbiAgICBzaWduKGRpZ2VzdCkge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgoZGlnZXN0KSA9PT0gMzIsIFwiaW52YWxpZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XHJcbiAgICAgICAgY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24oZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCksIGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwge1xyXG4gICAgICAgICAgICBsb3dTOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tKHtcclxuICAgICAgICAgICAgcjogdG9CZUhleChzaWcuciwgMzIpLFxyXG4gICAgICAgICAgICBzOiB0b0JlSGV4KHNpZy5zLCAzMiksXHJcbiAgICAgICAgICAgIHY6IChzaWcucmVjb3ZlcnkgPyAweDFjIDogMHgxYilcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIFtbbGluay13aWtpLWVjZGhdXSBzaGFyZWQgc2VjcmV0IGJldHdlZW4gdGhpc1xyXG4gICAgICogIHByaXZhdGUga2V5IGFuZCB0aGUgJSVvdGhlciUlIGtleS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhlICUlb3RoZXIlJSBrZXkgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSxcclxuICAgICAqICBhIGNvbXByZXNzZWQvdW5jb21wcmVzc2VkIHB1YmljIGtleSBvciBhcHJpdmF0ZSBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogIEJlc3QgcHJhY3RpY2UgaXMgdXN1YWxseSB0byB1c2UgYSBjcnlwdG9ncmFwaGljIGhhc2ggb24gdGhlXHJcbiAgICAgKiAgcmV0dXJuZWQgdmFsdWUgYmVmb3JlIHVzaW5nIGl0IGFzIGEgc3ltZXRyaWMgc2VjcmV0LlxyXG4gICAgICpcclxuICAgICAqICBAZXhhbXBsZTpcclxuICAgICAqICAgIHNpZ24xID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldC0xXCIpKVxyXG4gICAgICogICAgc2lnbjIgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTJcIikpXHJcbiAgICAgKlxyXG4gICAgICogICAgLy8gTm90aWNlIHRoYXQgcHJpdkEuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJCKS4uLlxyXG4gICAgICogICAgc2lnbjEuY29tcHV0ZVNoYXJlZFNlY3JldChzaWduMi5wdWJsaWNLZXkpXHJcbiAgICAgKiAgICAvL19yZXN1bHQ6XHJcbiAgICAgKlxyXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gcHJpdkIuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJBKS5cclxuICAgICAqICAgIHNpZ24yLmNvbXB1dGVTaGFyZWRTZWNyZXQoc2lnbjEucHVibGljS2V5KVxyXG4gICAgICogICAgLy9fcmVzdWx0OlxyXG4gICAgICovXHJcbiAgICBjb21wdXRlU2hhcmVkU2VjcmV0KG90aGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHViS2V5ID0gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KG90aGVyKTtcclxuICAgICAgICByZXR1cm4gaGV4bGlmeShzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwgZ2V0Qnl0ZXMocHViS2V5KSwgZmFsc2UpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yICUla2V5JSUsIG9wdGlvbmFsbHkgJSVjb21wcmVzc2VkJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSAlJWtleSUlIG1heSBiZSBhbnkgdHlwZSBvZiBrZXksIGEgcmF3IHB1YmxpYyBrZXksIGFcclxuICAgICAqICBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJsaWMga2V5IG9yIHByaXZhdGUga2V5LlxyXG4gICAgICpcclxuICAgICAqICBAZXhhbXBsZTpcclxuICAgICAqICAgIHNpZ24gPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleVxyXG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHJpdmF0ZUtleSlcclxuICAgICAqICAgIC8vX3Jlc3VsdDpcclxuICAgICAqXHJcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcclxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnByaXZhdGVLZXksIHRydWUpXHJcbiAgICAgKiAgICAvL19yZXN1bHQ6XHJcbiAgICAgKlxyXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlcclxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnB1YmxpY0tleSwgZmFsc2UpO1xyXG4gICAgICogICAgLy9fcmVzdWx0OlxyXG4gICAgICpcclxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIENvbXByZXNzZWQgYSBwdWJsaWMga2V5XHJcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIHRydWUpO1xyXG4gICAgICogICAgLy9fcmVzdWx0OlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tcHV0ZVB1YmxpY0tleShrZXksIGNvbXByZXNzZWQpIHtcclxuICAgICAgICBsZXQgYnl0ZXMgPSBnZXRCeXRlcyhrZXksIFwia2V5XCIpO1xyXG4gICAgICAgIC8vIHByaXZhdGUga2V5XHJcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcclxuICAgICAgICAgICAgY29uc3QgcHViS2V5ID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleShieXRlcywgISFjb21wcmVzc2VkKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocHViS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmF3IHB1YmxpYyBrZXk7IHVzZSB1bmNvbXByZXNzZWQga2V5IHdpdGggMHgwNCBwcmVmaXhcclxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xyXG4gICAgICAgICAgICBjb25zdCBwdWIgPSBuZXcgVWludDhBcnJheSg2NSk7XHJcbiAgICAgICAgICAgIHB1YlswXSA9IDB4MDQ7XHJcbiAgICAgICAgICAgIHB1Yi5zZXQoYnl0ZXMsIDEpO1xyXG4gICAgICAgICAgICBieXRlcyA9IHB1YjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoYnl0ZXMpO1xyXG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHBvaW50LnRvUmF3Qnl0ZXMoY29tcHJlc3NlZCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgcHVibGljIGtleSBmb3IgdGhlIHByaXZhdGUga2V5IHdoaWNoIHByb2R1Y2VkIHRoZVxyXG4gICAgICogICUlc2lnbmF0dXJlJSUgZm9yIHRoZSBnaXZlbiAlJWRpZ2VzdCUlLlxyXG4gICAgICpcclxuICAgICAqICBAZXhhbXBsZTpcclxuICAgICAqICAgIGtleSA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXRcIikpXHJcbiAgICAgKiAgICBkaWdlc3QgPSBpZChcImhlbGxvIHdvcmxkXCIpXHJcbiAgICAgKiAgICBzaWcgPSBrZXkuc2lnbihkaWdlc3QpXHJcbiAgICAgKlxyXG4gICAgICogICAgLy8gTm90aWNlIHRoZSBzaWduZXIgcHVibGljIGtleS4uLlxyXG4gICAgICogICAga2V5LnB1YmxpY0tleVxyXG4gICAgICogICAgLy9fcmVzdWx0OlxyXG4gICAgICpcclxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHRoZSByZWNvdmVyZWQgcHVibGljIGtleVxyXG4gICAgICogICAgU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnKVxyXG4gICAgICogICAgLy9fcmVzdWx0OlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKGRpZ2VzdCkgPT09IDMyLCBcImludmFsaWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xyXG4gICAgICAgIGNvbnN0IHNpZyA9IFNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSk7XHJcbiAgICAgICAgbGV0IHNlY3BTaWcgPSBzZWNwMjU2azEuU2lnbmF0dXJlLmZyb21Db21wYWN0KGdldEJ5dGVzQ29weShjb25jYXQoW3NpZy5yLCBzaWcuc10pKSk7XHJcbiAgICAgICAgc2VjcFNpZyA9IHNlY3BTaWcuYWRkUmVjb3ZlcnlCaXQoc2lnLnlQYXJpdHkpO1xyXG4gICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3BTaWcucmVjb3ZlclB1YmxpY0tleShnZXRCeXRlc0NvcHkoZGlnZXN0KSk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHViS2V5ICE9IG51bGwsIFwiaW52YWxpZCBzaWduYXR1cmUgZm9yIGRpZ2VzdFwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xyXG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWJLZXkudG9IZXgoZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgcG9pbnQgcmVzdWx0aW5nIGZyb20gYWRkaW5nIHRoZSBlbGxpcGljIGN1cnZlIHBvaW50c1xyXG4gICAgICogICUlcDAlJSBhbmQgJSVwMSUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIG5vdCBhIGNvbW1vbiBmdW5jdGlvbiBtb3N0IGRldmVsb3BlcnMgc2hvdWxkIHJlcXVpcmUsIGJ1dFxyXG4gICAgICogIGNhbiBiZSB1c2VmdWwgZm9yIGNlcnRhaW4gcHJpdmFjeS1zcGVjaWZpYyB0ZWNobmlxdWVzLlxyXG4gICAgICpcclxuICAgICAqICBGb3IgZXhhbXBsZSwgaXQgaXMgdXNlZCBieSBbW0hETm9kZVdhbGxldF1dIHRvIGNvbXB1dGUgY2hpbGRcclxuICAgICAqICBhZGRyZXNzZXMgZnJvbSBwYXJlbnQgcHVibGljIGtleXMgYW5kIGNoYWluIGNvZGVzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYWRkUG9pbnRzKHAwLCBwMSwgY29tcHJlc3NlZCkge1xyXG4gICAgICAgIGNvbnN0IHB1YjAgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHAwKS5zdWJzdHJpbmcoMikpO1xyXG4gICAgICAgIGNvbnN0IHB1YjEgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHAxKS5zdWJzdHJpbmcoMikpO1xyXG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWIwLmFkZChwdWIxKS50b0hleCghIWNvbXByZXNzZWQpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25pbmcta2V5LmpzLm1hcCIsImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XHJcbmNvbnN0IEJOXzM2ID0gQmlnSW50KDM2KTtcclxuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcclxuICAgIC8vICAgIGlmICghaXNIZXhTdHJpbmcoYWRkcmVzcywgMjApKSB7XHJcbiAgICAvLyAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XHJcbiAgICAvLyAgICB9XHJcbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgY29uc3QgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcclxuICAgIGNvbnN0IGV4cGFuZGVkID0gbmV3IFVpbnQ4QXJyYXkoNDApO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSsrKSB7XHJcbiAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFzaGVkID0gZ2V0Qnl0ZXMoa2VjY2FrMjU2KGV4cGFuZGVkKSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcclxuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcclxuICAgICAgICAgICAgY2hhcnNbaV0gPSBjaGFyc1tpXS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xyXG4gICAgICAgICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCIweFwiICsgY2hhcnMuam9pbihcIlwiKTtcclxufVxyXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlclxyXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlXHJcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcclxuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XHJcbiAgICBpYmFuTG9va3VwW1N0cmluZyhpKV0gPSBTdHJpbmcoaSk7XHJcbn1cclxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNjsgaSsrKSB7XHJcbiAgICBpYmFuTG9va3VwW1N0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBpKV0gPSBTdHJpbmcoMTAgKyBpKTtcclxufVxyXG4vLyBIb3cgbWFueSBkZWNpbWFsIGRpZ2l0cyBjYW4gd2UgcHJvY2Vzcz8gKGZvciA2NC1iaXQgZmxvYXQsIHRoaXMgaXMgMTUpXHJcbi8vIGkuZS4gTWF0aC5mbG9vcihNYXRoLmxvZzEwKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSk7XHJcbmNvbnN0IHNhZmVEaWdpdHMgPSAxNTtcclxuZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3MpIHtcclxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvVXBwZXJDYXNlKCk7XHJcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcclxuICAgIGxldCBleHBhbmRlZCA9IGFkZHJlc3Muc3BsaXQoXCJcIikubWFwKChjKSA9PiB7IHJldHVybiBpYmFuTG9va3VwW2NdOyB9KS5qb2luKFwiXCIpO1xyXG4gICAgLy8gSmF2YXNjcmlwdCBjYW4gaGFuZGxlIGludGVnZXJzIHNhZmVseSB1cCB0byAxNSAoZGVjaW1hbCkgZGlnaXRzXHJcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcclxuICAgICAgICBsZXQgYmxvY2sgPSBleHBhbmRlZC5zdWJzdHJpbmcoMCwgc2FmZURpZ2l0cyk7XHJcbiAgICAgICAgZXhwYW5kZWQgPSBwYXJzZUludChibG9jaywgMTApICUgOTcgKyBleHBhbmRlZC5zdWJzdHJpbmcoYmxvY2subGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGxldCBjaGVja3N1bSA9IFN0cmluZyg5OCAtIChwYXJzZUludChleHBhbmRlZCwgMTApICUgOTcpKTtcclxuICAgIHdoaWxlIChjaGVja3N1bS5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoZWNrc3VtO1xyXG59XHJcbjtcclxuY29uc3QgQmFzZTM2ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIDtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzNjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIltpXTtcclxuICAgICAgICByZXN1bHRba2V5XSA9IEJpZ0ludChpKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIGZyb21CYXNlMzYodmFsdWUpIHtcclxuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcclxuICAgIGxldCByZXN1bHQgPSBCTl8wO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIEJOXzM2ICsgQmFzZTM2W3ZhbHVlW2ldXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIGEgbm9ybWFsaXplZCBhbmQgY2hlY2tzdW1lZCBhZGRyZXNzIGZvciAlJWFkZHJlc3MlJS5cclxuICogIFRoaXMgYWNjZXB0cyBub24tY2hlY2tzdW0gYWRkcmVzc2VzLCBjaGVja3N1bSBhZGRyZXNzZXMgYW5kXHJcbiAqICBbW2dldEljYXBBZGRyZXNzXV0gZm9ybWF0cy5cclxuICpcclxuICogIFRoZSBjaGVja3N1bSBpbiBFdGhlcmV1bSB1c2VzIHRoZSBjYXBpdGFsaXphdGlvbiAodXBwZXItY2FzZVxyXG4gKiAgdnMgbG93ZXItY2FzZSkgb2YgdGhlIGNoYXJhY3RlcnMgd2l0aGluIGFuIGFkZHJlc3MgdG8gZW5jb2RlXHJcbiAqICBpdHMgY2hlY2tzdW0sIHdoaWNoIG9mZmVycywgb24gYXZlcmFnZSwgYSBjaGVja3N1bSBvZiAxNS1iaXRzLlxyXG4gKlxyXG4gKiAgSWYgJSVhZGRyZXNzJSUgY29udGFpbnMgYm90aCB1cHBlci1jYXNlIGFuZCBsb3dlci1jYXNlLCBpdCBpc1xyXG4gKiAgYXNzdW1lZCB0byBhbHJlYWR5IGJlIGEgY2hlY2tzdW0gYWRkcmVzcyBhbmQgaXRzIGNoZWNrc3VtIGlzXHJcbiAqICB2YWxpZGF0ZWQsIGFuZCBpZiB0aGUgYWRkcmVzcyBmYWlscyBpdHMgZXhwZWN0ZWQgY2hlY2tzdW0gYW5cclxuICogIGVycm9yIGlzIHRocm93bi5cclxuICpcclxuICogIElmIHlvdSB3aXNoIHRoZSBjaGVja3N1bSBvZiAlJWFkZHJlc3MlJSB0byBiZSBpZ25vcmUsIGl0IHNob3VsZFxyXG4gKiAgYmUgY29udmVydGVkIHRvIGxvd2VyLWNhc2UgKGkuZS4gYGAudG9Mb3dlcmNhc2UoKWBgKSBiZWZvcmVcclxuICogIGJlaW5nIHBhc3NlZCBpbi4gVGhpcyBzaG91bGQgYmUgYSB2ZXJ5IHJhcmUgc2l0dWF0aW9uIHRob3VnaCxcclxuICogIHRoYXQgeW91IHdpc2ggdG8gYnlwYXNzIHRoZSBzYWZlZ2F1cmRzIGluIHBsYWNlIHRvIHByb3RlY3RcclxuICogIGFnYWluc3QgYW4gYWRkcmVzcyB0aGF0IGhhcyBiZWVuIGluY29ycmVjdGx5IGNvcGllZCBmcm9tIGFub3RoZXJcclxuICogIHNvdXJjZS5cclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICAvLyBBZGRzIHRoZSBjaGVja3N1bSAodmlhIHVwcGVyLWNhc2luZyBzcGVjaWZpYyBsZXR0ZXJzKVxyXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgLy8gQ29udmVydHMgSUNBUCBhZGRyZXNzIGFuZCBhZGRzIGNoZWNrc3VtXHJcbiAqICAgIGdldEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgYW4gYWRkcmVzcyBjb250YWlucyBtaXhlZCBjYXNlLFxyXG4gKiAgICAvLyBidXQgdGhlIGNoZWNrc3VtIGZhaWxzXHJcbiAqICAgIGdldEFkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcclxuICogICAgLy9fZXJyb3I6XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XHJcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKGFkZHJlc3MpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XHJcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKSB7XHJcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XHJcbiAgICAgICAgaWYgKCFhZGRyZXNzLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xyXG4gICAgICAgICAgICBhZGRyZXNzID0gXCIweFwiICsgYWRkcmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xyXG4gICAgICAgIC8vIEl0IGlzIGEgY2hlY2tzdW1tZWQgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgfHwgcmVzdWx0ID09PSBhZGRyZXNzLCBcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcclxuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xyXG4gICAgICAgIC8vIEl0IGlzIGFuIElDQVAgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgPT09IGliYW5DaGVja3N1bShhZGRyZXNzKSwgXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZyb21CYXNlMzYoYWRkcmVzcy5zdWJzdHJpbmcoNCkpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDQwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tzdW1BZGRyZXNzKFwiMHhcIiArIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xyXG59XHJcbi8qKlxyXG4gKiAgVGhlIFtJQ0FQIEFkZHJlc3MgZm9ybWF0XShsaW5rLWljYXApIGZvcm1hdCBpcyBhbiBlYXJseSBjaGVja3N1bVxyXG4gKiAgZm9ybWF0IHdoaWNoIGF0dGVtcHRzIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgYmFua2luZ1xyXG4gKiAgaW5kdXN0cnkgW0lCQU4gZm9ybWF0XShsaW5rLXdpa2ktaWJhbikgZm9yIGJhbmsgYWNjb3VudHMuXHJcbiAqXHJcbiAqICBJdCBpcyBubyBsb25nZXIgY29tbW9uIG9yIGEgcmVjb21tZW5kZWQgZm9ybWF0LlxyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpO1xyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBJQ0FQIGNoZWNrc3VtIGlzIHdyb25nXHJcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzdcIik7XHJcbiAqICAgIC8vX2Vycm9yOlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcclxuICAgIC8vbGV0IGJhc2UzNiA9IF9iYXNlMTZUbzM2KGdldEFkZHJlc3MoYWRkcmVzcykuc3Vic3RyaW5nKDIpKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgbGV0IGJhc2UzNiA9IEJpZ0ludChnZXRBZGRyZXNzKGFkZHJlc3MpKS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKTtcclxuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcclxuICAgICAgICBiYXNlMzYgPSBcIjBcIiArIGJhc2UzNjtcclxuICAgIH1cclxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIiwiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBjb25jYXQsIGRhdGFTbGljZSwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZW5jb2RlUmxwLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzcy5qc1wiO1xyXG4vLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURWBgIGZvciAlJXR4JSUuXHJcbiAqXHJcbiAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGFkZHJlc3MgYSBjb250cmFjdCB3aWxsIGJlXHJcbiAqICBkZXBsb3llZCB0byBieSBhbiBFT0Egd2hlbiBzZW5kaW5nIGEgZGVwbG95bWVudCB0cmFuc2FjdGlvbiAoaS5lLlxyXG4gKiAgd2hlbiB0aGUgYGB0b2BgIGFkZHJlc3MgaXMgYGBudWxsYGApLlxyXG4gKlxyXG4gKiAgVGhpcyBjYW4gYWxzbyBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGFkZHJlc3MgYSBjb250cmFjdCB3aWxsIGJlXHJcbiAqICBkZXBsb3llZCB0byBieSBhIGNvbnRyYWN0LCBieSB1c2luZyB0aGUgY29udHJhY3QncyBhZGRyZXNzIGFzIHRoZVxyXG4gKiAgYGB0b2BgIGFuZCB0aGUgY29udHJhY3QncyBub25jZS5cclxuICpcclxuICogIEBleGFtcGxlXHJcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiO1xyXG4gKiAgICBub25jZSA9IDU7XHJcbiAqXHJcbiAqICAgIGdldENyZWF0ZUFkZHJlc3MoeyBmcm9tLCBub25jZSB9KTtcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZUFkZHJlc3ModHgpIHtcclxuICAgIGNvbnN0IGZyb20gPSBnZXRBZGRyZXNzKHR4LmZyb20pO1xyXG4gICAgY29uc3Qgbm9uY2UgPSBnZXRCaWdJbnQodHgubm9uY2UsIFwidHgubm9uY2VcIik7XHJcbiAgICBsZXQgbm9uY2VIZXggPSBub25jZS50b1N0cmluZygxNik7XHJcbiAgICBpZiAobm9uY2VIZXggPT09IFwiMFwiKSB7XHJcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4XCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChub25jZUhleC5sZW5ndGggJSAyKSB7XHJcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4MFwiICsgbm9uY2VIZXg7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBub25jZUhleCA9IFwiMHhcIiArIG5vbmNlSGV4O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEFkZHJlc3MoZGF0YVNsaWNlKGtlY2NhazI1NihlbmNvZGVSbHAoW2Zyb20sIG5vbmNlSGV4XSkpLCAxMikpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIGEgYGBDUkVBVEUyYGAgb3BlcmF0aW9uXHJcbiAqICB3aXRoIHRoZSBnaXZlbiAlJWZyb20lJSwgJSVzYWx0JSUgYW5kICUlaW5pdENvZGVIYXNoJSUuXHJcbiAqXHJcbiAqICBUbyBjb21wdXRlIHRoZSAlJWluaXRDb2RlSGFzaCUlIGZyb20gYSBjb250cmFjdCdzIGluaXQgY29kZSwgdXNlXHJcbiAqICB0aGUgW1trZWNjYWsyNTZdXSBmdW5jdGlvbi5cclxuICpcclxuICogIEZvciBhIHF1aWNrIG92ZXJ2aWV3IGFuZCBleGFtcGxlIG9mIGBgQ1JFQVRFMmBgLCBzZWUgW1tsaW5rLXJpY21vby13aXNwc11dLlxyXG4gKlxyXG4gKiAgQGV4YW1wbGVcclxuICogICAgLy8gVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0XHJcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiXHJcbiAqXHJcbiAqICAgIC8vIFRoZSBzYWx0XHJcbiAqICAgIHNhbHQgPSBpZChcIkhlbGxvV29ybGRcIilcclxuICpcclxuICogICAgLy8gVGhlIGhhc2ggb2YgdGhlIGluaXRDb2RlXHJcbiAqICAgIGluaXRDb2RlID0gXCIweDYzOTQxOThkZjE2MDAwNTI2MTAzZmY2MDIwNjAwNDYwMWMzMzVhZmE2MDQwNTE2MDYwZjNcIjtcclxuICogICAgaW5pdENvZGVIYXNoID0ga2VjY2FrMjU2KGluaXRDb2RlKVxyXG4gKlxyXG4gKiAgICBnZXRDcmVhdGUyQWRkcmVzcyhmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2gpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhfZnJvbSwgX3NhbHQsIF9pbml0Q29kZUhhc2gpIHtcclxuICAgIGNvbnN0IGZyb20gPSBnZXRBZGRyZXNzKF9mcm9tKTtcclxuICAgIGNvbnN0IHNhbHQgPSBnZXRCeXRlcyhfc2FsdCwgXCJzYWx0XCIpO1xyXG4gICAgY29uc3QgaW5pdENvZGVIYXNoID0gZ2V0Qnl0ZXMoX2luaXRDb2RlSGFzaCwgXCJpbml0Q29kZUhhc2hcIik7XHJcbiAgICBhc3NlcnRBcmd1bWVudChzYWx0Lmxlbmd0aCA9PT0gMzIsIFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwic2FsdFwiLCBfc2FsdCk7XHJcbiAgICBhc3NlcnRBcmd1bWVudChpbml0Q29kZUhhc2gubGVuZ3RoID09PSAzMiwgXCJpbml0Q29kZUhhc2ggbXVzdCBiZSAzMiBieXRlc1wiLCBcImluaXRDb2RlSGFzaFwiLCBfaW5pdENvZGVIYXNoKTtcclxuICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtcIjB4ZmZcIiwgZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRyYWN0LWFkZHJlc3MuanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzcy5qc1wiO1xyXG4vKipcclxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gb2JqZWN0IHdoaWNoIGltcGxlbWVudHMgdGhlXHJcbiAqICBbW0FkZHJlc3NhYmxlXV0gaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIC8vIFdhbGxldHMgYW5kIEFic3RyYWN0U2lnbmVyIHN1Yi1jbGFzc2VzXHJcbiAqICAgIGlzQWRkcmVzc2FibGUoV2FsbGV0LmNyZWF0ZVJhbmRvbSgpKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIENvbnRyYWN0c1xyXG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChcImRhaS50b2tlbnMuZXRoZXJzLmV0aFwiLCBbIF0sIHByb3ZpZGVyKVxyXG4gKiAgICBpc0FkZHJlc3NhYmxlKGNvbnRyYWN0KVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzYWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIGFkZHJlc3MuXHJcbiAqXHJcbiAqICBAZXhhbXBsZTpcclxuICogICAgLy8gVmFsaWQgYWRkcmVzc1xyXG4gKiAgICBpc0FkZHJlc3MoXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICAvLyBWYWxpZCBJQ0FQIGFkZHJlc3NcclxuICogICAgaXNBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICAvLyBJbnZhbGlkIGNoZWNrc3VtXHJcbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQmE3MlwiKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIEludmFsaWQgSUNBUCBjaGVja3N1bVxyXG4gKiAgICBpc0FkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICAvLyBOb3QgYW4gYWRkcmVzcyAoYW4gRU5TIG5hbWUgcmVxdWlyZXMgYSBwcm92aWRlZCBhbmQgYW5cclxuICogICAgLy8gYXN5bmNocm9ub3VzIEFQSSB0byBhY2Nlc3MpXHJcbiAqICAgIGlzQWRkcmVzcyhcInJpY21vby5ldGhcIilcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyh2YWx1ZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBnZXRBZGRyZXNzKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gY2hlY2tBZGRyZXNzKHRhcmdldCwgcHJvbWlzZSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcclxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpIHtcclxuICAgICAgICBhc3NlcnQodHlwZW9mICh0YXJnZXQpICE9PSBcInN0cmluZ1wiLCBcInVuY29uZmlndXJlZCBuYW1lXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwgeyB2YWx1ZTogdGFyZ2V0IH0pO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQWRkcmVzc0xpa2UgdmFsdWU7IGRpZCBub3QgcmVzb2x2ZSB0byBhIHZhbHVlIGFkZHJlc3NcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRBZGRyZXNzKHJlc3VsdCk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXNvbHZlcyB0byBhbiBhZGRyZXNzIGZvciB0aGUgJSV0YXJnZXQlJSwgd2hpY2ggbWF5IGJlIGFueVxyXG4gKiAgc3VwcG9ydGVkIGFkZHJlc3MgdHlwZSwgYW4gW1tBZGRyZXNzYWJsZV1dIG9yIGEgUHJvbWlzZSB3aGljaFxyXG4gKiAgcmVzb2x2ZXMgdG8gYW4gYWRkcmVzcy5cclxuICpcclxuICogIElmIGFuIEVOUyBuYW1lIGlzIHByb3ZpZGVkLCBidXQgdGhhdCBuYW1lIGhhcyBub3QgYmVlbiBjb3JyZWN0bHlcclxuICogIGNvbmZpZ3VyZWQgYSBbW1VuY29uZmlndXJlZE5hbWVFcnJvcl1dIGlzIHRocm93bi5cclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICBhZGRyID0gXCIweDZCMTc1NDc0RTg5MDk0QzQ0RGE5OGI5NTRFZWRlQUM0OTUyNzFkMEZcIlxyXG4gKlxyXG4gKiAgICAvLyBBZGRyZXNzZXMgYXJlIHJldHVybiBzeW5jaHJvbm91c2x5XHJcbiAqICAgIHJlc29sdmVBZGRyZXNzKGFkZHIsIHByb3ZpZGVyKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIEFkZHJlc3MgcHJvbWlzZXMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XHJcbiAqICAgIHJlc29sdmVBZGRyZXNzKFByb21pc2UucmVzb2x2ZShhZGRyKSlcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICAvLyBFTlMgbmFtZXMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XHJcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIHByb3ZpZGVyKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIEFkZHJlc3NhYmxlIG9iamVjdHMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XHJcbiAqICAgIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHIsIFsgXSlcclxuICogICAgcmVzb2x2ZUFkZHJlc3MoY29udHJhY3QsIHByb3ZpZGVyKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIFVuY29uZmlndXJlZCBFTlMgbmFtZXMgcmVqZWN0XHJcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIiwgcHJvdmlkZXIpXHJcbiAqICAgIC8vX2Vycm9yOlxyXG4gKlxyXG4gKiAgICAvLyBFTlMgbmFtZXMgcmVxdWlyZSBhIE5hbWVSZXNvbHZlciBvYmplY3QgcGFzc2VkIGluXHJcbiAqICAgIC8vIChub3RpY2UgdGhlIHByb3ZpZGVyIHdhcyBvbWl0dGVkKVxyXG4gKiAgICByZXNvbHZlQWRkcmVzcyhcIm5vdGhpbmctaGVyZS5yaWNtb28uZXRoXCIpXHJcbiAqICAgIC8vX2Vycm9yOlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVBZGRyZXNzKHRhcmdldCwgcmVzb2x2ZXIpIHtcclxuICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoKC9eMHhbMC05YS1mXXs0MH0kL2kpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydChyZXNvbHZlciAhPSBudWxsLCBcIkVOUyByZXNvbHV0aW9uIHJlcXVpcmVzIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIiB9KTtcclxuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgcmVzb2x2ZXIucmVzb2x2ZU5hbWUodGFyZ2V0KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FkZHJlc3NhYmxlKHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgdGFyZ2V0LmdldEFkZHJlc3MoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mICh0YXJnZXQudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgYWRkcmVzc2FibGUgdmFsdWVcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIiwiLyoqXHJcbiAqICBBIFR5cGVkIG9iamVjdCBhbGxvd3MgYSB2YWx1ZSB0byBoYXZlIGl0cyB0eXBlIGV4cGxpY2l0bHlcclxuICogIHNwZWNpZmllZC5cclxuICpcclxuICogIEZvciBleGFtcGxlLCBpbiBTb2xpZGl0eSwgdGhlIHZhbHVlIGBgNDVgYCBjb3VsZCByZXByZXNlbnQgYVxyXG4gKiAgYGB1aW50OGBgIG9yIGEgYGB1aW50MjU2YGAuIFRoZSB2YWx1ZSBgYDB4MTIzNGBgIGNvdWxkIHJlcHJlc2VudFxyXG4gKiAgYSBgYGJ5dGVzMmBgIG9yIGBgYnl0ZXNgYC5cclxuICpcclxuICogIFNpbmNlIEphdmFTY3JpcHQgaGFzIG5vIG1lYW5pbmdmdWwgd2F5IHRvIGV4cGxpY2l0bHkgaW5mb3JtIGFueVxyXG4gKiAgQVBJcyB3aGljaCB3aGF0IHRoZSB0eXBlIGlzLCB0aGlzIGFsbG93cyB0cmFuc3BhcmVudCBpbnRlcm9wZXJhdGlvblxyXG4gKiAgd2l0aCBTb2xkaXR5LlxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvYWJpOlR5cGVkIFZhbHVlc1xyXG4gKi9cclxuaW1wb3J0IHsgYXNzZXJ0UHJpdmF0ZSwgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5jb25zdCBfZ2F1cmQgPSB7fTtcclxuZnVuY3Rpb24gbih2YWx1ZSwgd2lkdGgpIHtcclxuICAgIGxldCBzaWduZWQgPSBmYWxzZTtcclxuICAgIGlmICh3aWR0aCA8IDApIHtcclxuICAgICAgICBzaWduZWQgPSB0cnVlO1xyXG4gICAgICAgIHdpZHRoICo9IC0xO1xyXG4gICAgfVxyXG4gICAgLy8gQFRPRE86IENoZWNrIHJhbmdlIGlzIHZhbGlkIGZvciB2YWx1ZVxyXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGAke3NpZ25lZCA/IFwiXCIgOiBcInVcIn1pbnQke3dpZHRofWAsIHZhbHVlLCB7IHNpZ25lZCwgd2lkdGggfSk7XHJcbn1cclxuZnVuY3Rpb24gYih2YWx1ZSwgc2l6ZSkge1xyXG4gICAgLy8gQFRPRE86IENoZWNrIHJhbmdlIGlzIHZhbGlkIGZvciB2YWx1ZVxyXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGBieXRlcyR7KHNpemUpID8gc2l6ZSA6IFwiXCJ9YCwgdmFsdWUsIHsgc2l6ZSB9KTtcclxufVxyXG5jb25zdCBfdHlwZWRTeW1ib2wgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc190eXBlZFwiKTtcclxuLyoqXHJcbiAqICBUaGUgKipUeXBlZCoqIGNsYXNzIHRvIHdyYXAgdmFsdWVzIHByb3ZpZGluZyBleHBsaWNpdCB0eXBlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFR5cGVkIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0eXBlLCBhcyBhIFNvbGlkaXR5LWNvbXBhdGlibGUgdHlwZS5cclxuICAgICAqL1xyXG4gICAgdHlwZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBhY3R1YWwgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHZhbHVlO1xyXG4gICAgI29wdGlvbnM7XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgX3R5cGVkU3ltYm9sO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdhdXJkLCB0eXBlLCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydFByaXZhdGUoX2dhdXJkLCBnYXVyZCwgXCJUeXBlZFwiKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgX3R5cGVkU3ltYm9sLCB0eXBlLCB2YWx1ZSB9KTtcclxuICAgICAgICB0aGlzLiNvcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAvLyBDaGVjayB0aGUgdmFsdWUgaXMgdmFsaWRcclxuICAgICAgICB0aGlzLmZvcm1hdCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgRm9ybWF0IHRoZSB0eXBlIGFzIGEgSHVtYW4tUmVhZGFibGUgdHlwZS5cclxuICAgICAqL1xyXG4gICAgZm9ybWF0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwiYXJyYXlcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJkeW5hbWljQXJyYXlcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJ0dXBsZVwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgdHVwbGUoJHt0aGlzLnZhbHVlLm1hcCgodikgPT4gdi5mb3JtYXQoKSkuam9pbihcIixcIil9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSB0aGlzIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtaW5pbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxyXG4gICAgICovXHJcbiAgICBtaW5WYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxyXG4gICAgICovXHJcbiAgICBtYXhWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZEJpZ0ludF1dLlxyXG4gICAgICovXHJcbiAgICBpc0JpZ0ludCgpIHtcclxuICAgICAgICByZXR1cm4gISEodGhpcy50eXBlLm1hdGNoKC9edT9pbnRbMC05XSskLykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkRGF0YV1dLlxyXG4gICAgICovXHJcbiAgICBpc0RhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zdGFydHNXaXRoKFwiYnl0ZXNcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRTdHJpbmddXS5cclxuICAgICAqL1xyXG4gICAgaXNTdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IFwic3RyaW5nXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgdHVwbGUgbmFtZSwgaWYgdGhpcyBpcyBhIHR1cGxlLiBUaHJvd3Mgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBnZXQgdHVwbGVOYW1lKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwidHVwbGVcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJub3QgYSB0dXBsZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnM7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhpcyB0eXBlIGFzIGFuIGFycmF5XHJcbiAgICAvLyAtIGBudWxsYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyB1bmZvcmNlZCwgaXQgY291bGQgYmUgZHluYW1pY1xyXG4gICAgLy8gLSBgLTFgIGluZGljYXRlcyB0aGUgbGVuZ3RoIGlzIGR5bmFtaWNcclxuICAgIC8vIC0gYW55IG90aGVyIHZhbHVlIGluZGljYXRlcyBpdCBpcyBhIHN0YXRpYyBhcnJheSBhbmQgaXMgaXRzIGxlbmd0aFxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSB0eXBlIG9yIGBgLTFgYCBpZiBpdCBpcyBkeW5hbWljLlxyXG4gICAgICpcclxuICAgICAqICBUaHJvd3MgaWYgdGhlIHR5cGUgaXMgbm90IGFuIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBnZXQgYXJyYXlMZW5ndGgoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gXCJhcnJheVwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy4jb3B0aW9ucyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlKS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlR5cGVkKiogb2YgJSV0eXBlJSUgd2l0aCB0aGUgJSV2YWx1ZSUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbSh0eXBlLCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCB0eXBlLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDgodikgeyByZXR1cm4gbih2LCA4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MTYodikgeyByZXR1cm4gbih2LCAxNik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDI0KHYpIHsgcmV0dXJuIG4odiwgMjQpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MzJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQzMih2KSB7IHJldHVybiBuKHYsIDMyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDQwYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50NDAodikgeyByZXR1cm4gbih2LCA0MCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDQ4KHYpIHsgcmV0dXJuIG4odiwgNDgpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NTZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQ1Nih2KSB7IHJldHVybiBuKHYsIDU2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDY0YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50NjQodikgeyByZXR1cm4gbih2LCA2NCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDcyKHYpIHsgcmV0dXJuIG4odiwgNzIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODBgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQ4MCh2KSB7IHJldHVybiBuKHYsIDgwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDg4YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50ODgodikgeyByZXR1cm4gbih2LCA4OCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDk2KHYpIHsgcmV0dXJuIG4odiwgOTYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MTA0KHYpIHsgcmV0dXJuIG4odiwgMTA0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDExMmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDExMih2KSB7IHJldHVybiBuKHYsIDExMik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQxMjAodikgeyByZXR1cm4gbih2LCAxMjApOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MTI4KHYpIHsgcmV0dXJuIG4odiwgMTI4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEzNmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDEzNih2KSB7IHJldHVybiBuKHYsIDEzNik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQxNDQodikgeyByZXR1cm4gbih2LCAxNDQpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTUyYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MTUyKHYpIHsgcmV0dXJuIG4odiwgMTUyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2MGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDE2MCh2KSB7IHJldHVybiBuKHYsIDE2MCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQxNjgodikgeyByZXR1cm4gbih2LCAxNjgpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTc2YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MTc2KHYpIHsgcmV0dXJuIG4odiwgMTc2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE4NGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDE4NCh2KSB7IHJldHVybiBuKHYsIDE4NCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxOTJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQxOTIodikgeyByZXR1cm4gbih2LCAxOTIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MjAwKHYpIHsgcmV0dXJuIG4odiwgMjAwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwOGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDIwOCh2KSB7IHJldHVybiBuKHYsIDIwOCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQyMTYodikgeyByZXR1cm4gbih2LCAyMTYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MjI0KHYpIHsgcmV0dXJuIG4odiwgMjI0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIzMmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDIzMih2KSB7IHJldHVybiBuKHYsIDIzMik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQyNDAodikgeyByZXR1cm4gbih2LCAyNDApOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1aW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgMjQ4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI1NmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdWludDI1Nih2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVpbnQodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQ4KHYpIHsgcmV0dXJuIG4odiwgLTgpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MTYodikgeyByZXR1cm4gbih2LCAtMTYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MjQodikgeyByZXR1cm4gbih2LCAtMjQpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQzMmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MzIodikgeyByZXR1cm4gbih2LCAtMzIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0MGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50NDAodikgeyByZXR1cm4gbih2LCAtNDApOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50NDgodikgeyByZXR1cm4gbih2LCAtNDgpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1NmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50NTYodikgeyByZXR1cm4gbih2LCAtNTYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ2NGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50NjQodikgeyByZXR1cm4gbih2LCAtNjQpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50NzIodikgeyByZXR1cm4gbih2LCAtNzIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4MGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50ODAodikgeyByZXR1cm4gbih2LCAtODApOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4OGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50ODgodikgeyByZXR1cm4gbih2LCAtODgpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50OTYodikgeyByZXR1cm4gbih2LCAtOTYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMDRgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDEwNCh2KSB7IHJldHVybiBuKHYsIC0xMDQpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMTJgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDExMih2KSB7IHJldHVybiBuKHYsIC0xMTIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDEyMCh2KSB7IHJldHVybiBuKHYsIC0xMjApOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjhgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDEyOCh2KSB7IHJldHVybiBuKHYsIC0xMjgpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMzZgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDEzNih2KSB7IHJldHVybiBuKHYsIC0xMzYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGludDE0NCh2KSB7IHJldHVybiBuKHYsIC0xNDQpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1MmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MTUyKHYpIHsgcmV0dXJuIG4odiwgLTE1Mik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2MGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MTYwKHYpIHsgcmV0dXJuIG4odiwgLTE2MCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2OGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MTY4KHYpIHsgcmV0dXJuIG4odiwgLTE2OCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE3NmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MTc2KHYpIHsgcmV0dXJuIG4odiwgLTE3Nik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE4NGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50MTg0KHYpIHsgcmV0dXJuIG4odiwgLTE4NCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDkyYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQxOTIodikgeyByZXR1cm4gbih2LCAtMTkyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQyMDAodikgeyByZXR1cm4gbih2LCAtMjAwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjA4YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQyMDgodikgeyByZXR1cm4gbih2LCAtMjA4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQyMTYodikgeyByZXR1cm4gbih2LCAtMjE2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQyMjQodikgeyByZXR1cm4gbih2LCAtMjI0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjMyYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQyMzIodikgeyByZXR1cm4gbih2LCAtMjMyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQyNDAodikgeyByZXR1cm4gbih2LCAtMjQwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQyNDgodikgeyByZXR1cm4gbih2LCAtMjQ4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQyNTYodikgeyByZXR1cm4gbih2LCAtMjU2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnQodikgeyByZXR1cm4gbih2LCAtMjU2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBieXRlczEodikgeyByZXR1cm4gYih2LCAxKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBieXRlczIodikgeyByZXR1cm4gYih2LCAyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBieXRlczModikgeyByZXR1cm4gYih2LCAzKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM0YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBieXRlczQodikgeyByZXR1cm4gYih2LCA0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM1YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBieXRlczUodikgeyByZXR1cm4gYih2LCA1KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM2YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBieXRlczYodikgeyByZXR1cm4gYih2LCA2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM3YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBieXRlczcodikgeyByZXR1cm4gYih2LCA3KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM4YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBieXRlczgodikgeyByZXR1cm4gYih2LCA4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM5YGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBieXRlczkodikgeyByZXR1cm4gYih2LCA5KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMxMCh2KSB7IHJldHVybiBiKHYsIDEwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMWBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMxMSh2KSB7IHJldHVybiBiKHYsIDExKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMxMih2KSB7IHJldHVybiBiKHYsIDEyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxM2BgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMxMyh2KSB7IHJldHVybiBiKHYsIDEzKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMxNCh2KSB7IHJldHVybiBiKHYsIDE0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNWBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMxNSh2KSB7IHJldHVybiBiKHYsIDE1KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMxNih2KSB7IHJldHVybiBiKHYsIDE2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxN2BgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMxNyh2KSB7IHJldHVybiBiKHYsIDE3KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMxOCh2KSB7IHJldHVybiBiKHYsIDE4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOWBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMxOSh2KSB7IHJldHVybiBiKHYsIDE5KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMyMCh2KSB7IHJldHVybiBiKHYsIDIwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMWBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMyMSh2KSB7IHJldHVybiBiKHYsIDIxKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMyMih2KSB7IHJldHVybiBiKHYsIDIyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyM2BgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMyMyh2KSB7IHJldHVybiBiKHYsIDIzKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMyNCh2KSB7IHJldHVybiBiKHYsIDI0KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNWBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMyNSh2KSB7IHJldHVybiBiKHYsIDI1KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMyNih2KSB7IHJldHVybiBiKHYsIDI2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyN2BgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMyNyh2KSB7IHJldHVybiBiKHYsIDI3KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyOGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMyOCh2KSB7IHJldHVybiBiKHYsIDI4KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyOWBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMyOSh2KSB7IHJldHVybiBiKHYsIDI5KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMGBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMzMCh2KSB7IHJldHVybiBiKHYsIDMwKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMWBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMzMSh2KSB7IHJldHVybiBiKHYsIDMxKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMmBgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXMzMih2KSB7IHJldHVybiBiKHYsIDMyKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYWRkcmVzc2BgIHR5cGUgZm9yICUldiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYWRkcmVzcyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImFkZHJlc3NcIiwgdik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJvb2xgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJvb2wodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJib29sXCIsICEhdik7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzYGAgdHlwZSBmb3IgJSV2JSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBieXRlcyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImJ5dGVzXCIsIHYpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBzdHJpbmdgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHN0cmluZyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInN0cmluZ1wiLCB2KTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYXJyYXlgYCB0eXBlIGZvciAlJXYlJSwgYWxsb3dpbmcgJSVkeW5hbWljJSUgbGVuZ3RoLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXJyYXkodiwgZHluYW1pYykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYXJyYXlcIiwgdiwgZHluYW1pYyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB0dXBsZWBgIHR5cGUgZm9yICUldiUlLCB3aXRoIHRoZSBvcHRpb25hbCAlJW5hbWUlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHR1cGxlKHYsIG5hbWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInR1cGxlXCIsIHYsIG5hbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG92ZXJyaWRlcyh2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwib3ZlcnJpZGVzXCIsIE9iamVjdC5hc3NpZ24oe30sIHYpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmICUldmFsdWUlJSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzVHlwZWQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlXHJcbiAgICAgICAgICAgICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiXHJcbiAgICAgICAgICAgICYmIFwiX3R5cGVkU3ltYm9sXCIgaW4gdmFsdWVcclxuICAgICAgICAgICAgJiYgdmFsdWUuX3R5cGVkU3ltYm9sID09PSBfdHlwZWRTeW1ib2wpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgSWYgdGhlIHZhbHVlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLCB2YWxpZGF0ZXMgdGhlIHVuZGVybHlpbmcgdmFsdWVcclxuICAgICAqICBhbmQgcmV0dXJucyBpdCwgb3RoZXJ3aXNlIHJldHVybnMgdmFsdWUgZGlyZWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciBmdW5jdGlvbnMgdGhhdCB3aXRoIHRvIGFjY2VwdCBlaXRoZXIgYSBbW1R5cGVkXV1cclxuICAgICAqICBvYmplY3Qgb3IgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpIHtcclxuICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlOiBleHBlY2V0ZCAke3R5cGV9LCBnb3QgJHt2YWx1ZS50eXBlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLmpzLm1hcCIsImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyB0b0JlSGV4IH0gZnJvbSBcIi4uLy4uL3V0aWxzL21hdGhzLmpzXCI7XHJcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XHJcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcclxuLyoqXHJcbiAqICBAX2lnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFkZHJlc3NDb2RlciBleHRlbmRzIENvZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xyXG4gICAgICAgIHN1cGVyKFwiYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCBfdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZGVjb2RlKHJlYWRlcikge1xyXG4gICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHRvQmVIZXgocmVhZGVyLnJlYWRWYWx1ZSgpLCAyMCkpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIiwiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xyXG4vKipcclxuICogIENsb25lcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhbiBleGlzdGluZyBDb2RlciwgYnV0IHdpdGhvdXQgYSBsb2NhbE5hbWVcclxuICpcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XHJcbiAgICBjb2RlcjtcclxuICAgIGNvbnN0cnVjdG9yKGNvZGVyKSB7XHJcbiAgICAgICAgc3VwZXIoY29kZXIubmFtZSwgY29kZXIudHlwZSwgXCJfXCIsIGNvZGVyLmR5bmFtaWMpO1xyXG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcclxuICAgIH1cclxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcclxuICAgIH1cclxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZGVjb2RlKHJlYWRlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFub255bW91cy5qcy5tYXAiLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRBcmd1bWVudENvdW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XHJcbmltcG9ydCB7IENvZGVyLCBSZXN1bHQsIFdvcmRTaXplLCBXcml0ZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xyXG5pbXBvcnQgeyBBbm9ueW1vdXNDb2RlciB9IGZyb20gXCIuL2Fub255bW91cy5qc1wiO1xyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWVzKSB7XHJcbiAgICBsZXQgYXJyYXlWYWx1ZXMgPSBbXTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcclxuICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBsZXQgdW5pcXVlID0ge307XHJcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSBjb2RlcnMubWFwKChjb2RlcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xyXG4gICAgICAgICAgICBhc3NlcnQobmFtZSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggbWlzc2luZyBuYW1lc1wiLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogXCJ2YWx1ZXNcIiwgaW5mbzogeyBjb2RlciB9LCB2YWx1ZTogdmFsdWVzIH0pO1xyXG4gICAgICAgICAgICBhc3NlcnQoIXVuaXF1ZVtuYW1lXSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggZHVwbGljYXRlIG5hbWVzXCIsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBcInZhbHVlc1wiLCBpbmZvOiB7IGNvZGVyIH0sIHZhbHVlOiB2YWx1ZXMgfSk7XHJcbiAgICAgICAgICAgIHVuaXF1ZVtuYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbbmFtZV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KGNvZGVycy5sZW5ndGggPT09IGFycmF5VmFsdWVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZSBsZW5ndGggbWlzbWF0Y2hcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xyXG4gICAgbGV0IHN0YXRpY1dyaXRlciA9IG5ldyBXcml0ZXIoKTtcclxuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xyXG4gICAgbGV0IHVwZGF0ZUZ1bmNzID0gW107XHJcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xyXG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGR5bmFtaWMgb2Zmc2V0IChmb3IgdGhlIGZ1dHVyZSBwb2ludGVyKVxyXG4gICAgICAgICAgICBsZXQgZHluYW1pY09mZnNldCA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIGR5bmFtaWMgdmFsdWUgaW50byB0aGUgZHluYW1pY1dyaXRlclxyXG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoZHluYW1pY1dyaXRlciwgdmFsdWUpO1xyXG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXHJcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jID0gc3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTtcclxuICAgICAgICAgICAgdXBkYXRlRnVuY3MucHVzaCgoYmFzZU9mZnNldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29kZXIuZW5jb2RlKHN0YXRpY1dyaXRlciwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8gQmFja2ZpbGwgYWxsIHRoZSBkeW5hbWljIG9mZnNldHMsIG5vdyB0aGF0IHdlIGtub3cgdGhlIHN0YXRpYyBsZW5ndGhcclxuICAgIHVwZGF0ZUZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHsgZnVuYyhzdGF0aWNXcml0ZXIubGVuZ3RoKTsgfSk7XHJcbiAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xyXG4gICAgbGVuZ3RoICs9IHdyaXRlci5hcHBlbmRXcml0ZXIoZHluYW1pY1dyaXRlcik7XHJcbiAgICByZXR1cm4gbGVuZ3RoO1xyXG59XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2socmVhZGVyLCBjb2RlcnMpIHtcclxuICAgIGxldCB2YWx1ZXMgPSBbXTtcclxuICAgIGxldCBrZXlzID0gW107XHJcbiAgICAvLyBBIHJlYWRlciBhbmNob3JlZCB0byB0aGlzIGJhc2VcclxuICAgIGxldCBiYXNlUmVhZGVyID0gcmVhZGVyLnN1YlJlYWRlcigwKTtcclxuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcclxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcclxuICAgICAgICAgICAgbGV0IG9mZnNldFJlYWRlciA9IGJhc2VSZWFkZXIuc3ViUmVhZGVyKG9mZnNldCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcclxuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcclxuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJVRkZFUl9PVkVSUlVOXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcclxuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52ZXN0aWdhdGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICBrZXlzLnB1c2goY29kZXIubG9jYWxOYW1lIHx8IG51bGwpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xyXG59XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgQ29kZXIge1xyXG4gICAgY29kZXI7XHJcbiAgICBsZW5ndGg7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gKGNvZGVyLnR5cGUgKyBcIltcIiArIChsZW5ndGggPj0gMCA/IGxlbmd0aCA6IFwiXCIpICsgXCJdXCIpO1xyXG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSAobGVuZ3RoID09PSAtMSB8fCBjb2Rlci5keW5hbWljKTtcclxuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyLCBsZW5ndGggfSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgLy8gVmVyaWZpZXMgdGhlIGNoaWxkIGNvZGVyIGlzIHZhbGlkIChldmVuIGlmIHRoZSBhcnJheSBpcyBkeW5hbWljIG9yIDAtbGVuZ3RoKVxyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDaGlsZCA9IHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlZmF1bHRDaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJhcnJheVwiKTtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50Q291bnQodmFsdWUubGVuZ3RoLCBjb3VudCwgXCJjb2RlciBhcnJheVwiICsgKHRoaXMubG9jYWxOYW1lID8gKFwiIFwiICsgdGhpcy5sb2NhbE5hbWUpIDogXCJcIikpO1xyXG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKHRoaXMuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZGVjb2RlKHJlYWRlcikge1xyXG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgY291bnQgPSByZWFkZXIucmVhZEluZGV4KCk7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgKnJvdWdobHkqIGVub3VnaCBkYXRhIHRvIGVuc3VyZVxyXG4gICAgICAgICAgICAvLyBzdHJheSByYW5kb20gZGF0YSBpcyBub3QgYmVpbmcgcmVhZCBhcyBhIGxlbmd0aC4gRWFjaFxyXG4gICAgICAgICAgICAvLyBzbG90IHJlcXVpcmVzIGF0IGxlYXN0IDMyIGJ5dGVzIGZvciB0aGVpciB2YWx1ZSAob3IgMzJcclxuICAgICAgICAgICAgLy8gYnl0ZXMgYXMgYSBsaW5rIHRvIHRoZSBkYXRhKS4gVGhpcyBjb3VsZCB1c2UgYSBtdWNoXHJcbiAgICAgICAgICAgIC8vIHRpZ2h0ZXIgYm91bmQsIGJ1dCB3ZSBhcmUgZXJyb3Jpbmcgb24gdGhlIHNpZGUgb2Ygc2FmZXR5LlxyXG4gICAgICAgICAgICBhc3NlcnQoY291bnQgKiBXb3JkU2l6ZSA8PSByZWFkZXIuZGF0YUxlbmd0aCwgXCJpbnN1ZmZpY2llbnQgZGF0YSBsZW5ndGhcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7IGJ1ZmZlcjogcmVhZGVyLmJ5dGVzLCBvZmZzZXQ6IGNvdW50ICogV29yZFNpemUsIGxlbmd0aDogcmVhZGVyLmRhdGFMZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IEFub255bW91c0NvZGVyKHRoaXMuY29kZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIGNvZGVycyk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIiwiaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcclxuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQm9vbGVhbkNvZGVyIGV4dGVuZHMgQ29kZXIge1xyXG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XHJcbiAgICAgICAgc3VwZXIoXCJib29sXCIsIFwiYm9vbFwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJib29sXCIpO1xyXG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcclxuICAgIH1cclxuICAgIGRlY29kZShyZWFkZXIpIHtcclxuICAgICAgICByZXR1cm4gISFyZWFkZXIucmVhZFZhbHVlKCk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbGVhbi5qcy5tYXAiLCJpbXBvcnQgeyBnZXRCeXRlc0NvcHksIGhleGxpZnkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRHluYW1pY0J5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsb2NhbE5hbWUpIHtcclxuICAgICAgICBzdXBlcih0eXBlLCB0eXBlLCBsb2NhbE5hbWUsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZGVmYXVsdFZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiBcIjB4XCI7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhbHVlID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcclxuICAgICAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcclxuICAgICAgICBsZW5ndGggKz0gd3JpdGVyLndyaXRlQnl0ZXModmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICBkZWNvZGUocmVhZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRJbmRleCgpLCB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQnl0ZXNDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xyXG4gICAgICAgIHN1cGVyKFwiYnl0ZXNcIiwgbG9jYWxOYW1lKTtcclxuICAgIH1cclxuICAgIGRlY29kZShyZWFkZXIpIHtcclxuICAgICAgICByZXR1cm4gaGV4bGlmeShzdXBlci5kZWNvZGUocmVhZGVyKSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XHJcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcclxuLyoqXHJcbiAqICBAX2lnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZpeGVkQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcclxuICAgIHNpemU7XHJcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBsb2NhbE5hbWUpIHtcclxuICAgICAgICBsZXQgbmFtZSA9IFwiYnl0ZXNcIiArIFN0cmluZyhzaXplKTtcclxuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgc2l6ZSB9LCB7IHNpemU6IFwibnVtYmVyXCIgfSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKS5zdWJzdHJpbmcoMCwgMiArIHRoaXMuc2l6ZSAqIDIpO1xyXG4gICAgfVxyXG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBnZXRCeXRlc0NvcHkoVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCB0aGlzLnR5cGUpKTtcclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsIF92YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhkYXRhKTtcclxuICAgIH1cclxuICAgIGRlY29kZShyZWFkZXIpIHtcclxuICAgICAgICByZXR1cm4gaGV4bGlmeShyZWFkZXIucmVhZEJ5dGVzKHRoaXMuc2l6ZSkpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkLWJ5dGVzLmpzLm1hcCIsImltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcclxuY29uc3QgRW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBOdWxsQ29kZXIgZXh0ZW5kcyBDb2RlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcclxuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJub3QgbnVsbFwiLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhFbXB0eSk7XHJcbiAgICB9XHJcbiAgICBkZWNvZGUocmVhZGVyKSB7XHJcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGZyb21Ud29zLCBnZXRCaWdJbnQsIG1hc2ssIHRvVHdvcyB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xyXG5pbXBvcnQgeyBDb2RlciwgV29yZFNpemUgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xyXG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xyXG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xyXG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcclxuLyoqXHJcbiAqICBAX2lnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE51bWJlckNvZGVyIGV4dGVuZHMgQ29kZXIge1xyXG4gICAgc2l6ZTtcclxuICAgIHNpZ25lZDtcclxuICAgIGNvbnN0cnVjdG9yKHNpemUsIHNpZ25lZCwgbG9jYWxOYW1lKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9ICgoc2lnbmVkID8gXCJpbnRcIiA6IFwidWludFwiKSArIChzaXplICogOCkpO1xyXG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBzaXplLCBzaWduZWQgfSwgeyBzaXplOiBcIm51bWJlclwiLCBzaWduZWQ6IFwiYm9vbGVhblwiIH0pO1xyXG4gICAgfVxyXG4gICAgZGVmYXVsdFZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRzIGFyZSBzYWZlIGZvciBlbmNvZGluZ1xyXG4gICAgICAgIGxldCBtYXhVaW50VmFsdWUgPSBtYXNrKEJOX01BWF9VSU5UMjU2LCBXb3JkU2l6ZSAqIDgpO1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xyXG4gICAgICAgICAgICBsZXQgYm91bmRzID0gbWFzayhtYXhVaW50VmFsdWUsICh0aGlzLnNpemUgKiA4KSAtIDEpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPiBib3VuZHMgfHwgdmFsdWUgPCAtKGJvdW5kcyArIEJOXzEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlID0gdG9Ud29zKHZhbHVlLCA4ICogV29yZFNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IEJOXzAgfHwgdmFsdWUgPiBtYXNrKG1heFVpbnRWYWx1ZSwgdGhpcy5zaXplICogOCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgX3ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGRlY29kZShyZWFkZXIpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBtYXNrKHJlYWRlci5yZWFkVmFsdWUoKSwgdGhpcy5zaXplICogOCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbVR3b3ModmFsdWUsIHRoaXMuc2l6ZSAqIDgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCIsImltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRmOC5qc1wiO1xyXG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xyXG5pbXBvcnQgeyBEeW5hbWljQnl0ZXNDb2RlciB9IGZyb20gXCIuL2J5dGVzLmpzXCI7XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xyXG4gICAgICAgIHN1cGVyKFwic3RyaW5nXCIsIGxvY2FsTmFtZSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZW5jb2RlKHdyaXRlciwgdG9VdGY4Qnl0ZXMoVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKSkpO1xyXG4gICAgfVxyXG4gICAgZGVjb2RlKHJlYWRlcikge1xyXG4gICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXAiLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3Byb3BlcnRpZXMuanNcIjtcclxuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcclxuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xyXG5pbXBvcnQgeyBwYWNrLCB1bnBhY2sgfSBmcm9tIFwiLi9hcnJheS5qc1wiO1xyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHVwbGVDb2RlciBleHRlbmRzIENvZGVyIHtcclxuICAgIGNvZGVycztcclxuICAgIGNvbnN0cnVjdG9yKGNvZGVycywgbG9jYWxOYW1lKSB7XHJcbiAgICAgICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xyXG4gICAgICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xyXG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHlwZXMucHVzaChjb2Rlci50eXBlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB0eXBlID0gKFwidHVwbGUoXCIgKyB0eXBlcy5qb2luKFwiLFwiKSArIFwiKVwiKTtcclxuICAgICAgICBzdXBlcihcInR1cGxlXCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyczogT2JqZWN0LmZyZWV6ZShjb2RlcnMuc2xpY2UoKSkgfSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2goY29kZXIuZGVmYXVsdFZhbHVlKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xyXG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gdGhpcy5jb2RlcnMucmVkdWNlKChhY2N1bSwgY29kZXIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcclxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYWNjdW1bbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgLy8gQWRkIG5hbWVkIHZhbHVlc1xyXG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcclxuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJ0dXBsZVwiKTtcclxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBkZWNvZGUocmVhZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIHRoaXMuY29kZXJzKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLCBzdG9yYWdlS2V5cykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGFkZHIpLFxyXG4gICAgICAgIHN0b3JhZ2VLZXlzOiBzdG9yYWdlS2V5cy5tYXAoKHN0b3JhZ2VLZXksIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHN0b3JhZ2VLZXksIDMyKSwgXCJpbnZhbGlkIHNsb3RcIiwgYHN0b3JhZ2VLZXlzWyR7aW5kZXh9XWAsIHN0b3JhZ2VLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZUtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyBhIFtbQWNjZXNzTGlzdF1dIGZyb20gYW55IGV0aGVycy1zdXBwb3J0ZWQgYWNjZXNzLWxpc3Qgc3RydWN0dXJlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFjY2Vzc0xpc3RpZnkodmFsdWUpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHNldCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0Lmxlbmd0aCA9PT0gMiwgXCJpbnZhbGlkIHNsb3Qgc2V0XCIsIGB2YWx1ZVske2luZGV4fV1gLCBzZXQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXRbMF0sIHNldFsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0ICE9IG51bGwgJiYgdHlwZW9mIChzZXQpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWRkcmVzcy1zbG90IHNldFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlICE9IG51bGwgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBhY2Nlc3MgbGlzdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGFkZHIpID0+IHtcclxuICAgICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHZhbHVlW2FkZHJdLnJlZHVjZSgoYWNjdW0sIHN0b3JhZ2VLZXkpID0+IHtcclxuICAgICAgICAgICAgYWNjdW1bc3RvcmFnZUtleV0gPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoYWRkciwgT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSk7XHJcbiAgICB9KTtcclxuICAgIHJlc3VsdC5zb3J0KChhLCBiKSA9PiAoYS5hZGRyZXNzLmxvY2FsZUNvbXBhcmUoYi5hZGRyZXNzKSkpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3NsaXN0LmpzLm1hcCIsImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGdldEJpZ0ludCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5leHBvcnQgZnVuY3Rpb24gYXV0aG9yaXphdGlvbmlmeShhdXRoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYXV0aC5hZGRyZXNzKSxcclxuICAgICAgICBub25jZTogZ2V0QmlnSW50KChhdXRoLm5vbmNlICE9IG51bGwpID8gYXV0aC5ub25jZSA6IDApLFxyXG4gICAgICAgIGNoYWluSWQ6IGdldEJpZ0ludCgoYXV0aC5jaGFpbklkICE9IG51bGwpID8gYXV0aC5jaGFpbklkIDogMCksXHJcbiAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbShhdXRoLnNpZ25hdHVyZSlcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aG9yaXphdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsga2VjY2FrMjU2LCBTaWduaW5nS2V5IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG4vKipcclxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgZm9yIHRoZSAlJWtleSUlLlxyXG4gKlxyXG4gKiAgVGhlIGtleSBtYXkgYmUgYW55IHN0YW5kYXJkIGZvcm0gb2YgcHVibGljIGtleSBvciBhIHByaXZhdGUga2V5LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGtleSkge1xyXG4gICAgbGV0IHB1YmtleTtcclxuICAgIGlmICh0eXBlb2YgKGtleSkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBwdWJrZXkgPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoa2V5LCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwdWJrZXkgPSBrZXkucHVibGljS2V5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEFkZHJlc3Moa2VjY2FrMjU2KFwiMHhcIiArIHB1YmtleS5zdWJzdHJpbmcoNCkpLnN1YnN0cmluZygyNikpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0aGUgcmVjb3ZlcmVkIGFkZHJlc3MgZm9yIHRoZSBwcml2YXRlIGtleSB0aGF0IHdhc1xyXG4gKiAgdXNlZCB0byBzaWduICUlZGlnZXN0JSUgdGhhdCByZXN1bHRlZCBpbiAlJXNpZ25hdHVyZSUlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgc2lnbmF0dXJlKSB7XHJcbiAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MoU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2FkZHJlc3Nlcy5qc1wiO1xyXG5pbXBvcnQgeyBrZWNjYWsyNTYsIHNoYTI1NiwgU2lnbmF0dXJlLCBTaWduaW5nS2V5IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBjb25jYXQsIGRlY29kZVJscCwgZW5jb2RlUmxwLCBnZXRCeXRlcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzQnl0ZXNMaWtlLCBpc0hleFN0cmluZywgdG9CZUFycmF5LCB6ZXJvUGFkVmFsdWUgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuL2FjY2Vzc2xpc3QuanNcIjtcclxuaW1wb3J0IHsgYXV0aG9yaXphdGlvbmlmeSB9IGZyb20gXCIuL2F1dGhvcml6YXRpb24uanNcIjtcclxuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XHJcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XHJcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XHJcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcclxuY29uc3QgQk5fMjggPSBCaWdJbnQoMjgpO1xyXG5jb25zdCBCTl8zNSA9IEJpZ0ludCgzNSk7XHJcbmNvbnN0IEJOX01BWF9VSU5UID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xyXG5jb25zdCBCTE9CX1NJWkUgPSA0MDk2ICogMzI7XHJcbmZ1bmN0aW9uIGdldEt6Z0xpYnJhcnkoa3pnKSB7XHJcbiAgICBjb25zdCBibG9iVG9LemdDb21taXRtZW50ID0gKGJsb2IpID0+IHtcclxuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYlByb29mXCIgaW4ga3pnKSB7XHJcbiAgICAgICAgICAgIC8vIG1pY3JvLWVjYy1zaWduZXI7IGNoZWNrIGZvciBjb21wdXRlQmxvYlByb29mIHNpbmNlIHRoaXMgQVBJXHJcbiAgICAgICAgICAgIC8vIGV4cGVjdHMgYSBzdHJpbmcgd2hpbGUgdGhlIGt6Zy13YXNtIGJlbG93IGV4cGVjdHMgYSBVbml0OEFycmF5XHJcbiAgICAgICAgICAgIGlmIChcImJsb2JUb0t6Z0NvbW1pdG1lbnRcIiBpbiBremcgJiYgdHlwZW9mIChremcuYmxvYlRvS3pnQ29tbWl0bWVudCkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KGhleGxpZnkoYmxvYikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcImJsb2JUb0t6Z0NvbW1pdG1lbnRcIiBpbiBremcgJiYgdHlwZW9mIChremcuYmxvYlRvS3pnQ29tbWl0bWVudCkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAvLyBremctd2FzbSA8MC41LjA7IGJsb2JUb0t6Z0NvbW1pdG1lbnQoVWludDhBcnJheSkgPT4gVWludDhBcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQoYmxvYikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBremctd2FzbSA+PSAwLjUuMDsgYmxvYlRvS1pHQ29tbWl0bWVudChzdHJpbmcpID0+IHN0cmluZ1xyXG4gICAgICAgIGlmIChcImJsb2JUb0taR0NvbW1pdG1lbnRcIiBpbiBremcgJiYgdHlwZW9mIChremcuYmxvYlRvS1pHQ29tbWl0bWVudCkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmJsb2JUb0taR0NvbW1pdG1lbnQoaGV4bGlmeShibG9iKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBLWkcgbGlicmFyeVwiLCBcImt6Z1wiLCBremcpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGNvbXB1dGVCbG9iS3pnUHJvb2YgPSAoYmxvYiwgY29tbWl0bWVudCkgPT4ge1xyXG4gICAgICAgIC8vIG1pY3JvLWVjYy1zaWduZXJcclxuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYlByb29mXCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmNvbXB1dGVCbG9iUHJvb2YpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5jb21wdXRlQmxvYlByb29mKGhleGxpZnkoYmxvYiksIGhleGxpZnkoY29tbWl0bWVudCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8ga3pnLXdhc20gPDAuNS4wOyBjb21wdXRlQmxvYkt6Z1Byb29mKFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXlcclxuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYkt6Z1Byb29mXCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmNvbXB1dGVCbG9iS3pnUHJvb2YpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGt6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKGJsb2IsIGNvbW1pdG1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBremctd2FzbSA+PSAwLjUuMDsgY29tcHV0ZUJsb2JLWkdQcm9vZihzdHJpbmcsIHN0cmluZykgPT4gc3RyaW5nXHJcbiAgICAgICAgaWYgKFwiY29tcHV0ZUJsb2JLWkdQcm9vZlwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5jb21wdXRlQmxvYktaR1Byb29mKSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuY29tcHV0ZUJsb2JLWkdQcm9vZihoZXhsaWZ5KGJsb2IpLCBoZXhsaWZ5KGNvbW1pdG1lbnQpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIEtaRyBsaWJyYXJ5XCIsIFwia3pnXCIsIGt6Zyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHsgYmxvYlRvS3pnQ29tbWl0bWVudCwgY29tcHV0ZUJsb2JLemdQcm9vZiB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFZlcnNpb25lZEhhc2godmVyc2lvbiwgaGFzaCkge1xyXG4gICAgbGV0IHZlcnNpb25lZCA9IHZlcnNpb24udG9TdHJpbmcoMTYpO1xyXG4gICAgd2hpbGUgKHZlcnNpb25lZC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgdmVyc2lvbmVkID0gXCIwXCIgKyB2ZXJzaW9uZWQ7XHJcbiAgICB9XHJcbiAgICB2ZXJzaW9uZWQgKz0gc2hhMjU2KGhhc2gpLnN1YnN0cmluZyg0KTtcclxuICAgIHJldHVybiBcIjB4XCIgKyB2ZXJzaW9uZWQ7XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlQWRkcmVzcyh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVBY2Nlc3NMaXN0KHZhbHVlLCBwYXJhbSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgZXJyb3IubWVzc2FnZSwgcGFyYW0sIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYW5kbGVBdXRob3JpemF0aW9uTGlzdCh2YWx1ZSwgcGFyYW0pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdXRob3JpemF0aW9uTGlzdDogaW52YWxpZCBhcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBhdXRoID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhdXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdXRob3JpemF0aW9uWyR7aX1dOiBpbnZhbGlkIGFycmF5YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGF1dGgubGVuZ3RoICE9PSA2KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF1dGhvcml6YXRpb25bJHtpfV06IHdyb25nIGxlbmd0aGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghYXV0aFsxXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdXRob3JpemF0aW9uWyR7aX1dOiBudWxsIGFkZHJlc3NgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBoYW5kbGVBZGRyZXNzKGF1dGhbMV0pLFxyXG4gICAgICAgICAgICAgICAgbm9uY2U6IGhhbmRsZVVpbnQoYXV0aFsyXSwgXCJub25jZVwiKSxcclxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoYXV0aFswXSwgXCJjaGFpbklkXCIpLFxyXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbSh7XHJcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eTogaGFuZGxlTnVtYmVyKGF1dGhbM10sIFwieVBhcml0eVwiKSxcclxuICAgICAgICAgICAgICAgICAgICByOiB6ZXJvUGFkVmFsdWUoYXV0aFs0XSwgMzIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHM6IHplcm9QYWRWYWx1ZShhdXRoWzVdLCAzMilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIHBhcmFtLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlTnVtYmVyKF92YWx1ZSwgcGFyYW0pIHtcclxuICAgIGlmIChfdmFsdWUgPT09IFwiMHhcIikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldE51bWJlcihfdmFsdWUsIHBhcmFtKTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVVaW50KF92YWx1ZSwgcGFyYW0pIHtcclxuICAgIGlmIChfdmFsdWUgPT09IFwiMHhcIikge1xyXG4gICAgICAgIHJldHVybiBCTl8wO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBwYXJhbSk7XHJcbiAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA8PSBCTl9NQVhfVUlOVCwgXCJ2YWx1ZSBleGNlZWRzIHVpbnQgc2l6ZVwiLCBwYXJhbSwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihfdmFsdWUsIG5hbWUpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRvQmVBcnJheSh2YWx1ZSk7XHJcbiAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQubGVuZ3RoIDw9IDMyLCBgdmFsdWUgdG9vIGxhcmdlYCwgYHR4LiR7bmFtZX1gLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdEFjY2Vzc0xpc3QodmFsdWUpIHtcclxuICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKS5tYXAoKHNldCkgPT4gW3NldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXNdKTtcclxufVxyXG5mdW5jdGlvbiBmb3JtYXRBdXRob3JpemF0aW9uTGlzdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlLm1hcCgoYSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGZvcm1hdE51bWJlcihhLmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcclxuICAgICAgICAgICAgYS5hZGRyZXNzLFxyXG4gICAgICAgICAgICBmb3JtYXROdW1iZXIoYS5ub25jZSwgXCJub25jZVwiKSxcclxuICAgICAgICAgICAgZm9ybWF0TnVtYmVyKGEuc2lnbmF0dXJlLnlQYXJpdHksIFwieVBhcml0eVwiKSxcclxuICAgICAgICAgICAgdG9CZUFycmF5KGEuc2lnbmF0dXJlLnIpLFxyXG4gICAgICAgICAgICB0b0JlQXJyYXkoYS5zaWduYXR1cmUucylcclxuICAgICAgICBdO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0SGFzaGVzKHZhbHVlLCBwYXJhbSkge1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSksIGBpbnZhbGlkICR7cGFyYW19YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWVbaV0sIDMyKSwgXCJpbnZhbGlkICR7IHBhcmFtIH0gaGFzaFwiLCBgdmFsdWVbJHtpfV1gLCB2YWx1ZVtpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gX3BhcnNlTGVnYWN5KGRhdGEpIHtcclxuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChkYXRhKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSA2KSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciBsZWdhY3kgdHJhbnNhY3Rpb25cIiwgXCJkYXRhXCIsIGRhdGEpO1xyXG4gICAgY29uc3QgdHggPSB7XHJcbiAgICAgICAgdHlwZTogMCxcclxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1swXSwgXCJub25jZVwiKSxcclxuICAgICAgICBnYXNQcmljZTogaGFuZGxlVWludChmaWVsZHNbMV0sIFwiZ2FzUHJpY2VcIiksXHJcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc0xpbWl0XCIpLFxyXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1szXSksXHJcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcInZhbHVlXCIpLFxyXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzVdKSxcclxuICAgICAgICBjaGFpbklkOiBCTl8wXHJcbiAgICB9O1xyXG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXHJcbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gNikge1xyXG4gICAgICAgIHJldHVybiB0eDtcclxuICAgIH1cclxuICAgIGNvbnN0IHYgPSBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2XCIpO1xyXG4gICAgY29uc3QgciA9IGhhbmRsZVVpbnQoZmllbGRzWzddLCBcInJcIik7XHJcbiAgICBjb25zdCBzID0gaGFuZGxlVWludChmaWVsZHNbOF0sIFwic1wiKTtcclxuICAgIGlmIChyID09PSBCTl8wICYmIHMgPT09IEJOXzApIHtcclxuICAgICAgICAvLyBFSVAtMTU1IHVuc2lnbmVkIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgdHguY2hhaW5JZCA9IHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IGNoYWluIElEIChvciAwIGZvciBsZWdhY3kpXHJcbiAgICAgICAgbGV0IGNoYWluSWQgPSAodiAtIEJOXzM1KSAvIEJOXzI7XHJcbiAgICAgICAgaWYgKGNoYWluSWQgPCBCTl8wKSB7XHJcbiAgICAgICAgICAgIGNoYWluSWQgPSBCTl8wO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0eC5jaGFpbklkID0gY2hhaW5JZDtcclxuICAgICAgICAvLyBTaWduZWQgTGVnYWN5IFRyYW5zYWN0aW9uXHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoY2hhaW5JZCAhPT0gQk5fMCB8fCAodiA9PT0gQk5fMjcgfHwgdiA9PT0gQk5fMjgpLCBcIm5vbi1jYW5vbmljYWwgbGVnYWN5IHZcIiwgXCJ2XCIsIGZpZWxkc1s2XSk7XHJcbiAgICAgICAgdHguc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xyXG4gICAgICAgICAgICByOiB6ZXJvUGFkVmFsdWUoZmllbGRzWzddLCAzMiksXHJcbiAgICAgICAgICAgIHM6IHplcm9QYWRWYWx1ZShmaWVsZHNbOF0sIDMyKSxcclxuICAgICAgICAgICAgdlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vdHguaGFzaCA9IGtlY2NhazI1NihkYXRhKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0eDtcclxufVxyXG5mdW5jdGlvbiBfc2VyaWFsaXplTGVnYWN5KHR4LCBzaWcpIHtcclxuICAgIGNvbnN0IGZpZWxkcyA9IFtcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxyXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcclxuICAgICAgICB0eC5kYXRhLFxyXG4gICAgXTtcclxuICAgIGxldCBjaGFpbklkID0gQk5fMDtcclxuICAgIGlmICh0eC5jaGFpbklkICE9IEJOXzApIHtcclxuICAgICAgICAvLyBBIGNoYWluSWQgd2FzIHByb3ZpZGVkOyBpZiBub24temVybyB3ZSdsbCB1c2UgRUlQLTE1NVxyXG4gICAgICAgIGNoYWluSWQgPSBnZXRCaWdJbnQodHguY2hhaW5JZCwgXCJ0eC5jaGFpbklkXCIpO1xyXG4gICAgICAgIC8vIFdlIGhhdmUgYSBjaGFpbklkIGluIHRoZSB0eCBhbmQgYW4gRUlQLTE1NSB2IGluIHRoZSBzaWduYXR1cmUsXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXkgYWdyZWUgd2l0aCBlYWNoIG90aGVyXHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXNpZyB8fCBzaWcubmV0d29ya1YgPT0gbnVsbCB8fCBzaWcubGVnYWN5Q2hhaW5JZCA9PT0gY2hhaW5JZCwgXCJ0eC5jaGFpbklkL3NpZy52IG1pc21hdGNoXCIsIFwic2lnXCIsIHNpZyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eC5zaWduYXR1cmUpIHtcclxuICAgICAgICAvLyBObyBleHBsaWNpdCBjaGFpbklkLCBidXQgRUlQLTE1NSBoYXZlIGEgZGVyaXZlZCBpbXBsaWNpdCBjaGFpbklkXHJcbiAgICAgICAgY29uc3QgbGVnYWN5ID0gdHguc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XHJcbiAgICAgICAgaWYgKGxlZ2FjeSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNoYWluSWQgPSBsZWdhY3k7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUmVxdWVzdGluZyBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvblxyXG4gICAgaWYgKCFzaWcpIHtcclxuICAgICAgICAvLyBXZSBoYXZlIGFuIEVJUC0xNTUgdHJhbnNhY3Rpb24gKGNoYWluSWQgd2FzIHNwZWNpZmllZCBhbmQgbm9uLXplcm8pXHJcbiAgICAgICAgaWYgKGNoYWluSWQgIT09IEJOXzApIHtcclxuICAgICAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KGNoYWluSWQpKTtcclxuICAgICAgICAgICAgZmllbGRzLnB1c2goXCIweFwiKTtcclxuICAgICAgICAgICAgZmllbGRzLnB1c2goXCIweFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVuY29kZVJscChmaWVsZHMpO1xyXG4gICAgfVxyXG4gICAgLy8gQFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBjaGVjayB0aGF0IHR4LnNpZ25hdHVyZSwgY2hhaW5JZCwgYW5kIHNpZ1xyXG4gICAgLy8gICAgICAgIG1hdGNoIGJ1dCB0aGF0IGxvZ2ljIGNvdWxkIGJyZWFrIGV4aXN0aW5nIGNvZGUsIHNvIHNjaGVkdWxlXHJcbiAgICAvLyAgICAgICAgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgYnVtcC5cclxuICAgIC8vIENvbXB1dGUgdGhlIEVJUC0xNTUgdlxyXG4gICAgbGV0IHYgPSBCaWdJbnQoMjcgKyBzaWcueVBhcml0eSk7XHJcbiAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xyXG4gICAgICAgIHYgPSBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgc2lnLnYpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoQmlnSW50KHNpZy52KSAhPT0gdikge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcclxuICAgIH1cclxuICAgIC8vIEFkZCB0aGUgc2lnbmF0dXJlXHJcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkodikpO1xyXG4gICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XHJcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcclxuICAgIHJldHVybiBlbmNvZGVSbHAoZmllbGRzKTtcclxufVxyXG5mdW5jdGlvbiBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcykge1xyXG4gICAgbGV0IHlQYXJpdHk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHlQYXJpdHkgPSBoYW5kbGVOdW1iZXIoZmllbGRzWzBdLCBcInlQYXJpdHlcIik7XHJcbiAgICAgICAgaWYgKHlQYXJpdHkgIT09IDAgJiYgeVBhcml0eSAhPT0gMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgeVBhcml0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHlQYXJpdHlcIiwgXCJ5UGFyaXR5XCIsIGZpZWxkc1swXSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByID0gemVyb1BhZFZhbHVlKGZpZWxkc1sxXSwgMzIpO1xyXG4gICAgY29uc3QgcyA9IHplcm9QYWRWYWx1ZShmaWVsZHNbMl0sIDMyKTtcclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHsgciwgcywgeVBhcml0eSB9KTtcclxuICAgIHR4LnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcclxufVxyXG5mdW5jdGlvbiBfcGFyc2VFaXAxNTU5KGRhdGEpIHtcclxuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XHJcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDkgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTIpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDJcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xyXG4gICAgY29uc3QgdHggPSB7XHJcbiAgICAgICAgdHlwZTogMixcclxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxyXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxyXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcclxuICAgICAgICBtYXhGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKSxcclxuICAgICAgICBnYXNQcmljZTogbnVsbCxcclxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXHJcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzVdKSxcclxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXHJcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbN10pLFxyXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzhdLCBcImFjY2Vzc0xpc3RcIiksXHJcbiAgICB9O1xyXG4gICAgLy8gVW5zaWduZWQgRUlQLTE1NTkgVHJhbnNhY3Rpb25cclxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA5KSB7XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfVxyXG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xyXG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoOSkpO1xyXG4gICAgcmV0dXJuIHR4O1xyXG59XHJcbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAxNTU5KHR4LCBzaWcpIHtcclxuICAgIGNvbnN0IGZpZWxkcyA9IFtcclxuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcclxuICAgICAgICAodHgudG8gfHwgXCIweFwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXHJcbiAgICAgICAgdHguZGF0YSxcclxuICAgICAgICBmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pXHJcbiAgICBdO1xyXG4gICAgaWYgKHNpZykge1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJ5UGFyaXR5XCIpKTtcclxuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcclxuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMlwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xyXG59XHJcbmZ1bmN0aW9uIF9wYXJzZUVpcDI5MzAoZGF0YSkge1xyXG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOCB8fCBmaWVsZHMubGVuZ3RoID09PSAxMSksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMVwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XHJcbiAgICBjb25zdCB0eCA9IHtcclxuICAgICAgICB0eXBlOiAxLFxyXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXHJcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXHJcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc1ByaWNlXCIpLFxyXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJnYXNMaW1pdFwiKSxcclxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNF0pLFxyXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s1XSwgXCJ2YWx1ZVwiKSxcclxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s2XSksXHJcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbN10sIFwiYWNjZXNzTGlzdFwiKVxyXG4gICAgfTtcclxuICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXHJcbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gOCkge1xyXG4gICAgICAgIHJldHVybiB0eDtcclxuICAgIH1cclxuICAgIC8vdHguaGFzaCA9IGtlY2NhazI1NihkYXRhKTtcclxuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDgpKTtcclxuICAgIHJldHVybiB0eDtcclxufVxyXG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0eCwgc2lnKSB7XHJcbiAgICBjb25zdCBmaWVsZHMgPSBbXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxyXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcclxuICAgICAgICB0eC5kYXRhLFxyXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSlcclxuICAgIF07XHJcbiAgICBpZiAoc2lnKSB7XHJcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInJlY292ZXJ5UGFyYW1cIikpO1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDAxXCIsIGVuY29kZVJscChmaWVsZHMpXSk7XHJcbn1cclxuZnVuY3Rpb24gX3BhcnNlRWlwNDg0NChkYXRhKSB7XHJcbiAgICBsZXQgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcclxuICAgIGxldCB0eXBlTmFtZSA9IFwiM1wiO1xyXG4gICAgbGV0IGJsb2JzID0gbnVsbDtcclxuICAgIC8vIFBhcnNlIHRoZSBuZXR3b3JrIGZvcm1hdFxyXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDQgJiYgQXJyYXkuaXNBcnJheShmaWVsZHNbMF0pKSB7XHJcbiAgICAgICAgdHlwZU5hbWUgPSBcIjMgKG5ldHdvcmsgZm9ybWF0KVwiO1xyXG4gICAgICAgIGNvbnN0IGZCbG9icyA9IGZpZWxkc1sxXSwgZkNvbW1pdHMgPSBmaWVsZHNbMl0sIGZQcm9vZnMgPSBmaWVsZHNbM107XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmQmxvYnMpLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGJsb2JzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1sxXVwiLCBmQmxvYnMpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZkNvbW1pdHMpLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGNvbW1pdG1lbnRzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1syXVwiLCBmQ29tbWl0cyk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmUHJvb2ZzKSwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBwcm9vZnMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzNdXCIsIGZQcm9vZnMpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZCbG9icy5sZW5ndGggPT09IGZDb21taXRzLmxlbmd0aCwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBibG9icy9jb21taXRtZW50cyBsZW5ndGggbWlzbWF0Y2hcIiwgXCJmaWVsZHNcIiwgZmllbGRzKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmQmxvYnMubGVuZ3RoID09PSBmUHJvb2ZzLmxlbmd0aCwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBibG9icy9wcm9vZnMgbGVuZ3RoIG1pc21hdGNoXCIsIFwiZmllbGRzXCIsIGZpZWxkcyk7XHJcbiAgICAgICAgYmxvYnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkc1sxXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBibG9icy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGZCbG9ic1tpXSxcclxuICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGZDb21taXRzW2ldLFxyXG4gICAgICAgICAgICAgICAgcHJvb2Y6IGZQcm9vZnNbaV0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaWVsZHMgPSBmaWVsZHNbMF07XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDExIHx8IGZpZWxkcy5sZW5ndGggPT09IDE0KSwgYGludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHlwZU5hbWV9YCwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xyXG4gICAgY29uc3QgdHggPSB7XHJcbiAgICAgICAgdHlwZTogMyxcclxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxyXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxyXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcclxuICAgICAgICBtYXhGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKSxcclxuICAgICAgICBnYXNQcmljZTogbnVsbCxcclxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXHJcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzVdKSxcclxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXHJcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbN10pLFxyXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzhdLCBcImFjY2Vzc0xpc3RcIiksXHJcbiAgICAgICAgbWF4RmVlUGVyQmxvYkdhczogaGFuZGxlVWludChmaWVsZHNbOV0sIFwibWF4RmVlUGVyQmxvYkdhc1wiKSxcclxuICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzOiBmaWVsZHNbMTBdXHJcbiAgICB9O1xyXG4gICAgaWYgKGJsb2JzKSB7XHJcbiAgICAgICAgdHguYmxvYnMgPSBibG9icztcclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KHR4LnRvICE9IG51bGwsIGBpbnZhbGlkIGFkZHJlc3MgZm9yIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHlwZU5hbWV9YCwgXCJkYXRhXCIsIGRhdGEpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheSh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzKSwgXCJpbnZhbGlkIGJsb2JWZXJzaW9uZWRIYXNoZXM6IG11c3QgYmUgYW4gYXJyYXlcIiwgXCJkYXRhXCIsIGRhdGEpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodHguYmxvYlZlcnNpb25lZEhhc2hlc1tpXSwgMzIpLCBgaW52YWxpZCBibG9iVmVyc2lvbmVkSGFzaCBhdCBpbmRleCAke2l9OiBtdXN0IGJlIGxlbmd0aCAzMmAsIFwiZGF0YVwiLCBkYXRhKTtcclxuICAgIH1cclxuICAgIC8vIFVuc2lnbmVkIEVJUC00ODQ0IFRyYW5zYWN0aW9uXHJcbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMTEpIHtcclxuICAgICAgICByZXR1cm4gdHg7XHJcbiAgICB9XHJcbiAgICAvLyBAVE9ETzogRG8gd2UgbmVlZCB0byBkbyB0aGlzPyBUaGlzIGlzIG9ubHkgY2FsbGVkIGludGVybmFsbHlcclxuICAgIC8vIGFuZCB1c2VkIHRvIHZlcmlmeSBoYXNoZXM7IGl0IG1pZ2h0IHNhdmUgdGltZSB0byBub3QgZG8gdGhpc1xyXG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGNvbmNhdChbIFwiMHgwM1wiLCBlbmNvZGVSbHAoZmllbGRzKSBdKSk7XHJcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSgxMSkpO1xyXG4gICAgcmV0dXJuIHR4O1xyXG59XHJcbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXA0ODQ0KHR4LCBzaWcsIGJsb2JzKSB7XHJcbiAgICBjb25zdCBmaWVsZHMgPSBbXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IDAsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXHJcbiAgICAgICAgKHR4LnRvIHx8IFplcm9BZGRyZXNzKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXHJcbiAgICAgICAgdHguZGF0YSxcclxuICAgICAgICBmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pLFxyXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJCbG9iR2FzIHx8IDAsIFwibWF4RmVlUGVyQmxvYkdhc1wiKSxcclxuICAgICAgICBmb3JtYXRIYXNoZXModHguYmxvYlZlcnNpb25lZEhhc2hlcyB8fCBbXSwgXCJibG9iVmVyc2lvbmVkSGFzaGVzXCIpXHJcbiAgICBdO1xyXG4gICAgaWYgKHNpZykge1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJ5UGFyaXR5XCIpKTtcclxuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcclxuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcclxuICAgICAgICAvLyBXZSBoYXZlIGJsb2JzOyByZXR1cm4gdGhlIG5ldHdvcmsgd3JhcHBlZCBmb3JtYXRcclxuICAgICAgICBpZiAoYmxvYnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdChbXHJcbiAgICAgICAgICAgICAgICBcIjB4MDNcIixcclxuICAgICAgICAgICAgICAgIGVuY29kZVJscChbXHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2JzLm1hcCgoYikgPT4gYi5kYXRhKSxcclxuICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIuY29tbWl0bWVudCksXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvYnMubWFwKChiKSA9PiBiLnByb29mKSxcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwM1wiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xyXG59XHJcbmZ1bmN0aW9uIF9wYXJzZUVpcDc3MDIoZGF0YSkge1xyXG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gMTAgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTMpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDRcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xyXG4gICAgY29uc3QgdHggPSB7XHJcbiAgICAgICAgdHlwZTogNCxcclxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxyXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxyXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcclxuICAgICAgICBtYXhGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKSxcclxuICAgICAgICBnYXNQcmljZTogbnVsbCxcclxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXHJcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzVdKSxcclxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXHJcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbN10pLFxyXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzhdLCBcImFjY2Vzc0xpc3RcIiksXHJcbiAgICAgICAgYXV0aG9yaXphdGlvbkxpc3Q6IGhhbmRsZUF1dGhvcml6YXRpb25MaXN0KGZpZWxkc1s5XSwgXCJhdXRob3JpemF0aW9uTGlzdFwiKSxcclxuICAgIH07XHJcbiAgICAvLyBVbnNpZ25lZCBFSVAtNzcwMiBUcmFuc2FjdGlvblxyXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDEwKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfVxyXG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoMTApKTtcclxuICAgIHJldHVybiB0eDtcclxufVxyXG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwNzcwMih0eCwgc2lnKSB7XHJcbiAgICBjb25zdCBmaWVsZHMgPSBbXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IDAsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcclxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXHJcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxyXG4gICAgICAgIHR4LmRhdGEsXHJcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSxcclxuICAgICAgICBmb3JtYXRBdXRob3JpemF0aW9uTGlzdCh0eC5hdXRob3JpemF0aW9uTGlzdCB8fCBbXSlcclxuICAgIF07XHJcbiAgICBpZiAoc2lnKSB7XHJcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDA0XCIsIGVuY29kZVJscChmaWVsZHMpXSk7XHJcbn1cclxuLyoqXHJcbiAqICBBICoqVHJhbnNhY3Rpb24qKiBkZXNjcmliZXMgYW4gb3BlcmF0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uXHJcbiAqICBFdGhlcmV1bSBieSBhbiBFeHRlcm5hbGx5IE93bmVkIEFjY291bnQgKEVPQSkuIEl0IGluY2x1ZGVzXHJcbiAqICB3aG8gKHRoZSBbW3RvXV0gYWRkcmVzcyksIHdoYXQgKHRoZSBbW2RhdGFdXSkgYW5kIGhvdyBtdWNoICh0aGVcclxuICogIFtbdmFsdWVdXSBpbiBldGhlcikgdGhlIG9wZXJhdGlvbiBzaG91bGQgZW50YWlsLlxyXG4gKlxyXG4gKiAgQGV4YW1wbGU6XHJcbiAqICAgIHR4ID0gbmV3IFRyYW5zYWN0aW9uKClcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKlxyXG4gKiAgICB0eC5kYXRhID0gXCIweDEyMzRcIjtcclxuICogICAgLy9fcmVzdWx0OlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIHtcclxuICAgICN0eXBlO1xyXG4gICAgI3RvO1xyXG4gICAgI2RhdGE7XHJcbiAgICAjbm9uY2U7XHJcbiAgICAjZ2FzTGltaXQ7XHJcbiAgICAjZ2FzUHJpY2U7XHJcbiAgICAjbWF4UHJpb3JpdHlGZWVQZXJHYXM7XHJcbiAgICAjbWF4RmVlUGVyR2FzO1xyXG4gICAgI3ZhbHVlO1xyXG4gICAgI2NoYWluSWQ7XHJcbiAgICAjc2lnO1xyXG4gICAgI2FjY2Vzc0xpc3Q7XHJcbiAgICAjbWF4RmVlUGVyQmxvYkdhcztcclxuICAgICNibG9iVmVyc2lvbmVkSGFzaGVzO1xyXG4gICAgI2t6ZztcclxuICAgICNibG9icztcclxuICAgICNhdXRocztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiB0eXBlLlxyXG4gICAgICpcclxuICAgICAqICBJZiBudWxsLCB0aGUgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgYmFzZWQgb25cclxuICAgICAqICBleHBsaWNpdCBwcm9wZXJ0aWVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuI3R5cGU7IH1cclxuICAgIHNldCB0eXBlKHZhbHVlKSB7XHJcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBjYXNlIG51bGw6XHJcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIGNhc2UgXCJsZWdhY3lcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgY2FzZSBcImJlcmxpblwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZWlwLTI5MzBcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgY2FzZSBcImxvbmRvblwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZWlwLTE1NTlcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgY2FzZSBcImNhbmN1blwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZWlwLTQ4NDRcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgY2FzZSBcInBlY3RyYVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZWlwLTc3MDJcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSA0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwidHlwZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIHRyYW5zYWN0aW9uIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIGdldCB0eXBlTmFtZSgpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBcImxlZ2FjeVwiO1xyXG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBcImVpcC0yOTMwXCI7XHJcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFwiZWlwLTE1NTlcIjtcclxuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gXCJlaXAtNDg0NFwiO1xyXG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBcImVpcC03NzAyXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGBgdG9gYCBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb24gb3IgYGBudWxsYGAgaWYgdGhlXHJcbiAgICAgKiAgdHJhbnNhY3Rpb24gaXMgYW4gYGBpbml0YGAgdHJhbnNhY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCB0bygpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3RvO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PT0gMykge1xyXG4gICAgICAgICAgICByZXR1cm4gWmVyb0FkZHJlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB0byh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI3RvID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEFkZHJlc3ModmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIG5vbmNlLlxyXG4gICAgICovXHJcbiAgICBnZXQgbm9uY2UoKSB7IHJldHVybiB0aGlzLiNub25jZTsgfVxyXG4gICAgc2V0IG5vbmNlKHZhbHVlKSB7IHRoaXMuI25vbmNlID0gZ2V0TnVtYmVyKHZhbHVlLCBcInZhbHVlXCIpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZ2FzIGxpbWl0LlxyXG4gICAgICovXHJcbiAgICBnZXQgZ2FzTGltaXQoKSB7IHJldHVybiB0aGlzLiNnYXNMaW1pdDsgfVxyXG4gICAgc2V0IGdhc0xpbWl0KHZhbHVlKSB7IHRoaXMuI2dhc0xpbWl0ID0gZ2V0QmlnSW50KHZhbHVlKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGdhcyBwcmljZS5cclxuICAgICAqXHJcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzIHRoaXMgZGVmaW5lcyB0aGUgZmVlIHRoYXQgd2lsbCBiZSBwYWlkLiBPblxyXG4gICAgICogIEVJUC0xNTU5IG5ldHdvcmtzLCB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGdhc1ByaWNlKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZ2FzUHJpY2U7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgKHRoaXMudHlwZSA9PT0gMCB8fCB0aGlzLnR5cGUgPT09IDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgZ2FzUHJpY2UodmFsdWUpIHtcclxuICAgICAgICB0aGlzLiNnYXNQcmljZSA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwiZ2FzUHJpY2VcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWF4aW11bSBwcmlvcml0eSBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XHJcbiAgICAgKiAgbmV0d29ya3MgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBtYXhQcmlvcml0eUZlZVBlckdhcygpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IG1heFByaW9yaXR5RmVlUGVyR2FzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG1heGltdW0gdG90YWwgZmVlIHBlciB1bml0IG9mIGdhcyB0byBwYXkuIE9uIGxlZ2FjeVxyXG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4RmVlUGVyR2FzKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyR2FzO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IG1heEZlZVBlckdhcyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI21heEZlZVBlckdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4RmVlUGVyR2FzXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGRhdGEuIEZvciBgYGluaXRgYCB0cmFuc2FjdGlvbnMgdGhpcyBpcyB0aGVcclxuICAgICAqICBkZXBsb3ltZW50IGNvZGUuXHJcbiAgICAgKi9cclxuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gdGhpcy4jZGF0YTsgfVxyXG4gICAgc2V0IGRhdGEodmFsdWUpIHsgdGhpcy4jZGF0YSA9IGhleGxpZnkodmFsdWUpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYW1vdW50IG9mIGV0aGVyIChpbiB3ZWkpIHRvIHNlbmQgaW4gdGhpcyB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuI3ZhbHVlOyB9XHJcbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLiN2YWx1ZSA9IGdldEJpZ0ludCh2YWx1ZSwgXCJ2YWx1ZVwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjaGFpbiBJRCB0aGlzIHRyYW5zYWN0aW9uIGlzIHZhbGlkIG9uLlxyXG4gICAgICovXHJcbiAgICBnZXQgY2hhaW5JZCgpIHsgcmV0dXJuIHRoaXMuI2NoYWluSWQ7IH1cclxuICAgIHNldCBjaGFpbklkKHZhbHVlKSB7IHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQodmFsdWUpOyB9XHJcbiAgICAvKipcclxuICAgICAqICBJZiBzaWduZWQsIHRoZSBzaWduYXR1cmUgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBzaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLiNzaWcgfHwgbnVsbDsgfVxyXG4gICAgc2V0IHNpZ25hdHVyZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI3NpZyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBTaWduYXR1cmUuZnJvbSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYWNjZXNzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogIEFuIGFjY2VzcyBsaXN0IHBlcm1pdHMgZGlzY291bnRlZCAoYnV0IHByZS1wYWlkKSBhY2Nlc3MgdG9cclxuICAgICAqICBieXRlY29kZSBhbmQgc3RhdGUgdmFyaWFibGUgYWNjZXNzIHdpdGhpbiBjb250cmFjdCBleGVjdXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBhY2Nlc3NMaXN0KCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jYWNjZXNzTGlzdCB8fCBudWxsO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDEgfHwgdGhpcy50eXBlID09PSAyIHx8IHRoaXMudHlwZSA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IGluIHY3LCB0aGlzIHNob3VsZCBhc3NpZ24gdGhlIHZhbHVlIG9yIGJlY29tZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBsaXZlIG9iamVjdCBpdHNlbGYsIG90aGVyd2lzZSBtdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnRcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IGFjY2Vzc0xpc3QodmFsdWUpIHtcclxuICAgICAgICB0aGlzLiNhY2Nlc3NMaXN0ID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGFjY2Vzc0xpc3RpZnkodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGF1dGhvcml6YXRpb25MaXN0KCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jYXV0aHMgfHwgbnVsbDtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaW4gdjcsIHRoaXMgc2hvdWxkIGJlY29tZSBhIGxpdmUgb2JqZWN0IGl0c2VsZixcclxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBtdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnRcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgYXV0aG9yaXphdGlvbkxpc3QoYXV0aHMpIHtcclxuICAgICAgICB0aGlzLiNhdXRocyA9IChhdXRocyA9PSBudWxsKSA/IG51bGwgOiBhdXRocy5tYXAoKGEpID0+IGF1dGhvcml6YXRpb25pZnkoYSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG1heCBmZWUgcGVyIGJsb2IgZ2FzIGZvciBDYW5jdW4gdHJhbnNhY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4RmVlUGVyQmxvYkdhcygpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heEZlZVBlckJsb2JHYXM7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgbWF4RmVlUGVyQmxvYkdhcyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI21heEZlZVBlckJsb2JHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heEZlZVBlckJsb2JHYXNcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgQkxPYiB2ZXJzaW9uZWQgaGFzaGVzIGZvciBDYW5jdW4gdHJhbnNhY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBnZXQgYmxvYlZlcnNpb25lZEhhc2hlcygpIHtcclxuICAgICAgICAvLyBAVE9ETzogTXV0YXRpb24gaXMgaW5jb25zaXN0ZW50OyBpZiB1bnNldCwgdGhlIHJldHVybmVkIHZhbHVlXHJcbiAgICAgICAgLy8gY2Fubm90IG11dGF0ZSB0aGUgb2JqZWN0LCBpZiBzZXQgaXQgY2FuXHJcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcztcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT09IDMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgYmxvYlZlcnNpb25lZEhhc2hlcyh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkodmFsdWUpLCBcImJsb2JWZXJzaW9uZWRIYXNoZXMgbXVzdCBiZSBhbiBBcnJheVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZVtpXSwgMzIpLCBcImludmFsaWQgYmxvYlZlcnNpb25lZEhhc2hcIiwgYHZhbHVlWyR7aX1dYCwgdmFsdWVbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBCTE9icyBmb3IgdGhlIFRyYW5zYWN0aW9uLCBpZiBhbnkuXHJcbiAgICAgKlxyXG4gICAgICogIElmIGBgYmxvYnNgYCBpcyBub24tYGBudWxsYGAsIHRoZW4gdGhlIFtbc2VyaWFpbGl6ZWRdXVxyXG4gICAgICogIHdpbGwgcmV0dXJuIHRoZSBuZXR3b3JrIGZvcm1hdHRlZCBzaWRlY2FyLCBvdGhlcndpc2UgaXRcclxuICAgICAqICB3aWxsIHJldHVybiB0aGUgc3RhbmRhcmQgW1tsaW5rLWVpcC0yNzE4XV0gcGF5bG9hZC4gVGhlXHJcbiAgICAgKiAgW1t1bnNpZ25lZFNlcmlhbGl6ZWRdXSBpcyB1bmFmZmVjdGVkIHJlZ2FyZGxlc3MuXHJcbiAgICAgKlxyXG4gICAgICogIFdoZW4gc2V0dGluZyBgYGJsb2JzYGAsIGVpdGhlciBmdWxseSB2YWxpZCBbW0Jsb2JdXSBvYmplY3RzXHJcbiAgICAgKiAgbWF5IGJlIHNwZWNpZmllZCAoaS5lLiBjb3JyZWN0bHkgcGFkZGVkLCB3aXRoIGNvcnJlY3RcclxuICAgICAqICBjb21taXR0bWVudHMgYW5kIHByb29mcykgb3IgYSByYXcgW1tCeXRlc0xpa2VdXSBtYXlcclxuICAgICAqICBiZSBwcm92aWRlZC5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgcmF3IFtbQnl0ZXNMaWtlXV0gYXJlIHByb3ZpZGVkLCB0aGUgW1tremddXSBwcm9wZXJ0eSAqKm11c3QqKlxyXG4gICAgICogIGJlIGFscmVhZHkgc2V0LiBUaGUgYmxvYiB3aWxsIGJlIGNvcnJlY3RseSBwYWRkZWQgYW5kIHRoZVxyXG4gICAgICogIFtbS3pnTGlicmFyeV1dIHdpbGwgYmUgdXNlZCB0byBjb21wdXRlIHRoZSBjb21taXR0bWVudCBhbmRcclxuICAgICAqICBwcm9vZiBmb3IgdGhlIGJsb2IuXHJcbiAgICAgKlxyXG4gICAgICogIEEgQkxPYiBpcyBhIHNlcXVlbmNlIG9mIGZpZWxkIGVsZW1lbnRzLCBlYWNoIG9mIHdoaWNoIG11c3RcclxuICAgICAqICBiZSB3aXRoaW4gdGhlIEJMUyBmaWVsZCBtb2R1bG8sIHNvIHNvbWUgYWRkaXRpb25hbCBwcm9jZXNzaW5nXHJcbiAgICAgKiAgbWF5IGJlIHJlcXVpcmVkIHRvIGVuY29kZSBhcmJpdHJhcnkgZGF0YSB0byBlbnN1cmUgZWFjaCAzMiBieXRlXHJcbiAgICAgKiAgZmllbGQgaXMgd2l0aGluIHRoZSB2YWxpZCByYW5nZS5cclxuICAgICAqXHJcbiAgICAgKiAgU2V0dGluZyB0aGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVzIFtbYmxvYlZlcnNpb25lZEhhc2hlc11dLFxyXG4gICAgICogIG92ZXJ3cml0aW5nIGFueSBleGlzdGluZyB2YWx1ZXMuIFNldHRpbmcgdGhpcyB0byBgYG51bGxgYFxyXG4gICAgICogIGRvZXMgKipub3QqKiByZW1vdmUgdGhlIFtbYmxvYlZlcnNpb25lZEhhc2hlc11dLCBsZWF2aW5nIHRoZW1cclxuICAgICAqICBwcmVzZW50LlxyXG4gICAgICovXHJcbiAgICBnZXQgYmxvYnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI2Jsb2JzID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLiNibG9icy5tYXAoKGIpID0+IE9iamVjdC5hc3NpZ24oe30sIGIpKTtcclxuICAgIH1cclxuICAgIHNldCBibG9icyhfYmxvYnMpIHtcclxuICAgICAgICBpZiAoX2Jsb2JzID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy4jYmxvYnMgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJsb2JzID0gW107XHJcbiAgICAgICAgY29uc3QgdmVyc2lvbmVkSGFzaGVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYmxvYnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYmxvYiA9IF9ibG9ic1tpXTtcclxuICAgICAgICAgICAgaWYgKGlzQnl0ZXNMaWtlKGJsb2IpKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQodGhpcy4ja3pnLCBcImFkZGluZyBhIHJhdyBibG9iIHJlcXVpcmVzIGEgS1pHIGxpYnJhcnlcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXQgYmxvYnMoKVwiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gZ2V0Qnl0ZXMoYmxvYik7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhLmxlbmd0aCA8PSBCTE9CX1NJWkUsIFwiYmxvYiBpcyB0b28gbGFyZ2VcIiwgYGJsb2JzWyR7aX1dYCwgYmxvYik7XHJcbiAgICAgICAgICAgICAgICAvLyBQYWQgYmxvYiBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gQkxPQl9TSVpFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoQkxPQl9TSVpFKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWRkZWQuc2V0KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwYWRkZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21taXQgPSB0aGlzLiNremcuYmxvYlRvS3pnQ29tbWl0bWVudChkYXRhKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb29mID0gaGV4bGlmeSh0aGlzLiNremcuY29tcHV0ZUJsb2JLemdQcm9vZihkYXRhLCBjb21taXQpKTtcclxuICAgICAgICAgICAgICAgIGJsb2JzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleGxpZnkoZGF0YSksXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogaGV4bGlmeShjb21taXQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb29mXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZlcnNpb25lZEhhc2hlcy5wdXNoKGdldFZlcnNpb25lZEhhc2goMSwgY29tbWl0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21taXQgPSBoZXhsaWZ5KGJsb2IuY29tbWl0bWVudCk7XHJcbiAgICAgICAgICAgICAgICBibG9icy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhsaWZ5KGJsb2IuZGF0YSksXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogY29tbWl0LFxyXG4gICAgICAgICAgICAgICAgICAgIHByb29mOiBoZXhsaWZ5KGJsb2IucHJvb2YpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZlcnNpb25lZEhhc2hlcy5wdXNoKGdldFZlcnNpb25lZEhhc2goMSwgY29tbWl0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jYmxvYnMgPSBibG9icztcclxuICAgICAgICB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzID0gdmVyc2lvbmVkSGFzaGVzO1xyXG4gICAgfVxyXG4gICAgZ2V0IGt6ZygpIHsgcmV0dXJuIHRoaXMuI2t6ZzsgfVxyXG4gICAgc2V0IGt6ZyhremcpIHtcclxuICAgICAgICBpZiAoa3pnID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy4ja3pnID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2t6ZyA9IGdldEt6Z0xpYnJhcnkoa3pnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IFRyYW5zYWN0aW9uIHdpdGggZGVmYXVsdCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuI3R5cGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI3RvID0gbnVsbDtcclxuICAgICAgICB0aGlzLiNub25jZSA9IDA7XHJcbiAgICAgICAgdGhpcy4jZ2FzTGltaXQgPSBCTl8wO1xyXG4gICAgICAgIHRoaXMuI2dhc1ByaWNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gbnVsbDtcclxuICAgICAgICB0aGlzLiNkYXRhID0gXCIweFwiO1xyXG4gICAgICAgIHRoaXMuI3ZhbHVlID0gQk5fMDtcclxuICAgICAgICB0aGlzLiNjaGFpbklkID0gQk5fMDtcclxuICAgICAgICB0aGlzLiNzaWcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI21heEZlZVBlckJsb2JHYXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI2t6ZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jYmxvYnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI2F1dGhzID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBoYXNoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuI2dldFNlcmlhbGl6ZWQodHJ1ZSwgZmFsc2UpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwcmUtaW1hZ2UgaGFzaCBvZiB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIHRoZSBkaWdlc3QgdGhhdCBhIFtbU2lnbmVyXV0gbXVzdCBzaWduIHRvIGF1dGhvcml6ZVxyXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCB1bnNpZ25lZEhhc2goKSB7XHJcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLnVuc2lnbmVkU2VyaWFsaXplZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgc2VuZGluZyBhZGRyZXNzLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBmcm9tKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3ModGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBzZW5kZXIsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGZyb21QdWJsaWNLZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkodGhpcy51bnNpZ25lZEhhc2gsIHRoaXMuc2lnbmF0dXJlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBzaWduZWQuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgcHJvcGVydGllcyByZXF1aXJpbmcgYSBzaWduZWRcclxuICAgICAqICB0cmFuc2FjdGlvbiBhcmUgbm9uLW51bGwuXHJcbiAgICAgKi9cclxuICAgIGlzU2lnbmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZSAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgI2dldFNlcmlhbGl6ZWQoc2lnbmVkLCBzaWRlY2FyKSB7XHJcbiAgICAgICAgYXNzZXJ0KCFzaWduZWQgfHwgdGhpcy5zaWduYXR1cmUgIT0gbnVsbCwgXCJjYW5ub3Qgc2VyaWFsaXplIHVuc2lnbmVkIHRyYW5zYWN0aW9uOyBtYXliZSB5b3UgbWVhbnQgLnVuc2lnbmVkU2VyaWFsaXplZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIuc2VyaWFsaXplZFwiIH0pO1xyXG4gICAgICAgIGNvbnN0IHNpZyA9IHNpZ25lZCA/IHRoaXMuc2lnbmF0dXJlIDogbnVsbDtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5mZXJUeXBlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVMZWdhY3kodGhpcywgc2lnKTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAyOTMwKHRoaXMsIHNpZyk7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0aGlzLCBzaWcpO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDQ4NDQodGhpcywgc2lnLCBzaWRlY2FyID8gdGhpcy5ibG9icyA6IG51bGwpO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDc3MDIodGhpcywgc2lnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHRocm93cyBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgdW5zaWduZWQuIEZvciB0aGUgcHJlLWltYWdlLFxyXG4gICAgICogIHVzZSBbW3Vuc2lnbmVkU2VyaWFsaXplZF1dLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2VyaWFsaXplZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0U2VyaWFsaXplZCh0cnVlLCB0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UuXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSBoYXNoIG9mIHRoaXMgaXMgdGhlIGRpZ2VzdCB3aGljaCBuZWVkcyB0byBiZSBzaWduZWQgdG9cclxuICAgICAqICBhdXRob3JpemUgdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IHVuc2lnbmVkU2VyaWFsaXplZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0U2VyaWFsaXplZChmYWxzZSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBtb3N0IFwibGlrZWx5XCIgdHlwZTsgY3VycmVudGx5IHRoZSBoaWdoZXN0XHJcbiAgICAgKiAgc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIGluZmVyVHlwZSgpIHtcclxuICAgICAgICBjb25zdCB0eXBlcyA9IHRoaXMuaW5mZXJUeXBlcygpO1xyXG4gICAgICAgIC8vIFByZWZlciBMb25kb24gKEVJUC0xNTU5KSBvdmVyIENhbmN1biAoQkxPYilcclxuICAgICAgICBpZiAodHlwZXMuaW5kZXhPZigyKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXR1cm4gdGhlIGhpZ2hlc3QgaW5mZXJyZWQgdHlwZVxyXG4gICAgICAgIHJldHVybiAodHlwZXMucG9wKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVmFsaWRhdGVzIHRoZSBleHBsaWNpdCBwcm9wZXJ0aWVzIGFuZCByZXR1cm5zIGEgbGlzdCBvZiBjb21wYXRpYmxlXHJcbiAgICAgKiAgdHJhbnNhY3Rpb24gdHlwZXMuXHJcbiAgICAgKi9cclxuICAgIGluZmVyVHlwZXMoKSB7XHJcbiAgICAgICAgLy8gQ2hlY2tzIHRoYXQgdGhlcmUgYXJlIG5vIGNvbmZsaWN0aW5nIHByb3BlcnRpZXMgc2V0XHJcbiAgICAgICAgY29uc3QgaGFzR2FzUHJpY2UgPSB0aGlzLmdhc1ByaWNlICE9IG51bGw7XHJcbiAgICAgICAgY29uc3QgaGFzRmVlID0gKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcclxuICAgICAgICBjb25zdCBoYXNBY2Nlc3NMaXN0ID0gKHRoaXMuYWNjZXNzTGlzdCAhPSBudWxsKTtcclxuICAgICAgICBjb25zdCBoYXNCbG9iID0gKHRoaXMuI21heEZlZVBlckJsb2JHYXMgIT0gbnVsbCB8fCB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzKTtcclxuICAgICAgICAvL2lmIChoYXNHYXNQcmljZSAmJiBoYXNGZWUpIHtcclxuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZSBhbmQgbWF4RmVlUGVyR2FzXCIpO1xyXG4gICAgICAgIC8vfVxyXG4gICAgICAgIGlmICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsICYmIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhc3NlcnQodGhpcy5tYXhGZWVQZXJHYXMgPj0gdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcywgXCJwcmlvcml0eUZlZSBjYW5ub3QgYmUgbW9yZSB0aGFuIG1heEZlZVwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vaWYgKHRoaXMudHlwZSA9PT0gMiAmJiBoYXNHYXNQcmljZSkge1xyXG4gICAgICAgIC8vICAgIHRocm93IG5ldyBFcnJvcihcImVpcC0xNTU5IHRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGdhc1ByaWNlXCIpO1xyXG4gICAgICAgIC8vfVxyXG4gICAgICAgIGFzc2VydCghaGFzRmVlIHx8ICh0aGlzLnR5cGUgIT09IDAgJiYgdGhpcy50eXBlICE9PSAxKSwgXCJ0cmFuc2FjdGlvbiB0eXBlIGNhbm5vdCBoYXZlIG1heEZlZVBlckdhcyBvciBtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMudHlwZSAhPT0gMCB8fCAhaGFzQWNjZXNzTGlzdCwgXCJsZWdhY3kgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgYWNjZXNzTGlzdFwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcclxuICAgICAgICAvLyBFeHBsaWNpdCB0eXBlXHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHR5cGVzLnB1c2godGhpcy50eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dGhvcml6YXRpb25MaXN0ICYmIHRoaXMuYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0ZlZSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYXNHYXNQcmljZSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzQWNjZXNzTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQWNjZXNzTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcclxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQmxvYiAmJiB0aGlzLnRvKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcclxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xyXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0eXBlcy5zb3J0KCk7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYSBsZWdhY3kgdHJhbnNhY3Rpb24gKGkuZS5cclxuICAgICAqICBgYHR5cGUgPT09IDBgYCkuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcclxuICAgICAqICBub24tbnVsbC5cclxuICAgICAqL1xyXG4gICAgaXNMZWdhY3koKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYmVybGluIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXHJcbiAgICAgKiAgYGB0eXBlID09PSAxYGApLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXHJcbiAgICAgKiAgbm9uLW51bGwuXHJcbiAgICAgKi9cclxuICAgIGlzQmVybGluKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGxvbmRvbiBoYXJkZm9ybSB0cmFuc2FjdGlvbiAoaS5lLlxyXG4gICAgICogIGBgdHlwZSA9PT0gMmBgKS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxyXG4gICAgICogIG5vbi1udWxsLlxyXG4gICAgICovXHJcbiAgICBpc0xvbmRvbigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhbiBbW2xpbmstZWlwLTQ4NDRdXSBCTE9CXHJcbiAgICAgKiAgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcclxuICAgICAqICBub24tbnVsbC5cclxuICAgICAqL1xyXG4gICAgaXNDYW5jdW4oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIHRyYW5zYWNpdG9uLlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbSh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIEpTT04tZnJpZW5kbHkgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3QgcyA9ICh2KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSxcclxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxyXG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZSxcclxuICAgICAgICAgICAgZ2FzTGltaXQ6IHModGhpcy5nYXNMaW1pdCksXHJcbiAgICAgICAgICAgIGdhc1ByaWNlOiBzKHRoaXMuZ2FzUHJpY2UpLFxyXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcyh0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcclxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBzKHRoaXMubWF4RmVlUGVyR2FzKSxcclxuICAgICAgICAgICAgdmFsdWU6IHModGhpcy52YWx1ZSksXHJcbiAgICAgICAgICAgIGNoYWluSWQ6IHModGhpcy5jaGFpbklkKSxcclxuICAgICAgICAgICAgc2lnOiB0aGlzLnNpZ25hdHVyZSA/IHRoaXMuc2lnbmF0dXJlLnRvSlNPTigpIDogbnVsbCxcclxuICAgICAgICAgICAgYWNjZXNzTGlzdDogdGhpcy5hY2Nlc3NMaXN0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhICoqVHJhbnNhY3Rpb24qKiBmcm9tIGEgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBvciBhXHJcbiAgICAgKiAgVHJhbnNhY3Rpb24tbGlrZSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKHR4KSB7XHJcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGdldEJ5dGVzKHR4KTtcclxuICAgICAgICAgICAgaWYgKHBheWxvYWRbMF0gPj0gMHg3ZikgeyAvLyBAVE9ETzogPiB2cyA+PSA/P1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlTGVnYWN5KHBheWxvYWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMjkzMChwYXlsb2FkKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDE1NTkocGF5bG9hZCkpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXA0ODQ0KHBheWxvYWQpKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwNzcwMihwYXlsb2FkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZnJvbVwiIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVHJhbnNhY3Rpb24oKTtcclxuICAgICAgICBpZiAodHgudHlwZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdHgudHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnRvID0gdHgudG87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5ub25jZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5ub25jZSA9IHR4Lm5vbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHguZ2FzTGltaXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0Lmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4Lm1heEZlZVBlckJsb2JHYXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQubWF4RmVlUGVyQmxvYkdhcyA9IHR4Lm1heEZlZVBlckJsb2JHYXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5kYXRhICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0eC5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHgudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB0eC52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LmNoYWluSWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5zaWduYXR1cmUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odHguc2lnbmF0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IHR4LmFjY2Vzc0xpc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5hdXRob3JpemF0aW9uTGlzdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hdXRob3JpemF0aW9uTGlzdCA9IHR4LmF1dGhvcml6YXRpb25MaXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGlzIHdpbGwgZ2V0IG92ZXJ3cml0dGVuIGJ5IGJsb2JzLCBpZiBwcmVzZW50XHJcbiAgICAgICAgaWYgKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuYmxvYlZlcnNpb25lZEhhc2hlcyA9IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhc3NpZ24gdGhlIGt6ZyBiZWZvcmUgYXNzaWduaW5nIGJsb2JzLCB3aGljaFxyXG4gICAgICAgIC8vIHJlcXVpcmUgdGhlIGxpYnJhcnkgaW4gdGhlIGV2ZW50IHJhdyBibG9iIGRhdGEgaXMgcHJvdmlkZWQuXHJcbiAgICAgICAgaWYgKHR4Lmt6ZyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5remcgPSB0eC5remc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5ibG9icyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5ibG9icyA9IHR4LmJsb2JzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHguaGFzaCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgJy5oYXNoJ1wiLCBcInR4XCIsIHR4KTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0Lmhhc2ggPT09IHR4Lmhhc2gsIFwiaGFzaCBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lICcuZnJvbSdcIiwgXCJ0eFwiLCB0eCk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5mcm9tLnRvTG93ZXJDYXNlKCkgPT09ICh0eC5mcm9tIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyByZWNvdmVyQWRkcmVzcyB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCwgY29uY2F0LCBlbmNvZGVSbHAsIHRvQmVBcnJheSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG4vKipcclxuICogIENvbXB1dGVzIHRoZSBbW2xpbmstZWlwLTc3MDJdXSBhdXRob3JpemF0aW9uIGRpZ2VzdCB0byBzaWduLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hBdXRob3JpemF0aW9uKGF1dGgpIHtcclxuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoYXV0aC5hZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3MgZm9yIGhhc2hBdXRob3JpemF0aW9uXCIsIFwiYXV0aC5hZGRyZXNzXCIsIGF1dGgpO1xyXG4gICAgcmV0dXJuIGtlY2NhazI1Nihjb25jYXQoW1xyXG4gICAgICAgIFwiMHgwNVwiLCBlbmNvZGVSbHAoW1xyXG4gICAgICAgICAgICAoYXV0aC5jaGFpbklkICE9IG51bGwpID8gdG9CZUFycmF5KGF1dGguY2hhaW5JZCkgOiBcIjB4XCIsXHJcbiAgICAgICAgICAgIGdldEFkZHJlc3MoYXV0aC5hZGRyZXNzKSxcclxuICAgICAgICAgICAgKGF1dGgubm9uY2UgIT0gbnVsbCkgPyB0b0JlQXJyYXkoYXV0aC5ub25jZSkgOiBcIjB4XCIsXHJcbiAgICAgICAgXSlcclxuICAgIF0pKTtcclxufVxyXG4vKipcclxuICogIFJldHVybiB0aGUgYWRkcmVzcyBvZiB0aGUgcHJpdmF0ZSBrZXkgdGhhdCBwcm9kdWNlZFxyXG4gKiAgdGhlIHNpZ25hdHVyZSAlJXNpZyUlIGR1cmluZyBzaWduaW5nIGZvciAlJW1lc3NhZ2UlJS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlBdXRob3JpemF0aW9uKGF1dGgsIHNpZykge1xyXG4gICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKGhhc2hBdXRob3JpemF0aW9uKGF1dGgpLCBzaWcpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhvcml6YXRpb24uanMubWFwIiwiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG4vKipcclxuICogIEEgc2ltcGxlIGhhc2hpbmcgZnVuY3Rpb24gd2hpY2ggb3BlcmF0ZXMgb24gVVRGLTggc3RyaW5ncyB0b1xyXG4gKiAgY29tcHV0ZSBhbiAzMi1ieXRlIGlkZW50aWZpZXIuXHJcbiAqXHJcbiAqICBUaGlzIHNpbXBseSBjb21wdXRlcyB0aGUgW1VURi04IGJ5dGVzXSh0b1V0ZjhCeXRlcykgYW5kIGNvbXB1dGVzXHJcbiAqICB0aGUgW1trZWNjYWsyNTZdXS5cclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICBpZChcImhlbGxvIHdvcmxkXCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpZCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGtlY2NhazI1Nih0b1V0ZjhCeXRlcyh2YWx1ZSkpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIi8vIGNyZWF0ZWQgMjAyMy0wOS0yNVQwMTowMTo1NS4xNDhaXHJcbi8vIGNvbXByZXNzZWQgYmFzZTY0LWVuY29kZWQgYmxvYiBmb3IgaW5jbHVkZS1lbnMgZGF0YVxyXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvYmxvYi9tYWluL3NyYy9tYWtlLmpzXHJcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxyXG4vLyBTSEEtMjU2OiAwNTY1ZWQwNDliOWNmMTYxNGJiOWUxMWJhN2Q4YWM2YTZmYjk2Yzg5MzI1M2Q4OTBmN2UyYjI4ODRiOWRlZDMyXHJcbnZhciBDT01QUkVTU0VEJDEgPSAnQUVFVWR3bWdEUzhCeFFLS0FQNEJPZ0RqQVRBQW5nRFVBSU1Bb0FCb0FPQUFhZ0NPQUVRQWhBQk1BSElBT3dBOUFDc0FOZ0FtQUdJQUhnQXVBQ2dBSndBWEFDMEFHZ0FqQUI4QUx3QVVBQ2tBRWdBZUFBa0FHd0FSQUJrQUZnQTVBQ2dBTFFBckFEY0FGUUFwQUJBQUhnQWlBQkFBR2dBZUFCTUFHQVVoQmU4QkZ4UkVOOHNGMndDNUFLNUhBVzhBclFrRHpRQ3VoemMzTnpjQlA2OE5FZk1BQlFkSEJ1dzVCVjhGWUFBOU16a0k5cjRaQmc3UXlRQVdBOUNlT3dMTkNqY0NqcWtDaHVBL2xtK1JBc1hUQW9QNkFTZm5FUUR5dFFGSkFqV1ZDa2VYQU9zQTZnb2RBQi9jd2RBVUUwV2xCQ04vQVFVQ1FSakZEL01SQmpIeERRU0pidzBqQnpVQXN3QnhtZSt0bkljQVl3YWJBeXNHOFFBakFFTU1teGNEcWdQS1F5RFhDTU14QTdrVVF3RDNOWE9yQUttRklBQWZCQzBEM3g0QkpRREJHZFVGQWhFZ1ZEOEpud21RSmlOV1lVenJnMG9BR3dBVUFCMEFGbk5jQUNrQUZnQlA5aDNnUGZzRE9XREtuZVkyQ2hnbFgxVURZRDMwQUJzQUZBQWRBQlp6SUdSQW53REQ4d0FqQUVFTXpSYkRxZ01CMnNBRll3WHFBdENuQXNTNEF3cFVKS1J0RkhzYWRVejlBTU1WYndMcEFCTTFOSkVYMFprQ2dZTUJFeU1BeFJWdkF1a0FFelVCVUZBdG1Vd1NBeTREQlRFUjMzRWZ0UUhmU3dCNU14Si9BamtXS1FMekw4RS9jd0JCNlFIOUxRRFBEdE85QVNOcmlRQzVEUUFOQXdDSzIxRUZJOTF6SHdDb0w5a0JxUWNIQndjSEt6VURvd0J2QVFvaFB2VTNmQVFnSHdDeUFjOENLUU1BNXpNU2V6cjdVTGdGbURwL0x6VlFCZ0VHQWk4RllRVmd0OEFGY1R0bFFocENXRW1mZTV0bVo2SUFFeHNEelE4dCtYOHJCS3RUQWx0YkFuMGpzeThCbDZ1dFBXTURUUjhFaTJrUkFOa0RCck5ITnlzREJ6RUNRV1VBY3dGcEoza0FpeVVoQUowQlViOEFMM0VmQWJmTkF6ODFLVXNGV3dGM1lRWnRBbTBBK1ZFZkF6RUpEUUJSU1FDekFRQmxBSHNBTTcwR0QvdjNJWldIQndBUktRQXhBTHNqVHdIWkFlTVBFem1YZ0lId0FCSUFHUUE4QUVVQVFEdDNnZHZJRUdjUVpBa0dUUkZNZEVJVkV3SzBENjRMN1JFZEROa3EwOVBnQURTeEIvTURXd2Z6QTFzRFd3ZnpCL01EV3dmekExc0RXd05iQTFzY0V2QWkyOGdRWnc5UUJIVUZsZ1dUQk40SWl5WlJFWWtITUFqYVZCVjBKaHhQQTAwQkJDTXRTU1E3bXpNVEpVcE1GRTBMQ0FRMlNteXZmVUFEVHpHelZQMlFxZ1BUTWxjNWRBa0dIbmtTcUFBeUQzc2tOYjFPaG5wUGNhZ0tVMCsydFlkSmFrNXZBc1k2c0VBQUNpa0ptMi9EZDFZR1JSQWZKNmtRK3d3M0Fia0JQdzN4Uzl3RTlRWS9CTTBmZ1JrZEQ5R1ZvQWlwTGVFTThTYm5McVdBWGlQNUtvY0Y4VXY0UE9FTFVWRnNEMTBMYVFubk9tZUJVZ01sQVJFaWp3cmhEVDBJY1JEM0NzMXZEZWtSU1FjOUE5bEpuZ0NwQndVTEZSMDVGYmttRkdLd0N3MDVld2IvR3ZvTGt5YXpFeTE3QUFYWEdpVUdVUUV0R3dNQTB5N3JoYlJhTlZ3Z1QyTUdCd3NwSThzVXJGQWtEU2xBdTNoTUdoOEhHU1d0QXBWRGRFcUxVVG9lbHlINlBFRU5haTRYVVlBSCtUd0pHVk1MaFR5aVJxOUZFaEhXUHBFOVRDSk5UREFFT1lNc015ZVBDZE1QaVF5OWZIWUJYUWtsQ2JVTWRSTTFFUnMzeVFnOUJ4MHhseWduR1FnbFJwbGduZ1Q3b3dQM0U5VUREd1ZEQ1VVSEZ3TzVIREVUTWhVdEJSR0JLTnNDOXpiWkxyY0NrMWFFQVJzRnp3OHBIK01RVkVma0R1MElud0pwQTRjbDd3QXhGU1VBR3lLZkNFZG5BR09QM0ZNSkxzOEl5MnB3STNnRGF4VHJaUkYzQjVVT1d3ZXJIRGNWd3h6bGNNeGVENFlNS0tlekNWOEJlUW1kQVdNRTV3Z05OVitNcENCRloxZUxYQmlmSUdWQlExNEFBalVNYVJXalJNR0hmQUtQRDI4U0h3RTVBWGNIUFEwRkFuc1I4UkZ2RUprSTc0WUlOYmt6L0RvcEJGTWhoeUFWQ2lzRFUyelNDeXNtL1F6OGJRR25FbVlERURSQmQvSm5yMkM2S0JnQkJ4MHl5VUZrSWZVTGxrL1JES0FheFJoR1ZESVo2QWZEQS9jYTl5ZnVRVnNHQXdPbkJ4YzZVVFB5Qk1FTGJRaVBDVU1BVFE2bkd3ZmJHRzRLZFl6VUFUV1BBYnVkQTF1Vmh3Snprd1k3Qnc4QWF3K0xCWDNwQUNFQ3F3aW5BQWtBMHdOYkFEMENzUWVoQUIwQWlVVUJRUU1yTXdFbDZRS1RBNWNJTmM4Qm1UTUI5eTBFSDhjTUdRRDdPMjVPQXNPMUFvQnVacVlGNFZ3Q2tnSk5PUUZSS1FRSlVrdFZBN04xNVFEZkFFOEdGK05MQVJtdlRzOGU1MGNCNDNNdkFNc0Evd0FKT1FjSlJRSFJBZmR4QUxzQll3czFDYWEzdVFGUjdTMEFod0FaYndIYkFvMEE0UUE1QUlQMUFWY0FVUVZkL1FYWEFsTk5BUlUxSEM5YlpRRy9BeU1CTndFUkFIMEd6NUdwelFzakJIRUgxd0lRSHhYbEF1OHlCN2tGQXlMakU5RkN5UUs5NGxrQU1ob0tQQXFyQ3FwZ1gyUTNDalYyUFZRQUVoK3NQc3MvVWdWVk8xYzdYRHRYTzF3N1Z6dGNPMWM3WER0WE8xd0RtOFBtdytZS2NGOUpZZThNcWczWVJNdzZUUlBmWUZWZ05oUE1MYnNVeFJYU0pWb1pRUnJBSndrbDZGVU5Ed2d0MTJZMENEQTBlUmZBQUVNcGJJTkZZNG9lTkFwUEhPdFRsVlQ4TFI4QXRVdW1NN01Oc0JzWlJFUUZTM1h4WWk0V0Vnb21BbVNGQW1KR1gxR3pBVjgzSkFLaCt3Sm9uQUptRFFLZmlEZ2ZEd0ptUHdKbUtnUnlCSU1EZnhjRGZwWTVDamw3R3ptR09pY25BbXdoQWpJNk9BNENiY3NDYmJMempnTTNhMGt2QVdzQTRnRGxBRTRKQjV3TWtRRUNEOFlBRWJrQ2R6TUNkcVpEQW5sUFJ3SjR2aUZnMzBXeVJ2Y0NmRU1DZXN3Q2ZRMENmUFJJQkVpQlp5Z0FMeGxKWEVwZkdSdEswQUxSQlFMUTBFc3JBNGhUQTRmcVJNbVJOZ0x5cFYwSEF3T3lTOUpNTVNrSDAwMVFUYk1DaTBNQ2l0ekZId3NoUjJzSnV3S09Pd0tPWUVTYmhRS08zUUtPWUh4UnVGTTVBUTVTMkZTSkFwUC9BcE1RQU8wQUlGVWlWYk5WMUFvc0h5bVppakxsZUdwRlB6MENsNk1DNzdaWUphd0FYU2tDbHBNQ2xvQ2dBSzFac0ZvTmhWRUFQd0tXdVFLV1VseElYTlVDbWM4Q21XaGN6bDBMSFFLY256bkdPcUVDbkJvQ241OENucnlPQUNFVE5TNFRBcDMxQXA2V0FMbEJZVGhoOHdLZTF3S2djZ0d0QXA2akl3S2VVcWxqekdRcktTOENKN01DSm9JQ29QOENvRkRiQXFZekFxWFNBcWdEQUlFQ3AvWm9nR2kxQUFkTmFpQnExUUtzNXdLc3NnS3Rhd0t0QmdKWElRSlY0QUt4NWRzREgxSnNtd0t5d1JFQ3N1d2JiT1J0WjIxTVl3TWwwUUsyWUQ5RGJwUURLVWtDdUdJQ3VVc1pBcmt1ZTNBNmNPVUN2UjBETGJZRE1oVUN2b3h5QmdNemRRSytIbk1tYzFNQ3c4OEN3d2h6aG5SUE9VbDA1QU04cXdFRFBKNERQY01DeFlBQ3hrc0N4aFNOQXNodFZRTElTQUxKVXdMSk1nSmtvUUxkMW5oOVpYaXllU2xMMUFNWXAyY0dBbUg0R2ZlVktIc1BYcFpldnhVQ3oyOEN6M0F6VDFmVzl4ZWpBTXF4QXM5M0FTM3VBMDRXZms4SkF0d3JBdHVPQXRKVEExSmdBMU5qQVFVRFZaQ0FqVU1FenhyeFpFbDVBNExTZzVFQzJzc0MyZUtFRklSTnAwQURocWtBTXdOa0VvWjFYZjBBV1FMZmFRTGV2SGQ3QXVJejdSZ0I4elFyQWZTZkFmTFdpd0xyOXdMcGRIMERBdXI5QXVyb0FQMUxBYjBDN28wQzY2Q1dycGNIQXU1REE0WGttSDF3NUhHbEF2TUhBRzBEamhxWmx3TDNGd09SY2dPU2l3TDNuQUw1M1FMNGFwb2dtcSsvTzVzaUE1MkhBdjcrQVI4QVBaOGdBWiszQXdXUkE2WnVBNmJkQU5YSkF3WnVvWXlpQ1EwRERFMEJFd0VqQjNFR1piMXJDUUMvQkcvREZZOGV0eEVBRzNrOUFDY0ROeEpSQTQyREFXY3JKUUNNOHdBbEFPYW5DNk9WQ0xzR0k2ZkpCZ0N2QlJuREJ2RWxSVVlGRm9BRmNEOUdTRE5DS1VLOFgza1pYOFFBbHMwRk9nQ1FWQ0did1RzdVlEb1p1dGNPTnhqT0dKSEovZ1ZmQldBRlh3VmdCV3NGWUFWZkJXQUZYd1ZnQlY4RllBVmZCV0JPSFFqZmpXOEtDZ29LYkY3eE13VFJBN2tHTjhQREFNTUVyOE1BNzBneEZyb0ZUajV4UG5oQ1IwSytYMzAvWC9BQVdCa3pzd0NOQnN4enpBU203MGFDUlM0ckRETWVMejQ5Zm5YZmNzSDVHY29zY1FGejEzWTRId1ZuQlhMSnljbkFDTmRSWXdnSUNBcUVYb1dUeGdBN1A0a0FDeGJaQnUyMUt3MEFqTXNUQXdrVkFPVnRKVVVzSjFKQ3VVTEVTVUFyWHk5Z1BpOUFLd25KUlFZS1REOUxQb0EraVQ1NFBua0NrVUxFVVVwRFg5TldWM0pWRWpRQWMxdzNBM0lCRTNZblgrZzdRaU1KYjZNS2Fpc3pSQ1V1UXJOQ3hEUE1DY3dFWDlFV0p6WVJFQkVFQndJSEtuNmwzM0pDTlZJZnliUEp0QWx0eWRQVUNtaEJady90RUtzWkFKT1ZKVTFDTFJ1eGJVSE9RQW83UDBzK2VFSkhIQThTSlZSUGRHTTBOVnJwdkJvS2hmVWxNMEpISEdVUVVoRVdPMXhMU2o4TU8wdWNOQXFKSXpWQ1J4djlFRnNxS3lBNE9RZ05qMm53WmdwNVpORmdFMkExSzNZSFMyQWhRUW9qSm1DN0RncHpHRzFXWUZVWkNRWUhaTzlnSFdDZFlJVmd1MkJUWUpsd0ZoOEd2UmJjWGJHOFlndERIck1Cd3pQVnlRb25IUWdrQ3lZQmdRSjBBamM0blZxSUF3R1NDc0JQSWdEc0szU1dFdElWQmE1TjhnR2pBbytrVndWSVp3RC9BRVVTQ0R3ZVg0SVRyUlFzSjhLM1R3QlhGRHdFQUIwVHZ6VmNBdG9UUzIwUkl3RGdWZ1o5QkJJbVlnQTVBTDRDb2k4TEZuZXpPa0NuSVFGakFZNEtCQVBoOVJjR3NnWlNCc0VBSmN0ZHNXSVJ1MmtUa1FzdFJ3N0RBY01CS2dwUEJHSUdNREF3S0NZbktUUWFMZzRBS1JTVkFGd0NkbCtZVVowSmRpY0ZEM2xQQWR0MUY5WlpLQ0d4dUUzeUJ4a0ZWR2NBL3dCRkVnaUNCd0FPTEhRU2p4T3RRRGcxejdkZUZSTUFaOFFUQUd0S2IxQXBJaVBIQURrQXZnS2lMeTFERnRZQ21CaURBbEREV05CMGVvN2ZwYU1PL2FFVlJSdjBBVEVRWkJJT0R5TUVBYzhKUWhDYkRSZ3pGRDRUQUVNQXU5WUJDZ0NzQU9rQW01STNBQndBWXh2T05uUitNaFhKQXhnS1F5eEwyK2trSmhNYmhRS0RCTWtTc3ZGMEFEOUJOUTZ1UUM3V3FTUUh3eEVBRUVJdTFoa2hBSDJ6NGlRUHd5SlBITldwZHlZQlJTcG5KQUx6b0JBRVZQUHNIMjBNeEEwQ0NFUUtSZ0FGeUF0RkFsTU53d2pFRFVRSlJBckVMdGFwTWc3RERaZ0pJdytUR3VrRUl3dkRGa01BcUF0REVNTU1CaGlvZStRQU8zTU1SQUFDcmduRUJTUFk5UTBGRG5iU0JvTUFCOE1TWXhrU3hBRUpBUElKQUFCOEZXTU9GdE1jL0hjWHd4aERBQzdEQXZPb3d3QWV3d0pkS0RLSEFBSERBQUxyRlVRVnd3QWJ3eXZ6cFdNV3Y4d0EvQUJwQXkrK2JjWURVS1BEMEtoREN3S21KMU1BQW1NQTUrVVp3eEFhZ3dpcEJSTC9lQURmdzZmREdPTUNHc09qazNsNkJ3T3BvNHNBRXNNT0d4TUFBNXNBYmNNT0FBdkRwME1KR2tNRHdnaXBuTklQQXdmSXFVTUdBT0dEQUFQekFCWERBQWNEQUFuREFHbVRBQnJEQUE3RENoakRqbkVXQXdBQll3QU9jd0F1VXlZQUJzTUFGOE1JS1FBTlVnQzZ3eTRBQThNQURxTXE4d0N5WWdBY0l3QUI4d3FwQUFYT0N4MFY0d0FIb3dCQ3d3RUtBR25EQUF1REFCM0RBQWpEQ2FrQUJkSUFicWNaM1FDWkNDa0FCZElBQUFGREFBZmpBQjJqQ0NrQUJxSUFDWU1BR3pNQWJTTUE1c09JQUFoakFBaERBQlREQkFrcEFBYlNBT09UQUFsREM2a096UHRuQUFkREFHNmtRRkFBVHdBS3d3d0FBME1BQ2JVRFB3QUhJd0FaZ3dBQ0U2Y0RBQW9qQUFwREFBb0RwL01Hd3dBSkl3QURFd0FRUXdnQUZFTUFFWE1BRDVNQURmTUFEY01BR1JNT0ZpTUFGVU1BYnFNV3V3SERBTUlBRTBNTEFHa3pFZ0RoVXdBQ1F3QUVXZ0FYZ3dVakFBYllBQmpEQlNZQmd6QmFBRUZOQUxjUUJ4VU1lZ0F3TW5nQnJBMElaZ0owS3hRSEJSRVBkMU4wWnpLUkp3YUlIQVpxTlQ0RHFRcThCd25nQUI0REF3dDJBWDU2VDFvY0tRTlhBaDFHQVRRR0MzdE94WU5hZ2tnQU1RQTVDUUFEQVFFQVd4TGpBSU9ZTkFFekFIN3RGUms2VGdsU0FGOE5BQWxZQVErUzFBQ0FRd1FvclFCaUFONGRBSjF3UHllVEFOVnp1UURYM0FJZUVNcDlleU1nWGlVQUVka0JrSml6S2x0YlZWQWFSTXFSQUFFQWh5US9TREV6NkJtZlZ3QjZBVEVzT0NsS0lSY0RPRjBFLzgzMkFGTnQ1QUJ5QW5rQ1J4R0NPczk0TmpYZEF3SU5HQm9uREJ3UEFMVzJBd0lDQWdBQUFBQUFBQVlEQlFNREFSclVBd0F0QUFBQUFnRUdCZ1lHQmdZRkJRVUZCUVVFQlFZSENBa0VCUVVGQlFRQUFBSUNBQUFBSWdDTkFKQUFsVDBBNmdDN0FOd0FwRVFBd2dDeUFLMEFxQUR1QUtZQTJnQ2pBT2NCQ0FFREFNY0FnUUJpQU5JQTFBRURBTjRBOGdDUUFLa0JNUURxQU44QTNBc0JDUTh5TzlyYTJ0cTh4dUxUMXRSSk9CMEJVZ0ZjTlUwQldnRnBBV2dCV3dGTVVVbExiaE1CVXhzTkVBczZQaE1PQUNjVUt5MHZNajVBUUVORFEwUkZGRVlHSkZkWFYxZFpXVmhaTDFwYlhWeGNJMk5uWjJab1p5cHNibloxZUhoNGVIaDRlbnA2ZW5wNmVucDZlbnA4ZkgxOGUySUFSUElBU1FDYUFIZ0FNZ0JtK0FDT0FGY0FWd0EzQW5idkFJc0FCZmo0QUdRQWsvSUFud0JQQUdJQVpQLy9zQUNGQUlVQWFRQldBTEVBSkFDMkFJTUNRQUpEQVB3QTV3RCtBUDRBNkFEL0FPa0E2UURvQU9ZQUx3SjdBVkVCUUFFK0FWUUJQZ0UrQVQ0Qk9RRTRBVGdCT0FFY0FWZ1hBREVRQ0FFQVV4OFNIZ3NkSGhZQWpnQ1dBS1lBVVFCcUlBSXhBSFlBYndDWEF4VURKeklESVVsR1R6RUFrUUpQQU1jQ1Z3S2tBTUFDbGdLV0FwWUNsZ0tXQXBZQ2l3S1dBcFlDbGdLV0FwWUNsZ0tWQXBVQ21BS2dBcGNDbGdLV0FwUUNsQUtVQXBRQ2tnS1ZBblVCMUFLWEFwOENsZ0tXQXBVZUFJRVRCUUQrRFFPZkFtRUNPaDhCVkJnOUF1SVpFak1iQVU0L0cxV1pBWHVzUkFGcFlRRUZBMEZQQVFZQW1URWVJSmR5QURGb0FIRUFOZ0NSQTV6TWsvQzJqR0lOd2pNV3lnSVpDYVhkZkRJTEJDczVkQUU3WW5RQnVnRGxob2lIaG9pR2lZcUtob3VPaklhTmtJNklqNHFRaXBHR2tvYVRocFNTbFlhV2hwZUttSWFaaHBxR200YWNpNTJRbm9xZmh1SUM0WFRwQXQ5MEFJcDBMSFNvQUlzQWRIUUVRd1JBQkVJRVJRUkRCRWtFUmdSQkJFY0VTUVJJQkVRRVJnUkpBSjV1ZEFDckE0OTBBTHh1QVExMEFORlpkSFFBMTNRQ0ZIUUEvbUowQVA0QklRRCtBUHdBL0FEOUFQd0RoR1owM0FTTUsyM0hBUDRBL0FEOEFQMEEvQ1IwZEFDUlluUUEvZ0NSQVNFQS9nQ1JBdlFBL2dDUkE0Um1kTndFakN0dHh5UjBBUDlpZEFFaEFQNEEvZ0Q4QVB3QS9RRDhBUDhBL0FEOEFQMEEvQU9FWm5UY0JJd3JiY2NrZEhRQWtXSjBBU0VBL2dDUkFQNEFrUUwwQVA0QWtRT0VablRjQkl3cmJjY2tkQUpMQVQ1MEFsSUJRWFFDVThsMGRBSmZkSFFEcGdMMEE2WURwZ09uQTZjRHB3T25BNFJtZE53RWpDdHR4eVIwZEFDUlluUUJJUU9tQUpFRHBnQ1JBdlFEcGdDUkE0Um1kTndFakN0dHh5UjBCRGgwQUpFRU9RQ1JEcFU1ZFNnQ0FEUjAzZ1YyQ3dBcmRBRUZBTTVpQ25SMEFGMWlBQVljT2dwMGRBQ1JDblFBWEFFSXdXWjBDblJtZEhRQWtXWjBDblJtZEVYZ0FGRjAzZ3AwZEVZMHRsVDJ1M1NPQVFUd3Njd2hqWlpLcmhZY0JTZkZwOVhOYktpVkRPRDJiK2NwZTQvWjE3bVFuYnR6emhhZVF0RTJHR2owSUROVGpSVVN5VHh4dy9SUEhXLyt2UzdkMU5mUnQ5ejlRUFpnNFg3UUZmaENua3ZnTlBJSXRPc0MyZVY2aFBhbm5aTkhsWjl4cndaWElNT2x1M2pTb1FTcTc4V0Vqd0xqdzFFTFNsRjFhQnZmendrNVpYN0FVdlF6alBRS2JEdVErc200d05PcDRBNkFkVnVSUzB0MXkvRFpwZzRSNm03Rk5qTTlIZ3ZXN0JpODh6YU1qT282bE04d3RCQmRqOExQNHlsdjN6Q1hQaGViTUtKYzA2Nm85c0Y3MW9GVy84Slh1ODZISmJ3RElENWx6dzVHV0xSL0xoVDBRcW5wMkpReE5aTmZjYkxJelB5K1l5cHFSbS9sQm1HbWV4KzgyK1Bpc3hVdW1TZUprQUxJVDZySmV6eE1IK0NUSm1RdHQ1dXdUVmJMM3B0bWpEVVF6bFNJdldpOFRsN25nMU5wdVJuMU5nNG4xNFFjKzNJaWw3T3drdk5Xb2dMU1BrbjNwaWhJRnl0eUlHbU1oT2UzbjF0V3N1TXk5QmRLeXFGNFozdjJTZ2dnVEw5S1Z2TVhQbkNiUmUrb091RkZQM0hlakJHL3c5Z3ZtZk5Zdmc2SnVXaWEybGNTU04xdUlqQmt0em9JYXpPSFBKWjdrS0hQejhtUldWZFczbEE4V0dGOWRRRjZCbTY3M2Jvb3YzQlVXRFUySk5jYWhSMjNHdGZIS0xPei92aVorclluWkZhSXpuWE82N0NZRUoxZlh1VFJwWmhZWmtLZTU0eGVvYWdrTkdMcytOVFpIRTByWDQ1L1h2UTJSR0FEWDZ2Y0F2ZHhJVUJWMjd3eEdtMnpqWm80WDNJTGdBbHJPRmhldVo2d3RzdmFJajR5TFk3cXFhd2xsaWFJY3J6MkcrYzN2c2NBbkNrQ3VNek1tWnZNZnU5bEx3VHZmWCszY1ZTeVBkTjlad2dEWmhmalJnTkpjTGlKNjdiOXh4OEpIc3dwcmJpRTN2OVVwaG90QVBJZ25YVklONUttTWMwcGlYaGM2Y0NoUG5OK01SaEc5YWR0ZHR0UVRUd1NJcGw4STQvai8vZDNzejEzMjZxVEJUcFBSTS9IZ2gza3pxRVhzOFpBazRFclFoTk84aHpyUTBETGtXTUEvTis5MXRuMk1kT0puV0MyRkNaZWhrUXJ3endiS09qaHZac2JNOTVRb2VMOXNrWXlNZjRzclZQVkpTZ2c3cE9MVXRyL245ZVQ5OW9lOW5MdEZScGpBOW9rVjJLajhoOWs1SGFDMG9pdlJEOFZ5WGtKODF0Y2Q0ZkhOWFBDZmxvSVFhc3hzdU8xOC80NmRSMmpndWwvVUlldDJHMGtSdm55T05NS2hIczZKMjZGRW9xU3FkK3JmWWplRUd3SFdWRHBYMWZoMWpCQmNLR01xUmVwanU5WTAwbURWSEMrWGRpai9qNDRyS2Z2ZmpHaW5OczFqTy8wRjNqQjgzWENESU5OL0hCODRheGxQKzNFL2tsa3RSbyt2bDNVL2FpeU1KYklvZEUxWFNzRG42VUF6SW9NdFVPYlkyK2svNGdZL2wrQWtaSjVTajJ2UXJreUxtM0ZveGpoRFgrMzFVWEJGZjlYckFIMzFmRnFvQm1ERVp2aHZ2cG5aODdOK29aRXU3VTlPL25uaytRV2ozeDh1eW9SYkVuZitPNVVNcjlpMG5IUDM4SUY1QXZ6ckJXOFlXQlVSMG1JQXpJdm5kUXE5TjN2L0p0bzNhUGpQWFVQbDhBU2RQUHlBcDdqRU5mOGJrN1ZNTTlvbDlYR21sQm1lRE11R3F0K1d6dUw2Q1hBeFhqSWhDUE01dkFDY2hnTUovOFhCR0xPL0QxaXNWdkdod3dISHIxRExhSTVtbjJKci9iMXBVRDkwdWNpRGFTOGNYTkR6Q1d2Tm1UL1BoUWU1ZThuVG5ubmt0OERzL1NJamliY3VtL2ZxRGhLb3B4QVk4QWtTclBuK0lHREVLT08rVTNYT1A2ZGpGczJINU45K29yaE9haGlRazVLbkVVV2ErQ3prVnpocDhiTUhSYmc4MXFoampYdUlLYkhqU0xTSUJLV3FvY2tHdEtpblkrejQvUmRCVUY2cGNjM0ptbmx4VmNOZ3JJNFNFektVWlN3Y0QyUUN5eHpLdmUrZ0FtZzZadVNSa3BQRmE2bWZUaHU3TEpOdTNINUs0MnVDcE52UEFzb2Vkb2xLVi9MSGUvZUorQmJhRzVNRzBOYVNHVlBSVW1ORk1GRlNTcFhFY1h3YlZoN1VFVE9aWnRvVk5SR09JYmJraWczTWNFdFI2OGNHMFJaQW9KZXZXWW83RGcvbFoxQ1F6YmxXZVV2VkhtcjhmWTROcWQ5SkppSC96RVgyNG1KdmlINjBmQXlGcjBBM2M0YkMxajN5WlU2MFZnSnhYbjhKZ0pYTFVJc2lCbm1LbU1Zeis3eUJRRkJ2cWIyZVludVc1OWpvWkJmNTYvd1h2V0lSNFI4d1RtVjgwaTFtWnkrUzQrQlVFUytoemprMHVYcEMvLy96L0lscUhaMW1vbnpsWHA4YUNmaEdLTXRpNzNGSTFLYkwxcTZJS080ZnVCdVo1OWdhZ2puNXhVNzltdU1wSFhnNlMrZStnRE0vVTlCS0xIYmw5bDZvOGN6UUtsNFJVa0pKaXFmdFFHMmkzQk1nL1RRbFVZRmtKRFlCT092QXVnWXV6WVNEblpiRERkL2FTZDl4ME9lNkYrYkpjSGZsOStncDZMNS9UZ0ErQmRGRm92YmZDclE0MHM1dk1Qdzg4NjZwTlg4enlGR2VGV2R4SXBQVnA5UmcxVVBPVkZiRlpydmFGcS9ZQXpIUWdxTVdwYWhNWWZxSHBtd1hmSEwxL2twWW1HdUhGd1Q1NW1RdTBkeWxmTnVxMk9xMGhUTUNQd3FmeG51QklQTFhmY2k0WTFBTnkrMUNVaXBReGxkL2l6VmgxNld5RzJRMENRUTlOcXRBbngxSENId0RqN3NZeE9TQjB3b3BaU25PenhRT2NFeG14clZURjJCa090aFZwR2Z1aGFHRUNmQ0pwSktwam5paFkreE9UMlFKeE42MSs5SzZRU3F0djJTaHI4MkkzamdKcnFCZzB3RUxGWlBqdkhwdnpUdGFKbkxLNlZiOTdZbjkzM2tvTy9zYU43ZnNqd05LenA0bDJsSlZ4Mm9yakNHekMvNFpMNHpDdmVyNmFRWXRDNXNkb3ljaHVGRTZ1Zk9pb2crVldpNVVEa2Jtdm10YWgvM2FBckVCSWkzOXM1SUxVbmxGTGdpbGNHdXo5Q1FzaEVZN2Z3Mm91b0lMQVlQVlQvZ3lBSXEzVEZBSXdWc2wra3RrUnovcUdmbkNER3JtNWdzbC9sOVFkdkNXR3NqUHozZFU3WHVxS2ZkVXJyLzZYSWdqcDRyZXk2QUpCbUNtVUpNaklUSFZkRmI1bTFwK2RMTUNMOHQ1NXpENDJjbWZ0bUxFSkMwRGEwNFlpUkNWVUJMTGE4RDA3MS9ONVVCTkJYRGgwTEZzbWhWLzVCNUV4T0I0ajNXVkcvUzNsZks1bytWNkVMSHZ5NlJSOW40YWMrVnNLNFZFNHlwaFB2VitrRzlGZWdUQkg0WlJYTDJIeXRVSENkdUphekIvS3lramZldFl4T1hUTHdzMjY3YUdPZCtJK0poS1AvLytWblhtUzkwT0QvanZMY1Z1MGFzeXFjdVlOMW1TYjZYVGxDa3F2MXZpZ1pQSVl3TkYvenBXY1QxR1IvNmFFSVJqa2gweWhnNExYSmZhR29iWUpUWTRKSTU4S2lBS2dtbWdBS1dkbDVuWUNlTHFhdlJKR1FOdVl1WnRaRkd4K0lrSTR3NE5TMnh3YmV0Tk11bk9qQnUvaG1LQ0kvdzd0ZmlpeVVkLy80cmJUZVd0NGl6Qlk4WXZHSU42dnlLWW1QLzhYOHdIS0NlTitXUmNLTTcwK3RYS05HeWV2VTlIMkRnNUJzbGpuVGY4WWJzSjFUbU1zNzRDZTJYbEhpc2xlZ3VoeWVnNDRyUU9IWnV3LzZIVGtobm51cksyZDYycTZ5UzcyMTBTc0FJYVIralhNUUErc3Zrckxwc1VZK0YzMFV3ODl1T2RHQVI2dm80RklNRTBFZlZWZUhUdTZlS2ljZmhTcU9lWEpoYmZ0Y2QwOHNXRW5OVUwxQzlmbnByVGdkODNJTXV0OG9uVlVGMGh2cXpaZkhkdVBqYmp3RVhJY29ZbXkrUDZ0Y0paSG1lT3Y2VnJ2RWRrSERKZWNqSHVIZVdBTmU3OVZHNjYycVRqQS9IQ3Z1bVZ2M3FMK0xyT2NwcUdwczJaR3dRZEZKN1BVNGl1eVJsQnJ3Zk8reG5QeXI0N3MyY1hWYld6QXl6bkRpQkdqQ00za3N4ampxTTYyR0U5QzhmNVUzOGtCM1ZqdGFiS3AvblJkdk1FU1BHREc5MGJXUkxBdDFRazVEeUx1YXpSUjFZemRDMWMraFpYdkFXVjh4QTcyUzRBOEI2N3ZqVmhiYmEzTU1vcDI5M0ZlRVhwZTd6SXRNV3JKRy9MT0g5QnlPWG1Zbk5KZmptZnVYOUticnBnTE9iYTRuWitmbDhHYmR2L2lodis2d0ZHS0hDWXJWd21oRkMwSjNWMmJuMnRJQjF3Q2MxQ1NUM2QzWDJPeXhoZ3VYY3M0c202NzlVbmd6b2Z1U2VCZXdNRkpib0lRSGJVaC9tMkpoVzJoRzlESXZHMnQ3eVpJektCVHo5d0J0bk5DKzJwQ1JZaFNJdVExajh4c3o1VnZxbnlVSXRodnVveXl1N2ZOSXJnL0tRVVZtR1FhcWtxWmsvVng1YjMzL2dzRXM4eVg3U0MxSitOVjRpY3o2YnZJRTdDNUc2TWNCYUk4clZnNTZxNVFCSld4bi84N1Exc1BLNCtzUWE4ZkxVNWdYbzRwYWFxNGNPY1E0d1IwVkJIUEdqS2grVWxQQ2JBMW5MWHlFVVg0NXFaOEo3L0xuNEZQSkUyVGR6RDBaOE1MU05RaXlrTU1tU3lPQ2lGZnk4NFJxNjBlbVlCMnZEMDlLall3c29JcGVEY0JEVEVsQmJYeE5ENzJ5aGQ5cEMvMUNNaWQvNUhVTXZBTDI3T3RjSUpEek5LcFJQTnFQT3B5dDJhUEd6OVFXSXM5aFE5TGlYNXM4bTloalRVdS9mN015SWF0ampkK3RTZlEzdWZaeFBwbUpoVGFCdFp0S0xVY2ZPQ1VxQUR1TytRb0g4Qjl2NlUrUDBIVjFHTFFtdG9ORlRiM3M3NGl2WmdqRVMwcWZLKzhSZEdnQmJjQ01TeThlQnZoOTgrZXQxS0lGcVNlMUtRUHlYVUxCTVRzSVlueXNJd2laQkpZZEkyMHZzZVYrd3VKa2NxR2VtZWhLamFBYjlMNTd4Wm0zZzJ6WDBiWjJ4ay9mVStiQ283VGxuYlc3SnVGMVlkVVJvLzJHdzdWY2xERzFXN0xPdGFzMkxYNHVwaWZaLzIzcnpwc25ZL0FMZlJncmNXUDVoWW1WOVZ4Vk9RQTFmWnZwOUYyVU5VKzdkN3hSeVZtNXdpTHAzLzBkbFY3dmR3MVBNaVpyYkRBWXpJVnFFalJZMllVMDNzSmhQbmx3SVBjWlVHNWx0TDZTOFhDeFUxZVlTNWNqcjM0dmVCbVhBdnk3eU40WmpBcklHMGRmRC81VXBCTmxYMVpQb3hKT3d5cVJpM3dRV3RPemQ0b05LaDBMa29UbThjd3FnSWZLaHFxR09od283MUkrelhuTWVtVHYyQjJBVXpBQld5Rnp0R2dHVUxqRER6V1l3SlVWQlRqS0NuNUsyUUdNSzFDUVQ3U3p6aU9qbytCaEFtcUJqenVjM3hZeW0yZWVkR2VPSVJKVnlUd0R3MzdpQ01lNGc1VmJuc2I1WkJkeE9Bbk1UN0hVNERIcHhXR3VRN0dlaVkzMENwYnZ6c3M1NSs1S20xWXNiRDVlYTNOSTlRTllJWG9sNWFwZ1N1OWRaOGY4eFM1ZHRIcGlkbzVCY2xEdUxXWTRsaGlrMHRiSmEwN3lKaEgwQk95RXV0L0dSYllUUzZSZmlUWVdHTUNrTnBmU0hpN0h2ZGlUZ2xFVkhLWlhhVmhlekg0a2tYaUl2S29wWUFsUHVzZnRwRTRhNUlad3Z3MXgvZUx2b0RJaC96cG85RmlRSW5zVGIyU0FrS0hWNDJYWUJqcEpEZzQzNzRYaVZiM3dzNHFNMHM5ZVNRNUh6c01VNE9aSkt1b3BGakJNK2RBWkVsOFJVTXg1dVUyTjQ4NktyMTQxdFZzR1FmR2pPUllNQ0pBTXN4RUxlTlQ0Um1XalJjcGRUR0J3Y3g2WE45ZHJXcVBtSnpjckdySDQrRFJjNytuMXcza1Bad3UwQmtOcjZoUXJxZ283SlRCOUE1a2RKL0g3UDRjV0JNd3NtdWl4QXpKQjN5clFwbkdJcTkwbHhBWEx6RENkbjFMUGlic1J0N3JITmpnUUJrbFJnUFo4dlRialhkZ1hyVFdRc0s1TWRyWFhRVlBwMFJpbnEzZnJ6WktKMHFENlFoYzQwVnpBcmFVWGxvYjFndmtoSzN2cG1IZ0k2RlJsUVpOeDZlUnFrcDB6eTRBUWxYODEzZkFQdEwzak1SYWl0R0ZGam8wem1FcmxvQytoK1lZZFZRNms0Ri9lcHhBb0YwQm1xRW9LTlR0Nmo0dlFaTlEyQm9xRjlWajUzVE9Jb05tRGl1OVhwMTVSa0lnUUlHY29McGZvSWJlbnpwR1VBdHFGSnA1VytMTG54MzhqSGVFQ1RKL25hdktZMU5XZk4wc1kxVDgvcEI4a0lIM0RVM0RYK3U2VzNZd3B5cEJNWU9oYlN4R2pxODRSWjg0ZldKb3c4cHlIcW40Uy85SjE1RWNDTXNYcXJmd3lkOW1oaXUzK3JFbzlwUHBvSmtkWnFIanJhNE52ekZ3dVRoTkt5Nmhhby9TbEx3M1pBRFVjVXAzdzNTUlZmVzJyaGw4MHpPZ1RZbktFMEhzMnFwMUo2SDN4cVBxSWt2VURSTUZEWXlSYnNGSTNNOU1FeW92UGs4cmx3Ny8wYTgxY0RWTG1Cc1IyemUycEJ1S2IyM2ZiZVpDMHVYb0l2RHBwZlR3SUR4azFPcTJkR2VzR2Mrb0pYV0pMR2tPaGEzQ1grRFVuemdBcDlIR0g5UnNQWk42M0huNFJNQTVlU1ZoUEhPKzlSY1JiL0lPZ3RXMzFWMVE1SVBHdG94UGpDK01FSmJWbElNWUFEZDlhSFlXVUlRS29wdVBPSG1vcVNrdWJuQUtuemdLSHFnSU9mVzVSZEFnb3RONkJOK08yWllIa3VlbUxudlE4VTlUSFZyUzFSdExtS2JjQzdQZWVEc1l6bnZxemVnNlZDTndtcjBZeXgxd25ManlUODRCWnozRUp5Q3B0RDN5ZXVlQXlEV0lzMEwycXMvVlEzSFV5cWZyamEwVjFMZER6cUFpa2VXdVY0c2M3UkxJQjY5akVJQmpDa3laZWRvVUhxQ3JPdlNoVnp5ZDczT2RySlcwaFBPdVF2MnFPb0hEYzl4VmI2WXU2dXEzWHFwMlphSDQ2QTdsemV2YnhRRW1mcnp2QVlTSnVaNFdEazFIejNRWDFMVmRpVUswRXZsQUdBWWxHM01kMzByN2RjUE42M3lxQkNJajI1cHJwdlpQMG5JNCtFZ1dvRkc5NVY1OTZDdXJYcEtSQkdSalFsSEN2eTVJYi9pVzhuWkpXd3JFVDNtZ2Q2bUVoZlA0S0N1YUxqb3BXczdoK01kWEZkSXY4ZEhRSmdnMXhpMWVZcUIwdURZanh3Vm1yaTBTdjVYS3V0L29ucWFwQytGUWlDMkMxbHZZSjlNVmNvNnlEWXNTM0FBTlVmTXR2dGJZSTJoZndaYXRpU3Nub1VlTVpkMzRHVmprTU1LQStYbmpKcFhnUlcyU0hUWnBsVm93UG1Kc3ZYeTZ3M2NmTzFBSzJkdnRaRUtUa0MvVFk5TEZpS0hDRzBEbnJNUWRHbTJsemxCSE05aUVZeW5IMlVjVk1oVUVqc2Mwb0RCVGdvMlpTUTFnemtBSGVXZUJYWUZqWUx1dWY4eXpUQ3k3L1JGUjgxV0RqWE1icTJCT0g1ZFVSbnhvNm9pdm14TDNjS3pLSW5sWmtEMzFudnBIQjlLazdHZmNmRTF0KzFWNjRiOUx0Z2VKR2xwUkZ4UUNBcVdKNURvWTc3c2tpOGdzT0VPcjJ1eXdaYW9PL05HYTBYMHkxcE5RSEJpM2IyU1VHTnBjWnhEVDdyTGJCZjFGU25ROGd1eEdXM1crMzZCVzBnQmplNERPejZCYTZTVmsweGlLZ3QrcTJKT0Z5cjRTWWZudStJYzFRWllJdXdIQnJnenI2VXZPY1NDelBUT283RDZJQzRJU2VTN3prbDRoKzJWb2VIcG5HL3VXUjMreXNOZ1BjT0lYUWJ2MG40bXIzQndRY2RLSnhnUFNleXVQL3oxSmpnNGU5blV2b1hlZ3FRVklFMzBFSHg1R0h2K0ZBVlVOVG93WURKZ3lGaGY1SXZsWW1FcVJpZjYrV04xTWtFSm1EY1FJVHg5RlgyM2E0bXh5MUFRUnNPSE8vK2VJbVg5bDhFTUpJM29QV3pWWHhTT2VIVTFkVVdZcjJ1QUE3QU1iK3ZBRVpTYlUzcW9iOWliQ3lYZXlwRU1wWjY4NjNvNlFQcWxxR0haa3VXQUJTVFZOZDRjT2g5aHYzcUVwU3gyWnkvREpNUDZjSXRFbWlCSjVQRnFRbkRFSXQzTnJBM0NPbE9TZ3o0M0Q3Z3BORk5KNU1CaDRvRnpoRFBpZ2xDMnlwc05VNElTeXdZMmVya3liMU5DM1FoL0lmV2owZURnWkk0L2xuOFdQZkJzVDNtZVRqcTFVcXQxRTdabC9xZnRxa3g2YU05S3VlTUNla1NuTXJjSGoxQ3FUV1d6RXpQc1pHY0RlM1VlNFdzK1hGWVZ4TmJPRkY4ZXprdlFHUjZaT3RPTFUybFFFbk1CU3R4NDd2RTZQYjdBWU1CUmoyT09mWlhmaXNqSm5wVGZTTmpvNnNaNnFTdk54Wk5tRGVTN0drM3lZeUNrMUh0S04yVW5oTUlqT1hVekFxRHY5MGx4OU8vcS9BVDFaTW5pdDVYUWU5d21ReG5FL1dTSDBDcVo5LzJIeStTZm1wZWc4UndzSEk1WjhrQzhIMjkzbS9MSFZWTS9CQTdIYVRKWWc1RW5rN00veFdwcTAxOTJBQ2ZCYWkyTEEvcXJDakNyNkRoMUJJTXpNWElOQm1YOTZNSjVIbjJueGxuL1JYUEZod0h4VW1TVjBFVjJWMGptODYvZHh4dVlTVTFXN3NWa0ViTjlFemtHMFFGd1BoeUhLeWIzdCtGajVXb1VVVEVyY2F6RS9ONkVXNkx2cDBkLy9TRFBqN0VWOVVkSk4rQW1uZjNXd2szQTBTbEo5WjAweXZYWjduM3o3MEc0N0hmc293OFdxMUpYY2Z3bkErWXhhNW1Gc2dWNDY0S0tQNFQzMXdxSWd6RlBkM2VDZTNqNW9yeTVmQkYyaGdDRnlWRnJMekk5ZWV0Tlh2TTdvUXF5RmdEbzRDVHAvaERWOU5NWDlKREhRL255SFRMdlpMTkxGNmZ0bjJPeGpHbTgrUHFPd2h4blBIV2lwa0UvOHdidHlyaTgwU3I3cE1Oa1FHTWZvNFpZSzlPY0NDNEVTVkZGYkxNSXZseFNvUnFXaWUwd3hxbkxmY0xTWE1TcE1NUUVKWURWT2JZc1hJUU52NFRHTndqcTFrdlQxVU9raWNUckczSWFCWjNYZFNjUzN1OHNnZVpQVnBPTGtiaUY5NDBGamJDZU5SSU5OdkRiZDAxRVBCclRDUHBtMTJtNDN6ZTFiQkI1OUlhNk92aG51ci9OdngzSXh3U1dvbCszSDJxZkNKUjhkZjZhUWY0djZXaU9OeGtLK0lxVDRwS1FyWksvTHBsZ0RJL1BKWmJPZXA4ZHRiVjdvQ3I2Q2dmcFdhOE5jek9rUHg4MWlTSGJzTmhWU0pCT3RyTElNckwzMUxLOVRxSHFBYkFIZTBSTG1tVjgwNmtSTERMTkVoVUVKZm05dTBzeHBrTDkzWmdkNnJ3K3RxQmZUTWk1OXhxWEhMWFNId1NiU0JsMEVLMCtsb0VDT1B0cmwrL25zYUZlMTk3ZGk0eVVnb2U0aktvQUpEWGM2REdEanJRT29GRFdaSjlIWHd0OHhEclFQKzdhUndXS1dJMUdGOHM4TzRLenhXQkJjd25sM3ZubDFPZXozb2g2RWExdmpSNy96N0REVHJGdHFVMlcvS0FFekF1WEROWjdNWTczTUYyMTZkemRTYldtVXA0bGNtN2tlSmZXYU1IZ3V0OXg1QzltajY2WjBsSit5aHNqVnZ5aVdyZmsxbHpQT1RkaEcxNVk3Z1FsWHRhY3ZJN3F2L1hOU3NjRHdxa2d3SFQvZ1VzRDV5QjdMZFJSdkp4UUdZSU5uOWhUcG9kS0ZWU1RQcnRHdnlRdytIbFJGWElrb2RFckFHdTlJeTFZcGZTUGMzamtGaDVDWDNsUHh2N2FxakUvSkFmVElwRWpHYi9IN01PMGUydnNWaVNXMXFhL0xtaTQvbjRERUkzZzdsWXJjYW5zcERmRXBLa2RWMU9qU0xPeTBCQ1VxVm9FQ2FCNTV2czA2clhsNGpxbUxzUHNGTS83dllKMHZyQmhEQ20vMDBBL0g4MWwxdWVrSi82TG1sM0hiOStOS2lMcUFUSm1EcHl6ZllaRkh1bUVqQzY2MkwwQndreGk3RTlVNGNRQTBYTVZEdU1ZQUllTE1QZ1FhTVZPZDhmbXQ1U2ZsRklmdUJvc3plQXc3b3c1Z1hQRTJZL3lCYy83akV4QVJVZi9CeElIUUJGNVNuM2k2MXc0ejV4SmRDeU8xRjFYMyszYXgrSlN2TWVaN1M2UVNLcDFGcC9zall6NlorVmdDWnppYkdlRW91anJ5Zk11bEg3UmFpNWtBZnQ5ZWJjVzUwRHlKcjJ1bzJ6OTdtVFdJdTQ1WXNTbk5TTXJyTlV1RzFYc1lCdEQ5VERZelFmZktCODd2V2JrTTRFYlBBRmdvQlY0R1FTK3Z0RkRVcU9GQW9pMW5UdG1JT3ZnMzhONGhUMlNuOHI4Y2xtQkNYc3BCbE1CWVRucnFGSkdCVDN3Wk96QXlKRHJlOWRISDcreDdxYWFLRE9CNFVRQUxENWVjUzBERTRvYnViUUVpdUpaMEVwQlZwTHVZY2NlOEFhNFBZZC9WNERMREFKQllLUVBDV1RjckVhWjVIWWJKaTExR2Q2aGpHb20xaWkxOFZIWW5HMjhOS3BrejJVS1ZQeGxoWVNwOHVacjM2N2lPbW95N3pzeGVoVzl3emN5MnpHMGE4MFBCTUNSUU1iMzJobmFIZU9SOGZuTkR6WmhhTlloa09kRHNCVVozbG9ETWExWVAwdVMwY2pVUDNiLzZEQmxxbVpPZU5BQkRzTGw1Qkk1UUp1cHM4dXhBdVdKZGtVQi9wTzZaYXg2dHNnN2ZONW1qakRnTUduZ08rRFBjS3FpSElEYkZJR3VkeHRQVEl5RGk5U0ZNS0JEY2ZkR1FSdjQxcTFBcW14Z2tWZkpNblA4dy9CYzdOOS9UUjZDN21HT2JGcUZrSUVvbThzS2kyeFlxSkxUQ0hLN2N4emFadnFPRG8yMmMzd2lzQkNQNEhlQWdjUmJOUEFzQmtOUmhTbUQ0OGRIdXBkQlJ3NG1JdnRTNW9lRjZ6ZVQxS01DeWhNbm1ocGtGQUdXbkdzY29Oa3d2UThaTTVsRS92Z1RIRllMOTlPdU54ZEZCeFRFRGQ1djJxTFI4eTlXa1hzV2dHNmtaTm5kRkcrcE8vVUFrT0NpcHFJaEwzaHE3Y1JTZHJDcTdZaFVzVG9jRWNuYUZhNm5Wa2huU2VSWVVBMVlPMHo1aXRGOVNseTNWbHhZRHcyMzlUSkpINmYzRVVmWU81bGI3YmNGY3o4QnA3T284UW1uc1VIT3ovZmFnVlVCdEtFdzFpVDg4aithS2t2OGNzY0tOa014allyODM0NEQxa0ZvWjcvdGQxVzZMQ05ZTjU5NDMwMXRVR1JtRmpBemVSZzV2eW9NMUY2K2JKWi9RNTRqTi9rOFNGZDNEeFBUWWFBVXNpdnNCZmdUbjdNeDhIMlNwUHQ0R09kWVJuRUpPSDZqSE0ycDZTZ0IwZ3pJUnE2Zkh4R01tU21xYVBDbWxmd3hpdWxvYVZJaXRMR044d2llMkNEV2hrekxvQ0pjT0RoN0tJT0FxYkhFdlhkVXhhUzRUVFRzMDdDbHpqLzZHbVZzOWtpWkRlck14RW5oVUI2UVFQbGNmcWtHOTg4MlJxSG9MaUhHQm9IZlF1WElzQUc4R1RBdGFvMktWd1JudnZhbThqbzFlMzEyR1FBS1dFYTRzVVZFQU1HNEc2Y2tjT05Ed1JjZzFlMkQzK29oWGdZNFVBV0Y4d0hLUU1yU256Q2dmRnBzeGgrYUhYTUd0UFFyb1Fhc1JZNFU2VWRHMHJ6MVZqYmthME1la09HUlpRRXZxUUZseHNlRm9yOHpXRmdIZWszdjI5K1dxTjZnYUs1Z1pPVE9NWnpwUUlDMTIwMUxrTUNYaWxkM3ZXWFNjNVVYOXhjRllmYlJQekdGYTFGRGNQZlBCL2pVRXEvRmVHdDQxOUNJM1ltQmxWb0hzYTRLZGN3UVA1WlN3SEhoRko3L1BoL1JhcC80dm1HOTFlRHdQUDBsRGZDRFJDTHN6VHFmek03MXhwbWlLaTJId1M0V2xxdkdOd3R2d0Y1RHFwbjZLVHE4YXgwMFVNUGt4RGNackVFRXNJdkhpVVhYRXBoZGI0R0I0RnltbFB3Qno0R3BlcnFxNXBXN1RRNi95TlJoVzhWVDVOaHVQMHVkbHhvNGdJTHE1WnhBWms4WkdoM2c0Q3F4SmxQS1k3QVF4dXBmVWNWcFdUNVZJdHAxKzMwVXFveVA0d1dzUm8zb2xSUmdrV1paMlpONlZDM09aRmVYQjhOYm5VclNkaWtOcHREMVFpR3VLa3I4RW1TUi9BSzlSdytGRjNzNXV3dVBidkhHaVBlRk9WaWx0TUs3QVVhT3NxOSt4OWNuZGszaUpFRTVMS1pSbFdKYktPWndlUk96bVBOVlBrakUzSy9UeUE1N1JzNjhUa1ozTVI4YWtLcG03Y0ZqbmpQZC9EZGtXamdZb0tIU3I1V3U1c3NvQllVNGFjUnM1ZzJESHhVbWRxOFZYT1hSYnVuRDhRTjBMaGdrc3NnYWhjZG9Zc052dVhHVUsvS1hELzdvRmIrVkdkaHFJbjAydmV1TTViTHVkSk9jMkt5MEdNYUc0Vy94V0J4SUpjTDd5bGlKT1hPcHgwQWtCcVVnemxEY3ptTFQ0aUlMWER4eHRSUjFvWmEySldGZ2lBYjQzb2JySm5HL1RaQzJLU0syd3FPelJaVFhhdlpaRk1iMWYzYlh2VmFOYUs4Mjh3OVRPNjEwZ2s4Sk5mM2dNZkVUelhYc2JjdlJHQ0c5SldRWjYrY0RQcWM0NDY2WW8yUmNLSCtQSUxlS09xdG5sYkluUjNNbUJlR0czRkgxMHl6a3lidXFFQzJIU1F3cEEwQW43ZDkrNzNCa0RVVG0zMGJabW9QL1JHYmdGTitHckNPZkFEZ3FyMFdiSTFhMW9rcEZtczhpSFl3OWhtMHpVdmxFTWl2QlJ4TW9kcmJKSis5L3AzalVkUVE5QkN0UWR4bk9HclQ1ZHpSVW13MDU5My9tYlJTZEJnMG5SdlJaTTUvRTE2bTdaSG1ERXRXaHd2ZmRaQ1o4SjhNMTJXMHlSTXN6WGFtV2ZRVHdJWjRheVlrdHJuc2NRdVdyOGlkcDNQalQyZUYvam10ZGhJZmNwTW5iK0lmWlkyRmViVzZVWS9BSzNqUDR1M1R1NHpFNHFsblFnTEZiTTE5RUJJc05mN0toamRicVEvRDZ5aURiK05sRWkyU0tEK2l2WFZVSzhpYjBvQm8zNjZnWGtSOFp4R2pwSklEY0VnWlBhOVRjWWUwVEliaVBsL3JQVVFEdTNYQko5WC9HTnEzRkFVc0tzbGw1N0R6YUdNcmpjVCtnY3RwKzlNTFlYQ3Erc3FQODFlVlEwcjlsdCtnY1FmWmJBQ1JiRWp2bE1za3p0Wkc4Z2JDOFFuOXR0MjZRN3k3bkRyYlpxL0xFejdrUjZKYzZwZzNOOXJWWDhZNU1KckdsTUw5cDlsVTRqYlRrS3FDdmVlWlVKakhCMDNtMktSS1IyVHl0b0ZrVFhPTGc3a2VVMXMxbHJQTVFKcG9PS0x1QUFDK3kxSGxKdWNVNnlzQjVoc1hodlNQUExxNUo3SnRucUhLWjR2WWpDNFZ5ODE1M1FZKzY3ODB4RHVHQVJzR2JPczFXcXpIMFFTNzY1cm5TS0ViYktsa084b0kvVkR3VWQwaXMxM3RLcHFJTHUxbURKRk55L2lKQVdjdkRnanh2dXNJVCtQR3ozU1QvSjlyOU10ZmQwanBhR2VpTFlJcVhjN0RpSFNTOFRjakZWa3NpNjZQRWt4VzF6NnVqYkxMVUdOTlluek9XcEg4QlpHSzRiQ0s3aVIrTWJJdjhuY0RBejF1NFN0TjN2VFR6ZXdyOUlRams5d3hGeG4rNk4xZGRLczB2ZmZKaVMwOE4zYTRHMVNWcmxaOTdRL00rOEc5ZmU1QVA2ZDkvUXE0V1JuT1JWaG9mUElLRWRDcjNsbHNwVWZFMG9LSUlZb0J5QlJQaCtiWDFITFMzSldHSlJoSXZFMWFXNE5UZDhlUGk0WitrWGIrWjhzbllmU05jcWlqaEFnVnN4NFJDTTU0Y1hVaVlramVCbW1DNGFqT0hyQ2hvRUxzY0pKQzcrOWpqTWp3NUJhZ1pLbGdSTWlTTll6N2g3dnZaSW9RcWJ0UW1zcGMwY1VrMUcvNzNpWHRTcFJPbDV3dExnUWkwbVcyRXg4aTNXVUxoY2dneDZFMUxNVkhVc2RjOUdISTFQSDNVMktvMFB5R2RuOUtkVk9MbTdGUEJ1aTBpOWEwSHBBNjBNc2V3VkU0ejhDQXQ1ZDQwMUd2NnpYbElUNVliaXQxVklBMEZDczd3dHZZcmVydTFmVXlXM29MQVovK2FUblpyT2NZUk5WQThzcG9SdGxSb1dmbHNSQ2xGY2d6a3FpSE9yZjAvU1Z3K0VwVmFGbEowZzRLeHExTU1PbWlRZHBNTnB0ZThsTU1RcW02Y0lGWGxuR2JmSmxseXNLRGkrMEpKTW90a3FnSXhPU1FnVTlkbi9sV2tlVmY4blVtM2l3WDJObDNXRHc5aTZBVUszdkJBYlpacmNKcERRL042NEFWd2pUMDdKZWYzMEdTU210TnUyV2xXN1lveVcyRmxXZlpGUVV3azg2N0VkTFlLazlWRzZKZ0VuQmlCeGtZN0xNbzRZTFFKSmxBbzlsL29UdkprU0FSREYvWHR5QXpNOE8ydDNlVC9pWGE2d0ROM1dld05tUUhkUGZzeENoVS9LdExHMk1uOGk0WnFLZFNsSWFCWmFkeEptUnpWUy9vNHlBNjVSVFNWaXE2MG9hMzk1THF3MHB6WTRTaXB3RTBTWFhzS1YrR1pyYUdTa3IvUlcwOHdQUnZxdlNVa1lCTUE5bFB4NG0yNGF6K0lIbUNiWEErMGZheFRSRTl3dUdlTzA2RElYYTZRbEtKM3B1SXlpdUFWZlByNzM2dnpvMnBCaXJTK1Z4ZWwzVE1tM0pLaHo5bzJab1J2YUZWcElreWtiMEhjbTRvSEZCTWNOU05qNy80R0p0NDNvZ29uWTJWZzRuc0RRSVd4QWNvcnBYQUN6Z0JxUVBqWXNFL1ZVcFhwd05NYW5FcnU0TndNQ0ZQa1h2TW9xdm9lTE4zcXl1L04xZVdFSHR0TUQ2NXYxOWwvMGtIMm1SMzVpdi9GSSt5am9ISjlnUE16NjdhZjNNcS9Cb1dYcXUzcnBoaVdNWFZrbW5QU0VrcEdwVUkyaDFNVGhpZGVHRkVPSzZZWkhQd1l6TUJ2cE5DNytaSHhQYjdlcGZlZkd5SUI0SnpPOURUTkVZbkRMVlZIZFF5dk9FVmVmcms2VXY1a1RRWVZZV1dkcXJkY0lsN3lsand3SVdkZlEveSsyUUIzZVIvcXhZT2J1WXlCNGdUYm8yaW40UHphclUxc085bkVUa21qOS9Bb3hEQStKTTNHTXFRdEpSNGp0ZHVIdG5vQ0x4ZDFnUVVzY0hSQi9Nb1JZSUVzUDJwRFo5S3ZIZ3RsazFpVGJXV2JIaG9od0ZFWVg3eTUxZlVWMm51VW1ub1VjcW5XSVFBQWdsOUxUVlgrQmMwUUdORWhDaHhIUjRZamZFNTFQVWRHZnNTRkU2Y2s3QkwzL2hUZjlqTHE0RzFJYWZJTnhPTEtlQXRPN3F1dWxZdkg1WU9CYyt6WDdDck1nV25XNDcvamZSc1duSmpZWW9FN3hNZldWMkhOMml5SXFMSSc7XHJcbmNvbnN0IEZFTkNFRCA9IG5ldyBNYXAoW1s4MjE3LFwiYXBvc3Ryb3BoZVwiXSxbODI2MCxcImZyYWN0aW9uIHNsYXNoXCJdLFsxMjUzOSxcIm1pZGRsZSBkb3RcIl1dKTtcclxuY29uc3QgTlNNX01BWCA9IDQ7XHJcblxyXG5mdW5jdGlvbiBkZWNvZGVfYXJpdGhtZXRpYyhieXRlcykge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdGZ1bmN0aW9uIHUxNigpIHsgcmV0dXJuIChieXRlc1twb3MrK10gPDwgOCkgfCBieXRlc1twb3MrK107IH1cclxuXHRcclxuXHQvLyBkZWNvZGUgdGhlIGZyZXF1ZW5jeSB0YWJsZVxyXG5cdGxldCBzeW1ib2xfY291bnQgPSB1MTYoKTtcclxuXHRsZXQgdG90YWwgPSAxO1xyXG5cdGxldCBhY2MgPSBbMCwgMV07IC8vIGZpcnN0IHN5bWJvbCBoYXMgZnJlcXVlbmN5IDFcclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IHN5bWJvbF9jb3VudDsgaSsrKSB7XHJcblx0XHRhY2MucHVzaCh0b3RhbCArPSB1MTYoKSk7XHJcblx0fVxyXG5cclxuXHQvLyBza2lwIHRoZSBzaXplZC1wYXlsb2FkIHRoYXQgdGhlIGxhc3QgMyBzeW1ib2xzIGluZGV4IGludG9cclxuXHRsZXQgc2tpcCA9IHUxNigpO1xyXG5cdGxldCBwb3NfcGF5bG9hZCA9IHBvcztcclxuXHRwb3MgKz0gc2tpcDtcclxuXHJcblx0bGV0IHJlYWRfd2lkdGggPSAwO1xyXG5cdGxldCByZWFkX2J1ZmZlciA9IDA7IFxyXG5cdGZ1bmN0aW9uIHJlYWRfYml0KCkge1xyXG5cdFx0aWYgKHJlYWRfd2lkdGggPT0gMCkge1xyXG5cdFx0XHQvLyB0aGlzIHdpbGwgcmVhZCBiZXlvbmQgZW5kIG9mIGJ1ZmZlclxyXG5cdFx0XHQvLyBidXQgKHVuZGVmaW5lZHwwKSA9PiB6ZXJvIHBhZFxyXG5cdFx0XHRyZWFkX2J1ZmZlciA9IChyZWFkX2J1ZmZlciA8PCA4KSB8IGJ5dGVzW3BvcysrXTtcclxuXHRcdFx0cmVhZF93aWR0aCA9IDg7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHJlYWRfYnVmZmVyID4+IC0tcmVhZF93aWR0aCkgJiAxO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgTiA9IDMxO1xyXG5cdGNvbnN0IEZVTEwgPSAyKipOO1xyXG5cdGNvbnN0IEhBTEYgPSBGVUxMID4+PiAxO1xyXG5cdGNvbnN0IFFSVFIgPSBIQUxGID4+IDE7XHJcblx0Y29uc3QgTUFTSyA9IEZVTEwgLSAxO1xyXG5cclxuXHQvLyBmaWxsIHJlZ2lzdGVyXHJcblx0bGV0IHJlZ2lzdGVyID0gMDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgfCByZWFkX2JpdCgpO1xyXG5cclxuXHRsZXQgc3ltYm9scyA9IFtdO1xyXG5cdGxldCBsb3cgPSAwO1xyXG5cdGxldCByYW5nZSA9IEZVTEw7IC8vIHRyZWF0IGxpa2UgYSBmbG9hdFxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdmFsdWUgPSBNYXRoLmZsb29yKCgoKHJlZ2lzdGVyIC0gbG93ICsgMSkgKiB0b3RhbCkgLSAxKSAvIHJhbmdlKTtcclxuXHRcdGxldCBzdGFydCA9IDA7XHJcblx0XHRsZXQgZW5kID0gc3ltYm9sX2NvdW50O1xyXG5cdFx0d2hpbGUgKGVuZCAtIHN0YXJ0ID4gMSkgeyAvLyBiaW5hcnkgc2VhcmNoXHJcblx0XHRcdGxldCBtaWQgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xyXG5cdFx0XHRpZiAodmFsdWUgPCBhY2NbbWlkXSkge1xyXG5cdFx0XHRcdGVuZCA9IG1pZDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFydCA9IG1pZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHN0YXJ0ID09IDApIGJyZWFrOyAvLyBmaXJzdCBzeW1ib2wgaXMgZW5kIG1hcmtcclxuXHRcdHN5bWJvbHMucHVzaChzdGFydCk7XHJcblx0XHRsZXQgYSA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnRdICAgLyB0b3RhbCk7XHJcblx0XHRsZXQgYiA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnQrMV0gLyB0b3RhbCkgLSAxO1xyXG5cdFx0d2hpbGUgKCgoYSBeIGIpICYgSEFMRikgPT0gMCkge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSAmIE1BU0sgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgJiBNQVNLO1xyXG5cdFx0XHRiID0gKGIgPDwgMSkgJiBNQVNLIHwgMTtcclxuXHRcdH1cclxuXHRcdHdoaWxlIChhICYgfmIgJiBRUlRSKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyICYgSEFMRikgfCAoKHJlZ2lzdGVyIDw8IDEpICYgKE1BU0sgPj4+IDEpKSB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSBeIEhBTEY7XHJcblx0XHRcdGIgPSAoKGIgXiBIQUxGKSA8PCAxKSB8IEhBTEYgfCAxO1xyXG5cdFx0fVxyXG5cdFx0bG93ID0gYTtcclxuXHRcdHJhbmdlID0gMSArIGIgLSBhO1xyXG5cdH1cclxuXHRsZXQgb2Zmc2V0ID0gc3ltYm9sX2NvdW50IC0gNDtcclxuXHRyZXR1cm4gc3ltYm9scy5tYXAoeCA9PiB7IC8vIGluZGV4IGludG8gcGF5bG9hZFxyXG5cdFx0c3dpdGNoICh4IC0gb2Zmc2V0KSB7XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIG9mZnNldCArIDB4MTAxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDE2KSB8IChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAyOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiBvZmZzZXQgKyBieXRlc1twb3NfcGF5bG9hZCsrXTtcclxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIHggLSAxO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHRcclxuXHJcbi8vIHJldHVybnMgYW4gaXRlcmF0b3Igd2hpY2ggcmV0dXJucyB0aGUgbmV4dCBzeW1ib2xcclxuZnVuY3Rpb24gcmVhZF9wYXlsb2FkKHYpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRyZXR1cm4gKCkgPT4gdltwb3MrK107XHJcbn1cclxuZnVuY3Rpb24gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQocykge1xyXG5cdHJldHVybiByZWFkX3BheWxvYWQoZGVjb2RlX2FyaXRobWV0aWModW5zYWZlX2F0b2IocykpKTtcclxufVxyXG5cclxuLy8gdW5zYWZlIGluIHRoZSBzZW5zZTpcclxuLy8gZXhwZWN0ZWQgd2VsbC1mb3JtZWQgQmFzZTY0IHcvbyBwYWRkaW5nIFxyXG4vLyAyMDIyMDkyMjogYWRkZWQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzRcclxuZnVuY3Rpb24gdW5zYWZlX2F0b2Iocykge1xyXG5cdGxldCBsb29rdXAgPSBbXTtcclxuXHRbLi4uJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXS5mb3JFYWNoKChjLCBpKSA9PiBsb29rdXBbYy5jaGFyQ29kZUF0KDApXSA9IGkpO1xyXG5cdGxldCBuID0gcy5sZW5ndGg7XHJcblx0bGV0IHJldCA9IG5ldyBVaW50OEFycmF5KCg2ICogbikgPj4gMyk7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIHdpZHRoID0gMCwgY2FycnkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjYXJyeSA9IChjYXJyeSA8PCA2KSB8IGxvb2t1cFtzLmNoYXJDb2RlQXQoaSldO1xyXG5cdFx0d2lkdGggKz0gNjtcclxuXHRcdGlmICh3aWR0aCA+PSA4KSB7XHJcblx0XHRcdHJldFtwb3MrK10gPSAoY2FycnkgPj4gKHdpZHRoIC09IDgpKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gZWcuIFswLDEsMiwzLi4uXSA9PiBbMCwtMSwxLC0yLC4uLl1cclxuZnVuY3Rpb24gc2lnbmVkKGkpIHsgXHJcblx0cmV0dXJuIChpICYgMSkgPyAofmkgPj4gMSkgOiAoaSA+PiAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9kZWx0YXMobiwgbmV4dCkge1xyXG5cdGxldCB2ID0gQXJyYXkobik7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHggPSAwOyBpIDwgbjsgaSsrKSB2W2ldID0geCArPSBzaWduZWQobmV4dCgpKTtcclxuXHRyZXR1cm4gdjtcclxufVxyXG5cclxuLy8gWzEyM11bNV0gPT4gWzAgM10gWzEgMV0gWzAgMF1cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWQobmV4dCwgcHJldiA9IDApIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB4ID0gbmV4dCgpO1xyXG5cdFx0bGV0IG4gPSBuZXh0KCk7XHJcblx0XHRpZiAoIW4pIGJyZWFrO1xyXG5cdFx0cHJldiArPSB4O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0cmV0LnB1c2gocHJldiArIGkpO1xyXG5cdFx0fVxyXG5cdFx0cHJldiArPSBuICsgMTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWRfYXJyYXlzKG5leHQpIHtcclxuXHRyZXR1cm4gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IFxyXG5cdFx0bGV0IHYgPSByZWFkX3NvcnRlZChuZXh0KTtcclxuXHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHY7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIHJldHVybnMgbWFwIG9mIHggPT4geXNcclxuZnVuY3Rpb24gcmVhZF9tYXBwZWQobmV4dCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCk7XHJcblx0XHRpZiAodyA9PSAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB3ID0gbmV4dCgpIC0gMTtcclxuXHRcdGlmICh3IDwgMCkgYnJlYWs7XHJcblx0XHRyZXQucHVzaChyZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldC5mbGF0KCk7XHJcbn1cclxuXHJcbi8vIHJlYWQgdW50aWwgbmV4dCBpcyBmYWxzeVxyXG4vLyByZXR1cm4gYXJyYXkgb2YgcmVhZCB2YWx1ZXNcclxuZnVuY3Rpb24gcmVhZF9hcnJheV93aGlsZShuZXh0KSB7XHJcblx0bGV0IHYgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KHYubGVuZ3RoKTtcclxuXHRcdGlmICgheCkgYnJlYWs7XHJcblx0XHR2LnB1c2goeCk7XHJcblx0fVxyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyByZWFkIHcgY29sdW1ucyBvZiBsZW5ndGggblxyXG4vLyByZXR1cm4gYXMgbiByb3dzIG9mIGxlbmd0aCB3XHJcbmZ1bmN0aW9uIHJlYWRfdHJhbnNwb3NlZChuLCB3LCBuZXh0KSB7XHJcblx0bGV0IG0gPSBBcnJheShuKS5maWxsKCkubWFwKCgpID0+IFtdKTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkrKykge1xyXG5cdFx0cmVhZF9kZWx0YXMobiwgbmV4dCkuZm9yRWFjaCgoeCwgaikgPT4gbVtqXS5wdXNoKHgpKTtcclxuXHR9XHJcblx0cmV0dXJuIG07XHJcbn1cclxuIFxyXG4vLyByZXR1cm5zIFtbeCwgeXNdLCBbeCtkeCwgeXMrZHldLCBbeCsyKmR4LCB5cysyKmR5XSwgLi4uXVxyXG4vLyB3aGVyZSBkeC9keSA9IHN0ZXBzLCBuID0gcnVuIHNpemUsIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSB7XHJcblx0bGV0IGR4ID0gMSArIG5leHQoKTtcclxuXHRsZXQgZHkgPSBuZXh0KCk7XHJcblx0bGV0IHZOID0gcmVhZF9hcnJheV93aGlsZShuZXh0KTtcclxuXHRsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZCh2Ti5sZW5ndGgsIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0uZmxhdE1hcCgodiwgaSkgPT4ge1xyXG5cdFx0bGV0IFt4LCAuLi55c10gPSB2O1xyXG5cdFx0cmV0dXJuIEFycmF5KHZOW2ldKS5maWxsKCkubWFwKChfLCBqKSA9PiB7XHJcblx0XHRcdGxldCBqX2R5ID0gaiAqIGR5O1xyXG5cdFx0XHRyZXR1cm4gW3ggKyBqICogZHgsIHlzLm1hcCh5ID0+IHkgKyBqX2R5KV07XHJcblx0XHR9KTtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJuIFtbeCwgeXMuLi5dLCAuLi5dXHJcbi8vIHdoZXJlIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpIHsgXHJcblx0bGV0IG4gPSAxICsgbmV4dCgpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKG4sIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0ubWFwKHYgPT4gW3ZbMF0sIHYuc2xpY2UoMSldKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlYWRfdHJpZShuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBzb3J0ZWQgPSByZWFkX3NvcnRlZChuZXh0KTsgXHJcblx0ZXhwYW5kKGRlY29kZShbXSksIFtdKTtcclxuXHRyZXR1cm4gcmV0OyAvLyBub3Qgc29ydGVkXHJcblx0ZnVuY3Rpb24gZGVjb2RlKFEpIHsgLy8gY2hhcmFjdGVycyB0aGF0IGxlYWQgaW50byB0aGlzIG5vZGVcclxuXHRcdGxldCBTID0gbmV4dCgpOyAvLyBzdGF0ZTogdmFsaWQsIHNhdmUsIGNoZWNrXHJcblx0XHRsZXQgQiA9IHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4geyAvLyBidWNrZXRzIGxlYWRpbmcgdG8gbmV3IG5vZGVzXHJcblx0XHRcdGxldCBjcHMgPSByZWFkX3NvcnRlZChuZXh0KS5tYXAoaSA9PiBzb3J0ZWRbaV0pO1xyXG5cdFx0XHRpZiAoY3BzLmxlbmd0aCkgcmV0dXJuIGRlY29kZShjcHMpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4ge1MsIEIsIFF9O1xyXG5cdH1cclxuXHRmdW5jdGlvbiBleHBhbmQoe1MsIEJ9LCBjcHMsIHNhdmVkKSB7XHJcblx0XHRpZiAoUyAmIDQgJiYgc2F2ZWQgPT09IGNwc1tjcHMubGVuZ3RoLTFdKSByZXR1cm47XHJcblx0XHRpZiAoUyAmIDIpIHNhdmVkID0gY3BzW2Nwcy5sZW5ndGgtMV07XHJcblx0XHRpZiAoUyAmIDEpIHJldC5wdXNoKGNwcyk7IFxyXG5cdFx0Zm9yIChsZXQgYnIgb2YgQikge1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBici5RKSB7XHJcblx0XHRcdFx0ZXhwYW5kKGJyLCBbLi4uY3BzLCBjcF0sIHNhdmVkKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gaGV4X2NwKGNwKSB7XHJcblx0cmV0dXJuIGNwLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1b3RlX2NwKGNwKSB7XHJcblx0cmV0dXJuIGB7JHtoZXhfY3AoY3ApfX1gOyAvLyByYWZmeSBjb252ZW50aW9uOiBsaWtlIFwiXFx1e1h9XCIgdy9vIHRoZSBcIlxcdVwiXHJcbn1cclxuXHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiBleHBsb2RlX2NwKHMpIHtcclxuXHRyZXR1cm4gWy4uLnNdLm1hcChjID0+IGMuY29kZVBvaW50QXQoMCkpO1xyXG59XHJcbiovXHJcbmZ1bmN0aW9uIGV4cGxvZGVfY3AocykgeyAvLyB0aGlzIGlzIGFib3V0IDJ4IGZhc3RlclxyXG5cdGxldCBjcHMgPSBbXTtcclxuXHRmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyApIHtcclxuXHRcdGxldCBjcCA9IHMuY29kZVBvaW50QXQocG9zKTtcclxuXHRcdHBvcyArPSBjcCA8IDB4MTAwMDAgPyAxIDogMjtcclxuXHRcdGNwcy5wdXNoKGNwKTtcclxuXHR9XHJcblx0cmV0dXJuIGNwcztcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyX2Zyb21fY3BzKGNwcykge1xyXG5cdGNvbnN0IGNodW5rID0gNDA5NjtcclxuXHRsZXQgbGVuID0gY3BzLmxlbmd0aDtcclxuXHRpZiAobGVuIDwgY2h1bmspIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jcHMpO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKSB7XHJcblx0XHRidWYucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jcHMuc2xpY2UoaSwgaSArPSBjaHVuaykpKTtcclxuXHR9XHJcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGFyZV9hcnJheXMoYSwgYikge1xyXG5cdGxldCBuID0gYS5sZW5ndGg7XHJcblx0bGV0IGMgPSBuIC0gYi5sZW5ndGg7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGMgPT0gMCAmJiBpIDwgbjsgaSsrKSBjID0gYVtpXSAtIGJbaV07XHJcblx0cmV0dXJuIGM7XHJcbn1cclxuXHJcbi8vIGNyZWF0ZWQgMjAyMy0wOS0yNVQwMTowMTo1NS4xNDhaXHJcbi8vIGNvbXByZXNzZWQgYmFzZTY0LWVuY29kZWQgYmxvYiBmb3IgaW5jbHVkZS1uZiBkYXRhXHJcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcclxuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzI3NlY3VyaXR5XHJcbi8vIFNIQS0yNTY6IGE5NzRiNmY4NTQxZmMyOWQ5MTliYzg1MTE4YWYwYTQ0MDE1ODUxZmFiNTM0M2Y4Njc5Y2IzMWJlMmJkYjIwOWVcclxudmFyIENPTVBSRVNTRUQgPSAnQUVVRFRBSEJDRlFBVFFEUkFEQUFjZ0FnQURRQUZBQXNBQlFBSHdBT0FDUUFEUUFSQUFvQUZ3QUhBQklBQ0FBUEFBVUFDd0FGQUF3QUJBQVFBQU1BQndBRUFBb0FCUUFJQUFJQUNnQUJBQVFBRkFBTEFBSUFDd0FCQUFJQUFRQUhBQU1BQXdBRUFBc0FEQUFNQUF3QUNnQU5BQTBBQXdBS0FBa0FCQUFkQUFZQVp3RFNBZHNESmdDMENrTUI4eGhaQXFmb0MxOTBVR2NUaGdCdXJ3ZjdQVDA5UGIwOUFqZ0p1bThPakRsbHhIWVVLWEFQeHpxNnRBQkF4Z0s4eXNVdldBZ01QVDA5UFQwOVBTczZMVDJIY2dXWFd3RkxvU01FRUVsNVJGVk1Ldk8wWFE4RXhEZEpNbklnc2oyNlBUUXl5OEZmRVE4QVk4SVBBR2NFYndSd0JIRUVjZ1J6QkhRRWRRUjJCSGNFZUFSNkJIc0VmQVIrQklBRWdmbmRCUW9CWWdVTEFXSUZEQUZpQk5jRTJBVFpCUkFGRVFVdkJkQUxGQXNWRFBjTkJ3MTNEWWNPTUE0eERqTUI0QmxsSEkwQjJncmJBTURwSExrUTdRSFZBUFJOUVFGbkdSVUVnMHlFQjJ1YUpGOEFKcElCcG9iNUFFUlNNQUtOb0FYcWFRTFVCTUN6RWlBQ253UlpFa2tWc1M3dEFOQXNCRzBSdUFRTEVQQUJ2OUhJQ1RVQlhpZ1Bad1JCQXBNRE93QWFtaHRhQUJxRUFZOEt2S3gzTFE0QXJBQjhVaHdFQkFWU2FnRDhBRUZaQURrQklhZFZqMlVNVWd4NUlsNEFOUUM5QXhJQjFCbGJFUE1BczMwQ0d4bFhBaHdaS1FJRUNCYzZFYnNDb3huZ3p2N1V6UlFBOE0wQmF3TDZad2tON3dBQkFEMzNPUVJjc2dMSkNqTUNqcVVDaHR3L2ttK05Bc1hQQW9QMkJUODRQd1VSQUswUkF2cHRiNmNBcFFTL09NTWV5NUhKUzg0VWR4cHhUUGtDb2dWRklUYVRPd0VSQUs1cEF2a05CT1Z5QTdxM0JLbE9KU0FMQWdVSUJSY0VkQVNwQlhxekFCWEZTV1pPYXdMQ09xdy8vQW9sQ1pkdnYzZFNCa0VRR3llbEVQY01Nd0cxQVRzTjdVdllCUEVHT3dUSkgzMFpHUS9ObFp3SXBTM2RETzBtNHk2aGdGb2o5U3FEQmUxTDlEemRDMDFSYUE5WkMyVUo0enBqZ1U0RElRRU5Jb3NLM1EwNUNHMFE4d3JKYXczbEVVVUhPUVBWU1pvQXBRY0JDeEVkTlJXMUpoQmlyQXNKT1hjRyt4cjJDNDhtcnhNcGV2d0YweG9oQmswQktSci9BTTh1NTRXd1dqRmNIRTlmQmdNTEpTUEhGS2hRSUEwbFFMZDRTQm9iQnhVbHFRS1JRM0JLaDFFMkhwTWg5anc5RFdZdUUxRjhCL1U4QlJsUEM0RThua2FyUlE0UjBqNk5QVWdpU1V3c0JEVi9MQzhuaXduUEQ0VU11WHh5QVZrSklRbXhESEVUTVJFWE44VUlPUWNaTFpja0p4VUlJVWFWWUpvRTk1OEQ4eFBSQXdzRlB3bEJCeE1EdFJ3dEV5NFZLUVVOZ1NUWEF2TTIxUzZ6QW85V2dBRVhCY3NQSlIvZkVGQkg0QTdwQ0pzQ1pRT0RKZXNBTFJVaEFCY2ltd2hEWXdCZmo5aFRCUzdMQ01kcWJDTjBBMmNVNTJFUmN3ZVJEbGNIcHh3ekZiOGM0WERJWGd1R0NDaWpyd2xiQVhVSm1RRmZCT01JQ1RWYmpLQWdRV2RUaTFnWW15QmhRVDlkL0FJeERHVVZuMFM5aDNnQ2l3OXJFaHNCTlFGekJ6a05BUUozRWUwUmF4Q1ZDT3VHQkRXMU0vZzZKUVJQSVlNZ0VRb25BMDlzemdzbkp2a00rR2tCb3hKaUF3dzBQWGZ1WjZ0Z3RpUVgvUWNaTXNWQllDSHhDNUpQelF5Y0dzRVlRbFF1R2VRSHZ3UHpHdk1uNmtGWEJmOERvd01UT2swejdnUzlDMmtJaXdrL0FFa09veGNIMXhocUNuR00wQUV4aXdHM21RTlhrWU1DYjQ4R053Y0xBR2NMaHdWNTVRQWRBcWNJb3dBRkFNOERWd0E1QXEwSG5RQVpBSVZCQVQwREp5OEJJZVVDandPVENESExBWlV2QWZNcEJCdkREQlVBOXpkdVNnTERzUUtBYW1haUJkMVlBbzRDU1RVQlRTVUVCVTVIVVFPdmNlRUEyd0JMQmhQZlJ3RVZxMHJMR3VOREFkOXZLd0RIQVBzQUJUVUhCVUVCelFIemJRQzNBVjhMTVFtaXM3VUJUZWtwQUlNQUZXc0Ixd0tKQU4wQU5RQi84UUZUQUUwRldma0Ywd0pQU1FFUk1SZ3JWMkVCdXdNZkFUTUJEUUI1QnN1TnBja0hId1J0QjlNQ0VCc1Y0UUx2TGdlMUFRTWkzeFBOUXNVQ3ZkNVZvV0FDWklFQ1lrSmJUYTliTnlBQ29mY0NhSmdDWmdrQ240UTRHd3NDWmpzQ1ppWUViZ1IvQTM4VEEzNlNPUVk1ZHhjNWdqb2pJd0pzSFFJeU5qZ0tBbTNIQW0ydTc0b3paMFVyQVdjQTNnRGhBRW9GQjVnTWpRRCtDOElBRGJVQ2R5OENkcUkvQW5sTFF3SjR1aDFjMjBXdVJ0Y0NmRDhDZXNnQ2ZRa0NmUEFGV1FVZ1NBQklmV01rQW9GdEFvQUFBb0FGQW4rdVNWaEtXeFVYU3N3QzBRRUMwTXhMSndPSVR3T0g1a1RGa1RJQzhxRmRBd01Ecmt2T1RDMGxBODlOVEUydkFvcy9Bb3JZd1JzSEhVTm5CYmNDampjQ2pseEFsNEVDanRrQ2pseDRVYlJUTlFwUzFGU0ZBcFA3QXBNTUFPa0FIRlVlVmE5VjBBWXNHeW1WaGpMaGVHWkZPemtDbDU4Qzc3SllJYWdBV1NVQ2xvOENsbnljQUtsWnJGb0pnVTBBT3dLV3RRS1dUbHhFWE5FQ21jc0NtV1JjeWwwSEdRS2Ntem5DT3AwQ25CWUNuNXNDbnJpS0FCMFBNU29QQXAzeEFwNlNBTFU5WVRSaDd3S2Uwd0tnYmdHcEFwNmZId0tlVHFWanlHUW5KU3NDSjY4Q0puNENvUHNDb0V3Q290MENvY1FDcGk4Q3BjNENwLzhBZlFLbjhtaDhhTEVBQTBscUhHclJBcXpqQXF5dUFxMW5BcTBDQWxjZEFsWGNBckhoMXdNZlRteVhBcks5RFFLeTZCZHM0RzFqYlVoZkF5WE5BclpjT3o5dWtBTXBSUUs0WGdLNVJ4VUN1U3AzY0RadzRRSzlHUUs3Mm5DV0F6SVJBcjZJY2dJRE0zRUN2aHB6SW5OUEFzUExBc01FYzRKMFN6VkZkT0FEUEtjRFBKb0RQYjhDeFh3Q3hrY0N4aENKQXNocFVRTElSQUxKVHdMSkxnSmtuUUxkMG5oNVlYaXVlU1ZMMEFNWW8yY0NBbUgwR2ZPVkpIc0xYcEpldXhFQ3oyc0N6Mnd2UzFQUzh4T2ZBTWF0QXM5ekFTbnFBMDRTZmtzRkF0d25BdHVLQXRKUEExSmNBMU5mQVFFRFZZeUFpVDhBeXhidFlFV0NISUxUZ3M2RGpRTGF4d0xaM29RUWhFbW5QQU9HcFFBdkEyUU9obkZaK1FCVkF0OWxBdDY0YzNjQzRpL3RGQUh6TUNjQjlKc0I4dEtIQXV2ekF1bHdlUUxxK1FMcTVBRDVSd0c1QXU2SkF1dWNscXFYQXdMdVB3T0Y0Smg1Y09CeG9RTHpBd0JwQTQ0V21aTUM5eE1Ea1c0RGtvY0M5NWdDK2RrQytHYWFISnFydXplYkhnT2Rnd0wrK2dFYkFEbWZISit6QXdXTkE2WnFBNmJaQU5IRkF3WnFvWWlpQlFrRERFa0N3QUEvQXdEaFFSZFRBUkh6QTJzSGwyY0ZBSk10SzdldnZkc0JpWmtVZnhFRU9RSDdLUVVoRHAwSm53Q1MvU2xYeFFMM0FaMEF0d1c1QUc4TGJVRXVGQ2FOTGdGREFZRDhBYlVtQUhVRERnUnRBQ3dDRmd5aEFBQUtBajBDYWdQZEEzNEVrUUVnUlFVaGZBb0FCUUJFQUJNQU5oSUNkd0VBQmRVRGErOEt4UUlBOXdxZko3K3h0K1VCa1NGQlFnSHBGSDhSTk1DSkFBUUFHd0JhQWtVQ2hJc0FCanBUT3BTTmJRQzRPbzg2MEFDTk9NRTYzQUNsQU9nQXl3RTZnVG83T2Z3NStUdDJpVHBiTzU2Sk9tODVHQUZXQVRNQmJBVXZOVjAxbmpXdE5XWTFkVFcyTmNVMWdqV1JOZEkxNFRXZU5hMDE3alg5TmJJMXdUWUNOaEUxeGpYVk5oWTJKelhlTmUwMkxqWTlOaTQxTFNFMk9qWTlOancyeVRjSUJKQThWelk0TnQwM0lEY1BOc29nTjRrM01Bb0VzRHhuTmlRM0dUZHNPbzAzSVVMVVF3ZEM0RU1MSEE4UENac29iU2hSVlFZQTZYOEE2YkFCRkNuWEF1a0Jvd0M5QmJjQWJ3TnpCTDhNREFNTUFRZ0RBQWtLQ3dzTENRb0dCQVZWQkkvRHZ3RHo5YjI5a2FVQ2IwUXRzUlROTHQ0ZUdCY1NIQU1aRmhZWkVoWUVBUkFFQlVFY1FSeEJIRUVjUVJ4QkhFRWFRUnhCSEVGQ1NUeEJQRWxJU1VoQk5rTTJRVFliTmtsSVNWbUJWSWdCRkxXWkF1MEJoUUNqQmNFQWJ5a0J2d0dKQWFRY0VaMGVQQ2tsTUFBaE12QUlNQUw1NGdDN0JtOEVlc2NqelFNcEFSUXBLZ0RVQUJhdkFqNjI2eFFBSlAwQTNldHp1ZjROTlJBN2VmeTJaOU5RckNuQzBPU3lBTno1QkJJYko1SUZEUjZtaUlhdllTNnRwcmpqbXVLZWJ4bTVDNzRRMjI1WDFwa2FZWVBiNmYxREs0azN4TUVCYjlTMldNakVpYlROV2hzUkpJQSt2d05WRWlYVEU1aVhzL3dlelY2Nm9GTGZwOU5aR1lXK0drMTlKMitiQ1Q2WWUydzZMRFlkZ3pLTVVhYms1OTVlTEJDWEFOejlIVXBXYkFUcTl2cVhWeDlYRGcrUGM5WHA0K2JzUzAwNVNWTS9CSkJNNDY4N1dVdWYrVWo5ZEVpOGFETmFQeHRwYkR4Y0cxVEhUSW1VTVpxNFVDYWFOWXBzVnFyYU55S0xKWERZc0ZaLzVqbDdiTFJ0Tzg4dDdQM3haYUF4aGI1T2RQTVhxc1NrcDFXQ2llRzhqWG0xVTk5K2JsdkxsWHpQQ1MrTTkzVm5KQ2lLKzA5TGZhU2FCQVZCb215RGdKdWE4ZGZVelI3Z2EzNEl2UjJOdmorQTloZUo2bHNsMUtHNE5rSTEwMzJDbmZmMW0xd29mMkI5b0hKSzRiaTZKa0VkU3FlTmVpdW82UW9aWmluY29jNzMvVEg5U1hGOHNDRTdYeXVZeVc4V1NnYkdGQ2pQVjBpaExLaGRQczA4VHg4MmZZQWtMTGM0STJ3ZGw0YXBZN0dVNWxIUkZ6UldKZXA3V3czd2JlQTNxbWQ1OS84NlA0eHVOYXFEcHlnWHQ2TTg1Z2xTQkhPQ0dnSkRudCtwTjliSzdIQXBNZ3VYNiswNlJaTmp6Vm1jWkord2NVcko5Ly9icFJOeE51S3BObDl1RmRzK1M5dGR4N0xhTTVaa0lyUGo2bklVOW1uYkZ0VmJzOXMvdUxnbDhNVmN6QXdldCtpT0V6ekJsWVc3UkNNZ0U2Z3lOTGVxNisxdEl4NGRwZ1puZDBEa3NKUzVmK0pORHB3d2NQTlhhYVZzcHExZmJRYWpPckpnSzBvZkt0SjFOZTkwTDZWTzRNT2w1Uzg4NnA3dTZ4bzdPTGpHOFRHTCtIVTFKWEdKZ3BwZzRuTmJOSjVubHpTcHVQWXkyMUpVRWNVQTk0UG9GaVpmalp1ZStRbnlRODBla091WlZreHg0ZytjdmhKZkhnTmw0aHkxL2E2K1JLY0tsYXIvSjI5eS8vRXp0bGJWUEhWVWVRMXpYODZlUVZBalIvTTNkQTl3NFc4TGZhWHA0RWdNODV3T1dhc2xpODM3UHpWTU9uc0x6UitrM283NS9sUlBBSlNFMXhBS1F6RWk1djEwa2UrVkJ2UnQxY3dRUk1kK1U1bUxDVEdWZDZYaVp0Z0JHNWNEaTB3MjJHS2NWTnZIaXU1TFFiWkVEVnR6MG9ubjdrNStoZXVLWFZzWnRTemlsa0xSQVVtak1YRU1CM0o5WUM1MFhCeFBpejUzU0MrRWhuUGw5V3NLQ3Y5MlNNL09GRklNSlpZZmwwV1c4dElPM1V4WWN3ZE1BajdGU21ncnNaMmFBWk8wM0JPaFAxYk5OWkl0eVhZUUZUcEMzU0cxVnVQRHFIOUdraUNEbUUrSnd4eUlWU081c2lERXJBT3BFWEZnank2UFF0T1ZEaitzNmUxcjhoZVdWdm1ablRjaXVmNEVpTlp6Q0FkN1NPTWhYRVJJT2xzSElNRzM5OWk5YUxUeTNtMmhSTFpqSlZETkxTNTNpR0lLMTFkUHFRdDB6QkR5ZzZxYzdZcWtEbTJNNVZlNmRDV0NhQ2JUWFgyclRvYUlnejYremg0bFlVaS8rNm5xY0ZNQWtRSktIWUxLMHdZazVOOXN6VjZ4aWhEYkRERnI0NWxOMUs0YUNYQnEvRml0UFN1ZDlnTHQ1WlZuK1pxR1g3Y3dtMno1RUdNZ2ZGcElGeWhHR3VEUG1zbzZUSXRUTXdueSs3dVBuTENmNFc2Z29GUUZWMG9RU3NjOVZmTW1WTGNMcjZaZXREWmJhU0ZUTHFuU08vYklQakEzL3pBVW9xZ0dGQUVRUzRJaHVNekVwMkkzakp6Ynpray9JRW15YXgrcmhaVHdkNmYrQ0d0d1BpeHU4SXZ6QUNxdVBXUFJFdTladkdrVXpwUnd2UlJ1YU5ONmNyMFcxd1dpdHM5SUNkWUo3bHRiZ01pU0wzc1RQZXVmZ05jVnFNVldGa0NQREg0akcyakEwWGNWZ1FqNjJDYjI5djlmL3ovKzJLYll2SXYvenpqcFFBUGtsaWFWRHpOclc1N1RaL1pPeVpEMG5sZk1tQUlCSUFHQUkwRDNrL21kTjR4cjl2ODVaYlpiYnFmSDJqR2Q1aFVxTlpXd2w1U1Bmb0dtZkVsbWF6VUllTkwxai9ta0Y3Vk5BelRxNGpOdDhKb1ExMU5RT2NtaHByWG94U3hmUkdKOUxERU9BUStkbXhBUUg5MGl0aTllMnUvTW9ldWFHY0RUSG9DK3hzbUVlV214RUtlZlF1SXpIYnB3NVRjNWNFb2Nib0FEMDlvaXBXUWh0VE8xd2l2Zi9PK0RSZTJycGwvRTl3bHJ6Qm9yakpzT2VHMUIvWFBXNEVhSkVGZE5sRUNFWmdhNVpvR1JIWGdZb3VHUnVWa204dERFU2lFeUZObyszczVNNXB1U2RUeVVMMmxsbklOVkhFdDkxWFVOVzRld2RNZ0o0Ym9KZkV5dC9pWTVXWHFiQStBMkZrdDVaMGx1dGlXaGU5blpJeUlVanlYREMzVXNhRzF0K2VOeDZ6NFcvT1lvVEI3QTZ4K2ROU1RPaTlBSW5jdGJFU3FtNWd2T0x3dzdPV1hQcm1Id1ZaYXNybDRlRDExM3BtK0p0VDdKVk92bkNYcWR6emRUUkhnSjBQaUdURllXNUd2dDlSOUxENkx6ZnMwdi9UWlpIU215Vk5xN3ZpSUhFNkRCSzdRcDA3SXo1NUVNOFNZdFF2WmYvb2JCbmlUV2k1QzIvb3ZIZnc0Vm5ka0U1WFlkak9oQ01SakRlT0VmWGVOL0N3ZkdkdWlVSWZzb0ZlVXhYZVFYYmE3Yzc5NzJYTnY4dytkVGpqVU0wUWVOQVJlVytKMDE0ZEtBRC9NY1FZWFQ3YzBHUVBJa24zTGw2UjdnR2p1aVFvWkQwVEVlRXFRcEtvWjE1Zy8wT1BRSTE3UWlTdjlBVVJPYS9WL1RRTjNkdkxBcmVjM1Jyc1lsdkJtMWI4TFd6bHRkdWdzQzUwbE5LWUxFcDJhK1paWXFQZWpVTFJsT0poNXpqL0xWTXlURHZ3S2hNeHh3dURreEoxUXBvTkkwT1RXTG9tNFo3MVNOekk5VFYxaVhKckl1OVdjbmQrTUNhQXc4bzFqU1hkOTRZVS8xZ25rckM5QlVFT3RRdkVJUTdnMGk2aCtLTDJKS2s4WWRsN0hydXZnV01TQW1OZStMc2hHaFY0cW5XSGhPOS9SSVBRelkxdEhSajJWcU95TnNEcEswY3d3KzU2QWREQzRnc1d3WTBYeG91Y0lXSXFzL0djd25XcWxhVDBLUHI4bWJLNVU5NC8zMDFpMVdMdDRZSU5UVnZDRkJyRlpiSWJZOGV5Y09kZUoydGVENUlmUExDUmc3ampjRlR3bE1GTmw5emRoL28zRS9oSFB3ajdCV2cwTVUwOXBQckJMYnJDZ201NEE2SCtJNnYyNytqTDVna2pXZy9pWWRrczlqYmZWUDV5L24wZGxnV0VNbEthc2w3SnZGWmQ1NkxmeWJXMWVlYVZPMGd4VGZYWndEOEc0U0kxMTZ5eDdVS1ZSZ3VpNllhMVlwaXhxWGVOTGM4SXh0QXdDVTVJaHdRZ24rTnFIblJhRHY2MUN4S2hPcTRwT1g3TTZwa0ErUG1wZDRqMXZuNkFDVUFMb0xMYzR2cFhjaThWaWRMeHptN3FGQmU3cytxdXVKczZFVFltbnBnUzNMd1NaeFBJbHRnQkRYejhNMWsvVzJ5U052MmY5L05QaHhMR0syRDIxZGtIZVNHbWVuUlQzWXFjZGwwbS9oM09ZcjhWK2xYTllHZjhhQ0NwZDRiV2pFNFFJUGo3dlVLTjROcmZzN01MNlkyT3lTODMwSkNub2ZnL2s3bHBGcHQ0U3FaYzVIR2cxSENPckh2T2RDOGJQNkZHRGJFL1ZWMG1YNElha3piZFMvb3ArS3QzRzI0LzhRYkJWN3k4NnNHU1Evdlp6VThGWHM3dTZqSXZ3Y2hzRVAyQnBJaFczRzh1V053YTNIbWpmSC9aamhoQ1d2bHVBY0Yrbk1mMTRDbEtnNWhHZ3RQTEo5OHVlTkFrYzVIczJXWmxrMlFIdmZyZUNLMUNDR082bk1aVlNiOTlWTS9hanI4V0hUdGU5SlNta1hxL2kvVTk0M0hFYmR6VzZSZS9TODhkS2dnOHBHT0xsQWVOaXFyY0xrVVIzL2FDbEZwTVhjT1VQM3JtRVRjV1NmTVhaRTNUVU9pOGkrZnFSblRZTGZsVngvVmIvNkdKN2VJUlpVQTZrM1JZUjNpRlNLOWM0aURkTndKdVpMMkZLei9JSzVWaW1jTldFcWRYalNveFNnbUYwVVBsRG9VbE5yUGNNN2Z0bUE4WTlnS2lxS0VIdVdOK0FaUkl3dFZTeHllMktmOHJNM2xoSjVYY0JYVTluNHYwT3kxUlUyTSs0cU04QVFQVndzZThFck5Tb2I1b0ZQV3h1cVpuVnpvMXFCL0lCeGtNM0VWVUtGVVVsTzNlNTEyNTlHZ05jSmJDbWx2cmRqdG9UVzdyQ2htMXd5Q0t6cENUd296VVVFT0ljV0xuZVJMZ01YaCtTakdTRmtBbGx6YkdTNUhLN0xsZkNNUk5SRFN2YlFQamNYYWVuTll4Q3Z1MlF5em56NlN0dXhWajY2U2dJMFQ4QjYvc2ZIQUpZWmFaNzh0aGpPU0lGdW1OV0xRYmVaaXhEQ0NDK3YwWUJ0a3hpQkIzamVmSHFaL2RGSFUrY3JiajZPdlMxeC9KREQ3dmxtN3pPVlB3cFVDMDFuaHhadVkvNjNFN2cnO1xyXG5cclxuLy8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMTUvXHJcbi8vIGZvciByZWZlcmVuY2UgaW1wbGVtZW50YXRpb25cclxuLy8gc2VlOiAvZGVyaXZlL25mLmpzXHJcblxyXG5cclxuLy8gYWxnb3JpdGhtaWMgaGFuZ3VsXHJcbi8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3ZlcnNpb25zL1VuaWNvZGUxNS4wLjAvY2gwMy5wZGYgKHBhZ2UgMTQ0KVxyXG5jb25zdCBTMCA9IDB4QUMwMDtcclxuY29uc3QgTDAgPSAweDExMDA7XHJcbmNvbnN0IFYwID0gMHgxMTYxO1xyXG5jb25zdCBUMCA9IDB4MTFBNztcclxuY29uc3QgTF9DT1VOVCA9IDE5O1xyXG5jb25zdCBWX0NPVU5UID0gMjE7XHJcbmNvbnN0IFRfQ09VTlQgPSAyODtcclxuY29uc3QgTl9DT1VOVCA9IFZfQ09VTlQgKiBUX0NPVU5UO1xyXG5jb25zdCBTX0NPVU5UID0gTF9DT1VOVCAqIE5fQ09VTlQ7XHJcbmNvbnN0IFMxID0gUzAgKyBTX0NPVU5UO1xyXG5jb25zdCBMMSA9IEwwICsgTF9DT1VOVDtcclxuY29uc3QgVjEgPSBWMCArIFZfQ09VTlQ7XHJcbmNvbnN0IFQxID0gVDAgKyBUX0NPVU5UO1xyXG5cclxuZnVuY3Rpb24gdW5wYWNrX2NjKHBhY2tlZCkge1xyXG5cdHJldHVybiAocGFja2VkID4+IDI0KSAmIDB4RkY7XHJcbn1cclxuZnVuY3Rpb24gdW5wYWNrX2NwKHBhY2tlZCkge1xyXG5cdHJldHVybiBwYWNrZWQgJiAweEZGRkZGRjtcclxufVxyXG5cclxubGV0IFNISUZURURfUkFOSywgRVhDTFVTSU9OUywgREVDT01QLCBSRUNPTVA7XHJcblxyXG5mdW5jdGlvbiBpbml0JDEoKSB7XHJcblx0Ly9jb25zb2xlLnRpbWUoJ25mJyk7XHJcblx0bGV0IHIgPSByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChDT01QUkVTU0VEKTtcclxuXHRTSElGVEVEX1JBTksgPSBuZXcgTWFwKHJlYWRfc29ydGVkX2FycmF5cyhyKS5mbGF0TWFwKCh2LCBpKSA9PiB2Lm1hcCh4ID0+IFt4LCAoaSsxKSA8PCAyNF0pKSk7IC8vIHByZS1zaGlmdGVkXHJcblx0RVhDTFVTSU9OUyA9IG5ldyBTZXQocmVhZF9zb3J0ZWQocikpO1xyXG5cdERFQ09NUCA9IG5ldyBNYXAoKTtcclxuXHRSRUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0Zm9yIChsZXQgW2NwLCBjcHNdIG9mIHJlYWRfbWFwcGVkKHIpKSB7XHJcblx0XHRpZiAoIUVYQ0xVU0lPTlMuaGFzKGNwKSAmJiBjcHMubGVuZ3RoID09IDIpIHtcclxuXHRcdFx0bGV0IFthLCBiXSA9IGNwcztcclxuXHRcdFx0bGV0IGJ1Y2tldCA9IFJFQ09NUC5nZXQoYSk7XHJcblx0XHRcdGlmICghYnVja2V0KSB7XHJcblx0XHRcdFx0YnVja2V0ID0gbmV3IE1hcCgpO1xyXG5cdFx0XHRcdFJFQ09NUC5zZXQoYSwgYnVja2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRidWNrZXQuc2V0KGIsIGNwKTtcclxuXHRcdH1cclxuXHRcdERFQ09NUC5zZXQoY3AsIGNwcy5yZXZlcnNlKCkpOyAvLyBzdG9yZWQgcmV2ZXJzZWRcclxuXHR9XHJcblx0Ly9jb25zb2xlLnRpbWVFbmQoJ25mJyk7XHJcblx0Ly8gMjAyMzA5MDU6IDExbXNcclxufVxyXG5cclxuZnVuY3Rpb24gaXNfaGFuZ3VsKGNwKSB7XHJcblx0cmV0dXJuIGNwID49IFMwICYmIGNwIDwgUzE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBvc2VfcGFpcihhLCBiKSB7XHJcblx0aWYgKGEgPj0gTDAgJiYgYSA8IEwxICYmIGIgPj0gVjAgJiYgYiA8IFYxKSB7XHJcblx0XHRyZXR1cm4gUzAgKyAoYSAtIEwwKSAqIE5fQ09VTlQgKyAoYiAtIFYwKSAqIFRfQ09VTlQ7XHJcblx0fSBlbHNlIGlmIChpc19oYW5ndWwoYSkgJiYgYiA+IFQwICYmIGIgPCBUMSAmJiAoYSAtIFMwKSAlIFRfQ09VTlQgPT0gMCkge1xyXG5cdFx0cmV0dXJuIGEgKyAoYiAtIFQwKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0bGV0IHJlY29tcCA9IFJFQ09NUC5nZXQoYSk7XHJcblx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdHJlY29tcCA9IHJlY29tcC5nZXQoYik7XHJcblx0XHRcdGlmIChyZWNvbXApIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVjb21wO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWNvbXBvc2VkKGNwcykge1xyXG5cdGlmICghU0hJRlRFRF9SQU5LKSBpbml0JDEoKTtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGxldCBjaGVja19vcmRlciA9IGZhbHNlO1xyXG5cdGZ1bmN0aW9uIGFkZChjcCkge1xyXG5cdFx0bGV0IGNjID0gU0hJRlRFRF9SQU5LLmdldChjcCk7XHJcblx0XHRpZiAoY2MpIHtcclxuXHRcdFx0Y2hlY2tfb3JkZXIgPSB0cnVlO1xyXG5cdFx0XHRjcCB8PSBjYztcclxuXHRcdH1cclxuXHRcdHJldC5wdXNoKGNwKTtcclxuXHR9XHJcblx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRpZiAoY3AgPCAweDgwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlzX2hhbmd1bChjcCkpIHtcclxuXHRcdFx0XHRsZXQgc19pbmRleCA9IGNwIC0gUzA7XHJcblx0XHRcdFx0bGV0IGxfaW5kZXggPSBzX2luZGV4IC8gTl9DT1VOVCB8IDA7XHJcblx0XHRcdFx0bGV0IHZfaW5kZXggPSAoc19pbmRleCAlIE5fQ09VTlQpIC8gVF9DT1VOVCB8IDA7XHJcblx0XHRcdFx0bGV0IHRfaW5kZXggPSBzX2luZGV4ICUgVF9DT1VOVDtcclxuXHRcdFx0XHRhZGQoTDAgKyBsX2luZGV4KTtcclxuXHRcdFx0XHRhZGQoVjAgKyB2X2luZGV4KTtcclxuXHRcdFx0XHRpZiAodF9pbmRleCA+IDApIGFkZChUMCArIHRfaW5kZXgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBtYXBwZWQgPSBERUNPTVAuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAobWFwcGVkKSB7XHJcblx0XHRcdFx0XHRidWYucHVzaCguLi5tYXBwZWQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRhZGQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWJ1Zi5sZW5ndGgpIGJyZWFrO1xyXG5cdFx0XHRjcCA9IGJ1Zi5wb3AoKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNoZWNrX29yZGVyICYmIHJldC5sZW5ndGggPiAxKSB7XHJcblx0XHRsZXQgcHJldl9jYyA9IHVucGFja19jYyhyZXRbMF0pO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGNjID0gdW5wYWNrX2NjKHJldFtpXSk7XHJcblx0XHRcdGlmIChjYyA9PSAwIHx8IHByZXZfY2MgPD0gY2MpIHtcclxuXHRcdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGogPSBpLTE7XHJcblx0XHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdFx0bGV0IHRtcCA9IHJldFtqKzFdO1xyXG5cdFx0XHRcdHJldFtqKzFdID0gcmV0W2pdO1xyXG5cdFx0XHRcdHJldFtqXSA9IHRtcDtcclxuXHRcdFx0XHRpZiAoIWopIGJyZWFrO1xyXG5cdFx0XHRcdHByZXZfY2MgPSB1bnBhY2tfY2MocmV0Wy0tal0pO1xyXG5cdFx0XHRcdGlmIChwcmV2X2NjIDw9IGNjKSBicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFtpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZCh2KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBzdGFjayA9IFtdO1xyXG5cdGxldCBwcmV2X2NwID0gLTE7XHJcblx0bGV0IHByZXZfY2MgPSAwO1xyXG5cdGZvciAobGV0IHBhY2tlZCBvZiB2KSB7XHJcblx0XHRsZXQgY2MgPSB1bnBhY2tfY2MocGFja2VkKTtcclxuXHRcdGxldCBjcCA9IHVucGFja19jcChwYWNrZWQpO1xyXG5cdFx0aWYgKHByZXZfY3AgPT0gLTEpIHtcclxuXHRcdFx0aWYgKGNjID09IDApIHtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0LnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPiAwICYmIHByZXZfY2MgPj0gY2MpIHtcclxuXHRcdFx0aWYgKGNjID09IDApIHtcclxuXHRcdFx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHJcblx0XHRcdFx0c3RhY2subGVuZ3RoID0gMDtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChjcCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNvbXBvc2VkID0gY29tcG9zZV9wYWlyKHByZXZfY3AsIGNwKTtcclxuXHRcdFx0aWYgKGNvbXBvc2VkID49IDApIHtcclxuXHRcdFx0XHRwcmV2X2NwID0gY29tcG9zZWQ7XHJcblx0XHRcdH0gZWxzZSBpZiAocHJldl9jYyA9PSAwICYmIGNjID09IDApIHtcclxuXHRcdFx0XHRyZXQucHVzaChwcmV2X2NwKTtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChjcCk7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2X2NwID49IDApIHtcclxuXHRcdHJldC5wdXNoKHByZXZfY3AsIC4uLnN0YWNrKTtcdFxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBub3RlOiBjcHMgY2FuIGJlIGl0ZXJhYmxlXHJcbmZ1bmN0aW9uIG5mZChjcHMpIHtcclxuXHRyZXR1cm4gZGVjb21wb3NlZChjcHMpLm1hcCh1bnBhY2tfY3ApO1xyXG59XHJcbmZ1bmN0aW9uIG5mYyhjcHMpIHtcclxuXHRyZXR1cm4gY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkKGRlY29tcG9zZWQoY3BzKSk7XHJcbn1cclxuXHJcbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XHJcbmNvbnN0IFNUT1AgPSAweDJFO1xyXG5jb25zdCBTVE9QX0NIID0gJy4nO1xyXG5jb25zdCBGRTBGID0gMHhGRTBGO1xyXG5jb25zdCBVTklRVUVfUEggPSAxO1xyXG5cclxuLy8gMjAyMzA5MTM6IHJlcGxhY2UgWy4uLnZdIHdpdGggQXJyYXlfZnJvbSh2KSB0byBhdm9pZCBsYXJnZSBzcHJlYWRzXHJcbmNvbnN0IEFycmF5X2Zyb20gPSB4ID0+IEFycmF5LmZyb20oeCk7IC8vIEFycmF5LmZyb20uYmluZChBcnJheSk7XHJcblxyXG5mdW5jdGlvbiBncm91cF9oYXNfY3AoZywgY3ApIHtcclxuXHQvLyAyMDIzMDkxMzoga2VlcCBwcmltYXJ5IGFuZCBzZWNvbmRhcnkgZGlzdGluY3QgaW5zdGVhZCBvZiBjcmVhdGluZyB2YWxpZCB1bmlvblxyXG5cdHJldHVybiBnLlAuaGFzKGNwKSB8fCBnLlEuaGFzKGNwKTtcclxufVxyXG5cclxuY2xhc3MgRW1vamkgZXh0ZW5kcyBBcnJheSB7XHJcblx0Z2V0IGlzX2Vtb2ppKCkgeyByZXR1cm4gdHJ1ZTsgfSAvLyBmcmVlIHRhZ2dpbmcgc3lzdGVtXHJcbn1cclxuXHJcbmxldCBNQVBQRUQsIElHTk9SRUQsIENNLCBOU00sIEVTQ0FQRSwgTkZDX0NIRUNLLCBHUk9VUFMsIFdIT0xFX1ZBTElELCBXSE9MRV9NQVAsIFZBTElELCBFTU9KSV9MSVNULCBFTU9KSV9ST09UO1xyXG5cclxuZnVuY3Rpb24gaW5pdCgpIHtcclxuXHRpZiAoTUFQUEVEKSByZXR1cm47XHJcblx0XHJcblx0bGV0IHIgPSByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChDT01QUkVTU0VEJDEpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX2FycmF5ID0gKCkgPT4gcmVhZF9zb3J0ZWQocik7XHJcblx0Y29uc3QgcmVhZF9zb3J0ZWRfc2V0ID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHRjb25zdCBzZXRfYWRkX21hbnkgPSAoc2V0LCB2KSA9PiB2LmZvckVhY2goeCA9PiBzZXQuYWRkKHgpKTtcclxuXHJcblx0TUFQUEVEID0gbmV3IE1hcChyZWFkX21hcHBlZChyKSk7IFxyXG5cdElHTk9SRUQgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gaWdub3JlZCBjaGFyYWN0ZXJzIGFyZSBub3QgdmFsaWQsIHNvIGp1c3QgcmVhZCByYXcgY29kZXBvaW50c1xyXG5cclxuXHQvKlxyXG5cdC8vIGRpcmVjdCBpbmNsdWRlIGZyb20gcGF5bG9hZCBpcyBzbWFsbGVyIHRoYW4gdGhlIGRlY29tcHJlc3Npb24gY29kZVxyXG5cdGNvbnN0IEZFTkNFRCA9IG5ldyBNYXAocmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRsZXQgY3AgPSByKCk7XHJcblx0XHRpZiAoY3ApIHJldHVybiBbY3AsIHJlYWRfc3RyKHIoKSldO1xyXG5cdH0pKTtcclxuXHQqL1xyXG5cdC8vIDIwMjMwMjE3OiB3ZSBzdGlsbCBuZWVkIGFsbCBDTSBmb3IgcHJvcGVyIGVycm9yIGZvcm1hdHRpbmdcclxuXHQvLyBidXQgbm9ybSBvbmx5IG5lZWRzIE5TTSBzdWJzZXQgdGhhdCBhcmUgcG90ZW50aWFsbHktdmFsaWRcclxuXHRDTSA9IHJlYWRfc29ydGVkX2FycmF5KCk7XHJcblx0TlNNID0gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLm1hcChpID0+IENNW2ldKSk7XHJcblx0Q00gPSBuZXcgU2V0KENNKTtcclxuXHRcclxuXHRFU0NBUEUgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gY2hhcmFjdGVycyB0aGF0IHNob3VsZCBub3QgYmUgcHJpbnRlZFxyXG5cdE5GQ19DSEVDSyA9IHJlYWRfc29ydGVkX3NldCgpOyAvLyBvbmx5IG5lZWRlZCB0byBpbGx1c3RyYXRlIGVuc190b2tlbml6ZSgpIHRyYW5zZm9ybWF0aW9uc1xyXG5cclxuXHRsZXQgY2h1bmtzID0gcmVhZF9zb3J0ZWRfYXJyYXlzKHIpO1xyXG5cdGxldCB1bnJlc3RyaWN0ZWQgPSByKCk7XHJcblx0Ly9jb25zdCByZWFkX2NodW5rZWQgPSAoKSA9PiBuZXcgU2V0KHJlYWRfc29ydGVkX2FycmF5KCkuZmxhdE1hcChpID0+IGNodW5rc1tpXSkuY29uY2F0KHJlYWRfc29ydGVkX2FycmF5KCkpKTtcclxuXHRjb25zdCByZWFkX2NodW5rZWQgPSAoKSA9PiB7XHJcblx0XHQvLyAyMDIzMDkyMTogYnVpbGQgc2V0IGluIHBhcnRzLCAyeCBmYXN0ZXJcclxuXHRcdGxldCBzZXQgPSBuZXcgU2V0KCk7XHJcblx0XHRyZWFkX3NvcnRlZF9hcnJheSgpLmZvckVhY2goaSA9PiBzZXRfYWRkX21hbnkoc2V0LCBjaHVua3NbaV0pKTtcclxuXHRcdHNldF9hZGRfbWFueShzZXQsIHJlYWRfc29ydGVkX2FycmF5KCkpO1xyXG5cdFx0cmV0dXJuIHNldDsgXHJcblx0fTtcclxuXHRHUk9VUFMgPSByZWFkX2FycmF5X3doaWxlKGkgPT4ge1xyXG5cdFx0Ly8gbWluaWZpZXIgcHJvcGVydHkgbWFuZ2xpbmcgc2VlbXMgdW5zYWZlXHJcblx0XHQvLyBzbyB0aGVzZSBhcmUgbWFudWFsbHkgcmVuYW1lZCB0byBzaW5nbGUgY2hhcnNcclxuXHRcdGxldCBOID0gcmVhZF9hcnJheV93aGlsZShyKS5tYXAoeCA9PiB4KzB4NjApO1xyXG5cdFx0aWYgKE4ubGVuZ3RoKSB7XHJcblx0XHRcdGxldCBSID0gaSA+PSB1bnJlc3RyaWN0ZWQ7IC8vIHVucmVzdHJpY3RlZCB0aGVuIHJlc3RyaWN0ZWRcclxuXHRcdFx0TlswXSAtPSAzMjsgLy8gY2FwaXRhbGl6ZVxyXG5cdFx0XHROID0gc3RyX2Zyb21fY3BzKE4pO1xyXG5cdFx0XHRpZiAoUikgTj1gUmVzdHJpY3RlZFske059XWA7XHJcblx0XHRcdGxldCBQID0gcmVhZF9jaHVua2VkKCk7IC8vIHByaW1hcnlcclxuXHRcdFx0bGV0IFEgPSByZWFkX2NodW5rZWQoKTsgLy8gc2Vjb25kYXJ5XHJcblx0XHRcdGxldCBNID0gIXIoKTsgLy8gbm90LXdoaXRlbGlzdGVkLCBjaGVjayBmb3IgTlNNXHJcblx0XHRcdC8vICoqKiB0aGlzIGNvZGUgY3VycmVudGx5IGlzbid0IG5lZWRlZCAqKipcclxuXHRcdFx0LypcclxuXHRcdFx0bGV0IFYgPSBbLi4uUCwgLi4uUV0uc29ydCgoYSwgYikgPT4gYS1iKTsgLy8gZGVyaXZlOiBzb3J0ZWQgdmFsaWRcclxuXHRcdFx0bGV0IE0gPSByKCktMTsgLy8gbnVtYmVyIG9mIGNvbWJpbmluZyBtYXJrXHJcblx0XHRcdGlmIChNIDwgMCkgeyAvLyB3aGl0ZWxpc3RlZFxyXG5cdFx0XHRcdE0gPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0XHRcdFx0bGV0IGkgPSByKCk7XHJcblx0XHRcdFx0XHRpZiAoaSkgcmV0dXJuIFtWW2ktMV0sIHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRsZXQgdiA9IHJlYWRfYXJyYXlfd2hpbGUocik7XHJcblx0XHRcdFx0XHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHYubWFwKHggPT4geC0xKTtcclxuXHRcdFx0XHRcdH0pXTtcclxuXHRcdFx0XHR9KSk7XHJcblx0XHRcdH0qL1xyXG5cdFx0XHRyZXR1cm4ge04sIFAsIFEsIE0sIFJ9O1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBkZWNvZGUgY29tcHJlc3NlZCB3aG9sZXNcclxuXHRXSE9MRV9WQUxJRCA9IHJlYWRfc29ydGVkX3NldCgpO1xyXG5cdFdIT0xFX01BUCA9IG5ldyBNYXAoKTtcclxuXHRsZXQgd2hvbGVzID0gcmVhZF9zb3J0ZWRfYXJyYXkoKS5jb25jYXQoQXJyYXlfZnJvbShXSE9MRV9WQUxJRCkpLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIG11c3QgYmUgc29ydGVkXHJcblx0d2hvbGVzLmZvckVhY2goKGNwLCBpKSA9PiB7XHJcblx0XHRsZXQgZCA9IHIoKTsgXHJcblx0XHRsZXQgdyA9IHdob2xlc1tpXSA9IGQgPyB3aG9sZXNbaS1kXSA6IHtWOiBbXSwgTTogbmV3IE1hcCgpfTtcclxuXHRcdHcuVi5wdXNoKGNwKTsgLy8gYWRkIHRvIG1lbWJlciBzZXRcclxuXHRcdGlmICghV0hPTEVfVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRXSE9MRV9NQVAuc2V0KGNwLCB3KTsgIC8vIHJlZ2lzdGVyIHdpdGggd2hvbGUgbWFwXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdC8vIGNvbXB1dGUgY29uZnVzYWJsZS1leHRlbnQgY29tcGxlbWVudHNcclxuXHQvLyB1c2FnZTogV0hPTEVfTUFQLmdldChjcCkuTS5nZXQoY3ApID0gY29tcGxlbWVudCBzZXRcclxuXHRmb3IgKGxldCB7ViwgTX0gb2YgbmV3IFNldChXSE9MRV9NQVAudmFsdWVzKCkpKSB7XHJcblx0XHQvLyBjb25uZWN0IGFsbCBncm91cHMgdGhhdCBoYXZlIGVhY2ggd2hvbGUgY2hhcmFjdGVyXHJcblx0XHRsZXQgcmVjcyA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgVikge1xyXG5cdFx0XHRsZXQgZ3MgPSBHUk9VUFMuZmlsdGVyKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSk7XHJcblx0XHRcdGxldCByZWMgPSByZWNzLmZpbmQoKHtHfSkgPT4gZ3Muc29tZShnID0+IEcuaGFzKGcpKSk7XHJcblx0XHRcdGlmICghcmVjKSB7XHJcblx0XHRcdFx0cmVjID0ge0c6IG5ldyBTZXQoKSwgVjogW119O1xyXG5cdFx0XHRcdHJlY3MucHVzaChyZWMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJlYy5WLnB1c2goY3ApO1xyXG5cdFx0XHRzZXRfYWRkX21hbnkocmVjLkcsIGdzKTtcclxuXHRcdH1cclxuXHRcdC8vIHBlciBjaGFyYWN0ZXIgY2FjaGUgZ3JvdXBzIHdoaWNoIGFyZSBub3QgYSBtZW1iZXIgb2YgdGhlIGV4dGVudFxyXG5cdFx0bGV0IHVuaW9uID0gcmVjcy5mbGF0TWFwKHggPT4gQXJyYXlfZnJvbSh4LkcpKTsgLy8gYWxsIG9mIHRoZSBncm91cHMgdXNlZCBieSB0aGlzIHdob2xlXHJcblx0XHRmb3IgKGxldCB7RywgVn0gb2YgcmVjcykge1xyXG5cdFx0XHRsZXQgY29tcGxlbWVudCA9IG5ldyBTZXQodW5pb24uZmlsdGVyKGcgPT4gIUcuaGFzKGcpKSk7IC8vIGdyb3VwcyBub3QgY292ZXJlZCBieSB0aGUgZXh0ZW50XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0XHRNLnNldChjcCwgY29tcGxlbWVudCk7IC8vIHRoaXMgaXMgdGhlIHNhbWUgcmVmZXJlbmNlXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGNvbXB1dGUgdmFsaWQgc2V0XHJcblx0Ly8gMjAyMzA5MjQ6IFZBTElEIHdhcyB1bmlvbiBidXQgY2FuIGJlIHJlLXVzZWRcclxuXHRWQUxJRCA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDErIGdyb3Vwc1xyXG5cdGxldCBtdWx0aSA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDIrIGdyb3Vwc1xyXG5cdGNvbnN0IGFkZF90b191bmlvbiA9IGNwID0+IFZBTElELmhhcyhjcCkgPyBtdWx0aS5hZGQoY3ApIDogVkFMSUQuYWRkKGNwKTtcclxuXHRmb3IgKGxldCBnIG9mIEdST1VQUykge1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5QKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5RKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdH1cclxuXHQvLyBkdWFsIHB1cnBvc2UgV0hPTEVfTUFQOiByZXR1cm4gcGxhY2Vob2xkZXIgaWYgdW5pcXVlIG5vbi1jb25mdXNhYmxlXHJcblx0Zm9yIChsZXQgY3Agb2YgVkFMSUQpIHtcclxuXHRcdGlmICghV0hPTEVfTUFQLmhhcyhjcCkgJiYgIW11bHRpLmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgVU5JUVVFX1BIKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gYWRkIGFsbCBkZWNvbXBvc2VkIHBhcnRzXHJcblx0Ly8gc2VlIGRlcml2ZTogXCJWYWxpZCBpcyBDbG9zZWQgKHZpYSBCcnV0ZS1mb3JjZSlcIlxyXG5cdHNldF9hZGRfbWFueShWQUxJRCwgbmZkKFZBTElEKSk7XHJcblx0XHJcblx0Ly8gZGVjb2RlIGVtb2ppXHJcblx0Ly8gMjAyMzA3MTk6IGVtb2ppIGFyZSBub3cgZnVsbHktZXhwYW5kZWQgdG8gYXZvaWQgcXVpcmsgbG9naWMgXHJcblx0RU1PSklfTElTVCA9IHJlYWRfdHJpZShyKS5tYXAodiA9PiBFbW9qaS5mcm9tKHYpKS5zb3J0KGNvbXBhcmVfYXJyYXlzKTtcclxuXHRFTU9KSV9ST09UID0gbmV3IE1hcCgpOyAvLyB0aGlzIGhhcyBhcHByb3ggN0sgbm9kZXMgKDIrIHBlciBlbW9qaSlcclxuXHRmb3IgKGxldCBjcHMgb2YgRU1PSklfTElTVCkge1xyXG5cdFx0Ly8gMjAyMzA3MTk6IGNoYW5nZSB0byAqc2xpZ2h0bHkqIHN0cmljdGVyIGFsZ29yaXRobSB3aGljaCBkaXNhbGxvd3MgXHJcblx0XHQvLyBpbnNlcnRpb24gb2YgbWlzcGxhY2VkIEZFMEYgaW4gZW1vamkgc2VxdWVuY2VzIChtYXRjaGluZyBFTlNJUC0xNSlcclxuXHRcdC8vIGV4YW1wbGU6IGJlYXV0aWZpZWQgW0EgQl0gKGVnLiBmbGFnIGVtb2ppKSBcclxuXHRcdC8vICBiZWZvcmU6IGFsbG93OiBbQSBGRTBGIEJdLCBlcnJvcjogW0EgRkUwRiBGRTBGIEJdIFxyXG5cdFx0Ly8gICBhZnRlcjogZXJyb3I6IGJvdGhcclxuXHRcdC8vIG5vdGU6IHRoaXMgY29kZSBub3cgbWF0Y2hlcyBFTlNOb3JtYWxpemUue2NzLGphdmF9IGxvZ2ljXHJcblx0XHRsZXQgcHJldiA9IFtFTU9KSV9ST09UXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRsZXQgbmV4dCA9IHByZXYubWFwKG5vZGUgPT4ge1xyXG5cdFx0XHRcdGxldCBjaGlsZCA9IG5vZGUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoIWNoaWxkKSB7XHJcblx0XHRcdFx0XHQvLyBzaG91bGQgdGhpcyBiZSBvYmplY3Q/IFxyXG5cdFx0XHRcdFx0Ly8gKG1vc3QgaGF2ZSAxLTIgaXRlbXMsIGZldyBoYXZlIG1hbnkpXHJcblx0XHRcdFx0XHQvLyAyMDIzMDcxOTogbm8sIHY4IGRlZmF1bHQgbWFwIGlzIDQ/XHJcblx0XHRcdFx0XHRjaGlsZCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRcdG5vZGUuc2V0KGNwLCBjaGlsZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBjaGlsZDtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGlmIChjcCA9PT0gRkUwRikge1xyXG5cdFx0XHRcdHByZXYucHVzaCguLi5uZXh0KTsgLy8gbGVzcyB0aGFuIDIwIGVsZW1lbnRzXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cHJldiA9IG5leHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAobGV0IHggb2YgcHJldikge1xyXG5cdFx0XHR4LlYgPSBjcHM7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBpZiBlc2NhcGVkOiB7SEVYfVxyXG4vLyAgICAgICBlbHNlOiBcInhcIiB7SEVYfVxyXG5mdW5jdGlvbiBxdW90ZWRfY3AoY3ApIHtcclxuXHRyZXR1cm4gKHNob3VsZF9lc2NhcGUoY3ApID8gJycgOiBgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKFtjcF0pKX0gYCkgKyBxdW90ZV9jcChjcCk7XHJcbn1cclxuXHJcbi8vIDIwMjMwMjExOiBzb21lIG1lc3NhZ2VzIGNhbiBiZSBtaXhlZC1kaXJlY3Rpb25hbCBhbmQgcmVzdWx0IGluIHNwaWxsb3ZlclxyXG4vLyB1c2UgMjAwRSBhZnRlciBhIHF1b3RlZCBzdHJpbmcgdG8gZm9yY2UgdGhlIHJlbWFpbmRlciBvZiBhIHN0cmluZyBmcm9tIFxyXG4vLyBhY3F1cmluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBxdW90ZVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvSW50ZXJuYXRpb25hbC9xdWVzdGlvbnMvcWEtYmlkaS11bmljb2RlLWNvbnRyb2xzI2V4Y2VwdGlvbnNcclxuZnVuY3Rpb24gYmlkaV9xcShzKSB7XHJcblx0cmV0dXJuIGBcIiR7c31cIlxcdTIwMEVgOyAvLyBzdHJvbmcgTFRSXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX2xhYmVsX2V4dGVuc2lvbihjcHMpIHtcclxuXHRpZiAoY3BzLmxlbmd0aCA+PSA0ICYmIGNwc1syXSA9PSBIWVBIRU4gJiYgY3BzWzNdID09IEhZUEhFTikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGxhYmVsIGV4dGVuc2lvbjogXCIke3N0cl9mcm9tX2NwcyhjcHMuc2xpY2UoMCwgNCkpfVwiYCk7IC8vIHRoaXMgY2FuIG9ubHkgYmUgYXNjaWkgc28gY2FudCBiZSBiaWRpXHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShjcHMpIHtcclxuXHRjb25zdCBVTkRFUlNDT1JFID0gMHg1RjtcclxuXHRmb3IgKGxldCBpID0gY3BzLmxhc3RJbmRleE9mKFVOREVSU0NPUkUpOyBpID4gMDsgKSB7XHJcblx0XHRpZiAoY3BzWy0taV0gIT09IFVOREVSU0NPUkUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd1bmRlcnNjb3JlIGFsbG93ZWQgb25seSBhdCBzdGFydCcpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4vLyBjaGVjayB0aGF0IGEgZmVuY2VkIGNwIGlzIG5vdCBsZWFkaW5nLCB0cmFpbGluZywgb3IgdG91Y2hpbmcgYW5vdGhlciBmZW5jZWQgY3BcclxuZnVuY3Rpb24gY2hlY2tfZmVuY2VkKGNwcykge1xyXG5cdGxldCBjcCA9IGNwc1swXTtcclxuXHRsZXQgcHJldiA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdGlmIChwcmV2KSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGxlYWRpbmcgJHtwcmV2fWApO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRsZXQgbGFzdCA9IC0xOyAvLyBwcmV2ZW50cyB0cmFpbGluZyBmcm9tIHRocm93aW5nXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNwID0gY3BzW2ldO1xyXG5cdFx0bGV0IG1hdGNoID0gRkVOQ0VELmdldChjcCk7XHJcblx0XHRpZiAobWF0Y2gpIHtcclxuXHRcdFx0Ly8gc2luY2UgY3BzWzBdIGlzbid0IGZlbmNlZCwgY3BzWzFdIGNhbm5vdCB0aHJvd1xyXG5cdFx0XHRpZiAobGFzdCA9PSBpKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYCR7cHJldn0gKyAke21hdGNofWApO1xyXG5cdFx0XHRsYXN0ID0gaSArIDE7XHJcblx0XHRcdHByZXYgPSBtYXRjaDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGxhc3QgPT0gbikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGB0cmFpbGluZyAke3ByZXZ9YCk7XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIHNhZmUgdG8gcHJpbnQgc3RyaW5nIFxyXG4vLyBpbnZpc2libGVzIGFyZSBlc2NhcGVkXHJcbi8vIGxlYWRpbmcgY20gdXNlcyBwbGFjZWhvbGRlclxyXG4vLyBpZiBjcHMgZXhjZWVkIG1heCwgbWlkZGxlIHRydW5jYXRlIHdpdGggZWxsaXBzaXNcclxuLy8gcXVvdGVyKGNwKSA9PiBzdHJpbmcsIGVnLiAzMDAwID0+IFwiezMwMDB9XCJcclxuLy8gbm90ZTogaW4gaHRtbCwgeW91J2QgY2FsbCB0aGlzIGZ1bmN0aW9uIHRoZW4gcmVwbGFjZSBbPD4mXSB3aXRoIGVudGl0aWVzXHJcbmZ1bmN0aW9uIHNhZmVfc3RyX2Zyb21fY3BzKGNwcywgbWF4ID0gSW5maW5pdHksIHF1b3RlciA9IHF1b3RlX2NwKSB7XHJcblx0Ly9pZiAoTnVtYmVyLmlzSW50ZWdlcihjcHMpKSBjcHMgPSBbY3BzXTtcclxuXHQvL2lmICghQXJyYXkuaXNBcnJheShjcHMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBjb2RlcG9pbnRzYCk7XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGlmIChpc19jb21iaW5pbmdfbWFyayhjcHNbMF0pKSBidWYucHVzaCgn4peMJyk7XHJcblx0aWYgKGNwcy5sZW5ndGggPiBtYXgpIHtcclxuXHRcdG1heCA+Pj0gMTtcclxuXHRcdGNwcyA9IFsuLi5jcHMuc2xpY2UoMCwgbWF4KSwgMHgyMDI2LCAuLi5jcHMuc2xpY2UoLW1heCldO1xyXG5cdH1cclxuXHRsZXQgcHJldiA9IDA7XHJcblx0bGV0IG4gPSBjcHMubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaV07XHJcblx0XHRpZiAoc2hvdWxkX2VzY2FwZShjcCkpIHtcclxuXHRcdFx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBpKSkpO1xyXG5cdFx0XHRidWYucHVzaChxdW90ZXIoY3ApKTtcclxuXHRcdFx0cHJldiA9IGkgKyAxO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRidWYucHVzaChzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKHByZXYsIG4pKSk7XHJcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuLy8gbm90ZTogc2V0KHMpIGNhbm5vdCBiZSBleHBvc2VkIGJlY2F1c2UgdGhleSBjYW4gYmUgbW9kaWZpZWRcclxuLy8gbm90ZTogT2JqZWN0LmZyZWV6ZSgpIGRvZXNuJ3Qgd29ya1xyXG5mdW5jdGlvbiBpc19jb21iaW5pbmdfbWFyayhjcCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gQ00uaGFzKGNwKTtcclxufVxyXG5mdW5jdGlvbiBzaG91bGRfZXNjYXBlKGNwKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBFU0NBUEUuaGFzKGNwKTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGFsbCBzdXBwb3J0ZWQgZW1vamkgYXMgZnVsbHktcXVhbGlmaWVkIGVtb2ppIFxyXG4vLyBvcmRlcmVkIGJ5IGxlbmd0aCB0aGVuIGxleGljb2dyYXBoaWMgXHJcbmZ1bmN0aW9uIGVuc19lbW9qaSgpIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVNT0pJX0xJU1QubWFwKHggPT4geC5zbGljZSgpKTsgLy8gZW1vamkgYXJlIGV4cG9zZWQgc28gY29weVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplX2ZyYWdtZW50KGZyYWcsIGRlY29tcG9zZSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgbmYgPSBkZWNvbXBvc2UgPyBuZmQgOiBuZmM7XHJcblx0cmV0dXJuIGZyYWcuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHN0cl9mcm9tX2Nwcyh0b2tlbnNfZnJvbV9zdHIoZXhwbG9kZV9jcChsYWJlbCksIG5mLCBmaWx0ZXJfZmUwZikuZmxhdCgpKSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZShuYW1lKSB7XHJcblx0cmV0dXJuIGZsYXR0ZW4oc3BsaXQobmFtZSwgbmZjLCBmaWx0ZXJfZmUwZikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfYmVhdXRpZnkobmFtZSkge1xyXG5cdGxldCBsYWJlbHMgPSBzcGxpdChuYW1lLCBuZmMsIHggPT4geCk7IC8vIGVtb2ppIG5vdCBleHBvc2VkXHJcblx0Zm9yIChsZXQge3R5cGUsIG91dHB1dCwgZXJyb3J9IG9mIGxhYmVscykge1xyXG5cdFx0aWYgKGVycm9yKSBicmVhazsgLy8gZmxhdHRlbiB3aWxsIHRocm93XHJcblxyXG5cdFx0Ly8gcmVwbGFjZSBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlblxyXG5cdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGJlYXV0aWZpbmcgYWxsIG9yIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuIHRvIHVuaWNvZGUgdmFyaWFudFxyXG5cdFx0Ly8gbm90IGV4YWN0bHkgdGhlIHNhbWUgaW4gZXZlcnkgZm9udCwgYnV0IHZlcnkgc2ltaWxhcjogXCItXCIgdnMgXCLigJBcIlxyXG5cdFx0LypcclxuXHRcdGNvbnN0IFVOSUNPREVfSFlQSEVOID0gMHgyMDEwO1xyXG5cdFx0Ly8gbWF5YmUgdGhpcyBzaG91bGQgcmVwbGFjZSBhbGwgZm9yIHZpc3VhbCBjb25zaXN0YW5jeT9cclxuXHRcdC8vIGBub2RlIHRvb2xzL3JlZy1jb3VudC5qcyByZWdleCBeLVxcezIsXFx9YCA9PiA1OTJcclxuXHRcdC8vZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIGlmIChvdXRwdXRbaV0gPT0gMHgyRCkgb3V0cHV0W2ldID0gMHgyMDEwO1xyXG5cdFx0aWYgKG91dHB1dFswXSA9PSBIWVBIRU4pIG91dHB1dFswXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0bGV0IGVuZCA9IG91dHB1dC5sZW5ndGgtMTtcclxuXHRcdGlmIChvdXRwdXRbZW5kXSA9PSBIWVBIRU4pIG91dHB1dFtlbmRdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHQqL1xyXG5cdFx0Ly8gMjAyMzAxMjM6IFdIQVRXRyBVUkwgdXNlcyBcIkNoZWNrSHlwaGVuc1wiIGZhbHNlXHJcblx0XHQvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2lkbmFcclxuXHJcblx0XHQvLyB1cGRhdGUgZXRoZXJldW0gc3ltYm9sXHJcblx0XHQvLyDOviA9PiDOniBpZiBub3QgZ3JlZWtcclxuXHRcdGlmICh0eXBlICE9PSAnR3JlZWsnKSBhcnJheV9yZXBsYWNlKG91dHB1dCwgMHgzQkUsIDB4MzlFKTtcclxuXHJcblx0XHQvLyAyMDIyMTIxMzogZml4ZXMgYmlkaSBzdWJkb21haW4gaXNzdWUsIGJ1dCBicmVha3MgaW52YXJpYW50ICgyMDBFIGlzIGRpc2FsbG93ZWQpXHJcblx0XHQvLyBjb3VsZCBiZSBmaXhlZCB3aXRoIHNwZWNpYWwgY2FzZSBmb3I6IDJEICguKSArIDIwMEUgKExUUilcclxuXHRcdC8vIGh0dHBzOi8vZGlzY3Vzcy5lbnMuZG9tYWlucy90L2JpZGktbGFiZWwtb3JkZXJpbmctc3Bvb2YvMTU4MjRcclxuXHRcdC8vb3V0cHV0LnNwbGljZSgwLCAwLCAweDIwMEUpO1xyXG5cdH1cclxuXHRyZXR1cm4gZmxhdHRlbihsYWJlbHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcnJheV9yZXBsYWNlKHYsIGEsIGIpIHtcclxuXHRsZXQgcHJldiA9IDA7XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCBuZXh0ID0gdi5pbmRleE9mKGEsIHByZXYpO1xyXG5cdFx0aWYgKG5leHQgPCAwKSBicmVhaztcclxuXHRcdHZbbmV4dF0gPSBiOyBcclxuXHRcdHByZXYgPSBuZXh0ICsgMTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19zcGxpdChuYW1lLCBwcmVzZXJ2ZV9lbW9qaSkge1xyXG5cdHJldHVybiBzcGxpdChuYW1lLCBuZmMsIHByZXNlcnZlX2Vtb2ppID8geCA9PiB4LnNsaWNlKCkgOiBmaWx0ZXJfZmUwZik7IC8vIGVtb2ppIGFyZSBleHBvc2VkIHNvIGNvcHlcclxufVxyXG5cclxuZnVuY3Rpb24gc3BsaXQobmFtZSwgbmYsIGVmKSB7XHJcblx0aWYgKCFuYW1lKSByZXR1cm4gW107IC8vIDIwMjMwNzE5OiBlbXB0eSBuYW1lIGFsbG93YW5jZVxyXG5cdGluaXQoKTtcclxuXHRsZXQgb2Zmc2V0ID0gMDtcclxuXHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHQvLyA0LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgY29udGFpbiBhIFUrMDAyRSAoIC4gKSBGVUxMIFNUT1AuXCJcclxuXHRyZXR1cm4gbmFtZS5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4ge1xyXG5cdFx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChsYWJlbCk7XHJcblx0XHRsZXQgaW5mbyA9IHtcclxuXHRcdFx0aW5wdXQsXHJcblx0XHRcdG9mZnNldCwgLy8gY29kZXBvaW50LCBub3Qgc3Vic3RyaW5nIVxyXG5cdFx0fTtcclxuXHRcdG9mZnNldCArPSBpbnB1dC5sZW5ndGggKyAxOyAvLyArIHN0b3BcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIDEuKSBcIlRoZSBsYWJlbCBtdXN0IGJlIGluIFVuaWNvZGUgTm9ybWFsaXphdGlvbiBGb3JtIE5GQ1wiXHJcblx0XHRcdGxldCB0b2tlbnMgPSBpbmZvLnRva2VucyA9IHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKTtcclxuXHRcdFx0bGV0IHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcclxuXHRcdFx0bGV0IHR5cGU7XHJcblx0XHRcdGlmICghdG9rZW5fY291bnQpIHsgLy8gdGhlIGxhYmVsIHdhcyBlZmZlY3RpdmVseSBlbXB0eSAoY291bGQgb2YgaGFkIGlnbm9yZWQgY2hhcmFjdGVycylcclxuXHRcdFx0XHQvL25vcm0gPSBbXTtcclxuXHRcdFx0XHQvL3R5cGUgPSAnTm9uZSc7IC8vIHVzZSB0aGlzIGluc3RlYWQgb2YgbmV4dCBtYXRjaCwgXCJBU0NJSVwiXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjA6IGNoYW5nZSB0byBzdHJpY3RcclxuXHRcdFx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9lbnMtbmFtZS1ub3JtYWxpemF0aW9uLTJuZC8xNDU2NC81OVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZW1wdHkgbGFiZWxgKTtcclxuXHRcdFx0fSBcclxuXHRcdFx0bGV0IG5vcm0gPSBpbmZvLm91dHB1dCA9IHRva2Vucy5mbGF0KCk7XHJcblx0XHRcdGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShub3JtKTtcclxuXHRcdFx0bGV0IGVtb2ppID0gaW5mby5lbW9qaSA9IHRva2VuX2NvdW50ID4gMSB8fCB0b2tlbnNbMF0uaXNfZW1vamk7IC8vIHNhbWUgYXM6IHRva2Vucy5zb21lKHggPT4geC5pc19lbW9qaSk7XHJcblx0XHRcdGlmICghZW1vamkgJiYgbm9ybS5ldmVyeShjcCA9PiBjcCA8IDB4ODApKSB7IC8vIHNwZWNpYWwgY2FzZSBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyAyMDIzMDEyMzogbWF0Y2hlcyBtYXRjaGVzIFdIQVRXRywgc2VlIG5vdGUgMy4zXHJcblx0XHRcdFx0Y2hlY2tfbGFiZWxfZXh0ZW5zaW9uKG5vcm0pOyAvLyBvbmx5IG5lZWRlZCBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgZmVuY2VkXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGNtXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIHdob2xlc1xyXG5cdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiRmFzdHBhdGggQVNDSUlcIlxyXG5cdFx0XHRcdHR5cGUgPSAnQVNDSUknO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjaGFycyA9IHRva2Vucy5mbGF0TWFwKHggPT4geC5pc19lbW9qaSA/IFtdIDogeCk7IC8vIGFsbCBvZiB0aGUgbmZjIHRva2VucyBjb25jYXQgdG9nZXRoZXJcclxuXHRcdFx0XHRpZiAoIWNoYXJzLmxlbmd0aCkgeyAvLyB0aGVyZXMgbm8gdGV4dCwganVzdCBlbW9qaVxyXG5cdFx0XHRcdFx0dHlwZSA9ICdFbW9qaSc7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIDUuKSBcIlRoZSBsYWJlbCBtdXN0IG5vdCBiZWdpbiB3aXRoIGEgY29tYmluaW5nIG1hcmssIHRoYXQgaXM6IEdlbmVyYWxfQ2F0ZWdvcnk9TWFyay5cIlxyXG5cdFx0XHRcdFx0aWYgKENNLmhhcyhub3JtWzBdKSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KCdsZWFkaW5nIGNvbWJpbmluZyBtYXJrJyk7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRva2VuX2NvdW50OyBpKyspIHsgLy8gd2UndmUgYWxyZWFkeSBjaGVja2VkIHRoZSBmaXJzdCB0b2tlblxyXG5cdFx0XHRcdFx0XHRsZXQgY3BzID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRcdFx0XHRpZiAoIWNwcy5pc19lbW9qaSAmJiBDTS5oYXMoY3BzWzBdKSkgeyAvLyBldmVyeSB0ZXh0IHRva2VuIGhhcyBlbW9qaSBuZWlnaGJvcnMsIGVnLiBFdEVFRXRFdC4uLlxyXG5cdFx0XHRcdFx0XHRcdC8vIGJpZGlfcXEoKSBub3QgbmVlZGVkIHNpbmNlIGVtb2ppIGlzIExUUiBhbmQgY3BzIGlzIGEgQ01cclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGVtb2ppICsgY29tYmluaW5nIG1hcms6IFwiJHtzdHJfZnJvbV9jcHModG9rZW5zW2ktMV0pfSArICR7c2FmZV9zdHJfZnJvbV9jcHMoW2Nwc1swXV0pfVwiYCk7IFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjaGVja19mZW5jZWQobm9ybSk7XHJcblx0XHRcdFx0XHRsZXQgdW5pcXVlID0gQXJyYXlfZnJvbShuZXcgU2V0KGNoYXJzKSk7XHJcblx0XHRcdFx0XHRsZXQgW2ddID0gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSk7IC8vIHRha2UgdGhlIGZpcnN0IG1hdGNoXHJcblx0XHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIk1hdGNoaW5nIEdyb3VwcyBoYXZlIFNhbWUgQ00gU3R5bGVcIlxyXG5cdFx0XHRcdFx0Ly8gYWx0ZXJuYXRpdmU6IGNvdWxkIGZvcm0gYSBoeWJyaWQgdHlwZTogTGF0aW4vSmFwYW5lc2UvLi4uXHRcclxuXHRcdFx0XHRcdGNoZWNrX2dyb3VwKGcsIGNoYXJzKTsgLy8gbmVlZCB0ZXh0IGluIG9yZGVyXHJcblx0XHRcdFx0XHRjaGVja193aG9sZShnLCB1bmlxdWUpOyAvLyBvbmx5IG5lZWQgdW5pcXVlIHRleHQgKG9yZGVyIHdvdWxkIGJlIHJlcXVpcmVkIGZvciBtdWx0aXBsZS1jaGFyIGNvbmZ1c2FibGVzKVxyXG5cdFx0XHRcdFx0dHlwZSA9IGcuTjtcclxuXHRcdFx0XHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBleHBvc2luZyByZXN0cmljdGVkIGZsYWdcclxuXHRcdFx0XHRcdC8vIGl0J3Mgc2ltcGxlciB0byBqdXN0IGNoZWNrIGZvciAnUmVzdHJpY3RlZCdcclxuXHRcdFx0XHRcdC8vIG9yIGV2ZW4gYmV0dGVyOiB0eXBlLmVuZHNXaXRoKCddJylcclxuXHRcdFx0XHRcdC8vaWYgKGcuUikgaW5mby5yZXN0cmljdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aW5mby50eXBlID0gdHlwZTtcclxuXHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRpbmZvLmVycm9yID0gZXJyOyAvLyB1c2UgZnVsbCBlcnJvciBvYmplY3RcclxuXHRcdH1cclxuXHRcdHJldHVybiBpbmZvO1xyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja193aG9sZShncm91cCwgdW5pcXVlKSB7XHJcblx0bGV0IG1ha2VyO1xyXG5cdGxldCBzaGFyZWQgPSBbXTtcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdGxldCB3aG9sZSA9IFdIT0xFX01BUC5nZXQoY3ApO1xyXG5cdFx0aWYgKHdob2xlID09PSBVTklRVUVfUEgpIHJldHVybjsgLy8gdW5pcXVlLCBub24tY29uZnVzYWJsZVxyXG5cdFx0aWYgKHdob2xlKSB7XHJcblx0XHRcdGxldCBzZXQgPSB3aG9sZS5NLmdldChjcCk7IC8vIGdyb3VwcyB3aGljaCBoYXZlIGEgY2hhcmFjdGVyIHRoYXQgbG9vay1saWtlIHRoaXMgY2hhcmFjdGVyXHJcblx0XHRcdG1ha2VyID0gbWFrZXIgPyBtYWtlci5maWx0ZXIoZyA9PiBzZXQuaGFzKGcpKSA6IEFycmF5X2Zyb20oc2V0KTtcclxuXHRcdFx0aWYgKCFtYWtlci5sZW5ndGgpIHJldHVybjsgLy8gY29uZnVzYWJsZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHNoYXJlZC5wdXNoKGNwKTsgXHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChtYWtlcikge1xyXG5cdFx0Ly8gd2UgaGF2ZSAxKyBjb25mdXNhYmxlXHJcblx0XHQvLyBjaGVjayBpZiBhbnkgb2YgdGhlIHJlbWFpbmluZyBncm91cHNcclxuXHRcdC8vIGNvbnRhaW4gdGhlIHNoYXJlZCBjaGFyYWN0ZXJzIHRvb1xyXG5cdFx0Zm9yIChsZXQgZyBvZiBtYWtlcikge1xyXG5cdFx0XHRpZiAoc2hhcmVkLmV2ZXJ5KGNwID0+IGdyb3VwX2hhc19jcChnLCBjcCkpKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB3aG9sZS1zY3JpcHQgY29uZnVzYWJsZTogJHtncm91cC5OfS8ke2cuTn1gKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogdW5pcXVlLnNpemUgPiAwXHJcbi8vIHJldHVybnMgbGlzdCBvZiBtYXRjaGluZyBncm91cHNcclxuZnVuY3Rpb24gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSkge1xyXG5cdGxldCBncm91cHMgPSBHUk9VUFM7XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHQvLyBub3RlOiB3ZSBuZWVkIHRvIGRvZGdlIENNIHRoYXQgYXJlIHdoaXRlbGlzdGVkXHJcblx0XHQvLyBidXQgdGhhdCBjb2RlIGlzbid0IGN1cnJlbnRseSBuZWNlc3NhcnlcclxuXHRcdGxldCBncyA9IGdyb3Vwcy5maWx0ZXIoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKTtcclxuXHRcdGlmICghZ3MubGVuZ3RoKSB7XHJcblx0XHRcdGlmICghR1JPVVBTLnNvbWUoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkgeyBcclxuXHRcdFx0XHQvLyB0aGUgY2hhcmFjdGVyIHdhcyBjb21wb3NlZCBvZiB2YWxpZCBwYXJ0c1xyXG5cdFx0XHRcdC8vIGJ1dCBpdCdzIE5GQyBmb3JtIGlzIGludmFsaWRcclxuXHRcdFx0XHQvLyAyMDIzMDcxNjogY2hhbmdlIHRvIG1vcmUgZXhhY3Qgc3RhdGVtZW50LCBzZWU6IEVOU05vcm1hbGl6ZS57Y3MsamF2YX1cclxuXHRcdFx0XHQvLyBub3RlOiB0aGlzIGRvZXNuJ3QgaGF2ZSB0byBiZSBhIGNvbXBvc2l0aW9uXHJcblx0XHRcdFx0Ly8gMjAyMzA3MjA6IGNoYW5nZSB0byBmdWxsIGNoZWNrXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZGlzYWxsb3dlZChjcCk7IC8vIHRoaXMgc2hvdWxkIGJlIHJhcmVcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBncm91cCB0aGF0IGNvbnRhaW5zIGFsbCB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0XHRcdFx0Ly8gdGhyb3cgdXNpbmcgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgZ3JvdXAgdGhhdCBtYXRjaGVkXHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZ3JvdXBzWzBdLCBjcCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGdyb3VwcyA9IGdzO1xyXG5cdFx0aWYgKGdzLmxlbmd0aCA9PSAxKSBicmVhazsgLy8gdGhlcmUgaXMgb25seSBvbmUgZ3JvdXAgbGVmdFxyXG5cdH1cclxuXHQvLyB0aGVyZSBhcmUgYXQgbGVhc3QgMSBncm91cChzKSB3aXRoIGFsbCBvZiB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0cmV0dXJuIGdyb3VwcztcclxufVxyXG5cclxuLy8gdGhyb3cgb24gZmlyc3QgZXJyb3JcclxuZnVuY3Rpb24gZmxhdHRlbihzcGxpdCkge1xyXG5cdHJldHVybiBzcGxpdC5tYXAoKHtpbnB1dCwgZXJyb3IsIG91dHB1dH0pID0+IHtcclxuXHRcdGlmIChlcnJvcikge1xyXG5cdFx0XHQvLyBkb24ndCBwcmludCBsYWJlbCBhZ2FpbiBpZiBqdXN0IGEgc2luZ2xlIGxhYmVsXHJcblx0XHRcdGxldCBtc2cgPSBlcnJvci5tZXNzYWdlO1xyXG5cdFx0XHQvLyBiaWRpX3FxKCkgb25seSBuZWNlc3NhcnkgaWYgbXNnIGlzIGRpZ2l0c1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc3BsaXQubGVuZ3RoID09IDEgPyBtc2cgOiBgSW52YWxpZCBsYWJlbCAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoaW5wdXQsIDYzKSl9OiAke21zZ31gKTsgXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyX2Zyb21fY3BzKG91dHB1dCk7XHJcblx0fSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3JfZGlzYWxsb3dlZChjcCkge1xyXG5cdC8vIFRPRE86IGFkZCBjcCB0byBlcnJvcj9cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWRfY3AoY3ApfWApOyBcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApIHtcclxuXHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRsZXQgZ2cgPSBHUk9VUFMuZmluZChnID0+IGcuUC5oYXMoY3ApKTsgLy8gb25seSBjaGVjayBwcmltYXJ5XHJcblx0aWYgKGdnKSB7XHJcblx0XHRxdW90ZWQgPSBgJHtnZy5OfSAke3F1b3RlZH1gO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIG1peHR1cmU6ICR7Zy5OfSArICR7cXVvdGVkfWApO1xyXG59XHJcbmZ1bmN0aW9uIGVycm9yX3BsYWNlbWVudCh3aGVyZSkge1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgcGxhY2VtZW50OiAke3doZXJlfWApO1xyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiBjcHMubGVuZ3RoID4gMFxyXG4vLyBhc3N1bXB0aW9uOiBjcHNbMF0gaXNuJ3QgYSBDTVxyXG4vLyBhc3N1bXB0aW9uOiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzbid0IGFuIGVtb2ppXHJcbmZ1bmN0aW9uIGNoZWNrX2dyb3VwKGcsIGNwcykge1xyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0aWYgKCFncm91cF9oYXNfY3AoZywgY3ApKSB7XHJcblx0XHRcdC8vIGZvciB3aGl0ZWxpc3RlZCBzY3JpcHRzLCB0aGlzIHdpbGwgdGhyb3cgaWxsZWdhbCBtaXh0dXJlIG9uIGludmFsaWQgY20sIGVnLiBcImV7MzAwfXszMDB9XCJcclxuXHRcdFx0Ly8gYXQgdGhlIG1vbWVudCwgaXQncyB1bm5lY2Vzc2FyeSB0byBpbnRyb2R1Y2UgYW4gZXh0cmEgZXJyb3IgdHlwZVxyXG5cdFx0XHQvLyB1bnRpbCB0aGVyZSBleGlzdHMgYSB3aGl0ZWxpc3RlZCBtdWx0aS1jaGFyYWN0ZXJcclxuXHRcdFx0Ly8gICBlZy4gaWYgKE0gPCAwICYmIGlzX2NvbWJpbmluZ19tYXJrKGNwKSkgeyAuLi4gfVxyXG5cdFx0XHQvLyB0aGVyZSBhcmUgMyBjYXNlczpcclxuXHRcdFx0Ly8gICAxLiBpbGxlZ2FsIGNtIGZvciB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdC8vICAgMi4gaWxsZWdhbCBjbSBmb3Igc2FtZSBncm91cCA9PiBjbSBlcnJvclxyXG5cdFx0XHQvLyAgICAgICByZXF1aXJlcyBzZXQgb2Ygd2hpdGVsaXN0IGNtIHBlciBncm91cDogXHJcblx0XHRcdC8vICAgICAgICBlZy4gbmV3IFNldChbLi4uZy5QLCAuLi5nLlFdLmZsYXRNYXAobmZjKS5maWx0ZXIoY3AgPT4gQ00uaGFzKGNwKSkpXHJcblx0XHRcdC8vICAgMy4gd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvL2lmIChNID49IDApIHsgLy8gd2UgaGF2ZSBhIGtub3duIGZpeGVkIGNtIGNvdW50XHJcblx0aWYgKGcuTSkgeyAvLyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBOU01cclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHNlZTogYXNzdW1wdGlvblxyXG5cdFx0XHQvLyAyMDIzMDIxMDogYnVnZml4OiB1c2luZyBjcHMgaW5zdGVhZCBvZiBkZWNvbXBvc2VkIGgvdCBDYXJib24yMjVcclxuXHRcdFx0LypcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiAke2cuTn0gJHtiaWRpX3FxKHN0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvLyAyMDIzMDIxNzogc3dpdGNoIHRvIE5TTSBjb3VudGluZ1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI09wdGlvbmFsX0RldGVjdGlvblxyXG5cdFx0XHRpZiAoTlNNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0Zm9yIChsZXQgY3A7IGogPCBlICYmIE5TTS5oYXMoY3AgPSBkZWNvbXBvc2VkW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0XHQvLyBhLiBGb3JiaWQgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIG5vbnNwYWNpbmcgbWFyay5cclxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSBpOyBrIDwgajsgaysrKSB7IC8vIE8obl4yKSBidXQgbiA8IDEwMFxyXG5cdFx0XHRcdFx0XHRpZiAoZGVjb21wb3NlZFtrXSA9PSBjcCkge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIG5vbi1zcGFjaW5nIG1hcmtzOiAke3F1b3RlZF9jcChjcCl9YCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gcGFyc2UgdG8gZW5kIHNvIHdlIGhhdmUgZnVsbCBuc20gY291bnRcclxuXHRcdFx0XHQvLyBiLiBGb3JiaWQgc2VxdWVuY2VzIG9mIG1vcmUgdGhhbiA0IG5vbnNwYWNpbmcgbWFya3MgKGdjPU1uIG9yIGdjPU1lKS5cclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBOU01fTUFYKSB7XHJcblx0XHRcdFx0XHQvLyBub3RlOiB0aGlzIHNsaWNlIHN0YXJ0cyB3aXRoIGEgYmFzZSBjaGFyIG9yIHNwYWNpbmctbWFyayBjbVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBleGNlc3NpdmUgbm9uLXNwYWNpbmcgbWFya3M6ICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke05TTV9NQVh9KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0LypcclxuXHRsZXQgY21fd2hpdGVsaXN0ID0gTSBpbnN0YW5jZW9mIE1hcDtcclxuXHRmb3IgKGxldCBpID0gMCwgZSA9IGNwcy5sZW5ndGg7IGkgPCBlOyApIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpKytdO1xyXG5cdFx0bGV0IHNlcXMgPSBjbV93aGl0ZWxpc3QgJiYgTS5nZXQoY3ApO1xyXG5cdFx0aWYgKHNlcXMpIHsgXHJcblx0XHRcdC8vIGxpc3Qgb2YgY29kZXBvaW50cyB0aGF0IGNhbiBmb2xsb3dcclxuXHRcdFx0Ly8gaWYgdGhpcyBleGlzdHMsIHRoaXMgd2lsbCBhbHdheXMgYmUgMStcclxuXHRcdFx0bGV0IGogPSBpO1xyXG5cdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGNwc1tqXSkpIGorKztcclxuXHRcdFx0bGV0IGNtcyA9IGNwcy5zbGljZShpLCBqKTtcclxuXHRcdFx0bGV0IG1hdGNoID0gc2Vxcy5maW5kKHNlcSA9PiAhY29tcGFyZV9hcnJheXMoc2VxLCBjbXMpKTtcclxuXHRcdFx0aWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNvbWJpbmluZyBtYXJrIHNlcXVlbmNlOiBcIiR7c2FmZV9zdHJfZnJvbV9jcHMoW2NwLCAuLi5jbXNdKX1cImApO1xyXG5cdFx0XHRpID0gajtcclxuXHRcdH0gZWxzZSBpZiAoIVYuaGFzKGNwKSkge1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRcdFx0bGV0IHUgPSBVTklRVUUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAodSAmJiB1ICE9PSBnKSB7XHJcblx0XHRcdFx0XHQvLyBpZiBib3RoIHNjcmlwdHMgYXJlIHJlc3RyaWN0ZWQgdGhpcyBlcnJvciBpcyBjb25mdXNpbmdcclxuXHRcdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3QgZGlmZmVyZW50aWF0ZSBSZXN0cmljdGVkQSBmcm9tIFJlc3RyaWN0ZWRCIFxyXG5cdFx0XHRcdFx0aWYgKCF1LlIpIHF1b3RlZCA9IGAke3F1b3RlZH0gaXMgJHt1Lk59YDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgJHtnLk59IGNoYXJhY3RlcjogJHtxdW90ZWR9YCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWR9IChleHBlY3RlZCAke2cuTn0pYCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGAke2cuTn0gZG9lcyBub3QgYWxsb3c6ICR7cXVvdGVkfWApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoIWNtX3doaXRlbGlzdCkge1xyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gd2Uga25vdyBpdCBjYW4ndCBiZSBjbSBsZWFkaW5nXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogXCIke3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpfVwiICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ki9cclxufVxyXG5cclxuLy8gZ2l2ZW4gYSBsaXN0IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyBhIGxpc3Qgb2YgbGlzdHMsIHdoZXJlIGVtb2ppIGFyZSBhIGZ1bGx5LXF1YWxpZmllZCAoYXMgQXJyYXkgc3ViY2xhc3MpXHJcbi8vIGVnLiBleHBsb2RlX2NwKFwiYWJj8J+SqWRcIikgPT4gW1s2MSwgNjIsIDYzXSwgRW1vamlbMUY0QTksIEZFMEZdLCBbNjRdXVxyXG4vLyAyMDIzMDgxODogcmVuYW1lIGZvciAncHJvY2VzcycgbmFtZSBjb2xsaXNpb24gaC90IEphdmFyb21lXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzIzXHJcbmZ1bmN0aW9uIHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBjaGFycyA9IFtdO1xyXG5cdGlucHV0ID0gaW5wdXQuc2xpY2UoKS5yZXZlcnNlKCk7IC8vIGZsaXAgc28gd2UgY2FuIHBvcFxyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQpO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdFx0XHRcdGNoYXJzID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0LnB1c2goZWYoZW1vamkpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdGNoYXJzLnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHRjaGFycy5wdXNoKC4uLmNwcyk7IC8vIGxlc3MgdGhhbiAxMCBlbGVtZW50c1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIUlHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzA5MTI6IHVuaWNvZGUgMTUuMSBjaGFuZ2VkIHRoZSBvcmRlciBvZiBwcm9jZXNzaW5nIHN1Y2ggdGhhdFxyXG5cdFx0XHRcdFx0Ly8gZGlzYWxsb3dlZCBwYXJ0cyBhcmUgb25seSByZWplY3RlZCBhZnRlciBORkNcclxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2Vzbid0IGltcGFjdCBub3JtYWxpemF0aW9uIGFzIG9mIHRvZGF5XHJcblx0XHRcdFx0XHQvLyB0ZWNobmljYWxseSwgdGhpcyBlcnJvciBjYW4gYmUgcmVtb3ZlZCBhcyB0aGUgZ3JvdXAgbG9naWMgd2lsbCBhcHBseSBzaW1pbGFyIGxvZ2ljXHJcblx0XHRcdFx0XHQvLyBob3dldmVyIHRoZSBlcnJvciB0eXBlIG1pZ2h0IGJlIGxlc3MgY2xlYXJcclxuXHRcdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJfZmUwZihjcHMpIHtcclxuXHRyZXR1cm4gY3BzLmZpbHRlcihjcCA9PiBjcCAhPSBGRTBGKTtcclxufVxyXG5cclxuLy8gZ2l2ZW4gYXJyYXkgb2YgY29kZXBvaW50c1xyXG4vLyByZXR1cm5zIHRoZSBsb25nZXN0IHZhbGlkIGVtb2ppIHNlcXVlbmNlIChvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2gpXHJcbi8vICpNVVRBVEVTKiB0aGUgc3VwcGxpZWQgYXJyYXlcclxuLy8gZGlzYWxsb3dzIGludGVybGVhdmVkIGlnbm9yZWQgY2hhcmFjdGVyc1xyXG4vLyBmaWxscyAob3B0aW9uYWwpIGVhdGVuIGFycmF5IHdpdGggbWF0Y2hlZCBjb2RlcG9pbnRzXHJcbmZ1bmN0aW9uIGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoY3BzLCBlYXRlbikge1xyXG5cdGxldCBub2RlID0gRU1PSklfUk9PVDtcclxuXHRsZXQgZW1vamk7XHJcblx0bGV0IHBvcyA9IGNwcy5sZW5ndGg7XHJcblx0d2hpbGUgKHBvcykge1xyXG5cdFx0bm9kZSA9IG5vZGUuZ2V0KGNwc1stLXBvc10pO1xyXG5cdFx0aWYgKCFub2RlKSBicmVhaztcclxuXHRcdGxldCB7Vn0gPSBub2RlO1xyXG5cdFx0aWYgKFYpIHsgLy8gdGhpcyBpcyBhIHZhbGlkIGVtb2ppIChzbyBmYXIpXHJcblx0XHRcdGVtb2ppID0gVjtcclxuXHRcdFx0aWYgKGVhdGVuKSBlYXRlbi5wdXNoKC4uLmNwcy5zbGljZShwb3MpLnJldmVyc2UoKSk7IC8vIChvcHRpb25hbCkgY29weSBpbnB1dCwgdXNlZCBmb3IgZW5zX3Rva2VuaXplKClcclxuXHRcdFx0Y3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGVtb2ppO1xyXG59XHJcblxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gdG9rZW5pemVyIFxyXG5cclxuY29uc3QgVFlfVkFMSUQgPSAndmFsaWQnO1xyXG5jb25zdCBUWV9NQVBQRUQgPSAnbWFwcGVkJztcclxuY29uc3QgVFlfSUdOT1JFRCA9ICdpZ25vcmVkJztcclxuY29uc3QgVFlfRElTQUxMT1dFRCA9ICdkaXNhbGxvd2VkJztcclxuY29uc3QgVFlfRU1PSkkgPSAnZW1vamknO1xyXG5jb25zdCBUWV9ORkMgPSAnbmZjJztcclxuY29uc3QgVFlfU1RPUCA9ICdzdG9wJztcclxuXHJcbmZ1bmN0aW9uIGVuc190b2tlbml6ZShuYW1lLCB7XHJcblx0bmYgPSB0cnVlLCAvLyBjb2xsYXBzZSB1bm5vcm1hbGl6ZWQgcnVucyBpbnRvIGEgc2luZ2xlIHRva2VuXHJcbn0gPSB7fSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTtcclxuXHRsZXQgZWF0ZW4gPSBbXTtcclxuXHRsZXQgdG9rZW5zID0gW107XHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCwgZWF0ZW4pO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdHRva2Vucy5wdXNoKHtcclxuXHRcdFx0XHR0eXBlOiBUWV9FTU9KSSxcclxuXHRcdFx0XHRlbW9qaTogZW1vamkuc2xpY2UoKSwgLy8gY29weSBlbW9qaVxyXG5cdFx0XHRcdGlucHV0OiBlYXRlbixcclxuXHRcdFx0XHRjcHM6IGZpbHRlcl9mZTBmKGVtb2ppKVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0ZWF0ZW4gPSBbXTsgLy8gcmVzZXQgYnVmZmVyXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKGNwID09IFNUT1ApIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfU1RPUCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1ZBTElELCBjcHM6IFtjcF19KTtcclxuXHRcdFx0fSBlbHNlIGlmIChJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfSUdOT1JFRCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX01BUFBFRCwgY3AsIGNwczogY3BzLnNsaWNlKCl9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0RJU0FMTE9XRUQsIGNwfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChuZikge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gLTE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IHRva2VuID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHRva2VuLnR5cGUpKSB7XHJcblx0XHRcdFx0aWYgKHJlcXVpcmVzX2NoZWNrKHRva2VuLmNwcykpIHsgLy8gbm9ybWFsaXphdGlvbiBtaWdodCBiZSBuZWVkZWRcclxuXHRcdFx0XHRcdGxldCBlbmQgPSBpICsgMTtcclxuXHRcdFx0XHRcdGZvciAobGV0IHBvcyA9IGVuZDsgcG9zIDwgdG9rZW5zLmxlbmd0aDsgcG9zKyspIHsgLy8gZmluZCBhZGphY2VudCB0ZXh0XHJcblx0XHRcdFx0XHRcdGxldCB7dHlwZSwgY3BzfSA9IHRva2Vuc1twb3NdO1xyXG5cdFx0XHRcdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFyZXF1aXJlc19jaGVjayhjcHMpKSBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRlbmQgPSBwb3MgKyAxO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gfHwgdHlwZSAhPT0gVFlfRElTQUxMT1dFRCkgeyBcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBpO1xyXG5cdFx0XHRcdFx0bGV0IHNsaWNlID0gdG9rZW5zLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cdFx0XHRcdFx0bGV0IGNwczAgPSBzbGljZS5mbGF0TWFwKHggPT4gaXNfdmFsaWRfb3JfbWFwcGVkKHgudHlwZSkgPyB4LmNwcyA6IFtdKTsgLy8gc3RyaXAganVuayB0b2tlbnNcclxuXHRcdFx0XHRcdGxldCBjcHMgPSBuZmMoY3BzMCk7XHJcblx0XHRcdFx0XHRpZiAoY29tcGFyZV9hcnJheXMoY3BzLCBjcHMwKSkgeyAvLyBidW5kbGUgaW50byBhbiBuZmMgdG9rZW5cclxuXHRcdFx0XHRcdFx0dG9rZW5zLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQsIHtcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBUWV9ORkMsIFxyXG5cdFx0XHRcdFx0XHRcdGlucHV0OiBjcHMwLCAvLyB0aGVyZSBhcmUgMyBzdGF0ZXM6IHRva2VuczAgPT0ocHJvY2Vzcyk9PiBpbnB1dCA9PShuZmMpPT4gdG9rZW5zL2Nwc1xyXG5cdFx0XHRcdFx0XHRcdGNwcywgXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zMDogY29sbGFwc2VfdmFsaWRfdG9rZW5zKHNsaWNlKSxcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnM6IGVuc190b2tlbml6ZShzdHJfZnJvbV9jcHMoY3BzKSwge25mOiBmYWxzZX0pXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRpID0gc3RhcnQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgeyBcclxuXHRcdFx0XHRcdFx0aSA9IGVuZCAtIDE7IC8vIHNraXAgdG8gZW5kIG9mIHNsaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdGFydCA9IGk7IC8vIHJlbWVtYmVyIGxhc3RcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyAyMDIyMTAyNDogaXMgdGhpcyBjb3JyZWN0P1xyXG5cdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc192YWxpZF9vcl9tYXBwZWQodHlwZSkge1xyXG5cdHJldHVybiB0eXBlID09IFRZX1ZBTElEIHx8IHR5cGUgPT0gVFlfTUFQUEVEO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlc19jaGVjayhjcHMpIHtcclxuXHRyZXR1cm4gY3BzLnNvbWUoY3AgPT4gTkZDX0NIRUNLLmhhcyhjcCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKSB7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0b2tlbnNbaV0udHlwZSA9PSBUWV9WQUxJRCkge1xyXG5cdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHR3aGlsZSAoaiA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2pdLnR5cGUgPT0gVFlfVkFMSUQpIGorKztcclxuXHRcdFx0dG9rZW5zLnNwbGljZShpLCBqIC0gaSwge3R5cGU6IFRZX1ZBTElELCBjcHM6IHRva2Vucy5zbGljZShpLCBqKS5mbGF0TWFwKHggPT4geC5jcHMpfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0b2tlbnM7XHJcbn1cclxuXHJcbmV4cG9ydCB7IGVuc19iZWF1dGlmeSwgZW5zX2Vtb2ppLCBlbnNfbm9ybWFsaXplLCBlbnNfbm9ybWFsaXplX2ZyYWdtZW50LCBlbnNfc3BsaXQsIGVuc190b2tlbml6ZSwgaXNfY29tYmluaW5nX21hcmssIG5mYywgbmZkLCBzYWZlX3N0cl9mcm9tX2Nwcywgc2hvdWxkX2VzY2FwZSB9O1xyXG4iLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgaGV4bGlmeSwgYXNzZXJ0QXJndW1lbnQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tIFwiQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZVwiO1xyXG5jb25zdCBaZXJvcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcclxuWmVyb3MuZmlsbCgwKTtcclxuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoY29tcCkge1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoY29tcC5sZW5ndGggIT09IDAsIFwiaW52YWxpZCBFTlMgbmFtZTsgZW1wdHkgY29tcG9uZW50XCIsIFwiY29tcFwiLCBjb21wKTtcclxuICAgIHJldHVybiBjb21wO1xyXG59XHJcbmZ1bmN0aW9uIGVuc05hbWVTcGxpdChuYW1lKSB7XHJcbiAgICBjb25zdCBieXRlcyA9IHRvVXRmOEJ5dGVzKGVuc05vcm1hbGl6ZShuYW1lKSk7XHJcbiAgICBjb25zdCBjb21wcyA9IFtdO1xyXG4gICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBzO1xyXG4gICAgfVxyXG4gICAgbGV0IGxhc3QgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGQgPSBieXRlc1tpXTtcclxuICAgICAgICAvLyBBIHNlcGFyYXRvciAoaS5lLiBcIi5cIik7IGNvcHkgdGhpcyBjb21wb25lbnRcclxuICAgICAgICBpZiAoZCA9PT0gMHgyZSkge1xyXG4gICAgICAgICAgICBjb21wcy5wdXNoKGNoZWNrQ29tcG9uZW50KGJ5dGVzLnNsaWNlKGxhc3QsIGkpKSk7XHJcbiAgICAgICAgICAgIGxhc3QgPSBpICsgMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBUaGVyZSB3YXMgYSBzdHJheSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgbmFtZVxyXG4gICAgYXNzZXJ0QXJndW1lbnQobGFzdCA8IGJ5dGVzLmxlbmd0aCwgXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xyXG4gICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0KSkpO1xyXG4gICAgcmV0dXJuIGNvbXBzO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJucyB0aGUgRU5TICUlbmFtZSUlIG5vcm1hbGl6ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW5zTm9ybWFsaXplKG5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IGxhYmVsXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW5zX25vcm1hbGl6ZShuYW1lKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBFTlMgbmFtZSAoJHtlcnJvci5tZXNzYWdlfSlgLCBcIm5hbWVcIiwgbmFtZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlbmFtZSUlIGlzIGEgdmFsaWQgRU5TIG5hbWUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZE5hbWUobmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKGVuc05hbWVTcGxpdChuYW1lKS5sZW5ndGggIT09IDApO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogIFJldHVybnMgdGhlIFtbbGluay1uYW1laGFzaF1dIGZvciAlJW5hbWUlJS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBuYW1laGFzaChuYW1lKSB7XHJcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgRU5TIG5hbWU7IG5vdCBhIHN0cmluZ1wiLCBcIm5hbWVcIiwgbmFtZSk7XHJcbiAgICBhc3NlcnRBcmd1bWVudChuYW1lLmxlbmd0aCwgYGludmFsaWQgRU5TIG5hbWUgKGVtcHR5IGxhYmVsKWAsIFwibmFtZVwiLCBuYW1lKTtcclxuICAgIGxldCByZXN1bHQgPSBaZXJvcztcclxuICAgIGNvbnN0IGNvbXBzID0gZW5zTmFtZVNwbGl0KG5hbWUpO1xyXG4gICAgd2hpbGUgKGNvbXBzLmxlbmd0aCkge1xyXG4gICAgICAgIHJlc3VsdCA9IGtlY2NhazI1Nihjb25jYXQoW3Jlc3VsdCwga2VjY2FrMjU2KChjb21wcy5wb3AoKSkpXSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcclxufVxyXG4vKipcclxuICogIFJldHVybnMgdGhlIEROUyBlbmNvZGVkICUlbmFtZSUlLlxyXG4gKlxyXG4gKiAgVGhpcyBpcyB1c2VkIGZvciB2YXJpb3VzIHBhcnRzIG9mIEVOUyBuYW1lIHJlc29sdXRpb24sIHN1Y2hcclxuICogIGFzIHRoZSB3aWxkY2FyZCByZXNvbHV0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRuc0VuY29kZShuYW1lLCBfbWF4TGVuZ3RoKSB7XHJcbiAgICBjb25zdCBsZW5ndGggPSAoX21heExlbmd0aCAhPSBudWxsKSA/IF9tYXhMZW5ndGggOiA2MztcclxuICAgIGFzc2VydEFyZ3VtZW50KGxlbmd0aCA8PSAyNTUsIFwiRE5TIGVuY29kZWQgbGFiZWwgY2Fubm90IGV4Y2VlZCAyNTVcIiwgXCJsZW5ndGhcIiwgbGVuZ3RoKTtcclxuICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChlbnNOYW1lU3BsaXQobmFtZSkubWFwKChjb21wKSA9PiB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoY29tcC5sZW5ndGggPD0gbGVuZ3RoLCBgbGFiZWwgJHtKU09OLnN0cmluZ2lmeShuYW1lKX0gZXhjZWVkcyAke2xlbmd0aH0gYnl0ZXNgLCBcIm5hbWVcIiwgbmFtZSk7XHJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjb21wLmxlbmd0aCArIDEpO1xyXG4gICAgICAgIGJ5dGVzLnNldChjb21wLCAxKTtcclxuICAgICAgICBieXRlc1swXSA9IGJ5dGVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xyXG4gICAgfSkpKSArIFwiMDBcIjtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1laGFzaC5qcy5tYXAiLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IE1lc3NhZ2VQcmVmaXggfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuLyoqXHJcbiAqICBDb21wdXRlcyB0aGUgW1tsaW5rLWVpcC0xOTFdXSBwZXJzb25hbC1zaWduIG1lc3NhZ2UgZGlnZXN0IHRvIHNpZ24uXHJcbiAqXHJcbiAqICBUaGlzIHByZWZpeGVzIHRoZSBtZXNzYWdlIHdpdGggW1tNZXNzYWdlUHJlZml4XV0gYW5kIHRoZSBkZWNpbWFsIGxlbmd0aFxyXG4gKiAgb2YgJSVtZXNzYWdlJSUgYW5kIGNvbXB1dGVzIHRoZSBbW2tlY2NhazI1Nl1dIGRpZ2VzdC5cclxuICpcclxuICogIElmICUlbWVzc2FnZSUlIGlzIGEgc3RyaW5nLCBpdCBpcyBjb252ZXJ0ZWQgdG8gaXRzIFVURi04IGJ5dGVzXHJcbiAqICBmaXJzdC4gVG8gY29tcHV0ZSB0aGUgZGlnZXN0IG9mIGEgW1tEYXRhSGV4U3RyaW5nXV0sIGl0IG11c3QgYmUgY29udmVydGVkXHJcbiAqICB0byBbYnl0ZXNdKGdldEJ5dGVzKS5cclxuICpcclxuICogIEBleGFtcGxlOlxyXG4gKiAgICBoYXNoTWVzc2FnZShcIkhlbGxvIFdvcmxkXCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgLy8gSGFzaGVzIHRoZSBTSVggKDYpIHN0cmluZyBjaGFyYWN0ZXJzLCBpLmUuXHJcbiAqICAgIC8vIFsgXCIwXCIsIFwieFwiLCBcIjRcIiwgXCIyXCIsIFwiNFwiLCBcIjNcIiBdXHJcbiAqICAgIGhhc2hNZXNzYWdlKFwiMHg0MjQzXCIpXHJcbiAqICAgIC8vX3Jlc3VsdDpcclxuICpcclxuICogICAgLy8gSGFzaGVzIHRoZSBUV08gKDIpIGJ5dGVzIFsgMHg0MiwgMHg0MyBdLi4uXHJcbiAqICAgIGhhc2hNZXNzYWdlKGdldEJ5dGVzKFwiMHg0MjQzXCIpKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqICAgIC8vIC4uLndoaWNoIGlzIGVxdWFsIHRvIHVzaW5nIGRhdGFcclxuICogICAgaGFzaE1lc3NhZ2UobmV3IFVpbnQ4QXJyYXkoWyAweDQyLCAweDQzIF0pKVxyXG4gKiAgICAvL19yZXN1bHQ6XHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzaE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgaWYgKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBtZXNzYWdlID0gdG9VdGY4Qnl0ZXMobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChbXHJcbiAgICAgICAgdG9VdGY4Qnl0ZXMoTWVzc2FnZVByZWZpeCksXHJcbiAgICAgICAgdG9VdGY4Qnl0ZXMoU3RyaW5nKG1lc3NhZ2UubGVuZ3RoKSksXHJcbiAgICAgICAgbWVzc2FnZVxyXG4gICAgXSkpO1xyXG59XHJcbi8qKlxyXG4gKiAgUmV0dXJuIHRoZSBhZGRyZXNzIG9mIHRoZSBwcml2YXRlIGtleSB0aGF0IHByb2R1Y2VkXHJcbiAqICB0aGUgc2lnbmF0dXJlICUlc2lnJSUgZHVyaW5nIHNpZ25pbmcgZm9yICUlbWVzc2FnZSUlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeU1lc3NhZ2UobWVzc2FnZSwgc2lnKSB7XHJcbiAgICBjb25zdCBkaWdlc3QgPSBoYXNoTWVzc2FnZShtZXNzYWdlKTtcclxuICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZS5qcy5tYXAiLCIvL2ltcG9ydCB7IFR5cGVkRGF0YURvbWFpbiwgVHlwZWREYXRhRmllbGQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJhYnN0cmFjdC1zaWduZXJcIjtcclxuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgY29uY2F0LCBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgbWFzaywgdG9CZUhleCwgdG9RdWFudGl0eSwgdG9Ud29zLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4vaWQuanNcIjtcclxuY29uc3QgcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KDMyKTtcclxucGFkZGluZy5maWxsKDApO1xyXG5jb25zdCBCTl9fMSA9IEJpZ0ludCgtMSk7XHJcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XHJcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XHJcbmNvbnN0IEJOX01BWF9VSU5UMjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xyXG47XHJcbjtcclxuZnVuY3Rpb24gaGV4UGFkUmlnaHQodmFsdWUpIHtcclxuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUpO1xyXG4gICAgY29uc3QgcGFkT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgMzI7XHJcbiAgICBpZiAocGFkT2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbYnl0ZXMsIHBhZGRpbmcuc2xpY2UocGFkT2Zmc2V0KV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xyXG59XHJcbmNvbnN0IGhleFRydWUgPSB0b0JlSGV4KEJOXzEsIDMyKTtcclxuY29uc3QgaGV4RmFsc2UgPSB0b0JlSGV4KEJOXzAsIDMyKTtcclxuY29uc3QgZG9tYWluRmllbGRUeXBlcyA9IHtcclxuICAgIG5hbWU6IFwic3RyaW5nXCIsXHJcbiAgICB2ZXJzaW9uOiBcInN0cmluZ1wiLFxyXG4gICAgY2hhaW5JZDogXCJ1aW50MjU2XCIsXHJcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogXCJhZGRyZXNzXCIsXHJcbiAgICBzYWx0OiBcImJ5dGVzMzJcIlxyXG59O1xyXG5jb25zdCBkb21haW5GaWVsZE5hbWVzID0gW1xyXG4gICAgXCJuYW1lXCIsIFwidmVyc2lvblwiLCBcImNoYWluSWRcIiwgXCJ2ZXJpZnlpbmdDb250cmFjdFwiLCBcInNhbHRcIlxyXG5dO1xyXG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciAke0pTT04uc3RyaW5naWZ5KGtleSl9YCwgYGRvbWFpbi4ke2tleX1gLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBkb21haW5DaGVja3MgPSB7XHJcbiAgICBuYW1lOiBjaGVja1N0cmluZyhcIm5hbWVcIiksXHJcbiAgICB2ZXJzaW9uOiBjaGVja1N0cmluZyhcInZlcnNpb25cIiksXHJcbiAgICBjaGFpbklkOiBmdW5jdGlvbiAoX3ZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcImRvbWFpbi5jaGFpbklkXCIpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IDAsIFwiaW52YWxpZCBjaGFpbiBJRFwiLCBcImRvbWFpbi5jaGFpbklkXCIsIF92YWx1ZSk7XHJcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkodmFsdWUpO1xyXG4gICAgfSxcclxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgZG9tYWluIHZhbHVlIFwidmVyaWZ5aW5nQ29udHJhY3RcImAsIFwiZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XCIsIHZhbHVlKTtcclxuICAgIH0sXHJcbiAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHZhbHVlLCBcImRvbWFpbi5zYWx0XCIpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gMzIsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInNhbHRcImAsIFwiZG9tYWluLnNhbHRcIiwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gZ2V0QmFzZUVuY29kZXIodHlwZSkge1xyXG4gICAgLy8gaW50WFggYW5kIHVpbnRYWFxyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXih1PylpbnQoXFxkKykkLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh3aWR0aCAlIDggPT09IDAgJiYgd2lkdGggIT09IDAgJiYgd2lkdGggPD0gMjU2ICYmIG1hdGNoWzJdID09PSBTdHJpbmcod2lkdGgpLCBcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc1VwcGVyID0gbWFzayhCTl9NQVhfVUlOVDI1Niwgc2lnbmVkID8gKHdpZHRoIC0gMSkgOiB3aWR0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc0xvd2VyID0gc2lnbmVkID8gKChib3VuZHNVcHBlciArIEJOXzEpICogQk5fXzEpIDogQk5fMDtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IGJvdW5kc0xvd2VyICYmIHZhbHVlIDw9IGJvdW5kc1VwcGVyLCBgdmFsdWUgb3V0LW9mLWJvdW5kcyBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvQmVIZXgoc2lnbmVkID8gdG9Ud29zKHZhbHVlLCAyNTYpIDogdmFsdWUsIDMyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBieXRlc1hYXHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKykkLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh3aWR0aCAhPT0gMCAmJiB3aWR0aCA8PSAzMiAmJiBtYXRjaFsxXSA9PT0gU3RyaW5nKHdpZHRoKSwgXCJpbnZhbGlkIGJ5dGVzIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChieXRlcy5sZW5ndGggPT09IHdpZHRoLCBgaW52YWxpZCBsZW5ndGggZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhQYWRSaWdodCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcImFkZHJlc3NcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZFZhbHVlKGdldEFkZHJlc3ModmFsdWUpLCAzMik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjYXNlIFwiYm9vbFwiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2FzZSBcImJ5dGVzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih2YWx1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gZW5jb2RlVHlwZShuYW1lLCBmaWVsZHMpIHtcclxuICAgIHJldHVybiBgJHtuYW1lfSgke2ZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiAodHlwZSArIFwiIFwiICsgbmFtZSkpLmpvaW4oXCIsXCIpfSlgO1xyXG59XHJcbi8vIGZvb1tdWzNdID0+IHsgYmFzZTogXCJmb29cIiwgaW5kZXg6IFwiW11bM11cIiwgYXJyYXk6IHtcclxuLy8gICAgIGJhc2U6IFwiZm9vXCIsIHByZWZpeDogXCJmb29bXVwiLCBjb3VudDogMyB9IH1cclxuZnVuY3Rpb24gc3BsaXRBcnJheSh0eXBlKSB7XHJcbiAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14oW15cXHg1Yl0qKSgoXFx4NWJcXGQqXFx4NWQpKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBiYXNlOiBtYXRjaFsxXSxcclxuICAgICAgICAgICAgaW5kZXg6IChtYXRjaFsyXSArIG1hdGNoWzRdKSxcclxuICAgICAgICAgICAgYXJyYXk6IHtcclxuICAgICAgICAgICAgICAgIGJhc2U6IG1hdGNoWzFdLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiAobWF0Y2hbMV0gKyBtYXRjaFsyXSksXHJcbiAgICAgICAgICAgICAgICBjb3VudDogKG1hdGNoWzVdID8gcGFyc2VJbnQobWF0Y2hbNV0pIDogLTEpLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGJhc2U6IHR5cGUgfTtcclxufVxyXG4vKipcclxuICogIEEgKipUeXBlZERhdGFFbmNvZGUqKiBwcmVwYXJlcyBhbmQgZW5jb2RlcyBbW2xpbmstZWlwLTcxMl1dIHBheWxvYWRzXHJcbiAqICBmb3Igc2lnbmVkIHR5cGVkIGRhdGEuXHJcbiAqXHJcbiAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgdGhvc2UgdGhhdCB3aXNoIHRvIGNvbXB1dGUgdmFyaW91cyBjb21wb25lbnRzIG9mIGFcclxuICogIHR5cGVkIGRhdGEgaGFzaCwgcHJpbWFyeSB0eXBlcywgb3Igc3ViLWNvbXBvbmVudHMsIGJ1dCBnZW5lcmFsbHkgdGhlXHJcbiAqICBoaWdoZXIgbGV2ZWwgW1tTaWduZXItc2lnblR5cGVkRGF0YV1dIGlzIG1vcmUgdXNlZnVsLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFR5cGVkRGF0YUVuY29kZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHByaW1hcnkgdHlwZSBmb3IgdGhlIHN0cnVjdHVyZWQgW1t0eXBlc11dLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGRlcml2ZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBbW3R5cGVzXV0sIHNpbmNlIG5vXHJcbiAgICAgKiAgcmVjdXJzaW9uIGlzIHBvc3NpYmxlLCBvbmNlIHRoZSBEQUcgZm9yIHRoZSB0eXBlcyBpcyBjb25zdHVyY3RlZFxyXG4gICAgICogIGludGVybmFsbHksIHRoZSBwcmltYXJ5IHR5cGUgbXVzdCBiZSB0aGUgb25seSByZW1haW5pbmcgdHlwZSB3aXRoXHJcbiAgICAgKiAgbm8gcGFyZW50IG5vZGVzLlxyXG4gICAgICovXHJcbiAgICBwcmltYXJ5VHlwZTtcclxuICAgICN0eXBlcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0eXBlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHR5cGVzKCkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuI3R5cGVzKTtcclxuICAgIH1cclxuICAgICNmdWxsVHlwZXM7XHJcbiAgICAjZW5jb2RlckNhY2hlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgcGVyZm9ybXMgYWxsIG5lY2Vzc2FyeSBjaGVja2luZyB0aGF0IHR5cGVzIGFyZSB2YWxpZCBhbmRcclxuICAgICAqICBkbyBub3QgdmlvbGF0ZSB0aGUgW1tsaW5rLWVpcC03MTJdXSBzdHJ1Y3R1cmFsIGNvbnN0cmFpbnRzIGFzXHJcbiAgICAgKiAgd2VsbCBhcyBjb21wdXRlcyB0aGUgW1twcmltYXJ5VHlwZV1dLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfdHlwZXMpIHtcclxuICAgICAgICB0aGlzLiNmdWxsVHlwZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIExpbmsgc3RydWN0IHR5cGVzIHRvIHRoZWlyIGRpcmVjdCBjaGlsZCBzdHJ1Y3RzXHJcbiAgICAgICAgY29uc3QgbGlua3MgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLy8gTGluayBzdHJ1Y3RzIHRvIHN0cnVjdHMgd2hpY2ggY29udGFpbiB0aGVtIGFzIGEgY2hpbGRcclxuICAgICAgICBjb25zdCBwYXJlbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIExpbmsgYWxsIHN1YnR5cGVzIHdpdGhpbiBhIGdpdmVuIHN0cnVjdFxyXG4gICAgICAgIGNvbnN0IHN1YnR5cGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IHR5cGVzID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMoX3R5cGVzKS5mb3JFYWNoKCh0eXBlKSA9PiB7XHJcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gX3R5cGVzW3R5cGVdLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgYmFzZSB0eXBlICh1bmxlc3MgbmFtZSBjb25mbGljdClcclxuICAgICAgICAgICAgICAgIGxldCB7IGJhc2UsIGluZGV4IH0gPSBzcGxpdEFycmF5KHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwiaW50XCIgJiYgIV90eXBlc1tcImludFwiXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBcImludDI1NlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwidWludFwiICYmICFfdHlwZXNbXCJ1aW50XCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IFwidWludDI1NlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgdHlwZTogKGJhc2UgKyAoaW5kZXggfHwgXCJcIikpIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsaW5rcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcclxuICAgICAgICAgICAgcGFyZW50cy5zZXQodHlwZSwgW10pO1xyXG4gICAgICAgICAgICBzdWJ0eXBlcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiN0eXBlcyA9IEpTT04uc3RyaW5naWZ5KHR5cGVzKTtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggZmllbGQgaGFzIGEgdW5pcXVlIG5hbWVcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCF1bmlxdWVOYW1lcy5oYXMoZmllbGQubmFtZSksIGBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZSAke0pTT04uc3RyaW5naWZ5KGZpZWxkLm5hbWUpfSBpbiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcclxuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChmaWVsZC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYmFzZSB0eXBlIChkcm9wIGFueSBhcnJheSBzcGVjaWZpZXJzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBzcGxpdEFycmF5KGZpZWxkLnR5cGUpLmJhc2U7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChiYXNlVHlwZSAhPT0gbmFtZSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcclxuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgYSBiYXNlIGVuY29kaW5nIHR5cGU/XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIoYmFzZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHBhcmVudHMuaGFzKGJhc2VUeXBlKSwgYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgbGlua2FnZVxyXG4gICAgICAgICAgICAgICAgcGFyZW50cy5nZXQoYmFzZVR5cGUpLnB1c2gobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBsaW5rcy5nZXQobmFtZSkuYWRkKGJhc2VUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEZWR1Y2UgdGhlIHByaW1hcnkgdHlwZVxyXG4gICAgICAgIGNvbnN0IHByaW1hcnlUeXBlcyA9IEFycmF5LmZyb20ocGFyZW50cy5rZXlzKCkpLmZpbHRlcigobikgPT4gKHBhcmVudHMuZ2V0KG4pLmxlbmd0aCA9PT0gMCkpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggIT09IDAsIFwibWlzc2luZyBwcmltYXJ5IHR5cGVcIiwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggPT09IDEsIGBhbWJpZ3VvdXMgcHJpbWFyeSB0eXBlcyBvciB1bnVzZWQgdHlwZXM6ICR7cHJpbWFyeVR5cGVzLm1hcCgodCkgPT4gKEpTT04uc3RyaW5naWZ5KHQpKSkuam9pbihcIiwgXCIpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJpbWFyeVR5cGU6IHByaW1hcnlUeXBlc1swXSB9KTtcclxuICAgICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2VzXHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLCBmb3VuZCkge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghZm91bmQuaGFzKHR5cGUpLCBgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XHJcbiAgICAgICAgICAgIGZvdW5kLmFkZCh0eXBlKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBsaW5rcy5nZXQodHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50cy5oYXMoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjaGVjayBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgY2hlY2tDaXJjdWxhcihjaGlsZCwgZm91bmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gTWFyayBhbGwgYW5jZXN0b3JzIGFzIGhhdmluZyB0aGlzIGRlY2VuZGFudFxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJ0eXBlIG9mIGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZXMuZ2V0KHN1YnR5cGUpLmFkZChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm91bmQuZGVsZXRlKHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVja0NpcmN1bGFyKHRoaXMucHJpbWFyeVR5cGUsIG5ldyBTZXQoKSk7XHJcbiAgICAgICAgLy8gQ29tcHV0ZSBlYWNoIGZ1bGx5IGRlc2NyaWJlIHR5cGVcclxuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBzZXRdIG9mIHN1YnR5cGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuZnJvbShzZXQpO1xyXG4gICAgICAgICAgICBzdC5zb3J0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuI2Z1bGxUeXBlcy5zZXQobmFtZSwgZW5jb2RlVHlwZShuYW1lLCB0eXBlc1tuYW1lXSkgKyBzdC5tYXAoKHQpID0+IGVuY29kZVR5cGUodCwgdHlwZXNbdF0pKS5qb2luKFwiXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm50aGUgZW5jb2RlciBmb3IgdGhlIHNwZWNpZmljICUldHlwZSUlLlxyXG4gICAgICovXHJcbiAgICBnZXRFbmNvZGVyKHR5cGUpIHtcclxuICAgICAgICBsZXQgZW5jb2RlciA9IHRoaXMuI2VuY29kZXJDYWNoZS5nZXQodHlwZSk7XHJcbiAgICAgICAgaWYgKCFlbmNvZGVyKSB7XHJcbiAgICAgICAgICAgIGVuY29kZXIgPSB0aGlzLiNnZXRFbmNvZGVyKHR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLiNlbmNvZGVyQ2FjaGUuc2V0KHR5cGUsIGVuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW5jb2RlcjtcclxuICAgIH1cclxuICAgICNnZXRFbmNvZGVyKHR5cGUpIHtcclxuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcclxuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFycmF5XHJcbiAgICAgICAgY29uc3QgYXJyYXkgPSBzcGxpdEFycmF5KHR5cGUpLmFycmF5O1xyXG4gICAgICAgIGlmIChhcnJheSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gYXJyYXkucHJlZml4O1xyXG4gICAgICAgICAgICBjb25zdCBzdWJFbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhcnJheS5jb3VudCA9PT0gLTEgfHwgYXJyYXkuY291bnQgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7YXJyYXkuY291bnR9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWUubWFwKHN1YkVuY29kZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXMoc3VidHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGtlY2NhazI1Nik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChyZXN1bHQpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3RydWN0XHJcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcclxuICAgICAgICBpZiAoZmllbGRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gaWQodGhpcy4jZnVsbFR5cGVzLmdldCh0eXBlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jZnVsbFR5cGVzLmhhcyh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhbHVlcy51bnNoaWZ0KGVuY29kZWRUeXBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXQodmFsdWVzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIGZ1bGwgdHlwZSBmb3IgJSVuYW1lJSUuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZVR5cGUobmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Z1bGxUeXBlcy5nZXQobmFtZSk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LCBgdW5rbm93biB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwibmFtZVwiLCBuYW1lKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlICUldHlwZSUlLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVEYXRhKHR5cGUsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBoYXNoIG9mICUldmFsdWUlJSBmb3IgdGhlIHR5cGUgb2YgJSVuYW1lJSUuXHJcbiAgICAgKi9cclxuICAgIGhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuZW5jb2RlRGF0YShuYW1lLCB2YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsZWQgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXHJcbiAgICAgKi9cclxuICAgIGVuY29kZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZURhdGEodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cclxuICAgICAqL1xyXG4gICAgaGFzaCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIF92aXNpdCh0eXBlLCB2YWx1ZSwgY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcclxuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0eXBlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXJyYXlcclxuICAgICAgICBjb25zdCBhcnJheSA9IHNwbGl0QXJyYXkodHlwZSkuYXJyYXk7XHJcbiAgICAgICAgaWYgKGFycmF5KSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFycmF5LmNvdW50ID09PSAtMSB8fCBhcnJheS5jb3VudCA9PT0gdmFsdWUubGVuZ3RoLCBgYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHthcnJheS5jb3VudH1gLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy5fdmlzaXQoYXJyYXkucHJlZml4LCB2LCBjYWxsYmFjaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdHJ1Y3RcclxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xyXG4gICAgICAgIGlmIChmaWVsZHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoKGFjY3VtLCB7IG5hbWUsIHR5cGUgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB0aGlzLl92aXNpdCh0eXBlLCB2YWx1ZVtuYW1lXSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xyXG4gICAgICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ2FsbCAlJWNhbGJhY2slJSBmb3IgZWFjaCB2YWx1ZSBpbiAlJXZhbHVlJSUsIHBhc3NpbmcgdGhlIHR5cGUgYW5kXHJcbiAgICAgKiAgY29tcG9uZW50IHdpdGhpbiAlJXZhbHVlJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciByZXBsYWNpbmcgYWRkcmVzc2VzIG9yIG90aGVyIHRyYW5zZm9ybWF0aW9uIHRoYXRcclxuICAgICAqICBtYXkgYmUgZGVzaXJlZCBvbiBlYWNoIGNvbXBvbmVudCwgYmFzZWQgb24gaXRzIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHZpc2l0KHZhbHVlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKHR5cGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZERhdGFFbmNvZGVyKHR5cGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgcHJpbWFyeSB0eXBlIGZvciAlJXR5cGVzJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcykge1xyXG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLnByaW1hcnlUeXBlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoZWQgc3RydWN0IGZvciAlJXZhbHVlJSUgdXNpbmcgJSV0eXBlcyUlIGFuZCAlJW5hbWUlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGhhc2hTdHJ1Y3QobmFtZSwgdHlwZXMsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIGRvbWFpbiBoYXNoIGZvciAlJWRvbWFpbiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaGFzaERvbWFpbihkb21haW4pIHtcclxuICAgICAgICBjb25zdCBkb21haW5GaWVsZHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZG9tYWluKSB7XHJcbiAgICAgICAgICAgIGlmIChkb21haW5bbmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV07XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGUsIGBpbnZhbGlkIHR5cGVkLWRhdGEgZG9tYWluIGtleTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcImRvbWFpblwiLCBkb21haW4pO1xyXG4gICAgICAgICAgICBkb21haW5GaWVsZHMucHVzaCh7IG5hbWUsIHR5cGUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvbWFpbkZpZWxkcy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYS5uYW1lKSAtIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihiLm5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmhhc2hTdHJ1Y3QoXCJFSVA3MTJEb21haW5cIiwgeyBFSVA3MTJEb21haW46IGRvbWFpbkZpZWxkcyB9LCBkb21haW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXHJcbiAgICAgICAgICAgIFwiMHgxOTAxXCIsXHJcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pLFxyXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2godmFsdWUpXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIGhhc2ggb2YgdGhlIGZ1bGx5IGVuY29kZWQgW1tsaW5rLWVpcC03MTJdXSAlJXZhbHVlJSUgZm9yICUldHlwZXMlJSB3aXRoICUlZG9tYWluJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBoYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1NihUeXBlZERhdGFFbmNvZGVyLmVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgLy8gUmVwbGFjZXMgYWxsIGFkZHJlc3MgdHlwZXMgd2l0aCBFTlMgbmFtZXMgd2l0aCB0aGVpciBsb29rZWQgdXAgYWRkcmVzc1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNvbHZlcyB0byB0aGUgdmFsdWUgZnJvbSByZXNvbHZpbmcgYWxsIGFkZHJlc3NlcyBpbiAlJXZhbHVlJSUgZm9yXHJcbiAgICAgKiAlJXR5cGVzJSUgYW5kIHRoZSAlJWRvbWFpbiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXN5bmMgcmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xyXG4gICAgICAgIC8vIE1ha2UgYSBjb3B5IHRvIGlzb2xhdGUgaXQgZnJvbSB0aGUgb2JqZWN0IHBhc3NlZCBpblxyXG4gICAgICAgIGRvbWFpbiA9IE9iamVjdC5hc3NpZ24oe30sIGRvbWFpbik7XHJcbiAgICAgICAgLy8gQWxsb3cgcGFzc2luZyBudWxsIHRvIGlnbm9yZSB2YWx1ZVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRvbWFpbikge1xyXG4gICAgICAgICAgICBpZiAoZG9tYWluW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbltrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIExvb2sgdXAgYWxsIEVOUyBuYW1lc1xyXG4gICAgICAgIGNvbnN0IGVuc0NhY2hlID0ge307XHJcbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBsb29rIHVwIHRoZSBkb21haW4ncyB2ZXJpZnlpbmdDb250cmFjdD9cclxuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICFpc0hleFN0cmluZyhkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsIDIwKSkge1xyXG4gICAgICAgICAgICBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdID0gXCIweFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBlbmNvZGVyIHRvIHZpc2l0IGFsbCB0aGUgYmFzZSB2YWx1ZXNcclxuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcclxuICAgICAgICAvLyBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgYWRkcmVzc2VzXHJcbiAgICAgICAgZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiAhaXNIZXhTdHJpbmcodmFsdWUsIDIwKSkge1xyXG4gICAgICAgICAgICAgICAgZW5zQ2FjaGVbdmFsdWVdID0gXCIweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBMb29rdXAgZWFjaCBuYW1lXHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGVuc0NhY2hlKSB7XHJcbiAgICAgICAgICAgIGVuc0NhY2hlW25hbWVdID0gYXdhaXQgcmVzb2x2ZU5hbWUobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBpZiBuZWVkZWRcclxuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0pIHtcclxuICAgICAgICAgICAgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ID0gZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgRU5TIG5hbWVzIHdpdGggdGhlaXIgYWRkcmVzc1xyXG4gICAgICAgIHZhbHVlID0gZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiBlbnNDYWNoZVt2YWx1ZV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnNDYWNoZVt2YWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7IGRvbWFpbiwgdmFsdWUgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIEpTT04tZW5jb2RlZCBwYXlsb2FkIGV4cGVjdGVkIGJ5IG5vZGVzIHdoaWNoIGltcGxlbWVudFxyXG4gICAgICogIHRoZSBKU09OLVJQQyBbW2xpbmstZWlwLTcxMl1dIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFBheWxvYWQoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcclxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZG9tYWluIGZpZWxkc1xyXG4gICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pO1xyXG4gICAgICAgIC8vIERlcml2ZSB0aGUgRUlQNzEyRG9tYWluIFN0cnVjdCByZWZlcmVuY2UgdHlwZVxyXG4gICAgICAgIGNvbnN0IGRvbWFpblZhbHVlcyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGRvbWFpblR5cGVzID0gW107XHJcbiAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tYWluW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRvbWFpblZhbHVlc1tuYW1lXSA9IGRvbWFpbkNoZWNrc1tuYW1lXSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGRvbWFpblR5cGVzLnB1c2goeyBuYW1lLCB0eXBlOiBkb21haW5GaWVsZFR5cGVzW25hbWVdIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xyXG4gICAgICAgIC8vIEdldCB0aGUgbm9ybWFsaXplZCB0eXBlc1xyXG4gICAgICAgIHR5cGVzID0gZW5jb2Rlci50eXBlcztcclxuICAgICAgICBjb25zdCB0eXBlc1dpdGhEb21haW4gPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlcyk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9PSBudWxsLCBcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIiwgXCJ0eXBlcy5FSVA3MTJEb21haW5cIiwgdHlwZXMpO1xyXG4gICAgICAgIHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPSBkb21haW5UeXBlcztcclxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCB0eXBlc1xyXG4gICAgICAgIGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlczogdHlwZXNXaXRoRG9tYWluLFxyXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblZhbHVlcyxcclxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IGVuY29kZXIucHJpbWFyeVR5cGUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gYnl0ZXNcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKikvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGdldEJ5dGVzKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB1aW50IG9yIGludFxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL151P2ludC8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBDb21wdXRlIHRoZSBhZGRyZXNzIHVzZWQgdG8gc2lnbiB0aGUgdHlwZWQgZGF0YSBmb3IgdGhlICUlc2lnbmF0dXJlJSUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5VHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBzaWduYXR1cmUpIHtcclxuICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyhUeXBlZERhdGFFbmNvZGVyLmhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpLCBzaWduYXR1cmUpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLWRhdGEuanMubWFwIiwiLyoqXHJcbiAqICBBIGZyYWdtZW50IGlzIGEgc2luZ2xlIGl0ZW0gZnJvbSBhbiBBQkksIHdoaWNoIG1heSByZXByZXNlbnQgYW55IG9mOlxyXG4gKlxyXG4gKiAgLSBbRnVuY3Rpb25zXShGdW5jdGlvbkZyYWdtZW50KVxyXG4gKiAgLSBbRXZlbnRzXShFdmVudEZyYWdtZW50KVxyXG4gKiAgLSBbQ29uc3RydWN0b3JzXShDb25zdHJ1Y3RvckZyYWdtZW50KVxyXG4gKiAgLSBDdXN0b20gW0Vycm9yc10oRXJyb3JGcmFnbWVudClcclxuICogIC0gW0ZhbGxiYWNrIG9yIFJlY2VpdmVdKEZhbGxiYWNrRnJhZ21lbnQpIGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmkvYWJpLWNvZGVyOkZyYWdtZW50cyAgW2Fib3V0LWZyYWdtZW50c11cclxuICovXHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBhc3NlcnQsIGFzc2VydFByaXZhdGUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcclxuO1xyXG4vLyBbIFwiYVwiLCBcImJcIiBdID0+IHsgXCJhXCI6IDEsIFwiYlwiOiAxIH1cclxuZnVuY3Rpb24gc2V0aWZ5KGl0ZW1zKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XHJcbiAgICBpdGVtcy5mb3JFYWNoKChrKSA9PiByZXN1bHQuYWRkKGspKTtcclxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XHJcbn1cclxuY29uc3QgX2t3VmlzaWJEZXBsb3kgPSBcImV4dGVybmFsIHB1YmxpYyBwYXlhYmxlIG92ZXJyaWRlXCI7XHJcbmNvbnN0IEt3VmlzaWJEZXBsb3kgPSBzZXRpZnkoX2t3VmlzaWJEZXBsb3kuc3BsaXQoXCIgXCIpKTtcclxuLy8gVmlzaWJpbGl0eSBLZXl3b3Jkc1xyXG5jb25zdCBfa3dWaXNpYiA9IFwiY29uc3RhbnQgZXh0ZXJuYWwgaW50ZXJuYWwgcGF5YWJsZSBwcml2YXRlIHB1YmxpYyBwdXJlIHZpZXcgb3ZlcnJpZGVcIjtcclxuY29uc3QgS3dWaXNpYiA9IHNldGlmeShfa3dWaXNpYi5zcGxpdChcIiBcIikpO1xyXG5jb25zdCBfa3dUeXBlcyA9IFwiY29uc3RydWN0b3IgZXJyb3IgZXZlbnQgZmFsbGJhY2sgZnVuY3Rpb24gcmVjZWl2ZSBzdHJ1Y3RcIjtcclxuY29uc3QgS3dUeXBlcyA9IHNldGlmeShfa3dUeXBlcy5zcGxpdChcIiBcIikpO1xyXG5jb25zdCBfa3dNb2RpZmllcnMgPSBcImNhbGxkYXRhIG1lbW9yeSBzdG9yYWdlIHBheWFibGUgaW5kZXhlZFwiO1xyXG5jb25zdCBLd01vZGlmaWVycyA9IHNldGlmeShfa3dNb2RpZmllcnMuc3BsaXQoXCIgXCIpKTtcclxuY29uc3QgX2t3T3RoZXIgPSBcInR1cGxlIHJldHVybnNcIjtcclxuLy8gQWxsIEtleXdvcmRzXHJcbmNvbnN0IF9rZXl3b3JkcyA9IFtfa3dUeXBlcywgX2t3TW9kaWZpZXJzLCBfa3dPdGhlciwgX2t3VmlzaWJdLmpvaW4oXCIgXCIpO1xyXG5jb25zdCBLZXl3b3JkcyA9IHNldGlmeShfa2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcclxuLy8gU2luZ2xlIGNoYXJhY3RlciB0b2tlbnNcclxuY29uc3QgU2ltcGxlVG9rZW5zID0ge1xyXG4gICAgXCIoXCI6IFwiT1BFTl9QQVJFTlwiLCBcIilcIjogXCJDTE9TRV9QQVJFTlwiLFxyXG4gICAgXCJbXCI6IFwiT1BFTl9CUkFDS0VUXCIsIFwiXVwiOiBcIkNMT1NFX0JSQUNLRVRcIixcclxuICAgIFwiLFwiOiBcIkNPTU1BXCIsIFwiQFwiOiBcIkFUXCJcclxufTtcclxuLy8gUGFyc2VyIHJlZ2V4ZXMgdG8gY29uc3VtZSB0aGUgbmV4dCB0b2tlblxyXG5jb25zdCByZWdleFdoaXRlc3BhY2VQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihcXFxccyopXCIpO1xyXG5jb25zdCByZWdleE51bWJlclByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFswLTldKylcIik7XHJcbmNvbnN0IHJlZ2V4SWRQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopXCIpO1xyXG4vLyBQYXJzZXIgcmVnZXhzIHRvIGNoZWNrIHZhbGlkaXR5XHJcbmNvbnN0IHJlZ2V4SWQgPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopJFwiKTtcclxuY29uc3QgcmVnZXhUeXBlID0gbmV3IFJlZ0V4cChcIl4oYWRkcmVzc3xib29sfGJ5dGVzKFswLTldKil8c3RyaW5nfHU/aW50KFswLTldKikpJFwiKTtcclxuY2xhc3MgVG9rZW5TdHJpbmcge1xyXG4gICAgI29mZnNldDtcclxuICAgICN0b2tlbnM7XHJcbiAgICBnZXQgb2Zmc2V0KCkgeyByZXR1cm4gdGhpcy4jb2Zmc2V0OyB9XHJcbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdG9rZW5zLmxlbmd0aCAtIHRoaXMuI29mZnNldDsgfVxyXG4gICAgY29uc3RydWN0b3IodG9rZW5zKSB7XHJcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLiN0b2tlbnMgPSB0b2tlbnMuc2xpY2UoKTtcclxuICAgIH1cclxuICAgIGNsb25lKCkgeyByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRoaXMuI3Rva2Vucyk7IH1cclxuICAgIHJlc2V0KCkgeyB0aGlzLiNvZmZzZXQgPSAwOyB9XHJcbiAgICAjc3ViVG9rZW5TdHJpbmcoZnJvbSA9IDAsIHRvID0gMCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zLnNsaWNlKGZyb20sIHRvKS5tYXAoKHQpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdCwge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2g6ICh0Lm1hdGNoIC0gZnJvbSksXHJcbiAgICAgICAgICAgICAgICBsaW5rQmFjazogKHQubGlua0JhY2sgLSBmcm9tKSxcclxuICAgICAgICAgICAgICAgIGxpbmtOZXh0OiAodC5saW5rTmV4dCAtIGZyb20pLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4sIGlmIGl0IGlzIGEga2V5d29yZCBpbiBhbGxvd2VkOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xyXG4gICAgcG9wS2V5d29yZChhbGxvd2VkKSB7XHJcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XHJcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIktFWVdPUkRcIiB8fCAhYWxsb3dlZC5oYXModG9wLnRleHQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQga2V5d29yZCAke3RvcC50ZXh0fWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xyXG4gICAgfVxyXG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xyXG4gICAgcG9wVHlwZSh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGVlaygpLnR5cGUgIT09IHR5cGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfTsgZ290ICR7dG9wLnR5cGV9ICR7SlNPTi5zdHJpbmdpZnkodG9wLnRleHQpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xyXG4gICAgfVxyXG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyBhIFwiKFwiIFRPS0VOUyBcIilcIlxyXG4gICAgcG9wUGFyZW4oKSB7XHJcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XHJcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIk9QRU5fUEFSRU5cIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI3N1YlRva2VuU3RyaW5nKHRoaXMuI29mZnNldCArIDEsIHRvcC5tYXRjaCArIDEpO1xyXG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIGl0ZW1zIHdpdGhpbiBcIihcIiBJVEVNMSBcIixcIiBJVEVNMiBcIixcIiAuLi4gXCIpXCJcclxuICAgIHBvcFBhcmFtcygpIHtcclxuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcclxuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBzdGFydFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuI29mZnNldCA8IHRvcC5tYXRjaCAtIDEpIHtcclxuICAgICAgICAgICAgY29uc3QgbGluayA9IHRoaXMucGVlaygpLmxpbmtOZXh0O1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCBsaW5rKSk7XHJcbiAgICAgICAgICAgIHRoaXMuI29mZnNldCA9IGxpbms7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIHRvcCBUb2tlbiwgdGhyb3dpbmcgaWYgb3V0IG9mIHRva2Vuc1xyXG4gICAgcGVlaygpIHtcclxuICAgICAgICBpZiAodGhpcy4jb2Zmc2V0ID49IHRoaXMuI3Rva2Vucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0LW9mLWJvdW5kc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Rva2Vuc1t0aGlzLiNvZmZzZXRdO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB2YWx1ZSwgaWYgaXQgaXMgYSBrZXl3b3JkIGluIGBhbGxvd2VkYFxyXG4gICAgcGVla0tleXdvcmQoYWxsb3dlZCkge1xyXG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xyXG4gICAgICAgIHJldHVybiAodG9wICE9IG51bGwgJiYgYWxsb3dlZC5oYXModG9wKSkgPyB0b3AgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgXHJcbiAgICBwZWVrVHlwZSh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcclxuICAgICAgICByZXR1cm4gKHRvcC50eXBlID09PSB0eXBlKSA/IHRvcC50ZXh0IDogbnVsbDtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdG9rZW47IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXHJcbiAgICBwb3AoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wZWVrKCk7XHJcbiAgICAgICAgdGhpcy4jb2Zmc2V0Kys7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLiNvZmZzZXQ7IGkgPCB0aGlzLiN0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLiN0b2tlbnNbaV07XHJcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKGAke3Rva2VuLnR5cGV9OiR7dG9rZW4udGV4dH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGA8VG9rZW5TdHJpbmcgJHt0b2tlbnMuam9pbihcIiBcIil9PmA7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbGV4KHRleHQpIHtcclxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xyXG4gICAgY29uc3QgdGhyb3dFcnJvciA9IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdG9rZW4gPSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpID8gSlNPTi5zdHJpbmdpZnkodGV4dFtvZmZzZXRdKSA6IFwiJEVPSVwiO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0b2tlbiAke3Rva2VufSBhdCAke29mZnNldH06ICR7bWVzc2FnZX1gKTtcclxuICAgIH07XHJcbiAgICBsZXQgYnJhY2tldHMgPSBbXTtcclxuICAgIGxldCBjb21tYXMgPSBbXTtcclxuICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgd2hpbGUgKG9mZnNldCA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gU3RyaXAgb2ZmIGFueSBsZWFkaW5nIHdoaXRlc3BhY2VcclxuICAgICAgICBsZXQgY3VyID0gdGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcclxuICAgICAgICBsZXQgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhXaGl0ZXNwYWNlUHJlZml4KTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IG1hdGNoWzFdLmxlbmd0aDtcclxuICAgICAgICAgICAgY3VyID0gdGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdG9rZW4gPSB7IGRlcHRoOiBicmFja2V0cy5sZW5ndGgsIGxpbmtCYWNrOiAtMSwgbGlua05leHQ6IC0xLCBtYXRjaDogLTEsIHR5cGU6IFwiXCIsIHRleHQ6IFwiXCIsIG9mZnNldCwgdmFsdWU6IC0xIH07XHJcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgICAgIGxldCB0eXBlID0gKFNpbXBsZVRva2Vuc1tjdXJbMF1dIHx8IFwiXCIpO1xyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gY3VyWzBdO1xyXG4gICAgICAgICAgICBvZmZzZXQrKztcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiT1BFTl9QQVJFTlwiKSB7XHJcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIGNvbW1hcy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiQ0xPU0VfUEFSRU5cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJubyBtYXRjaGluZyBvcGVuIGJyYWNrZXRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXRjaCA9IGJyYWNrZXRzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5tYXRjaF0pLm1hdGNoID0gdG9rZW5zLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICB0b2tlbi5kZXB0aC0tO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLmxpbmtCYWNrXSkubGlua05leHQgPSB0b2tlbnMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIkNPTU1BXCIpIHtcclxuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPUEVOX0JSQUNLRVRcIikge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiQlJBQ0tFVFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ0xPU0VfQlJBQ0tFVFwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIENMT1NFX0JSQUNLRVRcclxuICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSB0b2tlbnMucG9wKCkudGV4dDtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwiTlVNQkVSXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRva2Vucy5wb3AoKS50ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHZhbHVlICsgc3VmZml4O1xyXG4gICAgICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS52YWx1ZSA9IGdldE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgIT09IFwiQlJBQ0tFVFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBvcGVuaW5nIGJyYWNrZXRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkudGV4dCArPSBzdWZmaXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4SWRQcmVmaXgpO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XHJcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKEtleXdvcmRzLmhhcyh0b2tlbi50ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiS0VZV09SRFwiO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRva2VuLnRleHQubWF0Y2gocmVnZXhUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiVFlQRVwiO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiSURcIjtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4TnVtYmVyUHJlZml4KTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgdG9rZW4udGV4dCA9IG1hdGNoWzFdO1xyXG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJOVU1CRVJcIjtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHRva2VuLnRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHRva2VuICR7SlNPTi5zdHJpbmdpZnkoY3VyWzBdKX0gYXQgcG9zaXRpb24gJHtvZmZzZXR9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRva2Vucy5tYXAoKHQpID0+IE9iamVjdC5mcmVlemUodCkpKTtcclxufVxyXG4vLyBDaGVjayBvbmx5IG9uZSBvZiBgYWxsb3dlZGAgaXMgaW4gYHNldGBcclxuZnVuY3Rpb24gYWxsb3dTaW5nbGUoc2V0LCBhbGxvd2VkKSB7XHJcbiAgICBsZXQgaW5jbHVkZWQgPSBbXTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGFsbG93ZWQua2V5cygpKSB7XHJcbiAgICAgICAgaWYgKHNldC5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICBpbmNsdWRlZC5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGluY2x1ZGVkLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbmZsaWN0aW5nIHR5cGVzOiAke2luY2x1ZGVkLmpvaW4oXCIsIFwiKX1gKTtcclxuICAgIH1cclxufVxyXG4vLyBGdW5jdGlvbnMgdG8gcHJvY2VzcyBhIFNvbGlkaXR5IFNpZ25hdHVyZSBUb2tlblN0cmluZyBmcm9tIGxlZnQtdG8tcmlnaHQgZm9yLi4uXHJcbi8vIC4uLnRoZSBuYW1lIHdpdGggYW4gb3B0aW9uYWwgdHlwZSwgcmV0dXJuaW5nIHRoZSBuYW1lXHJcbmZ1bmN0aW9uIGNvbnN1bWVOYW1lKHR5cGUsIHRva2Vucykge1xyXG4gICAgaWYgKHRva2Vucy5wZWVrS2V5d29yZChLd1R5cGVzKSkge1xyXG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucG9wKCkudGV4dDtcclxuICAgICAgICBpZiAoa2V5d29yZCAhPT0gdHlwZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX0sIGdvdCAke2tleXdvcmR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRva2Vucy5wb3BUeXBlKFwiSURcIik7XHJcbn1cclxuLy8gLi4uYWxsIGtleXdvcmRzIG1hdGNoaW5nIGFsbG93ZWQsIHJldHVybmluZyB0aGUga2V5d29yZHNcclxuZnVuY3Rpb24gY29uc3VtZUtleXdvcmRzKHRva2VucywgYWxsb3dlZCkge1xyXG4gICAgY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KCk7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xyXG4gICAgICAgIGlmIChrZXl3b3JkID09IG51bGwgfHwgKGFsbG93ZWQgJiYgIWFsbG93ZWQuaGFzKGtleXdvcmQpKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xyXG4gICAgICAgIGlmIChrZXl3b3Jkcy5oYXMoa2V5d29yZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGUga2V5d29yZHM6ICR7SlNPTi5zdHJpbmdpZnkoa2V5d29yZCl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleXdvcmRzLmFkZChrZXl3b3JkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGtleXdvcmRzKTtcclxufVxyXG4vLyAuLi5hbGwgdmlzaWJpbGl0eSBrZXl3b3JkcywgcmV0dXJuaW5nIHRoZSBjb2FsZXNjZWQgbXV0YWJpbGl0eVxyXG5mdW5jdGlvbiBjb25zdW1lTXV0YWJpbGl0eSh0b2tlbnMpIHtcclxuICAgIGxldCBtb2RpZmllcnMgPSBjb25zdW1lS2V5d29yZHModG9rZW5zLCBLd1Zpc2liKTtcclxuICAgIC8vIERldGVjdCBjb25mbGljdGluZyBtb2RpZmllcnNcclxuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwiY29uc3RhbnQgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XHJcbiAgICBhbGxvd1NpbmdsZShtb2RpZmllcnMsIHNldGlmeShcInB1cmUgdmlldyBwYXlhYmxlIG5vbnBheWFibGVcIi5zcGxpdChcIiBcIikpKTtcclxuICAgIC8vIFByb2Nlc3MgbXV0YWJpbGl0eSBzdGF0ZXNcclxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwidmlld1wiKSkge1xyXG4gICAgICAgIHJldHVybiBcInZpZXdcIjtcclxuICAgIH1cclxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicHVyZVwiKSkge1xyXG4gICAgICAgIHJldHVybiBcInB1cmVcIjtcclxuICAgIH1cclxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicGF5YWJsZVwiKSkge1xyXG4gICAgICAgIHJldHVybiBcInBheWFibGVcIjtcclxuICAgIH1cclxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwibm9ucGF5YWJsZVwiKSkge1xyXG4gICAgICAgIHJldHVybiBcIm5vbnBheWFibGVcIjtcclxuICAgIH1cclxuICAgIC8vIFByb2Nlc3MgbGVnYWN5IGBjb25zdGFudGAgbGFzdFxyXG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJjb25zdGFudFwiKSkge1xyXG4gICAgICAgIHJldHVybiBcInZpZXdcIjtcclxuICAgIH1cclxuICAgIHJldHVybiBcIm5vbnBheWFibGVcIjtcclxufVxyXG4vLyAuLi5hIHBhcmFtZXRlciBsaXN0LCByZXR1cm5pbmcgdGhlIFBhcmFtVHlwZSBsaXN0XHJcbmZ1bmN0aW9uIGNvbnN1bWVQYXJhbXModG9rZW5zLCBhbGxvd0luZGV4ZWQpIHtcclxuICAgIHJldHVybiB0b2tlbnMucG9wUGFyYW1zKCkubWFwKCh0KSA9PiBQYXJhbVR5cGUuZnJvbSh0LCBhbGxvd0luZGV4ZWQpKTtcclxufVxyXG4vLyAuLi5hIGdhcyBsaW1pdCwgcmV0dXJuaW5nIGEgQmlnTnVtYmVyIG9yIG51bGwgaWYgbm9uZVxyXG5mdW5jdGlvbiBjb25zdW1lR2FzKHRva2Vucykge1xyXG4gICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIkFUXCIpKSB7XHJcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xyXG4gICAgICAgIGlmICh0b2tlbnMucGVla1R5cGUoXCJOVU1CRVJcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh0b2tlbnMucG9wKCkudGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZ2FzXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gY29uc3VtZUVvaSh0b2tlbnMpIHtcclxuICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHRva2VucyBhdCBvZmZzZXQgJHt0b2tlbnMub2Zmc2V0fTogJHt0b2tlbnMudG9TdHJpbmcoKX1gKTtcclxuICAgIH1cclxufVxyXG5jb25zdCByZWdleEFycmF5VHlwZSA9IG5ldyBSZWdFeHAoL14oLiopXFxbKFswLTldKilcXF0kLyk7XHJcbmZ1bmN0aW9uIHZlcmlmeUJhc2ljVHlwZSh0eXBlKSB7XHJcbiAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhUeXBlKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoLCBcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XHJcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50XCIpIHtcclxuICAgICAgICByZXR1cm4gXCJ1aW50MjU2XCI7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZSA9PT0gXCJpbnRcIikge1xyXG4gICAgICAgIHJldHVybiBcImludDI1NlwiO1xyXG4gICAgfVxyXG4gICAgaWYgKG1hdGNoWzJdKSB7XHJcbiAgICAgICAgLy8gYnl0ZXNYWFxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwidHlwZVwiLCB0eXBlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1hdGNoWzNdKSB7XHJcbiAgICAgICAgLy8gaW50WFggb3IgdWludFhYXHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzNdKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0eXBlO1xyXG59XHJcbi8vIE1ha2UgdGhlIEZyYWdtZW50IGNvbnN0cnVjdG9ycyBlZmZlY3RpdmVseSBwcml2YXRlXHJcbmNvbnN0IF9ndWFyZCA9IHt9O1xyXG5jb25zdCBpbnRlcm5hbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX2ludGVybmFsXCIpO1xyXG5jb25zdCBQYXJhbVR5cGVJbnRlcm5hbCA9IFwiX1BhcmFtVHlwZUludGVybmFsXCI7XHJcbmNvbnN0IEVycm9yRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0Vycm9ySW50ZXJuYWxcIjtcclxuY29uc3QgRXZlbnRGcmFnbWVudEludGVybmFsID0gXCJfRXZlbnRJbnRlcm5hbFwiO1xyXG5jb25zdCBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9Db25zdHJ1Y3RvckludGVybmFsXCI7XHJcbmNvbnN0IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0ZhbGxiYWNrSW50ZXJuYWxcIjtcclxuY29uc3QgRnVuY3Rpb25GcmFnbWVudEludGVybmFsID0gXCJfRnVuY3Rpb25JbnRlcm5hbFwiO1xyXG5jb25zdCBTdHJ1Y3RGcmFnbWVudEludGVybmFsID0gXCJfU3RydWN0SW50ZXJuYWxcIjtcclxuLyoqXHJcbiAqICBFYWNoIGlucHV0IGFuZCBvdXRwdXQgb2YgYSBbW0ZyYWdtZW50XV0gaXMgYW4gQXJyYXkgb2YgKipQYXJhbVR5cGUqKi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQYXJhbVR5cGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGxvY2FsIG5hbWUgb2YgdGhlIHBhcmFtZXRlciAob3IgYGBcIlwiYGAgaWYgdW5ib3VuZClcclxuICAgICAqL1xyXG4gICAgbmFtZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBmdWxseSBxdWFsaWZpZWQgdHlwZSAoZS5nLiBgYFwiYWRkcmVzc1wiYGAsIGBgXCJ0dXBsZShhZGRyZXNzKVwiYGAsXHJcbiAgICAgKiAgYGBcInVpbnQyNTZbM11bXVwiYGApXHJcbiAgICAgKi9cclxuICAgIHR5cGU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYmFzZSB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlXCJgYCwgYGBcImFycmF5XCJgYClcclxuICAgICAqL1xyXG4gICAgYmFzZVR5cGU7XHJcbiAgICAvKipcclxuICAgICAqICBUcnVlIGlmIHRoZSBwYXJhbWV0ZXJzIGlzIGluZGV4ZWQuXHJcbiAgICAgKlxyXG4gICAgICogIEZvciBub24taW5kZXhhYmxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXHJcbiAgICAgKi9cclxuICAgIGluZGV4ZWQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY29tcG9uZW50cyBmb3IgdGhlIHR1cGxlLlxyXG4gICAgICpcclxuICAgICAqICBGb3Igbm9uLXR1cGxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXHJcbiAgICAgKi9cclxuICAgIGNvbXBvbmVudHM7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYXJyYXkgbGVuZ3RoLCBvciBgYC0xYGAgZm9yIGR5bmFtaWMtbGVuZ3RoZWQgYXJyYXlzLlxyXG4gICAgICpcclxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXHJcbiAgICAgKi9cclxuICAgIGFycmF5TGVuZ3RoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHR5cGUgb2YgZWFjaCBjaGlsZCBpbiB0aGUgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgYXJyYXlDaGlsZHJlbjtcclxuICAgIC8qKlxyXG4gICAgICogIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pIHtcclxuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiUGFyYW1UeXBlXCIpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogUGFyYW1UeXBlSW50ZXJuYWwgfSk7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50cyA9IE9iamVjdC5mcmVlemUoY29tcG9uZW50cy5zbGljZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5TGVuZ3RoID09IG51bGwgfHwgYXJyYXlDaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJyYXlMZW5ndGggIT0gbnVsbCB8fCBhcnJheUNoaWxkcmVuICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XHJcbiAgICAgICAgICAgIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wb25lbnRzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiAgRm9yIGV4YW1wbGUsXHJcbiAgICAgKlxyXG4gICAgICogIGBgc2lnaGFzaFwiID0+IFwiKHVpbnQyNTYsYWRkcmVzcylcImBgXHJcbiAgICAgKlxyXG4gICAgICogIGBgXCJtaW5pbWFsXCIgPT4gXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcImBgXHJcbiAgICAgKlxyXG4gICAgICogIGBgXCJmdWxsXCIgPT4gXCJ0dXBsZSh1aW50MjU2IGZvbywgYWRkcmVzcyBiYXIpIGluZGV4ZWQgYmF6XCJgYFxyXG4gICAgICovXHJcbiAgICBmb3JtYXQoZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lIHx8IFwiXCI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSh0aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KFwianNvblwiKSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQudHlwZSArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAoKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpLFxyXG4gICAgICAgICAgICAgICAgbmFtZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLmluZGV4ZWQpID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGMpID0+IEpTT04ucGFyc2UoYy5mb3JtYXQoZm9ybWF0KSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICAvLyBBcnJheVxyXG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChmb3JtYXQpO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBjb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleGVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgaW5kZXhlZFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiZnVsbFwiICYmIHRoaXMubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgdGhpcy5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYW4gQXJyYXkgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2FycmF5Q2hpbGRyZW5dXVxyXG4gICAgICogIGFuZCBbW2FycmF5TGVuZ3RoXV0gYXJlIG5vbi1udWxsLlxyXG4gICAgICovXHJcbiAgICBpc0FycmF5KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhIFR1cGxlIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1tjb21wb25lbnRzXV1cclxuICAgICAqICBpcyBub24tbnVsbC5cclxuICAgICAqL1xyXG4gICAgaXNUdXBsZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYW4gSW5kZXhhYmxlIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1tpbmRleGVkXV1cclxuICAgICAqICBpcyBub24tbnVsbC5cclxuICAgICAqL1xyXG4gICAgaXNJbmRleGFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4ZWQgIT0gbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBXYWxrcyB0aGUgKipQYXJhbVR5cGUqKiB3aXRoICUldmFsdWUlJSwgY2FsbGluZyAlJXByb2Nlc3MlJVxyXG4gICAgICogIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cclxuICAgICAqL1xyXG4gICAgd2Fsayh2YWx1ZSwgcHJvY2Vzcykge1xyXG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFycmF5IHZhbHVlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IChfdGhpcy5hcnJheUNoaWxkcmVuLndhbGsodiwgcHJvY2VzcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gKF90aGlzLmNvbXBvbmVudHNbaV0ud2Fsayh2LCBwcm9jZXNzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvY2Vzcyh0aGlzLnR5cGUsIHZhbHVlKTtcclxuICAgIH1cclxuICAgICN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCBzZXRWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFycmF5IHZhbHVlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSB0aGlzLmFycmF5Q2hpbGRyZW47XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoaWxkVHlwZS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzO1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBvYmplY3QgaW50byBhbiBhcnJheVxyXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wb25lbnRzLm1hcCgocGFyYW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBvYmplY3QgdmFsdWUgd2l0aCB1bm5hbWVkIGNvbXBvbmVudHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtLm5hbWUgaW4gdmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgY29tcG9uZW50ICR7cGFyYW0ubmFtZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW3BhcmFtLm5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IHRoaXMuY29tcG9uZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2luZGV4XS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC50aGVuKSB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgc2V0VmFsdWUoYXdhaXQgcmVzdWx0KTsgfSkoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBhc3luY2hyb25vdXNseSBjYWxsaW5nXHJcbiAgICAgKiAgJSVwcm9jZXNzJSUgb24gZWFjaCB0eXBlLCBkZXN0cnVjdGluZyB0aGUgJSV2YWx1ZSUlIHJlY3Vyc2l2ZWx5LlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgRU5TIG5hbWVzIGJ5IHdhbGtpbmcgYW5kIHJlc29sdmluZyBlYWNoXHJcbiAgICAgKiAgYGBcImFkZHJlc3NcImBgIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHdhbGtBc3luYyh2YWx1ZSwgcHJvY2Vzcykge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW3ZhbHVlXTtcclxuICAgICAgICB0aGlzLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0WzBdID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqUGFyYW1UeXBlKiogZm9yICUlb2JqJSUuXHJcbiAgICAgKlxyXG4gICAgICogIElmICUlYWxsb3dJbmRleGVkJSUgdGhlbiB0aGUgYGBpbmRleGVkYGAga2V5d29yZCBpcyBwZXJtaXR0ZWQsXHJcbiAgICAgKiAgb3RoZXJ3aXNlIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIHdpbGwgdGhyb3cgYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKG9iaiwgYWxsb3dJbmRleGVkKSB7XHJcbiAgICAgICAgaWYgKFBhcmFtVHlwZS5pc1BhcmFtVHlwZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbShsZXgob2JqKSwgYWxsb3dJbmRleGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgcGFyYW0gdHlwZVwiLCBcIm9ialwiLCBvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGxldCB0eXBlID0gXCJcIiwgYmFzZVR5cGUgPSBcIlwiO1xyXG4gICAgICAgICAgICBsZXQgY29tcHMgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInR1cGxlXCJdKSkuaGFzKFwidHVwbGVcIikgfHwgb2JqLnBlZWtUeXBlKFwiT1BFTl9QQVJFTlwiKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHVwbGVcclxuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gXCJ0dXBsZVwiO1xyXG4gICAgICAgICAgICAgICAgY29tcHMgPSBvYmoucG9wUGFyYW1zKCkubWFwKCh0KSA9PiBQYXJhbVR5cGUuZnJvbSh0KSk7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gYHR1cGxlKCR7Y29tcHMubWFwKChjKSA9PiBjLmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbFxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHZlcmlmeUJhc2ljVHlwZShvYmoucG9wVHlwZShcIlRZUEVcIikpO1xyXG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBBcnJheVxyXG4gICAgICAgICAgICBsZXQgYXJyYXlDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBhcnJheUxlbmd0aCA9IG51bGw7XHJcbiAgICAgICAgICAgIHdoaWxlIChvYmoubGVuZ3RoICYmIG9iai5wZWVrVHlwZShcIkJSQUNLRVRcIikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJyYWNrZXQgPSBvYmoucG9wKCk7IC8vYXJyYXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbiA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBcIlwiLCB0eXBlLCBiYXNlVHlwZSwgbnVsbCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoID0gYnJhY2tldC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHR5cGUgKz0gYnJhY2tldC50ZXh0O1xyXG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcImFycmF5XCI7XHJcbiAgICAgICAgICAgICAgICBjb21wcyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGluZGV4ZWQgPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkcyA9IGNvbnN1bWVLZXl3b3JkcyhvYmosIEt3TW9kaWZpZXJzKTtcclxuICAgICAgICAgICAgaWYgKGtleXdvcmRzLmhhcyhcImluZGV4ZWRcIikpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IChvYmoucGVla1R5cGUoXCJJRFwiKSA/IG9iai5wb3AoKS50ZXh0IDogXCJcIik7XHJcbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZWZ0b3ZlciB0b2tlbnNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IG9iai5uYW1lO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFuYW1lIHx8ICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCkpLCBcImludmFsaWQgbmFtZVwiLCBcIm9iai5uYW1lXCIsIG5hbWUpO1xyXG4gICAgICAgIGxldCBpbmRleGVkID0gb2JqLmluZGV4ZWQ7XHJcbiAgICAgICAgaWYgKGluZGV4ZWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhbGxvd0luZGV4ZWQsIFwicGFyYW1ldGVyIGNhbm5vdCBiZSBpbmRleGVkXCIsIFwib2JqLmluZGV4ZWRcIiwgb2JqLmluZGV4ZWQpO1xyXG4gICAgICAgICAgICBpbmRleGVkID0gISFpbmRleGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdHlwZSA9IG9iai50eXBlO1xyXG4gICAgICAgIGxldCBhcnJheU1hdGNoID0gdHlwZS5tYXRjaChyZWdleEFycmF5VHlwZSk7XHJcbiAgICAgICAgaWYgKGFycmF5TWF0Y2gpIHtcclxuICAgICAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSBwYXJzZUludChhcnJheU1hdGNoWzJdIHx8IFwiLTFcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGFycmF5Q2hpbGRyZW4gPSBQYXJhbVR5cGUuZnJvbSh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBhcnJheU1hdGNoWzFdLFxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogb2JqLmNvbXBvbmVudHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCBcImFycmF5XCIsIGluZGV4ZWQsIG51bGwsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFwidHVwbGVcIiB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJ0dXBsZShcIiAvKiBmaXg6ICkgKi8pIHx8IHR5cGUuc3RhcnRzV2l0aChcIihcIiAvKiBmaXg6ICkgKi8pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG9iai5jb21wb25lbnRzICE9IG51bGwpID8gb2JqLmNvbXBvbmVudHMubWFwKChjKSA9PiBQYXJhbVR5cGUuZnJvbShjKSkgOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCB0dXBsZSA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwidHVwbGVcIiwgaW5kZXhlZCwgY29tcHMsIG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICAvLyBAVE9ETzogdXNlIGxleGVyIHRvIHZhbGlkYXRlIGFuZCBub3JtYWxpemUgdHlwZVxyXG4gICAgICAgICAgICByZXR1cm4gdHVwbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnR5cGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCB0eXBlLCBpbmRleGVkLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSAqKlBhcmFtVHlwZSoqLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNQYXJhbVR5cGUodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gUGFyYW1UeXBlSW50ZXJuYWwpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnQgZnJvbSBhIHBhcnNlIEFCSS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBGcmFnbWVudCB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdHlwZSBvZiB0aGUgZnJhZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIHR5cGU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgaW5wdXRzIGZvciB0aGUgZnJhZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIGlucHV0cztcclxuICAgIC8qKlxyXG4gICAgICogIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBpbnB1dHMpIHtcclxuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRnJhZ21lbnRcIik7XHJcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHR5cGUsIGlucHV0cyB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGcmFnbWVudCoqIGZvciAlJW9iaiUlLCB3aWNoIGNhbiBiZSBhbnkgc3VwcG9ydGVkXHJcbiAgICAgKiAgQUJJIGZyZ2FtZW50IHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKG9iaikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgLy8gVHJ5IHBhcnNpbmcgSlNPTi4uLlxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgRnJhZ21lbnQuZnJvbShKU09OLnBhcnNlKG9iaikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlLCB1c2UgdGhlIGh1bWFuLXJlYWRhYmxlIGxleGVyXHJcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKGxleChvYmopKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIC8vIEh1bWFuLXJlYWRhYmxlIEFCSSAoYWxyZWFkeSBsZXhlZClcclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9iai5wZWVrS2V5d29yZChLd1R5cGVzKTtcclxuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHJldHVybiBFcnJvckZyYWdtZW50LmZyb20ob2JqKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjogcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20ob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9iaikgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgLy8gSlNPTiBBQklcclxuICAgICAgICAgICAgc3dpdGNoIChvYmoudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6IHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20ob2JqKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjogcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShvYmopO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20ob2JqKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKG9iaik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5zdXBwb3J0ZWQgdHlwZTogJHtvYmoudHlwZX1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiRnJhZ21lbnQuZnJvbVwiXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBmcmdhbWVudCBvYmplY3RcIiwgXCJvYmpcIiwgb2JqKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW0NvbnN0cnVjdG9yRnJhZ21lbnRdXS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzQ29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFcnJvckZyYWdtZW50XV0uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0Vycm9yKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIFtbRXZlbnRGcmFnbWVudF1dLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNFdmVudCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbRnVuY3Rpb25GcmFnbWVudF1dLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNGdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbU3RydWN0RnJhZ21lbnRdXS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzU3RydWN0KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnRcclxuICogIHdoaWNoIGhhcyBhIG5hbWUgZnJvbSBhIHBhcnNlIEFCSS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBOYW1lZEZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGZyYWdtZW50LlxyXG4gICAgICovXHJcbiAgICBuYW1lO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIG5hbWUsIGlucHV0cykge1xyXG4gICAgICAgIHN1cGVyKGd1YXJkLCB0eXBlLCBpbnB1dHMpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIgJiYgbmFtZS5tYXRjaChyZWdleElkKSwgXCJpbnZhbGlkIGlkZW50aWZpZXJcIiwgXCJuYW1lXCIsIG5hbWUpO1xyXG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGpvaW5QYXJhbXMoZm9ybWF0LCBwYXJhbXMpIHtcclxuICAgIHJldHVybiBcIihcIiArIHBhcmFtcy5tYXAoKHApID0+IHAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gXCJmdWxsXCIpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XHJcbn1cclxuLyoqXHJcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSAvL0N1c3RvbSBFcnJvci8vLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVycm9yRnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcclxuICAgICAgICBzdXBlcihndWFyZCwgXCJlcnJvclwiLCBuYW1lLCBpbnB1dHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXJyb3JGcmFnbWVudEludGVybmFsIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIEN1c3RvbSBFcnJvciBzZWxlY3Rvci5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpLnN1YnN0cmluZygwLCAxMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnJhZ21lbnQgYXMgJSVmb3JtYXQlJS5cclxuICAgICAqL1xyXG4gICAgZm9ybWF0KGZvcm1hdCkge1xyXG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcclxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJlcnJvclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFcnJvckZyYWdtZW50KiogZm9yICUlb2JqJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKG9iaikge1xyXG4gICAgICAgIGlmIChFcnJvckZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20obGV4KG9iaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJlcnJvclwiLCBvYmopO1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XHJcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvckZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXHJcbiAgICAgKiAgKipFcnJvckZyYWdtZW50KiouXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEVycm9yRnJhZ21lbnRJbnRlcm5hbCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYW4gRXZlbnQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRXZlbnRGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgV2hldGhlciB0aGlzIGV2ZW50IGlzIGFub255bW91cy5cclxuICAgICAqL1xyXG4gICAgYW5vbnltb3VzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cywgYW5vbnltb3VzKSB7XHJcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZXZlbnRcIiwgbmFtZSwgaW5wdXRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCB9KTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYW5vbnltb3VzIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIEV2ZW50IHRvcGljIGhhc2guXHJcbiAgICAgKi9cclxuICAgIGdldCB0b3BpY0hhc2goKSB7XHJcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXZlbnQgYXMgJSVmb3JtYXQlJS5cclxuICAgICAqL1xyXG4gICAgZm9ybWF0KGZvcm1hdCkge1xyXG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcclxuICAgICAgICAgICAgICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZXZlbnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xyXG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiICYmIHRoaXMuYW5vbnltb3VzKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiYW5vbnltb3VzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSB0b3BpYyBoYXNoIGZvciBhbiBldmVudCB3aXRoICUlbmFtZSUlIGFuZCAlJXBhcmFtcyUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0VG9waWNIYXNoKG5hbWUsIHBhcmFtcykge1xyXG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCkpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBwYXJhbXMsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gZnJhZ21lbnQudG9waWNIYXNoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkV2ZW50RnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XHJcbiAgICAgICAgaWYgKEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBldmVudCBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImV2ZW50XCIsIG9iaik7XHJcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqLCB0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QgYW5vbnltb3VzID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiYW5vbnltb3VzXCJdKSkuaGFzKFwiYW5vbnltb3VzXCIpO1xyXG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cywgYW5vbnltb3VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCwgdHJ1ZSkpIDogW10sICEhb2JqLmFub255bW91cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXHJcbiAgICAgKiAgKipFdmVudEZyYWdtZW50KiouXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBjb25zdHJ1Y3Rvci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb25zdHJ1Y3RvckZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgV2hldGhlciB0aGUgY29uc3RydWN0b3IgY2FuIHJlY2VpdmUgYW4gZW5kb3dtZW50LlxyXG4gICAgICovXHJcbiAgICBwYXlhYmxlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHJlY29tbWVuZGVkIGdhcyBsaW1pdCBmb3IgZGVwbG95bWVudCBvciBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgZ2FzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cywgcGF5YWJsZSwgZ2FzKSB7XHJcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgfSk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBheWFibGUsIGdhcyB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb25zdHJ1Y3RvciBhcyAlJWZvcm1hdCUlLlxyXG4gICAgICovXHJcbiAgICBmb3JtYXQoZm9ybWF0KSB7XHJcbiAgICAgICAgYXNzZXJ0KGZvcm1hdCAhPSBudWxsICYmIGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIsIFwiY2Fubm90IGZvcm1hdCBhIGNvbnN0cnVjdG9yIGZvciBzaWdoYXNoXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZvcm1hdChzaWdoYXNoKVwiIH0pO1xyXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwidW5kZWZpbmVkXCIpLFxyXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxyXG4gICAgICAgICAgICAgICAgZ2FzOiAoKHRoaXMuZ2FzICE9IG51bGwpID8gdGhpcy5nYXMgOiB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbYGNvbnN0cnVjdG9yJHtqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpfWBdO1xyXG4gICAgICAgIGlmICh0aGlzLnBheWFibGUpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJwYXlhYmxlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5nYXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChgQCR7dGhpcy5nYXMudG9TdHJpbmcoKX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXcgKipDb25zdHJ1Y3RvckZyYWdtZW50KiogZm9yICUlb2JqJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKG9iaikge1xyXG4gICAgICAgIGlmIChDb25zdHJ1Y3RvckZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgY29uc3R1Y3RvciBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJjb25zdHJ1Y3RvclwiXSkpO1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIEt3VmlzaWJEZXBsb3kpLmhhcyhcInBheWFibGVcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGdhcyA9IGNvbnN1bWVHYXMob2JqKTtcclxuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIGlucHV0cywgcGF5YWJsZSwgZ2FzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9ndWFyZCwgXCJjb25zdHJ1Y3RvclwiLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sICEhb2JqLnBheWFibGUsIChvYmouZ2FzICE9IG51bGwpID8gb2JqLmdhcyA6IG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXHJcbiAgICAgKiAgKipDb25zdHJ1Y3RvckZyYWdtZW50KiouXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBtZXRob2QuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRmFsbGJhY2tGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBjYW4gYmUgc2VudCB2YWx1ZSBkdXJpbmcgaW52b2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcGF5YWJsZTtcclxuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBpbnB1dHMsIHBheWFibGUpIHtcclxuICAgICAgICBzdXBlcihndWFyZCwgXCJmYWxsYmFja1wiLCBpbnB1dHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRmFsbGJhY2tGcmFnbWVudEludGVybmFsIH0pO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwYXlhYmxlIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZhbGxiYWNrIGFzICUlZm9ybWF0JSUuXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdChmb3JtYXQpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gKCh0aGlzLmlucHV0cy5sZW5ndGggPT09IDApID8gXCJyZWNlaXZlXCIgOiBcImZhbGxiYWNrXCIpO1xyXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlTXV0YWJpbGl0eSA9ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwibm9ucGF5YWJsZVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHsgdHlwZSwgc3RhdGVNdXRhYmlsaXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYCR7dHlwZX0oKSR7dGhpcy5wYXlhYmxlID8gXCIgcGF5YWJsZVwiIDogXCJcIn1gO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkZhbGxiYWNrRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XHJcbiAgICAgICAgaWYgKEZhbGxiYWNrRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20obGV4KG9iaikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yT2JqID0gb2JqLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvcElzVmFsaWQgPSBvYmoucGVla0tleXdvcmQoc2V0aWZ5KFtcImZhbGxiYWNrXCIsIFwicmVjZWl2ZVwiXSkpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0b3BJc1ZhbGlkLCBcInR5cGUgbXVzdCBiZSBmYWxsYmFjayBvciByZWNlaXZlXCIsIFwib2JqXCIsIGVycm9yT2JqKTtcclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9iai5wb3BLZXl3b3JkKHNldGlmeShbXCJmYWxsYmFja1wiLCBcInJlY2VpdmVcIl0pKTtcclxuICAgICAgICAgICAgLy8gcmVjZWl2ZSgpXHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJlY2VpdmVcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5wdXRzLmxlbmd0aCA9PT0gMCwgYHJlY2VpdmUgY2Fubm90IGhhdmUgYXJndW1lbnRzYCwgXCJvYmouaW5wdXRzXCIsIGlucHV0cyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicGF5YWJsZVwiXSkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgW10sIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrKCkgW3BheWFibGVdXHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrKGJ5dGVzKSBbcGF5YWJsZV0gcmV0dXJucyAoYnl0ZXMpXHJcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbnB1dHMubGVuZ3RoID09PSAxICYmIGlucHV0c1swXS50eXBlID09PSBcImJ5dGVzXCIsIFwiaW52YWxpZCBmYWxsYmFjayBpbnB1dHNcIiwgXCJvYmouaW5wdXRzXCIsIGlucHV0cy5tYXAoKGkpID0+IGkuZm9ybWF0KFwibWluaW1hbFwiKSkuam9pbihcIiwgXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlucHV0cyA9IFtQYXJhbVR5cGUuZnJvbShcImJ5dGVzXCIpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtdXRhYmlsaXR5ID0gY29uc3VtZU11dGFiaWxpdHkob2JqKTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQobXV0YWJpbGl0eSA9PT0gXCJub25wYXlhYmxlXCIgfHwgbXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIsIFwiZmFsbGJhY2sgY2Fubm90IGJlIGNvbnN0YW50c1wiLCBcIm9iai5zdGF0ZU11dGFiaWxpdHlcIiwgbXV0YWJpbGl0eSk7XHJcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChvdXRwdXRzLmxlbmd0aCA9PT0gMSAmJiBvdXRwdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIG91dHB1dHNcIiwgXCJvYmoub3V0cHV0c1wiLCBvdXRwdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgaW5wdXRzLCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJyZWNlaXZlXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgW10sIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiZmFsbGJhY2tcIikge1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBbUGFyYW1UeXBlLmZyb20oXCJieXRlc1wiKV07XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAob2JqLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIHBheWFibGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGRlc2NyaXB0aW9uXCIsIFwib2JqXCIsIG9iaik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcclxuICAgICAqICAqKkZhbGxiYWNrRnJhZ21lbnQqKi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRmFsbGJhY2tGcmFnbWVudEludGVybmFsKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIG1ldGhvZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XHJcbiAgICAvKipcclxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gaXMgY29uc3RhbnQgKGUuZy4gYGBwdXJlYGAgb3IgYGB2aWV3YGAgZnVuY3Rpb25zKS5cclxuICAgICAqL1xyXG4gICAgY29uc3RhbnQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcmV0dXJuZWQgdHlwZXMgZm9yIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBvdXRwdXRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHN0YXRlIG11dGFiaWxpdHkgKGUuZy4gYGBwYXlhYmxlYGAsIGBgbm9ucGF5YWJsZWBgLCBgYHZpZXdgYFxyXG4gICAgICogIG9yIGBgcHVyZWBgKVxyXG4gICAgICovXHJcbiAgICBzdGF0ZU11dGFiaWxpdHk7XHJcbiAgICAvKipcclxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gY2FuIGJlIHNlbnQgdmFsdWUgZHVyaW5nIGludm9jYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHBheWFibGU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcmVjb21tZW5kZWQgZ2FzIGxpbWl0IHRvIHNlbmQgd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGdhcztcclxuICAgIC8qKlxyXG4gICAgICogIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBzdGF0ZU11dGFiaWxpdHksIGlucHV0cywgb3V0cHV0cywgZ2FzKSB7XHJcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZnVuY3Rpb25cIiwgbmFtZSwgaW5wdXRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCB9KTtcclxuICAgICAgICBvdXRwdXRzID0gT2JqZWN0LmZyZWV6ZShvdXRwdXRzLnNsaWNlKCkpO1xyXG4gICAgICAgIGNvbnN0IGNvbnN0YW50ID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XHJcbiAgICAgICAgY29uc3QgcGF5YWJsZSA9IChzdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgY29uc3RhbnQsIGdhcywgb3V0cHV0cywgcGF5YWJsZSwgc3RhdGVNdXRhYmlsaXR5IH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIEZ1bmN0aW9uIHNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2VsZWN0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSkuc3Vic3RyaW5nKDAsIDEwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhcyAlJWZvcm1hdCUlLlxyXG4gICAgICovXHJcbiAgICBmb3JtYXQoZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICAgICAgY29uc3RhbnQ6IHRoaXMuY29uc3RhbnQsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcclxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcclxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcclxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKSxcclxuICAgICAgICAgICAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cy5tYXAoKG8pID0+IEpTT04ucGFyc2Uoby5mb3JtYXQoZm9ybWF0KSkpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJmdW5jdGlvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XHJcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zdGF0ZU11dGFiaWxpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dHMgJiYgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJyZXR1cm5zXCIpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goam9pblBhcmFtcyhmb3JtYXQsIHRoaXMub3V0cHV0cykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChgQCR7dGhpcy5nYXMudG9TdHJpbmcoKX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBzZWxlY3RvciBmb3IgYSBmdW5jdGlvbiB3aXRoICUlbmFtZSUlIGFuZCAlJXBhcmFtcyUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3IobmFtZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG5hbWUsIFwidmlld1wiLCBwYXJhbXMsIFtdLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuc2VsZWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRnVuY3Rpb25GcmFnbWVudCoqIGZvciAlJW9iaiUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShvYmopIHtcclxuICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZ1bmN0aW9uIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZnVuY3Rpb25cIiwgb2JqKTtcclxuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xyXG4gICAgICAgICAgICBjb25zdCBtdXRhYmlsaXR5ID0gY29uc3VtZU11dGFiaWxpdHkob2JqKTtcclxuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJyZXR1cm5zXCJdKSkuaGFzKFwicmV0dXJuc1wiKSkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XHJcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgbXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3RhdGVNdXRhYmlsaXR5ID0gb2JqLnN0YXRlTXV0YWJpbGl0eTtcclxuICAgICAgICAvLyBVc2UgbGVnYWN5IFNvbGlkaXR5IEFCSSBsb2dpYyBpZiBzdGF0ZU11dGFiaWxpdHkgaXMgbWlzc2luZ1xyXG4gICAgICAgIGlmIChzdGF0ZU11dGFiaWxpdHkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLmNvbnN0YW50KSA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvYmouY29uc3RhbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQFRPRE86IHZlcmlmeVN0YXRlIGZvciBzdGF0ZU11dGFiaWxpdHkgKGUuZy4gdGhyb3cgaWZcclxuICAgICAgICAvLyAgICAgICAgcGF5YWJsZTogZmFsc2UgYnV0IHN0YXRlTXV0YWJpbGl0eSBpcyBcIm5vbnBheWFibGVcIilcclxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIG9iai5vdXRwdXRzID8gb2JqLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxyXG4gICAgICogICoqRnVuY3Rpb25GcmFnbWVudCoqLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgc3RydWN0dXJlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFN0cnVjdEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XHJcbiAgICAvKipcclxuICAgICAqICBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzKSB7XHJcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwic3RydWN0XCIsIG5hbWUsIGlucHV0cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBTdHJ1Y3RGcmFnbWVudEludGVybmFsIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHN0cnVjdCBhcyAlJWZvcm1hdCUlLlxyXG4gICAgICovXHJcbiAgICBmb3JtYXQoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqU3RydWN0RnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBzdHJ1Y3QgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJzdHJ1Y3RcIiwgb2JqKTtcclxuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xyXG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RydWN0RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XHJcbiAgICB9XHJcbiAgICAvLyBAVE9ETzogZml4IHRoaXMgcmV0dXJuIHR5cGVcclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxyXG4gICAgICogICoqU3RydWN0RnJhZ21lbnQqKi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gU3RydWN0RnJhZ21lbnRJbnRlcm5hbCk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhZ21lbnRzLmpzLm1hcCIsIi8qKlxyXG4gKiAgV2hlbiBzZW5kaW5nIHZhbHVlcyB0byBvciByZWNlaXZpbmcgdmFsdWVzIGZyb20gYSBbW0NvbnRyYWN0XV0sIHRoZVxyXG4gKiAgZGF0YSBpcyBnZW5lcmFsbHkgZW5jb2RlZCB1c2luZyB0aGUgW0FCSSBzdGFuZGFyZF0obGluay1zb2xjLWFiaSkuXHJcbiAqXHJcbiAqICBUaGUgQWJpQ29kZXIgcHJvdmlkZXMgYSB1dGlsaXR5IHRvIGVuY29kZSB2YWx1ZXMgdG8gQUJJIGRhdGEgYW5kXHJcbiAqICBkZWNvZGUgdmFsdWVzIGZyb20gQUJJIGRhdGEuXHJcbiAqXHJcbiAqICBNb3N0IG9mIHRoZSB0aW1lLCBkZXZlbG9wZXJzIHNob3VsZCBmYXZvdXIgdGhlIFtbQ29udHJhY3RdXSBjbGFzcyxcclxuICogIHdoaWNoIGZ1cnRoZXIgYWJzdHJhY3RzIGEgbG90IG9mIHRoZSBmaW5lciBkZXRhaWxzIG9mIEFCSSBkYXRhLlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uIGFwaS9hYmkvYWJpLWNvZGVyOkFCSSBFbmNvZGluZ1xyXG4gKi9cclxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxyXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudENvdW50LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBSZWFkZXIsIFdyaXRlciB9IGZyb20gXCIuL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qc1wiO1xyXG5pbXBvcnQgeyBBZGRyZXNzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWRkcmVzcy5qc1wiO1xyXG5pbXBvcnQgeyBBcnJheUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2FycmF5LmpzXCI7XHJcbmltcG9ydCB7IEJvb2xlYW5Db2RlciB9IGZyb20gXCIuL2NvZGVycy9ib29sZWFuLmpzXCI7XHJcbmltcG9ydCB7IEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYnl0ZXMuanNcIjtcclxuaW1wb3J0IHsgRml4ZWRCeXRlc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2ZpeGVkLWJ5dGVzLmpzXCI7XHJcbmltcG9ydCB7IE51bGxDb2RlciB9IGZyb20gXCIuL2NvZGVycy9udWxsLmpzXCI7XHJcbmltcG9ydCB7IE51bWJlckNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bWJlci5qc1wiO1xyXG5pbXBvcnQgeyBTdHJpbmdDb2RlciB9IGZyb20gXCIuL2NvZGVycy9zdHJpbmcuanNcIjtcclxuaW1wb3J0IHsgVHVwbGVDb2RlciB9IGZyb20gXCIuL2NvZGVycy90dXBsZS5qc1wiO1xyXG5pbXBvcnQgeyBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcclxuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5LCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbFxyXG5jb25zdCBQYW5pY1JlYXNvbnMgPSBuZXcgTWFwKCk7XHJcblBhbmljUmVhc29ucy5zZXQoMHgwMCwgXCJHRU5FUklDX1BBTklDXCIpO1xyXG5QYW5pY1JlYXNvbnMuc2V0KDB4MDEsIFwiQVNTRVJUX0ZBTFNFXCIpO1xyXG5QYW5pY1JlYXNvbnMuc2V0KDB4MTEsIFwiT1ZFUkZMT1dcIik7XHJcblBhbmljUmVhc29ucy5zZXQoMHgxMiwgXCJESVZJREVfQllfWkVST1wiKTtcclxuUGFuaWNSZWFzb25zLnNldCgweDIxLCBcIkVOVU1fUkFOR0VfRVJST1JcIik7XHJcblBhbmljUmVhc29ucy5zZXQoMHgyMiwgXCJCQURfU1RPUkFHRV9EQVRBXCIpO1xyXG5QYW5pY1JlYXNvbnMuc2V0KDB4MzEsIFwiU1RBQ0tfVU5ERVJGTE9XXCIpO1xyXG5QYW5pY1JlYXNvbnMuc2V0KDB4MzIsIFwiQVJSQVlfUkFOR0VfRVJST1JcIik7XHJcblBhbmljUmVhc29ucy5zZXQoMHg0MSwgXCJPVVRfT0ZfTUVNT1JZXCIpO1xyXG5QYW5pY1JlYXNvbnMuc2V0KDB4NTEsIFwiVU5JTklUSUFMSVpFRF9GVU5DVElPTl9DQUxMXCIpO1xyXG5jb25zdCBwYXJhbVR5cGVCeXRlcyA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO1xyXG5jb25zdCBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xyXG5sZXQgZGVmYXVsdENvZGVyID0gbnVsbDtcclxubGV0IGRlZmF1bHRNYXhJbmZsYXRpb24gPSAxMDI0O1xyXG5mdW5jdGlvbiBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhLCBhYmlDb2Rlcikge1xyXG4gICAgbGV0IG1lc3NhZ2UgPSBcIm1pc3NpbmcgcmV2ZXJ0IGRhdGFcIjtcclxuICAgIGxldCByZWFzb24gPSBudWxsO1xyXG4gICAgY29uc3QgaW52b2NhdGlvbiA9IG51bGw7XHJcbiAgICBsZXQgcmV2ZXJ0ID0gbnVsbDtcclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgbWVzc2FnZSA9IFwiZXhlY3V0aW9uIHJldmVydGVkXCI7XHJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcclxuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcclxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKG5vIGRhdGEgcHJlc2VudDsgbGlrZWx5IHJlcXVpcmUoZmFsc2UpIG9jY3VycmVkXCI7XHJcbiAgICAgICAgICAgIHJlYXNvbiA9IFwicmVxdWlyZShmYWxzZSlcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoICUgMzIgIT09IDQpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSByZWFzb247IGludmFsaWQgZGF0YSBsZW5ndGgpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpID09PSBcIjB4MDhjMzc5YTBcIikge1xyXG4gICAgICAgICAgICAvLyBFcnJvcihzdHJpbmcpXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZWFzb24gPSBhYmlDb2Rlci5kZWNvZGUoW1wic3RyaW5nXCJdLCBieXRlcy5zbGljZSg0KSlbMF07XHJcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIixcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlYXNvbl1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA6ICR7SlNPTi5zdHJpbmdpZnkocmVhc29uKX1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSByZWFzb247IGludmFsaWQgc3RyaW5nIGRhdGEpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHg0ZTQ4N2I3MVwiKSB7XHJcbiAgICAgICAgICAgIC8vIFBhbmljKHVpbnQyNTYpXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gTnVtYmVyKGFiaUNvZGVyLmRlY29kZShbXCJ1aW50MjU2XCJdLCBieXRlcy5zbGljZSg0KSlbMF0pO1xyXG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJQYW5pYyh1aW50MjU2KVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUGFuaWNcIixcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbY29kZV1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZWFzb24gPSBgUGFuaWMgZHVlIHRvICR7UGFuaWNSZWFzb25zLmdldChjb2RlKSB8fCBcIlVOS05PV05cIn0oJHtjb2RlfSlgO1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke3JlYXNvbn1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSBwYW5pYyBjb2RlKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiICh1bmtub3duIGN1c3RvbSBlcnJvcilcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcclxuICAgICAgICB0bzogKHR4LnRvID8gZ2V0QWRkcmVzcyh0eC50bykgOiBudWxsKSxcclxuICAgICAgICBkYXRhOiAodHguZGF0YSB8fCBcIjB4XCIpXHJcbiAgICB9O1xyXG4gICAgaWYgKHR4LmZyb20pIHtcclxuICAgICAgICB0cmFuc2FjdGlvbi5mcm9tID0gZ2V0QWRkcmVzcyh0eC5mcm9tKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYWtlRXJyb3IobWVzc2FnZSwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XHJcbiAgICAgICAgYWN0aW9uLCBkYXRhLCByZWFzb24sIHRyYW5zYWN0aW9uLCBpbnZvY2F0aW9uLCByZXZlcnRcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiAgVGhlICoqQWJpQ29kZXIqKiBpcyBhIGxvdy1sZXZlbCBjbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jb2RpbmcgSmF2YVNjcmlwdFxyXG4gKiAgdmFsdWVzIGludG8gYmluYXJ5IGRhdGEgYW5kIGRlY29kaW5nIGJpbmFyeSBkYXRhIGludG8gSmF2YVNjcmlwdCB2YWx1ZXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWJpQ29kZXIge1xyXG4gICAgI2dldENvZGVyKHBhcmFtKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtLmlzQXJyYXkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29kZXIodGhpcy4jZ2V0Q29kZXIocGFyYW0uYXJyYXlDaGlsZHJlbiksIHBhcmFtLmFycmF5TGVuZ3RoLCBwYXJhbS5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcmFtLmlzVHVwbGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlQ29kZXIocGFyYW0uY29tcG9uZW50cy5tYXAoKGMpID0+IHRoaXMuI2dldENvZGVyKGMpKSwgcGFyYW0ubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAocGFyYW0uYmFzZVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO1xyXG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuQ29kZXIocGFyYW0ubmFtZSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nQ29kZXIocGFyYW0ubmFtZSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlc0NvZGVyKHBhcmFtLm5hbWUpO1xyXG4gICAgICAgICAgICBjYXNlIFwiXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE51bGxDb2RlcihwYXJhbS5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdT9pbnRbMC05XSpcclxuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIFwiICsgbWF0Y2hbMV0gKyBcIiBiaXQgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvZGVyKHNpemUgLyA4LCAobWF0Y2hbMV0gPT09IFwiaW50XCIpLCBwYXJhbS5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYnl0ZXNbMC05XStcclxuICAgICAgICBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCBwYXJhbS50eXBlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEdldCB0aGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBnaXZlbiAlJXR5cGVzJSUuXHJcbiAgICAgKlxyXG4gICAgICogIEZvciBleGFtcGxlLCBhIGBgdWludGBgIGlzIGJ5IGRlZmF1bHQgYGAwYGAgYW5kIGBgYm9vbGBgXHJcbiAgICAgKiAgaXMgYnkgZGVmYXVsdCBgYGZhbHNlYGAuXHJcbiAgICAgKi9cclxuICAgIGdldERlZmF1bHRWYWx1ZSh0eXBlcykge1xyXG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcclxuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xyXG4gICAgICAgIHJldHVybiBjb2Rlci5kZWZhdWx0VmFsdWUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEVuY29kZSB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gQUJJIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcclxuICAgICAqL1xyXG4gICAgZW5jb2RlKHR5cGVzLCB2YWx1ZXMpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlcy5sZW5ndGgsIHR5cGVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIpO1xyXG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcclxuICAgICAgICBjb25zdCBjb2RlciA9IChuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKSk7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFdyaXRlcigpO1xyXG4gICAgICAgIGNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlcyk7XHJcbiAgICAgICAgcmV0dXJuIHdyaXRlci5kYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgRGVjb2RlIHRoZSBBQkkgJSVkYXRhJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgJSVsb29zZSUlIGRlY29kaW5nIGlzIGVuYWJsZWQsIHRoZW4gc3RyaWN0IHBhZGRpbmcgaXNcclxuICAgICAqICBub3QgZW5mb3JjZWQuIFNvbWUgb2xkZXIgdmVyc2lvbnMgb2YgU29saWRpdHkgaW5jb3JyZWN0bHlcclxuICAgICAqICBwYWRkZWQgZXZlbnQgZGF0YSBlbWl0dGVkIGZyb20gYGBleHRlcm5hbGBgIGZ1bmN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgZGVjb2RlKHR5cGVzLCBkYXRhLCBsb29zZSkge1xyXG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcclxuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xyXG4gICAgICAgIHJldHVybiBjb2Rlci5kZWNvZGUobmV3IFJlYWRlcihkYXRhLCBsb29zZSwgZGVmYXVsdE1heEluZmxhdGlvbikpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9zZXREZWZhdWx0TWF4SW5mbGF0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwiaW52YWxpZCBkZWZhdWx0TWF4SW5mbGF0aW9uIGZhY3RvclwiLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICBkZWZhdWx0TWF4SW5mbGF0aW9uID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBzaGFyZWQgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgZGVmYXVsdCBbW0FiaUNvZGVyXV0uXHJcbiAgICAgKlxyXG4gICAgICogIE9uIHRoZSBmaXJzdCBjYWxsLCB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCBpbnRlcm5hbGx5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZGVmYXVsdEFiaUNvZGVyKCkge1xyXG4gICAgICAgIGlmIChkZWZhdWx0Q29kZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWZhdWx0Q29kZXIgPSBuZXcgQWJpQ29kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb2RlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYW4gZXRoZXJzLWNvbXBhdGlibGUgW1tDYWxsRXhjZXB0aW9uRXJyb3JdXSBFcnJvciBmb3IgdGhlIGdpdmVuXHJcbiAgICAgKiAgcmVzdWx0ICUlZGF0YSUlIGZvciB0aGUgW1tDYWxsRXhjZXB0aW9uQWN0aW9uXV0gJSVhY3Rpb24lJSBhZ2FpbnN0XHJcbiAgICAgKiAgdGhlIFRyYW5zYWN0aW9uICUldHglJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaS1jb2Rlci5qcy5tYXAiLCIvKipcclxuICogIFRoZSBJbnRlcmZhY2UgY2xhc3MgaXMgYSBsb3ctbGV2ZWwgY2xhc3MgdGhhdCBhY2NlcHRzIGFuXHJcbiAqICBBQkkgYW5kIHByb3ZpZGVzIGFsbCB0aGUgbmVjZXNzYXJ5IGZ1bmN0aW9uYWxpdHkgdG8gZW5jb2RlXHJcbiAqICBhbmQgZGVjb2RlIHBhcmFtYXRlcnMgdG8gYW5kIHJlc3VsdHMgZnJvbSBtZXRob2RzLCBldmVudHNcclxuICogIGFuZCBlcnJvcnMuXHJcbiAqXHJcbiAqICBJdCBhbHNvIHByb3ZpZGVzIHNldmVyYWwgY29udmVuaWVuY2UgbWV0aG9kcyB0byBhdXRvbWF0aWNhbGx5XHJcbiAqICBzZWFyY2ggYW5kIGZpbmQgbWF0Y2hpbmcgdHJhbnNhY3Rpb25zIGFuZCBldmVudHMgdG8gcGFyc2UgdGhlbS5cclxuICpcclxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpOkludGVyZmFjZXMgIFtpbnRlcmZhY2VzXVxyXG4gKi9cclxuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnksIHplcm9QYWRCeXRlcywgemVyb1BhZFZhbHVlLCBpc0hleFN0cmluZywgZGVmaW5lUHJvcGVydGllcywgYXNzZXJ0QXJndW1lbnQsIHRvQmVIZXgsIGFzc2VydCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBBYmlDb2RlciB9IGZyb20gXCIuL2FiaS1jb2Rlci5qc1wiO1xyXG5pbXBvcnQgeyBjaGVja1Jlc3VsdEVycm9ycywgUmVzdWx0IH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzXCI7XHJcbmltcG9ydCB7IENvbnN0cnVjdG9yRnJhZ21lbnQsIEVycm9yRnJhZ21lbnQsIEV2ZW50RnJhZ21lbnQsIEZyYWdtZW50LCBGdW5jdGlvbkZyYWdtZW50LCBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcclxuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi90eXBlZC5qc1wiO1xyXG5leHBvcnQgeyBjaGVja1Jlc3VsdEVycm9ycywgUmVzdWx0IH07XHJcbi8qKlxyXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VMb2ddXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIGEgTG9nIHRvIGl0cyBldmVudFxyXG4gKiAgZm9yIHBhcnNpbmcsIGEgKipMb2dEZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExvZ0Rlc2NyaXB0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmb3IgdGhlIGBgdG9waWMwYGAuXHJcbiAgICAgKi9cclxuICAgIGZyYWdtZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEV2ZW50LlxyXG4gICAgICovXHJcbiAgICBuYW1lO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZ1bGwgRXZlbnQgc2lnbmF0dXJlLlxyXG4gICAgICovXHJcbiAgICBzaWduYXR1cmU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdG9waWMgaGFzaCBmb3IgdGhlIEV2ZW50LlxyXG4gICAgICovXHJcbiAgICB0b3BpYztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIEV2ZW50IHdpdGggYGBlbWl0YGAuXHJcbiAgICAgKi9cclxuICAgIGFyZ3M7XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHRvcGljLCBhcmdzKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgc2lnbmF0dXJlLCB0b3BpYywgYXJnc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VUcmFuc2FjdGlvbl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2hcclxuICogIGEgdHJhbnNhY3Rpb24gZGF0YSB0byBpdHMgZnVuY3Rpb24gZm9yIHBhcnNpbmcsXHJcbiAqICBhICoqVHJhbnNhY3Rpb25EZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uRGVzY3JpcHRpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxyXG4gICAgICovXHJcbiAgICBmcmFnbWVudDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cclxuICAgICAqL1xyXG4gICAgbmFtZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cclxuICAgICAqL1xyXG4gICAgYXJncztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBmdWxsIEZ1bmN0aW9uIHNpZ25hdHVyZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cclxuICAgICAqL1xyXG4gICAgc2lnbmF0dXJlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHNlbGVjdG9yIGZvciB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGBgdmFsdWVgYCAoaW4gd2VpKSBmcm9tIHRoZSB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgdmFsdWU7XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIGFyZ3MsIHNpZ25hdHVyZSwgc2VsZWN0b3IsIHZhbHVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZUVycm9yXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaCBhblxyXG4gKiAgZXJyb3IgZm9yIGEgY2FsbCByZXN1bHQgZm9yIHBhcnNpbmcsIGFuICoqRXJyb3JEZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVycm9yRGVzY3JpcHRpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50LlxyXG4gICAgICovXHJcbiAgICBmcmFnbWVudDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFcnJvci5cclxuICAgICAqL1xyXG4gICAgbmFtZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBFcnJvciB3aXRoIGBgcmV2ZXJ0YGAuXHJcbiAgICAgKi9cclxuICAgIGFyZ3M7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZnVsbCBFcnJvciBzaWduYXR1cmUuXHJcbiAgICAgKi9cclxuICAgIHNpZ25hdHVyZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEVycm9yLlxyXG4gICAgICovXHJcbiAgICBzZWxlY3RvcjtcclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XHJcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBhcmdzLCBzaWduYXR1cmUsIHNlbGVjdG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBbiAqKkluZGV4ZWQqKiBpcyB1c2VkIGFzIGEgdmFsdWUgd2hlbiBhIHZhbHVlIHRoYXQgZG9lcyBub3RcclxuICogIGZpdCB3aXRoaW4gYSB0b3BpYyAoaS5lLiBub3QgYSBmaXhlZC1sZW5ndGgsIDMyLWJ5dGUgdHlwZSkuIEl0XHJcbiAqICBpcyB0aGUgYGBrZWNjYWsyNTZgYCBvZiB0aGUgdmFsdWUsIGFuZCB1c2VkIGZvciB0eXBlcyBzdWNoIGFzXHJcbiAqICBhcnJheXMsIHR1cGxlcywgYnl0ZXMgYW5kIHN0cmluZ3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW5kZXhlZCB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYGBrZWNjYWsyNTZgYCBvZiB0aGUgdmFsdWUgbG9nZ2VkLlxyXG4gICAgICovXHJcbiAgICBoYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIF9pc0luZGV4ZWQ7XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUldmFsdWUlJSBpcyBhbiAqKkluZGV4ZWQqKi5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgZm9yIHByb3BlcnR5IGFjY2Vzcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzSW5kZXhlZCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbmRleGVkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihoYXNoKSB7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGhhc2gsIF9pc0luZGV4ZWQ6IHRydWUgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xMy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbD9oaWdobGlnaHQ9cGFuaWMjcGFuaWMtdmlhLWFzc2VydC1hbmQtZXJyb3ItdmlhLXJlcXVpcmVcclxuY29uc3QgUGFuaWNSZWFzb25zID0ge1xyXG4gICAgXCIwXCI6IFwiZ2VuZXJpYyBwYW5pY1wiLFxyXG4gICAgXCIxXCI6IFwiYXNzZXJ0KGZhbHNlKVwiLFxyXG4gICAgXCIxN1wiOiBcImFyaXRobWV0aWMgb3ZlcmZsb3dcIixcclxuICAgIFwiMThcIjogXCJkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiLFxyXG4gICAgXCIzM1wiOiBcImVudW0gb3ZlcmZsb3dcIixcclxuICAgIFwiMzRcIjogXCJpbnZhbGlkIGVuY29kZWQgc3RvcmFnZSBieXRlIGFycmF5IGFjY2Vzc2VkXCIsXHJcbiAgICBcIjQ5XCI6IFwib3V0LW9mLWJvdW5kcyBhcnJheSBhY2Nlc3M7IHBvcHBpbmcgb24gYW4gZW1wdHkgYXJyYXlcIixcclxuICAgIFwiNTBcIjogXCJvdXQtb2YtYm91bmRzIGFjY2VzcyBvZiBhbiBhcnJheSBvciBieXRlc05cIixcclxuICAgIFwiNjVcIjogXCJvdXQgb2YgbWVtb3J5XCIsXHJcbiAgICBcIjgxXCI6IFwidW5pbml0aWFsaXplZCBmdW5jdGlvblwiLFxyXG59O1xyXG5jb25zdCBCdWlsdGluRXJyb3JzID0ge1xyXG4gICAgXCIweDA4YzM3OWEwXCI6IHtcclxuICAgICAgICBzaWduYXR1cmU6IFwiRXJyb3Ioc3RyaW5nKVwiLFxyXG4gICAgICAgIG5hbWU6IFwiRXJyb3JcIixcclxuICAgICAgICBpbnB1dHM6IFtcInN0cmluZ1wiXSxcclxuICAgICAgICByZWFzb246IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCByZWFzb24gc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSl9YDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXCIweDRlNDg3YjcxXCI6IHtcclxuICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcclxuICAgICAgICBuYW1lOiBcIlBhbmljXCIsXHJcbiAgICAgICAgaW5wdXRzOiBbXCJ1aW50MjU2XCJdLFxyXG4gICAgICAgIHJlYXNvbjogKGNvZGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwidW5rbm93biBwYW5pYyBjb2RlXCI7XHJcbiAgICAgICAgICAgIGlmIChjb2RlID49IDAgJiYgY29kZSA8PSAweGZmICYmIFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldKSB7XHJcbiAgICAgICAgICAgICAgICByZWFzb24gPSBQYW5pY1JlYXNvbnNbY29kZS50b1N0cmluZygpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYHJldmVydGVkIHdpdGggcGFuaWMgY29kZSAweCR7Y29kZS50b1N0cmluZygxNil9ICgke3JlYXNvbn0pYDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiAgQW4gSW50ZXJmYWNlIGFic3RyYWN0cyBtYW55IG9mIHRoZSBsb3ctbGV2ZWwgZGV0YWlscyBmb3JcclxuICogIGVuY29kaW5nIGFuZCBkZWNvZGluZyB0aGUgZGF0YSBvbiB0aGUgYmxvY2tjaGFpbi5cclxuICpcclxuICogIEFuIEFCSSBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZW5jb2RlIGRhdGEgdG8gc2VuZCB0b1xyXG4gKiAgYSBDb250cmFjdCwgaG93IHRvIGRlY29kZSB0aGUgcmVzdWx0cyBhbmQgZXZlbnRzIGFuZCBob3cgdG9cclxuICogIGludGVycHJldCByZXZlcnQgZXJyb3JzLlxyXG4gKlxyXG4gKiAgVGhlIEFCSSBjYW4gYmUgc3BlY2lmaWVkIGJ5IFthbnkgc3VwcG9ydGVkIGZvcm1hdF0oSW50ZXJmYWNlQWJpKS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbnRlcmZhY2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQWxsIHRoZSBDb250cmFjdCBBQkkgbWVtYmVycyAoaS5lLiBtZXRob2RzLCBldmVudHMsIGVycm9ycywgZXRjKS5cclxuICAgICAqL1xyXG4gICAgZnJhZ21lbnRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIENvbnRyYWN0IGNvbnN0cnVjdG9yLlxyXG4gICAgICovXHJcbiAgICBkZXBsb3k7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgRmFsbGJhY2sgbWV0aG9kLCBpZiBhbnkuXHJcbiAgICAgKi9cclxuICAgIGZhbGxiYWNrO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgSWYgcmVjZWl2aW5nIGV0aGVyIGlzIHN1cHBvcnRlZC5cclxuICAgICAqL1xyXG4gICAgcmVjZWl2ZTtcclxuICAgICNlcnJvcnM7XHJcbiAgICAjZXZlbnRzO1xyXG4gICAgI2Z1bmN0aW9ucztcclxuICAgIC8vICAgICNzdHJ1Y3RzOiBNYXA8c3RyaW5nLCBTdHJ1Y3RGcmFnbWVudD47XHJcbiAgICAjYWJpQ29kZXI7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBuZXcgSW50ZXJmYWNlIGZvciB0aGUgJSVmcmFnbWVudHMlJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XHJcbiAgICAgICAgbGV0IGFiaSA9IFtdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50cykgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNmdW5jdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy4jZXJyb3JzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuI2V2ZW50cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvLyAgICAgICAgdGhpcy4jc3RydWN0cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCBmcmFncyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBhYmkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZyYWdzLnB1c2goRnJhZ21lbnQuZnJvbShhKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1dhcm5pbmddIEludmFsaWQgRnJhZ21lbnQgJHtKU09OLnN0cmluZ2lmeShhKX06YCwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XHJcbiAgICAgICAgICAgIGZyYWdtZW50czogT2JqZWN0LmZyZWV6ZShmcmFncylcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgZmFsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIGxldCByZWNlaXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy4jYWJpQ29kZXIgPSB0aGlzLmdldEFiaUNvZGVyKCk7XHJcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXHJcbiAgICAgICAgdGhpcy5mcmFnbWVudHMuZm9yRWFjaCgoZnJhZ21lbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBidWNrZXQ7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwbG95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZGVwbG95OiBmcmFnbWVudCB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFmYWxsYmFjayB8fCBmcmFnbWVudC5wYXlhYmxlICE9PSBmYWxsYmFjay5wYXlhYmxlLCBcImNvbmZsaWN0aW5nIGZhbGxiYWNrIGZyYWdtZW50c1wiLCBgZnJhZ21lbnRzWyR7aW5kZXh9XWAsIGZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBmcmFnbWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZSA9IGZhbGxiYWNrLnBheWFibGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJvdXRwdXRcIiwgKDxGdW5jdGlvbkZyYWdtZW50PmZyYWdtZW50KS5vdXRwdXRzKTtcclxuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNmdW5jdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcclxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcclxuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNldmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcclxuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNlcnJvcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUd28gaWRlbnRpY2FsIGVudHJpZXM7IGlnbm9yZSBpdFxyXG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcclxuICAgICAgICAgICAgaWYgKGJ1Y2tldC5oYXMoc2lnbmF0dXJlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ1Y2tldC5zZXQoc2lnbmF0dXJlLCBmcmFnbWVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgYSBjb25zdHJ1Y3RvciBhZGQgYSBkZWZhdWx0XHJcbiAgICAgICAgaWYgKCF0aGlzLmRlcGxveSkge1xyXG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIGRlcGxveTogQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKFwiY29uc3RydWN0b3IoKVwiKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZhbGxiYWNrLCByZWNlaXZlIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgZW50aXJlIEh1bWFuLVJlYWRhYmxlIEFCSSwgYXMgYW4gYXJyYXkgb2ZcclxuICAgICAqICBzaWduYXR1cmVzLCBvcHRpb25hbGx5IGFzICUlbWluaW1hbCUlIHN0cmluZ3MsIHdoaWNoXHJcbiAgICAgKiAgcmVtb3ZlcyBwYXJhbWV0ZXIgbmFtZXMgYW5kIHVubmVjZWVzYXJ5IHNwYWNlcy5cclxuICAgICAqL1xyXG4gICAgZm9ybWF0KG1pbmltYWwpIHtcclxuICAgICAgICBjb25zdCBmb3JtYXQgPSAobWluaW1hbCA/IFwibWluaW1hbFwiIDogXCJmdWxsXCIpO1xyXG4gICAgICAgIGNvbnN0IGFiaSA9IHRoaXMuZnJhZ21lbnRzLm1hcCgoZikgPT4gZi5mb3JtYXQoZm9ybWF0KSk7XHJcbiAgICAgICAgcmV0dXJuIGFiaTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgSlNPTi1lbmNvZGVkIEFCSS4gVGhpcyBpcyB0aGUgZm9ybWF0IFNvbGlkaXlcclxuICAgICAqICByZXR1cm5zLlxyXG4gICAgICovXHJcbiAgICBmb3JtYXRKc29uKCkge1xyXG4gICAgICAgIGNvbnN0IGFiaSA9IHRoaXMuZnJhZ21lbnRzLm1hcCgoZikgPT4gZi5mb3JtYXQoXCJqc29uXCIpKTtcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlLWJ1bmRsZSB0aGUgSlNPTiBmcmFnbWVudHMgYSBiaXRcclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIEFCSSBjb2RlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbmNvZGUgYW5kIGRlY29kZSBiaW5hcnlcclxuICAgICAqICBkYXRhLlxyXG4gICAgICovXHJcbiAgICBnZXRBYmlDb2RlcigpIHtcclxuICAgICAgICByZXR1cm4gQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCk7XHJcbiAgICB9XHJcbiAgICAvLyBGaW5kIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxyXG4gICAgI2dldEZ1bmN0aW9uKGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xyXG4gICAgICAgIC8vIFNlbGVjdG9yXHJcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiB0aGlzLiNmdW5jdGlvbnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXHJcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Z1bmN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5wdXNoKGZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSAodmFsdWVzLmxlbmd0aCA+IDApID8gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbGV0IGFsbG93T3B0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZChsYXN0VmFsdWUpICYmIGxhc3RWYWx1ZS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPcHRpb25zID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVMZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wYXRpYmxlIGxlbmd0aC4gVGhlIGFyZ3NcclxuICAgICAgICAgICAgICAgIC8vIG1heSBjb250YWluIGFuIG92ZXJyaWRlcywgc28gdGhlIG1hdGNoIG1heSBoYXZlIG4gb3IgbiAtIDEgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzICE9PSB2YWx1ZUxlbmd0aCAmJiAoIWFsbG93T3B0aW9ucyB8fCBpbnB1dHMgIT09IHZhbHVlTGVuZ3RoIC0gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB0eXBlZCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVR5cGVkLmlzVHlwZWQodmFsdWVzW2pdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHBhc3QgdGhlIGlucHV0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+PSBpbnB1dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgPT09IFwib3ZlcnJpZGVzXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmFsdWUgdHlwZSBtYXRjaGVzIHRoZSBpbnB1dCB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSAhPT0gaW5wdXRzW2pdLmJhc2VUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHNpbmdsZSBtYXRjaGluZyBzaWduYXR1cmUgd2l0aCBhbiBvdmVycmlkZXMsIGJ1dCB0aGVcclxuICAgICAgICAgICAgLy8gbGFzdCB2YWx1ZSBpcyBzb21ldGhpbmcgdGhhdCBjYW5ub3QgcG9zc2libHkgYmUgYW4gb3B0aW9uc1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAxICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoICE9PSBtYXRjaGluZ1swXS5pbnB1dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXJnID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0QXJnID09IG51bGwgfHwgQXJyYXkuaXNBcnJheShsYXN0QXJnKSB8fCB0eXBlb2YgKGxhc3RBcmcpICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPiAxICYmIGZvcmNlVW5pcXVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGZ1bmN0aW9uIGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVuY3Rpb25zLmdldChGdW5jdGlvbkZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEdldCB0aGUgZnVuY3Rpb24gbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb24gc2VsZWN0b3IsXHJcbiAgICAgKiAgZnVuY3Rpb24gbmFtZSBvciBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXHJcbiAgICAgKi9cclxuICAgIGdldEZ1bmN0aW9uTmFtZShrZXkpIHtcclxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwia2V5XCIsIGtleSk7XHJcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50Lm5hbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVrZXklJSAoYSBmdW5jdGlvbiBzZWxlY3RvciwgZnVuY3Rpb24gbmFtZSBvclxyXG4gICAgICogIGZ1bmN0aW9uIHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxyXG4gICAgICpcclxuICAgICAqICBJbiB0aGUgY2FzZSBvZiBhIGZ1bmN0aW9uIG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXHJcbiAgICAgKiAgYWNjZXNzaW5nIHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBtYXkgcmVxdWlyZSByZWZpbmVtZW50LlxyXG4gICAgICovXHJcbiAgICBoYXNGdW5jdGlvbihrZXkpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLiNnZXRGdW5jdGlvbihrZXksIG51bGwsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEdldCB0aGUgW1tGdW5jdGlvbkZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uXHJcbiAgICAgKiAgc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxyXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBmdW5jdGlvbnMgbWF0Y2ggYnkgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBmdW5jdGlvbiBpblxyXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cclxuICAgICAqL1xyXG4gICAgZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGZ1bmN0aW9ucywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoRnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZnVuY3Rpb25zLmtleXMoKSk7XHJcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2Z1bmN0aW9ucy5nZXQobmFtZSkpLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBGaW5kIGFuIGV2ZW50IGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcclxuICAgICNnZXRFdmVudChrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcclxuICAgICAgICAvLyBFdmVudFRvcGljXHJcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2V2ZW50cy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VG9waWMgPT09IGZyYWdtZW50LnRvcGljSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcclxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wYXRpYmxlIGxlbmd0aC5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoIDwgdmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIFR5cGVkIHNpZ25hdHVyZVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHR5cGVkIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgIT09IGlucHV0c1tqXS5iYXNlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZXZlbnQgZGVzY3JpcHRpb24gKGkuZS4gbWF0Y2hlcyAke21hdGNoU3RyfSlgLCBcImtleVwiLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNldmVudHMuZ2V0KEV2ZW50RnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgR2V0IHRoZSBldmVudCBuYW1lIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxyXG4gICAgICogIGV2ZW50IG5hbWUgb3IgZXZlbnQgc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxyXG4gICAgICovXHJcbiAgICBnZXRFdmVudE5hbWUoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLiNnZXRFdmVudChrZXksIG51bGwsIGZhbHNlKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBldmVudFwiLCBcImtleVwiLCBrZXkpO1xyXG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGFuIGV2ZW50IHRvcGljIGhhc2gsIGV2ZW50IG5hbWUgb3JcclxuICAgICAqICBldmVudCBzaWduYXR1cmUpIGlzIHByZXNlbnQgaW4gdGhlIEFCSS5cclxuICAgICAqXHJcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYW4gZXZlbnQgbmFtZSwgdGhlIG5hbWUgbWF5IGJlIGFtYmlndW91cywgc29cclxuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRXZlbnRGcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGhhc0V2ZW50KGtleSkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgR2V0IHRoZSBbW0V2ZW50RnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcclxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcclxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXZlbnRzIG1hdGNoIGJ5IG5hbWUuXHJcbiAgICAgKlxyXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZXZlbnQgaW5cclxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXHJcbiAgICAgKi9cclxuICAgIGdldEV2ZW50KGtleSwgdmFsdWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEV2ZW50KGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBldmVudHMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cclxuICAgICAqL1xyXG4gICAgZm9yRWFjaEV2ZW50KGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2V2ZW50cy5rZXlzKCkpO1xyXG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNldmVudHMuZ2V0KG5hbWUpKSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgR2V0IHRoZSBbW0Vycm9yRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGFuIGVycm9yXHJcbiAgICAgKiAgc2VsZWN0b3IsIGVycm9yIG5hbWUgb3IgZXJyb3Igc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxyXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBlcnJvcnMgbWF0Y2ggYnkgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBlcnJvciBpblxyXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cclxuICAgICAqL1xyXG4gICAgZ2V0RXJyb3Ioa2V5LCB2YWx1ZXMpIHtcclxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBpZiAoQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0uc2lnbmF0dXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Vycm9ycy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcclxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXJyb3JzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3JcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBFcnJvcihzdHJpbmcpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pY1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIFBhbmljKHVpbnQyNTYpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBlcnJvciBkZXNjcmlwdGlvbiAoaS5lLiAke21hdGNoU3RyfSlgLCBcIm5hbWVcIiwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXHJcbiAgICAgICAga2V5ID0gRXJyb3JGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCk7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJFcnJvcihzdHJpbmcpXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIEVycm9yKHN0cmluZylcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXkgPT09IFwiUGFuaWModWludDI1NilcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgUGFuaWModWludDI1NilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Vycm9ycy5nZXQoa2V5KTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBlcnJvcnMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cclxuICAgICAqL1xyXG4gICAgZm9yRWFjaEVycm9yKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2Vycm9ycy5rZXlzKCkpO1xyXG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNlcnJvcnMuZ2V0KG5hbWUpKSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gR2V0IHRoZSA0LWJ5dGUgc2VsZWN0b3IgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXHJcbiAgICAvKlxyXG5nZXRTZWxlY3RvcihmcmFnbWVudDogRXJyb3JGcmFnbWVudCB8IEZ1bmN0aW9uRnJhZ21lbnQpOiBzdHJpbmcge1xyXG4gICAgaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBjb25zdCBtYXRjaGVzOiBBcnJheTxGcmFnbWVudD4gPSBbIF07XHJcblxyXG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KSk7IH0gY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICB0cnkgeyBtYXRjaGVzLnB1c2godGhpcy5nZXRFcnJvcig8c3RyaW5nPmZyYWdtZW50KSk7IH0gY2F0Y2ggKF8pIHsgfVxyXG5cclxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVua25vd24gZnJhZ21lbnRcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbWJpZ3VvdXMgZnJhZ21lbnQgbWF0Y2hlcyBmdW5jdGlvbiBhbmQgZXJyb3JcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnJhZ21lbnQgPSBtYXRjaGVzWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcclxufVxyXG4gICAgKi9cclxuICAgIC8vIEdldCB0aGUgMzItYnl0ZSB0b3BpYyBoYXNoIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcclxuICAgIC8qXHJcbiAgICBnZXRFdmVudFRvcGljKGZyYWdtZW50OiBFdmVudEZyYWdtZW50KTogc3RyaW5nIHtcclxuICAgICAgICAvL2lmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTsgfVxyXG4gICAgICAgIHJldHVybiBpZChmcmFnbWVudC5mb3JtYXQoKSk7XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgX2RlY29kZVBhcmFtcyhwYXJhbXMsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKHBhcmFtcywgZGF0YSk7XHJcbiAgICB9XHJcbiAgICBfZW5jb2RlUGFyYW1zKHBhcmFtcywgdmFsdWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmVuY29kZShwYXJhbXMsIHZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBFbmNvZGVzIGEgYGB0eC5kYXRhYGAgb2JqZWN0IGZvciBkZXBsb3lpbmcgdGhlIENvbnRyYWN0IHdpdGhcclxuICAgICAqICB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgY29uc3RydWN0b3IgYXJndW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVEZXBsb3kodmFsdWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcclxuICAgICAqICBzcGVjaWZpZWQgZXJyb3IgKHNlZSBbW2dldEVycm9yXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcclxuICAgICAqICAlJWtleSUlKS5cclxuICAgICAqXHJcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXHJcbiAgICAgKiAgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCBhIGBgQ0FMTF9FWENFUFRJT05gYCBhbmQgdGhyb3cgdGhlXHJcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cclxuICAgICAqL1xyXG4gICAgZGVjb2RlRXJyb3JSZXN1bHQoZnJhZ21lbnQsIGRhdGEpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YVNsaWNlKGRhdGEsIDAsIDQpID09PSBmcmFnbWVudC5zZWxlY3RvciwgYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGVycm9yICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgRW5jb2RlcyB0aGUgdHJhbnNhY3Rpb24gcmV2ZXJ0IGRhdGEgZm9yIGEgY2FsbCByZXN1bHQgdGhhdFxyXG4gICAgICogIHJldmVydGVkIGZyb20gdGhlIHRoZSBDb250cmFjdCB3aXRoIHRoZSBzZXBjaWZpZWQgJSVlcnJvciUlXHJcbiAgICAgKiAgKHNlZSBbW2dldEVycm9yXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3IgJSVmcmFnbWVudCUlKSB3aXRoIHRoZSAlJXZhbHVlcyUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xyXG4gICAgICogIGEgcmVzdWx0IGZyb20gYSBDb250cmFjdC5cclxuICAgICAqL1xyXG4gICAgZW5jb2RlRXJyb3JSZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29uY2F0KFtcclxuICAgICAgICAgICAgZnJhZ21lbnQuc2VsZWN0b3IsXHJcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIERlY29kZXMgdGhlICUlZGF0YSUlIGZyb20gYSB0cmFuc2FjdGlvbiBgYHR4LmRhdGFgYCBmb3JcclxuICAgICAqICB0aGUgZnVuY3Rpb24gc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXNcclxuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKS5cclxuICAgICAqXHJcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VUcmFuc2FjdGlvbl1dIG1ldGhvZFxyXG4gICAgICogIGluc3RlYWQsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGZyYWdtZW50LlxyXG4gICAgICovXHJcbiAgICBkZWNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIGRhdGEpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YVNsaWNlKGRhdGEsIDAsIDQpID09PSBmcmFnbWVudC5zZWxlY3RvciwgYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGZ1bmN0aW9uICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgRW5jb2RlcyB0aGUgYGB0eC5kYXRhYGAgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBjYWxscyB0aGUgZnVuY3Rpb25cclxuICAgICAqICBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3IgJSVmcmFnbWVudCUlKSB3aXRoXHJcbiAgICAgKiAgdGhlICUldmFsdWVzJSUuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgdmFsdWVzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb25jYXQoW1xyXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcclxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgRGVjb2RlcyB0aGUgcmVzdWx0ICUlZGF0YSUlIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXHJcbiAgICAgKiAgc3BlY2lmaWVkIGZ1bmN0aW9uIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXHJcbiAgICAgKiAgJSVrZXklJSkuXHJcbiAgICAgKlxyXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxyXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxyXG4gICAgICogIGNvcnJlc3BvbmRpbmcgZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJpbnZhbGlkIGxlbmd0aCBmb3IgcmVzdWx0IGRhdGFcIjtcclxuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzQ29weShkYXRhKTtcclxuICAgICAgICBpZiAoKGJ5dGVzLmxlbmd0aCAlIDMyKSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5vdXRwdXRzLCBieXRlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJjb3VsZCBub3QgZGVjb2RlIHJlc3VsdCBkYXRhXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2FsbCByZXR1cm5lZCBkYXRhIHdpdGggbm8gZXJyb3IsIGJ1dCB0aGUgZGF0YSBpcyBqdW5rXHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBtZXNzYWdlLCBcIkJBRF9EQVRBXCIsIHtcclxuICAgICAgICAgICAgdmFsdWU6IGhleGxpZnkoYnl0ZXMpLFxyXG4gICAgICAgICAgICBpbmZvOiB7IG1ldGhvZDogZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtYWtlRXJyb3IoX2RhdGEsIHR4KSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihcImNhbGxcIiwgdHgsIGRhdGEpO1xyXG4gICAgICAgIC8vIE5vdCBhIGJ1aWx0LWluIGVycm9yOyB0cnkgZmluZGluZyBhIGN1c3RvbSBlcnJvclxyXG4gICAgICAgIGNvbnN0IGN1c3RvbVByZWZpeCA9IFwiZXhlY3V0aW9uIHJldmVydGVkICh1bmtub3duIGN1c3RvbSBlcnJvcilcIjtcclxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKGN1c3RvbVByZWZpeCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBoZXhsaWZ5KGRhdGEuc2xpY2UoMCwgNCkpO1xyXG4gICAgICAgICAgICBjb25zdCBlZiA9IHRoaXMuZ2V0RXJyb3Ioc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoZWYpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShlZi5pbnB1dHMsIGRhdGEuc2xpY2UoNCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJldmVydCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWYubmFtZSwgc2lnbmF0dXJlOiBlZi5mb3JtYXQoKSwgYXJnc1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVhc29uID0gZXJyb3IucmV2ZXJ0LnNpZ25hdHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYGV4ZWN1dGlvbiByZXZlcnRlZDogJHtlcnJvci5yZWFzb259YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQgKGNvdWx0IG5vdCBkZWNvZGUgY3VzdG9tIGVycm9yKWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIHRoZSBpbnZvY2F0aW9uLCBpZiBhdmFpbGFibGVcclxuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlVHJhbnNhY3Rpb24odHgpO1xyXG4gICAgICAgIGlmIChwYXJzZWQpIHtcclxuICAgICAgICAgICAgZXJyb3IuaW52b2NhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogcGFyc2VkLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHBhcnNlZC5zaWduYXR1cmUsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBwYXJzZWQuYXJnc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBFbmNvZGVzIHRoZSByZXN1bHQgZGF0YSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxyXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXHJcbiAgICAgKiAgZm9yICUlZnJhZ21lbnQlJSkgd2l0aCAlJXZhbHVlcyUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xyXG4gICAgICogIGEgcmVzdWx0IGZyb20gYSBDb250cmFjdC5cclxuICAgICAqL1xyXG4gICAgZW5jb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGV4bGlmeSh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICAgIHNwZWx1bmsoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55PiwgcHJvY2Vzc2Z1bmM6ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IFByb21pc2U8YW55Pik6IFByb21pc2U8QXJyYXk8YW55Pj4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlczogQXJyYXk8UHJvbWlzZTw+PiA9IFsgXTtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2VzcyA9IGZ1bmN0aW9uKHR5cGU6IFBhcmFtVHlwZSwgdmFsdWU6IGFueSk6IGFueSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NlbmQodHlwZS5jaGlsZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuID09PSBcImFkZHJlc3NcIikge1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGRlc2NlbmQgPSBmdW5jdGlvbiAoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55Pikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHsgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG1pc21hdGNoXCIpOyB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfTtcclxuICAgIFxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PGFueT4gPSBbIF07XHJcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHZhbHVlLm1hcCgodmFsdWUpID0+IGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICovXHJcbiAgICAvLyBDcmVhdGUgdGhlIGZpbHRlciBmb3IgdGhlIGV2ZW50IHdpdGggc2VhcmNoIGNyaXRlcmlhIChlLmcuIGZvciBldGhfZmlsdGVyTG9nKVxyXG4gICAgZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCB2YWx1ZXMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA8PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBgdG9vIG1hbnkgYXJndW1lbnRzIGZvciAke2ZyYWdtZW50LmZvcm1hdCgpfWAsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7IGNvdW50OiB2YWx1ZXMubGVuZ3RoLCBleHBlY3RlZENvdW50OiBmcmFnbWVudC5pbnB1dHMubGVuZ3RoIH0pO1xyXG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xyXG4gICAgICAgIGlmICghZnJhZ21lbnQuYW5vbnltb3VzKSB7XHJcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEBUT0RPOiBVc2UgdGhlIGNvZGVycyBmb3IgdGhpczsgdG8gcHJvcGVybHkgc3VwcG9ydCB0dXBsZXMsIGV0Yy5cclxuICAgICAgICBjb25zdCBlbmNvZGVUb3BpYyA9IChwYXJhbSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGhleGxpZnkodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJib29sXCIgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFwiMHgwMVwiIDogXCIweDAwXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUubWF0Y2goL151P2ludC8pKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvQmVIZXgodmFsdWUpOyAvLyBAVE9ETzogU2hvdWxkIHRoaXMgdG9Ud29zPz9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9eYnl0ZXMvKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB6ZXJvUGFkQnl0ZXModmFsdWUsIDMyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImFkZHJlc3NcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWRkcmVzc2VzIGFyZSB2YWxpZFxyXG4gICAgICAgICAgICAgICAgdGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB6ZXJvUGFkVmFsdWUoaGV4bGlmeSh2YWx1ZSksIDMyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBmcmFnbWVudC5pbnB1dHNbaW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoIXBhcmFtLmluZGV4ZWQpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID09IG51bGwsIFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHZhbHVlLm1hcCgodmFsdWUpID0+IGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gVHJpbSBvZmYgdHJhaWxpbmcgbnVsbHNcclxuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRvcGljcy5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvcGljcztcclxuICAgIH1cclxuICAgIGVuY29kZUV2ZW50TG9nKGZyYWdtZW50LCB2YWx1ZXMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcclxuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBkYXRhVmFsdWVzID0gW107XHJcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcclxuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWVzLmxlbmd0aCA9PT0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgXCJldmVudCBhcmd1bWVudHMvdmFsdWVzIG1pc21hdGNoXCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XHJcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGlkKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChrZWNjYWsyNTYodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtwYXJhbS50eXBlXSwgW3ZhbHVlXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgZGF0YVZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuI2FiaUNvZGVyLmVuY29kZShkYXRhVHlwZXMsIGRhdGFWYWx1ZXMpLFxyXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxyXG4gICAgZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGRhdGEsIHRvcGljcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b3BpY3MgIT0gbnVsbCAmJiAhZnJhZ21lbnQuYW5vbnltb3VzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VG9waWMgPSBmcmFnbWVudC50b3BpY0hhc2g7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHRvcGljc1swXSwgMzIpICYmIHRvcGljc1swXS50b0xvd2VyQ2FzZSgpID09PSBldmVudFRvcGljLCBcImZyYWdtZW50L3RvcGljIG1pc21hdGNoXCIsIFwidG9waWNzWzBdXCIsIHRvcGljc1swXSk7XHJcbiAgICAgICAgICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5kZXhlZCA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG5vbkluZGV4ZWQgPSBbXTtcclxuICAgICAgICBjb25zdCBkeW5hbWljID0gW107XHJcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgcGFyYW0udHlwZSA9PT0gXCJieXRlc1wiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChQYXJhbVR5cGUuZnJvbSh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2godHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2gocGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdEluZGV4ZWQgPSAodG9waWNzICE9IG51bGwpID8gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGluZGV4ZWQsIGNvbmNhdCh0b3BpY3MpKSA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0Tm9uSW5kZXhlZCA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShub25JbmRleGVkLCBkYXRhLCB0cnVlKTtcclxuICAgICAgICAvL2NvbnN0IHJlc3VsdDogKEFycmF5PGFueT4gJiB7IFsga2V5OiBzdHJpbmcgXTogYW55IH0pID0gWyBdO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcclxuICAgICAgICBsZXQgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcclxuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0SW5kZXhlZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgSW5kZXhlZChudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgSW5kZXhlZChyZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAga2V5cy5wdXNoKHBhcmFtLm5hbWUgfHwgbnVsbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFBhcnNlcyBhIHRyYW5zYWN0aW9uLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBhbmQgZXh0cmFjdHNcclxuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBmdW5jdGlvbiBkZXRhaWxzLlxyXG4gICAgICpcclxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gY2Fubm90IGJlIGZvdW5kLCByZXR1cm4gbnVsbC5cclxuICAgICAqL1xyXG4gICAgcGFyc2VUcmFuc2FjdGlvbih0eCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyh0eC5kYXRhLCBcInR4LmRhdGFcIik7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoKHR4LnZhbHVlICE9IG51bGwpID8gdHgudmFsdWUgOiAwLCBcInR4LnZhbHVlXCIpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihoZXhsaWZ5KGRhdGEuc2xpY2UoMCwgNCkpKTtcclxuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YS5zbGljZSg0KSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC5zZWxlY3RvciwgYXJncywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcGFyc2VDYWxsUmVzdWx0KGRhdGEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFBhcnNlcyBhIHJlY2VpcHQgbG9nLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBldmVudCBhbmQgZXh0cmFjdHNcclxuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBldmVudCBkZXRhaWxzLlxyXG4gICAgICpcclxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZXZlbnQgY2Fubm90IGJlIGZvdW5kLCByZXR1cm5zIG51bGwuXHJcbiAgICAgKi9cclxuICAgIHBhcnNlTG9nKGxvZykge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcclxuICAgICAgICBpZiAoIWZyYWdtZW50IHx8IGZyYWdtZW50LmFub255bW91cykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQFRPRE86IElmIGFub255bW91cywgYW5kIHRoZSBvbmx5IG1ldGhvZCwgYW5kIHRoZSBpbnB1dCBjb3VudCBtYXRjaGVzLCBzaG91bGQgd2UgcGFyc2U/XHJcbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXHJcbiAgICAgICAgLy8gICAgICAgIG5vdCBtZWFuIHdlIGhhdmUgdGhlIGZ1bGwgQUJJOyBtYXliZSBqdXN0IGEgZnJhZ21lbnQ/XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dEZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQudG9waWNIYXNoLCB0aGlzLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUGFyc2VzIGEgcmV2ZXJ0IGRhdGEsIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGVycm9yIGFuZCBleHRyYWN0c1xyXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGVycm9yIGRldGFpbHMuXHJcbiAgICAgKlxyXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBlcnJvciBjYW5ub3QgYmUgZm91bmQsIHJldHVybnMgbnVsbC5cclxuICAgICAqL1xyXG4gICAgcGFyc2VFcnJvcihkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgaGV4RGF0YSA9IGhleGxpZnkoZGF0YSk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGRhdGFTbGljZShoZXhEYXRhLCAwLCA0KSk7XHJcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShoZXhEYXRhLCA0KSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckRlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC5zZWxlY3RvciwgYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbSW50ZXJmYWNlXV0gZnJvbSB0aGUgQUJJICUldmFsdWUlJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhlICUldmFsdWUlJSBtYXkgYmUgcHJvdmlkZWQgYXMgYW4gZXhpc3RpbmcgW1tJbnRlcmZhY2VdXSBvYmplY3QsXHJcbiAgICAgKiAgYSBKU09OLWVuY29kZWQgQUJJIG9yIGFueSBIdW1hbi1SZWFkYWJsZSBBQkkgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xyXG4gICAgICAgIC8vIEFscmVhZHkgYW4gSW50ZXJmYWNlLCB3aGljaCBpcyBpbW11dGFibGVcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcmZhY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBKU09OXHJcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKEpTT04ucGFyc2UodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQW4gSW50ZXJmYWNlOyBwb3NzaWJseSBmcm9tIGFub3RoZXIgdjYgaW5zdGFuY2VcclxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZS5mb3JtYXRKc29uKSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdEpzb24oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEEgbGVnYWN5IEludGVyZmFjZTsgZnJvbSBhbiBvbGRlciB2ZXJzaW9uXHJcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUuZm9ybWF0KSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdChcImpzb25cIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBcnJheSBvZiBmcmFnbWVudHNcclxuICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsIi8vaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgaXNCeXRlc0xpa2UsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0Vycm9yLCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xyXG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiB0b0pzb24odmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcclxufVxyXG4vLyBAVE9ETz8gPFQgZXh0ZW5kcyBGZWVEYXRhID0geyB9PiBpbXBsZW1lbnRzIFJlcXVpcmVkPFQ+XHJcbi8qKlxyXG4gKiAgQSAqKkZlZURhdGEqKiB3cmFwcyBhbGwgdGhlIGZlZS1yZWxhdGVkIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGhcclxuICogIHRoZSBuZXR3b3JrLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZlZURhdGEge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBmb3IgbGVnYWN5IG5ldHdvcmtzLlxyXG4gICAgICovXHJcbiAgICBnYXNQcmljZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXhpbXVtIGZlZSB0byBwYXkgcGVyIGdhcy5cclxuICAgICAqXHJcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgaXMgZGVmaW5lZCBieSB0aGUgbmV0d29yayBhbmQgYmFzZWQgb25cclxuICAgICAqICBjb25nZXN0aW9uLCBpbmNyZWFzaW5nIHRoZSBjb3N0IGR1cmluZyB0aW1lcyBvZiBoZWF2eSBsb2FkXHJcbiAgICAgKiAgYW5kIGxvd2VyaW5nIHdoZW4gbGVzcyBidXN5LlxyXG4gICAgICpcclxuICAgICAqICBUaGUgYWN0dWFsIGZlZSBwZXIgZ2FzIHdpbGwgYmUgdGhlIGJhc2UgZmVlIGZvciB0aGUgYmxvY2tcclxuICAgICAqICBhbmQgdGhlIHByaW9yaXR5IGZlZSwgdXAgdG8gdGhlIG1heCBmZWUgcGVyIGdhcy5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcclxuICAgICAqL1xyXG4gICAgbWF4RmVlUGVyR2FzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGFkZGl0aW9uYWwgYW1vdXQgdG8gcGF5IHBlciBnYXMgdG8gZW5jb3VyYWdlIGEgdmFsaWRhdG9yXHJcbiAgICAgKiAgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgdG8gY29tcGVuc2F0ZSB0aGUgdmFsaWRhdG9yIGZvciB0aGVcclxuICAgICAqICBhZGp1c3RlZCByaXNrIGZvciBpbmNsdWRpbmcgYSBnaXZlbiB0cmFuc2FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcclxuICAgICAqL1xyXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IEZlZURhdGEgZm9yICUlZ2FzUHJpY2UlJSwgJSVtYXhGZWVQZXJHYXMlJSBhbmRcclxuICAgICAqICAlJW1heFByaW9yaXR5RmVlUGVyR2FzJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XHJcbiAgICAgICAgICAgIGdhc1ByaWNlOiBnZXRWYWx1ZShnYXNQcmljZSksXHJcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2V0VmFsdWUobWF4RmVlUGVyR2FzKSxcclxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGdldFZhbHVlKG1heFByaW9yaXR5RmVlUGVyR2FzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tZnJpZW5kbHkgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCB7IGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzIH0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIF90eXBlOiBcIkZlZURhdGFcIixcclxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbihnYXNQcmljZSksXHJcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKG1heEZlZVBlckdhcyksXHJcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24obWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuO1xyXG4vKipcclxuICogIFJldHVybnMgYSBjb3B5IG9mICUlcmVxJSUgd2l0aCBhbGwgcHJvcGVydGllcyBjb2VyY2VkIHRvIHRoZWlyIHN0cmljdFxyXG4gKiAgdHlwZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weVJlcXVlc3QocmVxKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgIC8vIFRoZXNlIGNvdWxkIGJlIGFkZHJlc3NlcywgRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlc1xyXG4gICAgaWYgKHJlcS50bykge1xyXG4gICAgICAgIHJlc3VsdC50byA9IHJlcS50bztcclxuICAgIH1cclxuICAgIGlmIChyZXEuZnJvbSkge1xyXG4gICAgICAgIHJlc3VsdC5mcm9tID0gcmVxLmZyb207XHJcbiAgICB9XHJcbiAgICBpZiAocmVxLmRhdGEpIHtcclxuICAgICAgICByZXN1bHQuZGF0YSA9IGhleGxpZnkocmVxLmRhdGEpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYmlnSW50S2V5cyA9IFwiY2hhaW5JZCxnYXNMaW1pdCxnYXNQcmljZSxtYXhGZWVQZXJCbG9iR2FzLG1heEZlZVBlckdhcyxtYXhQcmlvcml0eUZlZVBlckdhcyx2YWx1ZVwiLnNwbGl0KC8sLyk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBiaWdJbnRLZXlzKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXRCaWdJbnQocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbnVtYmVyS2V5cyA9IFwidHlwZSxub25jZVwiLnNwbGl0KC8sLyk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBudW1iZXJLZXlzKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXROdW1iZXIocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlcS5hY2Nlc3NMaXN0KSB7XHJcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHJlcS5hY2Nlc3NMaXN0KTtcclxuICAgIH1cclxuICAgIGlmIChyZXEuYXV0aG9yaXphdGlvbkxpc3QpIHtcclxuICAgICAgICByZXN1bHQuYXV0aG9yaXphdGlvbkxpc3QgPSByZXEuYXV0aG9yaXphdGlvbkxpc3Quc2xpY2UoKTtcclxuICAgIH1cclxuICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XHJcbiAgICAgICAgcmVzdWx0LmJsb2NrVGFnID0gcmVxLmJsb2NrVGFnO1xyXG4gICAgfVxyXG4gICAgaWYgKFwiZW5hYmxlQ2NpcFJlYWRcIiBpbiByZXEpIHtcclxuICAgICAgICByZXN1bHQuZW5hYmxlQ2NpcFJlYWQgPSAhIXJlcS5lbmFibGVDY2lwUmVhZDtcclxuICAgIH1cclxuICAgIGlmIChcImN1c3RvbURhdGFcIiBpbiByZXEpIHtcclxuICAgICAgICByZXN1bHQuY3VzdG9tRGF0YSA9IHJlcS5jdXN0b21EYXRhO1xyXG4gICAgfVxyXG4gICAgaWYgKFwiYmxvYlZlcnNpb25lZEhhc2hlc1wiIGluIHJlcSAmJiByZXEuYmxvYlZlcnNpb25lZEhhc2hlcykge1xyXG4gICAgICAgIHJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaGVzID0gcmVxLmJsb2JWZXJzaW9uZWRIYXNoZXMuc2xpY2UoKTtcclxuICAgIH1cclxuICAgIGlmIChcImt6Z1wiIGluIHJlcSkge1xyXG4gICAgICAgIHJlc3VsdC5remcgPSByZXEua3pnO1xyXG4gICAgfVxyXG4gICAgaWYgKFwiYmxvYnNcIiBpbiByZXEgJiYgcmVxLmJsb2JzKSB7XHJcbiAgICAgICAgcmVzdWx0LmJsb2JzID0gcmVxLmJsb2JzLm1hcCgoYikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNCeXRlc0xpa2UoYikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBiKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqICBBICoqQmxvY2sqKiByZXByZXNlbnRzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIGZ1bGwgYmxvY2sgb25cclxuICogIEV0aGVyZXVtLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJsb2NrIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGJsb2NrIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXHJcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICovXHJcbiAgICBwcm92aWRlcjtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBibG9jayBudW1iZXIsIHNvbWV0aW1lcyBjYWxsZWQgdGhlIGJsb2NrIGhlaWdodC4gVGhpcyBpcyBhXHJcbiAgICAgKiAgc2VxdWVudGlhbCBudW1iZXIgdGhhdCBpcyBvbmUgaGlnaGVyIHRoYW4gdGhlIHBhcmVudCBibG9jay5cclxuICAgICAqL1xyXG4gICAgbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2guXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaGFzaCBpbmNsdWRlcyBhbGwgcHJvcGVydGllcywgc28gY2FuIGJlIHNhZmVseSB1c2VkIHRvIGlkZW50aWZ5XHJcbiAgICAgKiAgYW4gZXhhY3Qgc2V0IG9mIGJsb2NrIHByb3BlcnRpZXMuXHJcbiAgICAgKi9cclxuICAgIGhhc2g7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdGltZXN0YW1wIGZvciB0aGlzIGJsb2NrLCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcclxuICAgICAqICBlcG9jaCB0aGF0IHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkLlxyXG4gICAgICovXHJcbiAgICB0aW1lc3RhbXA7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgcGFyZW50IGJsb2NrLlxyXG4gICAgICovXHJcbiAgICBwYXJlbnRIYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGhhc2ggdHJlZSByb290IG9mIHRoZSBwYXJlbnQgYmVhY29uIGJsb2NrIGZvciB0aGUgZ2l2ZW5cclxuICAgICAqICBleGVjdXRpb24gYmxvY2suIFNlZSBbW2xpbmstZWlwLTQ3ODhdXS5cclxuICAgICAqL1xyXG4gICAgcGFyZW50QmVhY29uQmxvY2tSb290O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5vbmNlLlxyXG4gICAgICpcclxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHJhbmRvbSBudW1iZXIgaW5zZXJ0ZWQgd2hpY2hcclxuICAgICAqICBwZXJtaXR0ZWQgdGhlIGRpZmZpY3VsdHkgdGFyZ2V0IHRvIGJlIHJlYWNoZWQuXHJcbiAgICAgKi9cclxuICAgIG5vbmNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGRpZmZpY3VsdHkgdGFyZ2V0LlxyXG4gICAgICpcclxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHByb29mLW9mLXdvcmsgdGFyZ2V0IHJlcXVpcmVkXHJcbiAgICAgKiAgZm9yIGEgYmxvY2sgdG8gbWVldCB0aGUgcHJvdG9jb2wgcnVsZXMgdG8gYmUgaW5jbHVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogIE9uIG1vZGVybiBuZXR3b3JrcywgdGhpcyBpcyBhIHJhbmRvbSBudW1iZXIgYXJyaXZlZCBhdCB1c2luZ1xyXG4gICAgICogIHJhbmRhby4gIEBUT0RPOiBGaW5kIGxpbmtzP1xyXG4gICAgICovXHJcbiAgICBkaWZmaWN1bHR5O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyBsaW1pdCBmb3IgdGhpcyBibG9jay5cclxuICAgICAqL1xyXG4gICAgZ2FzTGltaXQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdG90YWwgZ2FzIHVzZWQgaW4gdGhpcyBibG9jay5cclxuICAgICAqL1xyXG4gICAgZ2FzVXNlZDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSByb290IGhhc2ggZm9yIHRoZSBnbG9iYWwgc3RhdGUgYWZ0ZXIgYXBwbHlpbmcgY2hhbmdlc1xyXG4gICAgICogIGluIHRoaXMgYmxvY2suXHJcbiAgICAgKi9cclxuICAgIHN0YXRlUm9vdDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0cyB0cmllLlxyXG4gICAgICovXHJcbiAgICByZWNlaXB0c1Jvb3Q7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdG90YWwgYW1vdW50IG9mIGJsb2IgZ2FzIGNvbnN1bWVkIGJ5IHRoZSB0cmFuc2FjdGlvbnNcclxuICAgICAqICB3aXRoaW4gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXHJcbiAgICAgKi9cclxuICAgIGJsb2JHYXNVc2VkO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHJ1bm5pbmcgdG90YWwgb2YgYmxvYiBnYXMgY29uc3VtZWQgaW4gZXhjZXNzIG9mIHRoZVxyXG4gICAgICogIHRhcmdldCwgcHJpb3IgdG8gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXHJcbiAgICAgKi9cclxuICAgIGV4Y2Vzc0Jsb2JHYXM7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWluZXIgY29pbmJhc2UgYWRkcmVzcywgd2loY2ggcmVjZWl2ZXMgYW55IHN1YnNpZGllcyBmb3JcclxuICAgICAqICBpbmNsdWRpbmcgdGhpcyBibG9jay5cclxuICAgICAqL1xyXG4gICAgbWluZXI7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbGF0ZXN0IFJBTkRBTyBtaXggb2YgdGhlIHBvc3QgYmVhY29uIHN0YXRlIG9mXHJcbiAgICAgKiAgdGhlIHByZXZpb3VzIGJsb2NrLlxyXG4gICAgICovXHJcbiAgICBwcmV2UmFuZGFvO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQW55IGV4dHJhIGRhdGEgdGhlIHZhbGlkYXRvciB3aXNoZWQgdG8gaW5jbHVkZS5cclxuICAgICAqL1xyXG4gICAgZXh0cmFEYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgdGhhdCBhbGwgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2sgd2VyZVxyXG4gICAgICogIGNoYXJnZWQuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgYWRqdXN0cyBhZnRlciBlYWNoIGJsb2NrLCBkZXBlbmRpbmcgb24gaG93IGNvbmdlc3RlZCB0aGUgbmV0d29ya1xyXG4gICAgICogIGlzLlxyXG4gICAgICovXHJcbiAgICBiYXNlRmVlUGVyR2FzO1xyXG4gICAgI3RyYW5zYWN0aW9ucztcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkJsb2NrKiogb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIG5lY2Vzc2FyeSBhcyB0aGUgdW5sZXNzIGltcGxlbWVudGluZyBhXHJcbiAgICAgKiAgbG93LWxldmVsIGxpYnJhcnkuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJsb2NrLCBwcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuI3RyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBwcm92aWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICBwcm92aWRlcixcclxuICAgICAgICAgICAgaGFzaDogZ2V0VmFsdWUoYmxvY2suaGFzaCksXHJcbiAgICAgICAgICAgIG51bWJlcjogYmxvY2subnVtYmVyLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGJsb2NrLnRpbWVzdGFtcCxcclxuICAgICAgICAgICAgcGFyZW50SGFzaDogYmxvY2sucGFyZW50SGFzaCxcclxuICAgICAgICAgICAgcGFyZW50QmVhY29uQmxvY2tSb290OiBibG9jay5wYXJlbnRCZWFjb25CbG9ja1Jvb3QsXHJcbiAgICAgICAgICAgIG5vbmNlOiBibG9jay5ub25jZSxcclxuICAgICAgICAgICAgZGlmZmljdWx0eTogYmxvY2suZGlmZmljdWx0eSxcclxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJsb2NrLmdhc0xpbWl0LFxyXG4gICAgICAgICAgICBnYXNVc2VkOiBibG9jay5nYXNVc2VkLFxyXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogYmxvY2suYmxvYkdhc1VzZWQsXHJcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IGJsb2NrLmV4Y2Vzc0Jsb2JHYXMsXHJcbiAgICAgICAgICAgIG1pbmVyOiBibG9jay5taW5lcixcclxuICAgICAgICAgICAgcHJldlJhbmRhbzogZ2V0VmFsdWUoYmxvY2sucHJldlJhbmRhbyksXHJcbiAgICAgICAgICAgIGV4dHJhRGF0YTogYmxvY2suZXh0cmFEYXRhLFxyXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBnZXRWYWx1ZShibG9jay5iYXNlRmVlUGVyR2FzKSxcclxuICAgICAgICAgICAgc3RhdGVSb290OiBibG9jay5zdGF0ZVJvb3QsXHJcbiAgICAgICAgICAgIHJlY2VpcHRzUm9vdDogYmxvY2sucmVjZWlwdHNSb290LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbiBoYXNoZXMsIGluIHRoZSBvcmRlclxyXG4gICAgICogIHRoZXkgd2VyZSBleGVjdXRlZCB3aXRoaW4gdGhlIGJsb2NrLlxyXG4gICAgICovXHJcbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiN0cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHguaGFzaDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIGNvbXBsZXRlIHRyYW5zYWN0aW9ucywgaW4gdGhlIG9yZGVyIHRoZXlcclxuICAgICAqICB3ZXJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgYmxvY2suXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGJsb2NrcyB3aGljaCBwcmVmZXRjaGVkXHJcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCBieSBwYXNzaW5nIGBgdHJ1ZWBgIHRvICUlcHJlZmV0Y2hUeHMlJVxyXG4gICAgICogIGludG8gW1tQcm92aWRlci1nZXRCbG9ja11dLlxyXG4gICAgICovXHJcbiAgICBnZXQgcHJlZmV0Y2hlZFRyYW5zYWN0aW9ucygpIHtcclxuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLiN0cmFuc2FjdGlvbnMuc2xpY2UoKTtcclxuICAgICAgICAvLyBEb2Vzbid0IG1hdHRlci4uLlxyXG4gICAgICAgIGlmICh0eHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHByZWZldGNoZWQgdGhlIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHR4c1swXSkgPT09IFwib2JqZWN0XCIsIFwidHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQgd2l0aCBibG9jayByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRyYW5zYWN0aW9uUmVzcG9uc2VzKClcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0eHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IHsgYmFzZUZlZVBlckdhcywgZGlmZmljdWx0eSwgZXh0cmFEYXRhLCBnYXNMaW1pdCwgZ2FzVXNlZCwgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsIHRpbWVzdGFtcCwgdHJhbnNhY3Rpb25zIH0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIF90eXBlOiBcIkJsb2NrXCIsXHJcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IHRvSnNvbihiYXNlRmVlUGVyR2FzKSxcclxuICAgICAgICAgICAgZGlmZmljdWx0eTogdG9Kc29uKGRpZmZpY3VsdHkpLFxyXG4gICAgICAgICAgICBleHRyYURhdGEsXHJcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24oZ2FzTGltaXQpLFxyXG4gICAgICAgICAgICBnYXNVc2VkOiB0b0pzb24oZ2FzVXNlZCksXHJcbiAgICAgICAgICAgIGJsb2JHYXNVc2VkOiB0b0pzb24odGhpcy5ibG9iR2FzVXNlZCksXHJcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IHRvSnNvbih0aGlzLmV4Y2Vzc0Jsb2JHYXMpLFxyXG4gICAgICAgICAgICBoYXNoLCBtaW5lciwgcHJldlJhbmRhbywgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLFxyXG4gICAgICAgICAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3QsIHN0YXRlUm9vdCwgcmVjZWlwdHNSb290LFxyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy50cmFuc2FjdGlvbnM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHhzW2luZGV4KytdLCBkb25lOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jay5cclxuICAgICAqL1xyXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5sZW5ndGg7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBbW2xpbmstanMtZGF0ZV1dIHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkIGF0LlxyXG4gICAgICovXHJcbiAgICBnZXQgZGF0ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lc3RhbXAgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudGltZXN0YW1wICogMTAwMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBHZXQgdGhlIHRyYW5zYWN0aW9uIGF0ICUlaW5kZXhlJSUgd2l0aGluIHRoaXMgYmxvY2suXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgaW50ZXJuYWwgdmFsdWUgYnkgaXRzIGluZGV4IG9yIGhhc2hcclxuICAgICAgICBsZXQgdHggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHR4ID0gdGhpcy4jdHJhbnNhY3Rpb25zW2luZGV4T3JIYXNoXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy4jdHJhbnNhY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSBoYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodi5oYXNoICE9PSBoYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCB0eFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIElmIGEgKipCbG9jayoqIHdhcyBmZXRjaGVkIHdpdGggYSByZXF1ZXN0IHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uc1xyXG4gICAgICogIHRoaXMgd2lsbCBhbGxvdyBzeW5jaHJvbm91cyBhY2Nlc3MgdG8gdGhvc2UgdHJhbnNhY3Rpb25zLlxyXG4gICAgICpcclxuICAgICAqICBJZiB0aGUgdHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQsIHRoaXMgd2lsbCB0aHJvdy5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJlZmV0Y2hlZFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XHJcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy5wcmVmZXRjaGVkVHJhbnNhY3Rpb25zO1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGluZGV4T3JIYXNoKSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHhzW2luZGV4T3JIYXNoXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5kZXhPckhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgdHggb2YgdHhzKSB7XHJcbiAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSBpbmRleE9ySGFzaCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcIm5vIG1hdGNoaW5nIHRyYW5zYWN0aW9uXCIsIFwiaW5kZXhPckhhc2hcIiwgaW5kZXhPckhhc2gpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgYmVlbiBtaW5lZC4gVGhpcyBwcm92aWRlcyBhIHR5cGUgZ3VhcmRcclxuICAgICAqICBmb3IgYWxsIHByb3BlcnRpZXMgb24gYSBbW01pbmVkQmxvY2tdXS5cclxuICAgICAqL1xyXG4gICAgaXNNaW5lZCgpIHsgcmV0dXJuICEhdGhpcy5oYXNoOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBpcyBhbiBbW2xpbmstZWlwLTI5MzBdXSBibG9jay5cclxuICAgICAqL1xyXG4gICAgaXNMb25kb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5iYXNlRmVlUGVyR2FzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIG9ycGhhbmVkRXZlbnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzTWluZWQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gTG9nXHJcbi8qKlxyXG4gKiAgQSAqKkxvZyoqIGluIEV0aGVyZXVtIHJlcHJlc2VudHMgYW4gZXZlbnQgdGhhdCBoYXMgYmVlbiBpbmNsdWRlZCBpbiBhXHJcbiAqICB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYGBMT0cqYGAgb3Bjb2Rlcywgd2hpY2ggYXJlIG1vc3QgY29tbW9ubHkgdXNlZCBieVxyXG4gKiAgU29saWRpdHkncyBlbWl0IGZvciBhbm5vdW5jaW5nIGV2ZW50cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBMb2cge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXHJcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICovXHJcbiAgICBwcm92aWRlcjtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxyXG4gICAgICogIFtbTG9nLWdldFRyYW5zYWN0aW9uXV0gdG8gZ2V0IHRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cclxuICAgICAqL1xyXG4gICAgdHJhbnNhY3Rpb25IYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXHJcbiAgICAgKiAgW1tMb2ctZ2V0QmxvY2tdXSB0byBnZXQgdGhlIFtbQmxvY2tdXS5cclxuICAgICAqL1xyXG4gICAgYmxvY2tIYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIEl0IGlzIHByZWZlcnJlZFxyXG4gICAgICogIHRvIHVzZSB0aGUgW1tCbG9jay1oYXNoXV0gd2hlbiBmZXRjaGluZyB0aGUgcmVsYXRlZCBbW0Jsb2NrXV0sXHJcbiAgICAgKiAgc2luY2UgaW4gdGhlIGNhc2Ugb2YgYW4gb3JwaGFuZWQgYmxvY2ssIHRoZSBibG9jayBhdCB0aGF0IGhlaWdodCBtYXlcclxuICAgICAqICBoYXZlIGNoYW5nZWQuXHJcbiAgICAgKi9cclxuICAgIGJsb2NrTnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgSWYgdGhlICoqTG9nKiogcmVwcmVzZW50cyBhIGJsb2NrIHRoYXQgd2FzIHJlbW92ZWQgZHVlIHRvIGFuIG9ycGhhbmVkXHJcbiAgICAgKiAgYmxvY2ssIHRoaXMgd2lsbCBiZSB0cnVlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGNhbiBvbmx5IGhhcHBlbiB3aXRoaW4gYW4gb3JwaGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVkO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHRoYXQgZW1pdHRlZCB0aGlzIGxvZy5cclxuICAgICAqL1xyXG4gICAgYWRkcmVzcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXHJcbiAgICAgKi9cclxuICAgIGRhdGE7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgaW5kZXhlZCB0b3BpY3MgaW5jbHVkZWQgaW4gdGhpcyBsb2cgd2hlbiBpdCB3YXMgZW1pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiAgQWxsIHRvcGljcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGJsb29tIGZpbHRlcnMsIHNvIHRoZXkgY2FuIGJlXHJcbiAgICAgKiAgZWZmaWNpZW50bHkgZmlsdGVyZWQgdXNpbmcgdGhlIFtbUHJvdmlkZXItZ2V0TG9nc11dIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgdG9waWNzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgYXQuIFRoaXMgaXMgZ2VuZXJhbGx5XHJcbiAgICAgKiAgbm90IHVzZWZ1bCB0byBkZXZlbG9wZXJzLCBidXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgdmFyaW91cyByb290c1xyXG4gICAgICogIHRvIHByb29mIGluY2x1c2lvbiB3aXRoaW4gYSBibG9jay5cclxuICAgICAqL1xyXG4gICAgaW5kZXg7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBvZiB0aGlzIGxvZy5cclxuICAgICAqL1xyXG4gICAgdHJhbnNhY3Rpb25JbmRleDtcclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2csIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgICAgIGNvbnN0IHRvcGljcyA9IE9iamVjdC5mcmVlemUobG9nLnRvcGljcy5zbGljZSgpKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxyXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXHJcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXHJcbiAgICAgICAgICAgIHJlbW92ZWQ6IGxvZy5yZW1vdmVkLFxyXG4gICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcclxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXHJcbiAgICAgICAgICAgIHRvcGljcyxcclxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleCxcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbG9nLnRyYW5zYWN0aW9uSW5kZXgsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IHsgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsIHJlbW92ZWQsIHRvcGljcywgdHJhbnNhY3Rpb25IYXNoLCB0cmFuc2FjdGlvbkluZGV4IH0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIF90eXBlOiBcImxvZ1wiLFxyXG4gICAgICAgICAgICBhZGRyZXNzLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBkYXRhLCBpbmRleCxcclxuICAgICAgICAgICAgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXhcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgYmxvY2sgdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XHJcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcclxuICAgICAgICBhc3NlcnQoISFibG9jaywgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xyXG4gICAgICAgIHJldHVybiBibG9jaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XHJcbiAgICAgICAgYXNzZXJ0KCEhdHgsIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb25cIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcclxuICAgICAgICByZXR1cm4gdHg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvdCB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzXHJcbiAgICAgKiAgbG9nIG9jY3VycmVkIGluLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XHJcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMudHJhbnNhY3Rpb25IYXNoKTtcclxuICAgICAgICBhc3NlcnQoISFyZWNlaXB0LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uIHJlY2VpcHRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcclxuICAgICAgICByZXR1cm4gcmVjZWlwdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICByZW1vdmVkRXZlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIodGhpcyk7XHJcbiAgICB9XHJcbn1cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBUcmFuc2FjdGlvbiBSZWNlaXB0XHJcbi8qXHJcbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWN5VHJhbnNhY3Rpb25SZWNlaXB0IHtcclxuICAgIGJ5emFudGl1bTogZmFsc2U7XHJcbiAgICBzdGF0dXM6IG51bGw7XHJcbiAgICByb290OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQnl6YW50aXVtVHJhbnNhY3Rpb25SZWNlaXB0IHtcclxuICAgIGJ5emFudGl1bTogdHJ1ZTtcclxuICAgIHN0YXR1czogbnVtYmVyO1xyXG4gICAgcm9vdDogbnVsbDtcclxufVxyXG4qL1xyXG4vKipcclxuICogIEEgKipUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IGFcclxuICogIHRyYW5zYWN0aW9uIHRoYXQgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgaXQgaGFzIGJlZW4gbWluZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZWNlaXB0IHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xyXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cclxuICAgICAqL1xyXG4gICAgcHJvdmlkZXI7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYWRkcmVzcyB0aGUgdHJhbnNhY3Rpb24gd2FzIHNlbnQgdG8uXHJcbiAgICAgKi9cclxuICAgIHRvO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHNlbmRlciBvZiB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZyb207XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBkaXJlY3RseVxyXG4gICAgICogIHJlc3BvbnNpYmxlIGZvciBkZXBsb3lpbmcgb25lLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIG5vbi1udWxsICoqb25seSoqIGlmIHRoZSBgYHRvYGAgaXMgZW1wdHkgYW5kIHRoZSBgYGRhdGFgYFxyXG4gICAgICogIHdhcyBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQgYXMgaW5pdGNvZGUuXHJcbiAgICAgKi9cclxuICAgIGNvbnRyYWN0QWRkcmVzcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxyXG4gICAgICovXHJcbiAgICBoYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGluZGV4IG9mIHRoaXMgdHJhbnNhY3Rpb24gd2l0aGluIHRoZSBibG9jayB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGluZGV4O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIFtbQmxvY2tdXSB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cclxuICAgICAqL1xyXG4gICAgYmxvY2tIYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxyXG4gICAgICovXHJcbiAgICBibG9ja051bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBibG9vbSBmaWx0ZXIgYnl0ZXMgdGhhdCByZXByZXNlbnQgYWxsIGxvZ3MgdGhhdCBvY2N1cnJlZCB3aXRoaW5cclxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLiBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIGZvciBtb3N0IGRldmVsb3BlcnMsXHJcbiAgICAgKiAgYnV0IGNhbiBiZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBpbmNsdWRlZCBsb2dzLlxyXG4gICAgICovXHJcbiAgICBsb2dzQmxvb207XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYWN0dWFsIGFtb3VudCBvZiBnYXMgdXNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqICBXaGVuIGNyZWF0aW5nIGEgdHJhbnNhY3Rpb24sIHRoZSBhbW91bnQgb2YgZ2FzIHRoYXQgd2lsbCBiZSB1c2VkIGNhblxyXG4gICAgICogIG9ubHkgYmUgYXBwcm94aW1hdGVkLCBidXQgdGhlIHNlbmRlciBtdXN0IHBheSB0aGUgZ2FzIGZlZSBmb3IgdGhlXHJcbiAgICAgKiAgZW50aXJlIGdhcyBsaW1pdC4gQWZ0ZXIgdGhlIHRyYW5zYWN0aW9uLCB0aGUgZGlmZmVyZW5jZSBpcyByZWZ1bmRlZC5cclxuICAgICAqL1xyXG4gICAgZ2FzVXNlZDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBnYXMgdXNlZCBmb3IgQkxPYnMuIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cclxuICAgICAqL1xyXG4gICAgYmxvYkdhc1VzZWQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IGFsbCB0cmFuc2FjdGlvbnMgd2l0aGluIHRoZSBibG9jayBmb3IgdGhpc1xyXG4gICAgICogIGFuZCBhbGwgdHJhbnNhY3Rpb25zIHdpdGggYSBsb3dlciBgYGluZGV4YGAuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIGRldmVsb3BlcnMgYnV0IGNhbiBiZSB1c2VkIHRvXHJcbiAgICAgKiAgdmFsaWRhdGUgY2VydGFpbiBhc3BlY3RzIG9mIGV4ZWN1dGlvbi5cclxuICAgICAqL1xyXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYWN0dWFsIGdhcyBwcmljZSB1c2VkIGR1cmluZyBleGVjdXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogIER1ZSB0byB0aGUgY29tcGxleGl0eSBvZiBbW2xpbmstZWlwLTE1NTldXSB0aGlzIHZhbHVlIGNhbiBvbmx5XHJcbiAgICAgKiAgYmUgY2FsdWNsYXRlZCBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQsIHNuY2UgdGhlIGJhc2VcclxuICAgICAqICBmZWUgaXMgcHJvdG9jb2wtZW5mb3JjZWQuXHJcbiAgICAgKi9cclxuICAgIGdhc1ByaWNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHByaWNlIHBhaWQgcGVyIEJMT0IgaW4gZ2FzLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXHJcbiAgICAgKi9cclxuICAgIGJsb2JHYXNQcmljZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiB0eXBlLlxyXG4gICAgICovXHJcbiAgICB0eXBlO1xyXG4gICAgLy9yZWFkb25seSBieXphbnRpdW0hOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHN0YXR1cyBvZiB0aGlzIHRyYW5zYWN0aW9uLCBpbmRpY2F0aW5nIHN1Y2Nlc3MgKGkuZS4gYGAxYGApIG9yXHJcbiAgICAgKiAgYSByZXZlcnQgKGkuZS4gYGAwYGApLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGF2YWlsYWJsZSBpbiBwb3N0LWJ5emFudGl1bSBibG9ja3MsIGJ1dCBzb21lIGJhY2tlbmRzIG1heVxyXG4gICAgICogIGJhY2tmaWxsIHRoaXMgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXR1cztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSByb290IGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBpcyBubyBwcmVzZW50IGFuZCB3YXMgb25seSBpbmNsdWRlZCBpbiBwcmUtYnl6YW50aXVtIGJsb2NrcywgYnV0XHJcbiAgICAgKiAgY291bGQgYmUgdXNlZCB0byB2YWxpZGF0ZSBjZXJ0YWluIHBhcnRzIG9mIHRoZSByZWNlaXB0LlxyXG4gICAgICovXHJcbiAgICByb290O1xyXG4gICAgI2xvZ3M7XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodHgsIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy4jbG9ncyA9IE9iamVjdC5mcmVlemUodHgubG9ncy5tYXAoKGxvZykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgbGV0IGdhc1ByaWNlID0gQk5fMDtcclxuICAgICAgICBpZiAodHguZWZmZWN0aXZlR2FzUHJpY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBnYXNQcmljZSA9IHR4LmVmZmVjdGl2ZUdhc1ByaWNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICBwcm92aWRlcixcclxuICAgICAgICAgICAgdG86IHR4LnRvLFxyXG4gICAgICAgICAgICBmcm9tOiB0eC5mcm9tLFxyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHR4LmNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcclxuICAgICAgICAgICAgaW5kZXg6IHR4LmluZGV4LFxyXG4gICAgICAgICAgICBibG9ja0hhc2g6IHR4LmJsb2NrSGFzaCxcclxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxyXG4gICAgICAgICAgICBsb2dzQmxvb206IHR4LmxvZ3NCbG9vbSxcclxuICAgICAgICAgICAgZ2FzVXNlZDogdHguZ2FzVXNlZCxcclxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxyXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdHguYmxvYkdhc1VzZWQsXHJcbiAgICAgICAgICAgIGdhc1ByaWNlLFxyXG4gICAgICAgICAgICBibG9iR2FzUHJpY2U6IHR4LmJsb2JHYXNQcmljZSxcclxuICAgICAgICAgICAgdHlwZTogdHgudHlwZSxcclxuICAgICAgICAgICAgLy9ieXphbnRpdW06IHR4LmJ5emFudGl1bSxcclxuICAgICAgICAgICAgc3RhdHVzOiB0eC5zdGF0dXMsXHJcbiAgICAgICAgICAgIHJvb3Q6IHR4LnJvb3RcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBsb2dzIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXQgbG9ncygpIHsgcmV0dXJuIHRoaXMuI2xvZ3M7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCB7IHRvLCBmcm9tLCBjb250cmFjdEFkZHJlc3MsIGhhc2gsIGluZGV4LCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBsb2dzQmxvb20sIGxvZ3MsIC8vYnl6YW50aXVtLCBcclxuICAgICAgICBzdGF0dXMsIHJvb3QgfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsXHJcbiAgICAgICAgICAgIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsXHJcbiAgICAgICAgICAgIC8vYnl6YW50aXVtLCBcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogdG9Kc29uKHRoaXMuY3VtdWxhdGl2ZUdhc1VzZWQpLFxyXG4gICAgICAgICAgICBmcm9tLFxyXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxyXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdG9Kc29uKHRoaXMuYmxvYkdhc1VzZWQpLFxyXG4gICAgICAgICAgICBibG9iR2FzUHJpY2U6IHRvSnNvbih0aGlzLmJsb2JHYXNQcmljZSksXHJcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxyXG4gICAgICAgICAgICBoYXNoLCBpbmRleCwgbG9ncywgbG9nc0Jsb29tLCByb290LCBzdGF0dXMsIHRvXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5sb2dzLmxlbmd0aDsgfVxyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLmxvZ3NbaW5kZXgrK10sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHRvdGFsIGZlZSBmb3IgdGhpcyB0cmFuc2FjdGlvbiwgaW4gd2VpLlxyXG4gICAgICovXHJcbiAgICBnZXQgZmVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdhc1VzZWQgKiB0aGlzLmdhc1ByaWNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEJsb2NrKCkge1xyXG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayh0aGlzLmJsb2NrSGFzaCk7XHJcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xyXG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGV4ZWN1dGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXHJcbiAgICAgKiAgd2l0aCB0aGUgYGBkZWJ1Z19gYCBvciBgYHRyYWNlX2BgIEFQSSBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVzdWx0KHRoaXMuaGFzaCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBjb25maXJtYXRpb25zIHRoaXMgdHJhbnNhY3Rpb24gaGFzLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpKSAtIHRoaXMuYmxvY2tOdW1iZXIgKyAxO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZWRFdmVudCgpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XHJcbiAgICAgICAgYXNzZXJ0KCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zY3Rpb24gY2Fubm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlb3JkZXJlZEV2ZW50KG90aGVyKVwiIH0pO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzLCBvdGhlcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cclxuICogIHRoYXQgd2FzIHNlbnQgdG8gdGhlIG5ldHdvcmssIHdoaWNoIG1heSBvciBtYXkgbm90IGJlIGluY2x1ZGVkIGluIGFcclxuICogIGJsb2NrLlxyXG4gKlxyXG4gKiAgVGhlIFtbVHJhbnNhY3Rpb25SZXNwb25zZS1pc01pbmVkXV0gY2FuIGJlIHVzZWQgdG8gY2hlY2sgaWYgdGhlXHJcbiAqICB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhcyB3ZWxsIGFzIHR5cGUgZ3VhcmQgdGhhdCB0aGUgb3RoZXJ3aXNlXHJcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uUmVzcG9uc2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgaXMgY29ubmVjdGVkIHRvLCB3aGljaCB3aWxsIGluZmx1ZW5jZSBob3cgaXRzXHJcbiAgICAgKiAgbWV0aG9kcyB3aWxsIHJlc29sdmUgaXRzIGFzeW5jIGluc3BlY3Rpb24gbWV0aG9kcy5cclxuICAgICAqL1xyXG4gICAgcHJvdmlkZXI7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGBgbnVsbGBgIGZvciBwZW5kaW5nIHRyYW5zYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgYmxvY2tOdW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgYmxvY2tIYXNoIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGBgbnVsbGBgIGZvciBwZW5kaW5nIHRyYW5zYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgYmxvY2tIYXNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHJlc2lkZXMgYXQuXHJcbiAgICAgKi9cclxuICAgIGluZGV4O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXHJcbiAgICAgKi9cclxuICAgIGhhc2g7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yNzE4XV0gdHJhbnNhY3Rpb24gZW52ZWxvcGUgdHlwZS4gVGhpcyBpc1xyXG4gICAgICogIGBgMGBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zIHR5cGVzLlxyXG4gICAgICovXHJcbiAgICB0eXBlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHJlY2VpdmVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIElmIGBgbnVsbGBgLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBpbml0Y29kZSB0cmFuc2FjdGlvbi5cclxuICAgICAqICBUaGlzIG1lYW5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSBbW2RhdGFdXSB3aWxsIGJlIGRlcGxveWVkXHJcbiAgICAgKiAgYXMgYSBuZXcgY29udHJhY3Qgb24gY2hhaW4gKGFzc3VtaW5nIGl0IGRvZXMgbm90IHJldmVydCkgYW5kIHRoZVxyXG4gICAgICogIGFkZHJlc3MgbWF5IGJlIGNvbXB1dGVkIHVzaW5nIFtbZ2V0Q3JlYXRlQWRkcmVzc11dLlxyXG4gICAgICovXHJcbiAgICB0bztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi4gSXQgaXMgaW1wbGljaXRseSBjb21wdXRlZFxyXG4gICAgICogIGZyb20gdGhlIHRyYW5zYWN0aW9uIHByZS1pbWFnZSBoYXNoIChhcyB0aGUgZGlnZXN0KSBhbmQgdGhlXHJcbiAgICAgKiAgW1tzaWduYXR1cmVdXSB1c2luZyBlY3JlY292ZXIuXHJcbiAgICAgKi9cclxuICAgIGZyb207XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbm9uY2UsIHdoaWNoIGlzIHVzZWQgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcyBhbmQgb2ZmZXJcclxuICAgICAqICBhIG1ldGhvZCB0byBlbnN1cmUgdHJhbnNhY3Rpb25zIGZyb20gYSBnaXZlbiBzZW5kZXIgYXJlIGV4cGxpY2l0bHlcclxuICAgICAqICBvcmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqICBXaGVuIHNlbmRpbmcgYSB0cmFuc2FjdGlvbiwgdGhpcyBtdXN0IGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2ZcclxuICAgICAqICB0cmFuc2FjdGlvbnMgZXZlciBzZW50IGJ5IFtbZnJvbV1dLlxyXG4gICAgICovXHJcbiAgICBub25jZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXhpbXVtIHVuaXRzIG9mIGdhcyB0aGlzIHRyYW5zYWN0aW9uIGNhbiBjb25zdW1lLiBJZiBleGVjdXRpb25cclxuICAgICAqICBleGNlZWRzIHRoaXMsIHRoZSBlbnRyaWVzIHRyYW5zYWN0aW9uIGlzIHJldmVydGVkIGFuZCB0aGUgc2VuZGVyXHJcbiAgICAgKiAgaXMgY2hhcmdlZCBmb3IgdGhlIGZ1bGwgYW1vdW50LCBkZXNwaXRlIG5vdCBzdGF0ZSBjaGFuZ2VzIGJlaW5nIG1hZGUuXHJcbiAgICAgKi9cclxuICAgIGdhc0xpbWl0O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBjYW4gaGF2ZSB2YXJpb3VzIHZhbHVlcywgZGVwZW5kaW5nIG9uIHRoZSBuZXR3b3JrLlxyXG4gICAgICpcclxuICAgICAqICBJbiBtb2Rlcm4gbmV0d29ya3MsIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgaW5jbHVkZWQgdGhpcyBpc1xyXG4gICAgICogIHRoZSAvL2VmZmVjdGl2ZSBnYXMgcHJpY2UvLyAodGhlIGZlZSBwZXIgZ2FzIHRoYXQgd2FzIGFjdHVhbGx5XHJcbiAgICAgKiAgY2hhcmdlZCksIHdoaWxlIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBoYXZlIG5vdCBiZWVuIGluY2x1ZGVkIHlldFxyXG4gICAgICogIGlzIHRoZSBbW21heEZlZVBlckdhc11dLlxyXG4gICAgICpcclxuICAgICAqICBGb3IgbGVnYWN5IHRyYW5zYWN0aW9ucywgb3IgdHJhbnNhY3Rpb25zIG9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpc1xyXG4gICAgICogIGlzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIGNoYXJnZWQgcGVyIHVuaXQgb2YgZ2FzIHRoZSB0cmFuc2FjdGlvblxyXG4gICAgICogIGNvbnN1bWVzLlxyXG4gICAgICovXHJcbiAgICBnYXNQcmljZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXhpbXVtIHByaW9yaXR5IGZlZSAocGVyIHVuaXQgb2YgZ2FzKSB0byBhbGxvdyBhXHJcbiAgICAgKiAgdmFsaWRhdG9yIHRvIGNoYXJnZSB0aGUgc2VuZGVyLiBUaGlzIGlzIGluY2x1c2l2ZSBvZiB0aGVcclxuICAgICAqICBbW21heEZlZUZlZVBlckdhc11dLlxyXG4gICAgICovXHJcbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXhpbXVtIGZlZSAocGVyIHVuaXQgb2YgZ2FzKSB0byBhbGxvdyB0aGlzIHRyYW5zYWN0aW9uXHJcbiAgICAgKiAgdG8gY2hhcmdlIHRoZSBzZW5kZXIuXHJcbiAgICAgKi9cclxuICAgIG1heEZlZVBlckdhcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBtYXggZmVlIHBlciBCTE9iIGdhcy5cclxuICAgICAqL1xyXG4gICAgbWF4RmVlUGVyQmxvYkdhcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBkYXRhLlxyXG4gICAgICovXHJcbiAgICBkYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHZhbHVlLCBpbiB3ZWkuIFVzZSBbW2Zvcm1hdEV0aGVyXV0gdG8gZm9ybWF0IHRoaXMgdmFsdWVcclxuICAgICAqICBhcyBldGhlci5cclxuICAgICAqL1xyXG4gICAgdmFsdWU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY2hhaW4gSUQuXHJcbiAgICAgKi9cclxuICAgIGNoYWluSWQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgc2lnbmF0dXJlLlxyXG4gICAgICovXHJcbiAgICBzaWduYXR1cmU7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QgZm9yIHRyYW5zYWN0aW9uIHR5cGVzIHRoYXRcclxuICAgICAqICBzdXBwb3J0IGl0LCBvdGhlcndpc2UgYGBudWxsYGAuXHJcbiAgICAgKi9cclxuICAgIGFjY2Vzc0xpc3Q7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgW1tsaW5rLWVpcC00ODQ0XV0gQkxPYiB2ZXJzaW9uZWQgaGFzaGVzLlxyXG4gICAgICovXHJcbiAgICBibG9iVmVyc2lvbmVkSGFzaGVzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIFtbbGluay1laXAtNzcwMl1dIGF1dGhvcml6YXRpb25zIChpZiBhbnkpLlxyXG4gICAgICovXHJcbiAgICBhdXRob3JpemF0aW9uTGlzdDtcclxuICAgICNzdGFydEJsb2NrO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgICAgICB0aGlzLmJsb2NrTnVtYmVyID0gKHR4LmJsb2NrTnVtYmVyICE9IG51bGwpID8gdHguYmxvY2tOdW1iZXIgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuYmxvY2tIYXNoID0gKHR4LmJsb2NrSGFzaCAhPSBudWxsKSA/IHR4LmJsb2NrSGFzaCA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5oYXNoID0gdHguaGFzaDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gdHguaW5kZXg7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHgudHlwZTtcclxuICAgICAgICB0aGlzLmZyb20gPSB0eC5mcm9tO1xyXG4gICAgICAgIHRoaXMudG8gPSB0eC50byB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcclxuICAgICAgICB0aGlzLm5vbmNlID0gdHgubm9uY2U7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdHguZGF0YTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdHgudmFsdWU7XHJcbiAgICAgICAgdGhpcy5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xyXG4gICAgICAgIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5tYXhGZWVQZXJHYXMgPSAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4RmVlUGVyR2FzIDogbnVsbDtcclxuICAgICAgICB0aGlzLm1heEZlZVBlckJsb2JHYXMgPSAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckJsb2JHYXMgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XHJcbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSB0eC5zaWduYXR1cmU7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NMaXN0ID0gKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkgPyB0eC5hY2Nlc3NMaXN0IDogbnVsbDtcclxuICAgICAgICB0aGlzLmJsb2JWZXJzaW9uZWRIYXNoZXMgPSAodHguYmxvYlZlcnNpb25lZEhhc2hlcyAhPSBudWxsKSA/IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuYXV0aG9yaXphdGlvbkxpc3QgPSAodHguYXV0aG9yaXphdGlvbkxpc3QgIT0gbnVsbCkgPyB0eC5hdXRob3JpemF0aW9uTGlzdCA6IG51bGw7XHJcbiAgICAgICAgdGhpcy4jc3RhcnRCbG9jayA9IC0xO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tIYXNoLCBpbmRleCwgaGFzaCwgdHlwZSwgdG8sIGZyb20sIG5vbmNlLCBkYXRhLCBzaWduYXR1cmUsIGFjY2Vzc0xpc3QsIGJsb2JWZXJzaW9uZWRIYXNoZXMgfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZXNwb25zZVwiLFxyXG4gICAgICAgICAgICBhY2Nlc3NMaXN0LCBibG9ja051bWJlciwgYmxvY2tIYXNoLFxyXG4gICAgICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzLFxyXG4gICAgICAgICAgICBjaGFpbklkOiB0b0pzb24odGhpcy5jaGFpbklkKSxcclxuICAgICAgICAgICAgZGF0YSwgZnJvbSxcclxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbih0aGlzLmdhc0xpbWl0KSxcclxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbih0aGlzLmdhc1ByaWNlKSxcclxuICAgICAgICAgICAgaGFzaCxcclxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJHYXMpLFxyXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdG9Kc29uKHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxyXG4gICAgICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJCbG9iR2FzKSxcclxuICAgICAgICAgICAgbm9uY2UsIHNpZ25hdHVyZSwgdG8sIGluZGV4LCB0eXBlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdG9Kc29uKHRoaXMudmFsdWUpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgQmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gaW5jbHVkZWQgeWV0LlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRCbG9jaygpIHtcclxuICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSB0aGlzLmJsb2NrTnVtYmVyO1xyXG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbigpO1xyXG4gICAgICAgICAgICBpZiAodHgpIHtcclxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlcik7XHJcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhpcyB0cmFuc2FjdGlvbiBiZWluZyByZS1yZXF1ZXN0ZWQgZnJvbSB0aGVcclxuICAgICAqICBwcm92aWRlci4gVGhpcyBjYW4gYmUgdXNlZCBpZiB5b3UgaGF2ZSBhbiB1bm1pbmVkIHRyYW5zYWN0aW9uXHJcbiAgICAgKiAgYW5kIHdpc2ggdG8gZ2V0IGFuIHVwLXRvLWRhdGUgcG9wdWxhdGVkIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGNvbmZpcm1hdGlvbnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHR4LCBibG9ja051bWJlciB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgdHg6IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKSxcclxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIE5vdCBtaW5lZCB5ZXQuLi5cclxuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwgfHwgdHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXHJcbiAgICAgKiAgJSVjb25maXJtcyUlIGJsb2NrcyBpbmNsdWRpbmcgaXQgKGRlZmF1bHQ6IGBgMWBgKSB3aXRoIGFuXHJcbiAgICAgKiAgb3B0aW9uYWwgJSV0aW1lb3V0JSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgY2FuIHJlc29sdmUgdG8gYGBudWxsYGAgb25seSBpZiAlJWNvbmZpcm1zJSUgaXMgYGAwYGBcclxuICAgICAqICBhbmQgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgb3RoZXJ3aXNlIHRoaXMgd2lsbFxyXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHdhaXQoX2NvbmZpcm1zLCBfdGltZW91dCkge1xyXG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyA9PSBudWxsKSA/IDEgOiBfY29uZmlybXM7XHJcbiAgICAgICAgY29uc3QgdGltZW91dCA9IChfdGltZW91dCA9PSBudWxsKSA/IDAgOiBfdGltZW91dDtcclxuICAgICAgICBsZXQgc3RhcnRCbG9jayA9IHRoaXMuI3N0YXJ0QmxvY2s7XHJcbiAgICAgICAgbGV0IG5leHRTY2FuID0gLTE7XHJcbiAgICAgICAgbGV0IHN0b3BTY2FubmluZyA9IChzdGFydEJsb2NrID09PSAtMSkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgY29uc3QgY2hlY2tSZXBsYWNlbWVudCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGlzIHNlbmRlclxyXG4gICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBub25jZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSxcclxuICAgICAgICAgICAgICAgIG5vbmNlOiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5mcm9tKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gTm8gdHJhbnNhY3Rpb24gb3Igb3VyIG5vbmNlIGhhcyBub3QgYmVlbiBtaW5lZCB5ZXQ7IGJ1dCB3ZVxyXG4gICAgICAgICAgICAvLyBjYW4gc3RhcnQgc2Nhbm5pbmcgbGF0ZXIgd2hlbiB3ZSBkbyBzdGFydFxyXG4gICAgICAgICAgICBpZiAobm9uY2UgPCB0aGlzLm5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydEJsb2NrID0gYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcclxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbWluZWQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XHJcbiAgICAgICAgICAgIGlmIChtaW5lZCAmJiBtaW5lZC5ibG9ja051bWJlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2Ugd2VyZSByZXBsYWNlZDsgc3RhcnQgc2Nhbm5pbmcgZm9yIHRoYXQgdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgLy8gU3RhcnRpbmcgdG8gc2NhbjsgbG9vayBiYWNrIGEgZmV3IGV4dHJhIGJsb2NrcyBmb3Igc2FmZXR5XHJcbiAgICAgICAgICAgIGlmIChuZXh0U2NhbiA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIG5leHRTY2FuID0gc3RhcnRCbG9jayAtIDM7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNjYW4gPCB0aGlzLiNzdGFydEJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNjYW4gPSB0aGlzLiNzdGFydEJsb2NrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChuZXh0U2NhbiA8PSBibG9ja051bWJlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGJsb2NrIHRvIHNjYW5cclxuICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayhuZXh0U2NhbiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcclxuICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGFzaCBvZiBibG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoID09PSB0aGlzLmhhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRoYXQgcmVwbGFjZWQgdXNcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGJsb2NrLmdldFRyYW5zYWN0aW9uKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5mcm9tID09PSB0aGlzLmZyb20gJiYgdHgubm9uY2UgPT09IHRoaXMubm9uY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZWNlaXB0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eC5oYXNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbjsgYnV0IHdlJ2xsIHRyeSBhZ2FpbiBzaG9ydGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIHJldHJ5IHRoaXMgb24gdGhlIG5leHQgYmxvY2sgKHRoaXMgY2FzZSBjb3VsZCBiZSBvcHRpbWl6ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSkgPCBjb25maXJtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhc29uID0gXCJyZXBsYWNlZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZGF0YSA9PT0gdGhpcy5kYXRhICYmIHR4LnRvID09PSB0aGlzLnRvICYmIHR4LnZhbHVlID09PSB0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHguZGF0YSA9PT0gXCIweFwiICYmIHR4LmZyb20gPT09IHR4LnRvICYmIHR4LnZhbHVlID09PSBCTl8wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJ0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWRcIiwgXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQ6IHR4LnJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jayksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0U2NhbisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGNoZWNrUmVjZWlwdCA9IChyZWNlaXB0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgfHwgcmVjZWlwdC5zdGF0dXMgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJ0cmFuc2FjdGlvbiBleGVjdXRpb24gcmV2ZXJ0ZWRcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLCByZWFzb246IG51bGwsIGludm9jYXRpb246IG51bGwsIHJldmVydDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG86IHJlY2VpcHQudG8sXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcmVjZWlwdC5mcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIgLy8gQFRPRE86IGluIHY3LCBzcGxpdCBvdXQgc2VuZFRyYW5zYWN0aW9uIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgIH0sIHJlY2VpcHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5oYXNoKTtcclxuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlY2VpcHQpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09PSAxIHx8IChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aHJvd3MgaWYgYSByZXBsYWNlbWVudCB3YXMgZm91bmRcclxuICAgICAgICAgICAgYXdhaXQgY2hlY2tSZXBsYWNlbWVudCgpO1xyXG4gICAgICAgICAgICAvLyBBbGxvdyBudWxsIG9ubHkgd2hlbiB0aGUgY29uZmlybXMgaXMgMFxyXG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHdhaXRlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgLy8gTGlzdCBvZiB0aGluZ3MgdG8gY2FuY2VsIHdoZW4gd2UgaGF2ZSBhIHJlc3VsdCAob25lIHdheSBvciB0aGUgb3RoZXIpXHJcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlcnMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4geyBjYW5jZWxsZXJzLmZvckVhY2goKGMpID0+IGMoKSk7IH07XHJcbiAgICAgICAgICAgIC8vIE9uIGNhbmNlbCwgc3RvcCBzY2FubmluZyBmb3IgcmVwbGFjZW1lbnRzXHJcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHN0b3BTY2FubmluZyA9IHRydWU7IH0pO1xyXG4gICAgICAgICAgICAvLyBTZXQgdXAgYW55IHRpbWVvdXQgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwid2FpdCBmb3IgdHJhbnNhY3Rpb24gdGltZW91dFwiLCBcIlRJTUVPVVRcIikpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyBjbGVhclRpbWVvdXQodGltZXIpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0eExpc3RlbmVyID0gYXN5bmMgKHJlY2VpcHQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIERvbmU7IHJldHVybiBpdCFcclxuICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjaGVja1JlY2VpcHQocmVjZWlwdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7IH0pO1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIC8vIFdlIHN1cHBvcnQgcmVwbGFjZW1lbnQgZGV0ZWN0aW9uOyBzdGFydCBjaGVja2luZ1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRCbG9jayA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTGlzdGVuZXIgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRoaXMgdGhyb3dzIG9ubHkgaWYgb25lIGlzIGZvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQgKHdpdGggZW5vdWdoIGNvbmZpcm1zKTsgcmUtdGhyb3cgdGhlIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzY2hldWRsZSBhIGNoZWNrIG9uIHRoZSBuZXh0IGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wU2Nhbm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgdGhpcy5wcm92aWRlci5vZmYoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpOyB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgd2FpdGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBpZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIGluY2x1ZGVkLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGlzIGVmZmVjdGl2ZSBvbmx5IGFzIG9mIHRoZSB0aW1lIHRoZSBUcmFuc2FjdGlvblJlc3BvbnNlXHJcbiAgICAgKiAgd2FzIGluc3RhbnRpYXRlZC4gVG8gZ2V0IHVwLXRvLWRhdGUgaW5mb3JtYXRpb24sIHVzZVxyXG4gICAgICogIFtbZ2V0VHJhbnNhY3Rpb25dXS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxyXG4gICAgICogIG5vbi1udWxsIHByb3BlcnR5IHZhbHVlcyBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBudWxsIGZvclxyXG4gICAgICogIHVubWluZWQgdHJhbnNhY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBpc01pbmVkKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5ibG9ja0hhc2ggIT0gbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgbGVnYWN5IChpLmUuIGBgdHlwZSA9PSAwYGApXHJcbiAgICAgKiAgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcclxuICAgICAqICB0aGUgYGBudWxsYGAtbmVzcyBmb3IgaGFyZGZvcmstc3BlY2lmaWMgcHJvcGVydGllcyBzZXQgY29ycmVjdGx5LlxyXG4gICAgICovXHJcbiAgICBpc0xlZ2FjeSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgQmVybGluIChpLmUuIGBgdHlwZSA9PSAxYGApXHJcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTIwNzBdXS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZVxyXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXHJcbiAgICAgKi9cclxuICAgIGlzQmVybGluKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBMb25kb24gKGkuZS4gYGB0eXBlID09IDJgYClcclxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtMTU1OV1dLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXHJcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cclxuICAgICAqL1xyXG4gICAgaXNMb25kb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIGh0ZSB0cmFuc2FjdGlvbiBpcyBhIENhbmN1biAoaS5lLiBgYHR5cGUgPT0gM2BgKVxyXG4gICAgICogIHRyYW5zYWN0aW9uLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXHJcbiAgICAgKi9cclxuICAgIGlzQ2FuY3VuKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXHJcbiAgICAgKiAgdGhhdCBldmljdCB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVkRXZlbnQoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgZmlsdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3Igb3JwaGFuIGV2ZW50c1xyXG4gICAgICogIHRoYXQgcmUtb3JkZXIgdGhpcyBldmVudCBhZ2FpbnN0ICUlb3RoZXIlJS5cclxuICAgICAqL1xyXG4gICAgcmVvcmRlcmVkRXZlbnQob3RoZXIpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5pc01pbmVkKCksIFwidW5taW5lZCB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XHJcbiAgICAgICAgYXNzZXJ0KCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcywgb3RoZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlIGluc3RhbmNlIHdoaWNoIGhhcyB0aGUgYWJpbGl0eSB0b1xyXG4gICAgICogIGRldGVjdCAoYW5kIHRocm93IGFuIGVycm9yKSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgcmVwbGFjZWQsIHdoaWNoXHJcbiAgICAgKiAgd2lsbCBiZWdpbiBzY2FubmluZyBhdCAlJXN0YXJ0QmxvY2slJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSB1c2VkIGJ5IGRldmVsb3BlcnMgYW5kIGlzIGludGVuZGVkXHJcbiAgICAgKiAgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIFNldHRpbmcgYW4gaW5jb3JyZWN0ICUlc3RhcnRCbG9jayUlIGNhblxyXG4gICAgICogIGhhdmUgZGV2YXN0YXRpbmcgcGVyZm9ybWFuY2UgY29uc2VxdWVuY2VzIGlmIHVzZWQgaW5jb3JyZWN0bHkuXHJcbiAgICAgKi9cclxuICAgIHJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jaykge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIoc3RhcnRCbG9jaykgJiYgc3RhcnRCbG9jayA+PSAwLCBcImludmFsaWQgc3RhcnRCbG9ja1wiLCBcInN0YXJ0QmxvY2tcIiwgc3RhcnRCbG9jayk7XHJcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLCB0aGlzLnByb3ZpZGVyKTtcclxuICAgICAgICB0eC4jc3RhcnRCbG9jayA9IHN0YXJ0QmxvY2s7XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIoYmxvY2spIHtcclxuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWJsb2NrXCIsIGhhc2g6IGJsb2NrLmhhc2gsIG51bWJlcjogYmxvY2subnVtYmVyIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgsIG90aGVyKSB7XHJcbiAgICByZXR1cm4geyBvcnBoYW46IFwicmVvcmRlci10cmFuc2FjdGlvblwiLCB0eCwgb3RoZXIgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgpIHtcclxuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLXRyYW5zYWN0aW9uXCIsIHR4IH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcihsb2cpIHtcclxuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxyXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXHJcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXHJcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxyXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcclxuICAgICAgICAgICAgdG9waWNzOiBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSksXHJcbiAgICAgICAgICAgIGluZGV4OiBsb2cuaW5kZXhcclxuICAgICAgICB9IH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXIuanMubWFwIiwiLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxyXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXHJcbmltcG9ydCB7IExvZywgVHJhbnNhY3Rpb25SZWNlaXB0LCBUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9wcm92aWRlci5qc1wiO1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBFdmVudFBheWxvYWQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuLyoqXHJcbiAqICBBbiAqKkV2ZW50TG9nKiogY29udGFpbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHBhcnNlZCBmcm9tIHRoZSBbW0xvZ11dLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEV2ZW50TG9nIGV4dGVuZHMgTG9nIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGludGVyZmFjZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtYXRjaGluZyBldmVudC5cclxuICAgICAqL1xyXG4gICAgZnJhZ21lbnQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcGFyc2VkIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGV2ZW50IGJ5IGBgZW1pdGBgLlxyXG4gICAgICovXHJcbiAgICBhcmdzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobG9nLCBpZmFjZSwgZnJhZ21lbnQpIHtcclxuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IGlmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcyk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFyZ3MsIGZyYWdtZW50LCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBnZXQgZXZlbnROYW1lKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lOyB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGV2ZW50U2lnbmF0dXJlKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTsgfVxyXG59XHJcbi8qKlxyXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBVbmRlY29kZWRFdmVudExvZyBleHRlbmRzIExvZyB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZXJyb3IgZW5jb3VudGVkIHdoZW4gdHJ5aW5nIHRvIGRlY29kZSB0aGUgbG9nLlxyXG4gICAgICovXHJcbiAgICBlcnJvcjtcclxuICAgIC8qKlxyXG4gICAgICogQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvZywgZXJyb3IpIHtcclxuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGVycm9yIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgdGhlIHBhcnNlZCBsb2dzIGZyb20gYVxyXG4gKiAgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCBleHRlbmRzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XHJcbiAgICAjaWZhY2U7XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWZhY2UsIHByb3ZpZGVyLCB0eCkge1xyXG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwYXJzZWQgbG9ncyBmb3IgYW55IFtbTG9nXV0gd2hpY2ggaGFzIGEgbWF0Y2hpbmcgZXZlbnQgaW4gdGhlXHJcbiAgICAgKiAgQ29udHJhY3QgQUJJLlxyXG4gICAgICovXHJcbiAgICBnZXQgbG9ncygpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIubG9ncy5tYXAoKGxvZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGxvZy50b3BpY3MubGVuZ3RoID8gdGhpcy4jaWZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSkgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuI2lmYWNlLCBmcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsb2c7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKiogd2lsbCByZXR1cm4gYVxyXG4gKiAgW1tDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdF1dIHdoZW4gd2FpdGVkIG9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSBleHRlbmRzIFRyYW5zYWN0aW9uUmVzcG9uc2Uge1xyXG4gICAgI2lmYWNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcclxuICAgICAgICBzdXBlcih0eCwgcHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYW5kIGhhc1xyXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxyXG4gICAgICogIG9wdGlvbmFsICUldGltZW91dCUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXHJcbiAgICAgKiAgYW5kIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQsIG90aGVyd2lzZSB0aGlzIHdpbGxcclxuICAgICAqICB3YWl0IHVudGlsIGVub3VnaCBjb25maXJtYXRpb25zIGhhdmUgY29tcGxldGVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyB3YWl0KGNvbmZpcm1zLCB0aW1lb3V0KSB7XHJcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHN1cGVyLndhaXQoY29uZmlybXMsIHRpbWVvdXQpO1xyXG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaWZhY2UsIHRoaXMucHJvdmlkZXIsIHJlY2VpcHQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSAqKkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xyXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGRvZXMgbm90IG1hdGNoIGFueSBldmVudHMgaW4gdGhlIEFCSS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQgZXh0ZW5kcyBFdmVudFBheWxvYWQge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGxvZyB3aXRoIG5vIG1hdGNoaW5nIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgbG9nO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQF9ldmVudDpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGxvZykge1xyXG4gICAgICAgIHN1cGVyKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbG9nIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoZSBldmVudCBvY2N1cmVkIGluLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRCbG9jaygpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0QmxvY2soKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgKipDb250cmFjdEV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xyXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGlzIGtub3duLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbnRyYWN0RXZlbnRQYXlsb2FkIGV4dGVuZHMgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIHtcclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgZnJhZ21lbnQsIF9sb2cpIHtcclxuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgbmV3IEV2ZW50TG9nKF9sb2csIGNvbnRyYWN0LmludGVyZmFjZSwgZnJhZ21lbnQpKTtcclxuICAgICAgICBjb25zdCBhcmdzID0gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCB0aGlzLmxvZy5kYXRhLCB0aGlzLmxvZy50b3BpY3MpO1xyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhcmdzLCBmcmFnbWVudCB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICovXHJcbiAgICBnZXQgZXZlbnROYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50Lm5hbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZXZlbnQgc2lnbmF0dXJlLlxyXG4gICAgICovXHJcbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JhcHBlcnMuanMubWFwIiwiaW1wb3J0IHsgSW50ZXJmYWNlLCBUeXBlZCB9IGZyb20gXCIuLi9hYmkvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgaXNBZGRyZXNzYWJsZSwgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xyXG4vLyBpbXBvcnQgZnJvbSBwcm92aWRlci50cyBpbnN0ZWFkIG9mIGluZGV4LnRzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwXHJcbi8vIGZyb20gRXRoZXJzY2FuUHJvdmlkZXJcclxuaW1wb3J0IHsgY29weVJlcXVlc3QsIExvZyB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIjtcclxuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBpc0NhbGxFeGNlcHRpb24sIGlzSGV4U3RyaW5nLCByZXNvbHZlUHJvcGVydGllcywgaXNFcnJvciwgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IENvbnRyYWN0RXZlbnRQYXlsb2FkLCBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQsIENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSwgRXZlbnRMb2csIFVuZGVjb2RlZEV2ZW50TG9nIH0gZnJvbSBcIi4vd3JhcHBlcnMuanNcIjtcclxuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcclxuZnVuY3Rpb24gY2FuQ2FsbCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmNhbGwpID09PSBcImZ1bmN0aW9uXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbkVzdGltYXRlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuZXN0aW1hdGVHYXMpID09PSBcImZ1bmN0aW9uXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGNhblJlc29sdmUodmFsdWUpIHtcclxuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5yZXNvbHZlTmFtZSkgPT09IFwiZnVuY3Rpb25cIik7XHJcbn1cclxuZnVuY3Rpb24gY2FuU2VuZCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnNlbmRUcmFuc2FjdGlvbikgPT09IFwiZnVuY3Rpb25cIik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGNhblJlc29sdmUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlLnByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wcm92aWRlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmNsYXNzIFByZXBhcmVkVG9waWNGaWx0ZXIge1xyXG4gICAgI2ZpbHRlcjtcclxuICAgIGZyYWdtZW50O1xyXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKSB7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZyYWdtZW50IH0pO1xyXG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoIDwgYXJncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZWN1cnNpdmVseSBkZXNjZW5kIGludG8gYXJncyBhbmQgcmVzb2x2ZSBhbnkgYWRkcmVzc2VzXHJcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcclxuICAgICAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XHJcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gKGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgUHJvbWlzZS5hbGwoZnJhZ21lbnQuaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLndhbGtBc3luYyhhcmdzW2luZGV4XSwgKHR5cGUsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbHVlLm1hcCgodikgPT4gcmVzb2x2ZUFkZHJlc3ModiwgcmVzb2x2ZXIpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKHZhbHVlLCByZXNvbHZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcbiAgICBnZXRUb3BpY0ZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jZmlsdGVyO1xyXG4gICAgfVxyXG59XHJcbi8vIEEgPSBBcmd1bWVudHMgcGFzc2VkIGluIGFzIGEgdHVwbGVcclxuLy8gUiA9IFRoZSByZXN1bHQgdHlwZSBvZiB0aGUgY2FsbCAoaS5lLiBpZiBvbmx5IG9uZSByZXR1cm4gdHlwZSxcclxuLy8gICAgIHRoZSBxdWFsaWZpZWQgdHlwZSwgb3RoZXJ3aXNlIFJlc3VsdClcclxuLy8gRCA9IFRoZSB0eXBlIHRoZSBkZWZhdWx0IGNhbGwgd2lsbCByZXR1cm4gKGkuZS4gUiBmb3Igdmlldy9wdXJlLFxyXG4vLyAgICAgVHJhbnNhY3Rpb25SZXNwb25zZSBvdGhlcndpc2UpXHJcbi8vZXhwb3J0IGludGVyZmFjZSBDb250cmFjdE1ldGhvZDxBIGV4dGVuZHMgQXJyYXk8YW55PiA9IEFycmF5PGFueT4sIFIgPSBhbnksIEQgZXh0ZW5kcyBSIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlPiB7XHJcbmZ1bmN0aW9uIGdldFJ1bm5lcih2YWx1ZSwgZmVhdHVyZSkge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgKHZhbHVlW2ZlYXR1cmVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlLnByb3ZpZGVyICYmIHR5cGVvZiAodmFsdWUucHJvdmlkZXJbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBnZXRQcm92aWRlcih2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZS5wcm92aWRlciB8fCBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiAgQF9pZ25vcmU6XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29weU92ZXJyaWRlcyhhcmcsIGFsbG93ZWQpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgb3ZlcnJpZGVzIHBhc3NlZCBpbiBhcmUgYSB2YWxpZCBvdmVycmlkZXMgb2JqZWN0XHJcbiAgICBjb25zdCBfb3ZlcnJpZGVzID0gVHlwZWQuZGVyZWZlcmVuY2UoYXJnLCBcIm92ZXJyaWRlc1wiKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoX292ZXJyaWRlcykgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBvdmVycmlkZXMgcGFyYW1ldGVyXCIsIFwib3ZlcnJpZGVzXCIsIGFyZyk7XHJcbiAgICAvLyBDcmVhdGUgYSBzaGFsbG93IGNvcHkgKHdlJ2xsIGRlZXAtaWZ5IGFueXRoaW5nIG5lZWRlZCBkdXJpbmcgbm9ybWFsaXppbmcpXHJcbiAgICBjb25zdCBvdmVycmlkZXMgPSBjb3B5UmVxdWVzdChfb3ZlcnJpZGVzKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KG92ZXJyaWRlcy50byA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwidG9cIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgdG9cIiwgXCJvdmVycmlkZXMudG9cIiwgb3ZlcnJpZGVzLnRvKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KG92ZXJyaWRlcy5kYXRhID09IG51bGwgfHwgKGFsbG93ZWQgfHwgW10pLmluZGV4T2YoXCJkYXRhXCIpID49IDAsIFwiY2Fubm90IG92ZXJyaWRlIGRhdGFcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCBvdmVycmlkZXMuZGF0YSk7XHJcbiAgICAvLyBSZXNvbHZlIGFueSBmcm9tXHJcbiAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcclxuICAgICAgICBvdmVycmlkZXMuZnJvbSA9IG92ZXJyaWRlcy5mcm9tO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG92ZXJyaWRlcztcclxufVxyXG4vKipcclxuICogIEBfaWdub3JlOlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVBcmdzKF9ydW5uZXIsIGlucHV0cywgYXJncykge1xyXG4gICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xyXG4gICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKF9ydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XHJcbiAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XHJcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtLndhbGtBc3luYyhhcmdzW2luZGV4XSwgKHR5cGUsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyh2YWx1ZSwgcmVzb2x2ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH0pKTtcclxufVxyXG5mdW5jdGlvbiBidWlsZFdyYXBwZWRGYWxsYmFjayhjb250cmFjdCkge1xyXG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcclxuICAgICAgICAvLyBJZiBhbiBvdmVycmlkZXMgd2FzIHBhc3NlZCBpbiwgY29weSBpdCBhbmQgbm9ybWFsaXplIHRoZSB2YWx1ZXNcclxuICAgICAgICBjb25zdCB0eCA9IChhd2FpdCBjb3B5T3ZlcnJpZGVzKG92ZXJyaWRlcywgW1wiZGF0YVwiXSkpO1xyXG4gICAgICAgIHR4LnRvID0gYXdhaXQgY29udHJhY3QuZ2V0QWRkcmVzcygpO1xyXG4gICAgICAgIGlmICh0eC5mcm9tKSB7XHJcbiAgICAgICAgICAgIHR4LmZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0eC5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaWZhY2UgPSBjb250cmFjdC5pbnRlcmZhY2U7XHJcbiAgICAgICAgY29uc3Qgbm9WYWx1ZSA9IChnZXRCaWdJbnQoKHR4LnZhbHVlIHx8IEJOXzApLCBcIm92ZXJyaWRlcy52YWx1ZVwiKSA9PT0gQk5fMCk7XHJcbiAgICAgICAgY29uc3Qgbm9EYXRhID0gKCh0eC5kYXRhIHx8IFwiMHhcIikgPT09IFwiMHhcIik7XHJcbiAgICAgICAgaWYgKGlmYWNlLmZhbGxiYWNrICYmICFpZmFjZS5mYWxsYmFjay5wYXlhYmxlICYmIGlmYWNlLnJlY2VpdmUgJiYgIW5vRGF0YSAmJiAhbm9WYWx1ZSkge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUgb3Igc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBmYWxsYmFja1wiLCBcIm92ZXJyaWRlc1wiLCBvdmVycmlkZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChpZmFjZS5mYWxsYmFjayB8fCBub0RhdGEsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlLW9ubHkgY29udHJhY3RcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCB0eC5kYXRhKTtcclxuICAgICAgICAvLyBPbmx5IGFsbG93IHBheWFibGUgY29udHJhY3RzIHRvIHNldCBub24temVybyB2YWx1ZVxyXG4gICAgICAgIGNvbnN0IHBheWFibGUgPSBpZmFjZS5yZWNlaXZlIHx8IChpZmFjZS5mYWxsYmFjayAmJiBpZmFjZS5mYWxsYmFjay5wYXlhYmxlKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChwYXlhYmxlIHx8IG5vVmFsdWUsIFwiY2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXMudmFsdWVcIiwgdHgudmFsdWUpO1xyXG4gICAgICAgIC8vIE9ubHkgYWxsb3cgZmFsbGJhY2sgY29udHJhY3RzIHRvIHNldCBub24tZW1wdHkgZGF0YVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0eDtcclxuICAgIH07XHJcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xyXG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcclxuICAgICAgICBhc3NlcnQoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250cmFjdC5pbnRlcmZhY2UubWFrZUVycm9yKGVycm9yLmRhdGEsIHR4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcclxuICAgICAgICBjb25zdCBydW5uZXIgPSBjb250cmFjdC5ydW5uZXI7XHJcbiAgICAgICAgYXNzZXJ0KGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcclxuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHJ1bm5lci5zZW5kVHJhbnNhY3Rpb24oYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpKTtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XHJcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxyXG4gICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZXN0aW1hdGVHYXMgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJlc3RpbWF0ZUdhc1wiKTtcclxuICAgICAgICBhc3NlcnQoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuZXN0aW1hdGVHYXMoYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAob3ZlcnJpZGVzKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmQob3ZlcnJpZGVzKTtcclxuICAgIH07XHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xyXG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsXHJcbiAgICAgICAgZXN0aW1hdGVHYXMsXHJcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcclxuICAgICAgICBzZW5kLCBzdGF0aWNDYWxsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBtZXRob2Q7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkTWV0aG9kKGNvbnRyYWN0LCBrZXkpIHtcclxuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXksIGFyZ3MpO1xyXG4gICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxyXG4gICAgICAgICAgICBpbmZvOiB7IGtleSwgYXJncyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHBvcHVsYXRlVHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XHJcbiAgICAgICAgLy8gSWYgYW4gb3ZlcnJpZGVzIHdhcyBwYXNzZWQgaW4sIGNvcHkgaXQgYW5kIG5vcm1hbGl6ZSB0aGUgdmFsdWVzXHJcbiAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xyXG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSA9PT0gYXJncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgb3ZlcnJpZGVzID0gYXdhaXQgY29weU92ZXJyaWRlcyhhcmdzLnBvcCgpKTtcclxuICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XHJcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKG92ZXJyaWRlcy5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWwgZXJyb3I6IGZyYWdtZW50IGlucHV0cyBkb2Vzbid0IG1hdGNoIGFyZ3VtZW50czsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0IHJlc29sdmVBcmdzKGNvbnRyYWN0LnJ1bm5lciwgZnJhZ21lbnQuaW5wdXRzLCBhcmdzKTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzLCBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XHJcbiAgICAgICAgICAgIHRvOiBjb250cmFjdC5nZXRBZGRyZXNzKCksXHJcbiAgICAgICAgICAgIGRhdGE6IGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHJlc29sdmVkQXJncylcclxuICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc3RhdGljQ2FsbCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RhdGljQ2FsbFJlc3VsdCguLi5hcmdzKTtcclxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcclxuICAgICAgICBhc3NlcnQoY2FuU2VuZChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpKTtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XHJcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxyXG4gICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZXN0aW1hdGVHYXMgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiZXN0aW1hdGVHYXNcIik7XHJcbiAgICAgICAgYXNzZXJ0KGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmVzdGltYXRlR2FzKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncykpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHN0YXRpY0NhbGxSZXN1bHQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcclxuICAgICAgICBhc3NlcnQoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xyXG4gICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xyXG4gICAgICAgIGlmIChmcmFnbWVudC5jb25zdGFudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc3RhdGljQ2FsbCguLi5hcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmQoLi4uYXJncyk7XHJcbiAgICB9O1xyXG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcclxuICAgICAgICBuYW1lOiBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb25OYW1lKGtleSksXHJcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxyXG4gICAgICAgIGdldEZyYWdtZW50LFxyXG4gICAgICAgIGVzdGltYXRlR2FzLFxyXG4gICAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24sXHJcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbCwgc3RhdGljQ2FsbFJlc3VsdCxcclxuICAgIH0pO1xyXG4gICAgLy8gT25seSB3b3JrcyBvbiBub24tYW1iaWd1b3VzIGtleXMgKHJlZmluZWQgZnJhZ21lbnQgaXMgYWx3YXlzIG5vbi1hbWJpZ3VvdXMpXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uKGtleSk7XHJcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIGluZm86IHsga2V5IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBtZXRob2Q7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRXZlbnQoY29udHJhY3QsIGtleSkge1xyXG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGtleSwgYXJncyk7XHJcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXHJcbiAgICAgICAgICAgIGluZm86IHsga2V5LCBhcmdzIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbWV0aG9kID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZXBhcmVkVG9waWNGaWx0ZXIoY29udHJhY3QsIGdldEZyYWdtZW50KC4uLmFyZ3MpLCBhcmdzKTtcclxuICAgIH07XHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xyXG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudE5hbWUoa2V5KSxcclxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXHJcbiAgICAgICAgZ2V0RnJhZ21lbnRcclxuICAgIH0pO1xyXG4gICAgLy8gT25seSB3b3JrcyBvbiBub24tYW1iaWd1b3VzIGtleXMgKHJlZmluZWQgZnJhZ21lbnQgaXMgYWx3YXlzIG5vbi1hbWJpZ3VvdXMpXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGtleSk7XHJcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIGluZm86IHsga2V5IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBtZXRob2Q7XHJcbn1cclxuLy8gVGhlIGNvbWJpbmF0aW9uIG9mIFR5cGVTY3J5cGUsIFByaXZhdGUgRmllbGRzIGFuZCBQcm94aWVzIG1ha2VzXHJcbi8vIHRoZSB3b3JsZCBnbyBib29tOyBzbyB3ZSBoaWRlIHZhcmlhYmxlcyB3aXRoIHNvbWUgdHJpY2tlcnkga2VlcGluZ1xyXG4vLyBhIHN5bWJvbCBhdHRhY2hlZCB0byBlYWNoIEJhc2VDb250cmFjdCB3aGljaCBpdHMgc3ViLWNsYXNzIChldmVuXHJcbi8vIHZpYSBhIFByb3h5KSBjYW4gcmVhY2ggYW5kIHVzZSB0byBsb29rIHVwIGl0cyBpbnRlcm5hbCB2YWx1ZXMuXHJcbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNJbnRlcm5hbF9jb250cmFjdFwiKTtcclxuY29uc3QgaW50ZXJuYWxWYWx1ZXMgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiBzZXRJbnRlcm5hbChjb250cmFjdCwgdmFsdWVzKSB7XHJcbiAgICBpbnRlcm5hbFZhbHVlcy5zZXQoY29udHJhY3RbaW50ZXJuYWxdLCB2YWx1ZXMpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEludGVybmFsKGNvbnRyYWN0KSB7XHJcbiAgICByZXR1cm4gaW50ZXJuYWxWYWx1ZXMuZ2V0KGNvbnRyYWN0W2ludGVybmFsXSk7XHJcbn1cclxuZnVuY3Rpb24gaXNEZWZlcnJlZCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiAoXCJnZXRUb3BpY0ZpbHRlclwiIGluIHZhbHVlKSAmJlxyXG4gICAgICAgICh0eXBlb2YgKHZhbHVlLmdldFRvcGljRmlsdGVyKSA9PT0gXCJmdW5jdGlvblwiKSAmJiB2YWx1ZS5mcmFnbWVudCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpIHtcclxuICAgIGxldCB0b3BpY3M7XHJcbiAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xyXG4gICAgLy8gQ29udmVydCBuYW1lZCBldmVudHMgdG8gdG9waWNIYXNoIGFuZCBnZXQgdGhlIGZyYWdtZW50IGZvclxyXG4gICAgLy8gZXZlbnRzIHdoaWNoIG5lZWQgZGVjb25zdHJ1Y3RpbmcuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcclxuICAgICAgICBjb25zdCB0b3BpY0hhc2hpZnkgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZSwgMzIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChuYW1lKTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudC50b3BpY0hhc2g7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBBcnJheSBvZiBUb3BpY3MgYW5kIE5hbWVzOyBlLmcuIGBbIFwiMHgxMjM0Li4uODlhYlwiLCBcIlRyYW5zZmVyKGFkZHJlc3MpXCIgXWBcclxuICAgICAgICB0b3BpY3MgPSBldmVudC5tYXAoKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlLm1hcCh0b3BpY0hhc2hpZnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0b3BpY0hhc2hpZnkoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChldmVudCA9PT0gXCIqXCIpIHtcclxuICAgICAgICB0b3BpY3MgPSBbbnVsbF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgKGV2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhldmVudCwgMzIpKSB7XHJcbiAgICAgICAgICAgIC8vIFRvcGljIEhhc2hcclxuICAgICAgICAgICAgdG9waWNzID0gW2V2ZW50XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5hbWUgb3IgU2lnbmF0dXJlOyBlLmcuIGBcIlRyYW5zZmVyXCIsIGBcIlRyYW5zZmVyKGFkZHJlc3MpXCJgXHJcbiAgICAgICAgICAgIGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcImV2ZW50XCIsIGV2ZW50KTtcclxuICAgICAgICAgICAgdG9waWNzID0gW2ZyYWdtZW50LnRvcGljSGFzaF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNEZWZlcnJlZChldmVudCkpIHtcclxuICAgICAgICAvLyBEZWZlcnJlZCBUb3BpYyBGaWx0ZXI7IGUuZy4gYGNvbnRyYWN0LmZpbHRlci5UcmFuc2Zlcihmcm9tKWBcclxuICAgICAgICB0b3BpY3MgPSBhd2FpdCBldmVudC5nZXRUb3BpY0ZpbHRlcigpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoXCJmcmFnbWVudFwiIGluIGV2ZW50KSB7XHJcbiAgICAgICAgLy8gQ29udHJhY3RFdmVudDsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyYFxyXG4gICAgICAgIGZyYWdtZW50ID0gZXZlbnQuZnJhZ21lbnQ7XHJcbiAgICAgICAgdG9waWNzID0gW2ZyYWdtZW50LnRvcGljSGFzaF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIGV2ZW50IG5hbWVcIiwgXCJldmVudFwiLCBldmVudCk7XHJcbiAgICB9XHJcbiAgICAvLyBOb3JtYWxpemUgdG9waWNzIGFuZCBzb3J0IFRvcGljU2V0c1xyXG4gICAgdG9waWNzID0gdG9waWNzLm1hcCgodCkgPT4ge1xyXG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShuZXcgU2V0KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKS52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtc1swXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpdGVtcy5zb3J0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgdGFnID0gdG9waWNzLm1hcCgodCkgPT4ge1xyXG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdC5qb2luKFwifFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9KS5qb2luKFwiJlwiKTtcclxuICAgIHJldHVybiB7IGZyYWdtZW50LCB0YWcsIHRvcGljcyB9O1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGhhc1N1Yihjb250cmFjdCwgZXZlbnQpIHtcclxuICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwoY29udHJhY3QpO1xyXG4gICAgcmV0dXJuIHN1YnMuZ2V0KChhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCkpLnRhZykgfHwgbnVsbDtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBnZXRTdWIoY29udHJhY3QsIG9wZXJhdGlvbiwgZXZlbnQpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSBvdXIgcnVubmVyIGNhbiBhY3R1YWxseSBzdWJzY3JpYmUgdG8gZXZlbnRzXHJcbiAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XHJcbiAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc3Vic2NyaWJpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XHJcbiAgICBjb25zdCB7IGZyYWdtZW50LCB0YWcsIHRvcGljcyB9ID0gYXdhaXQgZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpO1xyXG4gICAgY29uc3QgeyBhZGRyLCBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XHJcbiAgICBsZXQgc3ViID0gc3Vicy5nZXQodGFnKTtcclxuICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IGNvbnRyYWN0KTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGFkZHJlc3MsIHRvcGljcyB9O1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGxvZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xyXG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIGZyYWdtZW50IGlzIG51bGwsIHdlIGRvIG5vdCBkZWNvbnN0cnVjdCB0aGUgYXJncyB0byBlbWl0XHJcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBfZm91bmRGcmFnbWVudCA9IGZvdW5kRnJhZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gZnJhZ21lbnQgPyBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIChsaXN0ZW5lcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RFdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgX2ZvdW5kRnJhZ21lbnQsIGxvZyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBbXSwgKGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgbG9nKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgc3RhcnRpbmcgPSBbXTtcclxuICAgICAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0YXJ0aW5nLnB1c2gocHJvdmlkZXIub24oZmlsdGVyLCBsaXN0ZW5lcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc3RvcCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHN0YXJ0ZWQgPSBzdGFydGluZztcclxuICAgICAgICAgICAgc3RhcnRpbmcgPSBbXTtcclxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc3RhcnRlZCk7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLm9mZihmaWx0ZXIsIGxpc3RlbmVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHN1YiA9IHsgdGFnLCBsaXN0ZW5lcnM6IFtdLCBzdGFydCwgc3RvcCB9O1xyXG4gICAgICAgIHN1YnMuc2V0KHRhZywgc3ViKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdWI7XHJcbn1cclxuLy8gV2UgdXNlIHRoaXMgdG8gZW5zdXJlIG9uZSBlbWl0IHJlc29sdmVzIGJlZm9yZSBmaXJpbmcgdGhlIG5leHQgdG9cclxuLy8gZW5zdXJlIGNvcnJlY3Qgb3JkZXJpbmcgKG5vdGUgdGhpcyBjYW5ub3QgdGhyb3cgYW5kIGp1c3QgYWRkcyB0aGVcclxuLy8gbm90aWNlIHRvIHRoZSBldmVudCBxdWV1IHVzaW5nIHNldFRpbWVvdXQpLlxyXG5sZXQgbGFzdEVtaXQgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuYXN5bmMgZnVuY3Rpb24gX2VtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYykge1xyXG4gICAgYXdhaXQgbGFzdEVtaXQ7XHJcbiAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIoY29udHJhY3QsIGV2ZW50KTtcclxuICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY291bnQgPSBzdWIubGlzdGVuZXJzLmxlbmd0aDtcclxuICAgIHN1Yi5saXN0ZW5lcnMgPSBzdWIubGlzdGVuZXJzLmZpbHRlcigoeyBsaXN0ZW5lciwgb25jZSB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGFzc0FyZ3MgPSBBcnJheS5mcm9tKGFyZ3MpO1xyXG4gICAgICAgIGlmIChwYXlsb2FkRnVuYykge1xyXG4gICAgICAgICAgICBwYXNzQXJncy5wdXNoKHBheWxvYWRGdW5jKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChjb250cmFjdCwgLi4ucGFzc0FyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgIHJldHVybiAhb25jZTtcclxuICAgIH0pO1xyXG4gICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgc3ViLnN0b3AoKTtcclxuICAgICAgICBnZXRJbnRlcm5hbChjb250cmFjdCkuc3Vicy5kZWxldGUoc3ViLnRhZyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGNvdW50ID4gMCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IGxhc3RFbWl0O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgIGNvbnN0IHJlc3VsdFByb21pc2UgPSBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKTtcclxuICAgIGxhc3RFbWl0ID0gcmVzdWx0UHJvbWlzZTtcclxuICAgIHJldHVybiBhd2FpdCByZXN1bHRQcm9taXNlO1xyXG59XHJcbmNvbnN0IHBhc3NQcm9wZXJ0aWVzID0gW1widGhlblwiXTtcclxuZXhwb3J0IGNsYXNzIEJhc2VDb250cmFjdCB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdGFyZ2V0IHRvIGNvbm5lY3QgdG8uXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgY2FuIGJlIGFuIGFkZHJlc3MsIEVOUyBuYW1lIG9yIGFueSBbW0FkZHJlc3NhYmxlXV0sIHN1Y2ggYXNcclxuICAgICAqICBhbm90aGVyIGNvbnRyYWN0LiBUbyBnZXQgdGhlIHJlc292bGVkIGFkZHJlc3MsIHVzZSB0aGUgYGBnZXRBZGRyZXNzYGBcclxuICAgICAqICBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjb250cmFjdCBJbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGludGVyZmFjZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcnVubmVyLiBUaGlzIGlzIGdlbmVyYWxseSBhIFtbUHJvdmlkZXJdXSBvciBhXHJcbiAgICAgKiAgW1tTaWduZXJdXSwgd2hpY2ggZGljdGF0ZXMgd2hhdCBvcGVyYXRpb25zIGFyZSBzdXBwb3J0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogIEZvciBleGFtcGxlLCBhICoqQ29udHJhY3QqKiBjb25uZWN0ZWQgdG8gYSBbW1Byb3ZpZGVyXV0gbWF5XHJcbiAgICAgKiAgb25seSBleGVjdXRlIHJlYWQtb25seSBvcGVyYXRpb25zLlxyXG4gICAgICovXHJcbiAgICBydW5uZXI7XHJcbiAgICAvKipcclxuICAgICAqICBBbGwgdGhlIEV2ZW50cyBhdmFpbGFibGUgb24gdGhpcyBjb250cmFjdC5cclxuICAgICAqL1xyXG4gICAgZmlsdGVycztcclxuICAgIC8qKlxyXG4gICAgICogIEBfaWdub3JlOlxyXG4gICAgICovXHJcbiAgICBbaW50ZXJuYWxdO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZhbGxiYWNrIG9yIHJlY2VpdmUgZnVuY3Rpb24gaWYgYW55LlxyXG4gICAgICovXHJcbiAgICBmYWxsYmFjaztcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgY29udHJhY3QgY29ubmVjdGVkIHRvICUldGFyZ2V0JSUgd2l0aCB0aGUgJSVhYmklJSBhbmRcclxuICAgICAqICBvcHRpb25hbGx5IGNvbm5lY3RlZCB0byBhICUlcnVubmVyJSUgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGJlaGFsZlxyXG4gICAgICogIG9mLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGFiaSwgcnVubmVyLCBfZGVwbG95VHgpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIgfHwgaXNBZGRyZXNzYWJsZSh0YXJnZXQpLCBcImludmFsaWQgdmFsdWUgZm9yIENvbnRyYWN0IHRhcmdldFwiLCBcInRhcmdldFwiLCB0YXJnZXQpO1xyXG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZmFjZSA9IEludGVyZmFjZS5mcm9tKGFiaSk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHRhcmdldCwgcnVubmVyLCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZToge30gfSk7XHJcbiAgICAgICAgbGV0IGFkZHJQcm9taXNlO1xyXG4gICAgICAgIGxldCBhZGRyID0gbnVsbDtcclxuICAgICAgICBsZXQgZGVwbG95VHggPSBudWxsO1xyXG4gICAgICAgIGlmIChfZGVwbG95VHgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihydW5uZXIpO1xyXG4gICAgICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXHJcbiAgICAgICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcclxuICAgICAgICAgICAgZGVwbG95VHggPSBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKHRoaXMuaW50ZXJmYWNlLCBwcm92aWRlciwgX2RlcGxveVR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN1YnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdGFyZ2V0IGFzIHRoZSBhZGRyZXNzXHJcbiAgICAgICAgaWYgKHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgYWRkciA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIGFkZHJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGdldFJ1bm5lcihydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNhblJlc29sdmUocmVzb2x2ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgbmFtZSByZXNvbHV0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCJcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFkZHJQcm9taXNlID0gcmVzb2x2ZXIucmVzb2x2ZU5hbWUodGFyZ2V0KS50aGVuKChhZGRyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3IoXCJhbiBFTlMgbmFtZSB1c2VkIGZvciBhIGNvbnRyYWN0IHRhcmdldCBtdXN0IGJlIGNvcnJlY3RseSBjb25maWd1cmVkXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWRkclByb21pc2UgPSB0YXJnZXQuZ2V0QWRkcmVzcygpLnRoZW4oKGFkZHIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNldCBvdXIgcHJpdmF0ZSB2YWx1ZXNcclxuICAgICAgICBzZXRJbnRlcm5hbCh0aGlzLCB7IGFkZHJQcm9taXNlLCBhZGRyLCBkZXBsb3lUeCwgc3VicyB9KTtcclxuICAgICAgICAvLyBBZGQgdGhlIGV2ZW50IGZpbHRlcnNcclxuICAgICAgICBjb25zdCBmaWx0ZXJzID0gbmV3IFByb3h5KHt9LCB7XHJcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnQocHJvcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJrZXlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGlmIChwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApIHx8IHRoaXMuaW50ZXJmYWNlLmhhc0V2ZW50KFN0cmluZyhwcm9wKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmlsdGVycyB9KTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgZmFsbGJhY2s6ICgoaWZhY2UucmVjZWl2ZSB8fCBpZmFjZS5mYWxsYmFjaykgPyAoYnVpbGRXcmFwcGVkRmFsbGJhY2sodGhpcykpIDogbnVsbClcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBSZXR1cm4gYSBQcm94eSB0aGF0IHdpbGwgcmVzcG9uZCB0byBmdW5jdGlvbnNcclxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcclxuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiB0YXJnZXQgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVW5kZWZpbmVkIHByb3BlcnRpZXMgc2hvdWxkIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRGdW5jdGlvbihwcm9wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiB0YXJnZXQgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmludGVyZmFjZS5oYXNGdW5jdGlvbihwcm9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgdGFyZ2V0IGFuZCBBQkksIGJ1dFxyXG4gICAgICogIGEgZGlmZmVyZW50ICUlcnVubmVyJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbm5lY3QocnVubmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlQ29udHJhY3QodGhpcy50YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCBydW5uZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgQUJJIGFuZCBydW5uZXIsIGJ1dFxyXG4gICAgICogIGEgZGlmZmVyZW50ICUldGFyZ2V0JSUuXHJcbiAgICAgKi9cclxuICAgIGF0dGFjaCh0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnJ1bm5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIHJlc29sdmVkIGFkZHJlc3Mgb2YgdGhpcyBDb250cmFjdC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIGF3YWl0IGdldEludGVybmFsKHRoaXMpLmFkZHJQcm9taXNlOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIGRlcGxveWVkIGJ5dGVjb2RlIG9yIG51bGwgaWYgbm8gYnl0ZWNvZGUgaXMgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldERlcGxveWVkQ29kZSgpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcclxuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwicnVubmVyIGRvZXMgbm90IHN1cHBvcnQgLnByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImdldERlcGxveWVkQ29kZVwiIH0pO1xyXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBwcm92aWRlci5nZXRDb2RlKGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpKTtcclxuICAgICAgICBpZiAoY29kZSA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29kZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmUgdG8gdGhpcyBDb250cmFjdCBvbmNlIHRoZSBieXRlY29kZSBoYXMgYmVlbiBkZXBsb3llZCwgb3JcclxuICAgICAqICByZXNvbHZlIGltbWVkaWF0ZWx5IGlmIGFscmVhZHkgZGVwbG95ZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHdhaXRGb3JEZXBsb3ltZW50KCkge1xyXG4gICAgICAgIC8vIFdlIGhhdmUgdGhlIGRlcGxveWVtZW50IHRyYW5zYWN0aW9uOyBqdXN0IHVzZSB0aGF0ICh0aHJvd3MgaWYgZGVwbG95ZW1lbnQgZmFpbHMpXHJcbiAgICAgICAgY29uc3QgZGVwbG95VHggPSB0aGlzLmRlcGxveW1lbnRUcmFuc2FjdGlvbigpO1xyXG4gICAgICAgIGlmIChkZXBsb3lUeCkge1xyXG4gICAgICAgICAgICBhd2FpdCBkZXBsb3lUeC53YWl0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBmb3IgY29kZVxyXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xyXG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjYW4gc3Vic2NyaWJlIHRvIGEgcHJvdmlkZXIgZXZlbnRcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcclxuICAgICAgICBhc3NlcnQocHJvdmlkZXIgIT0gbnVsbCwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwid2FpdEZvckRlcGxveW1lbnRcIiB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGVja0NvZGUgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCBjaGVja0NvZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2hlY2tDb2RlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIHRyYW5zYWN0aW9uIHVzZWQgdG8gZGVwbG95IHRoaXMgY29udHJhY3QuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaWYgdGhpcyBpbnN0YW5jZSB3YXMgcmV0dXJuZWQgZnJvbSBhXHJcbiAgICAgKiAgW1tDb250cmFjdEZhY3RvcnldXS5cclxuICAgICAqL1xyXG4gICAgZGVwbG95bWVudFRyYW5zYWN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbCh0aGlzKS5kZXBsb3lUeDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XHJcbiAgICAgKiAgbWV0aG9kIG5hbWUgY29uZmxpY3RzIHdpdGggYSBKYXZhU2NyaXB0IG5hbWUgc3VjaCBhcyBgYHByb3RvdHlwZWBgIG9yXHJcbiAgICAgKiAgd2hlbiB1c2luZyBhIENvbnRyYWN0IHByb2dyYW1hdGljYWxseS5cclxuICAgICAqL1xyXG4gICAgZ2V0RnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZ1bmMgPSBidWlsZFdyYXBwZWRNZXRob2QodGhpcywga2V5KTtcclxuICAgICAgICByZXR1cm4gZnVuYztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiB0aGUgZXZlbnQgZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XHJcbiAgICAgKiAgZXZlbnQgbmFtZSBjb25mbGljdHMgd2l0aCBhIEphdmFTY3JpcHQgbmFtZSBzdWNoIGFzIGBgcHJvdG90eXBlYGAgb3JcclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxyXG4gICAgICovXHJcbiAgICBnZXRFdmVudChrZXkpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGtleSA9IGtleS5mb3JtYXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkV3JhcHBlZEV2ZW50KHRoaXMsIGtleSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBAX2lnbm9yZTpcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcXVlcnlUcmFuc2FjdGlvbihoYXNoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgLy8gQFRPRE86IHRoaXMgaXMgYSBub24tYmFja3dhcmRzIGNvbXBhdGlibGUgY2hhbmdlLCBidXQgd2lsbCBiZSBhZGRlZFxyXG4gICAgLy8gICAgICAgIGluIHY3IGFuZCBpbiBhIHBvdGVudGlhbCBTbWFydENvbnRyYWN0IGNsYXNzIGluIGFuIHVwY29taW5nXHJcbiAgICAvLyAgICAgICAgdjYgcmVsZWFzZVxyXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2g6IHN0cmluZyk6IFByb21pc2U8bnVsbCB8IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0PiB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XHJcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBoYXZlIGEgcHJvdmlkZXJcIixcclxuICAgICAgICAgICAgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlUcmFuc2FjdGlvblwiIH0pO1xyXG5cclxuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xyXG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmludGVyZmFjZSwgcHJvdmlkZXIsIHJlY2VpcHQpO1xyXG4gICAgfVxyXG4gICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogIFByb3ZpZGUgaGlzdG9yaWMgYWNjZXNzIHRvIGV2ZW50IGRhdGEgZm9yICUlZXZlbnQlJSBpbiB0aGUgcmFuZ2VcclxuICAgICAqICAlJWZyb21CbG9jayUlIChkZWZhdWx0OiBgYDBgYCkgdG8gJSV0b0Jsb2NrJSUgKGRlZmF1bHQ6IGBgXCJsYXRlc3RcImBgKVxyXG4gICAgICogIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcXVlcnlGaWx0ZXIoZXZlbnQsIGZyb21CbG9jaywgdG9CbG9jaykge1xyXG4gICAgICAgIGlmIChmcm9tQmxvY2sgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmcm9tQmxvY2sgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9CbG9jayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRvQmxvY2sgPSBcImxhdGVzdFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGFkZHIsIGFkZHJQcm9taXNlIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcclxuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogKGF3YWl0IGFkZHJQcm9taXNlKSk7XHJcbiAgICAgICAgY29uc3QgeyBmcmFnbWVudCwgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKHRoaXMsIGV2ZW50KTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGFkZHJlc3MsIHRvcGljcywgZnJvbUJsb2NrLCB0b0Jsb2NrIH07XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XHJcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBoYXZlIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlGaWx0ZXJcIiB9KTtcclxuICAgICAgICByZXR1cm4gKGF3YWl0IHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKSkubWFwKChsb2cpID0+IHtcclxuICAgICAgICAgICAgbGV0IGZvdW5kRnJhZ21lbnQgPSBmcmFnbWVudDtcclxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRMb2cobG9nLCB0aGlzLmludGVyZmFjZSwgZm91bmRGcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nKGxvZywgcHJvdmlkZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgb24oZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgZ2V0U3ViKHRoaXMsIFwib25cIiwgZXZlbnQpO1xyXG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcclxuICAgICAgICBzdWIuc3RhcnQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEFkZCBhbiBldmVudCAlJWxpc3RlbmVyJSUgZm9yIHRoZSAlJWV2ZW50JSUsIGJ1dCByZW1vdmUgdGhlIGxpc3RlbmVyXHJcbiAgICAgKiAgYWZ0ZXIgaXQgaXMgZmlyZWQgb25jZS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgb25jZShldmVudCwgbGlzdGVuZXIpIHtcclxuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvbmNlXCIsIGV2ZW50KTtcclxuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcclxuICAgICAgICBzdWIuc3RhcnQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEVtaXQgYW4gJSVldmVudCUlIGNhbGxpbmcgYWxsIGxpc3RlbmVycyB3aXRoICUlYXJncyUlLlxyXG4gICAgICpcclxuICAgICAqICBSZXNvbHZlcyB0byBgYHRydWVgYCBpZiBhbnkgbGlzdGVuZXJzIHdlcmUgY2FsbGVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVtaXQodGhpcywgZXZlbnQsIGFyZ3MsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgb2YgJSVldmVudCUlIG9yIHRoZSB0b3RhbCBudW1iZXJcclxuICAgICAqICBvZiBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKCFzdWIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcclxuICAgICAgICBsZXQgdG90YWwgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIHRvdGFsICs9IGxpc3RlbmVycy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b3RhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBsaXN0ZW5lcnMgc3Vic2NyaWJlZCB0byAlJWV2ZW50JSUgb3IgYWxsIGxpc3RlbmVyc1xyXG4gICAgICogIGlmIHVuc3BlY2lmaWVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBsaXN0ZW5lcnMoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKCFzdWIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlbW92ZSB0aGUgJSVsaXN0ZW5lciUlIGZyb20gdGhlIGxpc3RlbmVycyBmb3IgJSVldmVudCUlIG9yIHJlbW92ZVxyXG4gICAgICogIGFsbCBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIG9mZihldmVudCwgbGlzdGVuZXIpIHtcclxuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xyXG4gICAgICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgc3ViLnN0b3AoKTtcclxuICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuc3Vicy5kZWxldGUoc3ViLnRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIGZvciAlJWV2ZW50JSUgb3IgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaWZcclxuICAgICAqICB1bnNwZWNpZmllZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XHJcbiAgICAgICAgICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdWIuc3RvcCgpO1xyXG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YWcsIHN0b3AgfSBvZiBzdWJzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICBzdG9wKCk7XHJcbiAgICAgICAgICAgICAgICBzdWJzLmRlbGV0ZSh0YWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQWxpYXMgZm9yIFtvbl0uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBBbGlhcyBmb3IgW29mZl0uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IENsYXNzIGZvciB0aGUgJSVhYmklJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ1aWxkQ2xhc3MoYWJpKSB7XHJcbiAgICAgICAgY2xhc3MgQ3VzdG9tQ29udHJhY3QgZXh0ZW5kcyBCYXNlQ29udHJhY3Qge1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBydW5uZXIgPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzdXBlcihhZGRyZXNzLCBhYmksIHJ1bm5lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEN1c3RvbUNvbnRyYWN0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEJhc2VDb250cmFjdCB3aXRoIGEgc3BlY2lmaWVkIEludGVyZmFjZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20odGFyZ2V0LCBhYmksIHJ1bm5lcikge1xyXG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyB0aGlzKHRhcmdldCwgYWJpLCBydW5uZXIpO1xyXG4gICAgICAgIHJldHVybiBjb250cmFjdDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfQ29udHJhY3RCYXNlKCkge1xyXG4gICAgcmV0dXJuIEJhc2VDb250cmFjdDtcclxufVxyXG4vKipcclxuICogIEEgW1tCYXNlQ29udHJhY3RdXSB3aXRoIG5vIHR5cGUgZ3VhcmRzIG9uIGl0cyBtZXRob2RzIG9yIGV2ZW50cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb250cmFjdCBleHRlbmRzIF9Db250cmFjdEJhc2UoKSB7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QuanMubWFwIiwiLyoqXHJcbiAqICBFTlMgaXMgYSBzZXJ2aWNlIHdoaWNoIGFsbG93cyBlYXN5LXRvLXJlbWVtYmVyIG5hbWVzIHRvIG1hcCB0b1xyXG4gKiAgbmV0d29yayBhZGRyZXNzZXMuXHJcbiAqXHJcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvZW5zLXJlc29sdmVyOkVOUyBSZXNvbHZlciAgW2Fib3V0LWVucy1yc29sdmVyXVxyXG4gKi9cclxuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBkbnNFbmNvZGUsIG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvQmVIZXgsIGRlZmluZVByb3BlcnRpZXMsIGVuY29kZUJhc2U1OCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNFcnJvciwgRmV0Y2hSZXF1ZXN0IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbi8vIEBUT0RPOiBUaGlzIHNob3VsZCB1c2UgdGhlIGZldGNoLWRhdGE6aXBmcyBnYXRld2F5XHJcbi8vIFRyaW0gb2ZmIHRoZSBpcGZzOi8vIHByZWZpeCBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0IGdhdGV3YXkgVVJMXHJcbmZ1bmN0aW9uIGdldElwZnNMaW5rKGxpbmspIHtcclxuICAgIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC9pcGZzXFwvL2kpKSB7XHJcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDEyKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcLy9pKSkge1xyXG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZyg3KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIElQRlMgZm9ybWF0XCIsIFwibGlua1wiLCBsaW5rKTtcclxuICAgIH1cclxuICAgIHJldHVybiBgaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzLyR7bGlua31gO1xyXG59XHJcbjtcclxuO1xyXG4vKipcclxuICogIEEgcHJvdmlkZXIgcGx1Z2luIHN1cGVyLWNsYXNzIGZvciBwcm9jZXNzaW5nIG11bHRpY29pbiBhZGRyZXNzIHR5cGVzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBuYW1lLlxyXG4gICAgICovXHJcbiAgICBuYW1lO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk11bHRpY29pblByb3ZpZGVyUGx1aW5nKiogZm9yICUlbmFtZSUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XHJcbiAgICB9XHJcbiAgICBjb25uZWN0KHByb2l2ZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlY29pblR5cGUlJSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBwbHVnaW4uXHJcbiAgICAgKi9cclxuICAgIHN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZW5jb2RlZCAlJWFkZHJlc3MlJSBmb3IgJSVjb2luVHlwZSUlLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBlbmNvZGVBZGRyZXNzKGNvaW5UeXBlLCBhZGRyZXNzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY29pblwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBkZWNvZGVkICUlZGF0YSUlIGZvciAlJWNvaW5UeXBlJSUuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGRlY29kZUFkZHJlc3MoY29pblR5cGUsIGRhdGEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IEJhc2ljTXVsdGljb2luUGx1Z2luSWQgPSBcIm9yZy5ldGhlcnMucGx1Z2lucy5wcm92aWRlci5CYXNpY011bHRpY29pblwiO1xyXG4vKipcclxuICogIEEgKipCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luKiogcHJvdmlkZXMgc2VydmljZSBmb3IgY29tbW9uXHJcbiAqICBjb2luIHR5cGVzLCB3aGljaCBkbyBub3QgcmVxdWlyZSBhZGRpdGlvbmFsIGxpYnJhcmllcyB0byBlbmNvZGUgb3JcclxuICogIGRlY29kZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luIGV4dGVuZHMgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbWF0Y2hlcklwZnMgPSBuZXcgUmVnRXhwKFwiXihpcGZzKTovXFwvKC4qKSRcIiwgXCJpXCIpO1xyXG5jb25zdCBtYXRjaGVycyA9IFtcclxuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxyXG4gICAgbmV3IFJlZ0V4cChcIl4oZGF0YSk6KC4qKSRcIiwgXCJpXCIpLFxyXG4gICAgbWF0Y2hlcklwZnMsXHJcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxyXG5dO1xyXG4vKipcclxuICogIEEgY29ubmVjdGVkIG9iamVjdCB0byBhIHJlc29sdmVkIEVOUyBuYW1lIHJlc29sdmVyLCB3aGljaCBjYW4gYmVcclxuICogIHVzZWQgdG8gcXVlcnkgYWRkaXRpb25hbCBkZXRhaWxzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVuc1Jlc29sdmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcHJvdmlkZXIuXHJcbiAgICAgKi9cclxuICAgIHByb3ZpZGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIHJlc29sdmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRyZXNzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5hbWUgdGhpcyByZXNvbHZlciB3YXMgcmVzb2x2ZWQgYWdhaW5zdC5cclxuICAgICAqL1xyXG4gICAgbmFtZTtcclxuICAgIC8vIEZvciBFSVAtMjU0NCBuYW1lcywgdGhlIGFuY2VzdG9yIHRoYXQgcHJvdmlkZWQgdGhlIHJlc29sdmVyXHJcbiAgICAjc3VwcG9ydHMyNTQ0O1xyXG4gICAgI3Jlc29sdmVyO1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUpIHtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUgfSk7XHJcbiAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLiNyZXNvbHZlciA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBbXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gc3VwcG9ydHNJbnRlcmZhY2UoYnl0ZXM0KSB2aWV3IHJldHVybnMgKGJvb2wpXCIsXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZShieXRlcywgYnl0ZXMpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyLCB1aW50KSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxyXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHRleHQoYnl0ZXMzMiwgc3RyaW5nKSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcclxuICAgICAgICAgICAgXCJmdW5jdGlvbiBjb250ZW50aGFzaChieXRlczMyKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxyXG4gICAgICAgIF0sIHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRydWUgaWYgdGhlIHJlc29sdmVyIHN1cHBvcnRzIHdpbGRjYXJkIHJlc29sdXRpb24uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHN1cHBvcnRzV2lsZGNhcmQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI3N1cHBvcnRzMjU0NCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNyZXNvbHZlci5zdXBwb3J0c0ludGVyZmFjZShcIjB4OTA2MWI5MjNcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXaWxkY2FyZCByZXNvbHZlcnMgbXVzdCB1bmRlcnN0YW5kIHN1cHBvcnRzSW50ZXJmYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0cnVlLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0IGZ1dHVyZSBhdHRlbXB0cyB0cnkgYWdhaW4uLi5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc3VwcG9ydHMyNTQ0O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgI2ZldGNoKGZ1bmNOYW1lLCBwYXJhbXMpIHtcclxuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5zbGljZSgpO1xyXG4gICAgICAgIGNvbnN0IGlmYWNlID0gdGhpcy4jcmVzb2x2ZXIuaW50ZXJmYWNlO1xyXG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXJzIGlzIGFsd2F5cyB0aGUgbm9kZWhhc2hcclxuICAgICAgICBwYXJhbXMudW5zaGlmdChuYW1laGFzaCh0aGlzLm5hbWUpKTtcclxuICAgICAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xyXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnN1cHBvcnRzV2lsZGNhcmQoKSkge1xyXG4gICAgICAgICAgICBmcmFnbWVudCA9IGlmYWNlLmdldEZ1bmN0aW9uKGZ1bmNOYW1lKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm1pc3NpbmcgZnJhZ21lbnRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHtcclxuICAgICAgICAgICAgICAgIGluZm86IHsgZnVuY05hbWUgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcGFyYW1zID0gW1xyXG4gICAgICAgICAgICAgICAgZG5zRW5jb2RlKHRoaXMubmFtZSwgMjU1KSxcclxuICAgICAgICAgICAgICAgIGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcGFyYW1zKVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBmdW5jTmFtZSA9IFwicmVzb2x2ZShieXRlcyxieXRlcylcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1zLnB1c2goe1xyXG4gICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Jlc29sdmVyW2Z1bmNOYW1lXSguLi5wYXJhbXMpO1xyXG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWNvaW5UeXBlJSUgb3IgbnVsbCBpZiB0aGVcclxuICAgICAqICBwcm92aWRlZCAlJWNvaW5UeXBlJSUgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEFkZHJlc3MoY29pblR5cGUpIHtcclxuICAgICAgICBpZiAoY29pblR5cGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29pblR5cGUgPT09IDYwKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMilcIik7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBaZXJvQWRkcmVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcnkgZGVjb2RpbmcgaXRzIEVWTSBjYW5vbmljYWwgY2hhaW4gYXMgYW4gRVZNIGNoYWluIGFkZHJlc3MgZmlyc3RcclxuICAgICAgICBpZiAoY29pblR5cGUgPj0gMCAmJiBjb2luVHlwZSA8IDB4ODAwMDAwMDApIHtcclxuICAgICAgICAgICAgbGV0IGV0aENvaW5UeXBlID0gY29pblR5cGUgKyAweDgwMDAwMDAwO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2V0aENvaW5UeXBlXSk7XHJcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCAyMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb2luUGx1Z2luID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnByb3ZpZGVyLnBsdWdpbnMpIHtcclxuICAgICAgICAgICAgaWYgKCEocGx1Z2luIGluc3RhbmNlb2YgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGx1Z2luLnN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb2luUGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvaW5QbHVnaW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyLHVpbnQyNTZcIilcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2NvaW5UeXBlXSk7XHJcbiAgICAgICAgLy8gTm8gYWRkcmVzc1xyXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb21wdXRlIHRoZSBhZGRyZXNzXHJcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IGNvaW5QbHVnaW4uZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSk7XHJcbiAgICAgICAgaWYgKGFkZHJlc3MgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCBjb2luIGRhdGFgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxcclxuICAgICAgICAgICAgaW5mbzogeyBjb2luVHlwZSwgZGF0YSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgRUlQLTYzNCB0ZXh0IHJlY29yZCBmb3IgJSVrZXklJSwgb3IgYGBudWxsYGBcclxuICAgICAqICBpZiB1bmNvbmZpZ3VyZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRleHQoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwidGV4dChieXRlczMyLHN0cmluZylcIiwgW2tleV0pO1xyXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJzb2x2ZXMgdG8gdGhlIGNvbnRlbnQtaGFzaCBvciBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldENvbnRlbnRIYXNoKCkge1xyXG4gICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJjb250ZW50aGFzaChieXRlczMyKVwiKTtcclxuICAgICAgICAvLyBObyBjb250ZW50aGFzaFxyXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJUEZTIChDSUQ6IDEsIFR5cGU6IDcwPURBRy1QQiwgNzI9bGlicDJwLWtleSlcclxuICAgICAgICBjb25zdCBpcGZzID0gZGF0YS5tYXRjaCgvXjB4KGUzMDEwMTcwfGU1MDEwMTcyKSgoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XHJcbiAgICAgICAgaWYgKGlwZnMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gKGlwZnNbMV0gPT09IFwiZTMwMTAxNzBcIikgPyBcImlwZnNcIiA6IFwiaXBuc1wiO1xyXG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChpcGZzWzRdLCAxNik7XHJcbiAgICAgICAgICAgIGlmIChpcGZzWzVdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NjaGVtZX06L1xcLyR7ZW5jb2RlQmFzZTU4KFwiMHhcIiArIGlwZnNbMl0pfWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3dhcm0gKENJRDogMSwgVHlwZTogc3dhcm0tbWFuaWZlc3Q7IGhhc2gvbGVuZ3RoIGhhcmQtY29kZWQgdG8ga2VjY2FrMjU2LzMyKVxyXG4gICAgICAgIGNvbnN0IHN3YXJtID0gZGF0YS5tYXRjaCgvXjB4ZTQwMTAxZmEwMTFiMjAoWzAtOWEtZl0qKSQvKTtcclxuICAgICAgICBpZiAoc3dhcm0gJiYgc3dhcm1bMV0ubGVuZ3RoID09PSA2NCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYGJ6ejovXFwvJHtzd2FybVsxXX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvbnRlbnQgaGFzaCBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0Q29udGVudEhhc2goKVwiLFxyXG4gICAgICAgICAgICBpbmZvOiB7IGRhdGEgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGF2YXRhciB1cmwgb3IgYGBudWxsYGAgaWYgdGhlIGF2YXRhciBpcyBlaXRoZXJcclxuICAgICAqICB1bmNvbmZpZ3VyZWQgb3IgaW5jb3JyZWN0bHkgY29uZmlndXJlZCAoZS5nLiByZWZlcmVuY2VzIGFuIE5GVFxyXG4gICAgICogIG5vdCBvd25lZCBieSB0aGUgYWRkcmVzcykuXHJcbiAgICAgKlxyXG4gICAgICogIElmIGRpYWdub3NpbmcgaXNzdWVzIHdpdGggY29uZmlndXJhdGlvbnMsIHRoZSBbW19nZXRBdmF0YXJdXVxyXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZnVsLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRBdmF0YXIoKSB7XHJcbiAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5fZ2V0QXZhdGFyKCk7XHJcbiAgICAgICAgcmV0dXJuIGF2YXRhci51cmw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBXaGVuIHJlc29sdmluZyBhbiBhdmF0YXIsIHRoZXJlIGFyZSBtYW55IHN0ZXBzIGludm9sdmVkLCBzdWNoXHJcbiAgICAgKiAgZmV0Y2hpbmcgbWV0YWRhdGEgYW5kIHBvc3NpYmx5IHZhbGlkYXRpbmcgb3duZXJzaGlwIG9mIGFuXHJcbiAgICAgKiAgTkZULlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBleGFtaW5lIGVhY2ggc3RlcCBhbmQgdGhlIHZhbHVlIGl0XHJcbiAgICAgKiAgd2FzIHdvcmtpbmcgZnJvbS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgX2dldEF2YXRhcigpIHtcclxuICAgICAgICBjb25zdCBsaW5rYWdlID0gW3sgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0aGlzLm5hbWUgfV07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gdGVzdCBkYXRhIGZvciByaWNtb28uZXRoXHJcbiAgICAgICAgICAgIC8vY29uc3QgYXZhdGFyID0gXCJlaXAxNTU6MS9lcmM3MjE6MHgyNjUzODVjN2Y0MTMyMjI4QTBkNTRFQjFBOWU3NDYwYjkxYzBjQzY4LzI5MjMzXCI7XHJcbiAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IGF3YWl0IHRoaXMuZ2V0VGV4dChcImF2YXRhclwiKTtcclxuICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFhdmF0YXJcIiwgdmFsdWU6IFwiXCIgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImF2YXRhclwiLCB2YWx1ZTogYXZhdGFyIH0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGF2YXRhci5tYXRjaChtYXRjaGVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IGF2YXRhciB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXBmc1wiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGdldElwZnNMaW5rKGF2YXRhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaXBmc1wiLCB2YWx1ZTogYXZhdGFyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogdXJsIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmwgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmMxMTU1XCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBFUkMgdHlwZSwgdXNlIHRva2VuVVJJKHVpbnQyNTYpIG9yIHVybCh1aW50MjU2KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IChzY2hlbWUgPT09IFwiZXJjNzIxXCIpID8gXCJ0b2tlblVSSSh1aW50MjU2KVwiIDogXCJ1cmkodWludDI1NilcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogc2NoZW1lLCB2YWx1ZTogYXZhdGFyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3duZXIgb2YgdGhpcyBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogXCJcIiB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG1hdGNoWzJdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogYCEke3NjaGVtZX1jYWlwYCwgdmFsdWU6IChtYXRjaFsyXSB8fCBcIlwiKSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuSWQgPSBjb21wc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoY29tcHNbMF0sIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy03MjFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdG9rZW5VUkkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIG93bmVyT2YodWludCkgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdXJpKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBiYWxhbmNlT2YoYWRkcmVzcywgdWludDI1NikgdmlldyByZXR1cm5zICh1aW50KVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIHRoaXMucHJvdmlkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgYWNjb3VudCBvd25zIHRoZSB0b2tlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzcyMVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbk93bmVyID0gYXdhaXQgY29udHJhY3Qub3duZXJPZih0b2tlbklkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW93bmVyXCIsIHZhbHVlOiB0b2tlbk93bmVyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY29udHJhY3QuYmFsYW5jZU9mKG93bmVyLCB0b2tlbklkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFsYW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWJhbGFuY2VcIiwgdmFsdWU6IFwiMFwiIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIHZhbHVlOiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdG9rZW4gY29udHJhY3QgZm9yIHRoZSBtZXRhZGF0YSBVUkxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhVXJsID0gYXdhaXQgY29udHJhY3Rbc2VsZWN0b3JdKHRva2VuSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwgPT0gbnVsbCB8fCBtZXRhZGF0YVVybCA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YS11cmxcIiwgdmFsdWU6IFwiXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1iYXNlXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gbWV0YWRhdGFVcmwucmVwbGFjZShcIntpZH1cIiwgdG9CZUhleCh0b2tlbklkLCAzMikuc3Vic3RyaW5nKDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWV4cGFuZGVkXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBtZXRhZGF0YSBsaW5rc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwubWF0Y2goL15pcGZzOi9pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBnZXRJcGZzTGluayhtZXRhZGF0YVVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmxcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRva2VuIG1ldGFkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChuZXcgRmV0Y2hSZXF1ZXN0KG1ldGFkYXRhVXJsKSkuc2VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSByZXNwb25zZS5ib2R5SnNvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IHJlc3BvbnNlLmJvZHlUZXh0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByZXNwb25zZS5ib2R5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogaGV4bGlmeShieXRlcykgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IFwiXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIHZhbHVlOiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhlIGltYWdlIFVSTCBvdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlVXJsID0gbWV0YWRhdGEuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGltYWdlVXJsKSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmxcIiwgdmFsdWU6IFwiXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VVcmwubWF0Y2goL14oaHR0cHM6XFwvXFwvfGRhdGE6KS9pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIGxpbmsgdG8gZ2F0ZXdheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXBmcyA9IGltYWdlVXJsLm1hdGNoKG1hdGNoZXJJcGZzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFpbWFnZVVybC1pcGZzXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaW1hZ2VVcmwtaXBmc1wiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGdldElwZnNMaW5rKGltYWdlVXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogaW1hZ2VVcmwgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IG51bGwgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBnZXRFbnNBZGRyZXNzKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKTtcclxuICAgICAgICBjb25zdCBlbnNQbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcclxuICAgICAgICAvLyBObyBFTlMuLi5cclxuICAgICAgICBhc3NlcnQoZW5zUGx1Z2luLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0RW5zQWRkcmVzc1wiLCBpbmZvOiB7IG5ldHdvcmsgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBlbnNQbHVnaW4uYWRkcmVzcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyAjZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyhwcm92aWRlcik7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoZW5zQWRkciwgW1xyXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcclxuICAgICAgICAgICAgXSwgcHJvdmlkZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgY29udHJhY3QucmVzb2x2ZXIobmFtZWhhc2gobmFtZSksIHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoYWRkciA9PT0gWmVyb0FkZHJlc3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhZGRyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gRU5TIHJlZ2lzdHJ5IGNhbm5vdCB0aHJvdyBlcnJvcnMgb24gcmVzb2x2ZXIoYnl0ZXMzMiksXHJcbiAgICAgICAgICAgIC8vIHNvIHByb2JhYmx5IGEgbGluayBlcnJvclxyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlIHRvIHRoZSBFTlMgcmVzb2x2ZXIgZm9yICUlbmFtZSUlIHVzaW5nICUlcHJvdmlkZXIlJSBvclxyXG4gICAgICogIGBgbnVsbGBgIGlmIHVuY29uZmlndXJlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzeW5jIGZyb21OYW1lKHByb3ZpZGVyLCBuYW1lKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnROYW1lID0gbmFtZTtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgPT09IFwiXCIgfHwgY3VycmVudE5hbWUgPT09IFwiLlwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gc2luY2UgdGhlIGV0aCBub2RlIGNhbm5vdCBjaGFuZ2UgYW5kIGRvZXNcclxuICAgICAgICAgICAgLy8gbm90IGhhdmUgYSB3aWxkY2FyZCByZXNvbHZlclxyXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJldGhcIiAmJiBjdXJyZW50TmFtZSA9PT0gXCJldGhcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQgbm9kZSBmb3IgYSByZXNvbHZlclxyXG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuI2dldFJlc29sdmVyKHByb3ZpZGVyLCBjdXJyZW50TmFtZSk7XHJcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgcmVzb2x2ZXIhXHJcbiAgICAgICAgICAgIGlmIChhZGRyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gbmV3IEVuc1Jlc29sdmVyKHByb3ZpZGVyLCBhZGRyLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSByZXNvbHZlciBmb3VuZCwgdXNpbmcgRUlQLTI1NDQgc28gaXQgaXNuJ3Qgc2FmZSB0byB1c2VcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSAhPT0gbmFtZSAmJiAhKGF3YWl0IHJlc29sdmVyLnN1cHBvcnRzV2lsZGNhcmQoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHBhcmVudCBub2RlXHJcbiAgICAgICAgICAgIGN1cnJlbnROYW1lID0gY3VycmVudE5hbWUuc3BsaXQoXCIuXCIpLnNsaWNlKDEpLmpvaW4oXCIuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnMtcmVzb2x2ZXIuanMubWFwIiwiLyoqXHJcbiAqICBAX2lnbm9yZVxyXG4gKi9cclxuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q3JlYXRlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xyXG5leHBvcnQgZnVuY3Rpb24gYWxsb3dOdWxsKGZvcm1hdCwgbnVsbFZhbHVlKSB7XHJcbiAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXQodmFsdWUpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5T2YoZm9ybWF0LCBhbGxvd051bGwpIHtcclxuICAgIHJldHVybiAoKGFycmF5KSA9PiB7XHJcbiAgICAgICAgaWYgKGFsbG93TnVsbCAmJiBhcnJheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoaSkgPT4gZm9ybWF0KGkpKTtcclxuICAgIH0pO1xyXG59XHJcbi8vIFJlcXVpcmVzIGFuIG9iamVjdCB3aGljaCBtYXRjaGVzIGEgZmxlZXQgb2Ygb3RoZXIgZm9ybWF0dGVyc1xyXG4vLyBBbnkgRm9ybWF0RnVuYyBtYXkgcmV0dXJuIGB1bmRlZmluZWRgIHRvIGhhdmUgdGhlIHZhbHVlIG9taXR0ZWRcclxuLy8gZnJvbSB0aGUgcmVzdWx0IG9iamVjdC4gQ2FsbHMgcHJlc2VydmUgYHRoaXNgLlxyXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0KGZvcm1hdCwgYWx0TmFtZXMpIHtcclxuICAgIHJldHVybiAoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGxldCBzcmNLZXkgPSBrZXk7XHJcbiAgICAgICAgICAgIGlmIChhbHROYW1lcyAmJiBrZXkgaW4gYWx0TmFtZXMgJiYgIShzcmNLZXkgaW4gdmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsdEtleSBvZiBhbHROYW1lc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsdEtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNLZXkgPSBhbHRLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbnYgPSBmb3JtYXRba2V5XSh2YWx1ZVtzcmNLZXldKTtcclxuICAgICAgICAgICAgICAgIGlmIChudiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBudjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgPyBlcnJvci5tZXNzYWdlIDogXCJub3QtYW4tZXJyb3JcIjtcclxuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgdmFsdWUgZm9yIHZhbHVlLiR7a2V5fSAoJHttZXNzYWdlfSlgLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCb29sZWFuKHZhbHVlKSB7XHJcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgY2FzZSB0cnVlOlxyXG4gICAgICAgIGNhc2UgXCJ0cnVlXCI6XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGNhc2UgZmFsc2U6XHJcbiAgICAgICAgY2FzZSBcImZhbHNlXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBib29sZWFuOyAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0YSh2YWx1ZSkge1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpLCBcImludmFsaWQgZGF0YVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0SGFzaCh2YWx1ZSkge1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWUsIDMyKSwgXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVpbnQyNTYodmFsdWUpIHtcclxuICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHplcm9QYWRWYWx1ZSh2YWx1ZSwgMzIpO1xyXG59XHJcbmNvbnN0IF9mb3JtYXRMb2cgPSBvYmplY3Qoe1xyXG4gICAgYWRkcmVzczogZ2V0QWRkcmVzcyxcclxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcclxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXHJcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxyXG4gICAgaW5kZXg6IGdldE51bWJlcixcclxuICAgIHJlbW92ZWQ6IGFsbG93TnVsbChmb3JtYXRCb29sZWFuLCBmYWxzZSksXHJcbiAgICB0b3BpY3M6IGFycmF5T2YoZm9ybWF0SGFzaCksXHJcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXHJcbiAgICB0cmFuc2FjdGlvbkluZGV4OiBnZXROdW1iZXIsXHJcbn0sIHtcclxuICAgIGluZGV4OiBbXCJsb2dJbmRleFwiXVxyXG59KTtcclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdExvZyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIF9mb3JtYXRMb2codmFsdWUpO1xyXG59XHJcbmNvbnN0IF9mb3JtYXRCbG9jayA9IG9iamVjdCh7XHJcbiAgICBoYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCksXHJcbiAgICBwYXJlbnRIYXNoOiBmb3JtYXRIYXNoLFxyXG4gICAgcGFyZW50QmVhY29uQmxvY2tSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXHJcbiAgICBudW1iZXI6IGdldE51bWJlcixcclxuICAgIHRpbWVzdGFtcDogZ2V0TnVtYmVyLFxyXG4gICAgbm9uY2U6IGFsbG93TnVsbChmb3JtYXREYXRhKSxcclxuICAgIGRpZmZpY3VsdHk6IGdldEJpZ0ludCxcclxuICAgIGdhc0xpbWl0OiBnZXRCaWdJbnQsXHJcbiAgICBnYXNVc2VkOiBnZXRCaWdJbnQsXHJcbiAgICBzdGF0ZVJvb3Q6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcclxuICAgIHJlY2VpcHRzUm9vdDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxyXG4gICAgYmxvYkdhc1VzZWQ6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxyXG4gICAgZXhjZXNzQmxvYkdhczogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXHJcbiAgICBtaW5lcjogYWxsb3dOdWxsKGdldEFkZHJlc3MpLFxyXG4gICAgcHJldlJhbmRhbzogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxyXG4gICAgZXh0cmFEYXRhOiBmb3JtYXREYXRhLFxyXG4gICAgYmFzZUZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludClcclxufSwge1xyXG4gICAgcHJldlJhbmRhbzogW1wibWl4SGFzaFwiXVxyXG59KTtcclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJsb2NrKHZhbHVlKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBfZm9ybWF0QmxvY2sodmFsdWUpO1xyXG4gICAgcmVzdWx0LnRyYW5zYWN0aW9ucyA9IHZhbHVlLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodHgpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IF9mb3JtYXRSZWNlaXB0TG9nID0gb2JqZWN0KHtcclxuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGdldE51bWJlcixcclxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXHJcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXHJcbiAgICBhZGRyZXNzOiBnZXRBZGRyZXNzLFxyXG4gICAgdG9waWNzOiBhcnJheU9mKGZvcm1hdEhhc2gpLFxyXG4gICAgZGF0YTogZm9ybWF0RGF0YSxcclxuICAgIGluZGV4OiBnZXROdW1iZXIsXHJcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXHJcbn0sIHtcclxuICAgIGluZGV4OiBbXCJsb2dJbmRleFwiXVxyXG59KTtcclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJlY2VpcHRMb2codmFsdWUpIHtcclxuICAgIHJldHVybiBfZm9ybWF0UmVjZWlwdExvZyh2YWx1ZSk7XHJcbn1cclxuY29uc3QgX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCA9IG9iamVjdCh7XHJcbiAgICB0bzogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxyXG4gICAgZnJvbTogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxyXG4gICAgY29udHJhY3RBZGRyZXNzOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXHJcbiAgICAvLyBzaG91bGQgYmUgYWxsb3dOdWxsKGhhc2gpLCBidXQgYnJva2VuLUVJUC02NTggc3VwcG9ydCBpcyBoYW5kbGVkIGluIHJlY2VpcHRcclxuICAgIGluZGV4OiBnZXROdW1iZXIsXHJcbiAgICByb290OiBhbGxvd051bGwoaGV4bGlmeSksXHJcbiAgICBnYXNVc2VkOiBnZXRCaWdJbnQsXHJcbiAgICBibG9iR2FzVXNlZDogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXHJcbiAgICBsb2dzQmxvb206IGFsbG93TnVsbChmb3JtYXREYXRhKSxcclxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcclxuICAgIGhhc2g6IGZvcm1hdEhhc2gsXHJcbiAgICBsb2dzOiBhcnJheU9mKGZvcm1hdFJlY2VpcHRMb2cpLFxyXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcclxuICAgIC8vY29uZmlybWF0aW9uczogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXHJcbiAgICBjdW11bGF0aXZlR2FzVXNlZDogZ2V0QmlnSW50LFxyXG4gICAgZWZmZWN0aXZlR2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxyXG4gICAgYmxvYkdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcclxuICAgIHN0YXR1czogYWxsb3dOdWxsKGdldE51bWJlciksXHJcbiAgICB0eXBlOiBhbGxvd051bGwoZ2V0TnVtYmVyLCAwKVxyXG59LCB7XHJcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogW1wiZ2FzUHJpY2VcIl0sXHJcbiAgICBoYXNoOiBbXCJ0cmFuc2FjdGlvbkhhc2hcIl0sXHJcbiAgICBpbmRleDogW1widHJhbnNhY3Rpb25JbmRleFwiXSxcclxufSk7XHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpIHtcclxuICAgIHJldHVybiBfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh2YWx1ZSkge1xyXG4gICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxyXG4gICAgLy8gMCBhZGRyZXNzOyBjb3JyZWN0IHRoaXMgdG8gYmUgYSByZWFsIGFkZHJlc3NcclxuICAgIGlmICh2YWx1ZS50byAmJiBnZXRCaWdJbnQodmFsdWUudG8pID09PSBCTl8wKSB7XHJcbiAgICAgICAgdmFsdWUudG8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gb2JqZWN0KHtcclxuICAgICAgICBoYXNoOiBmb3JtYXRIYXNoLFxyXG4gICAgICAgIC8vIFNvbWUgbm9kZXMgZG8gbm90IHJldHVybiB0aGlzLCB1c3VhbGx5IHRlc3Qgbm9kZXMgKGxpa2UgR2FuYWNoZSlcclxuICAgICAgICBpbmRleDogYWxsb3dOdWxsKGdldE51bWJlciwgdW5kZWZpbmVkKSxcclxuICAgICAgICB0eXBlOiAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4XCIgfHwgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhY2Nlc3NMaXN0OiBhbGxvd051bGwoYWNjZXNzTGlzdGlmeSwgbnVsbCksXHJcbiAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlczogYWxsb3dOdWxsKGFycmF5T2YoZm9ybWF0SGFzaCwgdHJ1ZSksIG51bGwpLFxyXG4gICAgICAgIGF1dGhvcml6YXRpb25MaXN0OiBhbGxvd051bGwoYXJyYXlPZigodikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc2lnO1xyXG4gICAgICAgICAgICBpZiAodi5zaWduYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHNpZyA9IHYuc2lnbmF0dXJlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHlQYXJpdHkgPSB2LnlQYXJpdHk7XHJcbiAgICAgICAgICAgICAgICBpZiAoeVBhcml0eSA9PT0gXCIweDFiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB5UGFyaXR5ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHlQYXJpdHkgPT09IFwiMHgxY1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzaWcgPSBPYmplY3QuYXNzaWduKHt9LCB2LCB7IHlQYXJpdHkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3Modi5hZGRyZXNzKSxcclxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGdldEJpZ0ludCh2LmNoYWluSWQpLFxyXG4gICAgICAgICAgICAgICAgbm9uY2U6IGdldEJpZ0ludCh2Lm5vbmNlKSxcclxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20oc2lnKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sIGZhbHNlKSwgbnVsbCksXHJcbiAgICAgICAgYmxvY2tIYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXHJcbiAgICAgICAgYmxvY2tOdW1iZXI6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxyXG4gICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxyXG4gICAgICAgIGZyb206IGdldEFkZHJlc3MsXHJcbiAgICAgICAgLy8gZWl0aGVyIChnYXNQcmljZSkgb3IgKG1heFByaW9yaXR5RmVlUGVyR2FzICsgbWF4RmVlUGVyR2FzKSBtdXN0IGJlIHNldFxyXG4gICAgICAgIGdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcclxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludCksXHJcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcclxuICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcclxuICAgICAgICBnYXNMaW1pdDogZ2V0QmlnSW50LFxyXG4gICAgICAgIHRvOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXHJcbiAgICAgICAgdmFsdWU6IGdldEJpZ0ludCxcclxuICAgICAgICBub25jZTogZ2V0TnVtYmVyLFxyXG4gICAgICAgIGRhdGE6IGZvcm1hdERhdGEsXHJcbiAgICAgICAgY3JlYXRlczogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxyXG4gICAgICAgIGNoYWluSWQ6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpXHJcbiAgICB9LCB7XHJcbiAgICAgICAgZGF0YTogW1wiaW5wdXRcIl0sXHJcbiAgICAgICAgZ2FzTGltaXQ6IFtcImdhc1wiXSxcclxuICAgICAgICBpbmRleDogW1widHJhbnNhY3Rpb25JbmRleFwiXVxyXG4gICAgfSkodmFsdWUpO1xyXG4gICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB2YWx1ZVxyXG4gICAgaWYgKHJlc3VsdC50byA9PSBudWxsICYmIHJlc3VsdC5jcmVhdGVzID09IG51bGwpIHtcclxuICAgICAgICByZXN1bHQuY3JlYXRlcyA9IGdldENyZWF0ZUFkZHJlc3MocmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8vIEBUT0RPOiBDaGVjayBmZWUgZGF0YVxyXG4gICAgLy8gQWRkIGFuIGFjY2VzcyBsaXN0IHRvIHN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlc1xyXG4gICAgaWYgKCh2YWx1ZS50eXBlID09PSAxIHx8IHZhbHVlLnR5cGUgPT09IDIpICYmIHZhbHVlLmFjY2Vzc0xpc3QgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gW107XHJcbiAgICB9XHJcbiAgICAvLyBDb21wdXRlIHRoZSBzaWduYXR1cmVcclxuICAgIGlmICh2YWx1ZS5zaWduYXR1cmUpIHtcclxuICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odmFsdWUuc2lnbmF0dXJlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyBTb21lIGJhY2tlbmRzIG9taXQgQ2hhaW5JZCBvbiBsZWdhY3kgdHJhbnNhY3Rpb25zLCBidXQgd2UgY2FuIGNvbXB1dGUgaXRcclxuICAgIGlmIChyZXN1bHQuY2hhaW5JZCA9PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IHJlc3VsdC5zaWduYXR1cmUubGVnYWN5Q2hhaW5JZDtcclxuICAgICAgICBpZiAoY2hhaW5JZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBAVE9ETzogY2hlY2sgY2hhaW5JRFxyXG4gICAgLypcclxuICAgIGlmICh2YWx1ZS5jaGFpbklkICE9IG51bGwpIHtcclxuICAgICAgICBsZXQgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XHJcblxyXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xyXG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUubmV0d29ya0lkO1xyXG5cclxuICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcclxuICAgICAgICBpZiAoY2hhaW5JZCA9PSBudWxsICYmIHJlc3VsdC52ID09IG51bGwpIHtcclxuICAgICAgICAgICAgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcclxuICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mKGNoYWluSWQpICE9PSBcIm51bWJlclwiICYmIHJlc3VsdC52ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY2hhaW5JZCA9IChyZXN1bHQudiAtIDM1KSAvIDI7XHJcbiAgICAgICAgICAgIGlmIChjaGFpbklkIDwgMCkgeyBjaGFpbklkID0gMDsgfVxyXG4gICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7IGNoYWluSWQgPSAwOyB9XHJcblxyXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcclxuICAgIH1cclxuICAgICovXHJcbiAgICAvLyAweDAwMDAuLi4gc2hvdWxkIGFjdHVhbGx5IGJlIG51bGxcclxuICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoICYmIGdldEJpZ0ludChyZXN1bHQuYmxvY2tIYXNoKSA9PT0gQk5fMCkge1xyXG4gICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XHJcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmNvbnN0IEVuc0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiO1xyXG4vKipcclxuICogIEEgKipOZXR3b3JrUGx1Z2luKiogcHJvdmlkZXMgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IG9uIGEgW1tOZXR3b3JrXV0uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTmV0d29ya1BsdWdpbiB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxyXG4gICAgICpcclxuICAgICAqICBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgcmV2ZXJzZS1kb21haW4tbm90YXRpb24sIHdoaWNoIHBlcm1pdHNcclxuICAgICAqICB1bmlxdWUgbmFtZXMgd2l0aCBhIGtub3duIGF1dGhvcml0eSBhcyB3ZWxsIGFzIGhpZXJhcmNoYWwgZW50cmllcy5cclxuICAgICAqL1xyXG4gICAgbmFtZTtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipOZXR3b3JrUGx1Z2luKiouXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgcGx1Z2luLlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5ldHdvcmtQbHVnaW4odGhpcy5uYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEEgKipHYXNDb3N0UGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFsdGVybmF0aXZlIHZhbHVlcyB3aGVuXHJcbiAqICBjb21wdXRpbmcgdGhlIGludHJpbnNpYyBnYXMgcmVxdWlyZWQgZm9yIGEgdHJhbnNhY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR2FzQ29zdFBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciB0byB0cmVhdCB0aGVzZSB2YWx1ZXMgYXMgdmFsaWQgZnJvbS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBhbGxvd3MgYSBoYXJkZm9yayB0byBoYXZlIHVwZGF0ZWQgdmFsdWVzIGluY2x1ZGVkIGFzIHdlbGwgYXNcclxuICAgICAqICBtdWx1dGlwbGUgaGFyZGZvcmtzIHRvIGJlIHN1cHBvcnRlZC5cclxuICAgICAqL1xyXG4gICAgZWZmZWN0aXZlQmxvY2s7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdHJhbnNhY3Rpb25zIGJhc2UgZmVlLlxyXG4gICAgICovXHJcbiAgICB0eEJhc2U7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZmVlIGZvciBjcmVhdGluZyBhIG5ldyBhY2NvdW50LlxyXG4gICAgICovXHJcbiAgICB0eENyZWF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBmZWUgcGVyIHplcm8tYnl0ZSBpbiB0aGUgZGF0YS5cclxuICAgICAqL1xyXG4gICAgdHhEYXRhWmVybztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBmZWUgcGVyIG5vbi16ZXJvLWJ5dGUgaW4gdGhlIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIHR4RGF0YU5vbnplcm87XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZmVlIHBlciBzdG9yYWdlIGtleSBpbiB0aGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QuXHJcbiAgICAgKi9cclxuICAgIHR4QWNjZXNzTGlzdFN0b3JhZ2VLZXk7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZmVlIHBlciBhZGRyZXNzIGluIHRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdC5cclxuICAgICAqL1xyXG4gICAgdHhBY2Nlc3NMaXN0QWRkcmVzcztcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgR2FzQ29zdFBsdWdpbiBmcm9tICUlZWZmZWN0aXZlQmxvY2slJSB1bnRpbCB0aGVcclxuICAgICAqICBsYXRlc3QgYmxvY2sgb3IgYW5vdGhlciBHYXNDb3N0UGx1Z2luIHN1cGVyY2VkZXMgdGhhdCBibG9jayBudW1iZXIsXHJcbiAgICAgKiAgd2l0aCB0aGUgYXNzb2NpYXRlZCAlJWNvc3RzJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGVmZmVjdGl2ZUJsb2NrLCBjb3N0cykge1xyXG4gICAgICAgIGlmIChlZmZlY3RpdmVCbG9jayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdGl2ZUJsb2NrID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIoYG9yZy5ldGhlcnMubmV0d29yay5wbHVnaW5zLkdhc0Nvc3QjJHsoZWZmZWN0aXZlQmxvY2sgfHwgMCl9YCk7XHJcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7IGVmZmVjdGl2ZUJsb2NrIH07XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0KG5hbWUsIG51bGxpc2gpIHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gKGNvc3RzIHx8IHt9KVtuYW1lXTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbGlzaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiwgYGludmFsdWQgdmFsdWUgZm9yICR7bmFtZX1gLCBcImNvc3RzXCIsIGNvc3RzKTtcclxuICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0KFwidHhCYXNlXCIsIDIxMDAwKTtcclxuICAgICAgICBzZXQoXCJ0eENyZWF0ZVwiLCAzMjAwMCk7XHJcbiAgICAgICAgc2V0KFwidHhEYXRhWmVyb1wiLCA0KTtcclxuICAgICAgICBzZXQoXCJ0eERhdGFOb256ZXJvXCIsIDE2KTtcclxuICAgICAgICBzZXQoXCJ0eEFjY2Vzc0xpc3RTdG9yYWdlS2V5XCIsIDE5MDApO1xyXG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdEFkZHJlc3NcIiwgMjQwMCk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCBwcm9wcyk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdhc0Nvc3RQbHVnaW4odGhpcy5lZmZlY3RpdmVCbG9jaywgdGhpcyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBbiAqKkVuc1BsdWdpbioqIGFsbG93cyBhIFtbTmV0d29ya11dIHRvIHNwZWNpZnkgdGhlIEVOUyBSZWdpc3RyeVxyXG4gKiAgQ29udHJhY3QgYWRkcmVzcyBhbmQgdGhlIHRhcmdldCBuZXR3b3JrIHRvIHVzZSB3aGVuIHVzaW5nIHRoYXRcclxuICogIGNvbnRyYWN0LlxyXG4gKlxyXG4gKiAgVmFyaW91cyB0ZXN0bmV0cyBoYXZlIHRoZWlyIG93biBpbnN0YW5jZSBvZiB0aGUgY29udHJhY3QgdG8gdXNlLCBidXRcclxuICogIGluIGdlbmVyYWwsIHRoZSBtYWlubmV0IGluc3RhbmNlIHN1cHBvcnRzIG11bHRpLWNoYWluIGFkZHJlc3NlcyBhbmRcclxuICogIHNob3VsZCBiZSB1c2VkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVuc1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIEVOUyBSZWdpc3RydHkgQ29udHJhY3QgYWRkcmVzcy5cclxuICAgICAqL1xyXG4gICAgYWRkcmVzcztcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjaGFpbiBJRCB0aGF0IHRoZSBFTlMgY29udHJhY3QgbGl2ZXMgb24uXHJcbiAgICAgKi9cclxuICAgIHRhcmdldE5ldHdvcms7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRW5zUGx1Z2luKiogY29ubmVjdGVkIHRvICUlYWRkcmVzcyUlIG9uIHRoZVxyXG4gICAgICogICUldGFyZ2V0TmV0d29yayUlLiBUaGUgZGVmYXVsdCBFTlMgYWRkcmVzcyBhbmQgbWFpbm5ldCBpcyB1c2VkXHJcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHRhcmdldE5ldHdvcmspIHtcclxuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgYWRkcmVzczogKGFkZHJlc3MgfHwgRW5zQWRkcmVzcyksXHJcbiAgICAgICAgICAgIHRhcmdldE5ldHdvcms6ICgodGFyZ2V0TmV0d29yayA9PSBudWxsKSA/IDEgOiB0YXJnZXROZXR3b3JrKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnNQbHVnaW4odGhpcy5hZGRyZXNzLCB0aGlzLnRhcmdldE5ldHdvcmspO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSAqKkZlZURhdGFOZXR3b3JrUGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFuZCBhbHRlcm5hdGVcclxuICogIG1lYW5zIHRvIHNwZWNpZnkgaXRzIGZlZSBkYXRhLlxyXG4gKlxyXG4gKiAgRm9yIGV4YW1wbGUsIGEgbmV0d29yayB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IFtbbGluay1laXAtMTU1OV1dIG1heVxyXG4gKiAgY2hvb3NlIHRvIHVzZSBhIEdhcyBTdGF0aW9uIHNpdGUgdG8gYXBwcm94aW1hdGUgdGhlIGdhcyBwcmljZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xyXG4gICAgI2ZlZURhdGFGdW5jO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZlZSBkYXRhIGZ1bmN0aW9uIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cclxuICAgICAqL1xyXG4gICAgZ2V0IGZlZURhdGFGdW5jKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNmZWVEYXRhRnVuYztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihmZWVEYXRhRnVuYykge1xyXG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmVlRGF0YVwiKTtcclxuICAgICAgICB0aGlzLiNmZWVEYXRhRnVuYyA9IGZlZURhdGFGdW5jO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGZlZSBkYXRhLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRGZWVEYXRhKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZlZURhdGFGdW5jKHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmVlRGF0YU5ldHdvcmtQbHVnaW4odGhpcy4jZmVlRGF0YUZ1bmMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XHJcbiAgICAjdXJsO1xyXG4gICAgI3Byb2Nlc3NGdW5jO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIFVSTCB0byBpbml0aWFsaXplIHRoZSBGZXRjaFJlcXVlc3Qgd2l0aCBpbiAlJXByb2Nlc3NGdW5jJSUuXHJcbiAgICAgKi9cclxuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjYWxsYmFjayB0byB1c2Ugd2hlbiBjb21wdXRpbmcgdGhlIEZlZURhdGEuXHJcbiAgICAgKi9cclxuICAgIGdldCBwcm9jZXNzRnVuYygpIHsgcmV0dXJuIHRoaXMuI3Byb2Nlc3NGdW5jOyB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbioqIHdoaWNoIHdpbGxcclxuICAgICAqICBiZSB1c2VkIHdoZW4gY29tcHV0aW5nIHRoZSBmZWUgZGF0YSBmb3IgdGhlIG5ldHdvcmsuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHVybCwgcHJvY2Vzc0Z1bmMpIHtcclxuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcclxuICAgICAgICB0aGlzLiN1cmwgPSB1cmw7XHJcbiAgICAgICAgdGhpcy4jcHJvY2Vzc0Z1bmMgPSBwcm9jZXNzRnVuYztcclxuICAgIH1cclxuICAgIC8vIFdlIGFyZSBpbW11dGFibGUsIHNvIHdlIGNhbiBzZXJ2ZSBhcyBvdXIgb3duIGNsb25lXHJcbiAgICBjbG9uZSgpIHsgcmV0dXJuIHRoaXM7IH1cclxufVxyXG4vKlxyXG5leHBvcnQgY2xhc3MgQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XHJcbiAgICByZWFkb25seSAjYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPjtcclxuICAgIHJlYWRvbmx5ICNibG9ja1dpdGhUeHNGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pID0+IEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJsb2NrRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pID0+IEJsb2NrPHN0cmluZz4sIGJsb2NrV2l0aFR4c0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPikgPT4gQmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT4pIHtcclxuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMubmV0d29yay1wbHVnaW5zLmN1c3RvbS1ibG9ja1wiKTtcclxuICAgICAgICB0aGlzLiNibG9ja0Z1bmMgPSBibG9ja0Z1bmM7XHJcbiAgICAgICAgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyA9IGJsb2NrV2l0aFR4c0Z1bmM7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZ2V0QmxvY2socHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPik6IFByb21pc2U8QmxvY2s8c3RyaW5nPj4ge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBnZXRCbG9ja2lvbnMocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pOiBQcm9taXNlPEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+PiB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9uZSgpOiBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luKHRoaXMuI2Jsb2NrRnVuYywgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyk7XHJcbiAgICB9XHJcbn1cclxuKi9cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2lucy1uZXR3b3JrLmpzLm1hcCIsIi8qKlxyXG4gKiAgQSAqKk5ldHdvcmsqKiBlbmNhcHN1bGF0ZXMgdGhlIHZhcmlvdXMgcHJvcGVydGllcyByZXF1aXJlZCB0b1xyXG4gKiAgaW50ZXJhY3Qgd2l0aCBhIHNwZWNpZmljIGNoYWluLlxyXG4gKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzOk5ldHdvcmtzICBbbmV0d29ya3NdXHJcbiAqL1xyXG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGdldEJpZ0ludCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBFbnNQbHVnaW4sIEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4sIEdhc0Nvc3RQbHVnaW4gfSBmcm9tIFwiLi9wbHVnaW5zLW5ldHdvcmsuanNcIjtcclxuLyogKiAqICpcclxuLy8gTmV0d29ya3Mgd2hpY2ggb3BlcmF0aW9uIGFnYWluc3QgYW4gTDIgY2FuIHVzZSB0aGlzIHBsdWdpbiB0b1xyXG4vLyBzcGVjaWZ5IGhvdyB0byBhY2Nlc3MgTDEsIGZvciB0aGUgcHVycG9zZSBvZiByZXNvbHZpbmcgRU5TLFxyXG4vLyBmb3IgZXhhbXBsZS5cclxuZXhwb3J0IGNsYXNzIExheWVyT25lQ29ubmVjdGlvblBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xyXG4gICAgcmVhZG9ubHkgcHJvdmlkZXIhOiBQcm92aWRlcjtcclxuLy8gQFRPRE86IFJlbmFtZSB0byBDaGFpbkFjY2VzcyBhbmQgYWxsb3cgZm9yIGNvbm5lY3RpbmcgdG8gYW55IGNoYWluXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcjogUHJvdmlkZXIpIHtcclxuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5sYXllci1vbmUtY29ubmVjdGlvblwiKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzPExheWVyT25lQ29ubmVjdGlvblBsdWdpbj4odGhpcywgeyBwcm92aWRlciB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9uZSgpOiBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luKHRoaXMucHJvdmlkZXIpO1xyXG4gICAgfVxyXG59XHJcbiovXHJcbmNvbnN0IE5ldHdvcmtzID0gbmV3IE1hcCgpO1xyXG4vKipcclxuICogIEEgKipOZXR3b3JrKiogcHJvdmlkZXMgYWNjZXNzIHRvIGEgY2hhaW4ncyBwcm9wZXJ0aWVzIGFuZCBhbGxvd3NcclxuICogIGZvciBwbHVnLWlucyB0byBleHRlbmQgZnVuY3Rpb25hbGl0eS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZXR3b3JrIHtcclxuICAgICNuYW1lO1xyXG4gICAgI2NoYWluSWQ7XHJcbiAgICAjcGx1Z2lucztcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipOZXR3b3JrKiogZm9yICUlbmFtZSUlIGFuZCAlJWNoYWluSWQlJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgY2hhaW5JZCkge1xyXG4gICAgICAgIHRoaXMuI25hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQoY2hhaW5JZCk7XHJcbiAgICAgICAgdGhpcy4jcGx1Z2lucyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24gb2YgYSBOZXR3b3JrLlxyXG4gICAgICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogdGhpcy5uYW1lLCBjaGFpbklkOiBTdHJpbmcodGhpcy5jaGFpbklkKSB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG5ldHdvcmsgY29tbW9uIG5hbWUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgaXMgdGhlIGNhbm9uaWNhbCBuYW1lLCBhcyBuZXR3b3JrcyBtaWdoIGhhdmUgbXVsdGlwbGVcclxuICAgICAqICBuYW1lcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLiNuYW1lOyB9XHJcbiAgICBzZXQgbmFtZSh2YWx1ZSkgeyB0aGlzLiNuYW1lID0gdmFsdWU7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBuZXR3b3JrIGNoYWluIElELlxyXG4gICAgICovXHJcbiAgICBnZXQgY2hhaW5JZCgpIHsgcmV0dXJuIHRoaXMuI2NoYWluSWQ7IH1cclxuICAgIHNldCBjaGFpbklkKHZhbHVlKSB7IHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQodmFsdWUsIFwiY2hhaW5JZFwiKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBtYXRjaGVzIHRoaXMgbmV0d29yay4gQW55IGNoYWluIElEXHJcbiAgICAgKiAgbXVzdCBtYXRjaCwgYW5kIGlmIG5vIGNoYWluIElEIGlzIHByZXNlbnQsIHRoZSBuYW1lIG11c3QgbWF0Y2guXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgbWV0aG9kIGRvZXMgbm90IGN1cnJlbnRseSBjaGVjayBmb3IgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLFxyXG4gICAgICogIHN1Y2ggYXMgRU5TIGFkZHJlc3Mgb3IgcGx1Zy1pbiBjb21wYXRpYmlsaXR5LlxyXG4gICAgICovXHJcbiAgICBtYXRjaGVzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubmFtZSA9PT0gb3RoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIChvdGhlcikgPT09IFwiYmlnaW50XCIpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBpZiAob3RoZXIuY2hhaW5JZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIuY2hhaW5JZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3RoZXIubmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMubmFtZSA9PT0gb3RoZXIubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBsaXN0IG9mIHBsdWdpbnMgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoaXMgTmV0d29yay5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBsdWdpbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jcGx1Z2lucy52YWx1ZXMoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBBdHRhY2ggYSBuZXcgJSVwbHVnaW4lJSB0byB0aGlzIE5ldHdvcmsuIFRoZSBuZXR3b3JrIG5hbWVcclxuICAgICAqICBtdXN0IGJlIHVuaXF1ZSwgZXhjbHVkaW5nIGFueSBmcmFnbWVudC5cclxuICAgICAqL1xyXG4gICAgYXR0YWNoUGx1Z2luKHBsdWdpbikge1xyXG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVwbGFjZSBleGlzdGluZyBwbHVnaW46ICR7cGx1Z2luLm5hbWV9IGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNsb25lKCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBwbHVnaW4sIGlmIGFueSwgbWF0Y2hpbmcgJSVuYW1lJSUgZXhhY3RseS4gUGx1Z2luc1xyXG4gICAgICogIHdpdGggZnJhZ21lbnRzIHdpbGwgbm90IGJlIHJldHVybmVkIHVubGVzcyAlJW5hbWUlJSBpbmNsdWRlc1xyXG4gICAgICogIGEgZnJhZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIGdldFBsdWdpbihuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEdldHMgYSBsaXN0IG9mIGFsbCBwbHVnaW5zIHRoYXQgbWF0Y2ggJSVuYW1lJSUsIHdpdGggb3RyIHdpdGhvdXRcclxuICAgICAqICBhIGZyYWdtZW50LlxyXG4gICAgICovXHJcbiAgICBnZXRQbHVnaW5zKGJhc2VuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnBsdWdpbnMuZmlsdGVyKChwKSA9PiAocC5uYW1lLnNwbGl0KFwiI1wiKVswXSA9PT0gYmFzZW5hbWUpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgTmV0d29yay5cclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgTmV0d29yayh0aGlzLm5hbWUsIHRoaXMuY2hhaW5JZCk7XHJcbiAgICAgICAgdGhpcy5wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xyXG4gICAgICAgICAgICBjbG9uZS5hdHRhY2hQbHVnaW4ocGx1Z2luLmNsb25lKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENvbXB1dGUgdGhlIGludHJpbnNpYyBnYXMgcmVxdWlyZWQgZm9yIGEgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogIEEgR2FzQ29zdFBsdWdpbiBjYW4gYmUgYXR0YWNoZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRcclxuICAgICAqICB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbXB1dGVJbnRyaW5zaWNHYXModHgpIHtcclxuICAgICAgICBjb25zdCBjb3N0cyA9IHRoaXMuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuR2FzQ29zdFwiKSB8fCAobmV3IEdhc0Nvc3RQbHVnaW4oKSk7XHJcbiAgICAgICAgbGV0IGdhcyA9IGNvc3RzLnR4QmFzZTtcclxuICAgICAgICBpZiAodHgudG8gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBnYXMgKz0gY29zdHMudHhDcmVhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5kYXRhKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdHguZGF0YS5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEuc3Vic3RyaW5nKGksIGkgKyAyKSA9PT0gXCIwMFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4RGF0YVplcm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhEYXRhTm9uemVybztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xyXG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeSh0eC5hY2Nlc3NMaXN0KTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIGluIGFjY2Vzc0xpc3QpIHtcclxuICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eEFjY2Vzc0xpc3RBZGRyZXNzICsgY29zdHMudHhBY2Nlc3NMaXN0U3RvcmFnZUtleSAqIGFjY2Vzc0xpc3RbYWRkcl0uc3RvcmFnZUtleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnYXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgbmV3IE5ldHdvcmsgZm9yIHRoZSAlJW5ldHdvcmslJSBuYW1lIG9yIGNoYWluSWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKG5ldHdvcmspIHtcclxuICAgICAgICBpbmplY3RDb21tb25OZXR3b3JrcygpO1xyXG4gICAgICAgIC8vIERlZmF1bHQgbmV0d29ya1xyXG4gICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5ldHdvcmsuZnJvbShcIm1haW5uZXRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbm9uaWNhbCBuYW1lIG9yIGNoYWluIElEXHJcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgbmV0d29yayA9IEJpZ0ludChuZXR3b3JrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xyXG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrRnVuYyA9IE5ldHdvcmtzLmdldChuZXR3b3JrKTtcclxuICAgICAgICAgICAgaWYgKG5ldHdvcmtGdW5jKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29ya0Z1bmMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrKFwidW5rbm93blwiLCBuZXR3b3JrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDbG9uYWJsZSB3aXRoIG5ldHdvcmstbGlrZSBhYmlsaXRpZXNcclxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrLmNsb25lKSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gbmV0d29yay5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvL2lmICh0eXBlb2YobmV0d29yay5uYW1lKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOZXR3b3JraXNoXHJcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuZXR3b3JrLm5hbWUpID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiAobmV0d29yay5jaGFpbklkKSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIG5ldHdvcmsgb2JqZWN0IG5hbWUgb3IgY2hhaW5JZFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbSA9IG5ldyBOZXR3b3JrKChuZXR3b3JrLm5hbWUpLCAobmV0d29yay5jaGFpbklkKSk7XHJcbiAgICAgICAgICAgIGlmIChuZXR3b3JrLmVuc0FkZHJlc3MgfHwgbmV0d29yay5lbnNOZXR3b3JrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbS5hdHRhY2hQbHVnaW4obmV3IEVuc1BsdWdpbihuZXR3b3JrLmVuc0FkZHJlc3MsIG5ldHdvcmsuZW5zTmV0d29yaykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikge1xyXG4gICAgICAgICAgICAvLyAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4oKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSk7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVnaXN0ZXIgJSVuYW1lT3JDaGFpbklkJSUgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnNcclxuICAgICAqICBhbiBpbnN0YW5jZSBvZiBhIE5ldHdvcmsgcmVwcmVzZW50aW5nIHRoYXQgY2hhaW4uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZWdpc3RlcihuYW1lT3JDaGFpbklkLCBuZXR3b3JrRnVuYykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKG5hbWVPckNoYWluSWQpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIG5hbWVPckNoYWluSWQgPSBCaWdJbnQobmFtZU9yQ2hhaW5JZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gTmV0d29ya3MuZ2V0KG5hbWVPckNoYWluSWQpO1xyXG4gICAgICAgIGlmIChleGlzdGluZykge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGNvbmZsaWN0aW5nIG5ldHdvcmsgZm9yICR7SlNPTi5zdHJpbmdpZnkoZXhpc3RpbmcubmFtZSl9YCwgXCJuYW1lT3JDaGFpbklkXCIsIG5hbWVPckNoYWluSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBOZXR3b3Jrcy5zZXQobmFtZU9yQ2hhaW5JZCwgbmV0d29ya0Z1bmMpO1xyXG4gICAgfVxyXG59XHJcbi8vIFdlIGRvbid0IHdhbnQgdG8gYnJpbmcgaW4gZm9ybWF0VW5pdHMgYmVjYXVzZSBpdCBpcyBiYWNrZWQgYnlcclxuLy8gRml4ZWROdW1iZXIgYW5kIHdlIHdhbnQgdG8ga2VlcCBOZXR3b3JrcyB0aW55LiBUaGUgdmFsdWVzXHJcbi8vIGluY2x1ZGVkIGJ5IHRoZSBHYXMgU3RhdGlvbnMgYXJlIGFsc28gSUVFRSA3NTQgd2l0aCBsb3RzIG9mXHJcbi8vIHJvdW5kaW5nIGlzc3VlcyBhbmQgZXhjZWVkIHRoZSBzdHJpY3QgY2hlY2tzIGZvcm1hdFVuaXRzIGhhcy5cclxuZnVuY3Rpb24gcGFyc2VVbml0cyhfdmFsdWUsIGRlY2ltYWxzKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IFN0cmluZyhfdmFsdWUpO1xyXG4gICAgaWYgKCF2YWx1ZS5tYXRjaCgvXlswLTkuXSskLykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZ3dlaSB2YWx1ZTogJHtfdmFsdWV9YCk7XHJcbiAgICB9XHJcbiAgICAvLyBCcmVhayBpbnRvIFsgd2hvbGUsIGZyYWN0aW9uIF1cclxuICAgIGNvbnN0IGNvbXBzID0gdmFsdWUuc3BsaXQoXCIuXCIpO1xyXG4gICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGNvbXBzLnB1c2goXCJcIik7XHJcbiAgICB9XHJcbiAgICAvLyBNb3JlIHRoYW4gMSBkZWNpbWFsIHBvaW50IG9yIHRvbyBtYW55IGZyYWN0aW9uYWwgcG9zaXRpb25zXHJcbiAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGd3ZWkgdmFsdWU6ICR7X3ZhbHVlfWApO1xyXG4gICAgfVxyXG4gICAgLy8gUGFkIHRoZSBmcmFjdGlvbiB0byA5IGRlY2ltYWxwbGFjZXNcclxuICAgIHdoaWxlIChjb21wc1sxXS5sZW5ndGggPCBkZWNpbWFscykge1xyXG4gICAgICAgIGNvbXBzWzFdICs9IFwiMFwiO1xyXG4gICAgfVxyXG4gICAgLy8gVG9vIG1hbnkgZGVjaW1hbHMgYW5kIHNvbWUgbm9uLXplcm8gZW5kaW5nLCB0YWtlIHRoZSBjZWlsaW5nXHJcbiAgICBpZiAoY29tcHNbMV0ubGVuZ3RoID4gOSkge1xyXG4gICAgICAgIGxldCBmcmFjID0gQmlnSW50KGNvbXBzWzFdLnN1YnN0cmluZygwLCA5KSk7XHJcbiAgICAgICAgaWYgKCFjb21wc1sxXS5zdWJzdHJpbmcoOSkubWF0Y2goL14wKyQvKSkge1xyXG4gICAgICAgICAgICBmcmFjKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBzWzFdID0gZnJhYy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJpZ0ludChjb21wc1swXSArIGNvbXBzWzFdKTtcclxufVxyXG4vLyBVc2VkIGJ5IFBvbHlnb24gdG8gdXNlIGEgZ2FzIHN0YXRpb24gZm9yIGZlZSBkYXRhXHJcbmZ1bmN0aW9uIGdldEdhc1N0YXRpb25QbHVnaW4odXJsKSB7XHJcbiAgICByZXR1cm4gbmV3IEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4odXJsLCBhc3luYyAoZmV0Y2hGZWVEYXRhLCBwcm92aWRlciwgcmVxdWVzdCkgPT4ge1xyXG4gICAgICAgIC8vIFByZXZlbnQgQ2xvdWRmbGFyZSBmcm9tIGJsb2NraW5nIG91ciByZXF1ZXN0IGluIG5vZGUuanNcclxuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcIlVzZXItQWdlbnRcIiwgXCJldGhlcnNcIik7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IFtfcmVzcG9uc2UsIF9mZWVEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpLCBmZXRjaEZlZURhdGEoKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfcmVzcG9uc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSByZXNwb25zZS5ib2R5SnNvbi5zdGFuZGFyZDtcclxuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBfZmVlRGF0YS5nYXNQcmljZSxcclxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogcGFyc2VVbml0cyhwYXlsb2FkLm1heEZlZSwgOSksXHJcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcGFyc2VVbml0cyhwYXlsb2FkLm1heFByaW9yaXR5RmVlLCA5KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGZlZURhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGBlcnJvciBlbmNvdW50ZXJlZCB3aXRoIHBvbHlnb24gZ2FzIHN0YXRpb24gKCR7SlNPTi5zdHJpbmdpZnkocmVxdWVzdC51cmwpfSlgLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlLCBlcnJvciB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vLyBTZWU6IGh0dHBzOi8vY2hhaW5saXN0Lm9yZ1xyXG5sZXQgaW5qZWN0ZWQgPSBmYWxzZTtcclxuZnVuY3Rpb24gaW5qZWN0Q29tbW9uTmV0d29ya3MoKSB7XHJcbiAgICBpZiAoaW5qZWN0ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpbmplY3RlZCA9IHRydWU7XHJcbiAgICAvLy8gUmVnaXN0ZXIgcG9wdWxhciBFdGhlcmV1bSBuZXR3b3Jrc1xyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJFdGgobmFtZSwgY2hhaW5JZCwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGZ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXcgTmV0d29yayhuYW1lLCBjaGFpbklkKTtcclxuICAgICAgICAgICAgLy8gV2UgdXNlIDAgdG8gZGlzYWJsZSBFTlNcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5zTmV0d29yayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihuZXcgRW5zUGx1Z2luKG51bGwsIG9wdGlvbnMuZW5zTmV0d29yaykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKG5ldyBHYXNDb3N0UGx1Z2luKCkpO1xyXG4gICAgICAgICAgICAob3B0aW9ucy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKChwbHVnaW4pID0+IHtcclxuICAgICAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKHBsdWdpbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXR3b3JrIGJ5IG5hbWUgYW5kIGNoYWluIElEXHJcbiAgICAgICAgTmV0d29yay5yZWdpc3RlcihuYW1lLCBmdW5jKTtcclxuICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKGNoYWluSWQsIGZ1bmMpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmFsdE5hbWVzKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuYWx0TmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgTmV0d29yay5yZWdpc3RlcihuYW1lLCBmdW5jKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJFdGgoXCJtYWlubmV0XCIsIDEsIHsgZW5zTmV0d29yazogMSwgYWx0TmFtZXM6IFtcImhvbWVzdGVhZFwiXSB9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwicm9wc3RlblwiLCAzLCB7IGVuc05ldHdvcms6IDMgfSk7XHJcbiAgICByZWdpc3RlckV0aChcInJpbmtlYnlcIiwgNCwgeyBlbnNOZXR3b3JrOiA0IH0pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJnb2VybGlcIiwgNSwgeyBlbnNOZXR3b3JrOiA1IH0pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJrb3ZhblwiLCA0MiwgeyBlbnNOZXR3b3JrOiA0MiB9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwic2Vwb2xpYVwiLCAxMTE1NTExMSwgeyBlbnNOZXR3b3JrOiAxMTE1NTExMSB9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwiaG9sZXNreVwiLCAxNzAwMCwgeyBlbnNOZXR3b3JrOiAxNzAwMCB9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY1wiLCA2MSwge30pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJjbGFzc2ljS290dGlcIiwgNiwge30pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bVwiLCA0MjE2MSwge1xyXG4gICAgICAgIGVuc05ldHdvcms6IDEsXHJcbiAgICB9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tZ29lcmxpXCIsIDQyMTYxMywge30pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bS1zZXBvbGlhXCIsIDQyMTYxNCwge30pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJiYXNlXCIsIDg0NTMsIHsgZW5zTmV0d29yazogMSB9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1nb2VybGlcIiwgODQ1MzEsIHt9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1zZXBvbGlhXCIsIDg0NTMyLCB7fSk7XHJcbiAgICByZWdpc3RlckV0aChcImJuYlwiLCA1NiwgeyBlbnNOZXR3b3JrOiAxIH0pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJibmJ0XCIsIDk3LCB7fSk7XHJcbiAgICByZWdpc3RlckV0aChcImxpbmVhXCIsIDU5MTQ0LCB7IGVuc05ldHdvcms6IDEgfSk7XHJcbiAgICByZWdpc3RlckV0aChcImxpbmVhLWdvZXJsaVwiLCA1OTE0MCwge30pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1zZXBvbGlhXCIsIDU5MTQxLCB7fSk7XHJcbiAgICByZWdpc3RlckV0aChcIm1hdGljXCIsIDEzNywge1xyXG4gICAgICAgIGVuc05ldHdvcms6IDEsXHJcbiAgICAgICAgcGx1Z2luczogW1xyXG4gICAgICAgICAgICBnZXRHYXNTdGF0aW9uUGx1Z2luKFwiaHR0cHM6L1xcL2dhc3N0YXRpb24ucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXHJcbiAgICAgICAgXVxyXG4gICAgfSk7XHJcbiAgICByZWdpc3RlckV0aChcIm1hdGljLWFtb3lcIiwgODAwMDIsIHt9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwibWF0aWMtbXVtYmFpXCIsIDgwMDAxLCB7XHJcbiAgICAgICAgYWx0TmFtZXM6IFtcIm1hdGljTXVtYmFpXCIsIFwibWF0aWNtdW1cIl0sXHJcbiAgICAgICAgcGx1Z2luczogW1xyXG4gICAgICAgICAgICBnZXRHYXNTdGF0aW9uUGx1Z2luKFwiaHR0cHM6L1xcL2dhc3N0YXRpb24tdGVzdG5ldC5wb2x5Z29uLnRlY2hub2xvZ3kvdjJcIilcclxuICAgICAgICBdXHJcbiAgICB9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc21cIiwgMTAsIHtcclxuICAgICAgICBlbnNOZXR3b3JrOiAxLFxyXG4gICAgICAgIHBsdWdpbnM6IFtdXHJcbiAgICB9KTtcclxuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tZ29lcmxpXCIsIDQyMCwge30pO1xyXG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbS1zZXBvbGlhXCIsIDExMTU1NDIwLCB7fSk7XHJcbiAgICByZWdpc3RlckV0aChcInhkYWlcIiwgMTAwLCB7IGVuc05ldHdvcms6IDEgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29yay5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcclxufVxyXG4vKipcclxuICogIFJldHVybiB0aGUgcG9sbGluZyBzdWJzY3JpYmVyIGZvciBjb21tb24gZXZlbnRzLlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2xsaW5nU3Vic2NyaWJlcihwcm92aWRlciwgZXZlbnQpIHtcclxuICAgIGlmIChldmVudCA9PT0gXCJibG9ja1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIGlmIChpc0hleFN0cmluZyhldmVudCwgMzIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHByb3ZpZGVyLCBldmVudCk7XHJcbiAgICB9XHJcbiAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgcG9sbGluZyBldmVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgb3BlcmF0aW9uOiBcImdldFBvbGxpbmdTdWJzY3JpYmVyXCIsIGluZm86IHsgZXZlbnQgfVxyXG4gICAgfSk7XHJcbn1cclxuLy8gQFRPRE86IHJlZmFjdG9yIHRoaXNcclxuLyoqXHJcbiAqICBBICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIHBvbGxzIGF0IGEgcmVndWxhciBpbnRlcnZhbCBmb3IgYSBjaGFuZ2VcclxuICogIGluIHRoZSBibG9jayBudW1iZXIuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBvbGxpbmdCbG9ja1N1YnNjcmliZXIge1xyXG4gICAgI3Byb3ZpZGVyO1xyXG4gICAgI3BvbGxlcjtcclxuICAgICNpbnRlcnZhbDtcclxuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayB3ZSBoYXZlIHNjYW5uZWQgZm9yIGV2ZW50cy4gVGhlIHZhbHVlIC0yXHJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxyXG4gICAgI2Jsb2NrTnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWwgPSA0MDAwO1xyXG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcG9sbGluZyBpbnRlcnZhbC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI2ludGVydmFsOyB9XHJcbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7IHRoaXMuI2ludGVydmFsID0gdmFsdWU7IH1cclxuICAgIGFzeW5jICNwb2xsKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgICAgICAgICAgLy8gQm9vdHN0cmFwIHBvbGwgdG8gc2V0dXAgb3VyIGluaXRpYWwgYmxvY2sgbnVtYmVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQFRPRE86IFB1dCBhIGNhcCBvbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHBlciBsb29wP1xyXG4gICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgIT09IHRoaXMuI2Jsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiID0gdGhpcy4jYmxvY2tOdW1iZXIgKyAxOyBiIDw9IGJsb2NrTnVtYmVyOyBiKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwb2xsZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmVtaXQoXCJibG9ja1wiLCBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIC8vIEBUT0RPOiBNaW5vciBidW1wLCBhZGQgYW4gXCJlcnJvclwiIGV2ZW50IHRvIGxldCBzdWJzY3JpYmVyc1xyXG4gICAgICAgICAgICAvLyAgICAgICAga25vdyB0aGluZ3Mgd2VudCBhd3J5LlxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIHN0b3BwZWRcclxuICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcclxuICAgICAgICB0aGlzLiNwb2xsKCk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICghdGhpcy4jcG9sbGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIuX2NsZWFyVGltZW91dCh0aGlzLiNwb2xsZXIpO1xyXG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEFuICoqT25CbG9ja1N1YnNjcmliZXIqKiBjYW4gYmUgc3ViLWNsYXNzZWQsIHdpdGggYSBbW19wb2xsXV1cclxuICogIGltcGxtZW50YXRpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBPbkJsb2NrU3Vic2NyaWJlciB7XHJcbiAgICAjcHJvdmlkZXI7XHJcbiAgICAjcG9sbDtcclxuICAgICNydW5uaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqT25CbG9ja1N1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy4jcG9sbCA9IChibG9ja051bWJlcikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2xsKGJsb2NrTnVtYmVyLCB0aGlzLiNwcm92aWRlcik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENhbGxlZCBvbiBldmVyeSBuZXcgYmxvY2suXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Yi1jbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy4jcG9sbCgtMik7XHJcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub24oXCJibG9ja1wiLCB0aGlzLiNwb2xsKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGwpO1xyXG4gICAgfVxyXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7IHRoaXMuc3RvcCgpOyB9XHJcbiAgICByZXN1bWUoKSB7IHRoaXMuc3RhcnQoKTsgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xyXG4gICAgI3RhZztcclxuICAgICNsYXN0QmxvY2s7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuI3RhZyA9IHRhZztcclxuICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSAtMjtcclxuICAgIH1cclxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xyXG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcclxuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gLTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrKHRoaXMuI3RhZyk7XHJcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrID09PSAtMikge1xyXG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSBibG9jay5udW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJsb2NrLm51bWJlciA+IHRoaXMuI2xhc3RCbG9jaykge1xyXG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI3RhZywgYmxvY2subnVtYmVyKTtcclxuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gYmxvY2subnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogIEBfaWdub3JlOlxyXG4gKlxyXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcclxuICAgICNmaWx0ZXI7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XHJcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuI2ZpbHRlcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvblxyXG4gKiAgaGFzaCBmb3IgaXRzIHJlY2VpcHQuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XHJcbiAgICAjaGFzaDtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiBhdHRhY2hlZCB0b1xyXG4gICAgICogICUlcHJvdmlkZXIlJSwgbGlzdGVuaW5nIGZvciAlJWhhc2glJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGhhc2gpIHtcclxuICAgICAgICBzdXBlcihwcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy4jaGFzaCA9IGhhc2g7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLiNoYXNoKTtcclxuICAgICAgICBpZiAodHgpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiNoYXNoLCB0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSAqKlBvbGxpbmdFdmVudFN1YnNjcmliZXIqKiB3aWxsIHBvbGwgZm9yIGEgZ2l2ZW4gZmlsdGVyIGZvciBpdHMgbG9ncy5cclxuICpcclxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB7XHJcbiAgICAjcHJvdmlkZXI7XHJcbiAgICAjZmlsdGVyO1xyXG4gICAgI3BvbGxlcjtcclxuICAgICNydW5uaW5nO1xyXG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcclxuICAgIC8vIGluZGljYXRlcyB3ZSBzdGlsbCBuZWVkIHRvIGZldGNoIGFuIGluaXRpYWwgYmxvY2sgbnVtYmVyXHJcbiAgICAjYmxvY2tOdW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cclxuICAgICAqICAlJXByb3ZpZGVyJSUsIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xyXG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gY29weShmaWx0ZXIpO1xyXG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcclxuICAgIH1cclxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgLy8gVGhlIGluaXRpYWwgYmxvY2sgaGFzbid0IGJlZW4gZGV0ZXJtaW5lZCB5ZXRcclxuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0gY29weSh0aGlzLiNmaWx0ZXIpO1xyXG4gICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSB0aGlzLiNibG9ja051bWJlciArIDE7XHJcbiAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSBibG9ja051bWJlcjtcclxuICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xyXG4gICAgICAgIC8vIE5vIGxvZ3MgY291bGQganVzdCBtZWFuIHRoZSBub2RlIGhhcyBub3QgaW5kZXhlZCB0aGVtIHlldCxcclxuICAgICAgICAvLyBzbyB3ZSBrZWVwIGEgc2xpZGluZyB3aW5kb3cgb2YgNjAgYmxvY2tzIHRvIGtlZXAgc2Nhbm5pbmdcclxuICAgICAgICBpZiAobG9ncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyIDwgYmxvY2tOdW1iZXIgLSA2MCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDYwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xyXG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5lbWl0KHRoaXMuI2ZpbHRlciwgbG9nKTtcclxuICAgICAgICAgICAgLy8gT25seSBhZHZhbmNlIHRoZSBibG9jayBudW1iZXIgd2hlbiBsb2dzIHdlcmUgZm91bmQgdG9cclxuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgbmV0d29ya3MgKGxpa2UgQk5CIGFuZCBQb2x5Z29uKSB3aGljaCBtYXlcclxuICAgICAgICAgICAgLy8gc2FjcmlmaWNlIGV2ZW50IGNvbnNpc3RlbmN5IGZvciBibG9jayBldmVudCBzcGVlZFxyXG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGxvZy5ibG9ja051bWJlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcclxuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChibG9ja051bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XHJcbiAgICB9XHJcbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLXBvbGxpbmcuanMubWFwIiwiLyoqXHJcbiAqICBUaGUgYXZhaWxhYmxlIHByb3ZpZGVycyBzaG91bGQgc3VmZmljZSBmb3IgbW9zdCBkZXZlbG9wZXJzIHB1cnBvc2VzLFxyXG4gKiAgYnV0IHRoZSBbW0Fic3RyYWN0UHJvdmlkZXJdXSBjbGFzcyBoYXMgbWFueSBmZWF0dXJlcyB3aGljaCBlbmFibGVcclxuICogIHN1Yi1jbGFzc2luZyBpdCBmb3Igc3BlY2lmaWMgcHVycG9zZXMuXHJcbiAqXHJcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXI6IFN1YmNsYXNzaW5nIFByb3ZpZGVyICBbYWJzdHJhY3QtcHJvdmlkZXJdXHJcbiAqL1xyXG4vLyBAVE9ET1xyXG4vLyBFdmVudCBjb2FsZXNjZW5jZVxyXG4vLyAgIFdoZW4gd2UgcmVnaXN0ZXIgYW4gZXZlbnQgd2l0aCBhbiBhc3luYyB2YWx1ZSAoZS5nLiBhZGRyZXNzIGlzIGEgU2lnbmVyXHJcbi8vICAgb3IgRU5TIG5hbWUpLCB3ZSBuZWVkIHRvIGFkZCBpdCBpbW1laWRhdGVseSBmb3IgdGhlIEV2ZW50IEFQSSwgYnV0IGFsc29cclxuLy8gICBuZWVkIHRpbWUgdG8gcmVzb2x2ZSB0aGUgYWRkcmVzcy4gVXBvbiByZXNvbHZpbmcgdGhlIGFkZHJlc3MsIHdlIG5lZWQgdG9cclxuLy8gICBtaWdyYXRlIHRoZSBsaXN0ZW5lciB0byB0aGUgc3RhdGljIGV2ZW50LiBXZSBhbHNvIG5lZWQgdG8gbWFpbnRhaW4gYSBtYXBcclxuLy8gICBvZiBTaWduZXIvRU5TIG5hbWUgdG8gYWRkcmVzcyBzbyB3ZSBjYW4gc3luYyByZXNwb25kIHRvIGxpc3RlbmVyQ291bnQuXHJcbmltcG9ydCB7IGdldEFkZHJlc3MsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBkYXRhU2xpY2UsIGhleGxpZnksIGlzSGV4U3RyaW5nLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXROdW1iZXIsIGlzQ2FsbEV4Y2VwdGlvbiwgaXNFcnJvciwgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBGZXRjaFJlcXVlc3QsIHRvQmVBcnJheSwgdG9RdWFudGl0eSwgZGVmaW5lUHJvcGVydGllcywgRXZlbnRQYXlsb2FkLCByZXNvbHZlUHJvcGVydGllcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IEVuc1Jlc29sdmVyIH0gZnJvbSBcIi4vZW5zLXJlc29sdmVyLmpzXCI7XHJcbmltcG9ydCB7IGZvcm1hdEJsb2NrLCBmb3JtYXRMb2csIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCwgZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuL2Zvcm1hdC5qc1wiO1xyXG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xyXG5pbXBvcnQgeyBjb3B5UmVxdWVzdCwgQmxvY2ssIEZlZURhdGEsIExvZywgVHJhbnNhY3Rpb25SZWNlaXB0LCBUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcclxuaW1wb3J0IHsgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciwgUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciwgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciwgUG9sbGluZ09ycGhhblN1YnNjcmliZXIsIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcclxuLy8gQ29uc3RhbnRzXHJcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XHJcbmNvbnN0IE1BWF9DQ0lQX1JFRElSRUNUUyA9IDEwO1xyXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcclxuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS50aGVuKSA9PT0gXCJmdW5jdGlvblwiKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUYWcocHJlZml4LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHByZWZpeCArIFwiOlwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrLCB2KSA9PiB7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcImJpZ2ludFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgYmlnaW50OiR7di50b1N0cmluZygpfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNvcnQgb2JqZWN0IGtleXNcclxuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2KSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModik7XHJcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKGFjY3VtLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGFjY3VtW2tleV0gPSB2W2tleV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICAgICAgICAgIH0sIHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogIEFuICoqVW5tYW5hZ2VkU3Vic2NyaWJlcioqIGlzIHVzZWZ1bCBmb3IgZXZlbnRzIHdoaWNoIGRvIG5vdCByZXF1aXJlXHJcbiAqICBhbnkgYWRkaXRpb25hbCBtYW5hZ2VtZW50LCBzdWNoIGFzIGBgXCJkZWJ1Z1wiYGAgd2hpY2ggb25seSByZXF1aXJlc1xyXG4gKiAgZW1pdCBpbiBzeW5jaHJvbm91cyBldmVudCBsb29wIHRyaWdnZXJlZCBjYWxscy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBVbm1hbmFnZWRTdWJzY3JpYmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBuYW1lIGZvZiB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIG5hbWU7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGUgYSBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlciB3aXRoICUlbmFtZSUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7IGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pOyB9XHJcbiAgICBzdGFydCgpIHsgfVxyXG4gICAgc3RvcCgpIHsgfVxyXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7IH1cclxuICAgIHJlc3VtZSgpIHsgfVxyXG59XHJcbmZ1bmN0aW9uIGNvcHkodmFsdWUpIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gY29uY2lzaWZ5KGl0ZW1zKSB7XHJcbiAgICBpdGVtcyA9IEFycmF5LmZyb20oKG5ldyBTZXQoaXRlbXMpKS52YWx1ZXMoKSk7XHJcbiAgICBpdGVtcy5zb3J0KCk7XHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uKF9ldmVudCwgcHJvdmlkZXIpIHtcclxuICAgIGlmIChfZXZlbnQgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnRcIik7XHJcbiAgICB9XHJcbiAgICAvLyBOb3JtYWxpemUgdG9waWMgYXJyYXkgaW5mbyBhbiBFdmVudEZpbHRlclxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2V2ZW50KSkge1xyXG4gICAgICAgIF9ldmVudCA9IHsgdG9waWNzOiBfZXZlbnQgfTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgKF9ldmVudCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBzd2l0Y2ggKF9ldmVudCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjpcclxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IF9ldmVudCwgdGFnOiBfZXZlbnQgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0hleFN0cmluZyhfZXZlbnQsIDMyKSkge1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBfZXZlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRyYW5zYWN0aW9uXCIsIHRhZzogZ2V0VGFnKFwidHhcIiwgeyBoYXNoIH0pLCBoYXNoIH07XHJcbiAgICB9XHJcbiAgICBpZiAoX2V2ZW50Lm9ycGhhbikge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xyXG4gICAgICAgIC8vIEBUT0RPOiBTaG91bGQgbG93ZXJjYXNlIGFuZCB3aGF0bm90IHRoaW5ncyBoZXJlIGluc3RlYWQgb2YgY29weS4uLlxyXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwib3JwaGFuXCIsIHRhZzogZ2V0VGFnKFwib3JwaGFuXCIsIGV2ZW50KSwgZmlsdGVyOiBjb3B5KGV2ZW50KSB9O1xyXG4gICAgfVxyXG4gICAgaWYgKChfZXZlbnQuYWRkcmVzcyB8fCBfZXZlbnQudG9waWNzKSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xyXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHtcclxuICAgICAgICAgICAgdG9waWNzOiAoKGV2ZW50LnRvcGljcyB8fCBbXSkubWFwKCh0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25jaXNpZnkodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoZXZlbnQuYWRkcmVzcykge1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgYWRkQWRkcmVzcyA9IChhZGRyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYWRkcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYXdhaXQgcmVzb2x2ZUFkZHJlc3MoYWRkciwgcHJvdmlkZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQuYWRkcmVzcykpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LmFkZHJlc3MuZm9yRWFjaChhZGRBZGRyZXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFkZEFkZHJlc3MoZXZlbnQuYWRkcmVzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gY29uY2lzaWZ5KGFkZHJlc3Nlcy5tYXAoKGEpID0+IGEudG9Mb3dlckNhc2UoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBmaWx0ZXIsIHRhZzogZ2V0VGFnKFwiZXZlbnRcIiwgZmlsdGVyKSwgdHlwZTogXCJldmVudFwiIH07XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIFByb3ZpZGVyRXZlbnRcIiwgXCJldmVudFwiLCBfZXZlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgY2FjaGVUaW1lb3V0OiAyNTAsXHJcbiAgICBwb2xsaW5nSW50ZXJ2YWw6IDQwMDBcclxufTtcclxuLyoqXHJcbiAqICBBbiAqKkFic3RyYWN0UHJvdmlkZXIqKiBwcm92aWRlcyBhIGJhc2UgY2xhc3MgZm9yIG90aGVyIHN1Yi1jbGFzc2VzIHRvXHJcbiAqICBpbXBsZW1lbnQgdGhlIFtbUHJvdmlkZXJdXSBBUEkgYnkgbm9ybWFsaXppbmcgaW5wdXQgYXJndW1lbnRzIGFuZFxyXG4gKiAgZm9ybWF0dGluZyBvdXRwdXQgcmVzdWx0cyBhcyB3ZWxsIGFzIHRyYWNraW5nIGV2ZW50cyBmb3IgY29uc2lzdGVudFxyXG4gKiAgYmVoYXZpb3VyIG9uIGFuIGV2ZW50dWFsbHktY29uc2lzdGVudCBuZXR3b3JrLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFic3RyYWN0UHJvdmlkZXIge1xyXG4gICAgI3N1YnM7XHJcbiAgICAjcGx1Z2lucztcclxuICAgIC8vIG51bGw9dW5wYXVzZWQsIHRydWU9cGF1c2VkK2Ryb3BXaGlsZVBhdXNlZCwgZmFsc2U9cGF1c2VkXHJcbiAgICAjcGF1c2VkU3RhdGU7XHJcbiAgICAjZGVzdHJveWVkO1xyXG4gICAgI25ldHdvcmtQcm9taXNlO1xyXG4gICAgI2FueU5ldHdvcms7XHJcbiAgICAjcGVyZm9ybUNhY2hlO1xyXG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIG51bWJlciBpZiBydW5uaW5nIGFuIGV2ZW50IG9yIC0xIGlmIG5vIFwiYmxvY2tcIiBldmVudFxyXG4gICAgI2xhc3RCbG9ja051bWJlcjtcclxuICAgICNuZXh0VGltZXI7XHJcbiAgICAjdGltZXJzO1xyXG4gICAgI2Rpc2FibGVDY2lwUmVhZDtcclxuICAgICNvcHRpb25zO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQWJzdHJhY3RQcm92aWRlcioqIGNvbm5lY3RlZCB0byAlJW5ldHdvcmslJSwgb3JcclxuICAgICAqICB1c2UgdGhlIHZhcmlvdXMgbmV0d29yayBkZXRlY3Rpb24gY2FwYWJpbGl0aWVzIHRvIGRpc2NvdmVyIHRoZVxyXG4gICAgICogIFtbTmV0d29ya11dIGlmIG5lY2Vzc2FyeS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xyXG4gICAgICAgIGlmIChfbmV0d29yayA9PT0gXCJhbnlcIikge1xyXG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChfbmV0d29yaykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcclxuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShuZXR3b3JrKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7IH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xyXG4gICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLiNzdWJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuI3BsdWdpbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuI25leHRUaW1lciA9IDE7XHJcbiAgICAgICAgdGhpcy4jdGltZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuI2Rpc2FibGVDY2lwUmVhZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI29wdGlvbnMucG9sbGluZ0ludGVydmFsOyB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGBgdGhpc2BgLCB0byBhbGxvdyBhbiAqKkFic3RyYWN0UHJvdmlkZXIqKiB0byBpbXBsZW1lbnRcclxuICAgICAqICB0aGUgW1tDb250cmFjdFJ1bm5lcl1dIGludGVyZmFjZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHByb3ZpZGVyKCkgeyByZXR1cm4gdGhpczsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhbGwgdGhlIHJlZ2lzdGVyZWQgcGx1Zy1pbnMuXHJcbiAgICAgKi9cclxuICAgIGdldCBwbHVnaW5zKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI3BsdWdpbnMudmFsdWVzKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQXR0YWNoIGEgbmV3IHBsdWctaW4uXHJcbiAgICAgKi9cclxuICAgIGF0dGFjaFBsdWdpbihwbHVnaW4pIHtcclxuICAgICAgICBpZiAodGhpcy4jcGx1Z2lucy5nZXQocGx1Z2luLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcGx1Z2lucy5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbi5jb25uZWN0KHRoaXMpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEdldCBhIHBsdWdpbiBieSBuYW1lLlxyXG4gICAgICovXHJcbiAgICBnZXRQbHVnaW4obmFtZSkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBQcmV2ZW50IGFueSBDQ0lQLXJlYWQgb3BlcmF0aW9uLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgcmVxdWVzdGVkXHJcbiAgICAgKiAgaW4gYSBbW2NhbGxdXSB1c2luZyBgYGVuYWJsZUNjaXBSZWFkYGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBkaXNhYmxlQ2NpcFJlYWQoKSB7IHJldHVybiB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQ7IH1cclxuICAgIHNldCBkaXNhYmxlQ2NpcFJlYWQodmFsdWUpIHsgdGhpcy4jZGlzYWJsZUNjaXBSZWFkID0gISF2YWx1ZTsgfVxyXG4gICAgLy8gU2hhcmVzIG11bHRpcGxlIGlkZW50aWNhbCByZXF1ZXN0cyBtYWRlIGR1cmluZyB0aGUgc2FtZSAyNTBtc1xyXG4gICAgYXN5bmMgI3BlcmZvcm0ocmVxKSB7XHJcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuI29wdGlvbnMuY2FjaGVUaW1lb3V0O1xyXG4gICAgICAgIC8vIENhY2hpbmcgZGlzYWJsZWRcclxuICAgICAgICBpZiAodGltZW91dCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3BlcmZvcm0ocmVxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGFnXHJcbiAgICAgICAgY29uc3QgdGFnID0gZ2V0VGFnKHJlcS5tZXRob2QsIHJlcSk7XHJcbiAgICAgICAgbGV0IHBlcmZvcm0gPSB0aGlzLiNwZXJmb3JtQ2FjaGUuZ2V0KHRhZyk7XHJcbiAgICAgICAgaWYgKCFwZXJmb3JtKSB7XHJcbiAgICAgICAgICAgIHBlcmZvcm0gPSB0aGlzLl9wZXJmb3JtKHJlcSk7XHJcbiAgICAgICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZS5zZXQodGFnLCBwZXJmb3JtKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpID09PSBwZXJmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlLmRlbGV0ZSh0YWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZGF0YSBmb3IgZXhlY3V0aW5nIHRoZSBDQ0lQLXJlYWQgb3BlcmF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgY2NpcFJlYWRGZXRjaCh0eCwgY2FsbGRhdGEsIHVybHMpIHtcclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ2NpcFJlYWQgfHwgdXJscy5sZW5ndGggPT09IDAgfHwgdHgudG8gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gdHgudG8udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gY2FsbGRhdGEudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHVybHNbaV07XHJcbiAgICAgICAgICAgIC8vIFVSTCBleHBhbnNpb25cclxuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHVybC5yZXBsYWNlKFwie3NlbmRlcn1cIiwgc2VuZGVyKS5yZXBsYWNlKFwie2RhdGF9XCIsIGRhdGEpO1xyXG4gICAgICAgICAgICAvLyBJZiBubyB7ZGF0YX0gaXMgcHJlc2VudCwgdXNlIFBPU1Q7IG90aGVyd2lzZSBHRVRcclxuICAgICAgICAgICAgLy9jb25zdCBqc29uOiBzdHJpbmcgfCBudWxsID0gKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID49IDApID8gbnVsbDogSlNPTi5zdHJpbmdpZnkoeyBkYXRhLCBzZW5kZXIgfSk7XHJcbiAgICAgICAgICAgIC8vY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2hKc29uKHsgdXJsOiBocmVmLCBlcnJvclBhc3NUaHJvdWdoOiB0cnVlIH0sIGpzb24sICh2YWx1ZSwgcmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgLy8gICAgdmFsdWUuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcclxuICAgICAgICAgICAgLy8gICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAvL30pO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdChocmVmKTtcclxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0geyBkYXRhLCBzZW5kZXIgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRGZXRjaFJlcXVlc3RcIiwgcmVxdWVzdCwgaW5kZXg6IGksIHVybHMgfSk7XHJcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcInVua25vd24gZXJyb3JcIjtcclxuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHJlc291cmNlLi4uXHJcbiAgICAgICAgICAgIGxldCByZXNwO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVzcCA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gLi4ubG93LWxldmVsIGZldGNoIGVycm9yIChtaXNzaW5nIGhvc3QsIGJhZCBTU0wsIGV0Yy4pLFxyXG4gICAgICAgICAgICAgICAgLy8gc28gdHJ5IG5leHQgVVJMXHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaEVycm9yXCIsIHJlcXVlc3QsIHJlc3VsdDogeyBlcnJvciB9IH0pO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3AuYm9keUpzb247XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaFJlc3VsdFwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gcmVzdWx0Lm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaEVycm9yXCIsIHJlcXVlc3QsIHJlc3VsdCB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgICAgICAvLyA0eHggaW5kaWNhdGVzIHRoZSByZXN1bHQgaXMgbm90IHByZXNlbnQ7IHN0b3BcclxuICAgICAgICAgICAgYXNzZXJ0KHJlc3Auc3RhdHVzQ29kZSA8IDQwMCB8fCByZXNwLnN0YXR1c0NvZGUgPj0gNTAwLCBgcmVzcG9uc2Ugbm90IGZvdW5kIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZX1gLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHsgcmVhc29uOiBcIjQwNF9NSVNTSU5HX1JFU09VUkNFXCIsIHRyYW5zYWN0aW9uOiB0eCwgaW5mbzogeyB1cmwsIGVycm9yTWVzc2FnZSB9IH0pO1xyXG4gICAgICAgICAgICAvLyA1eHggaW5kaWNhdGVzIHNlcnZlciBpc3N1ZTsgdHJ5IHRoZSBuZXh0IHVybFxyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlcy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0pKS5qb2luKFwiLCBcIil9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIHJlYXNvbjogXCI1MDBfU0VSVkVSX0VSUk9SXCIsXHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCwgaW5mbzogeyB1cmxzLCBlcnJvck1lc3NhZ2VzIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGJsb2NrIGJlZm9yZVxyXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcclxuICAgICAqICBzdWItY2xhc3Mgb2YgW1tCbG9ja11dLlxyXG4gICAgICovXHJcbiAgICBfd3JhcEJsb2NrKHZhbHVlLCBuZXR3b3JrKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9jayhmb3JtYXRCbG9jayh2YWx1ZSksIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgbG9nIGJlZm9yZVxyXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcclxuICAgICAqICBzdWItY2xhc3Mgb2YgW1tMb2ddXS5cclxuICAgICAqL1xyXG4gICAgX3dyYXBMb2codmFsdWUsIG5ldHdvcmspIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvZyhmb3JtYXRMb2codmFsdWUpLCB0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIHRyYW5zYWN0aW9uXHJcbiAgICAgKiAgcmVjZWlwdCBiZWZvcmUgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuXHJcbiAgICAgKiAgYWx0ZXJuYXRlIHN1Yi1jbGFzcyBvZiBbW1RyYW5zYWN0aW9uUmVjZWlwdF1dLlxyXG4gICAgICovXHJcbiAgICBfd3JhcFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSwgbmV0d29yaykge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZWNlaXB0KGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSksIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgdHJhbnNhY3Rpb25cclxuICAgICAqICByZXNwb25zZSBiZWZvcmUgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuXHJcbiAgICAgKiAgYWx0ZXJuYXRlIHN1Yi1jbGFzcyBvZiBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cclxuICAgICAqL1xyXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodHgpLCB0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBOZXR3b3JrLCBmb3JjaW5nIGEgbmV0d29yayBkZXRlY3Rpb24gdXNpbmcgd2hhdGV2ZXJcclxuICAgICAqICB0ZWNobmlxdWUgdGhlIHN1Yi1jbGFzcyByZXF1aXJlcy5cclxuICAgICAqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcy5cclxuICAgICAqL1xyXG4gICAgX2RldGVjdE5ldHdvcmsoKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInN1Yi1jbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IFwiX2RldGVjdE5ldHdvcmtcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgc2hvdWxkIHVzZSB0aGlzIHRvIHBlcmZvcm0gYWxsIGJ1aWx0LWluIG9wZXJhdGlvbnMuIEFsbFxyXG4gICAgICogIG1ldGhvZHMgc2FuaXRpemVzIGFuZCBub3JtYWxpemVzIHRoZSB2YWx1ZXMgcGFzc2VkIGludG8gdGhpcy5cclxuICAgICAqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5zdXBwb3J0ZWQgbWV0aG9kOiAke3JlcS5tZXRob2R9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICBvcGVyYXRpb246IHJlcS5tZXRob2QsXHJcbiAgICAgICAgICAgIGluZm86IHJlcVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gU3RhdGVcclxuICAgIGFzeW5jIGdldEJsb2NrTnVtYmVyKCkge1xyXG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gZ2V0TnVtYmVyKGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0QmxvY2tOdW1iZXJcIiB9KSwgXCIlcmVzcG9uc2VcIik7XHJcbiAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWFkZHJlc3MlJSwgcmVzb2x2aW5nIEVOU1xyXG4gICAgICogIG5hbWVzIGFuZCBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0cyBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYW5cclxuICAgICAqICBhZGRyZXNzLlxyXG4gICAgICovXHJcbiAgICBfZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKGFkZHJlc3MsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIHZhbGlkIGJsb2NrIHRhZyBmb3IgJSVibG9ja1RhZyUlLCByZXNvbHZpbmdcclxuICAgICAqICBuZWdhdGl2ZSB2YWx1ZXMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWQgYmxvY2sgdGFnLlxyXG4gICAgICovXHJcbiAgICBfZ2V0QmxvY2tUYWcoYmxvY2tUYWcpIHtcclxuICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChibG9ja1RhZykge1xyXG4gICAgICAgICAgICBjYXNlIFwiZWFybGllc3RcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIjB4MFwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJsYXRlc3RcIjpcclxuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrVGFnKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tUYWcsIDMyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KGJsb2NrVGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcImJpZ2ludFwiKSB7XHJcbiAgICAgICAgICAgIGJsb2NrVGFnID0gZ2V0TnVtYmVyKGJsb2NrVGFnLCBcImJsb2NrVGFnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKGJsb2NrVGFnID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KGJsb2NrVGFnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrTnVtYmVyID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KHRoaXMuI2xhc3RCbG9ja051bWJlciArIGJsb2NrVGFnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCbG9ja051bWJlcigpLnRoZW4oKGIpID0+IHRvUXVhbnRpdHkoYiArIGJsb2NrVGFnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgYmxvY2tUYWdcIiwgXCJibG9ja1RhZ1wiLCBibG9ja1RhZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgZmlsdGVyIGZvciAlJWZpbHRlciUlLCByZXNvbHZpbmcgYW55IEVOU1xyXG4gICAgICogIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBvYmplY3QgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWRcclxuICAgICAqICBmaWx0ZXIuXHJcbiAgICAgKi9cclxuICAgIF9nZXRGaWx0ZXIoZmlsdGVyKSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgY2Fub25pY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b3BpY3NcclxuICAgICAgICBjb25zdCB0b3BpY3MgPSAoZmlsdGVyLnRvcGljcyB8fCBbXSkubWFwKCh0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2lzaWZ5KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGJsb2NrSGFzaCA9IChcImJsb2NrSGFzaFwiIGluIGZpbHRlcikgPyBmaWx0ZXIuYmxvY2tIYXNoIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSAoX2FkZHJlc3MsIGZyb21CbG9jaywgdG9CbG9jaykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYWRkcmVzcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgc3dpdGNoIChfYWRkcmVzcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBfYWRkcmVzcy5zb3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChibG9ja0hhc2gpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmcm9tQmxvY2sgIT0gbnVsbCB8fCB0b0Jsb2NrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpbHRlclwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7fTtcclxuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gYWRkcmVzcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodG9waWNzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gZnJvbUJsb2NrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0b0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9IHRvQmxvY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJsb2NrSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyLmJsb2NrSGFzaCA9IGJsb2NrSGFzaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQWRkcmVzc2VzIGNvdWxkIGJlIGFzeW5jIChFTlMgbmFtZXMgb3IgQWRkcmVzc2FibGVzKVxyXG4gICAgICAgIGxldCBhZGRyZXNzID0gW107XHJcbiAgICAgICAgaWYgKGZpbHRlci5hZGRyZXNzKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlci5hZGRyZXNzKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIG9mIGZpbHRlci5hZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRoaXMuX2dldEFkZHJlc3MoYWRkcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRoaXMuX2dldEFkZHJlc3MoZmlsdGVyLmFkZHJlc3MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZnJvbUJsb2NrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChcImZyb21CbG9ja1wiIGluIGZpbHRlcikge1xyXG4gICAgICAgICAgICBmcm9tQmxvY2sgPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXIuZnJvbUJsb2NrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRvQmxvY2sgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKFwidG9CbG9ja1wiIGluIGZpbHRlcikge1xyXG4gICAgICAgICAgICB0b0Jsb2NrID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyLnRvQmxvY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWRkcmVzcy5maWx0ZXIoKGEpID0+ICh0eXBlb2YgKGEpICE9PSBcInN0cmluZ1wiKSkubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIChmcm9tQmxvY2sgIT0gbnVsbCAmJiB0eXBlb2YgKGZyb21CbG9jaykgIT09IFwic3RyaW5nXCIpIHx8XHJcbiAgICAgICAgICAgICh0b0Jsb2NrICE9IG51bGwgJiYgdHlwZW9mICh0b0Jsb2NrKSAhPT0gXCJzdHJpbmdcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtQcm9taXNlLmFsbChhZGRyZXNzKSwgZnJvbUJsb2NrLCB0b0Jsb2NrXSkudGhlbigocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHRbMF0sIHJlc3VsdFsxXSwgcmVzdWx0WzJdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNvbHZlKGFkZHJlc3MsIGZyb21CbG9jaywgdG9CbG9jayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgdHJhbnNhY3Rpb24gZm9yICUlcmVxdWVzdCUlLCByZXNvbHZpbmdcclxuICAgICAqICBhbnkgRU5TIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZFxyXG4gICAgICogIHRyYW5zYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBfZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF9yZXF1ZXN0KSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNvcHlSZXF1ZXN0KF9yZXF1ZXN0KTtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIFtcInRvXCIsIFwiZnJvbVwiXS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3Rba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYWRkciA9IHJlc29sdmVBZGRyZXNzKHJlcXVlc3Rba2V5XSwgdGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UoYWRkcikpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgcmVxdWVzdFtrZXldID0gYXdhaXQgYWRkcjsgfSkoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0W2tleV0gPSBhZGRyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHJlcXVlc3QuYmxvY2tUYWcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKHJlcXVlc3QuYmxvY2tUYWcpO1xyXG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGJsb2NrVGFnKSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyByZXF1ZXN0LmJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7IH0pKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ibG9ja1RhZyA9IGJsb2NrVGFnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXROZXR3b3JrKCkge1xyXG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IG5ldHdvcmsgd2FzIHNldCBhbmQgdGhpcyBpcyBvdXIgZmlyc3QgdGltZVxyXG4gICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIERldGVjdCB0aGUgY3VycmVudCBuZXR3b3JrIChzaGFyZWQgd2l0aCBhbGwgY2FsbHMpXHJcbiAgICAgICAgICAgIGNvbnN0IGRldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5fZGV0ZWN0TmV0d29yaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IGRldGVjdE5ldHdvcmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBkZXRlY3ROZXR3b3JrO1xyXG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IGRldGVjdE5ldHdvcmspLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ldHdvcmtQcm9taXNlID0gdGhpcy4jbmV0d29ya1Byb21pc2U7XHJcbiAgICAgICAgY29uc3QgW2V4cGVjdGVkLCBhY3R1YWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICBuZXR3b3JrUHJvbWlzZSxcclxuICAgICAgICAgICAgdGhpcy5fZGV0ZWN0TmV0d29yaygpIC8vIFRoZSBhY3R1YWwgY29ubmVjdGVkIG5ldHdvcmtcclxuICAgICAgICBdKTtcclxuICAgICAgICBpZiAoZXhwZWN0ZWQuY2hhaW5JZCAhPT0gYWN0dWFsLmNoYWluSWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuI2FueU5ldHdvcmspIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBcImFueVwiIG5ldHdvcmsgY2FuIGNoYW5nZSwgc28gbm90aWZ5IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBhY3R1YWwsIGV4cGVjdGVkKTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbmV0d29yayBpZiBzb21ldGhpbmcgZWxzZSBoYXNuJ3QgYWxyZWFkeSBjaGFuZ2VkIGl0XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IG5ldHdvcmtQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYWN0dWFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgZG8gbm90IGFsbG93IGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgbmV0d29ya1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgbmV0d29yayBjaGFuZ2VkOiAke2V4cGVjdGVkLmNoYWluSWR9ID0+ICR7YWN0dWFsLmNoYWluSWR9IGAsIFwiTkVUV09SS19FUlJPUlwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiY2hhbmdlZFwiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXhwZWN0ZWQuY2xvbmUoKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldEZlZURhdGEoKSB7XHJcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuZ2V0TmV0d29yaygpO1xyXG4gICAgICAgIGNvbnN0IGdldEZlZURhdGFGdW5jID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IF9ibG9jaywgZ2FzUHJpY2UsIHByaW9yaXR5RmVlIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XHJcbiAgICAgICAgICAgICAgICBfYmxvY2s6IHRoaXMuI2dldEJsb2NrKFwibGF0ZXN0XCIsIGZhbHNlKSxcclxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiAoKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0R2FzUHJpY2VcIiB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSwgXCIlcmVzcG9uc2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KSgpKSxcclxuICAgICAgICAgICAgICAgIHByaW9yaXR5RmVlOiAoKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0UHJpb3JpdHlGZWVcIiB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSwgXCIlcmVzcG9uc2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KSgpKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGV0IG1heEZlZVBlckdhcyA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgcmVjb21tZW5kZWQgRUlQLTE1NTkgaGV1cmlzdGljcyBmb3IgZmVlIGRhdGFcclxuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLl93cmFwQmxvY2soX2Jsb2NrLCBuZXR3b3JrKTtcclxuICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLmJhc2VGZWVQZXJHYXMpIHtcclxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gKHByaW9yaXR5RmVlICE9IG51bGwpID8gcHJpb3JpdHlGZWUgOiBCaWdJbnQoXCIxMDAwMDAwMDAwXCIpO1xyXG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzID0gKGJsb2NrLmJhc2VGZWVQZXJHYXMgKiBCTl8yKSArIG1heFByaW9yaXR5RmVlUGVyR2FzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmVlRGF0YShnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDaGVjayBmb3IgYSBGZWVEYXRhTmV0V29ya1BsdWdpblxyXG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xyXG4gICAgICAgIGlmIChwbHVnaW4pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IEZldGNoUmVxdWVzdChwbHVnaW4udXJsKTtcclxuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHBsdWdpbi5wcm9jZXNzRnVuYyhnZXRGZWVEYXRhRnVuYywgdGhpcywgcmVxKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZWVEYXRhKGZlZURhdGEuZ2FzUHJpY2UsIGZlZURhdGEubWF4RmVlUGVyR2FzLCBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldEZlZURhdGFGdW5jKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBlc3RpbWF0ZUdhcyhfdHgpIHtcclxuICAgICAgICBsZXQgdHggPSB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KTtcclxuICAgICAgICBpZiAoaXNQcm9taXNlKHR4KSkge1xyXG4gICAgICAgICAgICB0eCA9IGF3YWl0IHR4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2V0QmlnSW50KGF3YWl0IHRoaXMuI3BlcmZvcm0oe1xyXG4gICAgICAgICAgICBtZXRob2Q6IFwiZXN0aW1hdGVHYXNcIiwgdHJhbnNhY3Rpb246IHR4XHJcbiAgICAgICAgfSksIFwiJXJlc3BvbnNlXCIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgI2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0KSB7XHJcbiAgICAgICAgYXNzZXJ0KGF0dGVtcHQgPCBNQVhfQ0NJUF9SRURJUkVDVFMsIFwiQ0NJUCByZWFkIGV4Y2VlZGVkIG1heGltdW0gcmVkaXJlY3Rpb25zXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xyXG4gICAgICAgICAgICByZWFzb246IFwiVE9PX01BTllfUkVESVJFQ1RTXCIsXHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyBibG9ja1RhZywgZW5hYmxlQ2NpcFJlYWQ6IHRydWUgfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBUaGlzIGNhbWUgaW4gYXMgYSBQZXJmb3JtQWN0aW9uVHJhbnNhY3Rpb24sIHNvIHRvL2Zyb20gYXJlIHNhZmU7IHdlIGNhbiBjYXN0XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjb3B5UmVxdWVzdCh0eCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYXdhaXQgdGhpcy5fcGVyZm9ybSh7IG1ldGhvZDogXCJjYWxsXCIsIHRyYW5zYWN0aW9uLCBibG9ja1RhZyB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBDQ0lQIFJlYWQgT2ZmY2hhaW5Mb29rdXBcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVDY2lwUmVhZCAmJiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEgJiYgYXR0ZW1wdCA+PSAwICYmIGJsb2NrVGFnID09PSBcImxhdGVzdFwiICYmIHRyYW5zYWN0aW9uLnRvICE9IG51bGwgJiYgZGF0YVNsaWNlKGVycm9yLmRhdGEsIDAsIDQpID09PSBcIjB4NTU2ZjE4MzBcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGVycm9yLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eFNlbmRlciA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHRyYW5zYWN0aW9uLnRvLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBDQ0lQIFJlYWQgQXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICBsZXQgY2NpcEFyZ3M7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNjaXBBcmdzID0gcGFyc2VPZmZjaGFpbkxvb2t1cChkYXRhU2xpY2UoZXJyb3IuZGF0YSwgNCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkJBRF9EQVRBXCIsIHRyYW5zYWN0aW9uLCBpbmZvOiB7IGRhdGEgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHNlbmRlciBvZiB0aGUgT2ZmY2hhaW5Mb29rdXAgbWF0Y2hlcyB0aGUgdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgICAgIGFzc2VydChjY2lwQXJncy5zZW5kZXIudG9Mb3dlckNhc2UoKSA9PT0gdHhTZW5kZXIudG9Mb3dlckNhc2UoKSwgXCJDQ0lQIFJlYWQgc2VuZGVyIG1pc21hdGNoXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJjYWxsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiT2ZmY2hhaW5Mb29rdXBcIixcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGNjaXBBcmdzLmVycm9yQXJnc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2NpcFJlc3VsdCA9IGF3YWl0IHRoaXMuY2NpcFJlYWRGZXRjaCh0cmFuc2FjdGlvbiwgY2NpcEFyZ3MuY2FsbGRhdGEsIGNjaXBBcmdzLnVybHMpO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNjaXBSZXN1bHQgIT0gbnVsbCwgXCJDQ0lQIFJlYWQgZmFpbGVkIHRvIGZldGNoIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkZFVENIX0ZBSUxFRFwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhOiBlcnJvci5kYXRhLCBlcnJvckFyZ3M6IGNjaXBBcmdzLmVycm9yQXJncyB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0eFNlbmRlcixcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjb25jYXQoW2NjaXBBcmdzLnNlbGVjdG9yLCBlbmNvZGVCeXRlcyhbY2NpcFJlc3VsdCwgY2NpcEFyZ3MuZXh0cmFEYXRhXSldKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRDY2lwUmVhZENhbGxcIiwgdHJhbnNhY3Rpb246IHR4IH0pO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZENhbGxSZXN1bHRcIiwgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4KSwgcmVzdWx0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsRXJyb3JcIiwgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4KSwgZXJyb3IgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgI2NoZWNrTmV0d29yayhwcm9taXNlKSB7XHJcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcclxuICAgICAgICAgICAgdmFsdWU6IHByb21pc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBhc3luYyBjYWxsKF90eCkge1xyXG4gICAgICAgIGNvbnN0IHsgdHgsIGJsb2NrVGFnIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XHJcbiAgICAgICAgICAgIHR4OiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KSxcclxuICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKF90eC5ibG9ja1RhZylcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2hlY2tOZXR3b3JrKHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBfdHguZW5hYmxlQ2NpcFJlYWQgPyAwIDogLTEpKTtcclxuICAgIH1cclxuICAgIC8vIEFjY291bnRcclxuICAgIGFzeW5jICNnZXRBY2NvdW50VmFsdWUocmVxdWVzdCwgX2FkZHJlc3MsIF9ibG9ja1RhZykge1xyXG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhfYWRkcmVzcyk7XHJcbiAgICAgICAgbGV0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcoX2Jsb2NrVGFnKTtcclxuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKGJsb2NrVGFnKSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBbYWRkcmVzcywgYmxvY2tUYWddID0gYXdhaXQgUHJvbWlzZS5hbGwoW2FkZHJlc3MsIGJsb2NrVGFnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jcGVyZm9ybShPYmplY3QuYXNzaWduKHJlcXVlc3QsIHsgYWRkcmVzcywgYmxvY2tUYWcgfSkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldEJhbGFuY2UoYWRkcmVzcywgYmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gZ2V0QmlnSW50KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRCYWxhbmNlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uQ291bnQoYWRkcmVzcywgYmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldENvZGUoYWRkcmVzcywgYmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0Q29kZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRTdG9yYWdlKGFkZHJlc3MsIF9wb3NpdGlvbiwgYmxvY2tUYWcpIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldEJpZ0ludChfcG9zaXRpb24sIFwicG9zaXRpb25cIik7XHJcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFN0b3JhZ2VcIiwgcG9zaXRpb24gfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcclxuICAgIH1cclxuICAgIC8vIFdyaXRlXHJcbiAgICBhc3luYyBicm9hZGNhc3RUcmFuc2FjdGlvbihzaWduZWRUeCkge1xyXG4gICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIGhhc2gsIG5ldHdvcmsgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSxcclxuICAgICAgICAgICAgaGFzaDogdGhpcy5fcGVyZm9ybSh7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIixcclxuICAgICAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uOiBzaWduZWRUeFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKClcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB0eCA9IFRyYW5zYWN0aW9uLmZyb20oc2lnbmVkVHgpO1xyXG4gICAgICAgIGlmICh0eC5oYXNoICE9PSBoYXNoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPOiB0aGUgcmV0dXJuZWQgaGFzaCBkaWQgbm90IG1hdGNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIG5ldHdvcmspLnJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oYmxvY2tOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgI2dldEJsb2NrKGJsb2NrLCBpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XHJcbiAgICAgICAgLy8gQFRPRE86IEFkZCBDdXN0b21CbG9ja1BsdWdpbiBjaGVja1xyXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhibG9jaywgMzIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCbG9ja1wiLCBibG9ja0hhc2g6IGJsb2NrLCBpbmNsdWRlVHJhbnNhY3Rpb25zXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhibG9jayk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcclxuICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrVGFnLCBpbmNsdWRlVHJhbnNhY3Rpb25zXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBRdWVyaWVzXHJcbiAgICBhc3luYyBnZXRCbG9jayhibG9jaywgcHJlZmV0Y2hUeHMpIHtcclxuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcclxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNnZXRCbG9jayhibG9jaywgISFwcmVmZXRjaFR4cylcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwQmxvY2socGFyYW1zLCBuZXR3b3JrKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGhhc2gpIHtcclxuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcclxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uXCIsIGhhc2ggfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZXNwb25zZShwYXJhbXMsIG5ldHdvcmspO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpIHtcclxuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcclxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBoYXNoIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTb21lIGJhY2tlbmRzIGRpZCBub3QgYmFja2ZpbGwgdGhlIGVmZmVjdGl2ZUdhc1ByaWNlIGludG8gb2xkIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgIC8vIGluIHRoZSByZWNlaXB0LCBzbyB3ZSBsb29rIGl0IHVwIG1hbnVhbGx5IGFuZCBpbmplY3QgaXQuXHJcbiAgICAgICAgaWYgKHBhcmFtcy5nYXNQcmljZSA9PSBudWxsICYmIHBhcmFtcy5lZmZlY3RpdmVHYXNQcmljZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pO1xyXG4gICAgICAgICAgICBpZiAodHggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVwb3J0IHRoaXM7IGNvdWxkIG5vdCBmaW5kIHR4IG9yIGVmZmVjdGl2ZUdhc1ByaWNlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtcy5lZmZlY3RpdmVHYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVjZWlwdChwYXJhbXMsIG5ldHdvcmspO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZXN1bHQoaGFzaCkge1xyXG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XHJcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25SZXN1bHRcIiwgaGFzaCB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8vIEJsb29tLWZpbHRlciBRdWVyaWVzXHJcbiAgICBhc3luYyBnZXRMb2dzKF9maWx0ZXIpIHtcclxuICAgICAgICBsZXQgZmlsdGVyID0gdGhpcy5fZ2V0RmlsdGVyKF9maWx0ZXIpO1xyXG4gICAgICAgIGlmIChpc1Byb21pc2UoZmlsdGVyKSkge1xyXG4gICAgICAgICAgICBmaWx0ZXIgPSBhd2FpdCBmaWx0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XHJcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxyXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0TG9nc1wiLCBmaWx0ZXIgfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLm1hcCgocCkgPT4gdGhpcy5fd3JhcExvZyhwLCBuZXR3b3JrKSk7XHJcbiAgICB9XHJcbiAgICAvLyBFTlNcclxuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInByb3ZpZGVyIGNhbm5vdCBjb25uZWN0IHRvIHRhcmdldCBuZXR3b3JrXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9nZXRQcm92aWRlcigpXCJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldFJlc29sdmVyKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgRW5zUmVzb2x2ZXIuZnJvbU5hbWUodGhpcywgbmFtZSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRBdmF0YXIobmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcclxuICAgICAgICBpZiAocmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVyLmdldEF2YXRhcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGFzeW5jIHJlc29sdmVOYW1lKG5hbWUpIHtcclxuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XHJcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlci5nZXRBZGRyZXNzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgbG9va3VwQWRkcmVzcyhhZGRyZXNzKSB7XHJcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIik7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3ModGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuc0NvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGVuc0FkZHIsIFtcclxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZXIoYnl0ZXMzMikgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiXHJcbiAgICAgICAgICAgIF0sIHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IGVuc0NvbnRyYWN0LnJlc29sdmVyKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIgPT0gbnVsbCB8fCByZXNvbHZlciA9PT0gWmVyb0FkZHJlc3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQ29udHJhY3QgPSBuZXcgQ29udHJhY3QocmVzb2x2ZXIsIFtcclxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gbmFtZShieXRlczMyKSB2aWV3IHJldHVybnMgKHN0cmluZylcIlxyXG4gICAgICAgICAgICBdLCB0aGlzKTtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGF3YWl0IHJlc29sdmVyQ29udHJhY3QubmFtZShub2RlKTtcclxuICAgICAgICAgICAgLy8gRmFpbGVkIGZvcndhcmQgcmVzb2x1dGlvblxyXG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IGF3YWl0IHRoaXMucmVzb2x2ZU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChjaGVjayAhPT0gYWRkcmVzcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBObyBkYXRhIHdhcyByZXR1cm5lZCBmcm9tIHRoZSByZXNvbHZlclxyXG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCQURfREFUQVwiKSAmJiBlcnJvci52YWx1ZSA9PT0gXCIweFwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgcmVlcnRlZFxyXG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKGhhc2gsIF9jb25maXJtcywgdGltZW91dCkge1xyXG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyAhPSBudWxsKSA/IF9jb25maXJtcyA6IDE7XHJcbiAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoYXN5bmMgKGJsb2NrTnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxID49IGNvbmZpcm1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlY2VpcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLm9mZihcImJsb2NrXCIsIGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFRUVcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZihcImJsb2NrXCIsIGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwgeyByZWFzb246IFwidGltZW91dFwiIH0pKTtcclxuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKGF3YWl0IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyB3YWl0Rm9yQmxvY2soYmxvY2tUYWcpIHtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsIFwibm90IGltcGxlbWVudGVkIHlldFwiLCBcIk5PVF9JTVBMRU1FTlRFRFwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ3YWl0Rm9yQmxvY2tcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ2xlYXIgYSB0aW1lciBjcmVhdGVkIHVzaW5nIHRoZSBbW19zZXRUaW1lb3V0XV0gbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBfY2xlYXJUaW1lb3V0KHRpbWVySWQpIHtcclxuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuI3RpbWVycy5nZXQodGltZXJJZCk7XHJcbiAgICAgICAgaWYgKCF0aW1lcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aW1lci50aW1lcikge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiN0aW1lcnMuZGVsZXRlKHRpbWVySWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgdGltZXIgdGhhdCB3aWxsIGV4ZWN1dGUgJSVmdW5jJSUgYWZ0ZXIgYXQgbGVhc3QgJSV0aW1lb3V0JSVcclxuICAgICAqICAoaW4gbXMpLiBJZiAlJXRpbWVvdXQlJSBpcyB1bnNwZWNpZmllZCwgdGhlbiAlJWZ1bmMlJSB3aWxsIGV4ZWN1dGVcclxuICAgICAqICBpbiB0aGUgbmV4dCBldmVudCBsb29wLlxyXG4gICAgICpcclxuICAgICAqICBbUGF1c2luZ10oQWJzdHJhY3RQcm92aWRlci1wYXVzZWQpIHRoZSBwcm92aWRlciB3aWxsIHBhdXNlIGFueVxyXG4gICAgICogIGFzc29jaWF0ZWQgdGltZXJzLlxyXG4gICAgICovXHJcbiAgICBfc2V0VGltZW91dChfZnVuYywgdGltZW91dCkge1xyXG4gICAgICAgIGlmICh0aW1lb3V0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRpbWVySWQgPSB0aGlzLiNuZXh0VGltZXIrKztcclxuICAgICAgICBjb25zdCBmdW5jID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuZGVsZXRlKHRpbWVySWQpO1xyXG4gICAgICAgICAgICBfZnVuYygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lcjogbnVsbCwgZnVuYywgdGltZTogdGltZW91dCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChmdW5jLCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgdGhpcy4jdGltZXJzLnNldCh0aW1lcklkLCB7IHRpbWVyLCBmdW5jLCB0aW1lOiBnZXRUaW1lKCkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aW1lcklkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUGVyZm9ybSAlJWZ1bmMlJSBvbiBlYWNoIHN1YnNjcmliZXIuXHJcbiAgICAgKi9cclxuICAgIF9mb3JFYWNoU3Vic2NyaWJlcihmdW5jKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBmdW5jKHN1Yi5zdWJzY3JpYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBjdXN0b21pemUgc3Vic2NyaXB0aW9uXHJcbiAgICAgKiAgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICovXHJcbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcclxuICAgICAgICBzd2l0Y2ggKHN1Yi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcclxuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlcihzdWIudHlwZSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gbmV3IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMucG9sbGluZ0ludGVydmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcclxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyKHRoaXMsIHN1Yi50eXBlKTtcclxuICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2FjdGlvblwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHRoaXMsIHN1Yi5oYXNoKTtcclxuICAgICAgICAgICAgY2FzZSBcIm9ycGhhblwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBldmVudDogJHtzdWIudHlwZX1gKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIElmIGEgW1tTdWJzY3JpYmVyXV0gZmFpbHMgYW5kIG5lZWRzIHRvIHJlcGxhY2UgaXRzZWxmLCB0aGlzXHJcbiAgICAgKiAgbWV0aG9kIG1heSBiZSB1c2VkLlxyXG4gICAgICpcclxuICAgICAqICBGb3IgZXhhbXBsZSwgdGhpcyBpcyB1c2VkIGZvciBwcm92aWRlcnMgd2hlbiB1c2luZyB0aGVcclxuICAgICAqICBgYGV0aF9nZXRGaWx0ZXJDaGFuZ2VzYGAgbWV0aG9kLCB3aGljaCBjYW4gcmV0dXJuIG51bGwgaWYgc3RhdGVcclxuICAgICAqICBmaWx0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBiYWNrZW5kLCBhbGxvd2luZyB0aGUgU3Vic2NyaWJlclxyXG4gICAgICogIHRvIHN3YXAgaW4gYSBbW1BvbGxpbmdFdmVudFN1YnNjcmliZXJdXS5cclxuICAgICAqL1xyXG4gICAgX3JlY292ZXJTdWJzY3JpYmVyKG9sZFN1YiwgbmV3U3ViKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAoc3ViLnN1YnNjcmliZXIgPT09IG9sZFN1Yikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIgPSBuZXdTdWI7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTdWIuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgI2hhc1N1YihldmVudCwgZW1pdEFyZ3MpIHtcclxuICAgICAgICBsZXQgc3ViID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKGV2ZW50LCB0aGlzKTtcclxuICAgICAgICAvLyBUaGlzIGlzIGEgbG9nIHRoYXQgaXMgcmVtb3ZpbmcgYW4gZXhpc3RpbmcgbG9nOyB3ZSBhY3R1YWxseSB3YW50XHJcbiAgICAgICAgLy8gdG8gZW1pdCBhbiBvcnBoYW4gZXZlbnQgZm9yIHRoZSByZW1vdmVkIGxvZ1xyXG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJldmVudFwiICYmIGVtaXRBcmdzICYmIGVtaXRBcmdzLmxlbmd0aCA+IDAgJiYgZW1pdEFyZ3NbMF0ucmVtb3ZlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBzdWIgPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oeyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiBlbWl0QXJnc1swXSB9LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI3N1YnMuZ2V0KHN1Yi50YWcpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBhc3luYyAjZ2V0U3ViKGV2ZW50KSB7XHJcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKGV2ZW50LCB0aGlzKTtcclxuICAgICAgICAvLyBQcmV2ZW50IHRhbXBlcmluZyB3aXRoIG91ciB0YWcgaW4gYW55IHN1YmNsYXNzJyBfZ2V0U3Vic2NyaWJlclxyXG4gICAgICAgIGNvbnN0IHRhZyA9IHN1YnNjcmlwdGlvbi50YWc7XHJcbiAgICAgICAgbGV0IHN1YiA9IHRoaXMuI3N1YnMuZ2V0KHRhZyk7XHJcbiAgICAgICAgaWYgKCFzdWIpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHRoaXMuX2dldFN1YnNjcmliZXIoc3Vic2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2FibGVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBzdWIgPSB7IHN1YnNjcmliZXIsIHRhZywgYWRkcmVzc2FibGVNYXAsIG5hbWVNYXAsIHN0YXJ0ZWQ6IGZhbHNlLCBsaXN0ZW5lcnM6IFtdIH07XHJcbiAgICAgICAgICAgIHRoaXMuI3N1YnMuc2V0KHRhZywgc3ViKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1YjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XHJcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IGZhbHNlIH0pO1xyXG4gICAgICAgIGlmICghc3ViLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcclxuICAgICAgICAgICAgc3ViLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25jZShldmVudCwgbGlzdGVuZXIpIHtcclxuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xyXG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xyXG4gICAgICAgIGlmICghc3ViLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcclxuICAgICAgICAgICAgc3ViLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCwgYXJncyk7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IHN1YnNjcmlwdGlvbiBvciBpZiBhIHJlY2VudCBlbWl0IHJlbW92ZWRcclxuICAgICAgICAvLyB0aGUgbGFzdCBvZiB0aGVtICh3aGljaCBhbHNvIGRlbGV0ZWQgdGhlIHN1YikgZG8gbm90aGluZ1xyXG4gICAgICAgIGlmICghc3ViIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gc3ViLmxpc3RlbmVycy5sZW5ndGg7XHJcbiAgICAgICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG5ldyBFdmVudFBheWxvYWQodGhpcywgKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpLCBldmVudCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIC4uLmFyZ3MsIHBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICAgICAgICAgIHJldHVybiAhb25jZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUoc3ViLnRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoY291bnQgPiAwKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKCFzdWIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG90YWw7XHJcbiAgICB9XHJcbiAgICBhc3luYyBsaXN0ZW5lcnMoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKCFzdWIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcclxuICAgICAgICBpZiAoIXN1Yikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbGlzdGVuZXIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUoc3ViLnRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdGFnLCBzdGFydGVkLCBzdWJzY3JpYmVyIH0gPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUodGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3RhZywgeyBzdGFydGVkLCBzdWJzY3JpYmVyIH1dIG9mIHRoaXMuI3N1YnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gQWxpYXMgZm9yIFwib25cIlxyXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8vIEFsaWFzIGZvciBcIm9mZlwiXHJcbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIElmIHRoaXMgcHJvdmlkZXIgaGFzIGJlZW4gZGVzdHJveWVkIHVzaW5nIHRoZSBbW2Rlc3Ryb3ldXSBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogIE9uY2UgZGVzdHJveWVkLCBhbGwgcmVzb3VyY2VzIGFyZSByZWNsYWltZWQsIGludGVybmFsIGV2ZW50IGxvb3BzXHJcbiAgICAgKiAgYW5kIHRpbWVycyBhcmUgY2xlYW5lZCB1cCBhbmQgbm8gZnVydGhlciByZXF1ZXN0cyBtYXkgYmUgc2VudCB0b1xyXG4gICAgICogIHRoZSBwcm92aWRlci5cclxuICAgICAqL1xyXG4gICAgZ2V0IGRlc3Ryb3llZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jZGVzdHJveWVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IHVzZSB0aGlzIHRvIHNodXRkb3duIGFueSBzb2NrZXRzIG9yIHJlbGVhc2UgdGhlaXJcclxuICAgICAqICByZXNvdXJjZXMgYW5kIHJlamVjdCBhbnkgcGVuZGluZyByZXF1ZXN0cy5cclxuICAgICAqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0KiogY2FsbCBgYHN1cGVyLmRlc3Ryb3koKWBgLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIC8vIFN0b3AgYWxsIGxpc3RlbmVyc1xyXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgLy8gU2h1dCBkb3duIGFsbCB0aWVtcnNcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbWVySWQgb2YgdGhpcy4jdGltZXJzLmtleXMoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQodGltZXJJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBXaGV0aGVyIHRoZSBwcm92aWRlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxyXG4gICAgICpcclxuICAgICAqICBBIHBhdXNlZCBwcm92aWRlciB3aWxsIG5vdCBlbWl0IGFueSBldmVudHMsIGFuZCBnZW5lcmFsbHkgc2hvdWxkXHJcbiAgICAgKiAgbm90IG1ha2UgYW55IHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrLCBidXQgdGhhdCBpcyB1cCB0byBzdWItY2xhc3Nlc1xyXG4gICAgICogIHRvIG1hbmFnZS5cclxuICAgICAqXHJcbiAgICAgKiAgU2V0dGluZyBgYHBhdXNlZCA9IHRydWVgYCBpcyBpZGVudGljYWwgdG8gY2FsbGluZyBgYC5wYXVzZShmYWxzZSlgYCxcclxuICAgICAqICB3aGljaCB3aWxsIGJ1ZmZlciBhbnkgZXZlbnRzIHRoYXQgb2NjdXIgd2hpbGUgcGF1c2VkIHVudGlsIHRoZVxyXG4gICAgICogIHByb3ZpZGVyIGlzIHVucGF1c2VkLlxyXG4gICAgICovXHJcbiAgICBnZXQgcGF1c2VkKCkgeyByZXR1cm4gKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpOyB9XHJcbiAgICBzZXQgcGF1c2VkKHBhdXNlKSB7XHJcbiAgICAgICAgaWYgKCEhcGF1c2UgPT09IHRoaXMucGF1c2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBhdXNlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBQYXVzZSB0aGUgcHJvdmlkZXIuIElmICUlZHJvcFdoaWxlUGF1c2VkJSUsIGFueSBldmVudHMgdGhhdCBvY2N1clxyXG4gICAgICogIHdoaWxlIHBhdXNlZCBhcmUgZHJvcHBlZCwgb3RoZXJ3aXNlIGFsbCBldmVudHMgd2lsbCBiZSBlbWl0dGVkIG9uY2VcclxuICAgICAqICB0aGUgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXHJcbiAgICAgKi9cclxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xyXG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xyXG4gICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSAhIWRyb3BXaGlsZVBhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3QgY2hhbmdlIHBhdXNlIHR5cGU7IHJlc3VtZSBmaXJzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicGF1c2VcIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHMpID0+IHMucGF1c2UoZHJvcFdoaWxlUGF1c2VkKSk7XHJcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSAhIWRyb3BXaGlsZVBhdXNlZDtcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgdGltZXJcclxuICAgICAgICAgICAgaWYgKHRpbWVyLnRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyB0aW1lIG5lZWRlZCBmb3Igd2hlbiB3ZSBiZWNvbWUgdW5wYXVzZWRcclxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKSAtIHRpbWVyLnRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVzdW1lIHRoZSBwcm92aWRlci5cclxuICAgICAqL1xyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHMpID0+IHMucmVzdW1lKCkpO1xyXG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSB3aGVuIHdlIHdlcmUgcGF1c2VkXHJcbiAgICAgICAgICAgIGxldCB0aW1lb3V0ID0gdGltZXIudGltZTtcclxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdGFydCB0aW1lIChpbiBjYXVzZSBwYXVzZWQsIHNvIHdlIGNvbiBjb21wdXRlIHJlbWFpbmluZiB0aW1lKVxyXG4gICAgICAgICAgICB0aW1lci50aW1lID0gZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdGltZXJcclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lci5mdW5jLCB0aW1lb3V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCwgc3RhcnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KTtcclxuICAgICAgICBpZiAoYnl0ZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhieXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpIHtcclxuICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSBnZXROdW1iZXIoZGF0YVNsaWNlKHJlc3VsdCwgc3RhcnQsIHN0YXJ0ICsgMzIpKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBnZXROdW1iZXIoZGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0LCBvZmZzZXQgKyAzMikpO1xyXG4gICAgICAgIHJldHVybiBkYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIG51bVBhZCh2YWx1ZSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcclxuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgzMik7XHJcbiAgICBwYWRkZWQuc2V0KHJlc3VsdCwgMzIgLSByZXN1bHQubGVuZ3RoKTtcclxuICAgIHJldHVybiBwYWRkZWQ7XHJcbn1cclxuZnVuY3Rpb24gYnl0ZXNQYWQodmFsdWUpIHtcclxuICAgIGlmICgodmFsdWUubGVuZ3RoICUgMzIpID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMyKSAqIDMyKTtcclxuICAgIHJlc3VsdC5zZXQodmFsdWUpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5jb25zdCBlbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcclxuLy8gQUJJIEVuY29kZXMgYSBzZXJpZXMgb2YgKGJ5dGVzLCBieXRlcywgLi4uKVxyXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBsZXQgYnl0ZUNvdW50ID0gMDtcclxuICAgIC8vIEFkZCBwbGFjZS1ob2xkZXJzIGZvciBwb2ludGVycyBhcyB3ZSBhZGQgaXRlbXNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICByZXN1bHQucHVzaChlbXB0eSk7XHJcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhkYXRhc1tpXSk7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBieXRlcyBvZmZzZXRcclxuICAgICAgICByZXN1bHRbaV0gPSBudW1QYWQoYnl0ZUNvdW50KTtcclxuICAgICAgICAvLyBUaGUgbGVuZ3RoIGFuZCBwYWRkZWQgdmFsdWUgb2YgZGF0YVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKG51bVBhZChkYXRhLmxlbmd0aCkpO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKGJ5dGVzUGFkKGRhdGEpKTtcclxuICAgICAgICBieXRlQ291bnQgKz0gMzIgKyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyAzMikgKiAzMjtcclxuICAgIH1cclxuICAgIHJldHVybiBjb25jYXQocmVzdWx0KTtcclxufVxyXG5jb25zdCB6ZXJvcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XHJcbmZ1bmN0aW9uIHBhcnNlT2ZmY2hhaW5Mb29rdXAoZGF0YSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIHNlbmRlcjogXCJcIiwgdXJsczogW10sIGNhbGxkYXRhOiBcIlwiLCBzZWxlY3RvcjogXCJcIiwgZXh0cmFEYXRhOiBcIlwiLCBlcnJvckFyZ3M6IFtdXHJcbiAgICB9O1xyXG4gICAgYXNzZXJ0KGRhdGFMZW5ndGgoZGF0YSkgPj0gNSAqIDMyLCBcImluc3VmZmljaWVudCBPZmZjaGFpbkxvb2t1cCBkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xyXG4gICAgICAgIHJlYXNvbjogXCJpbnN1ZmZpY2llbnQgT2ZmY2hhaW5Mb29rdXAgZGF0YVwiXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHNlbmRlciA9IGRhdGFTbGljZShkYXRhLCAwLCAzMik7XHJcbiAgICBhc3NlcnQoZGF0YVNsaWNlKHNlbmRlciwgMCwgMTIpID09PSBkYXRhU2xpY2UoemVyb3MsIDAsIDEyKSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcclxuICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBzZW5kZXJcIlxyXG4gICAgfSk7XHJcbiAgICByZXN1bHQuc2VuZGVyID0gZGF0YVNsaWNlKHNlbmRlciwgMTIpO1xyXG4gICAgLy8gUmVhZCB0aGUgVVJMcyBmcm9tIHRoZSByZXNwb25zZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1cmxzID0gW107XHJcbiAgICAgICAgY29uc3QgdXJsc09mZnNldCA9IGdldE51bWJlcihkYXRhU2xpY2UoZGF0YSwgMzIsIDY0KSk7XHJcbiAgICAgICAgY29uc3QgdXJsc0xlbmd0aCA9IGdldE51bWJlcihkYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCwgdXJsc09mZnNldCArIDMyKSk7XHJcbiAgICAgICAgY29uc3QgdXJsc0RhdGEgPSBkYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCArIDMyKTtcclxuICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHVybHNMZW5ndGg7IHUrKykge1xyXG4gICAgICAgICAgICBjb25zdCB1cmwgPSBfcGFyc2VTdHJpbmcodXJsc0RhdGEsIHUgKiAzMik7XHJcbiAgICAgICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXJscy5wdXNoKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC51cmxzID0gdXJscztcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gR2V0IHRoZSBDQ0lQIGNhbGxkYXRhIHRvIGZvcndhcmRcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCA2NCk7XHJcbiAgICAgICAgaWYgKGNhbGxkYXRhID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5jYWxsZGF0YSA9IGNhbGxkYXRhO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XHJcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIEdldCB0aGUgY2FsbGJhY2tTZWxlY3RvciAoYnl0ZXM0KVxyXG4gICAgYXNzZXJ0KGRhdGFTbGljZShkYXRhLCAxMDAsIDEyOCkgPT09IGRhdGFTbGljZSh6ZXJvcywgMCwgMjgpLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XHJcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIlxyXG4gICAgfSk7XHJcbiAgICByZXN1bHQuc2VsZWN0b3IgPSBkYXRhU2xpY2UoZGF0YSwgOTYsIDEwMCk7XHJcbiAgICAvLyBHZXQgdGhlIGV4dHJhIGRhdGEgdG8gc2VuZCBiYWNrIHRvIHRoZSBjb250cmFjdCBhcyBjb250ZXh0XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGV4dHJhRGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDEyOCk7XHJcbiAgICAgICAgaWYgKGV4dHJhRGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuZXh0cmFEYXRhID0gZXh0cmFEYXRhO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xyXG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBleHRyYURhdGFcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LmVycm9yQXJncyA9IFwic2VuZGVyLHVybHMsY2FsbGRhdGEsc2VsZWN0b3IsZXh0cmFEYXRhXCIuc3BsaXQoLywvKS5tYXAoKGspID0+IHJlc3VsdFtrXSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0LXByb3ZpZGVyLmpzLm1hcCIsIi8qKlxyXG4gKiAgR2VuZXJhbGx5IHRoZSBbW1dhbGxldF1dIGFuZCBbW0pzb25ScGNTaWduZXJdXSBhbmQgdGhlaXIgc3ViLWNsYXNzZXNcclxuICogIGFyZSBzdWZmaWNlbnQgZm9yIG1vc3QgZGV2ZWxvcGVycywgYnV0IHRoaXMgaXMgcHJvdmlkZWQgdG9cclxuICogIGZhc2NpbGl0YXRlIG1vcmUgY29tcGxleCBTaWduZXJzLlxyXG4gKlxyXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lcjogU3ViY2xhc3NpbmcgU2lnbmVyIFthYnN0cmFjdC1zaWduZXJdXHJcbiAqL1xyXG5pbXBvcnQgeyByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgY29weVJlcXVlc3QgfSBmcm9tIFwiLi9wcm92aWRlci5qc1wiO1xyXG5mdW5jdGlvbiBjaGVja1Byb3ZpZGVyKHNpZ25lciwgb3BlcmF0aW9uKSB7XHJcbiAgICBpZiAoc2lnbmVyLnByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpZ25lci5wcm92aWRlcjtcclxuICAgIH1cclxuICAgIGFzc2VydChmYWxzZSwgXCJtaXNzaW5nIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHBvcHVsYXRlKHNpZ25lciwgdHgpIHtcclxuICAgIGxldCBwb3AgPSBjb3B5UmVxdWVzdCh0eCk7XHJcbiAgICBpZiAocG9wLnRvICE9IG51bGwpIHtcclxuICAgICAgICBwb3AudG8gPSByZXNvbHZlQWRkcmVzcyhwb3AudG8sIHNpZ25lcik7XHJcbiAgICB9XHJcbiAgICBpZiAocG9wLmZyb20gIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGZyb20gPSBwb3AuZnJvbTtcclxuICAgICAgICBwb3AuZnJvbSA9IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgc2lnbmVyLmdldEFkZHJlc3MoKSxcclxuICAgICAgICAgICAgcmVzb2x2ZUFkZHJlc3MoZnJvbSwgc2lnbmVyKVxyXG4gICAgICAgIF0pLnRoZW4oKFthZGRyZXNzLCBmcm9tXSkgPT4ge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGZyb20udG9Mb3dlckNhc2UoKSwgXCJ0cmFuc2FjdGlvbiBmcm9tIG1pc21hdGNoXCIsIFwidHguZnJvbVwiLCBmcm9tKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwb3AuZnJvbSA9IHNpZ25lci5nZXRBZGRyZXNzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMocG9wKTtcclxufVxyXG4vKipcclxuICogIEFuICoqQWJzdHJhY3RTaWduZXIqKiBpbmNsdWRlcyBtb3N0IG9mIHRlaCBmdW5jdGlvbmFsaXR5IHJlcXVpcmVkXHJcbiAqICB0byBnZXQgYSBbW1NpZ25lcl1dIHdvcmtpbmcgYXMgZXhwZWN0ZWQsIGJ1dCByZXF1aXJlcyBhIGZld1xyXG4gKiAgU2lnbmVyLXNwZWNpZmljIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbi5cclxuICpcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFNpZ25lciB7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcHJvdmlkZXIgdGhpcyBzaWduZXIgaXMgY29ubmVjdGVkIHRvLlxyXG4gICAgICovXHJcbiAgICBwcm92aWRlcjtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgU2lnbmVyIGNvbm5lY3RlZCB0byAlJXByb3ZpZGVyJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByb3ZpZGVyOiAocHJvdmlkZXIgfHwgbnVsbCkgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXROb25jZShibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKS5nZXRUcmFuc2FjdGlvbkNvdW50KGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBwb3B1bGF0ZUNhbGwodHgpIHtcclxuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCBwb3B1bGF0ZSh0aGlzLCB0eCk7XHJcbiAgICAgICAgcmV0dXJuIHBvcDtcclxuICAgIH1cclxuICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb24odHgpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCIpO1xyXG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcclxuICAgICAgICBpZiAocG9wLm5vbmNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcG9wLm5vbmNlID0gYXdhaXQgdGhpcy5nZXROb25jZShcInBlbmRpbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3AuZ2FzTGltaXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwb3AuZ2FzTGltaXQgPSBhd2FpdCB0aGlzLmVzdGltYXRlR2FzKHBvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBjaGFpbiBJRFxyXG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCAodGhpcy5wcm92aWRlcikuZ2V0TmV0d29yaygpO1xyXG4gICAgICAgIGlmIChwb3AuY2hhaW5JZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBnZXRCaWdJbnQocG9wLmNoYWluSWQpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChjaGFpbklkID09PSBuZXR3b3JrLmNoYWluSWQsIFwidHJhbnNhY3Rpb24gY2hhaW5JZCBtaXNtYXRjaFwiLCBcInR4LmNoYWluSWRcIiwgdHguY2hhaW5JZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwb3AuY2hhaW5JZCA9IG5ldHdvcmsuY2hhaW5JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90IGFsbG93IG1peGluZyBwcmUtZWlwLTE1NTkgYW5kIGVpcC0xNTU5IHByb3BlcnRpZXNcclxuICAgICAgICBjb25zdCBoYXNFaXAxNTU5ID0gKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XHJcbiAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsICYmIChwb3AudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcInR4XCIsIHR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInByZS1laXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBtYXhGZWVQZXJHYXMvbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ0eFwiLCB0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT0gbnVsbCkgJiYgKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgLy8gRnVsbHktZm9ybWVkIEVJUC0xNTU5IHRyYW5zYWN0aW9uIChza2lwIGdldEZlZURhdGEpXHJcbiAgICAgICAgICAgIHBvcC50eXBlID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDAgfHwgcG9wLnR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgLy8gRXhwbGljaXQgTGVnYWN5IG9yIEVJUC0yOTMwIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcclxuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmdldEZlZURhdGEoKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEdhc1ByaWNlXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZ2FzUHJpY2VcclxuICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwb3AuZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXHJcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XHJcbiAgICAgICAgICAgIGlmIChwb3AudHlwZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGF1dG8tZGV0ZWN0IHRoZSBpbnRlbmRlZCB0eXBlIG9mIHRoaXMgdHJhbnNhY3Rpb24uLi5cclxuICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXR3b3JrIHN1cHBvcnRzIEVJUC0xNTU5IVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZ3JhZGUgdHJhbnNhY3Rpb24gZnJvbSBudWxsIHRvIGVpcC0xNTU5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5hdXRob3JpemF0aW9uTGlzdCAmJiBwb3AuYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gNDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIGxlZ2FjeSBnYXNQcmljZSBwcm9wZXJ0eSBvbiBhbiBlaXAtMTU1OSBuZXR3b3JrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB1c2UgZ2FzUHJpY2UgYXMgYm90aCBmZWUgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHBvcC5nYXNQcmljZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBvcC5nYXNQcmljZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGdhc1ByaWNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBzdXBwb3J0IEVJUC0xNTU5Li4uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IHRoZXkgYXJlIHRyeWluZyB0byB1c2UgRUlQLTE1NTkgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCghaGFzRWlwMTU1OSwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRUlQLTE1NTlcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9wdWxhdGVUcmFuc2FjdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AuZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCB1bnR5cGVkIHRyYW5zYWN0aW9uIHRvIGxlZ2FjeVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBNYXliZSB0aGlzIHNob2xkIGFsbG93IHR5cGUgMT9cclxuICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXRGZWVEYXRhIGhhcyBmYWlsZWQgdXMuXHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImZhaWxlZCB0byBnZXQgY29uc2lzdGVudCBmZWUgZGF0YVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuZ2V0RmVlRGF0YVwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT09IDMgfHwgcG9wLnR5cGUgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNpbmcgRUlQLTE1NTkgb3IgRUlQLTQ4NDRcclxuICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcclxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vQFRPT0Q6IERvbid0IGF3YWl0IGFsbCBvdmVyIHRoZSBwbGFjZTsgc2F2ZSB0aGVtIHVwIGZvclxyXG4gICAgICAgIC8vIHRoZSBlbmQgZm9yIGJldHRlciBiYXRjaGluZ1xyXG4gICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlUHJvcGVydGllcyhwb3ApO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcG9wdWxhdGVBdXRob3JpemF0aW9uKF9hdXRoKSB7XHJcbiAgICAgICAgY29uc3QgYXV0aCA9IE9iamVjdC5hc3NpZ24oe30sIF9hdXRoKTtcclxuICAgICAgICAvLyBBZGQgYSBjaGFpbiBJRCBpZiBub3QgZXhwbGljaXRseSBzZXQgdG8gMFxyXG4gICAgICAgIGlmIChhdXRoLmNoYWluSWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhdXRoLmNoYWluSWQgPSAoYXdhaXQgY2hlY2tQcm92aWRlcih0aGlzLCBcImdldE5ldHdvcmtcIikuZ2V0TmV0d29yaygpKS5jaGFpbklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBAVE9ETzogVGFrZSBjaGFpbiBJRCBpbnRvIGFjY291bnQgd2hlbiBwb3B1bGF0aW5nIG5vY2U/XHJcbiAgICAgICAgaWYgKGF1dGgubm9uY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhdXRoLm5vbmNlID0gYXdhaXQgdGhpcy5nZXROb25jZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXV0aDtcclxuICAgIH1cclxuICAgIGFzeW5jIGVzdGltYXRlR2FzKHR4KSB7XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJlc3RpbWF0ZUdhc1wiKS5lc3RpbWF0ZUdhcyhhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY2FsbCh0eCkge1xyXG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiY2FsbFwiKS5jYWxsKGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwicmVzb2x2ZU5hbWVcIik7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwic2VuZFRyYW5zYWN0aW9uXCIpO1xyXG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0eCk7XHJcbiAgICAgICAgZGVsZXRlIHBvcC5mcm9tO1xyXG4gICAgICAgIGNvbnN0IHR4T2JqID0gVHJhbnNhY3Rpb24uZnJvbShwb3ApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5icm9hZGNhc3RUcmFuc2FjdGlvbihhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0eE9iaikpO1xyXG4gICAgfVxyXG4gICAgLy8gQFRPRE86IGluIHY3IG1vdmUgdGhpcyB0byBiZSBhYnN0cmFjdFxyXG4gICAgYXV0aG9yaXplKGF1dGhvcml6YXRpb24pIHtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiYXV0aG9yaXphdGlvbiBub3QgaW1wbGVtZW50ZWQgZm9yIHRoaXMgc2lnbmVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImF1dGhvcml6ZVwiIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAgQSAqKlZvaWRTaWduZXIqKiBpcyBhIGNsYXNzIGRlaXNnbmVkIHRvIGFsbG93IGFuIGFkZHJlc3MgdG8gYmUgdXNlZFxyXG4gKiAgaW4gYW55IEFQSSB3aGljaCBhY2NlcHRzIGEgU2lnbmVyLCBidXQgZm9yIHdoaWNoIHRoZXJlIGFyZSBub1xyXG4gKiAgY3JlZGVudGlhbHMgYXZhaWxhYmxlIHRvIHBlcmZvcm0gYW55IGFjdHVhbCBzaWduaW5nLlxyXG4gKlxyXG4gKiAgVGhpcyBmb3IgZXhhbXBsZSBhbGxvdyBpbXBlcnNvbmF0aW5nIGFuIGFjY291bnQgZm9yIHRoZSBwdXJwb3NlIG9mXHJcbiAqICBzdGF0aWMgY2FsbHMgb3IgZXN0aW1hdGluZyBnYXMsIGJ1dCBkb2VzIG5vdCBhbGxvdyBzZW5kaW5nIHRyYW5zYWN0aW9ucy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBWb2lkU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHNpZ25lciBhZGRyZXNzLlxyXG4gICAgICovXHJcbiAgICBhZGRyZXNzO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlZvaWRTaWduZXIqKiB3aXRoICUlYWRkcmVzcyUlIGF0dGFjaGVkIHRvXHJcbiAgICAgKiAgJSVwcm92aWRlciUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiB0aGlzLmFkZHJlc3M7IH1cclxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XHJcbiAgICB9XHJcbiAgICAjdGhyb3dVbnN1cHBvcnRlZChzdWZmaXgsIG9wZXJhdGlvbikge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgYFZvaWRTaWduZXIgY2Fubm90IHNpZ24gJHtzdWZmaXh9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHgpIHtcclxuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0eXBlZC1kYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1zaWduZXIuanMubWFwIiwiaW1wb3J0IHsgaXNFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XHJcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcclxufVxyXG4vKipcclxuICogIFNvbWUgYmFja2VuZHMgc3VwcG9ydCBzdWJzY3JpYmluZyB0byBldmVudHMgdXNpbmcgYSBGaWx0ZXIgSUQuXHJcbiAqXHJcbiAqICBXaGVuIHN1YnNjcmliaW5nIHdpdGggdGhpcyB0ZWNobmlxdWUsIHRoZSBub2RlIGlzc3VlcyBhIHVuaXF1ZVxyXG4gKiAgLy9GaWx0ZXIgSUQvLy4gQXQgdGhpcyBwb2ludCB0aGUgbm9kZSBkZWRpY2F0ZXMgcmVzb3VyY2VzIHRvXHJcbiAqICB0aGUgZmlsdGVyLCBzbyB0aGF0IHBlcmlvZGljIGNhbGxzIHRvIGZvbGxvdyB1cCBvbiB0aGUgLy9GaWx0ZXIgSUQvL1xyXG4gKiAgd2lsbCByZWNlaXZlIGFueSBldmVudHMgc2luY2UgdGhlIGxhc3QgY2FsbC5cclxuICpcclxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRmlsdGVySWRTdWJzY3JpYmVyIHtcclxuICAgICNwcm92aWRlcjtcclxuICAgICNmaWx0ZXJJZFByb21pc2U7XHJcbiAgICAjcG9sbGVyO1xyXG4gICAgI3J1bm5pbmc7XHJcbiAgICAjbmV0d29yaztcclxuICAgICNoYXVsdDtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiB3aGljaCB3aWxsIHVzZWQgW1tfc3Vic2NyaWJlXV1cclxuICAgICAqICBhbmQgW1tfZW1pdFJlc3VsdHNdXSB0byBzZXR1cCB0aGUgc3Vic2NyaXB0aW9uIGFuZCBwcm92aWRlIHRoZSBldmVudFxyXG4gICAgICogIHRvIHRoZSAlJXByb3ZpZGVyJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jaGF1bHQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgdG8gYmVnaW4gdGhlIHN1YnNjcmlwdGlvbi5cclxuICAgICAqL1xyXG4gICAgX3N1YnNjcmliZShwcm92aWRlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyBoYW5kbGUgdGhlIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHJlY292ZXJ5IG9uIGVycm9ycy5cclxuICAgICAqL1xyXG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcclxuICAgIH1cclxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICBpZiAodGhpcy4jZmlsdGVySWRQcm9taXNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IHRoaXMuX3N1YnNjcmliZSh0aGlzLiNwcm92aWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBGaWx0ZXIgSURcclxuICAgICAgICAgICAgbGV0IGZpbHRlcklkID0gbnVsbDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcklkID0gYXdhaXQgdGhpcy4jZmlsdGVySWRQcm9taXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiKSB8fCBlcnJvci5vcGVyYXRpb24gIT09IFwiZXRoX25ld0ZpbHRlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVGhlIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBGaWx0ZXIgSUQ7IGRvd25ncmFkZSB0b1xyXG4gICAgICAgICAgICAvLyBwb2xsaW5nXHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJJZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuX3JlY292ZXJTdWJzY3JpYmVyKHRoaXMsIHRoaXMuX3JlY292ZXIodGhpcy4jcHJvdmlkZXIpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuI25ldHdvcmspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBuZXR3b3JrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrLmNoYWluSWQgIT09IG5ldHdvcmsuY2hhaW5JZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhaWQgY2hhbmdlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy4jaGF1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIiwgW2ZpbHRlcklkXSk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2VtaXRSZXN1bHRzKHRoaXMuI3Byb3ZpZGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJAVE9ET1wiLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xyXG4gICAgfVxyXG4gICAgI3RlYXJkb3duKCkge1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcklkUHJvbWlzZSA9IHRoaXMuI2ZpbHRlcklkUHJvbWlzZTtcclxuICAgICAgICBpZiAoZmlsdGVySWRQcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGZpbHRlcklkUHJvbWlzZS50aGVuKChmaWx0ZXJJZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3Byb3ZpZGVyLmRlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy4jaGF1bHQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XHJcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcclxuICAgIH1cclxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xyXG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcclxuICAgICAgICAgICAgdGhpcy4jdGVhcmRvd24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcclxuICAgIH1cclxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XHJcbn1cclxuLyoqXHJcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBjb250cmFjdCBldmVudHMuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcclxuICAgICNldmVudDtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJVxyXG4gICAgICogIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xyXG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLiNldmVudCA9IGNvcHkoZmlsdGVyKTtcclxuICAgIH1cclxuICAgIF9yZWNvdmVyKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHByb3ZpZGVyLCB0aGlzLiNldmVudCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgZmlsdGVySWQgPSBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld0ZpbHRlclwiLCBbdGhpcy4jZXZlbnRdKTtcclxuICAgICAgICByZXR1cm4gZmlsdGVySWQ7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jZXZlbnQsIHByb3ZpZGVyLl93cmFwTG9nKHJlc3VsdCwgcHJvdmlkZXIuX25ldHdvcmspKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBldmVudHMuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIgZXh0ZW5kcyBGaWx0ZXJJZFN1YnNjcmliZXIge1xyXG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQoXCJwZW5kaW5nXCIsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZXItZmlsdGVyaWQuanMubWFwIiwiLyoqXHJcbiAqICBPbmUgb2YgdGhlIG1vc3QgY29tbW9uIHdheXMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgYmxvY2tjaGFpbiBpc1xyXG4gKiAgYnkgYSBub2RlIHJ1bm5pbmcgYSBKU09OLVJQQyBpbnRlcmZhY2Ugd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB0byxcclxuICogIGJhc2VkIG9uIHRoZSB0cmFuc3BvcnQsIHVzaW5nOlxyXG4gKlxyXG4gKiAgLSBIVFRQIG9yIEhUVFBTIC0gW1tKc29uUnBjUHJvdmlkZXJdXVxyXG4gKiAgLSBXZWJTb2NrZXQgLSBbW1dlYlNvY2tldFByb3ZpZGVyXV1cclxuICogIC0gSVBDIC0gW1tJcGNTb2NrZXRQcm92aWRlcl1dXHJcbiAqXHJcbiAqIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9qc29ucnBjOkpTT04tUlBDIFByb3ZpZGVyICBbYWJvdXQtanNvbnJwY1Byb3ZpZGVyXVxyXG4gKi9cclxuLy8gQFRPRE86XHJcbi8vIC0gQWRkIHRoZSBiYXRjaGluZyBBUElcclxuLy8gaHR0cHM6Ly9wbGF5Z3JvdW5kLm9wZW4tcnBjLm9yZy8/c2NoZW1hVXJsPWh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ldGhlcmV1bS9ldGgxLjAtYXBpcy9hc3NlbWJsZWQtc3BlYy9vcGVucnBjLmpzb24mdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpzcGxpdFZpZXclNUQ9dHJ1ZSZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOmlucHV0JTVEPWZhbHNlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6ZXhhbXBsZXNEcm9wZG93biU1RD1mYWxzZVxyXG5pbXBvcnQgeyBBYmlDb2RlciB9IGZyb20gXCIuLi9hYmkvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgZ2V0QWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBUeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSwgYXV0aG9yaXphdGlvbmlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGhleGxpZnksIGlzSGV4U3RyaW5nLCB0b1F1YW50aXR5LCB0b1V0ZjhCeXRlcywgaXNFcnJvciwgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBGZXRjaFJlcXVlc3QsIHJlc29sdmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IEFic3RyYWN0UHJvdmlkZXIsIFVubWFuYWdlZFN1YnNjcmliZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiO1xyXG5pbXBvcnQgeyBBYnN0cmFjdFNpZ25lciB9IGZyb20gXCIuL2Fic3RyYWN0LXNpZ25lci5qc1wiO1xyXG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xyXG5pbXBvcnQgeyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciwgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItZmlsdGVyaWQuanNcIjtcclxuaW1wb3J0IHsgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiO1xyXG5jb25zdCBQcmltaXRpdmUgPSBcImJpZ2ludCxib29sZWFuLGZ1bmN0aW9uLG51bWJlcixzdHJpbmcsc3ltYm9sXCIuc3BsaXQoLywvZyk7XHJcbi8vY29uc3QgTWV0aG9kcyA9IFwiZ2V0QWRkcmVzcyx0aGVuXCIuc3BsaXQoLywvZyk7XHJcbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBQcmltaXRpdmUuaW5kZXhPZih0eXBlb2YgKHZhbHVlKSkgPj0gMCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8vIEtlZXAgYW55IEFkZHJlc3NhYmxlXHJcbiAgICBpZiAodHlwZW9mICh2YWx1ZS5nZXRBZGRyZXNzKSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZS5tYXAoZGVlcENvcHkpKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGFjY3VtW2tleV0gPSB2YWx1ZVtrZXldO1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBzaG91bGQgbm90IGhhcHBlbjogJHt2YWx1ZX0gKCR7dHlwZW9mICh2YWx1ZSl9KWApO1xyXG59XHJcbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldExvd2VyQ2FzZSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gaXNQb2xsYWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnBvbGxpbmdJbnRlcnZhbCkgPT09IFwibnVtYmVyXCIpO1xyXG59XHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgcG9sbGluZzogZmFsc2UsXHJcbiAgICBzdGF0aWNOZXR3b3JrOiBudWxsLFxyXG4gICAgYmF0Y2hTdGFsbFRpbWU6IDEwLFxyXG4gICAgYmF0Y2hNYXhTaXplOiAoMSA8PCAyMCksXHJcbiAgICBiYXRjaE1heENvdW50OiAxMDAsXHJcbiAgICBjYWNoZVRpbWVvdXQ6IDI1MCxcclxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxyXG59O1xyXG4vLyBAVE9ETzogVW5jaGVja2VkIFNpZ25lcnNcclxuZXhwb3J0IGNsYXNzIEpzb25ScGNTaWduZXIgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XHJcbiAgICBhZGRyZXNzO1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MpIHtcclxuICAgICAgICBzdXBlcihwcm92aWRlcik7XHJcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFkZHJlc3MgfSk7XHJcbiAgICB9XHJcbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCByZWNvbm5lY3QgSnNvblJwY1NpZ25lclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuY29ubmVjdFwiXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3M7XHJcbiAgICB9XHJcbiAgICAvLyBKU09OLVJQQyB3aWxsIGF1dG9tYXRpYWxseSBmaWxsIGluIG5vbmNlLCBldGMuIHNvIHdlIGp1c3QgY2hlY2sgZnJvbVxyXG4gICAgYXN5bmMgcG9wdWxhdGVUcmFuc2FjdGlvbih0eCkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGp1c3QgdGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGFmdGVyIHNlbnQsIHdoaWNoIGlzIHdoYXRcclxuICAgIC8vIHRoZSBiYXJlIEpTT04tUlBDIEFQSSBkb2VzO1xyXG4gICAgYXN5bmMgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKF90eCkge1xyXG4gICAgICAgIGNvbnN0IHR4ID0gZGVlcENvcHkoX3R4KTtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcclxuICAgICAgICBpZiAodHguZnJvbSkge1xyXG4gICAgICAgICAgICBjb25zdCBfZnJvbSA9IHR4LmZyb207XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhfZnJvbSwgdGhpcy5wcm92aWRlcik7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcm9tICE9IG51bGwgJiYgZnJvbS50b0xvd2VyQ2FzZSgpID09PSB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCBfdHgpO1xyXG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XHJcbiAgICAgICAgICAgIH0pKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxyXG4gICAgICAgIC8vIHdpc2hlcyB0byB1c2UgdGhpcywgaXQgaXMgZWFzeSB0byBzcGVjaWZ5IGV4cGxpY2l0bHksIG90aGVyd2lzZVxyXG4gICAgICAgIC8vIHdlIGxvb2sgaXQgdXAgZm9yIHRoZW0uXHJcbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHguZ2FzTGltaXQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHsgLi4udHgsIGZyb206IHRoaXMuYWRkcmVzcyB9KTtcclxuICAgICAgICAgICAgfSkoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBhZGRyZXNzIG1heSBiZSBhbiBFTlMgbmFtZSBvciBBZGRyZXNzYWJsZVxyXG4gICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IF90byA9IHR4LnRvO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0eC50byA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKF90bywgdGhpcy5wcm92aWRlcik7XHJcbiAgICAgICAgICAgIH0pKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXYWl0IHVudGlsIGFsbCBvZiBvdXIgcHJvcGVydGllcyBhcmUgZmlsbGVkIGluXHJcbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhleFR4ID0gdGhpcy5wcm92aWRlci5nZXRScGNUcmFuc2FjdGlvbih0eCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgW2hleFR4XSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcclxuICAgICAgICAvLyBUaGlzIGNhbm5vdCBiZSBtaW5lZCBhbnkgZWFybGllciB0aGFuIGFueSByZWNlbnQgYmxvY2tcclxuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgICAgICAvLyBTZW5kIHRoZSB0cmFuc2FjdGlvblxyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0eCk7XHJcbiAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcclxuICAgICAgICAvLyBmb3IgYSByZXNwb25zZSwgYW5kIHdlIG5lZWQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiwgc28gd2UgcG9sbFxyXG4gICAgICAgIC8vIGZvciBpdDsgaXQgc2hvdWxkIHNob3cgdXAgdmVyeSBxdWlja2x5XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRzID0gWzEwMDAsIDEwMF07XHJcbiAgICAgICAgICAgIGxldCBpbnZhbGlkcyA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrVHggPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSB0cmFuc2FjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihoYXNoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHR4LnJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oYmxvY2tOdW1iZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgY2FuY2VsbGVkOiBzdG9wIHBvbGxpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRhdGEgaXMgYmFkOiB0aGUgbm9kZSByZXR1cm5zIGJhZCB0cmFuc2FjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBjaGFuZ2VkOiBjYWxsaW5nIGFnYWluIHdpbGwgYWxzbyBmYWlsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdW5zdXBwb3J0ZWQ6IGxpa2VseSBkZXN0cm95ZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQU5DRUxMRURcIikgfHwgaXNFcnJvcihlcnJvciwgXCJCQURfREFUQVwiKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Vycm9yKGVycm9yLCBcIk5FVFdPUktfRVJST1JcIikgfHwgaXNFcnJvcihlcnJvciwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmluZm8gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuaW5mbyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8uc2VuZFRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcC1nYXAgZm9yIG1pc2JlaGF2aW5nIGJhY2tlbmRzOyBzZWUgIzQ1MTNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5pbmZvID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvLnNlbmRUcmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZHMgPiAxMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RpZnkgYW55b25lIHRoYXQgY2FyZXM7IGJ1dCB3ZSB3aWxsIHRyeSBhZ2Fpbiwgc2luY2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBsaWtlbHkgYW4gaW50ZXJtaXR0ZW50IHNlcnZpY2UgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLmVtaXQoXCJlcnJvclwiLCBtYWtlRXJyb3IoXCJmYWlsZWQgdG8gZmV0Y2ggdHJhbnNhdGlvbiBhZnRlciBzZW5kaW5nICh3aWxsIHRyeSBhZ2FpbilcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgZXJyb3IgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gV2FpdCBhbm90aGVyIDQgc2Vjb25kc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5fc2V0VGltZW91dCgoKSA9PiB7IGNoZWNrVHgoKTsgfSwgdGltZW91dHMucG9wKCkgfHwgNDAwMCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNoZWNrVHgoKTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24oX3R4KSB7XHJcbiAgICAgICAgY29uc3QgdHggPSBkZWVwQ29weShfdHgpO1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcclxuICAgICAgICBpZiAodHguZnJvbSkge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHguZnJvbSwgdGhpcy5wcm92aWRlcik7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XHJcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmdldFJwY1RyYW5zYWN0aW9uKHR4KTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKF9tZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF9zaWduXCIsIFtcclxuICAgICAgICAgICAgaGV4bGlmeShtZXNzYWdlKSwgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKClcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgX3ZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkZWVwQ29weShfdmFsdWUpO1xyXG4gICAgICAgIC8vIFBvcHVsYXRlIGFueSBFTlMgbmFtZXMgKGluLXBsYWNlKVxyXG4gICAgICAgIGNvbnN0IHBvcHVsYXRlZCA9IGF3YWl0IFR5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHZhbHVlKTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcyAhPSBudWxsLCBcIlR5cGVkRGF0YSBkb2VzIG5vdCBzdXBwb3J0IG51bGwgYWRkcmVzc1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHlwZWREYXRhX3Y0XCIsIFtcclxuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFR5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHVubG9jayhwYXNzd29yZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFtcclxuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0pTT04tUlBDI2V0aF9zaWduXHJcbiAgICBhc3luYyBfbGVnYWN5U2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gKCh0eXBlb2YgKF9tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhfbWVzc2FnZSkgOiBfbWVzc2FnZSk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFtcclxuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIGhleGxpZnkobWVzc2FnZSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIFRoZSBKc29uUnBjQXBpUHJvdmlkZXIgaXMgYW4gYWJzdHJhY3QgY2xhc3MgYW5kICoqTVVTVCoqIGJlXHJcbiAqICBzdWItY2xhc3NlZC5cclxuICpcclxuICogIEl0IHByb3ZpZGVzIHRoZSBiYXNlIGZvciBhbGwgSlNPTi1SUEMtYmFzZWQgUHJvdmlkZXIgaW50ZXJhY3Rpb24uXHJcbiAqXHJcbiAqICBTdWItY2xhc3NpbmcgTm90ZXM6XHJcbiAqICAtIGEgc3ViLWNsYXNzIE1VU1Qgb3ZlcnJpZGUgX3NlbmRcclxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIHRoZSBgX3N0YXJ0KClgIG1ldGhvZCBvbmNlIGNvbm5lY3RlZFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEpzb25ScGNBcGlQcm92aWRlciBleHRlbmRzIEFic3RyYWN0UHJvdmlkZXIge1xyXG4gICAgI29wdGlvbnM7XHJcbiAgICAvLyBUaGUgbmV4dCBJRCB0byB1c2UgZm9yIHRoZSBKU09OLVJQQyBJRCBmaWVsZFxyXG4gICAgI25leHRJZDtcclxuICAgIC8vIFBheWxvYWRzIGFyZSBxdWV1ZWQgYW5kIHRyaWdnZXJlZCBpbiBiYXRjaGVzIHVzaW5nIHRoZSBkcmFpblRpbWVyXHJcbiAgICAjcGF5bG9hZHM7XHJcbiAgICAjZHJhaW5UaW1lcjtcclxuICAgICNub3RSZWFkeTtcclxuICAgICNuZXR3b3JrO1xyXG4gICAgI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xyXG4gICAgI3NjaGVkdWxlRHJhaW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI2RyYWluVGltZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgYmF0Y2hpbmcsIG5vIGhhcm0gaW4gc2VuZGluZyBpdCBpbW1lZGlhdGVseVxyXG4gICAgICAgIGNvbnN0IHN0YWxsVGltZSA9ICh0aGlzLl9nZXRPcHRpb24oXCJiYXRjaE1heENvdW50XCIpID09PSAxKSA/IDAgOiB0aGlzLl9nZXRPcHRpb24oXCJiYXRjaFN0YWxsVGltZVwiKTtcclxuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHRoaXMuI3BheWxvYWRzO1xyXG4gICAgICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xyXG4gICAgICAgICAgICB3aGlsZSAocGF5bG9hZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgcGF5bG9hZCBiYXRjaGVzIHRoYXQgc2F0aXNmeSBvdXIgYmF0Y2ggY29uc3RyYWludHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gWyhwYXlsb2Fkcy5zaGlmdCgpKV07XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocGF5bG9hZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA9PT0gdGhpcy4jb3B0aW9ucy5iYXRjaE1heENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYXRjaC5wdXNoKChwYXlsb2Fkcy5zaGlmdCgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBKU09OLnN0cmluZ2lmeShiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiB0aGlzLiNvcHRpb25zLmJhdGNoTWF4U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2Fkcy51bnNoaWZ0KChiYXRjaC5wb3AoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSByZXN1bHQgdG8gZWFjaCBwYXlsb2FkXHJcbiAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSAoKGJhdGNoLmxlbmd0aCA9PT0gMSkgPyBiYXRjaFswXS5wYXlsb2FkIDogYmF0Y2gubWFwKChwKSA9PiBwLnBheWxvYWQpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3NlbmQocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHJlc3VsdHMgaW4gYmF0Y2ggb3JkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlc29sdmUsIHJlamVjdCwgcGF5bG9hZCB9IG9mIGJhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwicHJvdmlkZXIgZGVzdHJveWVkOyBjYW5jZWxsZWQgcmVxdWVzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWF0Y2hpbmcgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gcmVzdWx0LmZpbHRlcigocikgPT4gKHIuaWQgPT09IHBheWxvYWQuaWQpKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdDsgdGhlIG5vZGUgZmFpbGVkIHVzIGluIHVuZXhwZWN0ZWQgd2F5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3AgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbWFrZUVycm9yKFwibWlzc2luZyByZXNwb25zZSBmb3IgcmVxdWVzdFwiLCBcIkJBRF9EQVRBXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdCwgaW5mbzogeyBwYXlsb2FkIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZSBpcyBhbiBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByZXNwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgcmVzcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGdvb2Q7IHNlbmQgdGhlIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNFcnJvclwiLCBlcnJvciB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlamVjdCB9IG9mIGJhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogYXVnbWVudCB0aGUgZXJyb3Igd2l0aCB0aGUgcGF5bG9hZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBzdGFsbFRpbWUpO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuI25leHRJZCA9IDE7XHJcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcclxuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI25ldHdvcmsgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCByZXNvbHZlID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy4jbm90UmVhZHkgPSB7IHByb21pc2UsIHJlc29sdmUgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhdGljTmV0d29yayA9IHRoaXMuX2dldE9wdGlvbihcInN0YXRpY05ldHdvcmtcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoc3RhdGljTmV0d29yaykgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFzdGF0aWNOZXR3b3JrIHx8IG5ldHdvcmsgIT09IFwiYW55XCIsIFwic3RhdGljTmV0d29yayBjYW5ub3QgYmUgdXNlZCBvbiBzcGVjaWFsIG5ldHdvcmsgJ2FueSdcIiwgXCJvcHRpb25zXCIsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGljTmV0d29yayAmJiBuZXR3b3JrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBOZXR3b3JrLmZyb20obmV0d29yayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RhdGljTmV0d29yaykge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYW55IHN0YXRpYyBuZXR3b3JrIGlzIGNvbXBhdGJpbGUgd2l0aCB0aGUgcHJvdmlkZWQgbmV0d3Jva1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChuZXR3b3JrID09IG51bGwgfHwgc3RhdGljTmV0d29yay5tYXRjaGVzKG5ldHdvcmspLCBcInN0YXRpY05ldHdvcmsgTVVTVCBtYXRjaCBuZXR3b3JrIG9iamVjdFwiLCBcIm9wdGlvbnNcIiwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBzdGF0aWNOZXR3b3JrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3B0aW9uICUla2V5JSUuXHJcbiAgICAgKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzIGNhbiB1c2UgdGhpcyB0byBpbnF1aXJlIGFib3V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cclxuICAgICAqL1xyXG4gICAgX2dldE9wdGlvbihrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9uc1trZXldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgR2V0cyB0aGUgW1tOZXR3b3JrXV0gdGhpcyBwcm92aWRlciBoYXMgY29tbWl0dGVkIHRvLiBPbiBlYWNoIGNhbGwsIHRoZSBuZXR3b3JrXHJcbiAgICAgKiAgaXMgZGV0ZWN0ZWQsIGFuZCBpZiBpdCBoYXMgY2hhbmdlZCwgdGhlIGNhbGwgd2lsbCByZWplY3QuXHJcbiAgICAgKi9cclxuICAgIGdldCBfbmV0d29yaygpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy4jbmV0d29yaywgXCJuZXR3b3JrIGlzIG5vdCBhdmFpbGFibGUgeWV0XCIsIFwiTkVUV09SS19FUlJPUlwiKTtcclxuICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBub24tbm9ybWFsaXplZCB2YWx1ZSBieSBwZXJmb3JtaW5nICUlcmVxJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIG1vZGlmeSBiZWhhdmlvciBvZiBhY3Rpb25zLFxyXG4gICAgICogIGFuZCBzaG91bGQgZ2VuZXJhbGx5IGNhbGwgYGBzdXBlci5fcGVyZm9ybWBgIGFzIGEgZmFsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xyXG4gICAgICAgIC8vIExlZ2FjeSBuZXR3b3JrcyBkbyBub3QgbGlrZSB0aGUgdHlwZSBmaWVsZCBiZWluZyBwYXNzZWQgYWxvbmcgKHdoaWNoXHJcbiAgICAgICAgLy8gaXMgZmFpciksIHNvIHdlIGRlbGV0ZSB0eXBlIGlmIGl0IGlzIDAgYW5kIGEgbm9uLUVJUC0xNTU5IG5ldHdvcmtcclxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJjYWxsXCIgfHwgcmVxLm1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSB7XHJcbiAgICAgICAgICAgIGxldCB0eCA9IHJlcS50cmFuc2FjdGlvbjtcclxuICAgICAgICAgICAgaWYgKHR4ICYmIHR4LnR5cGUgIT0gbnVsbCAmJiBnZXRCaWdJbnQodHgudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBFSVAtMTU1OSBvciBuZXdlciBwcm9wZXJ0aWVzLCBpdCBtaWdodCBiZSBwcmUtRUlQLTE1NTlcclxuICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0RmVlRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyA9PSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qga25vdyBhYm91dCBFSVAtMTU1OSAoYW5kIGhlbmNlIHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IE9iamVjdC5hc3NpZ24oe30sIHJlcSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4LCB7IHR5cGU6IHVuZGVmaW5lZCB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuZ2V0UnBjUmVxdWVzdChyZXEpO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5hcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9wZXJmb3JtKHJlcSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpczsgaXQgZGV0ZWN0cyB0aGUgKmFjdHVhbCogbmV0d29yayB0aGF0XHJcbiAgICAgKiAgd2UgYXJlICoqY3VycmVudGx5KiogY29ubmVjdGVkIHRvLlxyXG4gICAgICpcclxuICAgICAqICBLZWVwIGluIG1pbmQgdGhhdCBbW3NlbmRdXSBtYXkgb25seSBiZSB1c2VkIG9uY2UgW1tyZWFkeV1dLCBvdGhlcndpc2UgdGhlXHJcbiAgICAgKiAgX3NlbmQgcHJpbWl0aXZlIG11c3QgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBfZGV0ZWN0TmV0d29yaygpIHtcclxuICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcclxuICAgICAgICBpZiAobmV0d29yaykge1xyXG4gICAgICAgICAgICBpZiAobmV0d29yayA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmspIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaykge1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcms7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGFyZSByZWFkeSwgdXNlIGBgc2VuZGBgLCB3aGljaCBlbmFibGVkIHJlcXVlc3RzIHRvIGJlIGJhdGNoZWRcclxuICAgICAgICBpZiAodGhpcy5yZWFkeSkge1xyXG4gICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IE5ldHdvcmsuZnJvbShnZXRCaWdJbnQoYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIiwgW10pKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgYXJlIG5vdCByZWFkeSB5ZXQ7IHVzZSB0aGUgcHJpbWl0aXZlIF9zZW5kXHJcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuI25leHRJZCsrLCBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIiwgcGFyYW1zOiBbXSwganNvbnJwYzogXCIyLjBcIlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKGF3YWl0IHRoaXMuX3NlbmQocGF5bG9hZCkpWzBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XHJcbiAgICAgICAgICAgIGlmIChcInJlc3VsdFwiIGluIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5ldHdvcmsuZnJvbShnZXRCaWdJbnQocmVzdWx0LnJlc3VsdCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgcmVzdWx0KTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzICoqTVVTVCoqIGNhbGwgdGhpcy4gVW50aWwgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNhbGxzXHJcbiAgICAgKiAgd2lsbCBiZSBwYXNzZWQgdG8gW1tfc2VuZF1dIGZyb20gW1tzZW5kXV0uIElmIGl0IGlzIG92ZXJyaWRkZW4sIHRoZW5cclxuICAgICAqICBgYHN1cGVyLl9zdGFydCgpYGAgKipNVVNUKiogYmUgY2FsbGVkLlxyXG4gICAgICpcclxuICAgICAqICBDYWxsaW5nIGl0IG11bHRpcGxlIHRpbWVzIGlzIHNhZmUgYW5kIGhhcyBubyBlZmZlY3QuXHJcbiAgICAgKi9cclxuICAgIF9zdGFydCgpIHtcclxuICAgICAgICBpZiAodGhpcy4jbm90UmVhZHkgPT0gbnVsbCB8fCB0aGlzLiNub3RSZWFkeS5yZXNvbHZlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNub3RSZWFkeS5yZXNvbHZlKCk7XHJcbiAgICAgICAgdGhpcy4jbm90UmVhZHkgPSBudWxsO1xyXG4gICAgICAgIChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEJvb3RzdHJhcCB0aGUgbmV0d29ya1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy4jbmV0d29yayA9PSBudWxsICYmICF0aGlzLmRlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gYXdhaXQgdGhpcy5fZGV0ZWN0TmV0d29yaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkpzb25ScGNQcm92aWRlciBmYWlsZWQgdG8gZGV0ZWN0IG5ldHdvcmsgYW5kIGNhbm5vdCBzdGFydCB1cDsgcmV0cnkgaW4gMXMgKHBlcmhhcHMgdGhlIFVSTCBpcyB3cm9uZyBvciB0aGUgbm9kZSBpcyBub3Qgc3RhcnRlZClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbWFrZUVycm9yKFwiZmFpbGVkIHRvIGJvb3RzdHJhcCBuZXR3b3JrIGRldGVjdGlvblwiLCBcIk5FVFdPUktfRVJST1JcIiwgeyBldmVudDogXCJpbml0aWFsLW5ldHdvcmstZGlzY292ZXJ5XCIsIGluZm86IHsgZXJyb3IgfSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMTAwMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3RhcnQgZGlzcGF0Y2hpbmcgcmVxdWVzdHNcclxuICAgICAgICAgICAgdGhpcy4jc2NoZWR1bGVEcmFpbigpO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoZSBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZC4gVGhpcyBjYW4gYmUgdXNlZCBpblxyXG4gICAgICogIHN1Yi1jbGFzc2VzIHRvIGRlZmVyIHNlbmRpbmcgZGF0YSB1bnRpbCB0aGUgY29ubmVjdGlvbiBoYXMgYmVlblxyXG4gICAgICogIGVzdGFibGlzaGVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBfd2FpdFVudGlsUmVhZHkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jbm90UmVhZHkucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybiBhIFN1YnNjcmliZXIgdGhhdCB3aWxsIG1hbmFnZSB0aGUgJSVzdWIlJS5cclxuICAgICAqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IHRoZSBiZWhhdmlvciBvZlxyXG4gICAgICogIHN1YnNjcmlwdGlvbiBtYW5hZ2VtZW50LlxyXG4gICAgICovXHJcbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcclxuICAgICAgICAvLyBQZW5kaW5nIEZpbHRlcnMgYXJlbid0IGF2YWlsYmxlIHZpYSBwb2xsaW5nXHJcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcInBlbmRpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJldmVudFwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRPcHRpb24oXCJwb2xsaW5nXCIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3JwaGFuZWQgTG9ncyBhcmUgaGFuZGxlZCBhdXRvbWF0aWNhbGx5LCBieSB0aGUgZmlsdGVyLCBzaW5jZVxyXG4gICAgICAgIC8vIGxvZ3Mgd2l0aCByZW1vdmVkIGFyZSBlbWl0dGVkIGJ5IGl0XHJcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcIm9ycGhhblwiICYmIHN1Yi5maWx0ZXIub3JwaGFuID09PSBcImRyb3AtbG9nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyKFwib3JwaGFuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHJlYWR5KCkgeyByZXR1cm4gdGhpcy4jbm90UmVhZHkgPT0gbnVsbDsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyAlJXR4JSUgYXMgYSBub3JtYWxpemVkIEpTT04tUlBDIHRyYW5zYWN0aW9uIHJlcXVlc3QsXHJcbiAgICAgKiAgd2hpY2ggaGFzIGFsbCB2YWx1ZXMgaGV4bGlmaWVkIGFuZCBhbnkgbnVtZXJpYyB2YWx1ZXMgY29udmVydGVkXHJcbiAgICAgKiAgdG8gUXVhbnRpdHkgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBnZXRScGNUcmFuc2FjdGlvbih0eCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIC8vIEpTT04tUlBDIG5vdyByZXF1aXJlcyBudW1lcmljIHZhbHVlcyB0byBiZSBcInF1YW50aXR5XCIgdmFsdWVzXHJcbiAgICAgICAgW1wiY2hhaW5JZFwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ0eXBlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJub25jZVwiLCBcInZhbHVlXCJdLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGRzdEtleSA9IGtleTtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJnYXNMaW1pdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBkc3RLZXkgPSBcImdhc1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdFtkc3RLZXldID0gdG9RdWFudGl0eShnZXRCaWdJbnQodHhba2V5XSwgYHR4LiR7a2V5fWApKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgYWRkcmVzc2VzIGFuZCBkYXRhIGFyZSBsb3dlcmNhc2VcclxuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIiwgXCJkYXRhXCJdLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZXhsaWZ5KHR4W2tleV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgYWNjZXNzIGxpc3Qgb2JqZWN0XHJcbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QpIHtcclxuICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9IGFjY2Vzc0xpc3RpZnkodHguYWNjZXNzTGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzKSB7XHJcbiAgICAgICAgICAgIC8vIEBUT0RPOiBSZW1vdmUgdGhpcyA8YW55PiBjYXNlIG9uY2UgRUlQLTQ4NDQgYWRkZWQgdG8gcHJlcGFyZWQgdHhcclxuICAgICAgICAgICAgcmVzdWx0W1wiYmxvYlZlcnNpb25lZEhhc2hlc1wiXSA9IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMubWFwKGggPT4gaC50b0xvd2VyQ2FzZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4LmF1dGhvcml6YXRpb25MaXN0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtcImF1dGhvcml6YXRpb25MaXN0XCJdID0gdHguYXV0aG9yaXphdGlvbkxpc3QubWFwKChfYSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGF1dGhvcml6YXRpb25pZnkoX2EpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhLmFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHRvUXVhbnRpdHkoYS5ub25jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogdG9RdWFudGl0eShhLmNoYWluSWQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHlQYXJpdHk6IHRvUXVhbnRpdHkoYS5zaWduYXR1cmUueVBhcml0eSksXHJcbiAgICAgICAgICAgICAgICAgICAgcjogdG9RdWFudGl0eShhLnNpZ25hdHVyZS5yKSxcclxuICAgICAgICAgICAgICAgICAgICBzOiB0b1F1YW50aXR5KGEuc2lnbmF0dXJlLnMpLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEBUT0RPOiBibG9icyBzaG91bGQgcHJvYmFibHkgYWxzbyBiZSBjb3BpZWQgb3Zlciwgb3B0aW9uYWxseVxyXG4gICAgICAgIC8vIGFjY291bnRpbmcgZm9yIHRoZSBremcgcHJvcGVydHkgdG8gYmFja2ZpbGwgYmxvYlZlcnNpb25lZEhhc2hlc1xyXG4gICAgICAgIC8vIHVzaW5nIHRoZSBjb21taXRtZW50LiBPciBzaG91bGQgdGhhdCBiZSBsZWZ0IGFzIGFuIGV4ZXJjaXNlIHRvXHJcbiAgICAgICAgLy8gdGhlIGNhbGxlcj9cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgcmVxdWVzdCBtZXRob2QgYW5kIGFyZ3VtZW50cyByZXF1aXJlZCB0byBwZXJmb3JtXHJcbiAgICAgKiAgJSVyZXElJS5cclxuICAgICAqL1xyXG4gICAgZ2V0UnBjUmVxdWVzdChyZXEpIHtcclxuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcclxuICAgICAgICAgICAgY2FzZSBcImNoYWluSWRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBhcmdzOiBbXSB9O1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfYmxvY2tOdW1iZXJcIiwgYXJnczogW10gfTtcclxuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2dhc1ByaWNlXCIsIGFyZ3M6IFtdIH07XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRQcmlvcml0eUZlZVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBhcmdzOiBbXSB9O1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJhbGFuY2VcIixcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0Q29kZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLCByZXEuYmxvY2tUYWddXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFN0b3JhZ2VBdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiMHhcIiArIHJlcS5wb3NpdGlvbi50b1N0cmluZygxNikpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuYmxvY2tUYWdcclxuICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLnNpZ25lZFRyYW5zYWN0aW9uXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmJsb2NrVGFnLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImJsb2NrSGFzaFwiIGluIHJlcSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeUhhc2hcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja0hhc2gsICEhcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnNdXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuaGFzaF1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2NhbGxcIixcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pLCByZXEuYmxvY2tUYWddXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjoge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2VzdGltYXRlR2FzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3RoaXMuZ2V0UnBjVHJhbnNhY3Rpb24ocmVxLnRyYW5zYWN0aW9uKV1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcclxuICAgICAgICAgICAgICAgIGlmIChyZXEuZmlsdGVyICYmIHJlcS5maWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxLmZpbHRlci5hZGRyZXNzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuZmlsdGVyLmFkZHJlc3MgPSByZXEuZmlsdGVyLmFkZHJlc3MubWFwKGdldExvd2VyQ2FzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuZmlsdGVyLmFkZHJlc3MgPSBnZXRMb3dlckNhc2UocmVxLmZpbHRlci5hZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2dldExvZ3NcIiwgYXJnczogW3JlcS5maWx0ZXJdIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtc3R5bGUgRXJyb3IgZm9yIHRoZSBnaXZlbiBKU09OLVJQQyBlcnJvclxyXG4gICAgICogICUlcGF5bG9hZCUlLCBjb2FsZXNjaW5nIHRoZSB2YXJpb3VzIHN0cmluZ3MgYW5kIGVycm9yIHNoYXBlc1xyXG4gICAgICogIHRoYXQgZGlmZmVyZW50IG5vZGVzIHJldHVybiwgY29lcmNpbmcgdGhlbSBpbnRvIGEgbWFjaGluZS1yZWFkYWJsZVxyXG4gICAgICogIHN0YW5kYXJkaXplZCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgZ2V0UnBjRXJyb3IocGF5bG9hZCwgX2Vycm9yKSB7XHJcbiAgICAgICAgY29uc3QgeyBtZXRob2QgfSA9IHBheWxvYWQ7XHJcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gX2Vycm9yO1xyXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIgJiYgZXJyb3IubWVzc2FnZSkge1xyXG4gICAgICAgICAgICBjb25zdCBtc2cgPSBlcnJvci5tZXNzYWdlO1xyXG4gICAgICAgICAgICBpZiAoIW1zZy5tYXRjaCgvcmV2ZXJ0L2kpICYmIG1zZy5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzL2kpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogKHBheWxvYWQucGFyYW1zWzBdKSxcclxuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1zZy5tYXRjaCgvbm9uY2UvaSkgJiYgbXNnLm1hdGNoKC90b28gbG93L2kpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIFwiTk9OQ0VfRVhQSVJFRFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IChwYXlsb2FkLnBhcmFtc1swXSksXHJcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9jYWxsXCIgfHwgbWV0aG9kID09PSBcImV0aF9lc3RpbWF0ZUdhc1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmtEYXRhKGVycm9yKTtcclxuICAgICAgICAgICAgY29uc3QgZSA9IEFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKChtZXRob2QgPT09IFwiZXRoX2NhbGxcIikgPyBcImNhbGxcIiA6IFwiZXN0aW1hdGVHYXNcIiwgKHBheWxvYWQucGFyYW1zWzBdKSwgKHJlc3VsdCA/IHJlc3VsdC5kYXRhIDogbnVsbCkpO1xyXG4gICAgICAgICAgICBlLmluZm8gPSB7IGVycm9yLCBwYXlsb2FkIH07XHJcbiAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPbmx5IGVzdGltYXRlR2FzIGFuZCBjYWxsIGNhbiByZXR1cm4gYXJiaXRyYXJ5IGNvbnRyYWN0LWRlZmluZWQgdGV4dCwgc28gbm93IHdlXHJcbiAgICAgICAgLy8gd2UgY2FuIHByb2Nlc3MgdGV4dCBzYWZlbHkuXHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHNwZWx1bmtNZXNzYWdlKGVycm9yKSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWR8ZXRoZXJzLXVzZXItZGVuaWVkL2kpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbk1hcCA9IHtcclxuICAgICAgICAgICAgICAgIGV0aF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXHJcbiAgICAgICAgICAgICAgICBwZXJzb25hbF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXHJcbiAgICAgICAgICAgICAgICBldGhfc2lnblR5cGVkRGF0YV92NDogXCJzaWduVHlwZWREYXRhXCIsXHJcbiAgICAgICAgICAgICAgICBldGhfc2lnblRyYW5zYWN0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgZXRoX3NlbmRUcmFuc2FjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcclxuICAgICAgICAgICAgICAgIGV0aF9yZXF1ZXN0QWNjb3VudHM6IFwicmVxdWVzdEFjY2Vzc1wiLFxyXG4gICAgICAgICAgICAgICAgd2FsbGV0X3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoYHVzZXIgcmVqZWN0ZWQgYWN0aW9uYCwgXCJBQ1RJT05fUkVKRUNURURcIiwge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoYWN0aW9uTWFwW21ldGhvZF0gfHwgXCJ1bmtub3duXCIpLFxyXG4gICAgICAgICAgICAgICAgcmVhc29uOiBcInJlamVjdGVkXCIsXHJcbiAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiIHx8IG1ldGhvZCA9PT0gXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAocGF5bG9hZC5wYXJhbXNbMF0pO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzfGJhc2UgZmVlIGV4Y2VlZHMgZ2FzIGxpbWl0L2kpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBcIklOU1VGRklDSUVOVF9GVU5EU1wiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL25vbmNlL2kpICYmIG1lc3NhZ2UubWF0Y2goL3RvbyBsb3cvaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uL2kpICYmIG1lc3NhZ2UubWF0Y2goL3VuZGVycHJpY2VkL2kpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiLCB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL29ubHkgcmVwbGF5LXByb3RlY3RlZC9pKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImxlZ2FjeSBwcmUtZWlwLTE1NSB0cmFuc2FjdGlvbnMgbm90IHN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBtZXRob2QsIGluZm86IHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdW5zdXBwb3J0ZWQgPSAhIW1lc3NhZ2UubWF0Y2goL3RoZSBtZXRob2QgLiogZG9lcyBub3QgZXhpc3QvaSk7XHJcbiAgICAgICAgaWYgKCF1bnN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuZGV0YWlscyAmJiBlcnJvci5kZXRhaWxzLnN0YXJ0c1dpdGgoXCJVbmF1dGhvcml6ZWQgbWV0aG9kOlwiKSkge1xyXG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bnN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwidW5zdXBwb3J0ZWQgb3BlcmF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QsIGluZm86IHsgZXJyb3IsIHBheWxvYWQgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImNvdWxkIG5vdCBjb2FsZXNjZSBlcnJvclwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBlcnJvciwgcGF5bG9hZCB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlcXVlc3RzIHRoZSAlJW1ldGhvZCUlIHdpdGggJSVwYXJhbXMlJSB2aWEgdGhlIEpTT04tUlBDIHByb3RvY29sXHJcbiAgICAgKiAgb3ZlciB0aGUgdW5kZXJseWluZyBjaGFubmVsLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhbGwgbWV0aG9kc1xyXG4gICAgICogIG9uIHRoZSBiYWNrZW5kIHRoYXQgZG8gbm90IGhhdmUgYSBoaWdoLWxldmVsIEFQSSB3aXRoaW4gdGhlIFByb3ZpZGVyXHJcbiAgICAgKiAgQVBJLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIG1ldGhvZCBxdWV1ZXMgcmVxdWVzdHMgYWNjb3JkaW5nIHRvIHRoZSBiYXRjaCBjb25zdHJhaW50c1xyXG4gICAgICogIGluIHRoZSBvcHRpb25zLCBhc3NpZ25zIHRoZSByZXF1ZXN0IGEgdW5pcXVlIElELlxyXG4gICAgICpcclxuICAgICAqICAqKkRvIE5PVCBvdmVycmlkZSoqIHRoaXMgbWV0aG9kIGluIHN1Yi1jbGFzc2VzOyBpbnN0ZWFkXHJcbiAgICAgKiAgb3ZlcnJpZGUgW1tfc2VuZF1dIG9yIGZvcmNlIHRoZSBvcHRpb25zIHZhbHVlcyBpbiB0aGVcclxuICAgICAqICBjYWxsIHRvIHRoZSBjb25zdHJ1Y3RvciB0byBtb2RpZnkgdGhpcyBtZXRob2QncyBiZWhhdmlvci5cclxuICAgICAqL1xyXG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xyXG4gICAgICAgIC8vIEBUT0RPOiBjYWNoZSBjaGFpbklkPz8gcHVyZ2Ugb24gc3dpdGNoX25ldHdvcmtzXHJcbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIGRlc3Ryb3llZDsgbm8gb3BlcmF0aW9ucyBhcmUgc3VwcG9ydGVkIGFueW1vcmVcclxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IG1ldGhvZCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy4jbmV4dElkKys7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy4jcGF5bG9hZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlLCByZWplY3QsXHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IG1ldGhvZCwgcGFyYW1zLCBpZCwganNvbnJwYzogXCIyLjBcIiB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBhIHBlbmRpbmcgZHJhaW5UaW1lciwgc2V0IG9uZVxyXG4gICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBbW1NpZ25lcl1dIGFjY291bnQgZm9yICAlJWFkZHJlc3MlJSBtYW5hZ2VkIGJ5XHJcbiAgICAgKiAgdGhlIGNsaWVudC5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgdGhlICUlYWRkcmVzcyUlIGlzIGEgbnVtYmVyLCBpdCBpcyB1c2VkIGFzIGFuIGluZGV4IGluIHRoZVxyXG4gICAgICogIHRoZSBhY2NvdW50cyBmcm9tIFtbbGlzdEFjY291bnRzXV0uXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCBvbiBjbGllbnRzIHdoaWNoIG1hbmFnZSBhY2NvdW50cyAoc3VjaCBhc1xyXG4gICAgICogIEdldGggd2l0aCBpbXBvcnRlZCBhY2NvdW50IG9yIE1ldGFNYXNrKS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSBhY2NvdW50IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFNpZ25lcihhZGRyZXNzKSB7XHJcbiAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWNjb3VudHNQcm9taXNlID0gdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKTtcclxuICAgICAgICAvLyBBY2NvdW50IGluZGV4XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSAoYXdhaXQgYWNjb3VudHNQcm9taXNlKTtcclxuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPj0gYWNjb3VudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdWNoIGFjY291bnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFjY291bnRzW2FkZHJlc3NdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBhY2NvdW50cyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcclxuICAgICAgICAgICAgYWNjb3VudHM6IGFjY291bnRzUHJvbWlzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEFjY291bnQgYWRkcmVzc1xyXG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiBhY2NvdW50cykge1xyXG4gICAgICAgICAgICBpZiAoZ2V0QWRkcmVzcyhhY2NvdW50KSA9PT0gYWRkcmVzcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFkZHJlc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWNjb3VudFwiKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGxpc3RBY2NvdW50cygpIHtcclxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XHJcbiAgICAgICAgcmV0dXJuIGFjY291bnRzLm1hcCgoYSkgPT4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYSkpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICAvLyBTdG9wIHByb2Nlc3NpbmcgcmVxdWVzdHNcclxuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jZHJhaW5UaW1lcik7XHJcbiAgICAgICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYW5jZWwgYWxsIHBlbmRpbmcgcmVxdWVzdHNcclxuICAgICAgICBmb3IgKGNvbnN0IHsgcGF5bG9hZCwgcmVqZWN0IH0gb2YgdGhpcy4jcGF5bG9hZHMpIHtcclxuICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcclxuICAgICAgICAvLyBQYXJlbnQgY2xlYW4tdXBcclxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuLy8gQFRPRE86IHJlbW92ZSB0aGlzIGluIHY3LCBpdCBpcyBub3QgZXhwb3J0ZWQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uYWxpdHlcclxuLy8gaXMgZXhwb3NlZCBpbiB0aGUgSnNvblJwY0FwaVByb3ZpZGVyIGJ5IHNldHRpbmcgcG9sbGluZyB0byB0cnVlLiBJdCBzaG91bGRcclxuLy8gYmUgc2FmZSB0byByZW1vdmUgcmVnYXJkbGVzcywgYmVjYXVzZSBpdCBpc24ndCByZWFjaGFibGUsIGJ1dCBqdXN0IGluIGNhc2UuXHJcbi8qKlxyXG4gKiAgQF9pZ25vcmU6XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQcm92aWRlciB7XHJcbiAgICAjcG9sbGluZ0ludGVydmFsO1xyXG4gICAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xyXG4gICAgICAgIGxldCBwb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLl9nZXRPcHRpb24oXCJwb2xsaW5nSW50ZXJ2YWxcIik7XHJcbiAgICAgICAgaWYgKHBvbGxpbmdJbnRlcnZhbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IGRlZmF1bHRPcHRpb25zLnBvbGxpbmdJbnRlcnZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gcG9sbGluZ0ludGVydmFsO1xyXG4gICAgfVxyXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XHJcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XHJcbiAgICAgICAgaWYgKGlzUG9sbGFibGUoc3Vic2NyaWJlcikpIHtcclxuICAgICAgICAgICAgc3Vic2NyaWJlci5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHBvbGxpbmcgaW50ZXJ2YWwgKGRlZmF1bHQ6IDQwMDAgbXMpXHJcbiAgICAgKi9cclxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7IH1cclxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHtcclxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludGVydmFsXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNwb2xsaW5nSW50ZXJ2YWwgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigoc3ViKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YikpIHtcclxuICAgICAgICAgICAgICAgIHN1Yi5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogIFRoZSBKc29uUnBjUHJvdmlkZXIgaXMgb25lIG9mIHRoZSBtb3N0IGNvbW1vbiBQcm92aWRlcnMsXHJcbiAqICB3aGljaCBwZXJmb3JtcyBhbGwgb3BlcmF0aW9ucyBvdmVyIEhUVFAgKG9yIEhUVFBTKSByZXF1ZXN0cy5cclxuICpcclxuICogIEV2ZW50cyBhcmUgcHJvY2Vzc2VkIGJ5IHBvbGxpbmcgdGhlIGJhY2tlbmQgZm9yIHRoZSBjdXJyZW50IGJsb2NrXHJcbiAqICBudW1iZXI7IHdoZW4gaXQgYWR2YW5jZXMsIGFsbCBibG9jay1iYXNlIGV2ZW50cyBhcmUgdGhlbiBjaGVja2VkXHJcbiAqICBmb3IgdXBkYXRlcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIHtcclxuICAgICNjb25uZWN0O1xyXG4gICAgY29uc3RydWN0b3IodXJsLCBuZXR3b3JrLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHVybCA9IFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gbmV3IEZldGNoUmVxdWVzdCh1cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IHVybC5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRDb25uZWN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNjb25uZWN0LmNsb25lKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XHJcbiAgICAgICAgLy8gQWxsIHJlcXVlc3RzIGFyZSBvdmVyIEhUVFAsIHNvIHdlIGNhbiBqdXN0IHN0YXJ0IGhhbmRsaW5nIHJlcXVlc3RzXHJcbiAgICAgICAgLy8gV2UgZG8gdGhpcyBoZXJlIHJhdGhlciB0aGFuIHRoZSBjb25zdHJ1Y3RvciBzbyB0aGF0IHdlIGRvbid0IHNlbmQgYW55XHJcbiAgICAgICAgLy8gcmVxdWVzdHMgdG8gdGhlIG5ldHdvcmsgKGkuZS4gZXRoX2NoYWluSWQpIHVudGlsIHdlIGFic29sdXRlbHkgaGF2ZSB0by5cclxuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9zZW5kKHBheWxvYWQpIHtcclxuICAgICAgICAvLyBDb25maWd1cmUgYSBQT1NUIGNvbm5lY3Rpb24gZm9yIHRoZSByZXF1ZXN0ZWQgbWV0aG9kXHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX2dldENvbm5lY3Rpb24oKTtcclxuICAgICAgICByZXF1ZXN0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcclxuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcclxuICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xyXG4gICAgICAgIGxldCByZXNwID0gcmVzcG9uc2UuYm9keUpzb247XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3ApKSB7XHJcbiAgICAgICAgICAgIHJlc3AgPSBbcmVzcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNwO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNwZWx1bmtEYXRhKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cclxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1lc3NhZ2UubWF0Y2goL3JldmVydC9pKSAmJiBpc0hleFN0cmluZyh2YWx1ZS5kYXRhKSkge1xyXG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsIGRhdGE6IHZhbHVlLmRhdGEgfTtcclxuICAgIH1cclxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVua0RhdGEodmFsdWVba2V5XSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cclxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzcGVsdW5rRGF0YShKU09OLnBhcnNlKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBfc3BlbHVua01lc3NhZ2UodmFsdWUsIHJlc3VsdCkge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZS5tZXNzYWdlKTtcclxuICAgIH1cclxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxyXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlW2tleV0sIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXHJcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3NwZWx1bmtNZXNzYWdlKEpTT04ucGFyc2UodmFsdWUpLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNwZWx1bmtNZXNzYWdlKHZhbHVlKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZSwgcmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItanNvbnJwYy5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGhhc2hBdXRob3JpemF0aW9uLCBoYXNoTWVzc2FnZSwgVHlwZWREYXRhRW5jb2RlciB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IEFic3RyYWN0U2lnbmVyLCBjb3B5UmVxdWVzdCB9IGZyb20gXCIuLi9wcm92aWRlcnMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgY29tcHV0ZUFkZHJlc3MsIFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuLyoqXHJcbiAqICBUaGUgKipCYXNlV2FsbGV0KiogaXMgYSBzdHJlYW0tbGluZWQgaW1wbGVtZW50YXRpb24gb2YgYVxyXG4gKiAgW1tTaWduZXJdXSB0aGF0IG9wZXJhdGVzIHdpdGggYSBwcml2YXRlIGtleS5cclxuICpcclxuICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFtbV2FsbGV0XV0gY2xhc3MsIGFzIGl0IG9mZmVyc1xyXG4gKiAgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IGFuZCBzaW1wbGlmaWVzIGxvYWRpbmcgYSB2YXJpZXR5XHJcbiAqICBvZiBKU09OIGZvcm1hdHMsIE1uZW1vbmljIFBocmFzZXMsIGV0Yy5cclxuICpcclxuICogIFRoaXMgY2xhc3MgbWF5IGJlIG9mIHVzZSBmb3IgdGhvc2UgYXR0ZW1wdGluZyB0byBpbXBsZW1lbnRcclxuICogIGEgbWluaW1hbCBTaWduZXIuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmFzZVdhbGxldCBleHRlbmRzIEFic3RyYWN0U2lnbmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB3YWxsZXQgYWRkcmVzcy5cclxuICAgICAqL1xyXG4gICAgYWRkcmVzcztcclxuICAgICNzaWduaW5nS2V5O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBCYXNlV2FsbGV0IGZvciAlJXByaXZhdGVLZXklJSwgb3B0aW9uYWxseVxyXG4gICAgICogIGNvbm5lY3RlZCB0byAlJXByb3ZpZGVyJSUuXHJcbiAgICAgKlxyXG4gICAgICogIElmICUlcHJvdmlkZXIlJSBpcyBub3Qgc3BlY2lmaWVkLCBvbmx5IG9mZmxpbmUgbWV0aG9kcyBjYW5cclxuICAgICAqICBiZSB1c2VkLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5LCBwcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChwcml2YXRlS2V5ICYmIHR5cGVvZiAocHJpdmF0ZUtleS5zaWduKSA9PT0gXCJmdW5jdGlvblwiLCBcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xyXG4gICAgICAgIHRoaXMuI3NpZ25pbmdLZXkgPSBwcml2YXRlS2V5O1xyXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcyh0aGlzLnNpZ25pbmdLZXkucHVibGljS2V5KTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcclxuICAgIH1cclxuICAgIC8vIFN0b3JlIHByaXZhdGUgdmFsdWVzIGJlaGluZCBnZXR0ZXJzIHRvIHJlZHVjZSB2aXNpYmlsaXR5XHJcbiAgICAvLyBpbiBjb25zb2xlLmxvZ1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIFtbU2lnbmluZ0tleV1dIHVzZWQgZm9yIHNpZ25pbmcgcGF5bG9hZHMuXHJcbiAgICAgKi9cclxuICAgIGdldCBzaWduaW5nS2V5KCkgeyByZXR1cm4gdGhpcy4jc2lnbmluZ0tleTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIHByaXZhdGUga2V5IGZvciB0aGlzIHdhbGxldC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7IHJldHVybiB0aGlzLnNpZ25pbmdLZXkucHJpdmF0ZUtleTsgfVxyXG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIHRoaXMuYWRkcmVzczsgfVxyXG4gICAgY29ubmVjdChwcm92aWRlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmFzZVdhbGxldCh0aGlzLiNzaWduaW5nS2V5LCBwcm92aWRlcik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHgpIHtcclxuICAgICAgICB0eCA9IGNvcHlSZXF1ZXN0KHR4KTtcclxuICAgICAgICAvLyBSZXBsYWNlIGFueSBBZGRyZXNzYWJsZSBvciBFTlMgbmFtZSB3aXRoIGFuIGFkZHJlc3NcclxuICAgICAgICBjb25zdCB7IHRvLCBmcm9tIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XHJcbiAgICAgICAgICAgIHRvOiAodHgudG8gPyByZXNvbHZlQWRkcmVzcyh0eC50bywgdGhpcykgOiB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgICBmcm9tOiAodHguZnJvbSA/IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIHRoaXMpIDogdW5kZWZpbmVkKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0byAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHR4LnRvID0gdG87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZ2V0QWRkcmVzcygodHguZnJvbSkpID09PSB0aGlzLmFkZHJlc3MsIFwidHJhbnNhY3Rpb24gZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHguZnJvbVwiLCB0eC5mcm9tKTtcclxuICAgICAgICAgICAgZGVsZXRlIHR4LmZyb207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0cmFuc2FjdGlvblxyXG4gICAgICAgIGNvbnN0IGJ0eCA9IFRyYW5zYWN0aW9uLmZyb20odHgpO1xyXG4gICAgICAgIGJ0eC5zaWduYXR1cmUgPSB0aGlzLnNpZ25pbmdLZXkuc2lnbihidHgudW5zaWduZWRIYXNoKTtcclxuICAgICAgICByZXR1cm4gYnR4LnNlcmlhbGl6ZWQ7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbk1lc3NhZ2VTeW5jKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgLy8gQFRPRE86IEFkZCBhIHNlY2lhbGl6ZWQgc2lnblR4IGFuZCBzaWduVHlwZWQgc3luYyB0aGF0IGVuZm9yY2VzXHJcbiAgICAvLyBhbGwgcGFyYW1ldGVycyBhcmUga25vd24/XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBzaWduYXR1cmUgZm9yICUlbWVzc2FnZSUlIHNpZ25lZCB3aXRoIHRoaXMgd2FsbGV0LlxyXG4gICAgICovXHJcbiAgICBzaWduTWVzc2FnZVN5bmMobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25pbmdLZXkuc2lnbihoYXNoTWVzc2FnZShtZXNzYWdlKSkuc2VyaWFsaXplZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIEF1dGhvcml6YXRpb24gZm9yICUlYXV0aCUlLlxyXG4gICAgICovXHJcbiAgICBhdXRob3JpemVTeW5jKGF1dGgpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKGF1dGguYWRkcmVzcykgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBhZGRyZXNzIGZvciBhdXRob3JpemVTeW5jXCIsIFwiYXV0aC5hZGRyZXNzXCIsIGF1dGgpO1xyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuc2lnbmluZ0tleS5zaWduKGhhc2hBdXRob3JpemF0aW9uKGF1dGgpKTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwge1xyXG4gICAgICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGF1dGguYWRkcmVzcyksXHJcbiAgICAgICAgICAgIG5vbmNlOiBnZXRCaWdJbnQoYXV0aC5ub25jZSB8fCAwKSxcclxuICAgICAgICAgICAgY2hhaW5JZDogZ2V0QmlnSW50KGF1dGguY2hhaW5JZCB8fCAwKSxcclxuICAgICAgICB9LCB7IHNpZ25hdHVyZSB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBBdXRob3JpemF0aW9uIGZvciAlJWF1dGglJS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgYXV0aG9yaXplKGF1dGgpIHtcclxuICAgICAgICBhdXRoID0gT2JqZWN0LmFzc2lnbih7fSwgYXV0aCwge1xyXG4gICAgICAgICAgICBhZGRyZXNzOiBhd2FpdCByZXNvbHZlQWRkcmVzcyhhdXRoLmFkZHJlc3MsIHRoaXMpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aG9yaXplU3luYyhhd2FpdCB0aGlzLnBvcHVsYXRlQXV0aG9yaXphdGlvbihhdXRoKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XHJcbiAgICAgICAgLy8gUG9wdWxhdGUgYW55IEVOUyBuYW1lc1xyXG4gICAgICAgIGNvbnN0IHBvcHVsYXRlZCA9IGF3YWl0IFR5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBhc3luYyAobmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBAVE9ETzogdGhpcyBzaG91bGQgdXNlIHJlc29sdmVOYW1lOyBhZGRyZXNzZXMgZG9uJ3RcclxuICAgICAgICAgICAgLy8gICAgICAgIG5lZWQgYSBwcm92aWRlclxyXG4gICAgICAgICAgICBhc3NlcnQodGhpcy5wcm92aWRlciAhPSBudWxsLCBcImNhbm5vdCByZXNvbHZlIEVOUyBuYW1lcyB3aXRob3V0IGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIsXHJcbiAgICAgICAgICAgICAgICBpbmZvOiB7IG5hbWUgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGFzc2VydChhZGRyZXNzICE9IG51bGwsIFwidW5jb25maWd1cmVkIEVOUyBuYW1lXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25pbmdLZXkuc2lnbihUeXBlZERhdGFFbmNvZGVyLmhhc2gocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpLnNlcmlhbGl6ZWQ7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS13YWxsZXQuanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuY29uc3Qgc3Vic0NocnMgPSBcIiAhIyQlJicoKSorLC0uLzw9Pj9AW11eX2B7fH1+XCI7XHJcbmNvbnN0IFdvcmQgPSAvXlthLXpdKiQvaTtcclxuZnVuY3Rpb24gdW5mb2xkKHdvcmRzLCBzZXApIHtcclxuICAgIGxldCBpbml0aWFsID0gOTc7XHJcbiAgICByZXR1cm4gd29yZHMucmVkdWNlKChhY2N1bSwgd29yZCkgPT4ge1xyXG4gICAgICAgIGlmICh3b3JkID09PSBzZXApIHtcclxuICAgICAgICAgICAgaW5pdGlhbCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3b3JkLm1hdGNoKFdvcmQpKSB7XHJcbiAgICAgICAgICAgIGFjY3VtLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpbml0aWFsKSArIHdvcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5pdGlhbCA9IDk3O1xyXG4gICAgICAgICAgICBhY2N1bS5wdXNoKHdvcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICB9LCBbXSk7XHJcbn1cclxuLyoqXHJcbiAqICBAX2lnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBzdWJzKSB7XHJcbiAgICAvLyBSZXBsYWNlIGFsbCB0aGUgc3Vic3RpdHV0aW9ucyB3aXRoIHRoZWlyIGV4cGFuZGVkIGZvcm1cclxuICAgIGZvciAobGV0IGkgPSBzdWJzQ2hycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KHN1YnNDaHJzW2ldKS5qb2luKHN1YnMuc3Vic3RyaW5nKDIgKiBpLCAyICogaSArIDIpKTtcclxuICAgIH1cclxuICAgIC8vIEdldCBhbGwgdGxlIGNsdW1wczsgZWFjaCBzdWZmaXgsIGZpcnN0LWluY3JlbWVudCBhbmQgc2Vjb25kLWluY3JlbWVudFxyXG4gICAgY29uc3QgY2x1bXBzID0gW107XHJcbiAgICBjb25zdCBsZWZ0b3ZlciA9IGRhdGEucmVwbGFjZSgvKDp8KFswLTldKXwoW0EtWl1bYS16XSopKS9nLCAoYWxsLCBpdGVtLCBzZW1pLCB3b3JkKSA9PiB7XHJcbiAgICAgICAgaWYgKHNlbWkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlSW50KHNlbWkpOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY2x1bXBzLnB1c2goXCI7XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjbHVtcHMucHVzaChpdGVtLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH0pO1xyXG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXHJcbiAgICBpZiAobGVmdG92ZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGxlZnRvdmVyczogJHtKU09OLnN0cmluZ2lmeShsZWZ0b3Zlcil9YCk7XHJcbiAgICB9XHJcbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xyXG4gICAgcmV0dXJuIHVuZm9sZCh1bmZvbGQoY2x1bXBzLCBcIjtcIiksIFwiOlwiKTtcclxufVxyXG4vKipcclxuICogIEBfaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlT3dsKGRhdGEpIHtcclxuICAgIGFzc2VydEFyZ3VtZW50KGRhdGFbMF0gPT09IFwiMFwiLCBcInVuc3VwcG9ydGVkIGF1d2wgZGF0YVwiLCBcImRhdGFcIiwgZGF0YSk7XHJcbiAgICByZXR1cm4gZGVjb2RlKGRhdGEuc3Vic3RyaW5nKDEgKyAyICogc3Vic0NocnMubGVuZ3RoKSwgZGF0YS5zdWJzdHJpbmcoMSwgMSArIDIgKiBzdWJzQ2hycy5sZW5ndGgpKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvZGUtb3dsLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuLyoqXHJcbiAqICBBIFdvcmRsaXN0IHJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIGxhbmd1YWdlLXNwZWNpZmljXHJcbiAqICB3b3JkcyB1c2VkIHRvIGVuY29kZSBhbmQgZGV2b2NlIFtbbGluay1iaXAtMzldXSBlbmNvZGVkIGRhdGFcclxuICogIGJ5IG1hcHBpbmcgd29yZHMgdG8gMTEtYml0IHZhbHVlcyBhbmQgdmljZSB2ZXJzYS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXb3JkbGlzdCB7XHJcbiAgICBsb2NhbGU7XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IFdvcmRsaXN0IGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqICBTdWItY2xhc3NlcyBNVVNUIGNhbGwgdGhpcyBpZiB0aGV5IHByb3ZpZGUgdGhlaXIgb3duIGNvbnN0cnVjdG9yLFxyXG4gICAgICogIHBhc3NpbmcgaW4gdGhlIGxvY2FsZSBzdHJpbmcgb2YgdGhlIGxhbmd1YWdlLlxyXG4gICAgICpcclxuICAgICAqICBHZW5lcmFsbHkgdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGEgV29yZGxpc3QsXHJcbiAgICAgKiAgc2luY2UgZWFjaCBsYW5ndWFnZS1zcGVjaWZpYyBXb3JkbGlzdCBjcmVhdGVzIGFuIGluc3RhbmNlIGFuZFxyXG4gICAgICogIHRoZXJlIGlzIG5vIHN0YXRlIGtlcHQgaW50ZXJuYWxseSwgc28gdGhleSBhcmUgc2FmZSB0byBzaGFyZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobG9jYWxlKSB7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGxvY2FsZSB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIHByb3ZpZGUgYSBsYW5ndWFnZS1zcGVjaWZpY1xyXG4gICAgICogIG1ldGhvZCBmb3Igc3BsaXRpbmcgJSVwaHJhc2UlJSBpbnRvIGluZGl2aWR1YWwgd29yZHMuXHJcbiAgICAgKlxyXG4gICAgICogIEJ5IGRlZmF1bHQsICUlcGhyYXNlJSUgaXMgc3BsaXQgdXNpbmcgYW55IHNlcXVlbmNlcyBvZlxyXG4gICAgICogIHdoaXRlLXNwYWNlIGFzIGRlZmluZWQgYnkgcmVndWxhciBleHByZXNzaW9ucyAoaS5lLiBgYC9cXHMrL2BgKS5cclxuICAgICAqL1xyXG4gICAgc3BsaXQocGhyYXNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHBocmFzZS50b0xvd2VyQ2FzZSgpLnNwbGl0KC9cXHMrL2cpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gcHJvdmlkZXIgYSBsYW5ndWFnZS1zcGVjaWZpY1xyXG4gICAgICogIG1ldGhvZCBmb3Igam9pbmluZyAlJXdvcmRzJSUgaW50byBhIHBocmFzZS5cclxuICAgICAqXHJcbiAgICAgKiAgQnkgZGVmYXVsdCwgJSV3b3JkcyUlIGFyZSBqb2luZWQgYnkgYSBzaW5nbGUgc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIGpvaW4od29yZHMpIHtcclxuICAgICAgICByZXR1cm4gd29yZHMuam9pbihcIiBcIik7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29yZGxpc3QuanMubWFwIiwiLy8gVXNlIHRoZSBlbmNvZGUtbGF0aW4uanMgc2NyaXB0IHRvIGNyZWF0ZSB0aGUgbmVjZXNzYXJ5XHJcbi8vIGRhdGEgZmlsZXMgdG8gYmUgY29uc3VtZWQgYnkgdGhpcyBjbGFzc1xyXG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGRlY29kZU93bCB9IGZyb20gXCIuL2RlY29kZS1vd2wuanNcIjtcclxuaW1wb3J0IHsgV29yZGxpc3QgfSBmcm9tIFwiLi93b3JkbGlzdC5qc1wiO1xyXG4vKipcclxuICogIEFuIE9XTCBmb3JtYXQgV29yZGxpc3QgaXMgYW4gZW5jb2RpbmcgbWV0aG9kIHRoYXQgZXhwbG9pdHNcclxuICogIHRoZSBnZW5lcmFsIGxvY2FsaXR5IG9mIGFscGhhYmV0aWNhbGx5IHNvcnRlZCB3b3JkcyB0b1xyXG4gKiAgYWNoaWV2ZSBhIHNpbXBsZSBidXQgZWZmZWN0aXZlIG1lYW5zIG9mIGNvbXByZXNzaW9uLlxyXG4gKlxyXG4gKiAgVGhpcyBjbGFzcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCB0byBtb3N0IGRldmVsb3BlcnMgYXNcclxuICogIGl0IGlzIHVzZWQgbWFpbmx5IGludGVybmFsbHkgdG8ga2VlcCBXb3JkbGlzdHMgZm9yIGxhbmd1YWdlc1xyXG4gKiAgYmFzZWQgb24gQVNDSUktNyBzbWFsbC5cclxuICpcclxuICogIElmIG5lY2Vzc2FyeSwgdGhlcmUgYXJlIHRvb2xzIHdpdGhpbiB0aGUgYGBnZW5lcmF0aW9uL2BgIGZvbGRlclxyXG4gKiAgdG8gY3JlYXRlIHRoZSBuZWNlc3NhcnkgZGF0YS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXb3JkbGlzdE93bCBleHRlbmRzIFdvcmRsaXN0IHtcclxuICAgICNkYXRhO1xyXG4gICAgI2NoZWNrc3VtO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBXb3JkbGlzdCBmb3IgJSVsb2NhbGUlJSB1c2luZyB0aGUgT1dMICUlZGF0YSUlXHJcbiAgICAgKiAgYW5kIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSAlJWNoZWNrc3VtJSUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSwgZGF0YSwgY2hlY2tzdW0pIHtcclxuICAgICAgICBzdXBlcihsb2NhbGUpO1xyXG4gICAgICAgIHRoaXMuI2RhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuI2NoZWNrc3VtID0gY2hlY2tzdW07XHJcbiAgICAgICAgdGhpcy4jd29yZHMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIE9XTC1lbmNvZGVkIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGdldCBfZGF0YSgpIHsgcmV0dXJuIHRoaXMuI2RhdGE7IH1cclxuICAgIC8qKlxyXG4gICAgICogIERlY29kZSBhbGwgdGhlIHdvcmRzIGZvciB0aGUgd29yZGxpc3QuXHJcbiAgICAgKi9cclxuICAgIF9kZWNvZGVXb3JkcygpIHtcclxuICAgICAgICByZXR1cm4gZGVjb2RlT3dsKHRoaXMuI2RhdGEpO1xyXG4gICAgfVxyXG4gICAgI3dvcmRzO1xyXG4gICAgI2xvYWRXb3JkcygpIHtcclxuICAgICAgICBpZiAodGhpcy4jd29yZHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IHRoaXMuX2RlY29kZVdvcmRzKCk7XHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgY29tcHV0ZWQgbGlzdCBtYXRjaGVzIHRoZSBvZmZpY2lhbCBsaXN0XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gaWQod29yZHMuam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xyXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cclxuICAgICAgICAgICAgaWYgKGNoZWNrc3VtICE9PSB0aGlzLiNjaGVja3N1bSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCSVAzOSBXb3JkbGlzdCBmb3IgJHt0aGlzLmxvY2FsZX0gRkFJTEVEYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cclxuICAgICAgICAgICAgdGhpcy4jd29yZHMgPSB3b3JkcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dvcmRzO1xyXG4gICAgfVxyXG4gICAgZ2V0V29yZChpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IHdvcmRzID0gdGhpcy4jbG9hZFdvcmRzKCk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCAmJiBpbmRleCA8IHdvcmRzLmxlbmd0aCwgYGludmFsaWQgd29yZCBpbmRleDogJHtpbmRleH1gLCBcImluZGV4XCIsIGluZGV4KTtcclxuICAgICAgICByZXR1cm4gd29yZHNbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgZ2V0V29yZEluZGV4KHdvcmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jbG9hZFdvcmRzKCkuaW5kZXhPZih3b3JkKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdC1vd2wuanMubWFwIiwiaW1wb3J0IHsgV29yZGxpc3RPd2wgfSBmcm9tIFwiLi93b3JkbGlzdC1vd2wuanNcIjtcclxuY29uc3Qgd29yZHMgPSBcIjBlcmxlb25hbG9yZW5zZWluY2VyZWdlc3RpY2l0U3RhbnZldGVhcmN0c3NpI2NoMkF0aGNrJnRuZUxsMEFuZCNJbC55TGVPdXRPPVN8UyViL3JhQFN1cmRVJzBDZVtDaWR8Q291bnRDdSdIaWU9SWRPdSwtUXVpKlJvW1RUXVQlVCpbVHUkMEFwdERELXREKltKdSxNLlVsdFY8KVZpKTBSb2ItMEZhaXJGJWRSYWlkMEEoRUVudFJlZTBFYWQwTVJScCV0UyFfcm1CdW1Db2hvbEVydEkmTExleUxvd01vLE99UGhhUmVhZHlTb1QgV2F5czBBPnVyQXooZ09uZ091bnRVJ2QwQWx5LENoJUNpfEcgRyFHcnlJbSRLIU5vdW4pTnUkT2AgU3cgVCZuYVRpcXVlWGlldHlZMUFydE9sb2d5UGU/UCFQcm89UmlsMUNoQ3QtRWFFbmFHdWVNTWVkTSVNeU91bmRSPCtSZSxSaT1Sb3dUVGVmYUBUaSxUdyVrMEtQZUBTYXVsdFNldFNpLFN1bWVUaG1hMEghPk9tVGF7VCZkVC51ZGVUcmFAMEN0XUQuR3UsTnRUaCVUb1R1bW4wRXJhK09jYWRvT2lkMEFrZUEqQXlFc29tZUZ1bEt3P2QwSXM6QnlDaGVsJUMjRCtHTDwpTGMjeX5NYm9vTjxhTm4gUlJlbHlSZ2EoUipsU2VTLVNrZXRUdCEzQV5BbkF1dHlDYXUnQ29tZUVmRiVlRyhIYT1IKGRMaWU9TG93THROXk5lZi4vVHJheVR0IFR3ZSZZI2QzQ3ljIURLZU5kT2xvZ3lSZFJgVHQgX3tBZGVBbWVBbmtldEEsRWFrRVtJbmRPb2RPW29tT3UnVWVVclVzaF9yZEF0RHlJbE1iTmVOdXNPa08sUmQgUihnUnJvd1NzVHRvbVVuKVhZX3tldEEoQW5kQVtBPUVhZEVlemVJe0lkK0llZklnaHRJbmdJc2tPY2NvbGlPayZPbnplT29tT2AgT3duVXNoMkJiIURkeUQrdEZmJG9JbGRMYkxrTCF0TmQhTmsgUmQmUmcgUixTUyhlW1N5VHQgWSBaejpCYmErQihCIUN0dXNHZUtlfkxtTSBhTXBOTiROKWxOZHlObiNOb2VOdmFzTnkjUGFiIVAuJFB0YShSUmIjUmRSZ29ScGV0UnJ5UnRTZVNoUyhvLyFTdSRUVCRvZ1ReVGVnJXlUdCFVZ2h0VSdVdF1WZTNJbChnTCB5TXxOc3VzTnR1cnlSZSRSdGEoX2lyQWxrQW1wXUFuK0Fvc0FwdCBBcitBJ0F0RWFwRXtFZSdFZkVycnlFLEl7JkllZklsZEltfXlPaSlPbydSIy1VeyFVbmtVcm4wRz9ObmFtI1JjIVRpeiZUeVZpbF9pbUFwQXJpZnlBd0F5RTxFcmtFdiBJe0l8SWZmSW1iSW4tSXBPe09nTydPYE91ZE93blViVW1wVSwgVXReX15BLEMjdXREZUZmZWVJbEluTCFATCVMdW1uTWIoZU1lTWYldE0tTW0jTXA8eU5jIHROZHVATmZpcm1OZypbTn1ATnNpZCBOdHJvbE52KClPa09sUHAgUHlSJFJlUm5SKkAvVHQjVV5VbnRyeVVwIVVyJ1VzKFYgWW8+X3tBZCFBZnRBbUF9QXNoQXQgQXdsQXp5RWFtRWQuRWVrRXdJe2V0SW1lSXNwSXQtT3BPW091Xk93ZFVjaSRVZWxVaSdVbWIhVW5eVXNoWVksJDJCZUx0dSpQUGJvP2RSaW91c1JyfFJ0YShSPVNoXS9vbVRlM0MhOkRNYStNcE4pTmcgUihnU2hVZ2h0IFduWTNBbEJhPkJyaXNDYWRlQ2VtYiBDaWRlQ2woZUMlYT5DKmEnRXJGJidGKGVGeUcqZUxheUxpdiBNPGRNaSdOaSROdGksTnlQP3RQJmRQb3MuUGBQdXR5Umk9U2NyaWJlUyB0U2lnblNrU3BhaXIvcm95VGFpbFRlQFZlbG9wVmkpVm8+M0FncmFtQWxBbSNkQXJ5Q2VFJ2xFdEZmIEcuJEduLnlMZW1tYU5uIE5vc2F1clJlQFJ0U2FnKmVTY292IFNlYSdTaFNtaVtTJWQgU3BsYXkvPClWIHRWaWRlViUpWnp5NUN0JUN1bXxHfkxwaChNYShOYT5Oa2V5TiVPclNlVWIhVmVfZnRBZyNBbWFBLC1Bd0VhbUVbSWZ0SWxsSW5rSXBJPU9wVW1ZMkNrTWJOZVIoZy9UXlR5MUFyZjFOYW0tOkcgRyFSbHlSblJgU2lseS9TeTFIb09sb2d5T25vbXkwR2VJdFVjYT4xRiV0MEcxR2h0VGggMkJvd0QgRUByLUVnPHRFbXxFcGg8dEV2YXQlST5TZTBCP2tCb2R5QnJhKUVyK090XVBsb3lQb3cgUHR5MEFiIUFAREQhW0QlJ0VteUVyZ3lGJSlHYStHKGVIPClKb3lMaSxPdWdoUi1oUm9sbFN1KlQgVGkqVHJ5VmVsb3BlMUlzb2RlMFUkVWlwMEFBJ09kZU9zXVIlVXB0MENhcGVTYXlTJilUYT4wRXJuJEgtczFJZCYpSWxPa2VPbD0xQUBBbXAhQ2VbQ2g8K0MuZUNsdWRlQ3UnRWN1PkVyY2knSGF1LEhpYi5JIUksSXRPdC1QPGRQZUBQaSpQbGEoUG8nUCpbVCZkVHJhMEVFYnJvdzpCci1DZUN1bHR5RGVJbnRJYH5MJ01lTWlseU1vdXNOTmN5TnRhc3lSbVNoXVRUJFRoIFRpZ3VlVWx0ViUuZTNBdHUqQnJ1P3lEICRFRWRFbE1hIU4pL2l2JFReViBXM0IgQ3RdRWxkR3UqTGVMbUx0IE4kTmROZU5nIE5pc2hSZVJtUixTYyRTaFRUfVtYX2dBbWVBc2hBdEF2JUVlSWdodElwT2F0T3tPJU93IFVpZFVzaFlfbUN1c0dJbExkfm93T2RPdFIpUmUsUit0UmtSdHV9UnVtUnc/ZFNzaWwvIFVuZFhfZ2khQW1lRXF1fEVzaEkmZEluK09nT250TyxPd25PeiZVLjJFbE5ObnlSbmEpUnlUdSo6RCt0SW5MYXh5fiB5TWVQUmErUmJhK1JkJlJsLVJtfFNTcFRlVGggVStaZTNOICROaXVzTipOdCFOdShlL3UqMk8sMEFudEZ0R2chTmcgUmFmZmVSbFZlX2RBbilBKkFbSWRlSW1wJ09iZU9vbU9yeU89T3dVZV90RGRlW0xkT2RPJ1JpbGxhU3BlbFNzaXBWIG5Xbl9iQSlBKEFudEFwZUFbQXYueUVhdEUmSWRJZWZJdE9jIHlPdXBPd1VudF9yZEVbSWRlSWx0SXQ/TjNNOkIuSXJMZk1tIE0sIE5kUHB5UmIlUmRSc2hSPSxUVmVXa1o/ZDNBZEFsYEFydEF2eUQraG9nSWdodH5vTG1ldExwTlJvM0RkJkdofk50UFJlLyV5NUJieUNrZXlMZExlTGlkYXl+b3dNZU5leU9kUGVSblJyJVInU3AuJC9UZWxVclYgNUJHZU08TWIhTSVOZCpkTmdyeU50UmQhUnJ5UnRTYjxkM0JyaWQ6MUVPbjBFYUVudGlmeUxlMk4lZTRMTGVnJEx9WzBBK0l0YT5NJidNdX1QYUBQbydQcm89UHVsJzBDaENsdWRlQ29tZUMqYSdEZXhELWE+RG8lRHUscnlGPHRGbC10RiVtSGEhSCAuSXRpJEplQEp1cnlNYT5OIE5vY3xQdXRRdWlyeVM8ZVNlQFNpZGVTcGkqLyRsVGFAVCBlLFRvVmUsVi5lVm9sPTNPbjBMPGRPbGE+U3VlMEVtMU9yeTpDa2V0R3U/Ulp6M0Fsb3VzQW5zfnlXZWw5QkluS2VVcn15WTVEK0kpTXBOZyFOaSVOay86Tmc/b28zRW5FcFRedXBZM0NrRER9eU5kTmdkb21Tc1RUXiZUZVR0JldpNEVlSWZlT3tPdzpCQmVsQiVEZCBEeUtlTXBOZ3VhK1B0b3BSK1QgVChVZ2hVbmRyeVZhV1duV3N1LlkgWnkzQWQgQWZBcm5BPUN0dSpGdEdHJEcmZElzdSpNI05kTmdgTnNPcD9kU3MjVHQgVmVsM0FyQiB0eUJyP3lDJidGZUZ0R2h0S2VNYk0uTmtPblF1aWQvVHQhVmVaP2Q1QWRBbkIsIEMkQ2tHLU5lbHlOZ09wVHQgeVVkVW4rVmVZJDVDa3lHZ2ErTWIgTj9OXlh1cnkzUi1zOkNoKGVERy1HfXRJZElsSW5KJUtlTW0kTk5hK05kYT5OZ29Oc11OdSRQIVJiIVJeUmcoUihlUmtldFJyaWErU2tTcy8gVF5UIGkkVGhUcml4VHQgWGltdW1aZTNBZG93QW5Bc3UqQXRDaDwtRCREaWFMb2R5THRNYiBNJXlOdF1OdVJjeVIrUi5ScnlTaFNzYStUJFRob2QzRGQhRG5pZ2h0TGt+XU0tTmROaW11bU4lTnU+UmFjIVJyJVMgeVNzL2FrZVhYZWRYdHUqNUJpIURlbERpZnlNTXxOLiVOa2V5TiwgTmBPblIkUmVSbihnU3F1Lm9UaCBUXVQlVW50YShVJ1ZlVmllNUNoRmYoTGVMdGlwbHlTYyFTZXVtU2hyb29tUy0vVHUkM1NlbGYvIHlUaDpJPU1lUGsoUnJvdy95VF1UdSozQXJDa0VkR2F0aT1HIUBJYCBQaGV3Uj0vVFR3JWtVdHIkViBXc1h0M0NlR2h0NUIhSSdNKGVlT2QhUm0kUmBTZVRhYiFUZVRoKGdUaSlWZWxXNUMhP01iIFInVDpLMEV5SmVATGkrU2N1KlMgPVRhKFZpb3VzMEN1ckU8VG9iIDBPcjFGRiBGaSlUJjJMMUF5MERJPVltcC0wSXQwQ2VFSSNMKGVMeTFFbkVyYUluXVBvJ1RdMUFuK0IuQ2g/ZEQgRCg/eUc8SXxJZygkUGg8MFRyLWgwSCAwVGRvJVQgVHB1dFRzaWRlMEFsRW5FcjBOTiAwWWcmMC8gME99OkN0RGQhR2VJckxhKUxtTmRhTmVsTi1OYCBQIFJhZGVSfFJrUnJvdFJ0eVNzVF5UaFRpfFRyb2xUdCBuVSdWZVltfDNBKUFudXRBckFzPHRMLTxOTiR0eU5jaWxPcCFQcCBSZmVAUm0uUnMjVDJPfU90b1JhJ1lzLSQwQW5vQ24tQ3R1KkUpR0dlI35Mb3ROa099IFBlL29sVF5aemFfKUF9dEEsLUE+QXlFYSdFZCtVe1VnVW4rMkVtRXRJbnRMP0xlTGkpTmROeU9sUHVsP1J0XVMuXVNzaWIhL1RhdG9UdCB5ViB0eVdkIFcgX0BpKUFpJ0VkLXRFZiBFcGEqRXN8RXR0eUV2fEkpSWRlSW0/eUludEklLnlJcyNJdmE+SXplT2IhbU8pW09kdSlPZi5PZ3JhbU9qZUBPbW8+T29mT3AgdHlPc3AgTz5AT3VkT3ZpZGUyQmwtRGQoZ35McEwnTXBrKE5eUGlsUHB5Ul5hJ1IueVJwbydSJ1NoVFp6ITNSYW1pZDo5OUFsLnlBbnR1bUFydCBFLF1Je0l0SXpPPjpCYi5DY28jQ2VDa0Q/RGlvSWxJbkknfnlNcE5eTmRvbU4rUGlkUmVUZVRoIFYmV1olM0FkeUFsQXMjQmVsQnVpbGRDJGxDZWk9Q2lwZUMlZEN5YyFEdSlGIUBGJW1GdSdHXUcqdEd1bD9KZUBMYXhMZWEnTGllZkx5TWEoTWVtYiBNKGRNbz1OZCBOZXdOdE9wJlBhaXJQZWF0UGxhKVAldFF1aSpTY3VlU2VtYiFTaSxTb3VyKVNwIydTdWx0VGkqVCphdFR1cm5Vbl1WZSRWaWV3Vz9kMllgbTBCQmIjQ2VDaERlRCtGIUdodEdpZE5nT3RQcCFTa1R1JFYkViA1QWRBLEJvdEJ1LENrZXRNPClPZk9raWVPbVNlVGE+VWdoVW5kVT5ZJDVCYiBEZUdMZU5Od2F5UiQ6RERkIUR9W0ZlSWxMYWRMbSNMI0x0THU+TWVNcCFOZFRpc2Z5VG9zaGlVKVVzYStWZVkxQSFBbkEqQXR0IEV9SGVtZUhvb2xJJilJWyVzT3JwXU91dFJhcFJlJlJpcHRSdWIxQUFyXkFzI0F0QyNkQyp0Q3RdQ3VyLnlFZEVrR218TGVAfk0oP05pJU4nTnQmKVJpZXNSdmkpU3NdVHQhVHVwViZfZG93QWZ0QWxsb3dBKkVkRWxsRXJpZmZJZWxkSWZ0SX1JcEl2IE97T2VPb3RPcE9ydE91bGQgTz1SaW1wUnVnVWZmIVkwQmwoZ0NrRGVFK0dodEduTHxMa355THYgTWlsP01wIU4pTmdSJi8gVHVhPlhaZTFBPkV0XklJbGxJbklydFVsbDBBYkFtRWVwRW5kIEkpSWRlSWdodEltT2c8T3RPd1VzaDBBbGxBcnRJIU9rZU9vYDBBe0FrZUFwSWZmT3cwQXBDYyBDaSRDa0RhRnRMP0xkaSBMaWRMdXRdTD1NZSNlTmdPblJyeVJ0VWxVbmRVcFVyKVVgMEEpQSpBdGkkQXduRWFrRWNpJEVlZEVsbEVuZEggZUkpSWQgSWtlSW5Jci5MLk9pbE9ucyVPI09ydE90UmF5UmVhZFIoZ1kwVWEqVWVlemVVaXIqbF9iIUFkaXVtQWZmQStBaXJzQW1wQW5kQXJ0QT5BeUVha0VlbEVtRXBFKm9Je0lsbEluZ097T21hXk99T29sT3J5Tz1SYT5neVJlZXRSaWtlUiNnUnVnZyFVZHxVZmZVbWIhWSEwQmplQEJtLkJ3YXlDKVtDaERkJkZmIEc/RyssSXRNbSBOTm55Tid0UCBQcGx5UCptZVJlUmZhKVIrUnByaSdScm91bmRSPXlTcGVAL2EoMUFsbG93QW1wQXBBcm1FP0VldElmdEltSW5nSXReT3JkMU1ib2xNcHRvbVJ1cC9lbTpCIUNrIUdJbEx8TGtOa1BlUit0U2svZVR0b29YaTNBXkFtfk5OPHRObmlzTnRSbS9YdF9ua0F0RW1lRW5FJXlFKkV5SW5nSXNPdWdodFJlZVJpPVJvd1VtYlVuZCAwQ2tldERlRyBMdE1iIE1lTnlQUmVkU3N1ZVQhNUEsQmFjY29EYXlEZGwgRUdlYCBJIXRLJk1hdG9NJXJvd05lTmd1ZU5pZ2h0T2xPYFBQLVBwIVJeUm5hZG9SdG9pJ1NzVCRVcmksVz9kVyBXbllfe0FkZUFmZi1BZy1BKEFuc2YgQXBBc2hBPWxBeUVhdEVlRW5kSSRJYmVJe0lnZyBJbUlwT3BoeU91YiFVe1VlVWx5VW1wZXRVLFVgWTJCZUl0XU1iIU5hTn1sUmtleVJuUnQhMUVsPUVudHlJKUluSSxPMVBlUC0kOjVMeTVCKmxsYTBBYiFBd2EqQyFDb3YgRCBEb0ZhaXJGb2xkSGFwcHlJZiVtSXF1ZUl0SXYgJ0tub3duTG97VGlsVXN1JFZlaWwxRGE+R3JhZGVIb2xkT25QIFNldDFCPEdlMEErRUVkRWZ1bEUhW1UkMElsLnk6Qzx0Q3V1bUd1ZUxpZEwheUw9Tk5pc2hQJVJpb3VzL1VsdDNILSFMPXROZCVOdHUqTnVlUmJSaWZ5UnNdUnlTJ2xUIDwzQWIhQnI8dENpb3VzQ3QleURlb0V3fmErTnRhK09sKFJ0dSRSdXNTYVMuU3UkVCRWaWQ1QyRJKUlkTGM8b0x1bWVUZVlhKzpHZUcjSXRMa35MbnV0TnRSZmEqUm1ScmklU2hTcC9lVCBWZVkzQWxgQXAjQXJBJ2xBYCBCRGQoZ0VrJmRJcmRMY29tZS9UXyFBdEVhdEVlbEVuRSpJcElzcCAwRGVEYEZlTGR+Tk5kb3dOZU5nTmtObiBOdCBSZVNkb21TZVNoVH1bNUxmTTxOZCBPZE9sUmRSa1JsZFJyeVJgX3BFe0UsIUksST5Pbmc6OlJkM0Fyfm93OVVVbmdVYDozQnJhUm85TmVPXCI7XHJcbmNvbnN0IGNoZWNrc3VtID0gXCIweDNjOGFjYzFlN2IwOGQ4ZTc2ZjlmZGEwMTVlZjQ4ZGM4YzcxMGE3M2NiN2UwZjc3YjJjMThhOWI1YTdhZGRlNjBcIjtcclxubGV0IHdvcmRsaXN0ID0gbnVsbDtcclxuLyoqXHJcbiAqICBUaGUgW1tsaW5rLWJpcDM5LWVuXV0gZm9yIFttbmVtb25pYyBwaHJhc2VzXShsaW5rLWJpcC0zOSkuXHJcbiAqXHJcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExhbmdFbiBleHRlbmRzIFdvcmRsaXN0T3dsIHtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEVuZ2xpc2ggbGFuZ3VhZ2UgV29yZGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgc2hvdWxkIGJlIHVubmVjZXNzYXJ5IG1vc3Qgb2YgdGhlIHRpbWUgYXMgdGhlIGV4cG9ydGVkXHJcbiAgICAgKiAgW1tsYW5nRW5dXSBzaG91bGQgc3VmZmljZS5cclxuICAgICAqXHJcbiAgICAgKiAgQF9pZ25vcmU6XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcImVuXCIsIHdvcmRzLCBjaGVja3N1bSk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdFbmBgLCBjcmVhdGluZyBpdFxyXG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgd29yZGxpc3QoKSB7XHJcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgd29yZGxpc3QgPSBuZXcgTGFuZ0VuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWVuLmpzLm1hcCIsImltcG9ydCB7IHBia2RmMiwgc2hhMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCeXRlcywgaGV4bGlmeSwgYXNzZXJ0Tm9ybWFsaXplLCBhc3NlcnRQcml2YXRlLCBhc3NlcnRBcmd1bWVudCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgTGFuZ0VuIH0gZnJvbSBcIi4uL3dvcmRsaXN0cy9sYW5nLWVuLmpzXCI7XHJcbi8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIE1TQiBiaXRzIHNldFxyXG5mdW5jdGlvbiBnZXRVcHBlck1hc2soYml0cykge1xyXG4gICAgcmV0dXJuICgoMSA8PCBiaXRzKSAtIDEpIDw8ICg4IC0gYml0cykgJiAweGZmO1xyXG59XHJcbi8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIExTQiBiaXRzIHNldFxyXG5mdW5jdGlvbiBnZXRMb3dlck1hc2soYml0cykge1xyXG4gICAgcmV0dXJuICgoMSA8PCBiaXRzKSAtIDEpICYgMHhmZjtcclxufVxyXG5mdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpIHtcclxuICAgIGFzc2VydE5vcm1hbGl6ZShcIk5GS0RcIik7XHJcbiAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xyXG4gICAgICAgIHdvcmRsaXN0ID0gTGFuZ0VuLndvcmRsaXN0KCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3b3JkcyA9IHdvcmRsaXN0LnNwbGl0KG1uZW1vbmljKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KCh3b3Jkcy5sZW5ndGggJSAzKSA9PT0gMCAmJiB3b3Jkcy5sZW5ndGggPj0gMTIgJiYgd29yZHMubGVuZ3RoIDw9IDI0LCBcImludmFsaWQgbW5lbW9uaWMgbGVuZ3RoXCIsIFwibW5lbW9uaWNcIiwgXCJbIFJFREFDVEVEIF1cIik7XHJcbiAgICBjb25zdCBlbnRyb3B5ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKDExICogd29yZHMubGVuZ3RoIC8gOCkpO1xyXG4gICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gd29yZGxpc3QuZ2V0V29yZEluZGV4KHdvcmRzW2ldLm5vcm1hbGl6ZShcIk5GS0RcIikpO1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAsIGBpbnZhbGlkIG1uZW1vbmljIHdvcmQgYXQgaW5kZXggJHtpfWAsIFwibW5lbW9uaWNcIiwgXCJbIFJFREFDVEVEIF1cIik7XHJcbiAgICAgICAgZm9yIChsZXQgYml0ID0gMDsgYml0IDwgMTE7IGJpdCsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAmICgxIDw8ICgxMCAtIGJpdCkpKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyb3B5W29mZnNldCA+PiAzXSB8PSAoMSA8PCAoNyAtIChvZmZzZXQgJSA4KSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9mZnNldCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGVudHJvcHlCaXRzID0gMzIgKiB3b3Jkcy5sZW5ndGggLyAzO1xyXG4gICAgY29uc3QgY2hlY2tzdW1CaXRzID0gd29yZHMubGVuZ3RoIC8gMztcclxuICAgIGNvbnN0IGNoZWNrc3VtTWFzayA9IGdldFVwcGVyTWFzayhjaGVja3N1bUJpdHMpO1xyXG4gICAgY29uc3QgY2hlY2tzdW0gPSBnZXRCeXRlcyhzaGEyNTYoZW50cm9weS5zbGljZSgwLCBlbnRyb3B5Qml0cyAvIDgpKSlbMF0gJiBjaGVja3N1bU1hc2s7XHJcbiAgICBhc3NlcnRBcmd1bWVudChjaGVja3N1bSA9PT0gKGVudHJvcHlbZW50cm9weS5sZW5ndGggLSAxXSAmIGNoZWNrc3VtTWFzayksIFwiaW52YWxpZCBtbmVtb25pYyBjaGVja3N1bVwiLCBcIm1uZW1vbmljXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xyXG4gICAgcmV0dXJuIGhleGxpZnkoZW50cm9weS5zbGljZSgwLCBlbnRyb3B5Qml0cyAvIDgpKTtcclxufVxyXG5mdW5jdGlvbiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCkge1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoKGVudHJvcHkubGVuZ3RoICUgNCkgPT09IDAgJiYgZW50cm9weS5sZW5ndGggPj0gMTYgJiYgZW50cm9weS5sZW5ndGggPD0gMzIsIFwiaW52YWxpZCBlbnRyb3B5IHNpemVcIiwgXCJlbnRyb3B5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xyXG4gICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcclxuICAgICAgICB3b3JkbGlzdCA9IExhbmdFbi53b3JkbGlzdCgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5kaWNlcyA9IFswXTtcclxuICAgIGxldCByZW1haW5pbmdCaXRzID0gMTE7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJvcHkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyBDb25zdW1lIHRoZSB3aG9sZSBieXRlICh3aXRoIHN0aWxsIG1vcmUgdG8gZ28pXHJcbiAgICAgICAgaWYgKHJlbWFpbmluZ0JpdHMgPiA4KSB7XHJcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gODtcclxuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IGVudHJvcHlbaV07XHJcbiAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgLT0gODtcclxuICAgICAgICAgICAgLy8gVGhpcyBieXRlIHdpbGwgY29tcGxldGUgYW4gMTEtYml0IGluZGV4XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IHJlbWFpbmluZ0JpdHM7XHJcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSBlbnRyb3B5W2ldID4+ICg4IC0gcmVtYWluaW5nQml0cyk7XHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IHdvcmRcclxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGVudHJvcHlbaV0gJiBnZXRMb3dlck1hc2soOCAtIHJlbWFpbmluZ0JpdHMpKTtcclxuICAgICAgICAgICAgcmVtYWluaW5nQml0cyArPSAzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENvbXB1dGUgdGhlIGNoZWNrc3VtIGJpdHNcclxuICAgIGNvbnN0IGNoZWNrc3VtQml0cyA9IGVudHJvcHkubGVuZ3RoIC8gNDtcclxuICAgIGNvbnN0IGNoZWNrc3VtID0gcGFyc2VJbnQoc2hhMjU2KGVudHJvcHkpLnN1YnN0cmluZygyLCA0KSwgMTYpICYgZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7XHJcbiAgICAvLyBTaGlmdCB0aGUgY2hlY2tzdW0gaW50byB0aGUgd29yZCBpbmRpY2VzXHJcbiAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IGNoZWNrc3VtQml0cztcclxuICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSAoY2hlY2tzdW0gPj4gKDggLSBjaGVja3N1bUJpdHMpKTtcclxuICAgIHJldHVybiB3b3JkbGlzdC5qb2luKGluZGljZXMubWFwKChpbmRleCkgPT4gd29yZGxpc3QuZ2V0V29yZChpbmRleCkpKTtcclxufVxyXG5jb25zdCBfZ3VhcmQgPSB7fTtcclxuLyoqXHJcbiAqICBBICoqTW5lbW9uaWMqKiB3cmFwcyBhbGwgcHJvcGVydGllcyByZXF1aXJlZCB0byBjb21wdXRlIFtbbGluay1iaXAtMzldXVxyXG4gKiAgc2VlZHMgYW5kIGNvbnZlcnQgYmV0d2VlbiBwaHJhc2VzIGFuZCBlbnRyb3B5LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1uZW1vbmljIHtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBtbmVtb25pYyBwaHJhc2Ugb2YgMTIsIDE1LCAxOCwgMjEgb3IgMjQgd29yZHMuXHJcbiAgICAgKlxyXG4gICAgICogIFVzZSB0aGUgW1t3b3JkbGlzdF1dIGBgc3BsaXRgYCBtZXRob2QgdG8gZ2V0IHRoZSBpbmRpdmlkdWFsIHdvcmRzLlxyXG4gICAgICovXHJcbiAgICBwaHJhc2U7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgcGFzc3dvcmQgdXNlZCBmb3IgdGhpcyBtbmVtb25pYy4gSWYgbm8gcGFzc3dvcmQgaXMgdXNlZCB0aGlzXHJcbiAgICAgKiAgaXMgdGhlIGVtcHR5IHN0cmluZyAoaS5lLiBgYFwiXCJgYCkgYXMgcGVyIHRoZSBzcGVjaWZpY2F0aW9uLlxyXG4gICAgICovXHJcbiAgICBwYXNzd29yZDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB3b3JkbGlzdCBmb3IgdGhpcyBtbmVtb25pYy5cclxuICAgICAqL1xyXG4gICAgd29yZGxpc3Q7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdW5kZXJseWluZyBlbnRyb3B5IHdoaWNoIHRoZSBtbmVtb25pYyBlbmNvZGVzLlxyXG4gICAgICovXHJcbiAgICBlbnRyb3B5O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGVudHJvcHksIHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KSB7XHJcbiAgICAgICAgaWYgKHBhc3N3b3JkID09IG51bGwpIHtcclxuICAgICAgICAgICAgcGFzc3dvcmQgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB3b3JkbGlzdCA9IExhbmdFbi53b3JkbGlzdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiTW5lbW9uaWNcIik7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0LCBlbnRyb3B5IH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgc2VlZCBmb3IgdGhlIG1uZW1vbmljLlxyXG4gICAgICovXHJcbiAgICBjb21wdXRlU2VlZCgpIHtcclxuICAgICAgICBjb25zdCBzYWx0ID0gdG9VdGY4Qnl0ZXMoXCJtbmVtb25pY1wiICsgdGhpcy5wYXNzd29yZCwgXCJORktEXCIpO1xyXG4gICAgICAgIHJldHVybiBwYmtkZjIodG9VdGY4Qnl0ZXModGhpcy5waHJhc2UsIFwiTkZLRFwiKSwgc2FsdCwgMjA0OCwgNjQsIFwic2hhNTEyXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBNbmVtb25pYyBmb3IgdGhlICUlcGhyYXNlJSUuXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSBkZWZhdWx0ICUlcGFzc3dvcmQlJSBpcyB0aGUgZW1wdHkgc3RyaW5nIGFuZCB0aGUgZGVmYXVsdFxyXG4gICAgICogIHdvcmRsaXN0IGlzIHRoZSBbRW5nbGlzaCB3b3JkbGlzdHNdKExhbmdFbikuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tUGhyYXNlKHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KSB7XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBjYXNlIGFuZCBzcGFjZTsgdGhyb3dzIGlmIGludmFsaWRcclxuICAgICAgICBjb25zdCBlbnRyb3B5ID0gbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCk7XHJcbiAgICAgICAgcGhyYXNlID0gZW50cm9weVRvTW5lbW9uaWMoZ2V0Qnl0ZXMoZW50cm9weSksIHdvcmRsaXN0KTtcclxuICAgICAgICByZXR1cm4gbmV3IE1uZW1vbmljKF9ndWFyZCwgZW50cm9weSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqTW5lbW9uaWMqKiBmcm9tIHRoZSAlJWVudHJvcHklJS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhlIGRlZmF1bHQgJSVwYXNzd29yZCUlIGlzIHRoZSBlbXB0eSBzdHJpbmcgYW5kIHRoZSBkZWZhdWx0XHJcbiAgICAgKiAgd29yZGxpc3QgaXMgdGhlIFtFbmdsaXNoIHdvcmRsaXN0c10oTGFuZ0VuKS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21FbnRyb3B5KF9lbnRyb3B5LCBwYXNzd29yZCwgd29yZGxpc3QpIHtcclxuICAgICAgICBjb25zdCBlbnRyb3B5ID0gZ2V0Qnl0ZXMoX2VudHJvcHksIFwiZW50cm9weVwiKTtcclxuICAgICAgICBjb25zdCBwaHJhc2UgPSBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNbmVtb25pYyhfZ3VhcmQsIGhleGxpZnkoZW50cm9weSksIHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIHBocmFzZSBmb3IgJSVtbmVtb25pYyUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZW50cm9weVRvUGhyYXNlKF9lbnRyb3B5LCB3b3JkbGlzdCkge1xyXG4gICAgICAgIGNvbnN0IGVudHJvcHkgPSBnZXRCeXRlcyhfZW50cm9weSwgXCJlbnRyb3B5XCIpO1xyXG4gICAgICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRyb3B5IGZvciAlJXBocmFzZSUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcGhyYXNlVG9FbnRyb3B5KHBocmFzZSwgd29yZGxpc3QpIHtcclxuICAgICAgICByZXR1cm4gbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVwaHJhc2UlJSBpcyBhIHZhbGlkIFtbbGluay1iaXAtMzldXSBwaHJhc2UuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgY2hlY2tzIGFsbCB0aGUgcHJvdmlkZWQgd29yZHMgYmVsb25nIHRvIHRoZSAlJXdvcmRsaXN0JSUsXHJcbiAgICAgKiAgdGhhdCB0aGUgbGVuZ3RoIGlzIHZhbGlkIGFuZCB0aGUgY2hlY2tzdW0gaXMgY29ycmVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzVmFsaWRNbmVtb25pYyhwaHJhc2UsIHdvcmRsaXN0KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tbmVtb25pYy5qcy5tYXAiLCIvKiEgTUlUIExpY2Vuc2UuIENvcHlyaWdodCAyMDE1LTIwMjIgUmljaGFyZCBNb29yZSA8bWVAcmljbW9vLmNvbT4uIFNlZSBMSUNFTlNFLnR4dC4gKi9cclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufTtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn07XHJcbnZhciBfQUVTX2tleSwgX0FFU19LZCwgX0FFU19LZTtcclxuLy8gTnVtYmVyIG9mIHJvdW5kcyBieSBrZXlzaXplXHJcbmNvbnN0IG51bWJlck9mUm91bmRzID0geyAxNjogMTAsIDI0OiAxMiwgMzI6IDE0IH07XHJcbi8vIFJvdW5kIGNvbnN0YW50IHdvcmRzXHJcbmNvbnN0IHJjb24gPSBbMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNiwgMHg2YywgMHhkOCwgMHhhYiwgMHg0ZCwgMHg5YSwgMHgyZiwgMHg1ZSwgMHhiYywgMHg2MywgMHhjNiwgMHg5NywgMHgzNSwgMHg2YSwgMHhkNCwgMHhiMywgMHg3ZCwgMHhmYSwgMHhlZiwgMHhjNSwgMHg5MV07XHJcbi8vIFMtYm94IGFuZCBJbnZlcnNlIFMtYm94IChTIGlzIGZvciBTdWJzdGl0dXRpb24pXHJcbmNvbnN0IFMgPSBbMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NiwgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCwgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSwgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSwgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCwgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZiwgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCwgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMiwgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MywgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYiwgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSwgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCwgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSwgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSwgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZiwgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNl07XHJcbmNvbnN0IFNpID0gWzB4NTIsIDB4MDksIDB4NmEsIDB4ZDUsIDB4MzAsIDB4MzYsIDB4YTUsIDB4MzgsIDB4YmYsIDB4NDAsIDB4YTMsIDB4OWUsIDB4ODEsIDB4ZjMsIDB4ZDcsIDB4ZmIsIDB4N2MsIDB4ZTMsIDB4MzksIDB4ODIsIDB4OWIsIDB4MmYsIDB4ZmYsIDB4ODcsIDB4MzQsIDB4OGUsIDB4NDMsIDB4NDQsIDB4YzQsIDB4ZGUsIDB4ZTksIDB4Y2IsIDB4NTQsIDB4N2IsIDB4OTQsIDB4MzIsIDB4YTYsIDB4YzIsIDB4MjMsIDB4M2QsIDB4ZWUsIDB4NGMsIDB4OTUsIDB4MGIsIDB4NDIsIDB4ZmEsIDB4YzMsIDB4NGUsIDB4MDgsIDB4MmUsIDB4YTEsIDB4NjYsIDB4MjgsIDB4ZDksIDB4MjQsIDB4YjIsIDB4NzYsIDB4NWIsIDB4YTIsIDB4NDksIDB4NmQsIDB4OGIsIDB4ZDEsIDB4MjUsIDB4NzIsIDB4ZjgsIDB4ZjYsIDB4NjQsIDB4ODYsIDB4NjgsIDB4OTgsIDB4MTYsIDB4ZDQsIDB4YTQsIDB4NWMsIDB4Y2MsIDB4NWQsIDB4NjUsIDB4YjYsIDB4OTIsIDB4NmMsIDB4NzAsIDB4NDgsIDB4NTAsIDB4ZmQsIDB4ZWQsIDB4YjksIDB4ZGEsIDB4NWUsIDB4MTUsIDB4NDYsIDB4NTcsIDB4YTcsIDB4OGQsIDB4OWQsIDB4ODQsIDB4OTAsIDB4ZDgsIDB4YWIsIDB4MDAsIDB4OGMsIDB4YmMsIDB4ZDMsIDB4MGEsIDB4ZjcsIDB4ZTQsIDB4NTgsIDB4MDUsIDB4YjgsIDB4YjMsIDB4NDUsIDB4MDYsIDB4ZDAsIDB4MmMsIDB4MWUsIDB4OGYsIDB4Y2EsIDB4M2YsIDB4MGYsIDB4MDIsIDB4YzEsIDB4YWYsIDB4YmQsIDB4MDMsIDB4MDEsIDB4MTMsIDB4OGEsIDB4NmIsIDB4M2EsIDB4OTEsIDB4MTEsIDB4NDEsIDB4NGYsIDB4NjcsIDB4ZGMsIDB4ZWEsIDB4OTcsIDB4ZjIsIDB4Y2YsIDB4Y2UsIDB4ZjAsIDB4YjQsIDB4ZTYsIDB4NzMsIDB4OTYsIDB4YWMsIDB4NzQsIDB4MjIsIDB4ZTcsIDB4YWQsIDB4MzUsIDB4ODUsIDB4ZTIsIDB4ZjksIDB4MzcsIDB4ZTgsIDB4MWMsIDB4NzUsIDB4ZGYsIDB4NmUsIDB4NDcsIDB4ZjEsIDB4MWEsIDB4NzEsIDB4MWQsIDB4MjksIDB4YzUsIDB4ODksIDB4NmYsIDB4YjcsIDB4NjIsIDB4MGUsIDB4YWEsIDB4MTgsIDB4YmUsIDB4MWIsIDB4ZmMsIDB4NTYsIDB4M2UsIDB4NGIsIDB4YzYsIDB4ZDIsIDB4NzksIDB4MjAsIDB4OWEsIDB4ZGIsIDB4YzAsIDB4ZmUsIDB4NzgsIDB4Y2QsIDB4NWEsIDB4ZjQsIDB4MWYsIDB4ZGQsIDB4YTgsIDB4MzMsIDB4ODgsIDB4MDcsIDB4YzcsIDB4MzEsIDB4YjEsIDB4MTIsIDB4MTAsIDB4NTksIDB4MjcsIDB4ODAsIDB4ZWMsIDB4NWYsIDB4NjAsIDB4NTEsIDB4N2YsIDB4YTksIDB4MTksIDB4YjUsIDB4NGEsIDB4MGQsIDB4MmQsIDB4ZTUsIDB4N2EsIDB4OWYsIDB4OTMsIDB4YzksIDB4OWMsIDB4ZWYsIDB4YTAsIDB4ZTAsIDB4M2IsIDB4NGQsIDB4YWUsIDB4MmEsIDB4ZjUsIDB4YjAsIDB4YzgsIDB4ZWIsIDB4YmIsIDB4M2MsIDB4ODMsIDB4NTMsIDB4OTksIDB4NjEsIDB4MTcsIDB4MmIsIDB4MDQsIDB4N2UsIDB4YmEsIDB4NzcsIDB4ZDYsIDB4MjYsIDB4ZTEsIDB4NjksIDB4MTQsIDB4NjMsIDB4NTUsIDB4MjEsIDB4MGMsIDB4N2RdO1xyXG4vLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGVuY3J5cHRpb25cclxuY29uc3QgVDEgPSBbMHhjNjYzNjNhNSwgMHhmODdjN2M4NCwgMHhlZTc3Nzc5OSwgMHhmNjdiN2I4ZCwgMHhmZmYyZjIwZCwgMHhkNjZiNmJiZCwgMHhkZTZmNmZiMSwgMHg5MWM1YzU1NCwgMHg2MDMwMzA1MCwgMHgwMjAxMDEwMywgMHhjZTY3NjdhOSwgMHg1NjJiMmI3ZCwgMHhlN2ZlZmUxOSwgMHhiNWQ3ZDc2MiwgMHg0ZGFiYWJlNiwgMHhlYzc2NzY5YSwgMHg4ZmNhY2E0NSwgMHgxZjgyODI5ZCwgMHg4OWM5Yzk0MCwgMHhmYTdkN2Q4NywgMHhlZmZhZmExNSwgMHhiMjU5NTllYiwgMHg4ZTQ3NDdjOSwgMHhmYmYwZjAwYiwgMHg0MWFkYWRlYywgMHhiM2Q0ZDQ2NywgMHg1ZmEyYTJmZCwgMHg0NWFmYWZlYSwgMHgyMzljOWNiZiwgMHg1M2E0YTRmNywgMHhlNDcyNzI5NiwgMHg5YmMwYzA1YiwgMHg3NWI3YjdjMiwgMHhlMWZkZmQxYywgMHgzZDkzOTNhZSwgMHg0YzI2MjY2YSwgMHg2YzM2MzY1YSwgMHg3ZTNmM2Y0MSwgMHhmNWY3ZjcwMiwgMHg4M2NjY2M0ZiwgMHg2ODM0MzQ1YywgMHg1MWE1YTVmNCwgMHhkMWU1ZTUzNCwgMHhmOWYxZjEwOCwgMHhlMjcxNzE5MywgMHhhYmQ4ZDg3MywgMHg2MjMxMzE1MywgMHgyYTE1MTUzZiwgMHgwODA0MDQwYywgMHg5NWM3Yzc1MiwgMHg0NjIzMjM2NSwgMHg5ZGMzYzM1ZSwgMHgzMDE4MTgyOCwgMHgzNzk2OTZhMSwgMHgwYTA1MDUwZiwgMHgyZjlhOWFiNSwgMHgwZTA3MDcwOSwgMHgyNDEyMTIzNiwgMHgxYjgwODA5YiwgMHhkZmUyZTIzZCwgMHhjZGViZWIyNiwgMHg0ZTI3Mjc2OSwgMHg3ZmIyYjJjZCwgMHhlYTc1NzU5ZiwgMHgxMjA5MDkxYiwgMHgxZDgzODM5ZSwgMHg1ODJjMmM3NCwgMHgzNDFhMWEyZSwgMHgzNjFiMWIyZCwgMHhkYzZlNmViMiwgMHhiNDVhNWFlZSwgMHg1YmEwYTBmYiwgMHhhNDUyNTJmNiwgMHg3NjNiM2I0ZCwgMHhiN2Q2ZDY2MSwgMHg3ZGIzYjNjZSwgMHg1MjI5Mjk3YiwgMHhkZGUzZTMzZSwgMHg1ZTJmMmY3MSwgMHgxMzg0ODQ5NywgMHhhNjUzNTNmNSwgMHhiOWQxZDE2OCwgMHgwMDAwMDAwMCwgMHhjMWVkZWQyYywgMHg0MDIwMjA2MCwgMHhlM2ZjZmMxZiwgMHg3OWIxYjFjOCwgMHhiNjViNWJlZCwgMHhkNDZhNmFiZSwgMHg4ZGNiY2I0NiwgMHg2N2JlYmVkOSwgMHg3MjM5Mzk0YiwgMHg5NDRhNGFkZSwgMHg5ODRjNGNkNCwgMHhiMDU4NThlOCwgMHg4NWNmY2Y0YSwgMHhiYmQwZDA2YiwgMHhjNWVmZWYyYSwgMHg0ZmFhYWFlNSwgMHhlZGZiZmIxNiwgMHg4NjQzNDNjNSwgMHg5YTRkNGRkNywgMHg2NjMzMzM1NSwgMHgxMTg1ODU5NCwgMHg4YTQ1NDVjZiwgMHhlOWY5ZjkxMCwgMHgwNDAyMDIwNiwgMHhmZTdmN2Y4MSwgMHhhMDUwNTBmMCwgMHg3ODNjM2M0NCwgMHgyNTlmOWZiYSwgMHg0YmE4YThlMywgMHhhMjUxNTFmMywgMHg1ZGEzYTNmZSwgMHg4MDQwNDBjMCwgMHgwNThmOGY4YSwgMHgzZjkyOTJhZCwgMHgyMTlkOWRiYywgMHg3MDM4Mzg0OCwgMHhmMWY1ZjUwNCwgMHg2M2JjYmNkZiwgMHg3N2I2YjZjMSwgMHhhZmRhZGE3NSwgMHg0MjIxMjE2MywgMHgyMDEwMTAzMCwgMHhlNWZmZmYxYSwgMHhmZGYzZjMwZSwgMHhiZmQyZDI2ZCwgMHg4MWNkY2Q0YywgMHgxODBjMGMxNCwgMHgyNjEzMTMzNSwgMHhjM2VjZWMyZiwgMHhiZTVmNWZlMSwgMHgzNTk3OTdhMiwgMHg4ODQ0NDRjYywgMHgyZTE3MTczOSwgMHg5M2M0YzQ1NywgMHg1NWE3YTdmMiwgMHhmYzdlN2U4MiwgMHg3YTNkM2Q0NywgMHhjODY0NjRhYywgMHhiYTVkNWRlNywgMHgzMjE5MTkyYiwgMHhlNjczNzM5NSwgMHhjMDYwNjBhMCwgMHgxOTgxODE5OCwgMHg5ZTRmNGZkMSwgMHhhM2RjZGM3ZiwgMHg0NDIyMjI2NiwgMHg1NDJhMmE3ZSwgMHgzYjkwOTBhYiwgMHgwYjg4ODg4MywgMHg4YzQ2NDZjYSwgMHhjN2VlZWUyOSwgMHg2YmI4YjhkMywgMHgyODE0MTQzYywgMHhhN2RlZGU3OSwgMHhiYzVlNWVlMiwgMHgxNjBiMGIxZCwgMHhhZGRiZGI3NiwgMHhkYmUwZTAzYiwgMHg2NDMyMzI1NiwgMHg3NDNhM2E0ZSwgMHgxNDBhMGExZSwgMHg5MjQ5NDlkYiwgMHgwYzA2MDYwYSwgMHg0ODI0MjQ2YywgMHhiODVjNWNlNCwgMHg5ZmMyYzI1ZCwgMHhiZGQzZDM2ZSwgMHg0M2FjYWNlZiwgMHhjNDYyNjJhNiwgMHgzOTkxOTFhOCwgMHgzMTk1OTVhNCwgMHhkM2U0ZTQzNywgMHhmMjc5Nzk4YiwgMHhkNWU3ZTczMiwgMHg4YmM4Yzg0MywgMHg2ZTM3Mzc1OSwgMHhkYTZkNmRiNywgMHgwMThkOGQ4YywgMHhiMWQ1ZDU2NCwgMHg5YzRlNGVkMiwgMHg0OWE5YTllMCwgMHhkODZjNmNiNCwgMHhhYzU2NTZmYSwgMHhmM2Y0ZjQwNywgMHhjZmVhZWEyNSwgMHhjYTY1NjVhZiwgMHhmNDdhN2E4ZSwgMHg0N2FlYWVlOSwgMHgxMDA4MDgxOCwgMHg2ZmJhYmFkNSwgMHhmMDc4Nzg4OCwgMHg0YTI1MjU2ZiwgMHg1YzJlMmU3MiwgMHgzODFjMWMyNCwgMHg1N2E2YTZmMSwgMHg3M2I0YjRjNywgMHg5N2M2YzY1MSwgMHhjYmU4ZTgyMywgMHhhMWRkZGQ3YywgMHhlODc0NzQ5YywgMHgzZTFmMWYyMSwgMHg5NjRiNGJkZCwgMHg2MWJkYmRkYywgMHgwZDhiOGI4NiwgMHgwZjhhOGE4NSwgMHhlMDcwNzA5MCwgMHg3YzNlM2U0MiwgMHg3MWI1YjVjNCwgMHhjYzY2NjZhYSwgMHg5MDQ4NDhkOCwgMHgwNjAzMDMwNSwgMHhmN2Y2ZjYwMSwgMHgxYzBlMGUxMiwgMHhjMjYxNjFhMywgMHg2YTM1MzU1ZiwgMHhhZTU3NTdmOSwgMHg2OWI5YjlkMCwgMHgxNzg2ODY5MSwgMHg5OWMxYzE1OCwgMHgzYTFkMWQyNywgMHgyNzllOWViOSwgMHhkOWUxZTEzOCwgMHhlYmY4ZjgxMywgMHgyYjk4OThiMywgMHgyMjExMTEzMywgMHhkMjY5NjliYiwgMHhhOWQ5ZDk3MCwgMHgwNzhlOGU4OSwgMHgzMzk0OTRhNywgMHgyZDliOWJiNiwgMHgzYzFlMWUyMiwgMHgxNTg3ODc5MiwgMHhjOWU5ZTkyMCwgMHg4N2NlY2U0OSwgMHhhYTU1NTVmZiwgMHg1MDI4Mjg3OCwgMHhhNWRmZGY3YSwgMHgwMzhjOGM4ZiwgMHg1OWExYTFmOCwgMHgwOTg5ODk4MCwgMHgxYTBkMGQxNywgMHg2NWJmYmZkYSwgMHhkN2U2ZTYzMSwgMHg4NDQyNDJjNiwgMHhkMDY4NjhiOCwgMHg4MjQxNDFjMywgMHgyOTk5OTliMCwgMHg1YTJkMmQ3NywgMHgxZTBmMGYxMSwgMHg3YmIwYjBjYiwgMHhhODU0NTRmYywgMHg2ZGJiYmJkNiwgMHgyYzE2MTYzYV07XHJcbmNvbnN0IFQyID0gWzB4YTVjNjYzNjMsIDB4ODRmODdjN2MsIDB4OTllZTc3NzcsIDB4OGRmNjdiN2IsIDB4MGRmZmYyZjIsIDB4YmRkNjZiNmIsIDB4YjFkZTZmNmYsIDB4NTQ5MWM1YzUsIDB4NTA2MDMwMzAsIDB4MDMwMjAxMDEsIDB4YTljZTY3NjcsIDB4N2Q1NjJiMmIsIDB4MTllN2ZlZmUsIDB4NjJiNWQ3ZDcsIDB4ZTY0ZGFiYWIsIDB4OWFlYzc2NzYsIDB4NDU4ZmNhY2EsIDB4OWQxZjgyODIsIDB4NDA4OWM5YzksIDB4ODdmYTdkN2QsIDB4MTVlZmZhZmEsIDB4ZWJiMjU5NTksIDB4Yzk4ZTQ3NDcsIDB4MGJmYmYwZjAsIDB4ZWM0MWFkYWQsIDB4NjdiM2Q0ZDQsIDB4ZmQ1ZmEyYTIsIDB4ZWE0NWFmYWYsIDB4YmYyMzljOWMsIDB4Zjc1M2E0YTQsIDB4OTZlNDcyNzIsIDB4NWI5YmMwYzAsIDB4YzI3NWI3YjcsIDB4MWNlMWZkZmQsIDB4YWUzZDkzOTMsIDB4NmE0YzI2MjYsIDB4NWE2YzM2MzYsIDB4NDE3ZTNmM2YsIDB4MDJmNWY3ZjcsIDB4NGY4M2NjY2MsIDB4NWM2ODM0MzQsIDB4ZjQ1MWE1YTUsIDB4MzRkMWU1ZTUsIDB4MDhmOWYxZjEsIDB4OTNlMjcxNzEsIDB4NzNhYmQ4ZDgsIDB4NTM2MjMxMzEsIDB4M2YyYTE1MTUsIDB4MGMwODA0MDQsIDB4NTI5NWM3YzcsIDB4NjU0NjIzMjMsIDB4NWU5ZGMzYzMsIDB4MjgzMDE4MTgsIDB4YTEzNzk2OTYsIDB4MGYwYTA1MDUsIDB4YjUyZjlhOWEsIDB4MDkwZTA3MDcsIDB4MzYyNDEyMTIsIDB4OWIxYjgwODAsIDB4M2RkZmUyZTIsIDB4MjZjZGViZWIsIDB4Njk0ZTI3MjcsIDB4Y2Q3ZmIyYjIsIDB4OWZlYTc1NzUsIDB4MWIxMjA5MDksIDB4OWUxZDgzODMsIDB4NzQ1ODJjMmMsIDB4MmUzNDFhMWEsIDB4MmQzNjFiMWIsIDB4YjJkYzZlNmUsIDB4ZWViNDVhNWEsIDB4ZmI1YmEwYTAsIDB4ZjZhNDUyNTIsIDB4NGQ3NjNiM2IsIDB4NjFiN2Q2ZDYsIDB4Y2U3ZGIzYjMsIDB4N2I1MjI5MjksIDB4M2VkZGUzZTMsIDB4NzE1ZTJmMmYsIDB4OTcxMzg0ODQsIDB4ZjVhNjUzNTMsIDB4NjhiOWQxZDEsIDB4MDAwMDAwMDAsIDB4MmNjMWVkZWQsIDB4NjA0MDIwMjAsIDB4MWZlM2ZjZmMsIDB4Yzg3OWIxYjEsIDB4ZWRiNjViNWIsIDB4YmVkNDZhNmEsIDB4NDY4ZGNiY2IsIDB4ZDk2N2JlYmUsIDB4NGI3MjM5MzksIDB4ZGU5NDRhNGEsIDB4ZDQ5ODRjNGMsIDB4ZThiMDU4NTgsIDB4NGE4NWNmY2YsIDB4NmJiYmQwZDAsIDB4MmFjNWVmZWYsIDB4ZTU0ZmFhYWEsIDB4MTZlZGZiZmIsIDB4YzU4NjQzNDMsIDB4ZDc5YTRkNGQsIDB4NTU2NjMzMzMsIDB4OTQxMTg1ODUsIDB4Y2Y4YTQ1NDUsIDB4MTBlOWY5ZjksIDB4MDYwNDAyMDIsIDB4ODFmZTdmN2YsIDB4ZjBhMDUwNTAsIDB4NDQ3ODNjM2MsIDB4YmEyNTlmOWYsIDB4ZTM0YmE4YTgsIDB4ZjNhMjUxNTEsIDB4ZmU1ZGEzYTMsIDB4YzA4MDQwNDAsIDB4OGEwNThmOGYsIDB4YWQzZjkyOTIsIDB4YmMyMTlkOWQsIDB4NDg3MDM4MzgsIDB4MDRmMWY1ZjUsIDB4ZGY2M2JjYmMsIDB4YzE3N2I2YjYsIDB4NzVhZmRhZGEsIDB4NjM0MjIxMjEsIDB4MzAyMDEwMTAsIDB4MWFlNWZmZmYsIDB4MGVmZGYzZjMsIDB4NmRiZmQyZDIsIDB4NGM4MWNkY2QsIDB4MTQxODBjMGMsIDB4MzUyNjEzMTMsIDB4MmZjM2VjZWMsIDB4ZTFiZTVmNWYsIDB4YTIzNTk3OTcsIDB4Y2M4ODQ0NDQsIDB4MzkyZTE3MTcsIDB4NTc5M2M0YzQsIDB4ZjI1NWE3YTcsIDB4ODJmYzdlN2UsIDB4NDc3YTNkM2QsIDB4YWNjODY0NjQsIDB4ZTdiYTVkNWQsIDB4MmIzMjE5MTksIDB4OTVlNjczNzMsIDB4YTBjMDYwNjAsIDB4OTgxOTgxODEsIDB4ZDE5ZTRmNGYsIDB4N2ZhM2RjZGMsIDB4NjY0NDIyMjIsIDB4N2U1NDJhMmEsIDB4YWIzYjkwOTAsIDB4ODMwYjg4ODgsIDB4Y2E4YzQ2NDYsIDB4MjljN2VlZWUsIDB4ZDM2YmI4YjgsIDB4M2MyODE0MTQsIDB4NzlhN2RlZGUsIDB4ZTJiYzVlNWUsIDB4MWQxNjBiMGIsIDB4NzZhZGRiZGIsIDB4M2JkYmUwZTAsIDB4NTY2NDMyMzIsIDB4NGU3NDNhM2EsIDB4MWUxNDBhMGEsIDB4ZGI5MjQ5NDksIDB4MGEwYzA2MDYsIDB4NmM0ODI0MjQsIDB4ZTRiODVjNWMsIDB4NWQ5ZmMyYzIsIDB4NmViZGQzZDMsIDB4ZWY0M2FjYWMsIDB4YTZjNDYyNjIsIDB4YTgzOTkxOTEsIDB4YTQzMTk1OTUsIDB4MzdkM2U0ZTQsIDB4OGJmMjc5NzksIDB4MzJkNWU3ZTcsIDB4NDM4YmM4YzgsIDB4NTk2ZTM3MzcsIDB4YjdkYTZkNmQsIDB4OGMwMThkOGQsIDB4NjRiMWQ1ZDUsIDB4ZDI5YzRlNGUsIDB4ZTA0OWE5YTksIDB4YjRkODZjNmMsIDB4ZmFhYzU2NTYsIDB4MDdmM2Y0ZjQsIDB4MjVjZmVhZWEsIDB4YWZjYTY1NjUsIDB4OGVmNDdhN2EsIDB4ZTk0N2FlYWUsIDB4MTgxMDA4MDgsIDB4ZDU2ZmJhYmEsIDB4ODhmMDc4NzgsIDB4NmY0YTI1MjUsIDB4NzI1YzJlMmUsIDB4MjQzODFjMWMsIDB4ZjE1N2E2YTYsIDB4Yzc3M2I0YjQsIDB4NTE5N2M2YzYsIDB4MjNjYmU4ZTgsIDB4N2NhMWRkZGQsIDB4OWNlODc0NzQsIDB4MjEzZTFmMWYsIDB4ZGQ5NjRiNGIsIDB4ZGM2MWJkYmQsIDB4ODYwZDhiOGIsIDB4ODUwZjhhOGEsIDB4OTBlMDcwNzAsIDB4NDI3YzNlM2UsIDB4YzQ3MWI1YjUsIDB4YWFjYzY2NjYsIDB4ZDg5MDQ4NDgsIDB4MDUwNjAzMDMsIDB4MDFmN2Y2ZjYsIDB4MTIxYzBlMGUsIDB4YTNjMjYxNjEsIDB4NWY2YTM1MzUsIDB4ZjlhZTU3NTcsIDB4ZDA2OWI5YjksIDB4OTExNzg2ODYsIDB4NTg5OWMxYzEsIDB4MjczYTFkMWQsIDB4YjkyNzllOWUsIDB4MzhkOWUxZTEsIDB4MTNlYmY4ZjgsIDB4YjMyYjk4OTgsIDB4MzMyMjExMTEsIDB4YmJkMjY5NjksIDB4NzBhOWQ5ZDksIDB4ODkwNzhlOGUsIDB4YTczMzk0OTQsIDB4YjYyZDliOWIsIDB4MjIzYzFlMWUsIDB4OTIxNTg3ODcsIDB4MjBjOWU5ZTksIDB4NDk4N2NlY2UsIDB4ZmZhYTU1NTUsIDB4Nzg1MDI4MjgsIDB4N2FhNWRmZGYsIDB4OGYwMzhjOGMsIDB4Zjg1OWExYTEsIDB4ODAwOTg5ODksIDB4MTcxYTBkMGQsIDB4ZGE2NWJmYmYsIDB4MzFkN2U2ZTYsIDB4YzY4NDQyNDIsIDB4YjhkMDY4NjgsIDB4YzM4MjQxNDEsIDB4YjAyOTk5OTksIDB4Nzc1YTJkMmQsIDB4MTExZTBmMGYsIDB4Y2I3YmIwYjAsIDB4ZmNhODU0NTQsIDB4ZDY2ZGJiYmIsIDB4M2EyYzE2MTZdO1xyXG5jb25zdCBUMyA9IFsweDYzYTVjNjYzLCAweDdjODRmODdjLCAweDc3OTllZTc3LCAweDdiOGRmNjdiLCAweGYyMGRmZmYyLCAweDZiYmRkNjZiLCAweDZmYjFkZTZmLCAweGM1NTQ5MWM1LCAweDMwNTA2MDMwLCAweDAxMDMwMjAxLCAweDY3YTljZTY3LCAweDJiN2Q1NjJiLCAweGZlMTllN2ZlLCAweGQ3NjJiNWQ3LCAweGFiZTY0ZGFiLCAweDc2OWFlYzc2LCAweGNhNDU4ZmNhLCAweDgyOWQxZjgyLCAweGM5NDA4OWM5LCAweDdkODdmYTdkLCAweGZhMTVlZmZhLCAweDU5ZWJiMjU5LCAweDQ3Yzk4ZTQ3LCAweGYwMGJmYmYwLCAweGFkZWM0MWFkLCAweGQ0NjdiM2Q0LCAweGEyZmQ1ZmEyLCAweGFmZWE0NWFmLCAweDljYmYyMzljLCAweGE0Zjc1M2E0LCAweDcyOTZlNDcyLCAweGMwNWI5YmMwLCAweGI3YzI3NWI3LCAweGZkMWNlMWZkLCAweDkzYWUzZDkzLCAweDI2NmE0YzI2LCAweDM2NWE2YzM2LCAweDNmNDE3ZTNmLCAweGY3MDJmNWY3LCAweGNjNGY4M2NjLCAweDM0NWM2ODM0LCAweGE1ZjQ1MWE1LCAweGU1MzRkMWU1LCAweGYxMDhmOWYxLCAweDcxOTNlMjcxLCAweGQ4NzNhYmQ4LCAweDMxNTM2MjMxLCAweDE1M2YyYTE1LCAweDA0MGMwODA0LCAweGM3NTI5NWM3LCAweDIzNjU0NjIzLCAweGMzNWU5ZGMzLCAweDE4MjgzMDE4LCAweDk2YTEzNzk2LCAweDA1MGYwYTA1LCAweDlhYjUyZjlhLCAweDA3MDkwZTA3LCAweDEyMzYyNDEyLCAweDgwOWIxYjgwLCAweGUyM2RkZmUyLCAweGViMjZjZGViLCAweDI3Njk0ZTI3LCAweGIyY2Q3ZmIyLCAweDc1OWZlYTc1LCAweDA5MWIxMjA5LCAweDgzOWUxZDgzLCAweDJjNzQ1ODJjLCAweDFhMmUzNDFhLCAweDFiMmQzNjFiLCAweDZlYjJkYzZlLCAweDVhZWViNDVhLCAweGEwZmI1YmEwLCAweDUyZjZhNDUyLCAweDNiNGQ3NjNiLCAweGQ2NjFiN2Q2LCAweGIzY2U3ZGIzLCAweDI5N2I1MjI5LCAweGUzM2VkZGUzLCAweDJmNzE1ZTJmLCAweDg0OTcxMzg0LCAweDUzZjVhNjUzLCAweGQxNjhiOWQxLCAweDAwMDAwMDAwLCAweGVkMmNjMWVkLCAweDIwNjA0MDIwLCAweGZjMWZlM2ZjLCAweGIxYzg3OWIxLCAweDViZWRiNjViLCAweDZhYmVkNDZhLCAweGNiNDY4ZGNiLCAweGJlZDk2N2JlLCAweDM5NGI3MjM5LCAweDRhZGU5NDRhLCAweDRjZDQ5ODRjLCAweDU4ZThiMDU4LCAweGNmNGE4NWNmLCAweGQwNmJiYmQwLCAweGVmMmFjNWVmLCAweGFhZTU0ZmFhLCAweGZiMTZlZGZiLCAweDQzYzU4NjQzLCAweDRkZDc5YTRkLCAweDMzNTU2NjMzLCAweDg1OTQxMTg1LCAweDQ1Y2Y4YTQ1LCAweGY5MTBlOWY5LCAweDAyMDYwNDAyLCAweDdmODFmZTdmLCAweDUwZjBhMDUwLCAweDNjNDQ3ODNjLCAweDlmYmEyNTlmLCAweGE4ZTM0YmE4LCAweDUxZjNhMjUxLCAweGEzZmU1ZGEzLCAweDQwYzA4MDQwLCAweDhmOGEwNThmLCAweDkyYWQzZjkyLCAweDlkYmMyMTlkLCAweDM4NDg3MDM4LCAweGY1MDRmMWY1LCAweGJjZGY2M2JjLCAweGI2YzE3N2I2LCAweGRhNzVhZmRhLCAweDIxNjM0MjIxLCAweDEwMzAyMDEwLCAweGZmMWFlNWZmLCAweGYzMGVmZGYzLCAweGQyNmRiZmQyLCAweGNkNGM4MWNkLCAweDBjMTQxODBjLCAweDEzMzUyNjEzLCAweGVjMmZjM2VjLCAweDVmZTFiZTVmLCAweDk3YTIzNTk3LCAweDQ0Y2M4ODQ0LCAweDE3MzkyZTE3LCAweGM0NTc5M2M0LCAweGE3ZjI1NWE3LCAweDdlODJmYzdlLCAweDNkNDc3YTNkLCAweDY0YWNjODY0LCAweDVkZTdiYTVkLCAweDE5MmIzMjE5LCAweDczOTVlNjczLCAweDYwYTBjMDYwLCAweDgxOTgxOTgxLCAweDRmZDE5ZTRmLCAweGRjN2ZhM2RjLCAweDIyNjY0NDIyLCAweDJhN2U1NDJhLCAweDkwYWIzYjkwLCAweDg4ODMwYjg4LCAweDQ2Y2E4YzQ2LCAweGVlMjljN2VlLCAweGI4ZDM2YmI4LCAweDE0M2MyODE0LCAweGRlNzlhN2RlLCAweDVlZTJiYzVlLCAweDBiMWQxNjBiLCAweGRiNzZhZGRiLCAweGUwM2JkYmUwLCAweDMyNTY2NDMyLCAweDNhNGU3NDNhLCAweDBhMWUxNDBhLCAweDQ5ZGI5MjQ5LCAweDA2MGEwYzA2LCAweDI0NmM0ODI0LCAweDVjZTRiODVjLCAweGMyNWQ5ZmMyLCAweGQzNmViZGQzLCAweGFjZWY0M2FjLCAweDYyYTZjNDYyLCAweDkxYTgzOTkxLCAweDk1YTQzMTk1LCAweGU0MzdkM2U0LCAweDc5OGJmMjc5LCAweGU3MzJkNWU3LCAweGM4NDM4YmM4LCAweDM3NTk2ZTM3LCAweDZkYjdkYTZkLCAweDhkOGMwMThkLCAweGQ1NjRiMWQ1LCAweDRlZDI5YzRlLCAweGE5ZTA0OWE5LCAweDZjYjRkODZjLCAweDU2ZmFhYzU2LCAweGY0MDdmM2Y0LCAweGVhMjVjZmVhLCAweDY1YWZjYTY1LCAweDdhOGVmNDdhLCAweGFlZTk0N2FlLCAweDA4MTgxMDA4LCAweGJhZDU2ZmJhLCAweDc4ODhmMDc4LCAweDI1NmY0YTI1LCAweDJlNzI1YzJlLCAweDFjMjQzODFjLCAweGE2ZjE1N2E2LCAweGI0Yzc3M2I0LCAweGM2NTE5N2M2LCAweGU4MjNjYmU4LCAweGRkN2NhMWRkLCAweDc0OWNlODc0LCAweDFmMjEzZTFmLCAweDRiZGQ5NjRiLCAweGJkZGM2MWJkLCAweDhiODYwZDhiLCAweDhhODUwZjhhLCAweDcwOTBlMDcwLCAweDNlNDI3YzNlLCAweGI1YzQ3MWI1LCAweDY2YWFjYzY2LCAweDQ4ZDg5MDQ4LCAweDAzMDUwNjAzLCAweGY2MDFmN2Y2LCAweDBlMTIxYzBlLCAweDYxYTNjMjYxLCAweDM1NWY2YTM1LCAweDU3ZjlhZTU3LCAweGI5ZDA2OWI5LCAweDg2OTExNzg2LCAweGMxNTg5OWMxLCAweDFkMjczYTFkLCAweDllYjkyNzllLCAweGUxMzhkOWUxLCAweGY4MTNlYmY4LCAweDk4YjMyYjk4LCAweDExMzMyMjExLCAweDY5YmJkMjY5LCAweGQ5NzBhOWQ5LCAweDhlODkwNzhlLCAweDk0YTczMzk0LCAweDliYjYyZDliLCAweDFlMjIzYzFlLCAweDg3OTIxNTg3LCAweGU5MjBjOWU5LCAweGNlNDk4N2NlLCAweDU1ZmZhYTU1LCAweDI4Nzg1MDI4LCAweGRmN2FhNWRmLCAweDhjOGYwMzhjLCAweGExZjg1OWExLCAweDg5ODAwOTg5LCAweDBkMTcxYTBkLCAweGJmZGE2NWJmLCAweGU2MzFkN2U2LCAweDQyYzY4NDQyLCAweDY4YjhkMDY4LCAweDQxYzM4MjQxLCAweDk5YjAyOTk5LCAweDJkNzc1YTJkLCAweDBmMTExZTBmLCAweGIwY2I3YmIwLCAweDU0ZmNhODU0LCAweGJiZDY2ZGJiLCAweDE2M2EyYzE2XTtcclxuY29uc3QgVDQgPSBbMHg2MzYzYTVjNiwgMHg3YzdjODRmOCwgMHg3Nzc3OTllZSwgMHg3YjdiOGRmNiwgMHhmMmYyMGRmZiwgMHg2YjZiYmRkNiwgMHg2ZjZmYjFkZSwgMHhjNWM1NTQ5MSwgMHgzMDMwNTA2MCwgMHgwMTAxMDMwMiwgMHg2NzY3YTljZSwgMHgyYjJiN2Q1NiwgMHhmZWZlMTllNywgMHhkN2Q3NjJiNSwgMHhhYmFiZTY0ZCwgMHg3Njc2OWFlYywgMHhjYWNhNDU4ZiwgMHg4MjgyOWQxZiwgMHhjOWM5NDA4OSwgMHg3ZDdkODdmYSwgMHhmYWZhMTVlZiwgMHg1OTU5ZWJiMiwgMHg0NzQ3Yzk4ZSwgMHhmMGYwMGJmYiwgMHhhZGFkZWM0MSwgMHhkNGQ0NjdiMywgMHhhMmEyZmQ1ZiwgMHhhZmFmZWE0NSwgMHg5YzljYmYyMywgMHhhNGE0Zjc1MywgMHg3MjcyOTZlNCwgMHhjMGMwNWI5YiwgMHhiN2I3YzI3NSwgMHhmZGZkMWNlMSwgMHg5MzkzYWUzZCwgMHgyNjI2NmE0YywgMHgzNjM2NWE2YywgMHgzZjNmNDE3ZSwgMHhmN2Y3MDJmNSwgMHhjY2NjNGY4MywgMHgzNDM0NWM2OCwgMHhhNWE1ZjQ1MSwgMHhlNWU1MzRkMSwgMHhmMWYxMDhmOSwgMHg3MTcxOTNlMiwgMHhkOGQ4NzNhYiwgMHgzMTMxNTM2MiwgMHgxNTE1M2YyYSwgMHgwNDA0MGMwOCwgMHhjN2M3NTI5NSwgMHgyMzIzNjU0NiwgMHhjM2MzNWU5ZCwgMHgxODE4MjgzMCwgMHg5Njk2YTEzNywgMHgwNTA1MGYwYSwgMHg5YTlhYjUyZiwgMHgwNzA3MDkwZSwgMHgxMjEyMzYyNCwgMHg4MDgwOWIxYiwgMHhlMmUyM2RkZiwgMHhlYmViMjZjZCwgMHgyNzI3Njk0ZSwgMHhiMmIyY2Q3ZiwgMHg3NTc1OWZlYSwgMHgwOTA5MWIxMiwgMHg4MzgzOWUxZCwgMHgyYzJjNzQ1OCwgMHgxYTFhMmUzNCwgMHgxYjFiMmQzNiwgMHg2ZTZlYjJkYywgMHg1YTVhZWViNCwgMHhhMGEwZmI1YiwgMHg1MjUyZjZhNCwgMHgzYjNiNGQ3NiwgMHhkNmQ2NjFiNywgMHhiM2IzY2U3ZCwgMHgyOTI5N2I1MiwgMHhlM2UzM2VkZCwgMHgyZjJmNzE1ZSwgMHg4NDg0OTcxMywgMHg1MzUzZjVhNiwgMHhkMWQxNjhiOSwgMHgwMDAwMDAwMCwgMHhlZGVkMmNjMSwgMHgyMDIwNjA0MCwgMHhmY2ZjMWZlMywgMHhiMWIxYzg3OSwgMHg1YjViZWRiNiwgMHg2YTZhYmVkNCwgMHhjYmNiNDY4ZCwgMHhiZWJlZDk2NywgMHgzOTM5NGI3MiwgMHg0YTRhZGU5NCwgMHg0YzRjZDQ5OCwgMHg1ODU4ZThiMCwgMHhjZmNmNGE4NSwgMHhkMGQwNmJiYiwgMHhlZmVmMmFjNSwgMHhhYWFhZTU0ZiwgMHhmYmZiMTZlZCwgMHg0MzQzYzU4NiwgMHg0ZDRkZDc5YSwgMHgzMzMzNTU2NiwgMHg4NTg1OTQxMSwgMHg0NTQ1Y2Y4YSwgMHhmOWY5MTBlOSwgMHgwMjAyMDYwNCwgMHg3ZjdmODFmZSwgMHg1MDUwZjBhMCwgMHgzYzNjNDQ3OCwgMHg5ZjlmYmEyNSwgMHhhOGE4ZTM0YiwgMHg1MTUxZjNhMiwgMHhhM2EzZmU1ZCwgMHg0MDQwYzA4MCwgMHg4ZjhmOGEwNSwgMHg5MjkyYWQzZiwgMHg5ZDlkYmMyMSwgMHgzODM4NDg3MCwgMHhmNWY1MDRmMSwgMHhiY2JjZGY2MywgMHhiNmI2YzE3NywgMHhkYWRhNzVhZiwgMHgyMTIxNjM0MiwgMHgxMDEwMzAyMCwgMHhmZmZmMWFlNSwgMHhmM2YzMGVmZCwgMHhkMmQyNmRiZiwgMHhjZGNkNGM4MSwgMHgwYzBjMTQxOCwgMHgxMzEzMzUyNiwgMHhlY2VjMmZjMywgMHg1ZjVmZTFiZSwgMHg5Nzk3YTIzNSwgMHg0NDQ0Y2M4OCwgMHgxNzE3MzkyZSwgMHhjNGM0NTc5MywgMHhhN2E3ZjI1NSwgMHg3ZTdlODJmYywgMHgzZDNkNDc3YSwgMHg2NDY0YWNjOCwgMHg1ZDVkZTdiYSwgMHgxOTE5MmIzMiwgMHg3MzczOTVlNiwgMHg2MDYwYTBjMCwgMHg4MTgxOTgxOSwgMHg0ZjRmZDE5ZSwgMHhkY2RjN2ZhMywgMHgyMjIyNjY0NCwgMHgyYTJhN2U1NCwgMHg5MDkwYWIzYiwgMHg4ODg4ODMwYiwgMHg0NjQ2Y2E4YywgMHhlZWVlMjljNywgMHhiOGI4ZDM2YiwgMHgxNDE0M2MyOCwgMHhkZWRlNzlhNywgMHg1ZTVlZTJiYywgMHgwYjBiMWQxNiwgMHhkYmRiNzZhZCwgMHhlMGUwM2JkYiwgMHgzMjMyNTY2NCwgMHgzYTNhNGU3NCwgMHgwYTBhMWUxNCwgMHg0OTQ5ZGI5MiwgMHgwNjA2MGEwYywgMHgyNDI0NmM0OCwgMHg1YzVjZTRiOCwgMHhjMmMyNWQ5ZiwgMHhkM2QzNmViZCwgMHhhY2FjZWY0MywgMHg2MjYyYTZjNCwgMHg5MTkxYTgzOSwgMHg5NTk1YTQzMSwgMHhlNGU0MzdkMywgMHg3OTc5OGJmMiwgMHhlN2U3MzJkNSwgMHhjOGM4NDM4YiwgMHgzNzM3NTk2ZSwgMHg2ZDZkYjdkYSwgMHg4ZDhkOGMwMSwgMHhkNWQ1NjRiMSwgMHg0ZTRlZDI5YywgMHhhOWE5ZTA0OSwgMHg2YzZjYjRkOCwgMHg1NjU2ZmFhYywgMHhmNGY0MDdmMywgMHhlYWVhMjVjZiwgMHg2NTY1YWZjYSwgMHg3YTdhOGVmNCwgMHhhZWFlZTk0NywgMHgwODA4MTgxMCwgMHhiYWJhZDU2ZiwgMHg3ODc4ODhmMCwgMHgyNTI1NmY0YSwgMHgyZTJlNzI1YywgMHgxYzFjMjQzOCwgMHhhNmE2ZjE1NywgMHhiNGI0Yzc3MywgMHhjNmM2NTE5NywgMHhlOGU4MjNjYiwgMHhkZGRkN2NhMSwgMHg3NDc0OWNlOCwgMHgxZjFmMjEzZSwgMHg0YjRiZGQ5NiwgMHhiZGJkZGM2MSwgMHg4YjhiODYwZCwgMHg4YThhODUwZiwgMHg3MDcwOTBlMCwgMHgzZTNlNDI3YywgMHhiNWI1YzQ3MSwgMHg2NjY2YWFjYywgMHg0ODQ4ZDg5MCwgMHgwMzAzMDUwNiwgMHhmNmY2MDFmNywgMHgwZTBlMTIxYywgMHg2MTYxYTNjMiwgMHgzNTM1NWY2YSwgMHg1NzU3ZjlhZSwgMHhiOWI5ZDA2OSwgMHg4Njg2OTExNywgMHhjMWMxNTg5OSwgMHgxZDFkMjczYSwgMHg5ZTllYjkyNywgMHhlMWUxMzhkOSwgMHhmOGY4MTNlYiwgMHg5ODk4YjMyYiwgMHgxMTExMzMyMiwgMHg2OTY5YmJkMiwgMHhkOWQ5NzBhOSwgMHg4ZThlODkwNywgMHg5NDk0YTczMywgMHg5YjliYjYyZCwgMHgxZTFlMjIzYywgMHg4Nzg3OTIxNSwgMHhlOWU5MjBjOSwgMHhjZWNlNDk4NywgMHg1NTU1ZmZhYSwgMHgyODI4Nzg1MCwgMHhkZmRmN2FhNSwgMHg4YzhjOGYwMywgMHhhMWExZjg1OSwgMHg4OTg5ODAwOSwgMHgwZDBkMTcxYSwgMHhiZmJmZGE2NSwgMHhlNmU2MzFkNywgMHg0MjQyYzY4NCwgMHg2ODY4YjhkMCwgMHg0MTQxYzM4MiwgMHg5OTk5YjAyOSwgMHgyZDJkNzc1YSwgMHgwZjBmMTExZSwgMHhiMGIwY2I3YiwgMHg1NDU0ZmNhOCwgMHhiYmJiZDY2ZCwgMHgxNjE2M2EyY107XHJcbi8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjcnlwdGlvblxyXG5jb25zdCBUNSA9IFsweDUxZjRhNzUwLCAweDdlNDE2NTUzLCAweDFhMTdhNGMzLCAweDNhMjc1ZTk2LCAweDNiYWI2YmNiLCAweDFmOWQ0NWYxLCAweGFjZmE1OGFiLCAweDRiZTMwMzkzLCAweDIwMzBmYTU1LCAweGFkNzY2ZGY2LCAweDg4Y2M3NjkxLCAweGY1MDI0YzI1LCAweDRmZTVkN2ZjLCAweGM1MmFjYmQ3LCAweDI2MzU0NDgwLCAweGI1NjJhMzhmLCAweGRlYjE1YTQ5LCAweDI1YmExYjY3LCAweDQ1ZWEwZTk4LCAweDVkZmVjMGUxLCAweGMzMmY3NTAyLCAweDgxNGNmMDEyLCAweDhkNDY5N2EzLCAweDZiZDNmOWM2LCAweDAzOGY1ZmU3LCAweDE1OTI5Yzk1LCAweGJmNmQ3YWViLCAweDk1NTI1OWRhLCAweGQ0YmU4MzJkLCAweDU4NzQyMWQzLCAweDQ5ZTA2OTI5LCAweDhlYzljODQ0LCAweDc1YzI4OTZhLCAweGY0OGU3OTc4LCAweDk5NTgzZTZiLCAweDI3Yjk3MWRkLCAweGJlZTE0ZmI2LCAweGYwODhhZDE3LCAweGM5MjBhYzY2LCAweDdkY2UzYWI0LCAweDYzZGY0YTE4LCAweGU1MWEzMTgyLCAweDk3NTEzMzYwLCAweDYyNTM3ZjQ1LCAweGIxNjQ3N2UwLCAweGJiNmJhZTg0LCAweGZlODFhMDFjLCAweGY5MDgyYjk0LCAweDcwNDg2ODU4LCAweDhmNDVmZDE5LCAweDk0ZGU2Yzg3LCAweDUyN2JmOGI3LCAweGFiNzNkMzIzLCAweDcyNGIwMmUyLCAweGUzMWY4ZjU3LCAweDY2NTVhYjJhLCAweGIyZWIyODA3LCAweDJmYjVjMjAzLCAweDg2YzU3YjlhLCAweGQzMzcwOGE1LCAweDMwMjg4N2YyLCAweDIzYmZhNWIyLCAweDAyMDM2YWJhLCAweGVkMTY4MjVjLCAweDhhY2YxYzJiLCAweGE3NzliNDkyLCAweGYzMDdmMmYwLCAweDRlNjllMmExLCAweDY1ZGFmNGNkLCAweDA2MDViZWQ1LCAweGQxMzQ2MjFmLCAweGM0YTZmZThhLCAweDM0MmU1MzlkLCAweGEyZjM1NWEwLCAweDA1OGFlMTMyLCAweGE0ZjZlYjc1LCAweDBiODNlYzM5LCAweDQwNjBlZmFhLCAweDVlNzE5ZjA2LCAweGJkNmUxMDUxLCAweDNlMjE4YWY5LCAweDk2ZGQwNjNkLCAweGRkM2UwNWFlLCAweDRkZTZiZDQ2LCAweDkxNTQ4ZGI1LCAweDcxYzQ1ZDA1LCAweDA0MDZkNDZmLCAweDYwNTAxNWZmLCAweDE5OThmYjI0LCAweGQ2YmRlOTk3LCAweDg5NDA0M2NjLCAweDY3ZDk5ZTc3LCAweGIwZTg0MmJkLCAweDA3ODk4Yjg4LCAweGU3MTk1YjM4LCAweDc5YzhlZWRiLCAweGExN2MwYTQ3LCAweDdjNDIwZmU5LCAweGY4ODQxZWM5LCAweDAwMDAwMDAwLCAweDA5ODA4NjgzLCAweDMyMmJlZDQ4LCAweDFlMTE3MGFjLCAweDZjNWE3MjRlLCAweGZkMGVmZmZiLCAweDBmODUzODU2LCAweDNkYWVkNTFlLCAweDM2MmQzOTI3LCAweDBhMGZkOTY0LCAweDY4NWNhNjIxLCAweDliNWI1NGQxLCAweDI0MzYyZTNhLCAweDBjMGE2N2IxLCAweDkzNTdlNzBmLCAweGI0ZWU5NmQyLCAweDFiOWI5MTllLCAweDgwYzBjNTRmLCAweDYxZGMyMGEyLCAweDVhNzc0YjY5LCAweDFjMTIxYTE2LCAweGUyOTNiYTBhLCAweGMwYTAyYWU1LCAweDNjMjJlMDQzLCAweDEyMWIxNzFkLCAweDBlMDkwZDBiLCAweGYyOGJjN2FkLCAweDJkYjZhOGI5LCAweDE0MWVhOWM4LCAweDU3ZjExOTg1LCAweGFmNzUwNzRjLCAweGVlOTlkZGJiLCAweGEzN2Y2MGZkLCAweGY3MDEyNjlmLCAweDVjNzJmNWJjLCAweDQ0NjYzYmM1LCAweDViZmI3ZTM0LCAweDhiNDMyOTc2LCAweGNiMjNjNmRjLCAweGI2ZWRmYzY4LCAweGI4ZTRmMTYzLCAweGQ3MzFkY2NhLCAweDQyNjM4NTEwLCAweDEzOTcyMjQwLCAweDg0YzYxMTIwLCAweDg1NGEyNDdkLCAweGQyYmIzZGY4LCAweGFlZjkzMjExLCAweGM3MjlhMTZkLCAweDFkOWUyZjRiLCAweGRjYjIzMGYzLCAweDBkODY1MmVjLCAweDc3YzFlM2QwLCAweDJiYjMxNjZjLCAweGE5NzBiOTk5LCAweDExOTQ0OGZhLCAweDQ3ZTk2NDIyLCAweGE4ZmM4Y2M0LCAweGEwZjAzZjFhLCAweDU2N2QyY2Q4LCAweDIyMzM5MGVmLCAweDg3NDk0ZWM3LCAweGQ5MzhkMWMxLCAweDhjY2FhMmZlLCAweDk4ZDQwYjM2LCAweGE2ZjU4MWNmLCAweGE1N2FkZTI4LCAweGRhYjc4ZTI2LCAweDNmYWRiZmE0LCAweDJjM2E5ZGU0LCAweDUwNzg5MjBkLCAweDZhNWZjYzliLCAweDU0N2U0NjYyLCAweGY2OGQxM2MyLCAweDkwZDhiOGU4LCAweDJlMzlmNzVlLCAweDgyYzNhZmY1LCAweDlmNWQ4MGJlLCAweDY5ZDA5MzdjLCAweDZmZDUyZGE5LCAweGNmMjUxMmIzLCAweGM4YWM5OTNiLCAweDEwMTg3ZGE3LCAweGU4OWM2MzZlLCAweGRiM2JiYjdiLCAweGNkMjY3ODA5LCAweDZlNTkxOGY0LCAweGVjOWFiNzAxLCAweDgzNGY5YWE4LCAweGU2OTU2ZTY1LCAweGFhZmZlNjdlLCAweDIxYmNjZjA4LCAweGVmMTVlOGU2LCAweGJhZTc5YmQ5LCAweDRhNmYzNmNlLCAweGVhOWYwOWQ0LCAweDI5YjA3Y2Q2LCAweDMxYTRiMmFmLCAweDJhM2YyMzMxLCAweGM2YTU5NDMwLCAweDM1YTI2NmMwLCAweDc0NGViYzM3LCAweGZjODJjYWE2LCAweGUwOTBkMGIwLCAweDMzYTdkODE1LCAweGYxMDQ5ODRhLCAweDQxZWNkYWY3LCAweDdmY2Q1MDBlLCAweDE3OTFmNjJmLCAweDc2NGRkNjhkLCAweDQzZWZiMDRkLCAweGNjYWE0ZDU0LCAweGU0OTYwNGRmLCAweDllZDFiNWUzLCAweDRjNmE4ODFiLCAweGMxMmMxZmI4LCAweDQ2NjU1MTdmLCAweDlkNWVlYTA0LCAweDAxOGMzNTVkLCAweGZhODc3NDczLCAweGZiMGI0MTJlLCAweGIzNjcxZDVhLCAweDkyZGJkMjUyLCAweGU5MTA1NjMzLCAweDZkZDY0NzEzLCAweDlhZDc2MThjLCAweDM3YTEwYzdhLCAweDU5ZjgxNDhlLCAweGViMTMzYzg5LCAweGNlYTkyN2VlLCAweGI3NjFjOTM1LCAweGUxMWNlNWVkLCAweDdhNDdiMTNjLCAweDljZDJkZjU5LCAweDU1ZjI3MzNmLCAweDE4MTRjZTc5LCAweDczYzczN2JmLCAweDUzZjdjZGVhLCAweDVmZmRhYTViLCAweGRmM2Q2ZjE0LCAweDc4NDRkYjg2LCAweGNhYWZmMzgxLCAweGI5NjhjNDNlLCAweDM4MjQzNDJjLCAweGMyYTM0MDVmLCAweDE2MWRjMzcyLCAweGJjZTIyNTBjLCAweDI4M2M0OThiLCAweGZmMGQ5NTQxLCAweDM5YTgwMTcxLCAweDA4MGNiM2RlLCAweGQ4YjRlNDljLCAweDY0NTZjMTkwLCAweDdiY2I4NDYxLCAweGQ1MzJiNjcwLCAweDQ4NmM1Yzc0LCAweGQwYjg1NzQyXTtcclxuY29uc3QgVDYgPSBbMHg1MDUxZjRhNywgMHg1MzdlNDE2NSwgMHhjMzFhMTdhNCwgMHg5NjNhMjc1ZSwgMHhjYjNiYWI2YiwgMHhmMTFmOWQ0NSwgMHhhYmFjZmE1OCwgMHg5MzRiZTMwMywgMHg1NTIwMzBmYSwgMHhmNmFkNzY2ZCwgMHg5MTg4Y2M3NiwgMHgyNWY1MDI0YywgMHhmYzRmZTVkNywgMHhkN2M1MmFjYiwgMHg4MDI2MzU0NCwgMHg4ZmI1NjJhMywgMHg0OWRlYjE1YSwgMHg2NzI1YmExYiwgMHg5ODQ1ZWEwZSwgMHhlMTVkZmVjMCwgMHgwMmMzMmY3NSwgMHgxMjgxNGNmMCwgMHhhMzhkNDY5NywgMHhjNjZiZDNmOSwgMHhlNzAzOGY1ZiwgMHg5NTE1OTI5YywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHgyZGQ0YmU4MywgMHhkMzU4NzQyMSwgMHgyOTQ5ZTA2OSwgMHg0NDhlYzljOCwgMHg2YTc1YzI4OSwgMHg3OGY0OGU3OSwgMHg2Yjk5NTgzZSwgMHhkZDI3Yjk3MSwgMHhiNmJlZTE0ZiwgMHgxN2YwODhhZCwgMHg2NmM5MjBhYywgMHhiNDdkY2UzYSwgMHgxODYzZGY0YSwgMHg4MmU1MWEzMSwgMHg2MDk3NTEzMywgMHg0NTYyNTM3ZiwgMHhlMGIxNjQ3NywgMHg4NGJiNmJhZSwgMHgxY2ZlODFhMCwgMHg5NGY5MDgyYiwgMHg1ODcwNDg2OCwgMHgxOThmNDVmZCwgMHg4Nzk0ZGU2YywgMHhiNzUyN2JmOCwgMHgyM2FiNzNkMywgMHhlMjcyNGIwMiwgMHg1N2UzMWY4ZiwgMHgyYTY2NTVhYiwgMHgwN2IyZWIyOCwgMHgwMzJmYjVjMiwgMHg5YTg2YzU3YiwgMHhhNWQzMzcwOCwgMHhmMjMwMjg4NywgMHhiMjIzYmZhNSwgMHhiYTAyMDM2YSwgMHg1Y2VkMTY4MiwgMHgyYjhhY2YxYywgMHg5MmE3NzliNCwgMHhmMGYzMDdmMiwgMHhhMTRlNjllMiwgMHhjZDY1ZGFmNCwgMHhkNTA2MDViZSwgMHgxZmQxMzQ2MiwgMHg4YWM0YTZmZSwgMHg5ZDM0MmU1MywgMHhhMGEyZjM1NSwgMHgzMjA1OGFlMSwgMHg3NWE0ZjZlYiwgMHgzOTBiODNlYywgMHhhYTQwNjBlZiwgMHgwNjVlNzE5ZiwgMHg1MWJkNmUxMCwgMHhmOTNlMjE4YSwgMHgzZDk2ZGQwNiwgMHhhZWRkM2UwNSwgMHg0NjRkZTZiZCwgMHhiNTkxNTQ4ZCwgMHgwNTcxYzQ1ZCwgMHg2ZjA0MDZkNCwgMHhmZjYwNTAxNSwgMHgyNDE5OThmYiwgMHg5N2Q2YmRlOSwgMHhjYzg5NDA0MywgMHg3NzY3ZDk5ZSwgMHhiZGIwZTg0MiwgMHg4ODA3ODk4YiwgMHgzOGU3MTk1YiwgMHhkYjc5YzhlZSwgMHg0N2ExN2MwYSwgMHhlOTdjNDIwZiwgMHhjOWY4ODQxZSwgMHgwMDAwMDAwMCwgMHg4MzA5ODA4NiwgMHg0ODMyMmJlZCwgMHhhYzFlMTE3MCwgMHg0ZTZjNWE3MiwgMHhmYmZkMGVmZiwgMHg1NjBmODUzOCwgMHgxZTNkYWVkNSwgMHgyNzM2MmQzOSwgMHg2NDBhMGZkOSwgMHgyMTY4NWNhNiwgMHhkMTliNWI1NCwgMHgzYTI0MzYyZSwgMHhiMTBjMGE2NywgMHgwZjkzNTdlNywgMHhkMmI0ZWU5NiwgMHg5ZTFiOWI5MSwgMHg0ZjgwYzBjNSwgMHhhMjYxZGMyMCwgMHg2OTVhNzc0YiwgMHgxNjFjMTIxYSwgMHgwYWUyOTNiYSwgMHhlNWMwYTAyYSwgMHg0MzNjMjJlMCwgMHgxZDEyMWIxNywgMHgwYjBlMDkwZCwgMHhhZGYyOGJjNywgMHhiOTJkYjZhOCwgMHhjODE0MWVhOSwgMHg4NTU3ZjExOSwgMHg0Y2FmNzUwNywgMHhiYmVlOTlkZCwgMHhmZGEzN2Y2MCwgMHg5ZmY3MDEyNiwgMHhiYzVjNzJmNSwgMHhjNTQ0NjYzYiwgMHgzNDViZmI3ZSwgMHg3NjhiNDMyOSwgMHhkY2NiMjNjNiwgMHg2OGI2ZWRmYywgMHg2M2I4ZTRmMSwgMHhjYWQ3MzFkYywgMHgxMDQyNjM4NSwgMHg0MDEzOTcyMiwgMHgyMDg0YzYxMSwgMHg3ZDg1NGEyNCwgMHhmOGQyYmIzZCwgMHgxMWFlZjkzMiwgMHg2ZGM3MjlhMSwgMHg0YjFkOWUyZiwgMHhmM2RjYjIzMCwgMHhlYzBkODY1MiwgMHhkMDc3YzFlMywgMHg2YzJiYjMxNiwgMHg5OWE5NzBiOSwgMHhmYTExOTQ0OCwgMHgyMjQ3ZTk2NCwgMHhjNGE4ZmM4YywgMHgxYWEwZjAzZiwgMHhkODU2N2QyYywgMHhlZjIyMzM5MCwgMHhjNzg3NDk0ZSwgMHhjMWQ5MzhkMSwgMHhmZThjY2FhMiwgMHgzNjk4ZDQwYiwgMHhjZmE2ZjU4MSwgMHgyOGE1N2FkZSwgMHgyNmRhYjc4ZSwgMHhhNDNmYWRiZiwgMHhlNDJjM2E5ZCwgMHgwZDUwNzg5MiwgMHg5YjZhNWZjYywgMHg2MjU0N2U0NiwgMHhjMmY2OGQxMywgMHhlODkwZDhiOCwgMHg1ZTJlMzlmNywgMHhmNTgyYzNhZiwgMHhiZTlmNWQ4MCwgMHg3YzY5ZDA5MywgMHhhOTZmZDUyZCwgMHhiM2NmMjUxMiwgMHgzYmM4YWM5OSwgMHhhNzEwMTg3ZCwgMHg2ZWU4OWM2MywgMHg3YmRiM2JiYiwgMHgwOWNkMjY3OCwgMHhmNDZlNTkxOCwgMHgwMWVjOWFiNywgMHhhODgzNGY5YSwgMHg2NWU2OTU2ZSwgMHg3ZWFhZmZlNiwgMHgwODIxYmNjZiwgMHhlNmVmMTVlOCwgMHhkOWJhZTc5YiwgMHhjZTRhNmYzNiwgMHhkNGVhOWYwOSwgMHhkNjI5YjA3YywgMHhhZjMxYTRiMiwgMHgzMTJhM2YyMywgMHgzMGM2YTU5NCwgMHhjMDM1YTI2NiwgMHgzNzc0NGViYywgMHhhNmZjODJjYSwgMHhiMGUwOTBkMCwgMHgxNTMzYTdkOCwgMHg0YWYxMDQ5OCwgMHhmNzQxZWNkYSwgMHgwZTdmY2Q1MCwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg0ZDQzZWZiMCwgMHg1NGNjYWE0ZCwgMHhkZmU0OTYwNCwgMHhlMzllZDFiNSwgMHgxYjRjNmE4OCwgMHhiOGMxMmMxZiwgMHg3ZjQ2NjU1MSwgMHgwNDlkNWVlYSwgMHg1ZDAxOGMzNSwgMHg3M2ZhODc3NCwgMHgyZWZiMGI0MSwgMHg1YWIzNjcxZCwgMHg1MjkyZGJkMiwgMHgzM2U5MTA1NiwgMHgxMzZkZDY0NywgMHg4YzlhZDc2MSwgMHg3YTM3YTEwYywgMHg4ZTU5ZjgxNCwgMHg4OWViMTMzYywgMHhlZWNlYTkyNywgMHgzNWI3NjFjOSwgMHhlZGUxMWNlNSwgMHgzYzdhNDdiMSwgMHg1OTljZDJkZiwgMHgzZjU1ZjI3MywgMHg3OTE4MTRjZSwgMHhiZjczYzczNywgMHhlYTUzZjdjZCwgMHg1YjVmZmRhYSwgMHgxNGRmM2Q2ZiwgMHg4Njc4NDRkYiwgMHg4MWNhYWZmMywgMHgzZWI5NjhjNCwgMHgyYzM4MjQzNCwgMHg1ZmMyYTM0MCwgMHg3MjE2MWRjMywgMHgwY2JjZTIyNSwgMHg4YjI4M2M0OSwgMHg0MWZmMGQ5NSwgMHg3MTM5YTgwMSwgMHhkZTA4MGNiMywgMHg5Y2Q4YjRlNCwgMHg5MDY0NTZjMSwgMHg2MTdiY2I4NCwgMHg3MGQ1MzJiNiwgMHg3NDQ4NmM1YywgMHg0MmQwYjg1N107XHJcbmNvbnN0IFQ3ID0gWzB4YTc1MDUxZjQsIDB4NjU1MzdlNDEsIDB4YTRjMzFhMTcsIDB4NWU5NjNhMjcsIDB4NmJjYjNiYWIsIDB4NDVmMTFmOWQsIDB4NThhYmFjZmEsIDB4MDM5MzRiZTMsIDB4ZmE1NTIwMzAsIDB4NmRmNmFkNzYsIDB4NzY5MTg4Y2MsIDB4NGMyNWY1MDIsIDB4ZDdmYzRmZTUsIDB4Y2JkN2M1MmEsIDB4NDQ4MDI2MzUsIDB4YTM4ZmI1NjIsIDB4NWE0OWRlYjEsIDB4MWI2NzI1YmEsIDB4MGU5ODQ1ZWEsIDB4YzBlMTVkZmUsIDB4NzUwMmMzMmYsIDB4ZjAxMjgxNGMsIDB4OTdhMzhkNDYsIDB4ZjljNjZiZDMsIDB4NWZlNzAzOGYsIDB4OWM5NTE1OTIsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4ODMyZGQ0YmUsIDB4MjFkMzU4NzQsIDB4NjkyOTQ5ZTAsIDB4Yzg0NDhlYzksIDB4ODk2YTc1YzIsIDB4Nzk3OGY0OGUsIDB4M2U2Yjk5NTgsIDB4NzFkZDI3YjksIDB4NGZiNmJlZTEsIDB4YWQxN2YwODgsIDB4YWM2NmM5MjAsIDB4M2FiNDdkY2UsIDB4NGExODYzZGYsIDB4MzE4MmU1MWEsIDB4MzM2MDk3NTEsIDB4N2Y0NTYyNTMsIDB4NzdlMGIxNjQsIDB4YWU4NGJiNmIsIDB4YTAxY2ZlODEsIDB4MmI5NGY5MDgsIDB4Njg1ODcwNDgsIDB4ZmQxOThmNDUsIDB4NmM4Nzk0ZGUsIDB4ZjhiNzUyN2IsIDB4ZDMyM2FiNzMsIDB4MDJlMjcyNGIsIDB4OGY1N2UzMWYsIDB4YWIyYTY2NTUsIDB4MjgwN2IyZWIsIDB4YzIwMzJmYjUsIDB4N2I5YTg2YzUsIDB4MDhhNWQzMzcsIDB4ODdmMjMwMjgsIDB4YTViMjIzYmYsIDB4NmFiYTAyMDMsIDB4ODI1Y2VkMTYsIDB4MWMyYjhhY2YsIDB4YjQ5MmE3NzksIDB4ZjJmMGYzMDcsIDB4ZTJhMTRlNjksIDB4ZjRjZDY1ZGEsIDB4YmVkNTA2MDUsIDB4NjIxZmQxMzQsIDB4ZmU4YWM0YTYsIDB4NTM5ZDM0MmUsIDB4NTVhMGEyZjMsIDB4ZTEzMjA1OGEsIDB4ZWI3NWE0ZjYsIDB4ZWMzOTBiODMsIDB4ZWZhYTQwNjAsIDB4OWYwNjVlNzEsIDB4MTA1MWJkNmUsIDB4OGFmOTNlMjEsIDB4MDYzZDk2ZGQsIDB4MDVhZWRkM2UsIDB4YmQ0NjRkZTYsIDB4OGRiNTkxNTQsIDB4NWQwNTcxYzQsIDB4ZDQ2ZjA0MDYsIDB4MTVmZjYwNTAsIDB4ZmIyNDE5OTgsIDB4ZTk5N2Q2YmQsIDB4NDNjYzg5NDAsIDB4OWU3NzY3ZDksIDB4NDJiZGIwZTgsIDB4OGI4ODA3ODksIDB4NWIzOGU3MTksIDB4ZWVkYjc5YzgsIDB4MGE0N2ExN2MsIDB4MGZlOTdjNDIsIDB4MWVjOWY4ODQsIDB4MDAwMDAwMDAsIDB4ODY4MzA5ODAsIDB4ZWQ0ODMyMmIsIDB4NzBhYzFlMTEsIDB4NzI0ZTZjNWEsIDB4ZmZmYmZkMGUsIDB4Mzg1NjBmODUsIDB4ZDUxZTNkYWUsIDB4MzkyNzM2MmQsIDB4ZDk2NDBhMGYsIDB4YTYyMTY4NWMsIDB4NTRkMTliNWIsIDB4MmUzYTI0MzYsIDB4NjdiMTBjMGEsIDB4ZTcwZjkzNTcsIDB4OTZkMmI0ZWUsIDB4OTE5ZTFiOWIsIDB4YzU0ZjgwYzAsIDB4MjBhMjYxZGMsIDB4NGI2OTVhNzcsIDB4MWExNjFjMTIsIDB4YmEwYWUyOTMsIDB4MmFlNWMwYTAsIDB4ZTA0MzNjMjIsIDB4MTcxZDEyMWIsIDB4MGQwYjBlMDksIDB4YzdhZGYyOGIsIDB4YThiOTJkYjYsIDB4YTljODE0MWUsIDB4MTk4NTU3ZjEsIDB4MDc0Y2FmNzUsIDB4ZGRiYmVlOTksIDB4NjBmZGEzN2YsIDB4MjY5ZmY3MDEsIDB4ZjViYzVjNzIsIDB4M2JjNTQ0NjYsIDB4N2UzNDViZmIsIDB4Mjk3NjhiNDMsIDB4YzZkY2NiMjMsIDB4ZmM2OGI2ZWQsIDB4ZjE2M2I4ZTQsIDB4ZGNjYWQ3MzEsIDB4ODUxMDQyNjMsIDB4MjI0MDEzOTcsIDB4MTEyMDg0YzYsIDB4MjQ3ZDg1NGEsIDB4M2RmOGQyYmIsIDB4MzIxMWFlZjksIDB4YTE2ZGM3MjksIDB4MmY0YjFkOWUsIDB4MzBmM2RjYjIsIDB4NTJlYzBkODYsIDB4ZTNkMDc3YzEsIDB4MTY2YzJiYjMsIDB4Yjk5OWE5NzAsIDB4NDhmYTExOTQsIDB4NjQyMjQ3ZTksIDB4OGNjNGE4ZmMsIDB4M2YxYWEwZjAsIDB4MmNkODU2N2QsIDB4OTBlZjIyMzMsIDB4NGVjNzg3NDksIDB4ZDFjMWQ5MzgsIDB4YTJmZThjY2EsIDB4MGIzNjk4ZDQsIDB4ODFjZmE2ZjUsIDB4ZGUyOGE1N2EsIDB4OGUyNmRhYjcsIDB4YmZhNDNmYWQsIDB4OWRlNDJjM2EsIDB4OTIwZDUwNzgsIDB4Y2M5YjZhNWYsIDB4NDY2MjU0N2UsIDB4MTNjMmY2OGQsIDB4YjhlODkwZDgsIDB4Zjc1ZTJlMzksIDB4YWZmNTgyYzMsIDB4ODBiZTlmNWQsIDB4OTM3YzY5ZDAsIDB4MmRhOTZmZDUsIDB4MTJiM2NmMjUsIDB4OTkzYmM4YWMsIDB4N2RhNzEwMTgsIDB4NjM2ZWU4OWMsIDB4YmI3YmRiM2IsIDB4NzgwOWNkMjYsIDB4MThmNDZlNTksIDB4YjcwMWVjOWEsIDB4OWFhODgzNGYsIDB4NmU2NWU2OTUsIDB4ZTY3ZWFhZmYsIDB4Y2YwODIxYmMsIDB4ZThlNmVmMTUsIDB4OWJkOWJhZTcsIDB4MzZjZTRhNmYsIDB4MDlkNGVhOWYsIDB4N2NkNjI5YjAsIDB4YjJhZjMxYTQsIDB4MjMzMTJhM2YsIDB4OTQzMGM2YTUsIDB4NjZjMDM1YTIsIDB4YmMzNzc0NGUsIDB4Y2FhNmZjODIsIDB4ZDBiMGUwOTAsIDB4ZDgxNTMzYTcsIDB4OTg0YWYxMDQsIDB4ZGFmNzQxZWMsIDB4NTAwZTdmY2QsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4YjA0ZDQzZWYsIDB4NGQ1NGNjYWEsIDB4MDRkZmU0OTYsIDB4YjVlMzllZDEsIDB4ODgxYjRjNmEsIDB4MWZiOGMxMmMsIDB4NTE3ZjQ2NjUsIDB4ZWEwNDlkNWUsIDB4MzU1ZDAxOGMsIDB4NzQ3M2ZhODcsIDB4NDEyZWZiMGIsIDB4MWQ1YWIzNjcsIDB4ZDI1MjkyZGIsIDB4NTYzM2U5MTAsIDB4NDcxMzZkZDYsIDB4NjE4YzlhZDcsIDB4MGM3YTM3YTEsIDB4MTQ4ZTU5ZjgsIDB4M2M4OWViMTMsIDB4MjdlZWNlYTksIDB4YzkzNWI3NjEsIDB4ZTVlZGUxMWMsIDB4YjEzYzdhNDcsIDB4ZGY1OTljZDIsIDB4NzMzZjU1ZjIsIDB4Y2U3OTE4MTQsIDB4MzdiZjczYzcsIDB4Y2RlYTUzZjcsIDB4YWE1YjVmZmQsIDB4NmYxNGRmM2QsIDB4ZGI4Njc4NDQsIDB4ZjM4MWNhYWYsIDB4YzQzZWI5NjgsIDB4MzQyYzM4MjQsIDB4NDA1ZmMyYTMsIDB4YzM3MjE2MWQsIDB4MjUwY2JjZTIsIDB4NDk4YjI4M2MsIDB4OTU0MWZmMGQsIDB4MDE3MTM5YTgsIDB4YjNkZTA4MGMsIDB4ZTQ5Y2Q4YjQsIDB4YzE5MDY0NTYsIDB4ODQ2MTdiY2IsIDB4YjY3MGQ1MzIsIDB4NWM3NDQ4NmMsIDB4NTc0MmQwYjhdO1xyXG5jb25zdCBUOCA9IFsweGY0YTc1MDUxLCAweDQxNjU1MzdlLCAweDE3YTRjMzFhLCAweDI3NWU5NjNhLCAweGFiNmJjYjNiLCAweDlkNDVmMTFmLCAweGZhNThhYmFjLCAweGUzMDM5MzRiLCAweDMwZmE1NTIwLCAweDc2NmRmNmFkLCAweGNjNzY5MTg4LCAweDAyNGMyNWY1LCAweGU1ZDdmYzRmLCAweDJhY2JkN2M1LCAweDM1NDQ4MDI2LCAweDYyYTM4ZmI1LCAweGIxNWE0OWRlLCAweGJhMWI2NzI1LCAweGVhMGU5ODQ1LCAweGZlYzBlMTVkLCAweDJmNzUwMmMzLCAweDRjZjAxMjgxLCAweDQ2OTdhMzhkLCAweGQzZjljNjZiLCAweDhmNWZlNzAzLCAweDkyOWM5NTE1LCAweDZkN2FlYmJmLCAweDUyNTlkYTk1LCAweGJlODMyZGQ0LCAweDc0MjFkMzU4LCAweGUwNjkyOTQ5LCAweGM5Yzg0NDhlLCAweGMyODk2YTc1LCAweDhlNzk3OGY0LCAweDU4M2U2Yjk5LCAweGI5NzFkZDI3LCAweGUxNGZiNmJlLCAweDg4YWQxN2YwLCAweDIwYWM2NmM5LCAweGNlM2FiNDdkLCAweGRmNGExODYzLCAweDFhMzE4MmU1LCAweDUxMzM2MDk3LCAweDUzN2Y0NTYyLCAweDY0NzdlMGIxLCAweDZiYWU4NGJiLCAweDgxYTAxY2ZlLCAweDA4MmI5NGY5LCAweDQ4Njg1ODcwLCAweDQ1ZmQxOThmLCAweGRlNmM4Nzk0LCAweDdiZjhiNzUyLCAweDczZDMyM2FiLCAweDRiMDJlMjcyLCAweDFmOGY1N2UzLCAweDU1YWIyYTY2LCAweGViMjgwN2IyLCAweGI1YzIwMzJmLCAweGM1N2I5YTg2LCAweDM3MDhhNWQzLCAweDI4ODdmMjMwLCAweGJmYTViMjIzLCAweDAzNmFiYTAyLCAweDE2ODI1Y2VkLCAweGNmMWMyYjhhLCAweDc5YjQ5MmE3LCAweDA3ZjJmMGYzLCAweDY5ZTJhMTRlLCAweGRhZjRjZDY1LCAweDA1YmVkNTA2LCAweDM0NjIxZmQxLCAweGE2ZmU4YWM0LCAweDJlNTM5ZDM0LCAweGYzNTVhMGEyLCAweDhhZTEzMjA1LCAweGY2ZWI3NWE0LCAweDgzZWMzOTBiLCAweDYwZWZhYTQwLCAweDcxOWYwNjVlLCAweDZlMTA1MWJkLCAweDIxOGFmOTNlLCAweGRkMDYzZDk2LCAweDNlMDVhZWRkLCAweGU2YmQ0NjRkLCAweDU0OGRiNTkxLCAweGM0NWQwNTcxLCAweDA2ZDQ2ZjA0LCAweDUwMTVmZjYwLCAweDk4ZmIyNDE5LCAweGJkZTk5N2Q2LCAweDQwNDNjYzg5LCAweGQ5OWU3NzY3LCAweGU4NDJiZGIwLCAweDg5OGI4ODA3LCAweDE5NWIzOGU3LCAweGM4ZWVkYjc5LCAweDdjMGE0N2ExLCAweDQyMGZlOTdjLCAweDg0MWVjOWY4LCAweDAwMDAwMDAwLCAweDgwODY4MzA5LCAweDJiZWQ0ODMyLCAweDExNzBhYzFlLCAweDVhNzI0ZTZjLCAweDBlZmZmYmZkLCAweDg1Mzg1NjBmLCAweGFlZDUxZTNkLCAweDJkMzkyNzM2LCAweDBmZDk2NDBhLCAweDVjYTYyMTY4LCAweDViNTRkMTliLCAweDM2MmUzYTI0LCAweDBhNjdiMTBjLCAweDU3ZTcwZjkzLCAweGVlOTZkMmI0LCAweDliOTE5ZTFiLCAweGMwYzU0ZjgwLCAweGRjMjBhMjYxLCAweDc3NGI2OTVhLCAweDEyMWExNjFjLCAweDkzYmEwYWUyLCAweGEwMmFlNWMwLCAweDIyZTA0MzNjLCAweDFiMTcxZDEyLCAweDA5MGQwYjBlLCAweDhiYzdhZGYyLCAweGI2YThiOTJkLCAweDFlYTljODE0LCAweGYxMTk4NTU3LCAweDc1MDc0Y2FmLCAweDk5ZGRiYmVlLCAweDdmNjBmZGEzLCAweDAxMjY5ZmY3LCAweDcyZjViYzVjLCAweDY2M2JjNTQ0LCAweGZiN2UzNDViLCAweDQzMjk3NjhiLCAweDIzYzZkY2NiLCAweGVkZmM2OGI2LCAweGU0ZjE2M2I4LCAweDMxZGNjYWQ3LCAweDYzODUxMDQyLCAweDk3MjI0MDEzLCAweGM2MTEyMDg0LCAweDRhMjQ3ZDg1LCAweGJiM2RmOGQyLCAweGY5MzIxMWFlLCAweDI5YTE2ZGM3LCAweDllMmY0YjFkLCAweGIyMzBmM2RjLCAweDg2NTJlYzBkLCAweGMxZTNkMDc3LCAweGIzMTY2YzJiLCAweDcwYjk5OWE5LCAweDk0NDhmYTExLCAweGU5NjQyMjQ3LCAweGZjOGNjNGE4LCAweGYwM2YxYWEwLCAweDdkMmNkODU2LCAweDMzOTBlZjIyLCAweDQ5NGVjNzg3LCAweDM4ZDFjMWQ5LCAweGNhYTJmZThjLCAweGQ0MGIzNjk4LCAweGY1ODFjZmE2LCAweDdhZGUyOGE1LCAweGI3OGUyNmRhLCAweGFkYmZhNDNmLCAweDNhOWRlNDJjLCAweDc4OTIwZDUwLCAweDVmY2M5YjZhLCAweDdlNDY2MjU0LCAweDhkMTNjMmY2LCAweGQ4YjhlODkwLCAweDM5Zjc1ZTJlLCAweGMzYWZmNTgyLCAweDVkODBiZTlmLCAweGQwOTM3YzY5LCAweGQ1MmRhOTZmLCAweDI1MTJiM2NmLCAweGFjOTkzYmM4LCAweDE4N2RhNzEwLCAweDljNjM2ZWU4LCAweDNiYmI3YmRiLCAweDI2NzgwOWNkLCAweDU5MThmNDZlLCAweDlhYjcwMWVjLCAweDRmOWFhODgzLCAweDk1NmU2NWU2LCAweGZmZTY3ZWFhLCAweGJjY2YwODIxLCAweDE1ZThlNmVmLCAweGU3OWJkOWJhLCAweDZmMzZjZTRhLCAweDlmMDlkNGVhLCAweGIwN2NkNjI5LCAweGE0YjJhZjMxLCAweDNmMjMzMTJhLCAweGE1OTQzMGM2LCAweGEyNjZjMDM1LCAweDRlYmMzNzc0LCAweDgyY2FhNmZjLCAweDkwZDBiMGUwLCAweGE3ZDgxNTMzLCAweDA0OTg0YWYxLCAweGVjZGFmNzQxLCAweGNkNTAwZTdmLCAweDkxZjYyZjE3LCAweDRkZDY4ZDc2LCAweGVmYjA0ZDQzLCAweGFhNGQ1NGNjLCAweDk2MDRkZmU0LCAweGQxYjVlMzllLCAweDZhODgxYjRjLCAweDJjMWZiOGMxLCAweDY1NTE3ZjQ2LCAweDVlZWEwNDlkLCAweDhjMzU1ZDAxLCAweDg3NzQ3M2ZhLCAweDBiNDEyZWZiLCAweDY3MWQ1YWIzLCAweGRiZDI1MjkyLCAweDEwNTYzM2U5LCAweGQ2NDcxMzZkLCAweGQ3NjE4YzlhLCAweGExMGM3YTM3LCAweGY4MTQ4ZTU5LCAweDEzM2M4OWViLCAweGE5MjdlZWNlLCAweDYxYzkzNWI3LCAweDFjZTVlZGUxLCAweDQ3YjEzYzdhLCAweGQyZGY1OTljLCAweGYyNzMzZjU1LCAweDE0Y2U3OTE4LCAweGM3MzdiZjczLCAweGY3Y2RlYTUzLCAweGZkYWE1YjVmLCAweDNkNmYxNGRmLCAweDQ0ZGI4Njc4LCAweGFmZjM4MWNhLCAweDY4YzQzZWI5LCAweDI0MzQyYzM4LCAweGEzNDA1ZmMyLCAweDFkYzM3MjE2LCAweGUyMjUwY2JjLCAweDNjNDk4YjI4LCAweDBkOTU0MWZmLCAweGE4MDE3MTM5LCAweDBjYjNkZTA4LCAweGI0ZTQ5Y2Q4LCAweDU2YzE5MDY0LCAweGNiODQ2MTdiLCAweDMyYjY3MGQ1LCAweDZjNWM3NDQ4LCAweGI4NTc0MmQwXTtcclxuLy8gVHJhbnNmb3JtYXRpb25zIGZvciBkZWNyeXB0aW9uIGtleSBleHBhbnNpb25cclxuY29uc3QgVTEgPSBbMHgwMDAwMDAwMCwgMHgwZTA5MGQwYiwgMHgxYzEyMWExNiwgMHgxMjFiMTcxZCwgMHgzODI0MzQyYywgMHgzNjJkMzkyNywgMHgyNDM2MmUzYSwgMHgyYTNmMjMzMSwgMHg3MDQ4Njg1OCwgMHg3ZTQxNjU1MywgMHg2YzVhNzI0ZSwgMHg2MjUzN2Y0NSwgMHg0ODZjNWM3NCwgMHg0NjY1NTE3ZiwgMHg1NDdlNDY2MiwgMHg1YTc3NGI2OSwgMHhlMDkwZDBiMCwgMHhlZTk5ZGRiYiwgMHhmYzgyY2FhNiwgMHhmMjhiYzdhZCwgMHhkOGI0ZTQ5YywgMHhkNmJkZTk5NywgMHhjNGE2ZmU4YSwgMHhjYWFmZjM4MSwgMHg5MGQ4YjhlOCwgMHg5ZWQxYjVlMywgMHg4Y2NhYTJmZSwgMHg4MmMzYWZmNSwgMHhhOGZjOGNjNCwgMHhhNmY1ODFjZiwgMHhiNGVlOTZkMiwgMHhiYWU3OWJkOSwgMHhkYjNiYmI3YiwgMHhkNTMyYjY3MCwgMHhjNzI5YTE2ZCwgMHhjOTIwYWM2NiwgMHhlMzFmOGY1NywgMHhlZDE2ODI1YywgMHhmZjBkOTU0MSwgMHhmMTA0OTg0YSwgMHhhYjczZDMyMywgMHhhNTdhZGUyOCwgMHhiNzYxYzkzNSwgMHhiOTY4YzQzZSwgMHg5MzU3ZTcwZiwgMHg5ZDVlZWEwNCwgMHg4ZjQ1ZmQxOSwgMHg4MTRjZjAxMiwgMHgzYmFiNmJjYiwgMHgzNWEyNjZjMCwgMHgyN2I5NzFkZCwgMHgyOWIwN2NkNiwgMHgwMzhmNWZlNywgMHgwZDg2NTJlYywgMHgxZjlkNDVmMSwgMHgxMTk0NDhmYSwgMHg0YmUzMDM5MywgMHg0NWVhMGU5OCwgMHg1N2YxMTk4NSwgMHg1OWY4MTQ4ZSwgMHg3M2M3MzdiZiwgMHg3ZGNlM2FiNCwgMHg2ZmQ1MmRhOSwgMHg2MWRjMjBhMiwgMHhhZDc2NmRmNiwgMHhhMzdmNjBmZCwgMHhiMTY0NzdlMCwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHg5YjViNTRkMSwgMHg4OTQwNDNjYywgMHg4NzQ5NGVjNywgMHhkZDNlMDVhZSwgMHhkMzM3MDhhNSwgMHhjMTJjMWZiOCwgMHhjZjI1MTJiMywgMHhlNTFhMzE4MiwgMHhlYjEzM2M4OSwgMHhmOTA4MmI5NCwgMHhmNzAxMjY5ZiwgMHg0ZGU2YmQ0NiwgMHg0M2VmYjA0ZCwgMHg1MWY0YTc1MCwgMHg1ZmZkYWE1YiwgMHg3NWMyODk2YSwgMHg3YmNiODQ2MSwgMHg2OWQwOTM3YywgMHg2N2Q5OWU3NywgMHgzZGFlZDUxZSwgMHgzM2E3ZDgxNSwgMHgyMWJjY2YwOCwgMHgyZmI1YzIwMywgMHgwNThhZTEzMiwgMHgwYjgzZWMzOSwgMHgxOTk4ZmIyNCwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg3ODQ0ZGI4NiwgMHg2YTVmY2M5YiwgMHg2NDU2YzE5MCwgMHg0ZTY5ZTJhMSwgMHg0MDYwZWZhYSwgMHg1MjdiZjhiNywgMHg1YzcyZjViYywgMHgwNjA1YmVkNSwgMHgwODBjYjNkZSwgMHgxYTE3YTRjMywgMHgxNDFlYTljOCwgMHgzZTIxOGFmOSwgMHgzMDI4ODdmMiwgMHgyMjMzOTBlZiwgMHgyYzNhOWRlNCwgMHg5NmRkMDYzZCwgMHg5OGQ0MGIzNiwgMHg4YWNmMWMyYiwgMHg4NGM2MTEyMCwgMHhhZWY5MzIxMSwgMHhhMGYwM2YxYSwgMHhiMmViMjgwNywgMHhiY2UyMjUwYywgMHhlNjk1NmU2NSwgMHhlODljNjM2ZSwgMHhmYTg3NzQ3MywgMHhmNDhlNzk3OCwgMHhkZWIxNWE0OSwgMHhkMGI4NTc0MiwgMHhjMmEzNDA1ZiwgMHhjY2FhNGQ1NCwgMHg0MWVjZGFmNywgMHg0ZmU1ZDdmYywgMHg1ZGZlYzBlMSwgMHg1M2Y3Y2RlYSwgMHg3OWM4ZWVkYiwgMHg3N2MxZTNkMCwgMHg2NWRhZjRjZCwgMHg2YmQzZjljNiwgMHgzMWE0YjJhZiwgMHgzZmFkYmZhNCwgMHgyZGI2YThiOSwgMHgyM2JmYTViMiwgMHgwOTgwODY4MywgMHgwNzg5OGI4OCwgMHgxNTkyOWM5NSwgMHgxYjliOTE5ZSwgMHhhMTdjMGE0NywgMHhhZjc1MDc0YywgMHhiZDZlMTA1MSwgMHhiMzY3MWQ1YSwgMHg5OTU4M2U2YiwgMHg5NzUxMzM2MCwgMHg4NTRhMjQ3ZCwgMHg4YjQzMjk3NiwgMHhkMTM0NjIxZiwgMHhkZjNkNmYxNCwgMHhjZDI2NzgwOSwgMHhjMzJmNzUwMiwgMHhlOTEwNTYzMywgMHhlNzE5NWIzOCwgMHhmNTAyNGMyNSwgMHhmYjBiNDEyZSwgMHg5YWQ3NjE4YywgMHg5NGRlNmM4NywgMHg4NmM1N2I5YSwgMHg4OGNjNzY5MSwgMHhhMmYzNTVhMCwgMHhhY2ZhNThhYiwgMHhiZWUxNGZiNiwgMHhiMGU4NDJiZCwgMHhlYTlmMDlkNCwgMHhlNDk2MDRkZiwgMHhmNjhkMTNjMiwgMHhmODg0MWVjOSwgMHhkMmJiM2RmOCwgMHhkY2IyMzBmMywgMHhjZWE5MjdlZSwgMHhjMGEwMmFlNSwgMHg3YTQ3YjEzYywgMHg3NDRlYmMzNywgMHg2NjU1YWIyYSwgMHg2ODVjYTYyMSwgMHg0MjYzODUxMCwgMHg0YzZhODgxYiwgMHg1ZTcxOWYwNiwgMHg1MDc4OTIwZCwgMHgwYTBmZDk2NCwgMHgwNDA2ZDQ2ZiwgMHgxNjFkYzM3MiwgMHgxODE0Y2U3OSwgMHgzMjJiZWQ0OCwgMHgzYzIyZTA0MywgMHgyZTM5Zjc1ZSwgMHgyMDMwZmE1NSwgMHhlYzlhYjcwMSwgMHhlMjkzYmEwYSwgMHhmMDg4YWQxNywgMHhmZTgxYTAxYywgMHhkNGJlODMyZCwgMHhkYWI3OGUyNiwgMHhjOGFjOTkzYiwgMHhjNmE1OTQzMCwgMHg5Y2QyZGY1OSwgMHg5MmRiZDI1MiwgMHg4MGMwYzU0ZiwgMHg4ZWM5Yzg0NCwgMHhhNGY2ZWI3NSwgMHhhYWZmZTY3ZSwgMHhiOGU0ZjE2MywgMHhiNmVkZmM2OCwgMHgwYzBhNjdiMSwgMHgwMjAzNmFiYSwgMHgxMDE4N2RhNywgMHgxZTExNzBhYywgMHgzNDJlNTM5ZCwgMHgzYTI3NWU5NiwgMHgyODNjNDk4YiwgMHgyNjM1NDQ4MCwgMHg3YzQyMGZlOSwgMHg3MjRiMDJlMiwgMHg2MDUwMTVmZiwgMHg2ZTU5MThmNCwgMHg0NDY2M2JjNSwgMHg0YTZmMzZjZSwgMHg1ODc0MjFkMywgMHg1NjdkMmNkOCwgMHgzN2ExMGM3YSwgMHgzOWE4MDE3MSwgMHgyYmIzMTY2YywgMHgyNWJhMWI2NywgMHgwZjg1Mzg1NiwgMHgwMThjMzU1ZCwgMHgxMzk3MjI0MCwgMHgxZDllMmY0YiwgMHg0N2U5NjQyMiwgMHg0OWUwNjkyOSwgMHg1YmZiN2UzNCwgMHg1NWYyNzMzZiwgMHg3ZmNkNTAwZSwgMHg3MWM0NWQwNSwgMHg2M2RmNGExOCwgMHg2ZGQ2NDcxMywgMHhkNzMxZGNjYSwgMHhkOTM4ZDFjMSwgMHhjYjIzYzZkYywgMHhjNTJhY2JkNywgMHhlZjE1ZThlNiwgMHhlMTFjZTVlZCwgMHhmMzA3ZjJmMCwgMHhmZDBlZmZmYiwgMHhhNzc5YjQ5MiwgMHhhOTcwYjk5OSwgMHhiYjZiYWU4NCwgMHhiNTYyYTM4ZiwgMHg5ZjVkODBiZSwgMHg5MTU0OGRiNSwgMHg4MzRmOWFhOCwgMHg4ZDQ2OTdhM107XHJcbmNvbnN0IFUyID0gWzB4MDAwMDAwMDAsIDB4MGIwZTA5MGQsIDB4MTYxYzEyMWEsIDB4MWQxMjFiMTcsIDB4MmMzODI0MzQsIDB4MjczNjJkMzksIDB4M2EyNDM2MmUsIDB4MzEyYTNmMjMsIDB4NTg3MDQ4NjgsIDB4NTM3ZTQxNjUsIDB4NGU2YzVhNzIsIDB4NDU2MjUzN2YsIDB4NzQ0ODZjNWMsIDB4N2Y0NjY1NTEsIDB4NjI1NDdlNDYsIDB4Njk1YTc3NGIsIDB4YjBlMDkwZDAsIDB4YmJlZTk5ZGQsIDB4YTZmYzgyY2EsIDB4YWRmMjhiYzcsIDB4OWNkOGI0ZTQsIDB4OTdkNmJkZTksIDB4OGFjNGE2ZmUsIDB4ODFjYWFmZjMsIDB4ZTg5MGQ4YjgsIDB4ZTM5ZWQxYjUsIDB4ZmU4Y2NhYTIsIDB4ZjU4MmMzYWYsIDB4YzRhOGZjOGMsIDB4Y2ZhNmY1ODEsIDB4ZDJiNGVlOTYsIDB4ZDliYWU3OWIsIDB4N2JkYjNiYmIsIDB4NzBkNTMyYjYsIDB4NmRjNzI5YTEsIDB4NjZjOTIwYWMsIDB4NTdlMzFmOGYsIDB4NWNlZDE2ODIsIDB4NDFmZjBkOTUsIDB4NGFmMTA0OTgsIDB4MjNhYjczZDMsIDB4MjhhNTdhZGUsIDB4MzViNzYxYzksIDB4M2ViOTY4YzQsIDB4MGY5MzU3ZTcsIDB4MDQ5ZDVlZWEsIDB4MTk4ZjQ1ZmQsIDB4MTI4MTRjZjAsIDB4Y2IzYmFiNmIsIDB4YzAzNWEyNjYsIDB4ZGQyN2I5NzEsIDB4ZDYyOWIwN2MsIDB4ZTcwMzhmNWYsIDB4ZWMwZDg2NTIsIDB4ZjExZjlkNDUsIDB4ZmExMTk0NDgsIDB4OTM0YmUzMDMsIDB4OTg0NWVhMGUsIDB4ODU1N2YxMTksIDB4OGU1OWY4MTQsIDB4YmY3M2M3MzcsIDB4YjQ3ZGNlM2EsIDB4YTk2ZmQ1MmQsIDB4YTI2MWRjMjAsIDB4ZjZhZDc2NmQsIDB4ZmRhMzdmNjAsIDB4ZTBiMTY0NzcsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4ZDE5YjViNTQsIDB4Y2M4OTQwNDMsIDB4Yzc4NzQ5NGUsIDB4YWVkZDNlMDUsIDB4YTVkMzM3MDgsIDB4YjhjMTJjMWYsIDB4YjNjZjI1MTIsIDB4ODJlNTFhMzEsIDB4ODllYjEzM2MsIDB4OTRmOTA4MmIsIDB4OWZmNzAxMjYsIDB4NDY0ZGU2YmQsIDB4NGQ0M2VmYjAsIDB4NTA1MWY0YTcsIDB4NWI1ZmZkYWEsIDB4NmE3NWMyODksIDB4NjE3YmNiODQsIDB4N2M2OWQwOTMsIDB4Nzc2N2Q5OWUsIDB4MWUzZGFlZDUsIDB4MTUzM2E3ZDgsIDB4MDgyMWJjY2YsIDB4MDMyZmI1YzIsIDB4MzIwNThhZTEsIDB4MzkwYjgzZWMsIDB4MjQxOTk4ZmIsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4ODY3ODQ0ZGIsIDB4OWI2YTVmY2MsIDB4OTA2NDU2YzEsIDB4YTE0ZTY5ZTIsIDB4YWE0MDYwZWYsIDB4Yjc1MjdiZjgsIDB4YmM1YzcyZjUsIDB4ZDUwNjA1YmUsIDB4ZGUwODBjYjMsIDB4YzMxYTE3YTQsIDB4YzgxNDFlYTksIDB4ZjkzZTIxOGEsIDB4ZjIzMDI4ODcsIDB4ZWYyMjMzOTAsIDB4ZTQyYzNhOWQsIDB4M2Q5NmRkMDYsIDB4MzY5OGQ0MGIsIDB4MmI4YWNmMWMsIDB4MjA4NGM2MTEsIDB4MTFhZWY5MzIsIDB4MWFhMGYwM2YsIDB4MDdiMmViMjgsIDB4MGNiY2UyMjUsIDB4NjVlNjk1NmUsIDB4NmVlODljNjMsIDB4NzNmYTg3NzQsIDB4NzhmNDhlNzksIDB4NDlkZWIxNWEsIDB4NDJkMGI4NTcsIDB4NWZjMmEzNDAsIDB4NTRjY2FhNGQsIDB4Zjc0MWVjZGEsIDB4ZmM0ZmU1ZDcsIDB4ZTE1ZGZlYzAsIDB4ZWE1M2Y3Y2QsIDB4ZGI3OWM4ZWUsIDB4ZDA3N2MxZTMsIDB4Y2Q2NWRhZjQsIDB4YzY2YmQzZjksIDB4YWYzMWE0YjIsIDB4YTQzZmFkYmYsIDB4YjkyZGI2YTgsIDB4YjIyM2JmYTUsIDB4ODMwOTgwODYsIDB4ODgwNzg5OGIsIDB4OTUxNTkyOWMsIDB4OWUxYjliOTEsIDB4NDdhMTdjMGEsIDB4NGNhZjc1MDcsIDB4NTFiZDZlMTAsIDB4NWFiMzY3MWQsIDB4NmI5OTU4M2UsIDB4NjA5NzUxMzMsIDB4N2Q4NTRhMjQsIDB4NzY4YjQzMjksIDB4MWZkMTM0NjIsIDB4MTRkZjNkNmYsIDB4MDljZDI2NzgsIDB4MDJjMzJmNzUsIDB4MzNlOTEwNTYsIDB4MzhlNzE5NWIsIDB4MjVmNTAyNGMsIDB4MmVmYjBiNDEsIDB4OGM5YWQ3NjEsIDB4ODc5NGRlNmMsIDB4OWE4NmM1N2IsIDB4OTE4OGNjNzYsIDB4YTBhMmYzNTUsIDB4YWJhY2ZhNTgsIDB4YjZiZWUxNGYsIDB4YmRiMGU4NDIsIDB4ZDRlYTlmMDksIDB4ZGZlNDk2MDQsIDB4YzJmNjhkMTMsIDB4YzlmODg0MWUsIDB4ZjhkMmJiM2QsIDB4ZjNkY2IyMzAsIDB4ZWVjZWE5MjcsIDB4ZTVjMGEwMmEsIDB4M2M3YTQ3YjEsIDB4Mzc3NDRlYmMsIDB4MmE2NjU1YWIsIDB4MjE2ODVjYTYsIDB4MTA0MjYzODUsIDB4MWI0YzZhODgsIDB4MDY1ZTcxOWYsIDB4MGQ1MDc4OTIsIDB4NjQwYTBmZDksIDB4NmYwNDA2ZDQsIDB4NzIxNjFkYzMsIDB4NzkxODE0Y2UsIDB4NDgzMjJiZWQsIDB4NDMzYzIyZTAsIDB4NWUyZTM5ZjcsIDB4NTUyMDMwZmEsIDB4MDFlYzlhYjcsIDB4MGFlMjkzYmEsIDB4MTdmMDg4YWQsIDB4MWNmZTgxYTAsIDB4MmRkNGJlODMsIDB4MjZkYWI3OGUsIDB4M2JjOGFjOTksIDB4MzBjNmE1OTQsIDB4NTk5Y2QyZGYsIDB4NTI5MmRiZDIsIDB4NGY4MGMwYzUsIDB4NDQ4ZWM5YzgsIDB4NzVhNGY2ZWIsIDB4N2VhYWZmZTYsIDB4NjNiOGU0ZjEsIDB4NjhiNmVkZmMsIDB4YjEwYzBhNjcsIDB4YmEwMjAzNmEsIDB4YTcxMDE4N2QsIDB4YWMxZTExNzAsIDB4OWQzNDJlNTMsIDB4OTYzYTI3NWUsIDB4OGIyODNjNDksIDB4ODAyNjM1NDQsIDB4ZTk3YzQyMGYsIDB4ZTI3MjRiMDIsIDB4ZmY2MDUwMTUsIDB4ZjQ2ZTU5MTgsIDB4YzU0NDY2M2IsIDB4Y2U0YTZmMzYsIDB4ZDM1ODc0MjEsIDB4ZDg1NjdkMmMsIDB4N2EzN2ExMGMsIDB4NzEzOWE4MDEsIDB4NmMyYmIzMTYsIDB4NjcyNWJhMWIsIDB4NTYwZjg1MzgsIDB4NWQwMThjMzUsIDB4NDAxMzk3MjIsIDB4NGIxZDllMmYsIDB4MjI0N2U5NjQsIDB4Mjk0OWUwNjksIDB4MzQ1YmZiN2UsIDB4M2Y1NWYyNzMsIDB4MGU3ZmNkNTAsIDB4MDU3MWM0NWQsIDB4MTg2M2RmNGEsIDB4MTM2ZGQ2NDcsIDB4Y2FkNzMxZGMsIDB4YzFkOTM4ZDEsIDB4ZGNjYjIzYzYsIDB4ZDdjNTJhY2IsIDB4ZTZlZjE1ZTgsIDB4ZWRlMTFjZTUsIDB4ZjBmMzA3ZjIsIDB4ZmJmZDBlZmYsIDB4OTJhNzc5YjQsIDB4OTlhOTcwYjksIDB4ODRiYjZiYWUsIDB4OGZiNTYyYTMsIDB4YmU5ZjVkODAsIDB4YjU5MTU0OGQsIDB4YTg4MzRmOWEsIDB4YTM4ZDQ2OTddO1xyXG5jb25zdCBVMyA9IFsweDAwMDAwMDAwLCAweDBkMGIwZTA5LCAweDFhMTYxYzEyLCAweDE3MWQxMjFiLCAweDM0MmMzODI0LCAweDM5MjczNjJkLCAweDJlM2EyNDM2LCAweDIzMzEyYTNmLCAweDY4NTg3MDQ4LCAweDY1NTM3ZTQxLCAweDcyNGU2YzVhLCAweDdmNDU2MjUzLCAweDVjNzQ0ODZjLCAweDUxN2Y0NjY1LCAweDQ2NjI1NDdlLCAweDRiNjk1YTc3LCAweGQwYjBlMDkwLCAweGRkYmJlZTk5LCAweGNhYTZmYzgyLCAweGM3YWRmMjhiLCAweGU0OWNkOGI0LCAweGU5OTdkNmJkLCAweGZlOGFjNGE2LCAweGYzODFjYWFmLCAweGI4ZTg5MGQ4LCAweGI1ZTM5ZWQxLCAweGEyZmU4Y2NhLCAweGFmZjU4MmMzLCAweDhjYzRhOGZjLCAweDgxY2ZhNmY1LCAweDk2ZDJiNGVlLCAweDliZDliYWU3LCAweGJiN2JkYjNiLCAweGI2NzBkNTMyLCAweGExNmRjNzI5LCAweGFjNjZjOTIwLCAweDhmNTdlMzFmLCAweDgyNWNlZDE2LCAweDk1NDFmZjBkLCAweDk4NGFmMTA0LCAweGQzMjNhYjczLCAweGRlMjhhNTdhLCAweGM5MzViNzYxLCAweGM0M2ViOTY4LCAweGU3MGY5MzU3LCAweGVhMDQ5ZDVlLCAweGZkMTk4ZjQ1LCAweGYwMTI4MTRjLCAweDZiY2IzYmFiLCAweDY2YzAzNWEyLCAweDcxZGQyN2I5LCAweDdjZDYyOWIwLCAweDVmZTcwMzhmLCAweDUyZWMwZDg2LCAweDQ1ZjExZjlkLCAweDQ4ZmExMTk0LCAweDAzOTM0YmUzLCAweDBlOTg0NWVhLCAweDE5ODU1N2YxLCAweDE0OGU1OWY4LCAweDM3YmY3M2M3LCAweDNhYjQ3ZGNlLCAweDJkYTk2ZmQ1LCAweDIwYTI2MWRjLCAweDZkZjZhZDc2LCAweDYwZmRhMzdmLCAweDc3ZTBiMTY0LCAweDdhZWJiZjZkLCAweDU5ZGE5NTUyLCAweDU0ZDE5YjViLCAweDQzY2M4OTQwLCAweDRlYzc4NzQ5LCAweDA1YWVkZDNlLCAweDA4YTVkMzM3LCAweDFmYjhjMTJjLCAweDEyYjNjZjI1LCAweDMxODJlNTFhLCAweDNjODllYjEzLCAweDJiOTRmOTA4LCAweDI2OWZmNzAxLCAweGJkNDY0ZGU2LCAweGIwNGQ0M2VmLCAweGE3NTA1MWY0LCAweGFhNWI1ZmZkLCAweDg5NmE3NWMyLCAweDg0NjE3YmNiLCAweDkzN2M2OWQwLCAweDllNzc2N2Q5LCAweGQ1MWUzZGFlLCAweGQ4MTUzM2E3LCAweGNmMDgyMWJjLCAweGMyMDMyZmI1LCAweGUxMzIwNThhLCAweGVjMzkwYjgzLCAweGZiMjQxOTk4LCAweGY2MmYxNzkxLCAweGQ2OGQ3NjRkLCAweGRiODY3ODQ0LCAweGNjOWI2YTVmLCAweGMxOTA2NDU2LCAweGUyYTE0ZTY5LCAweGVmYWE0MDYwLCAweGY4Yjc1MjdiLCAweGY1YmM1YzcyLCAweGJlZDUwNjA1LCAweGIzZGUwODBjLCAweGE0YzMxYTE3LCAweGE5YzgxNDFlLCAweDhhZjkzZTIxLCAweDg3ZjIzMDI4LCAweDkwZWYyMjMzLCAweDlkZTQyYzNhLCAweDA2M2Q5NmRkLCAweDBiMzY5OGQ0LCAweDFjMmI4YWNmLCAweDExMjA4NGM2LCAweDMyMTFhZWY5LCAweDNmMWFhMGYwLCAweDI4MDdiMmViLCAweDI1MGNiY2UyLCAweDZlNjVlNjk1LCAweDYzNmVlODljLCAweDc0NzNmYTg3LCAweDc5NzhmNDhlLCAweDVhNDlkZWIxLCAweDU3NDJkMGI4LCAweDQwNWZjMmEzLCAweDRkNTRjY2FhLCAweGRhZjc0MWVjLCAweGQ3ZmM0ZmU1LCAweGMwZTE1ZGZlLCAweGNkZWE1M2Y3LCAweGVlZGI3OWM4LCAweGUzZDA3N2MxLCAweGY0Y2Q2NWRhLCAweGY5YzY2YmQzLCAweGIyYWYzMWE0LCAweGJmYTQzZmFkLCAweGE4YjkyZGI2LCAweGE1YjIyM2JmLCAweDg2ODMwOTgwLCAweDhiODgwNzg5LCAweDljOTUxNTkyLCAweDkxOWUxYjliLCAweDBhNDdhMTdjLCAweDA3NGNhZjc1LCAweDEwNTFiZDZlLCAweDFkNWFiMzY3LCAweDNlNmI5OTU4LCAweDMzNjA5NzUxLCAweDI0N2Q4NTRhLCAweDI5NzY4YjQzLCAweDYyMWZkMTM0LCAweDZmMTRkZjNkLCAweDc4MDljZDI2LCAweDc1MDJjMzJmLCAweDU2MzNlOTEwLCAweDViMzhlNzE5LCAweDRjMjVmNTAyLCAweDQxMmVmYjBiLCAweDYxOGM5YWQ3LCAweDZjODc5NGRlLCAweDdiOWE4NmM1LCAweDc2OTE4OGNjLCAweDU1YTBhMmYzLCAweDU4YWJhY2ZhLCAweDRmYjZiZWUxLCAweDQyYmRiMGU4LCAweDA5ZDRlYTlmLCAweDA0ZGZlNDk2LCAweDEzYzJmNjhkLCAweDFlYzlmODg0LCAweDNkZjhkMmJiLCAweDMwZjNkY2IyLCAweDI3ZWVjZWE5LCAweDJhZTVjMGEwLCAweGIxM2M3YTQ3LCAweGJjMzc3NDRlLCAweGFiMmE2NjU1LCAweGE2MjE2ODVjLCAweDg1MTA0MjYzLCAweDg4MWI0YzZhLCAweDlmMDY1ZTcxLCAweDkyMGQ1MDc4LCAweGQ5NjQwYTBmLCAweGQ0NmYwNDA2LCAweGMzNzIxNjFkLCAweGNlNzkxODE0LCAweGVkNDgzMjJiLCAweGUwNDMzYzIyLCAweGY3NWUyZTM5LCAweGZhNTUyMDMwLCAweGI3MDFlYzlhLCAweGJhMGFlMjkzLCAweGFkMTdmMDg4LCAweGEwMWNmZTgxLCAweDgzMmRkNGJlLCAweDhlMjZkYWI3LCAweDk5M2JjOGFjLCAweDk0MzBjNmE1LCAweGRmNTk5Y2QyLCAweGQyNTI5MmRiLCAweGM1NGY4MGMwLCAweGM4NDQ4ZWM5LCAweGViNzVhNGY2LCAweGU2N2VhYWZmLCAweGYxNjNiOGU0LCAweGZjNjhiNmVkLCAweDY3YjEwYzBhLCAweDZhYmEwMjAzLCAweDdkYTcxMDE4LCAweDcwYWMxZTExLCAweDUzOWQzNDJlLCAweDVlOTYzYTI3LCAweDQ5OGIyODNjLCAweDQ0ODAyNjM1LCAweDBmZTk3YzQyLCAweDAyZTI3MjRiLCAweDE1ZmY2MDUwLCAweDE4ZjQ2ZTU5LCAweDNiYzU0NDY2LCAweDM2Y2U0YTZmLCAweDIxZDM1ODc0LCAweDJjZDg1NjdkLCAweDBjN2EzN2ExLCAweDAxNzEzOWE4LCAweDE2NmMyYmIzLCAweDFiNjcyNWJhLCAweDM4NTYwZjg1LCAweDM1NWQwMThjLCAweDIyNDAxMzk3LCAweDJmNGIxZDllLCAweDY0MjI0N2U5LCAweDY5Mjk0OWUwLCAweDdlMzQ1YmZiLCAweDczM2Y1NWYyLCAweDUwMGU3ZmNkLCAweDVkMDU3MWM0LCAweDRhMTg2M2RmLCAweDQ3MTM2ZGQ2LCAweGRjY2FkNzMxLCAweGQxYzFkOTM4LCAweGM2ZGNjYjIzLCAweGNiZDdjNTJhLCAweGU4ZTZlZjE1LCAweGU1ZWRlMTFjLCAweGYyZjBmMzA3LCAweGZmZmJmZDBlLCAweGI0OTJhNzc5LCAweGI5OTlhOTcwLCAweGFlODRiYjZiLCAweGEzOGZiNTYyLCAweDgwYmU5ZjVkLCAweDhkYjU5MTU0LCAweDlhYTg4MzRmLCAweDk3YTM4ZDQ2XTtcclxuY29uc3QgVTQgPSBbMHgwMDAwMDAwMCwgMHgwOTBkMGIwZSwgMHgxMjFhMTYxYywgMHgxYjE3MWQxMiwgMHgyNDM0MmMzOCwgMHgyZDM5MjczNiwgMHgzNjJlM2EyNCwgMHgzZjIzMzEyYSwgMHg0ODY4NTg3MCwgMHg0MTY1NTM3ZSwgMHg1YTcyNGU2YywgMHg1MzdmNDU2MiwgMHg2YzVjNzQ0OCwgMHg2NTUxN2Y0NiwgMHg3ZTQ2NjI1NCwgMHg3NzRiNjk1YSwgMHg5MGQwYjBlMCwgMHg5OWRkYmJlZSwgMHg4MmNhYTZmYywgMHg4YmM3YWRmMiwgMHhiNGU0OWNkOCwgMHhiZGU5OTdkNiwgMHhhNmZlOGFjNCwgMHhhZmYzODFjYSwgMHhkOGI4ZTg5MCwgMHhkMWI1ZTM5ZSwgMHhjYWEyZmU4YywgMHhjM2FmZjU4MiwgMHhmYzhjYzRhOCwgMHhmNTgxY2ZhNiwgMHhlZTk2ZDJiNCwgMHhlNzliZDliYSwgMHgzYmJiN2JkYiwgMHgzMmI2NzBkNSwgMHgyOWExNmRjNywgMHgyMGFjNjZjOSwgMHgxZjhmNTdlMywgMHgxNjgyNWNlZCwgMHgwZDk1NDFmZiwgMHgwNDk4NGFmMSwgMHg3M2QzMjNhYiwgMHg3YWRlMjhhNSwgMHg2MWM5MzViNywgMHg2OGM0M2ViOSwgMHg1N2U3MGY5MywgMHg1ZWVhMDQ5ZCwgMHg0NWZkMTk4ZiwgMHg0Y2YwMTI4MSwgMHhhYjZiY2IzYiwgMHhhMjY2YzAzNSwgMHhiOTcxZGQyNywgMHhiMDdjZDYyOSwgMHg4ZjVmZTcwMywgMHg4NjUyZWMwZCwgMHg5ZDQ1ZjExZiwgMHg5NDQ4ZmExMSwgMHhlMzAzOTM0YiwgMHhlYTBlOTg0NSwgMHhmMTE5ODU1NywgMHhmODE0OGU1OSwgMHhjNzM3YmY3MywgMHhjZTNhYjQ3ZCwgMHhkNTJkYTk2ZiwgMHhkYzIwYTI2MSwgMHg3NjZkZjZhZCwgMHg3ZjYwZmRhMywgMHg2NDc3ZTBiMSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHg1YjU0ZDE5YiwgMHg0MDQzY2M4OSwgMHg0OTRlYzc4NywgMHgzZTA1YWVkZCwgMHgzNzA4YTVkMywgMHgyYzFmYjhjMSwgMHgyNTEyYjNjZiwgMHgxYTMxODJlNSwgMHgxMzNjODllYiwgMHgwODJiOTRmOSwgMHgwMTI2OWZmNywgMHhlNmJkNDY0ZCwgMHhlZmIwNGQ0MywgMHhmNGE3NTA1MSwgMHhmZGFhNWI1ZiwgMHhjMjg5NmE3NSwgMHhjYjg0NjE3YiwgMHhkMDkzN2M2OSwgMHhkOTllNzc2NywgMHhhZWQ1MWUzZCwgMHhhN2Q4MTUzMywgMHhiY2NmMDgyMSwgMHhiNWMyMDMyZiwgMHg4YWUxMzIwNSwgMHg4M2VjMzkwYiwgMHg5OGZiMjQxOSwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHg0NGRiODY3OCwgMHg1ZmNjOWI2YSwgMHg1NmMxOTA2NCwgMHg2OWUyYTE0ZSwgMHg2MGVmYWE0MCwgMHg3YmY4Yjc1MiwgMHg3MmY1YmM1YywgMHgwNWJlZDUwNiwgMHgwY2IzZGUwOCwgMHgxN2E0YzMxYSwgMHgxZWE5YzgxNCwgMHgyMThhZjkzZSwgMHgyODg3ZjIzMCwgMHgzMzkwZWYyMiwgMHgzYTlkZTQyYywgMHhkZDA2M2Q5NiwgMHhkNDBiMzY5OCwgMHhjZjFjMmI4YSwgMHhjNjExMjA4NCwgMHhmOTMyMTFhZSwgMHhmMDNmMWFhMCwgMHhlYjI4MDdiMiwgMHhlMjI1MGNiYywgMHg5NTZlNjVlNiwgMHg5YzYzNmVlOCwgMHg4Nzc0NzNmYSwgMHg4ZTc5NzhmNCwgMHhiMTVhNDlkZSwgMHhiODU3NDJkMCwgMHhhMzQwNWZjMiwgMHhhYTRkNTRjYywgMHhlY2RhZjc0MSwgMHhlNWQ3ZmM0ZiwgMHhmZWMwZTE1ZCwgMHhmN2NkZWE1MywgMHhjOGVlZGI3OSwgMHhjMWUzZDA3NywgMHhkYWY0Y2Q2NSwgMHhkM2Y5YzY2YiwgMHhhNGIyYWYzMSwgMHhhZGJmYTQzZiwgMHhiNmE4YjkyZCwgMHhiZmE1YjIyMywgMHg4MDg2ODMwOSwgMHg4OThiODgwNywgMHg5MjljOTUxNSwgMHg5YjkxOWUxYiwgMHg3YzBhNDdhMSwgMHg3NTA3NGNhZiwgMHg2ZTEwNTFiZCwgMHg2NzFkNWFiMywgMHg1ODNlNmI5OSwgMHg1MTMzNjA5NywgMHg0YTI0N2Q4NSwgMHg0MzI5NzY4YiwgMHgzNDYyMWZkMSwgMHgzZDZmMTRkZiwgMHgyNjc4MDljZCwgMHgyZjc1MDJjMywgMHgxMDU2MzNlOSwgMHgxOTViMzhlNywgMHgwMjRjMjVmNSwgMHgwYjQxMmVmYiwgMHhkNzYxOGM5YSwgMHhkZTZjODc5NCwgMHhjNTdiOWE4NiwgMHhjYzc2OTE4OCwgMHhmMzU1YTBhMiwgMHhmYTU4YWJhYywgMHhlMTRmYjZiZSwgMHhlODQyYmRiMCwgMHg5ZjA5ZDRlYSwgMHg5NjA0ZGZlNCwgMHg4ZDEzYzJmNiwgMHg4NDFlYzlmOCwgMHhiYjNkZjhkMiwgMHhiMjMwZjNkYywgMHhhOTI3ZWVjZSwgMHhhMDJhZTVjMCwgMHg0N2IxM2M3YSwgMHg0ZWJjMzc3NCwgMHg1NWFiMmE2NiwgMHg1Y2E2MjE2OCwgMHg2Mzg1MTA0MiwgMHg2YTg4MWI0YywgMHg3MTlmMDY1ZSwgMHg3ODkyMGQ1MCwgMHgwZmQ5NjQwYSwgMHgwNmQ0NmYwNCwgMHgxZGMzNzIxNiwgMHgxNGNlNzkxOCwgMHgyYmVkNDgzMiwgMHgyMmUwNDMzYywgMHgzOWY3NWUyZSwgMHgzMGZhNTUyMCwgMHg5YWI3MDFlYywgMHg5M2JhMGFlMiwgMHg4OGFkMTdmMCwgMHg4MWEwMWNmZSwgMHhiZTgzMmRkNCwgMHhiNzhlMjZkYSwgMHhhYzk5M2JjOCwgMHhhNTk0MzBjNiwgMHhkMmRmNTk5YywgMHhkYmQyNTI5MiwgMHhjMGM1NGY4MCwgMHhjOWM4NDQ4ZSwgMHhmNmViNzVhNCwgMHhmZmU2N2VhYSwgMHhlNGYxNjNiOCwgMHhlZGZjNjhiNiwgMHgwYTY3YjEwYywgMHgwMzZhYmEwMiwgMHgxODdkYTcxMCwgMHgxMTcwYWMxZSwgMHgyZTUzOWQzNCwgMHgyNzVlOTYzYSwgMHgzYzQ5OGIyOCwgMHgzNTQ0ODAyNiwgMHg0MjBmZTk3YywgMHg0YjAyZTI3MiwgMHg1MDE1ZmY2MCwgMHg1OTE4ZjQ2ZSwgMHg2NjNiYzU0NCwgMHg2ZjM2Y2U0YSwgMHg3NDIxZDM1OCwgMHg3ZDJjZDg1NiwgMHhhMTBjN2EzNywgMHhhODAxNzEzOSwgMHhiMzE2NmMyYiwgMHhiYTFiNjcyNSwgMHg4NTM4NTYwZiwgMHg4YzM1NWQwMSwgMHg5NzIyNDAxMywgMHg5ZTJmNGIxZCwgMHhlOTY0MjI0NywgMHhlMDY5Mjk0OSwgMHhmYjdlMzQ1YiwgMHhmMjczM2Y1NSwgMHhjZDUwMGU3ZiwgMHhjNDVkMDU3MSwgMHhkZjRhMTg2MywgMHhkNjQ3MTM2ZCwgMHgzMWRjY2FkNywgMHgzOGQxYzFkOSwgMHgyM2M2ZGNjYiwgMHgyYWNiZDdjNSwgMHgxNWU4ZTZlZiwgMHgxY2U1ZWRlMSwgMHgwN2YyZjBmMywgMHgwZWZmZmJmZCwgMHg3OWI0OTJhNywgMHg3MGI5OTlhOSwgMHg2YmFlODRiYiwgMHg2MmEzOGZiNSwgMHg1ZDgwYmU5ZiwgMHg1NDhkYjU5MSwgMHg0ZjlhYTg4MywgMHg0Njk3YTM4ZF07XHJcbmZ1bmN0aW9uIGNvbnZlcnRUb0ludDMyKGJ5dGVzKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDQpIHtcclxuICAgICAgICByZXN1bHQucHVzaCgoYnl0ZXNbaV0gPDwgMjQpIHwgKGJ5dGVzW2kgKyAxXSA8PCAxNikgfCAoYnl0ZXNbaSArIDJdIDw8IDgpIHwgYnl0ZXNbaSArIDNdKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZXhwb3J0IGNsYXNzIEFFUyB7XHJcbiAgICBnZXQga2V5KCkgeyByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX2tleSwgXCJmXCIpLnNsaWNlKCk7IH1cclxuICAgIGNvbnN0cnVjdG9yKGtleSkge1xyXG4gICAgICAgIF9BRVNfa2V5LnNldCh0aGlzLCB2b2lkIDApO1xyXG4gICAgICAgIF9BRVNfS2Quc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICAgICAgX0FFU19LZS5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQUVTKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQUVTX2tleSwgbmV3IFVpbnQ4QXJyYXkoa2V5KSwgXCJmXCIpO1xyXG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IG51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07XHJcbiAgICAgICAgaWYgKHJvdW5kcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IHNpemUgKG11c3QgYmUgMTYsIDI0IG9yIDMyIGJ5dGVzKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlbmNyeXB0aW9uIHJvdW5kIGtleXNcclxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BRVNfS2UsIFtdLCBcImZcIik7XHJcbiAgICAgICAgLy8gZGVjcnlwdGlvbiByb3VuZCBrZXlzXHJcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQUVTX0tkLCBbXSwgXCJmXCIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHJvdW5kczsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIikucHVzaChbMCwgMCwgMCwgMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByb3VuZEtleUNvdW50ID0gKHJvdW5kcyArIDEpICogNDtcclxuICAgICAgICBjb25zdCBLQyA9IHRoaXMua2V5Lmxlbmd0aCAvIDQ7XHJcbiAgICAgICAgLy8gY29udmVydCB0aGUga2V5IGludG8gaW50c1xyXG4gICAgICAgIGNvbnN0IHRrID0gY29udmVydFRvSW50MzIodGhpcy5rZXkpO1xyXG4gICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xyXG4gICAgICAgIGxldCBpbmRleDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEtDOyBpKyspIHtcclxuICAgICAgICAgICAgaW5kZXggPSBpID4+IDI7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpW2luZGV4XVtpICUgNF0gPSB0a1tpXTtcclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIChmaXBzLTE5NyBzZWN0aW9uIDUuMilcclxuICAgICAgICBsZXQgcmNvbnBvaW50ZXIgPSAwO1xyXG4gICAgICAgIGxldCB0ID0gS0MsIHR0O1xyXG4gICAgICAgIHdoaWxlICh0IDwgcm91bmRLZXlDb3VudCkge1xyXG4gICAgICAgICAgICB0dCA9IHRrW0tDIC0gMV07XHJcbiAgICAgICAgICAgIHRrWzBdIF49ICgoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMjQpIF5cclxuICAgICAgICAgICAgICAgIChTWyh0dCA+PiA4KSAmIDB4RkZdIDw8IDE2KSBeXHJcbiAgICAgICAgICAgICAgICAoU1t0dCAmIDB4RkZdIDw8IDgpIF5cclxuICAgICAgICAgICAgICAgIFNbKHR0ID4+IDI0KSAmIDB4RkZdIF5cclxuICAgICAgICAgICAgICAgIChyY29uW3Jjb25wb2ludGVyXSA8PCAyNCkpO1xyXG4gICAgICAgICAgICByY29ucG9pbnRlciArPSAxO1xyXG4gICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIChmb3Igbm9uLTI1NiBiaXQpXHJcbiAgICAgICAgICAgIGlmIChLQyAhPSA4KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEtDOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIGZvciAyNTYtYml0IGtleXMgaXMgXCJzbGlnaHRseSBkaWZmZXJlbnRcIiAoZmlwcy0xOTcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IChLQyAvIDIpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0dCA9IHRrWyhLQyAvIDIpIC0gMV07XHJcbiAgICAgICAgICAgICAgICB0a1tLQyAvIDJdIF49IChTW3R0ICYgMHhGRl0gXlxyXG4gICAgICAgICAgICAgICAgICAgIChTWyh0dCA+PiA4KSAmIDB4RkZdIDw8IDgpIF5cclxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMTYpIF5cclxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMjQpICYgMHhGRl0gPDwgMjQpKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAoS0MgLyAyKSArIDE7IGkgPCBLQzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xyXG4gICAgICAgICAgICBsZXQgaSA9IDAsIHIsIGM7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgS0MgJiYgdCA8IHJvdW5kS2V5Q291bnQpIHtcclxuICAgICAgICAgICAgICAgIHIgPSB0ID4+IDI7XHJcbiAgICAgICAgICAgICAgICBjID0gdCAlIDQ7XHJcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyXVtjXSA9IHRrW2ldO1xyXG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gcl1bY10gPSB0a1tpKytdO1xyXG4gICAgICAgICAgICAgICAgdCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGludmVyc2UtY2lwaGVyLWlmeSB0aGUgZGVjcnlwdGlvbiByb3VuZCBrZXkgKGZpcHMtMTk3IHNlY3Rpb24gNS4zKVxyXG4gICAgICAgIGZvciAobGV0IHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA0OyBjKyspIHtcclxuICAgICAgICAgICAgICAgIHR0ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcl1bY107XHJcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKVtyXVtjXSA9IChVMVsodHQgPj4gMjQpICYgMHhGRl0gXlxyXG4gICAgICAgICAgICAgICAgICAgIFUyWyh0dCA+PiAxNikgJiAweEZGXSBeXHJcbiAgICAgICAgICAgICAgICAgICAgVTNbKHR0ID4+IDgpICYgMHhGRl0gXlxyXG4gICAgICAgICAgICAgICAgICAgIFU0W3R0ICYgMHhGRl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcclxuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAhPSAxNikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByb3VuZHMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKS5sZW5ndGggLSAxO1xyXG4gICAgICAgIGNvbnN0IGEgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXHJcbiAgICAgICAgbGV0IHQgPSBjb252ZXJ0VG9JbnQzMihwbGFpbnRleHQpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbMF1baV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFwcGx5IHJvdW5kIHRyYW5zZm9ybXNcclxuICAgICAgICBmb3IgKGxldCByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gKFQxWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF5cclxuICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxyXG4gICAgICAgICAgICAgICAgICAgIFQzWyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF5cclxuICAgICAgICAgICAgICAgICAgICBUNFt0WyhpICsgMykgJSA0XSAmIDB4ZmZdIF5cclxuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyXVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdCA9IGEuc2xpY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhlIGxhc3Qgcm91bmQgaXMgc3BlY2lhbFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KDE2KTtcclxuICAgICAgICBsZXQgdHQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHR0ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbcm91bmRzXVtpXTtcclxuICAgICAgICAgICAgcmVzdWx0WzQgKiBpXSA9IChTWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xyXG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAxXSA9IChTWyh0WyhpICsgMSkgJSA0XSA+PiAxNikgJiAweGZmXSBeICh0dCA+PiAxNikpICYgMHhmZjtcclxuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU1sodFsoaSArIDIpICUgNF0gPj4gOCkgJiAweGZmXSBeICh0dCA+PiA4KSkgJiAweGZmO1xyXG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTW3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XHJcbiAgICAgICAgaWYgKGNpcGhlcnRleHQubGVuZ3RoICE9IDE2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByb3VuZHMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKS5sZW5ndGggLSAxO1xyXG4gICAgICAgIGNvbnN0IGEgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXHJcbiAgICAgICAgbGV0IHQgPSBjb252ZXJ0VG9JbnQzMihjaXBoZXJ0ZXh0KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICB0W2ldIF49IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpWzBdW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXHJcbiAgICAgICAgZm9yIChsZXQgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IChUNVsodFtpXSA+PiAyNCkgJiAweGZmXSBeXHJcbiAgICAgICAgICAgICAgICAgICAgVDZbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF5cclxuICAgICAgICAgICAgICAgICAgICBUN1sodFsoaSArIDIpICUgNF0gPj4gOCkgJiAweGZmXSBeXHJcbiAgICAgICAgICAgICAgICAgICAgVDhbdFsoaSArIDEpICUgNF0gJiAweGZmXSBeXHJcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcl1baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHQgPSBhLnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoZSBsYXN0IHJvdW5kIGlzIHNwZWNpYWxcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgxNik7XHJcbiAgICAgICAgbGV0IHR0ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JvdW5kc11baV07XHJcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaV0gPSAoU2lbKHRbaV0gPj4gMjQpICYgMHhmZl0gXiAodHQgPj4gMjQpKSAmIDB4ZmY7XHJcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDFdID0gKFNpWyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeICh0dCA+PiAxNikpICYgMHhmZjtcclxuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+IDgpICYgMHhmZl0gXiAodHQgPj4gOCkpICYgMHhmZjtcclxuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgM10gPSAoU2lbdFsoaSArIDEpICUgNF0gJiAweGZmXSBeIHR0KSAmIDB4ZmY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuX0FFU19rZXkgPSBuZXcgV2Vha01hcCgpLCBfQUVTX0tkID0gbmV3IFdlYWtNYXAoKSwgX0FFU19LZSA9IG5ldyBXZWFrTWFwKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFlcy5qcy5tYXAiLCJpbXBvcnQgeyBBRVMgfSBmcm9tIFwiLi9hZXMuanNcIjtcclxuZXhwb3J0IGNsYXNzIE1vZGVPZk9wZXJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBrZXksIGNscykge1xyXG4gICAgICAgIGlmIChjbHMgJiYgISh0aGlzIGluc3RhbmNlb2YgY2xzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBcIm5ld1wiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgYWVzOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBuZXcgQUVTKGtleSkgfSxcclxuICAgICAgICAgICAgbmFtZTogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogbmFtZSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS5qcy5tYXAiLCIvLyBDaXBoZXIgQmxvY2sgQ2hhaW5pbmdcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn07XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn07XHJcbnZhciBfQ0JDX2l2LCBfQ0JDX2xhc3RCbG9jaztcclxuaW1wb3J0IHsgTW9kZU9mT3BlcmF0aW9uIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xyXG5leHBvcnQgY2xhc3MgQ0JDIGV4dGVuZHMgTW9kZU9mT3BlcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgaXYpIHtcclxuICAgICAgICBzdXBlcihcIkVDQ1wiLCBrZXksIENCQyk7XHJcbiAgICAgICAgX0NCQ19pdi5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgICAgICBfQ0JDX2xhc3RCbG9jay5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgICAgICBpZiAoaXYpIHtcclxuICAgICAgICAgICAgaWYgKGl2Lmxlbmd0aCAlIDE2KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBpdiBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DQkNfaXYsIG5ldyBVaW50OEFycmF5KGl2KSwgXCJmXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2l2LCBuZXcgVWludDhBcnJheSgxNiksIFwiZlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgdGhpcy5pdiwgXCJmXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGl2KCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2l2LCBcImZcIikpOyB9XHJcbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xyXG4gICAgICAgIGlmIChwbGFpbnRleHQubGVuZ3RoICUgMTYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFpbnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKykge1xyXG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpW2pdIF49IHBsYWludGV4dFtpICsgal07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIikpLCBcImZcIik7XHJcbiAgICAgICAgICAgIGNpcGhlcnRleHQuc2V0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xyXG4gICAgfVxyXG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XHJcbiAgICAgICAgaWYgKGNpcGhlcnRleHQubGVuZ3RoICUgMTYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoY2lwaGVydGV4dC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcclxuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmFlcy5kZWNyeXB0KGNpcGhlcnRleHQuc3ViYXJyYXkoaSwgaSArIDE2KSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKykge1xyXG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0W2kgKyBqXSA9IGJsb2NrW2pdIF4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpW2pdO1xyXG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpW2pdID0gY2lwaGVydGV4dFtpICsgal07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcclxuICAgIH1cclxufVxyXG5fQ0JDX2l2ID0gbmV3IFdlYWtNYXAoKSwgX0NCQ19sYXN0QmxvY2sgPSBuZXcgV2Vha01hcCgpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWNiYy5qcy5tYXAiLCIvLyBDb3VudGVyIE1vZGVcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn07XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn07XHJcbnZhciBfQ1RSX3JlbWFpbmluZywgX0NUUl9yZW1haW5pbmdJbmRleCwgX0NUUl9jb3VudGVyO1xyXG5pbXBvcnQgeyBNb2RlT2ZPcGVyYXRpb24gfSBmcm9tIFwiLi9tb2RlLmpzXCI7XHJcbmV4cG9ydCBjbGFzcyBDVFIgZXh0ZW5kcyBNb2RlT2ZPcGVyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCBpbml0aWFsVmFsdWUpIHtcclxuICAgICAgICBzdXBlcihcIkNUUlwiLCBrZXksIENUUik7XHJcbiAgICAgICAgLy8gUmVtYWluaW5nIGJ5dGVzIGZvciB0aGUgb25lLXRpbWUgcGFkXHJcbiAgICAgICAgX0NUUl9yZW1haW5pbmcuc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICAgICAgX0NUUl9yZW1haW5pbmdJbmRleC5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgICAgICAvLyBUaGUgY3VycmVudCBjb3VudGVyXHJcbiAgICAgICAgX0NUUl9jb3VudGVyLnNldCh0aGlzLCB2b2lkIDApO1xyXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9jb3VudGVyLCBuZXcgVWludDhBcnJheSgxNiksIFwiZlwiKTtcclxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpLmZpbGwoMCk7XHJcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKSwgXCJmXCIpOyAvLyBUaGlzIHdpbGwgYmUgZGlzY2FyZGVkIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCAxNiwgXCJmXCIpO1xyXG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIChpbml0aWFsVmFsdWUpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q291bnRlclZhbHVlKGluaXRpYWxWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNldENvdW50ZXJCeXRlcyhpbml0aWFsVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBjb3VudGVyKCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKSk7IH1cclxuICAgIHNldENvdW50ZXJWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY291bnRlciBpbml0aWFsIGludGVnZXIgdmFsdWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTU7IGluZGV4ID49IDA7IC0taW5kZXgpIHtcclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpbmRleF0gPSB2YWx1ZSAlIDI1NjtcclxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gMjU2KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRDb3VudGVyQnl0ZXModmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAxNikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjb3VudGVyIGluaXRpYWwgVWludDhBcnJheSB2YWx1ZSBsZW5ndGhcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikuc2V0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGluY3JlbWVudCgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTU7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2ldID09PSAyNTUpIHtcclxuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaV0gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpXSsrO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgY3J5cHR0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNyeXB0dGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCBcImZcIikgPT09IDE2KSB7XHJcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nLCB0aGlzLmFlcy5lbmNyeXB0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikpLCBcImZcIik7XHJcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIDAsIFwiZlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3J5cHR0ZXh0W2ldIF49IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmcsIFwiZlwiKVtfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIChfYiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgXCJmXCIpLCBfYSA9IF9iKyssIF9iKSwgXCJmXCIpLCBfYV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjcnlwdHRleHQ7XHJcbiAgICB9XHJcbiAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0KGNpcGhlcnRleHQpO1xyXG4gICAgfVxyXG59XHJcbl9DVFJfcmVtYWluaW5nID0gbmV3IFdlYWtNYXAoKSwgX0NUUl9yZW1haW5pbmdJbmRleCA9IG5ldyBXZWFrTWFwKCksIF9DVFJfY291bnRlciA9IG5ldyBXZWFrTWFwKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtY3RyLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBwa2NzN1BhZChkYXRhKSB7XHJcbiAgICBjb25zdCBwYWRkZXIgPSAxNiAtIChkYXRhLmxlbmd0aCAlIDE2KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgcGFkZGVyKTtcclxuICAgIHJlc3VsdC5zZXQoZGF0YSk7XHJcbiAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICByZXN1bHRbaV0gPSBwYWRkZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBwa2NzN1N0cmlwKGRhdGEpIHtcclxuICAgIGlmIChkYXRhLmxlbmd0aCA8IDE2KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUEtDUyM3IGludmFsaWQgbGVuZ3RoJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYWRkZXIgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XHJcbiAgICBpZiAocGFkZGVyID4gMTYpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQS0NTIzcgcGFkZGluZyBieXRlIG91dCBvZiByYW5nZScpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBwYWRkZXI7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRlcjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGRhdGFbbGVuZ3RoICsgaV0gIT09IHBhZGRlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQS0NTIzcgaW52YWxpZCBwYWRkaW5nIGJ5dGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YS5zdWJhcnJheSgwLCBsZW5ndGgpKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWRkaW5nLmpzLm1hcCIsIi8qKlxyXG4gKiAgQF9pZ25vcmVcclxuICovXHJcbmltcG9ydCB7IGdldEJ5dGVzQ29weSwgYXNzZXJ0QXJndW1lbnQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmV4cG9ydCBmdW5jdGlvbiBsb29zZUFycmF5aWZ5KGhleFN0cmluZykge1xyXG4gICAgaWYgKHR5cGVvZiAoaGV4U3RyaW5nKSA9PT0gXCJzdHJpbmdcIiAmJiAhaGV4U3RyaW5nLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xyXG4gICAgICAgIGhleFN0cmluZyA9IFwiMHhcIiArIGhleFN0cmluZztcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRCeXRlc0NvcHkoaGV4U3RyaW5nKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24genBhZCh2YWx1ZSwgbGVuZ3RoKSB7XHJcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XHJcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFsdWUgPSAnMCcgKyB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFzc3dvcmQocGFzc3dvcmQpIHtcclxuICAgIGlmICh0eXBlb2YgKHBhc3N3b3JkKSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFwiTkZLQ1wiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRCeXRlc0NvcHkocGFzc3dvcmQpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzcGVsdW5rKG9iamVjdCwgX3BhdGgpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gX3BhdGgubWF0Y2goL14oW2EtejAtOSRfLi1dKikoOihbYS16XSspKT8oISk/JC9pKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoICE9IG51bGwsIFwiaW52YWxpZCBwYXRoXCIsIFwicGF0aFwiLCBfcGF0aCk7XHJcbiAgICBjb25zdCBwYXRoID0gbWF0Y2hbMV07XHJcbiAgICBjb25zdCB0eXBlID0gbWF0Y2hbM107XHJcbiAgICBjb25zdCByZXFkID0gKG1hdGNoWzRdID09PSBcIiFcIik7XHJcbiAgICBsZXQgY3VyID0gb2JqZWN0O1xyXG4gICAgZm9yIChjb25zdCBjb21wIG9mIHBhdGgudG9Mb3dlckNhc2UoKS5zcGxpdCgnLicpKSB7XHJcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXIpKSB7XHJcbiAgICAgICAgICAgIGlmICghY29tcC5tYXRjaCgvXlswLTldKyQvKSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VyID0gY3VyW3BhcnNlSW50KGNvbXApXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChjdXIpID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IG51bGw7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBjb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBjdXJba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXIgPSBmb3VuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1ciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3NlcnRBcmd1bWVudCghcmVxZCB8fCBjdXIgIT0gbnVsbCwgXCJtaXNzaW5nIHJlcXVpcmVkIHZhbHVlXCIsIFwicGF0aFwiLCBwYXRoKTtcclxuICAgIGlmICh0eXBlICYmIGN1ciAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiaW50XCIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJzdHJpbmdcIiAmJiBjdXIubWF0Y2goL14tP1swLTldKyQvKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGN1cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIoY3VyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChjdXIpID09PSBcInN0cmluZ1wiICYmIGN1ci5tYXRjaCgvXi0/WzAtOS5dKiQvKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoY3VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlQXJyYXlpZnkoY3VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gXCJhcnJheVwiICYmIEFycmF5LmlzQXJyYXkoY3VyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gdHlwZW9mIChjdXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgd3JvbmcgdHlwZSBmb3VuZCBmb3IgJHt0eXBlfSBgLCBcInBhdGhcIiwgcGF0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VyO1xyXG59XHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiBmb2xsb3cob2JqZWN0OiBhbnksIHBhdGg6IHN0cmluZyk6IG51bGwgfCBzdHJpbmcge1xyXG4gICAgbGV0IGN1cnJlbnRDaGlsZCA9IG9iamVjdDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgcGF0aC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJykpIHtcclxuXHJcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcclxuICAgICAgICBsZXQgbWF0Y2hpbmdDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VycmVudENoaWxkKSB7XHJcbiAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGNvbXApIHtcclxuICAgICAgICAgICAgICAgICBtYXRjaGluZ0NoaWxkID0gY3VycmVudENoaWxkW2tleV07XHJcbiAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobWF0Y2hpbmdDaGlsZCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxyXG5cclxuICAgICAgICBjdXJyZW50Q2hpbGQgPSBtYXRjaGluZ0NoaWxkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjdXJyZW50Q2hpbGQ7XHJcbn1cclxuXHJcbi8vIFwicGF0aC90by9zb21ldGhpbmc6dHlwZSFcIlxyXG5leHBvcnQgZnVuY3Rpb24gZm9sbG93UmVxdWlyZWQoZGF0YTogYW55LCBwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgdmFsdWUgPSBmb2xsb3coZGF0YSwgcGF0aCk7XHJcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgeyByZXR1cm4gdmFsdWU7IH1cclxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB2YWx1ZVwiLCBgZGF0YTokeyBwYXRoIH1gLFxyXG4gICAgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG59XHJcbiovXHJcbi8vIFNlZTogaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQxMjIudHh0IChTZWN0aW9uIDQuNClcclxuLypcclxuZXhwb3J0IGZ1bmN0aW9uIHV1aWRWNChyYW5kb21CeXRlczogQnl0ZXNMaWtlKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMocmFuZG9tQnl0ZXMsIFwicmFuZG9tQnl0ZXNcIik7XHJcblxyXG4gICAgLy8gU2VjdGlvbjogNC4xLjM6XHJcbiAgICAvLyAtIHRpbWVfaGlfYW5kX3ZlcnNpb25bMTI6MTZdID0gMGIwMTAwXHJcbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDtcclxuXHJcbiAgICAvLyBTZWN0aW9uIDQuNFxyXG4gICAgLy8gLSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkWzZdID0gMGIwXHJcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbN10gPSAwYjFcclxuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlID0gaGV4bGlmeShieXRlcyk7XHJcblxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgIHZhbHVlLnN1YnN0cmluZygyLCAxMCksXHJcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTAsIDE0KSxcclxuICAgICAgIHZhbHVlLnN1YnN0cmluZygxNCwgMTgpLFxyXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDE4LCAyMiksXHJcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMjIsIDM0KSxcclxuICAgIF0uam9pbihcIi1cIik7XHJcbn1cclxuKi9cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiLyoqXHJcbiAqICBUaGUgSlNPTiBXYWxsZXQgZm9ybWF0cyBhbGxvdyBhIHNpbXBsZSB3YXkgdG8gc3RvcmUgdGhlIHByaXZhdGVcclxuICogIGtleXMgbmVlZGVkIGluIEV0aGVyZXVtIGFsb25nIHdpdGggcmVsYXRlZCBpbmZvcm1hdGlvbiBhbmQgYWxsb3dzXHJcbiAqICBmb3IgZXh0ZW5zaWJsZSBmb3JtcyBvZiBlbmNyeXB0aW9uLlxyXG4gKlxyXG4gKiAgVGhlc2UgdXRpbGl0aWVzIGZhY2lsaXRhdGUgZGVjcnlwdGluZyBhbmQgZW5jcnlwdGluZyB0aGUgbW9zdCBjb21tb25cclxuICogIEpTT04gV2FsbGV0IGZvcm1hdHMuXHJcbiAqXHJcbiAqICBAX3N1YnNlY3Rpb246IGFwaS93YWxsZXQ6SlNPTiBXYWxsZXRzICBbanNvbi13YWxsZXRzXVxyXG4gKi9cclxuaW1wb3J0IHsgQ1RSIH0gZnJvbSBcImFlcy1qc1wiO1xyXG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcclxuaW1wb3J0IHsga2VjY2FrMjU2LCBwYmtkZjIsIHJhbmRvbUJ5dGVzLCBzY3J5cHQsIHNjcnlwdFN5bmMgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbXB1dGVBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IGNvbmNhdCwgZ2V0Qnl0ZXMsIGhleGxpZnksIHV1aWRWNCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRQYXNzd29yZCwgc3BlbHVuaywgenBhZCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb24uanNcIjtcclxuY29uc3QgZGVmYXVsdFBhdGggPSBcIm0vNDQnLzYwJy8wJy8wLzBcIjtcclxuLyoqXHJcbiAqICBSZXR1cm5zIHRydWUgaWYgJSVqc29uJSUgaXMgYSB2YWxpZCBKU09OIEtleXN0b3JlIFdhbGxldC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0tleXN0b3JlSnNvbihqc29uKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAoKGRhdGEudmVyc2lvbiAhPSBudWxsKSA/IHBhcnNlSW50KGRhdGEudmVyc2lvbikgOiAwKTtcclxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGRlY3J5cHQoZGF0YSwga2V5LCBjaXBoZXJ0ZXh0KSB7XHJcbiAgICBjb25zdCBjaXBoZXIgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmNpcGhlcjpzdHJpbmdcIik7XHJcbiAgICBpZiAoY2lwaGVyID09PSBcImFlcy0xMjgtY3RyXCIpIHtcclxuICAgICAgICBjb25zdCBpdiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8uY2lwaGVycGFyYW1zLml2OmRhdGEhXCIpO1xyXG4gICAgICAgIGNvbnN0IGFlc0N0ciA9IG5ldyBDVFIoa2V5LCBpdik7XHJcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYWVzQ3RyLmRlY3J5cHQoY2lwaGVydGV4dCkpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIGNpcGhlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgb3BlcmF0aW9uOiBcImRlY3J5cHRcIlxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWNjb3VudChkYXRhLCBfa2V5KSB7XHJcbiAgICBjb25zdCBrZXkgPSBnZXRCeXRlcyhfa2V5KTtcclxuICAgIGNvbnN0IGNpcGhlcnRleHQgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmNpcGhlcnRleHQ6ZGF0YSFcIik7XHJcbiAgICBjb25zdCBjb21wdXRlZE1BQyA9IGhleGxpZnkoa2VjY2FrMjU2KGNvbmNhdChba2V5LnNsaWNlKDE2LCAzMiksIGNpcGhlcnRleHRdKSkpLnN1YnN0cmluZygyKTtcclxuICAgIGFzc2VydEFyZ3VtZW50KGNvbXB1dGVkTUFDID09PSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLm1hYzpzdHJpbmchXCIpLnRvTG93ZXJDYXNlKCksIFwiaW5jb3JyZWN0IHBhc3N3b3JkXCIsIFwicGFzc3dvcmRcIiwgXCJbIFJFREFDVEVEIF1cIik7XHJcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gZGVjcnlwdChkYXRhLCBrZXkuc2xpY2UoMCwgMTYpLCBjaXBoZXJ0ZXh0KTtcclxuICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcyhwcml2YXRlS2V5KTtcclxuICAgIGlmIChkYXRhLmFkZHJlc3MpIHtcclxuICAgICAgICBsZXQgY2hlY2sgPSBkYXRhLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoIWNoZWNrLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xyXG4gICAgICAgICAgICBjaGVjayA9IFwiMHhcIiArIGNoZWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChnZXRBZGRyZXNzKGNoZWNrKSA9PT0gYWRkcmVzcywgXCJrZXlzdG9yZSBhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIiwgXCJhZGRyZXNzXCIsIGRhdGEuYWRkcmVzcyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzLCBwcml2YXRlS2V5IH07XHJcbiAgICAvLyBWZXJzaW9uIDAuMSB4LWV0aGVycyBtZXRhZGF0YSBtdXN0IGNvbnRhaW4gYW4gZW5jcnlwdGVkIG1uZW1vbmljIHBocmFzZVxyXG4gICAgY29uc3QgdmVyc2lvbiA9IHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy52ZXJzaW9uOnN0cmluZ1wiKTtcclxuICAgIGlmICh2ZXJzaW9uID09PSBcIjAuMVwiKSB7XHJcbiAgICAgICAgY29uc3QgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcclxuICAgICAgICBjb25zdCBtbmVtb25pY0NpcGhlcnRleHQgPSBzcGVsdW5rKGRhdGEsIFwieC1ldGhlcnMubW5lbW9uaWNDaXBoZXJ0ZXh0OmRhdGEhXCIpO1xyXG4gICAgICAgIGNvbnN0IG1uZW1vbmljSXYgPSBzcGVsdW5rKGRhdGEsIFwieC1ldGhlcnMubW5lbW9uaWNDb3VudGVyOmRhdGEhXCIpO1xyXG4gICAgICAgIGNvbnN0IG1uZW1vbmljQWVzQ3RyID0gbmV3IENUUihtbmVtb25pY0tleSwgbW5lbW9uaWNJdik7XHJcbiAgICAgICAgYWNjb3VudC5tbmVtb25pYyA9IHtcclxuICAgICAgICAgICAgcGF0aDogKHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy5wYXRoOnN0cmluZ1wiKSB8fCBkZWZhdWx0UGF0aCksXHJcbiAgICAgICAgICAgIGxvY2FsZTogKHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy5sb2NhbGU6c3RyaW5nXCIpIHx8IFwiZW5cIiksXHJcbiAgICAgICAgICAgIGVudHJvcHk6IGhleGxpZnkoZ2V0Qnl0ZXMobW5lbW9uaWNBZXNDdHIuZGVjcnlwdChtbmVtb25pY0NpcGhlcnRleHQpKSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjY291bnQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGVjcnlwdEtkZlBhcmFtcyhkYXRhKSB7XHJcbiAgICBjb25zdCBrZGYgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZjpzdHJpbmdcIik7XHJcbiAgICBpZiAoa2RmICYmIHR5cGVvZiAoa2RmKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGlmIChrZGYudG9Mb3dlckNhc2UoKSA9PT0gXCJzY3J5cHRcIikge1xyXG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuc2FsdDpkYXRhIVwiKTtcclxuICAgICAgICAgICAgY29uc3QgTiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLm46aW50IVwiKTtcclxuICAgICAgICAgICAgY29uc3QgciA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnI6aW50IVwiKTtcclxuICAgICAgICAgICAgY29uc3QgcCA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnA6aW50IVwiKTtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIE4gaXMgYSBwb3dlciBvZiAyXHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE4gPiAwICYmIChOICYgKE4gLSAxKSkgPT09IDAsIFwiaW52YWxpZCBrZGYuTlwiLCBcImtkZi5OXCIsIE4pO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyID4gMCAmJiBwID4gMCwgXCJpbnZhbGlkIGtkZlwiLCBcImtkZlwiLCBrZGYpO1xyXG4gICAgICAgICAgICBjb25zdCBka0xlbiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmRrbGVuOmludCFcIik7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGRrTGVuID09PSAzMiwgXCJpbnZhbGlkIGtkZi5ka2xlblwiLCBcImtkZi5kZmxlblwiLCBka0xlbik7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwic2NyeXB0XCIsIHNhbHQsIE4sIHIsIHAsIGRrTGVuOiA2NCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZGYudG9Mb3dlckNhc2UoKSA9PT0gXCJwYmtkZjJcIikge1xyXG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuc2FsdDpkYXRhIVwiKTtcclxuICAgICAgICAgICAgY29uc3QgcHJmID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMucHJmOnN0cmluZyFcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGFsZ29yaXRobSA9IHByZi5zcGxpdChcIi1cIikucG9wKCk7XHJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFsZ29yaXRobSA9PT0gXCJzaGEyNTZcIiB8fCBhbGdvcml0aG0gPT09IFwic2hhNTEyXCIsIFwiaW52YWxpZCBrZGYucGRmXCIsIFwia2RmLnBkZlwiLCBwcmYpO1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmM6aW50IVwiKTtcclxuICAgICAgICAgICAgY29uc3QgZGtMZW4gPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5ka2xlbjppbnQhXCIpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChka0xlbiA9PT0gMzIsIFwiaW52YWxpZCBrZGYuZGtsZW5cIiwgXCJrZGYuZGtsZW5cIiwgZGtMZW4pO1xyXG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcInBia2RmMlwiLCBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uXCIsIFwia2RmXCIsIGtkZik7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSBhY2NvdW50IGRldGFpbHMgZm9yIHRoZSBKU09OIEtleXN0b3JlIFdhbGxldCAlJWpzb24lJVxyXG4gKiAgdXNpbmcgJSVwYXNzd29yZCUlLlxyXG4gKlxyXG4gKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZlcnNpb25dKGRlY3J5cHRLZXlzdG9yZUpzb24pXHJcbiAqICBpbnN0ZWFkLCB3aGljaCBhbGxvd3MgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byBrZWVwIHRoZSB1c2VyIGluZm9ybWVkXHJcbiAqICBhcyB0byB0aGUgZGVjcnlwdGlvbiBzdGF0dXMuXHJcbiAqXHJcbiAqICBUaGlzIG1ldGhvZCB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIChmcmVlemluZyBhbGwgVUkpIHVudGlsIGRlY3J5cHRpb25cclxuICogIGlzIGNvbXBsZXRlLCB3aGljaCBjYW4gdGFrZSBxdWl0ZSBzb21lIHRpbWUsIGRlcGVuZGluZyBvbiB0aGUgd2FsbGV0XHJcbiAqICBwYXJhbXRlcnMgYW5kIHBsYXRmb3JtLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHRLZXlzdG9yZUpzb25TeW5jKGpzb24sIF9wYXNzd29yZCkge1xyXG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XHJcbiAgICBjb25zdCBwYXNzd29yZCA9IGdldFBhc3N3b3JkKF9wYXNzd29yZCk7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBnZXREZWNyeXB0S2RmUGFyYW1zKGRhdGEpO1xyXG4gICAgaWYgKHBhcmFtcy5uYW1lID09PSBcInBia2RmMlwiKSB7XHJcbiAgICAgICAgY29uc3QgeyBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9ID0gcGFyYW1zO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHBia2RmMihwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0pO1xyXG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3NlcnQocGFyYW1zLm5hbWUgPT09IFwic2NyeXB0XCIsIFwiY2Fubm90IGJlIHJlYWNoZWRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgcGFyYW1zIH0pO1xyXG4gICAgY29uc3QgeyBzYWx0LCBOLCByLCBwLCBka0xlbiB9ID0gcGFyYW1zO1xyXG4gICAgY29uc3Qga2V5ID0gc2NyeXB0U3luYyhwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pO1xyXG4gICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcclxufVxyXG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQoKCkgPT4geyByZXNvbHZlKCk7IH0sIGR1cmF0aW9uKTsgfSk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXNvbHZlcyB0byB0aGUgZGVjcnlwdGVkIEpTT04gS2V5c3RvcmUgV2FsbGV0ICUlanNvbiUlIHVzaW5nIHRoZVxyXG4gKiAgJSVwYXNzd29yZCUlLlxyXG4gKlxyXG4gKiAgSWYgcHJvdmlkZWQsICUlcHJvZ3Jlc3MlJSB3aWxsIGJlIGNhbGxlZCBwZXJpb2RpY2FsbHkgZHVyaW5nIHRoZVxyXG4gKiAgZGVjcnB5dGlvbiB0byBwcm92aWRlIGZlZWRiYWNrLCBhbmQgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnNcclxuICogIGBgZmFsc2VgYCB3aWxsIGhhbHQgZGVjcnlwdGlvbi5cclxuICpcclxuICogIFRoZSAlJXByb2dyZXNzQ2FsbGJhY2slJSB3aWxsICoqYWx3YXlzKiogcmVjZWl2ZSBgYDBgYCBiZWZvcmVcclxuICogIGRlY3J5cHRpb24gYmVnaW5zIGFuZCBgYDFgYCB3aGVuIGNvbXBsZXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRLZXlzdG9yZUpzb24oanNvbiwgX3Bhc3N3b3JkLCBwcm9ncmVzcykge1xyXG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XHJcbiAgICBjb25zdCBwYXNzd29yZCA9IGdldFBhc3N3b3JkKF9wYXNzd29yZCk7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBnZXREZWNyeXB0S2RmUGFyYW1zKGRhdGEpO1xyXG4gICAgaWYgKHBhcmFtcy5uYW1lID09PSBcInBia2RmMlwiKSB7XHJcbiAgICAgICAgaWYgKHByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIHByb2dyZXNzKDApO1xyXG4gICAgICAgICAgICBhd2FpdCBzdGFsbCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9ID0gcGFyYW1zO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHBia2RmMihwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGlmIChwcm9ncmVzcykge1xyXG4gICAgICAgICAgICBwcm9ncmVzcygxKTtcclxuICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3NlcnQocGFyYW1zLm5hbWUgPT09IFwic2NyeXB0XCIsIFwiY2Fubm90IGJlIHJlYWNoZWRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgcGFyYW1zIH0pO1xyXG4gICAgY29uc3QgeyBzYWx0LCBOLCByLCBwLCBka0xlbiB9ID0gcGFyYW1zO1xyXG4gICAgY29uc3Qga2V5ID0gYXdhaXQgc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3MpO1xyXG4gICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcclxufVxyXG5mdW5jdGlvbiBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpIHtcclxuICAgIC8vIENoZWNrL2dlbmVyYXRlIHRoZSBzYWx0XHJcbiAgICBjb25zdCBzYWx0ID0gKG9wdGlvbnMuc2FsdCAhPSBudWxsKSA/IGdldEJ5dGVzKG9wdGlvbnMuc2FsdCwgXCJvcHRpb25zLnNhbHRcIikgOiByYW5kb21CeXRlcygzMik7XHJcbiAgICAvLyBPdmVycmlkZSB0aGUgc2NyeXB0IHBhc3N3b3JkLWJhc2VkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnNcclxuICAgIGxldCBOID0gKDEgPDwgMTcpLCByID0gOCwgcCA9IDE7XHJcbiAgICBpZiAob3B0aW9ucy5zY3J5cHQpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQuTikge1xyXG4gICAgICAgICAgICBOID0gb3B0aW9ucy5zY3J5cHQuTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0LnIpIHtcclxuICAgICAgICAgICAgciA9IG9wdGlvbnMuc2NyeXB0LnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5wKSB7XHJcbiAgICAgICAgICAgIHAgPSBvcHRpb25zLnNjcnlwdC5wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoTikgPT09IFwibnVtYmVyXCIgJiYgTiA+IDAgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIoTikgJiYgKEJpZ0ludChOKSAmIEJpZ0ludChOIC0gMSkpID09PSBCaWdJbnQoMCksIFwiaW52YWxpZCBzY3J5cHQgTiBwYXJhbWV0ZXJcIiwgXCJvcHRpb25zLk5cIiwgTik7XHJcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHIpID09PSBcIm51bWJlclwiICYmIHIgPiAwICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHIpLCBcImludmFsaWQgc2NyeXB0IHIgcGFyYW1ldGVyXCIsIFwib3B0aW9ucy5yXCIsIHIpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChwKSA9PT0gXCJudW1iZXJcIiAmJiBwID4gMCAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihwKSwgXCJpbnZhbGlkIHNjcnlwdCBwIHBhcmFtZXRlclwiLCBcIm9wdGlvbnMucFwiLCBwKTtcclxuICAgIHJldHVybiB7IG5hbWU6IFwic2NyeXB0XCIsIGRrTGVuOiAzMiwgc2FsdCwgTiwgciwgcCB9O1xyXG59XHJcbmZ1bmN0aW9uIF9lbmNyeXB0S2V5c3RvcmUoa2V5LCBrZGYsIGFjY291bnQsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBnZXRCeXRlcyhhY2NvdW50LnByaXZhdGVLZXksIFwicHJpdmF0ZUtleVwiKTtcclxuICAgIC8vIE92ZXJyaWRlIGluaXRpYWxpemF0aW9uIHZlY3RvclxyXG4gICAgY29uc3QgaXYgPSAob3B0aW9ucy5pdiAhPSBudWxsKSA/IGdldEJ5dGVzKG9wdGlvbnMuaXYsIFwib3B0aW9ucy5pdlwiKSA6IHJhbmRvbUJ5dGVzKDE2KTtcclxuICAgIGFzc2VydEFyZ3VtZW50KGl2Lmxlbmd0aCA9PT0gMTYsIFwiaW52YWxpZCBvcHRpb25zLml2IGxlbmd0aFwiLCBcIm9wdGlvbnMuaXZcIiwgb3B0aW9ucy5pdik7XHJcbiAgICAvLyBPdmVycmlkZSB0aGUgdXVpZFxyXG4gICAgY29uc3QgdXVpZFJhbmRvbSA9IChvcHRpb25zLnV1aWQgIT0gbnVsbCkgPyBnZXRCeXRlcyhvcHRpb25zLnV1aWQsIFwib3B0aW9ucy51dWlkXCIpIDogcmFuZG9tQnl0ZXMoMTYpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQodXVpZFJhbmRvbS5sZW5ndGggPT09IDE2LCBcImludmFsaWQgb3B0aW9ucy51dWlkIGxlbmd0aFwiLCBcIm9wdGlvbnMudXVpZFwiLCBvcHRpb25zLml2KTtcclxuICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIHdhbGxldCAoYXMgcGVyIFdlYjMgc2VjcmV0IHN0b3JhZ2UpXHJcbiAgICAvLyAtIDMyIGJ5dGVzICAgQXMgbm9ybWFsIGZvciB0aGUgV2ViMyBzZWNyZXQgc3RvcmFnZSAoZGVyaXZlZEtleSwgbWFjUHJlZml4KVxyXG4gICAgLy8gLSAzMiBieXRlcyAgIEFFUyBrZXkgdG8gZW5jcnlwdCBtbmVtb25pYyB3aXRoIChyZXF1aXJlZCBoZXJlIHRvIGJlIEV0aGVycyBXYWxsZXQpXHJcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0ga2V5LnNsaWNlKDAsIDE2KTtcclxuICAgIGNvbnN0IG1hY1ByZWZpeCA9IGtleS5zbGljZSgxNiwgMzIpO1xyXG4gICAgLy8gRW5jcnlwdCB0aGUgcHJpdmF0ZSBrZXlcclxuICAgIGNvbnN0IGFlc0N0ciA9IG5ldyBDVFIoZGVyaXZlZEtleSwgaXYpO1xyXG4gICAgY29uc3QgY2lwaGVydGV4dCA9IGdldEJ5dGVzKGFlc0N0ci5lbmNyeXB0KHByaXZhdGVLZXkpKTtcclxuICAgIC8vIENvbXB1dGUgdGhlIG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZSwgdXNlZCB0byBjaGVjayB0aGUgcGFzc3dvcmRcclxuICAgIGNvbnN0IG1hYyA9IGtlY2NhazI1Nihjb25jYXQoW21hY1ByZWZpeCwgY2lwaGVydGV4dF0pKTtcclxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9XZWIzLVNlY3JldC1TdG9yYWdlLURlZmluaXRpb25cclxuICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgYWRkcmVzczogYWNjb3VudC5hZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgIGlkOiB1dWlkVjQodXVpZFJhbmRvbSksXHJcbiAgICAgICAgdmVyc2lvbjogMyxcclxuICAgICAgICBDcnlwdG86IHtcclxuICAgICAgICAgICAgY2lwaGVyOiBcImFlcy0xMjgtY3RyXCIsXHJcbiAgICAgICAgICAgIGNpcGhlcnBhcmFtczoge1xyXG4gICAgICAgICAgICAgICAgaXY6IGhleGxpZnkoaXYpLnN1YnN0cmluZygyKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2lwaGVydGV4dDogaGV4bGlmeShjaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksXHJcbiAgICAgICAgICAgIGtkZjogXCJzY3J5cHRcIixcclxuICAgICAgICAgICAga2RmcGFyYW1zOiB7XHJcbiAgICAgICAgICAgICAgICBzYWx0OiBoZXhsaWZ5KGtkZi5zYWx0KS5zdWJzdHJpbmcoMiksXHJcbiAgICAgICAgICAgICAgICBuOiBrZGYuTixcclxuICAgICAgICAgICAgICAgIGRrbGVuOiAzMixcclxuICAgICAgICAgICAgICAgIHA6IGtkZi5wLFxyXG4gICAgICAgICAgICAgICAgcjoga2RmLnJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWFjOiBtYWMuc3Vic3RyaW5nKDIpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIElmIHdlIGhhdmUgYSBtbmVtb25pYywgZW5jcnlwdCBpdCBpbnRvIHRoZSBKU09OIHdhbGxldFxyXG4gICAgaWYgKGFjY291bnQubW5lbW9uaWMpIHtcclxuICAgICAgICBjb25zdCBjbGllbnQgPSAob3B0aW9ucy5jbGllbnQgIT0gbnVsbCkgPyBvcHRpb25zLmNsaWVudCA6IGBldGhlcnMvJHt2ZXJzaW9ufWA7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGFjY291bnQubW5lbW9uaWMucGF0aCB8fCBkZWZhdWx0UGF0aDtcclxuICAgICAgICBjb25zdCBsb2NhbGUgPSBhY2NvdW50Lm1uZW1vbmljLmxvY2FsZSB8fCBcImVuXCI7XHJcbiAgICAgICAgY29uc3QgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcclxuICAgICAgICBjb25zdCBlbnRyb3B5ID0gZ2V0Qnl0ZXMoYWNjb3VudC5tbmVtb25pYy5lbnRyb3B5LCBcImFjY291bnQubW5lbW9uaWMuZW50cm9weVwiKTtcclxuICAgICAgICBjb25zdCBtbmVtb25pY0l2ID0gcmFuZG9tQnl0ZXMoMTYpO1xyXG4gICAgICAgIGNvbnN0IG1uZW1vbmljQWVzQ3RyID0gbmV3IENUUihtbmVtb25pY0tleSwgbW5lbW9uaWNJdik7XHJcbiAgICAgICAgY29uc3QgbW5lbW9uaWNDaXBoZXJ0ZXh0ID0gZ2V0Qnl0ZXMobW5lbW9uaWNBZXNDdHIuZW5jcnlwdChlbnRyb3B5KSk7XHJcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSAobm93LmdldFVUQ0Z1bGxZZWFyKCkgKyBcIi1cIiArXHJcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICtcclxuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDRGF0ZSgpLCAyKSArIFwiVFwiICtcclxuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDSG91cnMoKSwgMikgKyBcIi1cIiArXHJcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ01pbnV0ZXMoKSwgMikgKyBcIi1cIiArXHJcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ1NlY29uZHMoKSwgMikgKyBcIi4wWlwiKTtcclxuICAgICAgICBjb25zdCBnZXRoRmlsZW5hbWUgPSAoXCJVVEMtLVwiICsgdGltZXN0YW1wICsgXCItLVwiICsgZGF0YS5hZGRyZXNzKTtcclxuICAgICAgICBkYXRhW1wieC1ldGhlcnNcIl0gPSB7XHJcbiAgICAgICAgICAgIGNsaWVudCwgZ2V0aEZpbGVuYW1lLCBwYXRoLCBsb2NhbGUsXHJcbiAgICAgICAgICAgIG1uZW1vbmljQ291bnRlcjogaGV4bGlmeShtbmVtb25pY0l2KS5zdWJzdHJpbmcoMiksXHJcbiAgICAgICAgICAgIG1uZW1vbmljQ2lwaGVydGV4dDogaGV4bGlmeShtbmVtb25pY0NpcGhlcnRleHQpLnN1YnN0cmluZygyKSxcclxuICAgICAgICAgICAgdmVyc2lvbjogXCIwLjFcIlxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm4gdGhlIEpTT04gS2V5c3RvcmUgV2FsbGV0IGZvciAlJWFjY291bnQlJSBlbmNyeXB0ZWQgd2l0aFxyXG4gKiAgJSVwYXNzd29yZCUlLlxyXG4gKlxyXG4gKiAgVGhlICUlb3B0aW9ucyUlIGNhbiBiZSB1c2VkIHRvIHR1bmUgdGhlIHBhc3N3b3JkLWJhc2VkIGtleVxyXG4gKiAgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzLCBleHBsaWNpdGx5IHNldCB0aGUgcmFuZG9tIHZhbHVlc1xyXG4gKiAgdXNlZC4gQW55IHByb3ZpZGVkIFtbUHJvZ3Jlc3NDYWxsYmFja11dIGlzIGlnbm9yZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyhhY2NvdW50LCBwYXNzd29yZCwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhc3N3b3JkQnl0ZXMgPSBnZXRQYXNzd29yZChwYXNzd29yZCk7XHJcbiAgICBjb25zdCBrZGYgPSBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpO1xyXG4gICAgY29uc3Qga2V5ID0gc2NyeXB0U3luYyhwYXNzd29yZEJ5dGVzLCBrZGYuc2FsdCwga2RmLk4sIGtkZi5yLCBrZGYucCwgNjQpO1xyXG4gICAgcmV0dXJuIF9lbmNyeXB0S2V5c3RvcmUoZ2V0Qnl0ZXMoa2V5KSwga2RmLCBhY2NvdW50LCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogIFJlc29sdmVkIHRvIHRoZSBKU09OIEtleXN0b3JlIFdhbGxldCBmb3IgJSVhY2NvdW50JSUgZW5jcnlwdGVkXHJcbiAqICB3aXRoICUlcGFzc3dvcmQlJS5cclxuICpcclxuICogIFRoZSAlJW9wdGlvbnMlJSBjYW4gYmUgdXNlZCB0byB0dW5lIHRoZSBwYXNzd29yZC1iYXNlZCBrZXlcclxuICogIGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVycywgZXhwbGljaXRseSBzZXQgdGhlIHJhbmRvbSB2YWx1ZXNcclxuICogIHVzZWQgYW5kIHByb3ZpZGUgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byByZWNlaXZlIHBlcmlvZGljIHVwZGF0ZXNcclxuICogIG9uIHRoZSBjb21wbGV0aW9uIHN0YXR1cy4uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEtleXN0b3JlSnNvbihhY2NvdW50LCBwYXNzd29yZCwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhc3N3b3JkQnl0ZXMgPSBnZXRQYXNzd29yZChwYXNzd29yZCk7XHJcbiAgICBjb25zdCBrZGYgPSBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpO1xyXG4gICAgY29uc3Qga2V5ID0gYXdhaXQgc2NyeXB0KHBhc3N3b3JkQnl0ZXMsIGtkZi5zYWx0LCBrZGYuTiwga2RmLnIsIGtkZi5wLCA2NCwgb3B0aW9ucy5wcm9ncmVzc0NhbGxiYWNrKTtcclxuICAgIHJldHVybiBfZW5jcnlwdEtleXN0b3JlKGdldEJ5dGVzKGtleSksIGtkZiwgYWNjb3VudCwgb3B0aW9ucyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1rZXlzdG9yZS5qcy5tYXAiLCIvKipcclxuICogIEV4cGxhaW4gSEQgV2FsbGV0cy4uXHJcbiAqXHJcbiAqICBAX3N1YnNlY3Rpb246IGFwaS93YWxsZXQ6SEQgV2FsbGV0cyAgW2hkLXdhbGxldHNdXHJcbiAqL1xyXG5pbXBvcnQgeyBjb21wdXRlSG1hYywgcmFuZG9tQnl0ZXMsIHJpcGVtZDE2MCwgU2lnbmluZ0tleSwgc2hhMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBWb2lkU2lnbmVyIH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBjb21wdXRlQWRkcmVzcyB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBjb25jYXQsIGRhdGFTbGljZSwgZGVjb2RlQmFzZTU4LCBkZWZpbmVQcm9wZXJ0aWVzLCBlbmNvZGVCYXNlNTgsIGdldEJ5dGVzLCBoZXhsaWZ5LCBpc0J5dGVzTGlrZSwgZ2V0TnVtYmVyLCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b0JlSGV4LCBhc3NlcnRQcml2YXRlLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IExhbmdFbiB9IGZyb20gXCIuLi93b3JkbGlzdHMvbGFuZy1lbi5qc1wiO1xyXG5pbXBvcnQgeyBCYXNlV2FsbGV0IH0gZnJvbSBcIi4vYmFzZS13YWxsZXQuanNcIjtcclxuaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tIFwiLi9tbmVtb25pYy5qc1wiO1xyXG5pbXBvcnQgeyBlbmNyeXB0S2V5c3RvcmVKc29uLCBlbmNyeXB0S2V5c3RvcmVKc29uU3luYywgfSBmcm9tIFwiLi9qc29uLWtleXN0b3JlLmpzXCI7XHJcbi8qKlxyXG4gKiAgVGhlIGRlZmF1bHQgZGVyaXZhdGlvbiBwYXRoIGZvciBFdGhlcmV1bSBIRCBOb2Rlcy4gKGkuZS4gYGBcIm0vNDQnLzYwJy8wJy8wLzBcImBgKVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQYXRoID0gXCJtLzQ0Jy82MCcvMCcvMC8wXCI7XHJcbi8vIFwiQml0Y29pbiBzZWVkXCJcclxuY29uc3QgTWFzdGVyU2VjcmV0ID0gbmV3IFVpbnQ4QXJyYXkoWzY2LCAxMDUsIDExNiwgOTksIDExMSwgMTA1LCAxMTAsIDMyLCAxMTUsIDEwMSwgMTAxLCAxMDBdKTtcclxuY29uc3QgSGFyZGVuZWRCaXQgPSAweDgwMDAwMDAwO1xyXG5jb25zdCBOID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxXCIpO1xyXG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XHJcbmZ1bmN0aW9uIHpwYWQodmFsdWUsIGxlbmd0aCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XHJcbiAgICB3aGlsZSAodmFsdWUpIHtcclxuICAgICAgICByZXN1bHQgPSBOaWJibGVzW3ZhbHVlICUgMTZdICsgcmVzdWx0O1xyXG4gICAgICAgIHZhbHVlID0gTWF0aC50cnVuYyh2YWx1ZSAvIDE2KTtcclxuICAgIH1cclxuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgbGVuZ3RoICogMikge1xyXG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBlbmNvZGVCYXNlNThDaGVjayhfdmFsdWUpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gZ2V0Qnl0ZXMoX3ZhbHVlKTtcclxuICAgIGNvbnN0IGNoZWNrID0gZGF0YVNsaWNlKHNoYTI1NihzaGEyNTYodmFsdWUpKSwgMCwgNCk7XHJcbiAgICBjb25zdCBieXRlcyA9IGNvbmNhdChbdmFsdWUsIGNoZWNrXSk7XHJcbiAgICByZXR1cm4gZW5jb2RlQmFzZTU4KGJ5dGVzKTtcclxufVxyXG5jb25zdCBfZ3VhcmQgPSB7fTtcclxuZnVuY3Rpb24gc2VyX0koaW5kZXgsIGNoYWluQ29kZSwgcHVibGljS2V5LCBwcml2YXRlS2V5KSB7XHJcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoMzcpO1xyXG4gICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcclxuICAgICAgICBhc3NlcnQocHJpdmF0ZUtleSAhPSBudWxsLCBcImNhbm5vdCBkZXJpdmUgY2hpbGQgb2YgbmV1dGVyZWQgbm9kZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkZXJpdmVDaGlsZFwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gRGF0YSA9IDB4MDAgfHwgc2VyXzI1NihrX3BhcilcclxuICAgICAgICBkYXRhLnNldChnZXRCeXRlcyhwcml2YXRlS2V5KSwgMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBEYXRhID0gc2VyX3AocG9pbnQoa19wYXIpKVxyXG4gICAgICAgIGRhdGEuc2V0KGdldEJ5dGVzKHB1YmxpY0tleSkpO1xyXG4gICAgfVxyXG4gICAgLy8gRGF0YSArPSBzZXJfMzIoaSlcclxuICAgIGZvciAobGV0IGkgPSAyNDsgaSA+PSAwOyBpIC09IDgpIHtcclxuICAgICAgICBkYXRhWzMzICsgKGkgPj4gMyldID0gKChpbmRleCA+PiAoMjQgLSBpKSkgJiAweGZmKTtcclxuICAgIH1cclxuICAgIGNvbnN0IEkgPSBnZXRCeXRlcyhjb21wdXRlSG1hYyhcInNoYTUxMlwiLCBjaGFpbkNvZGUsIGRhdGEpKTtcclxuICAgIHJldHVybiB7IElMOiBJLnNsaWNlKDAsIDMyKSwgSVI6IEkuc2xpY2UoMzIpIH07XHJcbn1cclxuZnVuY3Rpb24gZGVyaXZlUGF0aChub2RlLCBwYXRoKSB7XHJcbiAgICBjb25zdCBjb21wb25lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XHJcbiAgICBhc3NlcnRBcmd1bWVudChjb21wb25lbnRzLmxlbmd0aCA+IDAsIFwiaW52YWxpZCBwYXRoXCIsIFwicGF0aFwiLCBwYXRoKTtcclxuICAgIGlmIChjb21wb25lbnRzWzBdID09PSBcIm1cIikge1xyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KG5vZGUuZGVwdGggPT09IDAsIGBjYW5ub3QgZGVyaXZlIHJvb3QgcGF0aCAoaS5lLiBwYXRoIHN0YXJ0aW5nIHdpdGggXCJtL1wiKSBmb3IgYSBub2RlIGF0IG5vbi16ZXJvIGRlcHRoICR7bm9kZS5kZXB0aH1gLCBcInBhdGhcIiwgcGF0aCk7XHJcbiAgICAgICAgY29tcG9uZW50cy5zaGlmdCgpO1xyXG4gICAgfVxyXG4gICAgbGV0IHJlc3VsdCA9IG5vZGU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xyXG4gICAgICAgIGlmIChjb21wb25lbnQubWF0Y2goL15bMC05XSsnJC8pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoY29tcG9uZW50LnN1YnN0cmluZygwLCBjb21wb25lbnQubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgcGF0aCBpbmRleFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kZXJpdmVDaGlsZChIYXJkZW5lZEJpdCArIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJC8pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoY29tcG9uZW50KTtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIHBhdGggaW5kZXhcIiwgYHBhdGhbJHtpfV1gLCBjb21wb25lbnQpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZGVyaXZlQ2hpbGQoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBwYXRoIGNvbXBvbmVudFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogIEFuICoqSEROb2RlV2FsbGV0KiogaXMgYSBbW1NpZ25lcl1dIGJhY2tlZCBieSB0aGUgcHJpdmF0ZSBrZXkgZGVyaXZlZFxyXG4gKiAgZnJvbSBhbiBIRCBOb2RlIHVzaW5nIHRoZSBbW2xpbmstYmlwLTMyXV0gc3RhbnRhcmQuXHJcbiAqXHJcbiAqICBBbiBIRCBOb2RlIGZvcm1zIGEgaGllcmFyY2hhbCBzdHJ1Y3R1cmUgd2l0aCBlYWNoIEhEIE5vZGUgaGF2aW5nIGFcclxuICogIHByaXZhdGUga2V5IGFuZCB0aGUgYWJpbGl0eSB0byBkZXJpdmUgY2hpbGQgSEQgTm9kZXMsIGRlZmluZWQgYnlcclxuICogIGEgcGF0aCBpbmRpY2F0aW5nIHRoZSBpbmRleCBvZiBlYWNoIGNoaWxkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEhETm9kZVdhbGxldCBleHRlbmRzIEJhc2VXYWxsZXQge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cclxuICAgICAqL1xyXG4gICAgcHVibGljS2V5O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZpbmdlcnByaW50LlxyXG4gICAgICpcclxuICAgICAqICBBIGZpbmdlcnByaW50IGFsbG93cyBxdWljayBxYXkgdG8gZGV0ZWN0IHBhcmVudCBhbmQgY2hpbGQgbm9kZXMsXHJcbiAgICAgKiAgYnV0IGRldmVsb3BlcnMgc2hvdWxkIGJlIHByZXBhcmVkIHRvIGRlYWwgd2l0aCBjb2xsaXNpb25zIGFzIGl0XHJcbiAgICAgKiAgaXMgb25seSA0IGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBmaW5nZXJwcmludDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwYXJlbnQgZmluZ2VycHJpbnQuXHJcbiAgICAgKi9cclxuICAgIHBhcmVudEZpbmdlcnByaW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIG1uZW1vbmljIHVzZWQgdG8gY3JlYXRlIHRoaXMgSEQgTm9kZSwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICpcclxuICAgICAqICBTb3VyY2VzIHN1Y2ggYXMgZXh0ZW5kZWQga2V5cyBkbyBub3QgZW5jb2RlIHRoZSBtbmVtb25pYywgaW5cclxuICAgICAqICB3aGljaCBjYXNlIHRoaXMgd2lsbCBiZSBgYG51bGxgYC5cclxuICAgICAqL1xyXG4gICAgbW5lbW9uaWM7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY2hhaW5jb2RlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhIHB1YmxpYyBrZXkgdXNlZFxyXG4gICAgICogIHRvIGRlcml2ZSBjaGlsZHJlbi5cclxuICAgICAqL1xyXG4gICAgY2hhaW5Db2RlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGRlcml2YXRpb24gcGF0aCBvZiB0aGlzIHdhbGxldC5cclxuICAgICAqXHJcbiAgICAgKiAgU2luY2UgZXh0ZW5kZWQga2V5cyBkbyBub3QgcHJvdmlkZSBmdWxsIHBhdGggZGV0YWlscywgdGhpc1xyXG4gICAgICogIG1heSBiZSBgYG51bGxgYCwgaWYgaW5zdGFudGlhdGVkIGZyb20gYSBzb3VyY2UgdGhhdCBkb2VzIG5vdFxyXG4gICAgICogIGVuY29kZSBpdC5cclxuICAgICAqL1xyXG4gICAgcGF0aDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBjaGlsZCBpbmRleCBvZiB0aGlzIHdhbGxldC4gVmFsdWVzIG92ZXIgYGAyICpcXCogMzFgYCBpbmRpY2F0ZVxyXG4gICAgICogIHRoZSBub2RlIGlzIGhhcmRlbmVkLlxyXG4gICAgICovXHJcbiAgICBpbmRleDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBkZXB0aCBvZiB0aGlzIHdhbGxldCwgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzXHJcbiAgICAgKiAgaW4gaXRzIHBhdGguXHJcbiAgICAgKi9cclxuICAgIGRlcHRoO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHNpZ25pbmdLZXksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aCwgbW5lbW9uaWMsIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgc3VwZXIoc2lnbmluZ0tleSwgcHJvdmlkZXIpO1xyXG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJIRE5vZGVXYWxsZXRcIik7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHB1YmxpY0tleTogc2lnbmluZ0tleS5jb21wcmVzc2VkUHVibGljS2V5IH0pO1xyXG4gICAgICAgIGNvbnN0IGZpbmdlcnByaW50ID0gZGF0YVNsaWNlKHJpcGVtZDE2MChzaGEyNTYodGhpcy5wdWJsaWNLZXkpKSwgMCwgNCk7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XHJcbiAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50LCBmaW5nZXJwcmludCxcclxuICAgICAgICAgICAgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGhcclxuICAgICAgICB9KTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbW5lbW9uaWMgfSk7XHJcbiAgICB9XHJcbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCB0aGlzLnNpZ25pbmdLZXksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnBhdGgsIHRoaXMuaW5kZXgsIHRoaXMuZGVwdGgsIHRoaXMubW5lbW9uaWMsIHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgICNhY2NvdW50KCkge1xyXG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3M6IHRoaXMuYWRkcmVzcywgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5IH07XHJcbiAgICAgICAgY29uc3QgbSA9IHRoaXMubW5lbW9uaWM7XHJcbiAgICAgICAgaWYgKHRoaXMucGF0aCAmJiBtICYmIG0ud29yZGxpc3QubG9jYWxlID09PSBcImVuXCIgJiYgbS5wYXNzd29yZCA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICBhY2NvdW50Lm1uZW1vbmljID0ge1xyXG4gICAgICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBcImVuXCIsXHJcbiAgICAgICAgICAgICAgICBlbnRyb3B5OiBtLmVudHJvcHlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFjY291bnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXNvbHZlcyB0byBhIFtKU09OIEtleXN0b3JlIFdhbGxldF0oanNvbi13YWxsZXRzKSBlbmNyeXB0ZWQgd2l0aFxyXG4gICAgICogICUlcGFzc3dvcmQlJS5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgJSVwcm9ncmVzc0NhbGxiYWNrJSUgaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlY2VpdmUgcGVyaW9kaWNcclxuICAgICAqICB1cGRhdGVzIGFzIHRoZSBlbmNyeXB0aW9uIHByb2Nlc3MgcHJvZ3Jlc2VzLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBlbmNyeXB0KHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVuY3J5cHRLZXlzdG9yZUpzb24odGhpcy4jYWNjb3VudCgpLCBwYXNzd29yZCwgeyBwcm9ncmVzc0NhbGxiYWNrIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyBhIFtKU09OIEtleXN0b3JlIFdhbGxldF0oanNvbi13YWxsZXRzKSBlbmNyeXBlZCB3aXRoXHJcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxyXG4gICAgICpcclxuICAgICAqICBJdCBpcyBwcmVmZXJyZWQgdG8gdXNlIHRoZSBbYXN5bmMgdmVyc2lvbl0oZW5jcnlwdCkgaW5zdGVhZCxcclxuICAgICAqICB3aGljaCBhbGxvd3MgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byBrZWVwIHRoZSB1c2VyIGluZm9ybWVkLlxyXG4gICAgICpcclxuICAgICAqICBUaGlzIG1ldGhvZCB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIChmcmVlemluZyBhbGwgVUkpIHVudGlsXHJcbiAgICAgKiAgaXQgaXMgY29tcGxldGUsIHdoaWNoIG1heSBiZSBhIG5vbi10cml2aWFsIGR1cmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBlbmNyeXB0U3luYyhwYXNzd29yZCkge1xyXG4gICAgICAgIHJldHVybiBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyh0aGlzLiNhY2NvdW50KCksIHBhc3N3b3JkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBleHRlbmRlZCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMga2V5IHdpbGwgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgeHByaXZgYCBhbmQgY2FuIGJlIHVzZWQgdG9cclxuICAgICAqICByZWNvbnN0cnVjdCB0aGlzIEhEIE5vZGUgdG8gZGVyaXZlIGl0cyBjaGlsZHJlbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IGV4dGVuZGVkS2V5KCkge1xyXG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB0aGUgbWFpbm5ldCB2YWx1ZXMgZm9yIG5vdywgYnV0IGlmIGFueW9uZSBuZWVkc1xyXG4gICAgICAgIC8vIHRlc3RuZXQgdmFsdWVzLCBsZXQgbWUga25vdy4gSSBiZWxpZXZlIGN1cnJlbnQgc2VudGltZW50IGlzIHRoYXRcclxuICAgICAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIHVzZSBtYWlubmV0LCBhbmQgdXNlIEJJUC00NCB0byBkZXJpdmUgdGhlIG5ldHdvcmtcclxuICAgICAgICAvLyAgIC0gTWFpbm5ldDogcHVibGljPTB4MDQ4OEIyMUUsIHByaXZhdGU9MHgwNDg4QURFNFxyXG4gICAgICAgIC8vICAgLSBUZXN0bmV0OiBwdWJsaWM9MHgwNDM1ODdDRiwgcHJpdmF0ZT0weDA0MzU4Mzk0XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuZGVwdGggPCAyNTYsIFwiRGVwdGggdG9vIGRlZXBcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXh0ZW5kZWRLZXlcIiB9KTtcclxuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTU4Q2hlY2soY29uY2F0KFtcclxuICAgICAgICAgICAgXCIweDA0ODhBREU0XCIsIHpwYWQodGhpcy5kZXB0aCwgMSksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsXHJcbiAgICAgICAgICAgIHpwYWQodGhpcy5pbmRleCwgNCksIHRoaXMuY2hhaW5Db2RlLFxyXG4gICAgICAgICAgICBjb25jYXQoW1wiMHgwMFwiLCB0aGlzLnByaXZhdGVLZXldKVxyXG4gICAgICAgIF0pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHdhbGxldCBoYXMgYSBwYXRoLCBwcm92aWRpbmcgYSBUeXBlIEd1YXJkXHJcbiAgICAgKiAgdGhhdCB0aGUgcGF0aCBpcyBub24tbnVsbC5cclxuICAgICAqL1xyXG4gICAgaGFzUGF0aCgpIHsgcmV0dXJuICh0aGlzLnBhdGggIT0gbnVsbCk7IH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYSBuZXV0ZXJlZCBIRCBOb2RlLCB3aGljaCByZW1vdmVzIHRoZSBwcml2YXRlIGRldGFpbHNcclxuICAgICAqICBvZiBhbiBIRCBOb2RlLlxyXG4gICAgICpcclxuICAgICAqICBBIG5ldXRlcmVkIG5vZGUgaGFzIG5vIHByaXZhdGUga2V5LCBidXQgY2FuIGJlIHVzZWQgdG8gZGVyaXZlXHJcbiAgICAgKiAgY2hpbGQgYWRkcmVzc2VzIGFuZCBvdGhlciBwdWJsaWMgZGF0YSBhYm91dCB0aGUgSEQgTm9kZS5cclxuICAgICAqL1xyXG4gICAgbmV1dGVyKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSEROb2RlVm9pZFdhbGxldChfZ3VhcmQsIHRoaXMuYWRkcmVzcywgdGhpcy5wdWJsaWNLZXksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnBhdGgsIHRoaXMuaW5kZXgsIHRoaXMuZGVwdGgsIHRoaXMucHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBjaGlsZCBmb3IgJSVpbmRleCUlLlxyXG4gICAgICovXHJcbiAgICBkZXJpdmVDaGlsZChfaW5kZXgpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihfaW5kZXgsIFwiaW5kZXhcIik7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPD0gMHhmZmZmZmZmZiwgXCJpbnZhbGlkIGluZGV4XCIsIFwiaW5kZXhcIiwgaW5kZXgpO1xyXG4gICAgICAgIC8vIEJhc2UgcGF0aFxyXG4gICAgICAgIGxldCBwYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgIGlmIChwYXRoKSB7XHJcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggJiBIYXJkZW5lZEJpdCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aCArPSBcIidcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IElSLCBJTCB9ID0gc2VyX0koaW5kZXgsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnB1YmxpY0tleSwgdGhpcy5wcml2YXRlS2V5KTtcclxuICAgICAgICBjb25zdCBraSA9IG5ldyBTaWduaW5nS2V5KHRvQmVIZXgoKHRvQmlnSW50KElMKSArIEJpZ0ludCh0aGlzLnByaXZhdGVLZXkpKSAlIE4sIDMyKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBraSwgdGhpcy5maW5nZXJwcmludCwgaGV4bGlmeShJUiksIHBhdGgsIGluZGV4LCB0aGlzLmRlcHRoICsgMSwgdGhpcy5tbmVtb25pYywgdGhpcy5wcm92aWRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm4gdGhlIEhETm9kZSBmb3IgJSVwYXRoJSUgZnJvbSB0aGlzIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGRlcml2ZVBhdGgocGF0aCkge1xyXG4gICAgICAgIHJldHVybiBkZXJpdmVQYXRoKHRoaXMsIHBhdGgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljICNmcm9tU2VlZChfc2VlZCwgbW5lbW9uaWMpIHtcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChpc0J5dGVzTGlrZShfc2VlZCksIFwiaW52YWxpZCBzZWVkXCIsIFwic2VlZFwiLCBcIltSRURBQ1RFRF1cIik7XHJcbiAgICAgICAgY29uc3Qgc2VlZCA9IGdldEJ5dGVzKF9zZWVkLCBcInNlZWRcIik7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2VlZC5sZW5ndGggPj0gMTYgJiYgc2VlZC5sZW5ndGggPD0gNjQsIFwiaW52YWxpZCBzZWVkXCIsIFwic2VlZFwiLCBcIltSRURBQ1RFRF1cIik7XHJcbiAgICAgICAgY29uc3QgSSA9IGdldEJ5dGVzKGNvbXB1dGVIbWFjKFwic2hhNTEyXCIsIE1hc3RlclNlY3JldCwgc2VlZCkpO1xyXG4gICAgICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBuZXcgU2lnbmluZ0tleShoZXhsaWZ5KEkuc2xpY2UoMCwgMzIpKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBzaWduaW5nS2V5LCBcIjB4MDAwMDAwMDBcIiwgaGV4bGlmeShJLnNsaWNlKDMyKSksIFwibVwiLCAwLCAwLCBtbmVtb25pYywgbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IEhEIE5vZGUgZnJvbSAlJWV4dGVuZGVkS2V5JSUuXHJcbiAgICAgKlxyXG4gICAgICogIElmIHRoZSAlJWV4dGVuZGVkS2V5JSUgd2lsbCBlaXRoZXIgaGF2ZSBhIHByZWZpeCBvciBgYHhwdWJgYCBvclxyXG4gICAgICogIGBgeHByaXZgYCwgcmV0dXJuaW5nIGEgbmV1dGVyZWQgSEQgTm9kZSAoW1tIRE5vZGVWb2lkV2FsbGV0XV0pXHJcbiAgICAgKiAgb3IgZnVsbCBIRCBOb2RlIChbW0hETm9kZVdhbGxldCkgcmVzcGVjdGl2ZWx5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkS2V5KGV4dGVuZGVkS2V5KSB7XHJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0b0JlQXJyYXkoZGVjb2RlQmFzZTU4KGV4dGVuZGVkS2V5KSk7IC8vIEBUT0RPOiByZWRhY3RcclxuICAgICAgICBhc3NlcnRBcmd1bWVudChieXRlcy5sZW5ndGggPT09IDgyIHx8IGVuY29kZUJhc2U1OENoZWNrKGJ5dGVzLnNsaWNlKDAsIDc4KSkgPT09IGV4dGVuZGVkS2V5LCBcImludmFsaWQgZXh0ZW5kZWQga2V5XCIsIFwiZXh0ZW5kZWRLZXlcIiwgXCJbIFJFREFDVEVEIF1cIik7XHJcbiAgICAgICAgY29uc3QgZGVwdGggPSBieXRlc1s0XTtcclxuICAgICAgICBjb25zdCBwYXJlbnRGaW5nZXJwcmludCA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoNSwgOSkpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoaGV4bGlmeShieXRlcy5zbGljZSg5LCAxMykpLnN1YnN0cmluZygyKSwgMTYpO1xyXG4gICAgICAgIGNvbnN0IGNoYWluQ29kZSA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMTMsIDQ1KSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYnl0ZXMuc2xpY2UoNDUsIDc4KTtcclxuICAgICAgICBzd2l0Y2ggKGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpKSB7XHJcbiAgICAgICAgICAgIC8vIFB1YmxpYyBLZXlcclxuICAgICAgICAgICAgY2FzZSBcIjB4MDQ4OGIyMWVcIjpcclxuICAgICAgICAgICAgY2FzZSBcIjB4MDQzNTg3Y2ZcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gaGV4bGlmeShrZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgY29tcHV0ZUFkZHJlc3MocHVibGljS2V5KSwgcHVibGljS2V5LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBudWxsLCBpbmRleCwgZGVwdGgsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFByaXZhdGUgS2V5XHJcbiAgICAgICAgICAgIGNhc2UgXCIweDA0ODhhZGU0XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCIweDA0MzU4Mzk0IFwiOlxyXG4gICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBuZXcgU2lnbmluZ0tleShrZXkuc2xpY2UoMSkpLCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBudWxsLCBpbmRleCwgZGVwdGgsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGV4dGVuZGVkIGtleSBwcmVmaXhcIiwgXCJleHRlbmRlZEtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSBuZXcgcmFuZG9tIEhETm9kZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVJhbmRvbShwYXNzd29yZCwgcGF0aCwgd29yZGxpc3QpIHtcclxuICAgICAgICBpZiAocGFzc3dvcmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRoID09IG51bGwpIHtcclxuICAgICAgICAgICAgcGF0aCA9IGRlZmF1bHRQYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB3b3JkbGlzdCA9IExhbmdFbi53b3JkbGlzdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtbmVtb25pYyA9IE1uZW1vbmljLmZyb21FbnRyb3B5KHJhbmRvbUJ5dGVzKDE2KSwgcGFzc3dvcmQsIHdvcmRsaXN0KTtcclxuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhbiBIRCBOb2RlIGZyb20gJSVtbmVtb25pYyUlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbU1uZW1vbmljKG1uZW1vbmljLCBwYXRoKSB7XHJcbiAgICAgICAgaWYgKCFwYXRoKSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBkZWZhdWx0UGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQobW5lbW9uaWMuY29tcHV0ZVNlZWQoKSwgbW5lbW9uaWMpLmRlcml2ZVBhdGgocGF0aCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGFuIEhEIE5vZGUgZnJvbSBhIG1uZW1vbmljICUlcGhyYXNlJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tUGhyYXNlKHBocmFzZSwgcGFzc3dvcmQsIHBhdGgsIHdvcmRsaXN0KSB7XHJcbiAgICAgICAgaWYgKHBhc3N3b3JkID09IG51bGwpIHtcclxuICAgICAgICAgICAgcGFzc3dvcmQgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBkZWZhdWx0UGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgd29yZGxpc3QgPSBMYW5nRW4ud29yZGxpc3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW5lbW9uaWMgPSBNbmVtb25pYy5mcm9tUGhyYXNlKHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KTtcclxuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYW4gSEQgTm9kZSBmcm9tIGEgJSVzZWVkJSUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tU2VlZChzZWVkKSB7XHJcbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQoc2VlZCwgbnVsbCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICBBICoqSEROb2RlVm9pZFdhbGxldCoqIGNhbm5vdCBzaWduLCBidXQgcHJvdmlkZXMgYWNjZXNzIHRvXHJcbiAqICB0aGUgY2hpbGRyZW4gbm9kZXMgb2YgYSBbW2xpbmstYmlwLTMyXV0gSEQgd2FsbGV0IGFkZHJlc3Nlcy5cclxuICpcclxuICogIFRoZSBjYW4gYmUgY3JlYXRlZCBieSB1c2luZyBhbiBleHRlbmRlZCBgYHhwdWJgYCBrZXkgdG9cclxuICogIFtbSEROb2RlV2FsbGV0X2Zyb21FeHRlbmRlZEtleV1dIG9yIGJ5XHJcbiAqICBbbnVldGVyaW5nXShIRE5vZGVXYWxsZXQtbmV1dGVyKSBhIFtbSEROb2RlV2FsbGV0XV0uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSEROb2RlVm9pZFdhbGxldCBleHRlbmRzIFZvaWRTaWduZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cclxuICAgICAqL1xyXG4gICAgcHVibGljS2V5O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGZpbmdlcnByaW50LlxyXG4gICAgICpcclxuICAgICAqICBBIGZpbmdlcnByaW50IGFsbG93cyBxdWljayBxYXkgdG8gZGV0ZWN0IHBhcmVudCBhbmQgY2hpbGQgbm9kZXMsXHJcbiAgICAgKiAgYnV0IGRldmVsb3BlcnMgc2hvdWxkIGJlIHByZXBhcmVkIHRvIGRlYWwgd2l0aCBjb2xsaXNpb25zIGFzIGl0XHJcbiAgICAgKiAgaXMgb25seSA0IGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBmaW5nZXJwcmludDtcclxuICAgIC8qKlxyXG4gICAgICogIFRoZSBwYXJlbnQgbm9kZSBmaW5nZXJwcmludC5cclxuICAgICAqL1xyXG4gICAgcGFyZW50RmluZ2VycHJpbnQ7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY2hhaW5jb2RlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhIHB1YmxpYyBrZXkgdXNlZFxyXG4gICAgICogIHRvIGRlcml2ZSBjaGlsZHJlbi5cclxuICAgICAqL1xyXG4gICAgY2hhaW5Db2RlO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGRlcml2YXRpb24gcGF0aCBvZiB0aGlzIHdhbGxldC5cclxuICAgICAqXHJcbiAgICAgKiAgU2luY2UgZXh0ZW5kZWQga2V5cyBkbyBub3QgcHJvdmlkZXIgZnVsbCBwYXRoIGRldGFpbHMsIHRoaXNcclxuICAgICAqICBtYXkgYmUgYGBudWxsYGAsIGlmIGluc3RhbnRpYXRlZCBmcm9tIGEgc291cmNlIHRoYXQgZG9lcyBub3RcclxuICAgICAqICBlbm9jZGUgaXQuXHJcbiAgICAgKi9cclxuICAgIHBhdGg7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgY2hpbGQgaW5kZXggb2YgdGhpcyB3YWxsZXQuIFZhbHVlcyBvdmVyIGBgMiAqXFwqIDMxYGAgaW5kaWNhdGVcclxuICAgICAqICB0aGUgbm9kZSBpcyBoYXJkZW5lZC5cclxuICAgICAqL1xyXG4gICAgaW5kZXg7XHJcbiAgICAvKipcclxuICAgICAqICBUaGUgZGVwdGggb2YgdGhpcyB3YWxsZXQsIHdoaWNoIGlzIHRoZSBudW1iZXIgb2YgY29tcG9uZW50c1xyXG4gICAgICogIGluIGl0cyBwYXRoLlxyXG4gICAgICovXHJcbiAgICBkZXB0aDtcclxuICAgIC8qKlxyXG4gICAgICogIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBhZGRyZXNzLCBwdWJsaWNLZXksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aCwgcHJvdmlkZXIpIHtcclxuICAgICAgICBzdXBlcihhZGRyZXNzLCBwcm92aWRlcik7XHJcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIkhETm9kZVZvaWRXYWxsZXRcIik7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHB1YmxpY0tleSB9KTtcclxuICAgICAgICBjb25zdCBmaW5nZXJwcmludCA9IGRhdGFTbGljZShyaXBlbWQxNjAoc2hhMjU2KHB1YmxpY0tleSkpLCAwLCA0KTtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgICAgICAgICAgcHVibGljS2V5LCBmaW5nZXJwcmludCwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgcGF0aCwgaW5kZXgsIGRlcHRoXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgdGhpcy5hZGRyZXNzLCB0aGlzLnB1YmxpY0tleSwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucGF0aCwgdGhpcy5pbmRleCwgdGhpcy5kZXB0aCwgcHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGV4dGVuZGVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiAgVGhpcyBrZXkgd2lsbCBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGB4cHViYGAgYW5kIGNhbiBiZSB1c2VkIHRvXHJcbiAgICAgKiAgcmVjb25zdHJ1Y3QgdGhpcyBuZXV0ZXJlZCBrZXkgdG8gZGVyaXZlIGl0cyBjaGlsZHJlbiBhZGRyZXNzZXMuXHJcbiAgICAgKi9cclxuICAgIGdldCBleHRlbmRlZEtleSgpIHtcclxuICAgICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgdGhlIG1haW5uZXQgdmFsdWVzIGZvciBub3csIGJ1dCBpZiBhbnlvbmUgbmVlZHNcclxuICAgICAgICAvLyB0ZXN0bmV0IHZhbHVlcywgbGV0IG1lIGtub3cuIEkgYmVsaWV2ZSBjdXJyZW50IHNlbnRpbWVudCBpcyB0aGF0XHJcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGFsd2F5cyB1c2UgbWFpbm5ldCwgYW5kIHVzZSBCSVAtNDQgdG8gZGVyaXZlIHRoZSBuZXR3b3JrXHJcbiAgICAgICAgLy8gICAtIE1haW5uZXQ6IHB1YmxpYz0weDA0ODhCMjFFLCBwcml2YXRlPTB4MDQ4OEFERTRcclxuICAgICAgICAvLyAgIC0gVGVzdG5ldDogcHVibGljPTB4MDQzNTg3Q0YsIHByaXZhdGU9MHgwNDM1ODM5NFxyXG4gICAgICAgIGFzc2VydCh0aGlzLmRlcHRoIDwgMjU2LCBcIkRlcHRoIHRvbyBkZWVwXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImV4dGVuZGVkS2V5XCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIGVuY29kZUJhc2U1OENoZWNrKGNvbmNhdChbXHJcbiAgICAgICAgICAgIFwiMHgwNDg4QjIxRVwiLFxyXG4gICAgICAgICAgICB6cGFkKHRoaXMuZGVwdGgsIDEpLFxyXG4gICAgICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50LFxyXG4gICAgICAgICAgICB6cGFkKHRoaXMuaW5kZXgsIDQpLFxyXG4gICAgICAgICAgICB0aGlzLmNoYWluQ29kZSxcclxuICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXksXHJcbiAgICAgICAgXSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgd2FsbGV0IGhhcyBhIHBhdGgsIHByb3ZpZGluZyBhIFR5cGUgR3VhcmRcclxuICAgICAqICB0aGF0IHRoZSBwYXRoIGlzIG5vbi1udWxsLlxyXG4gICAgICovXHJcbiAgICBoYXNQYXRoKCkgeyByZXR1cm4gKHRoaXMucGF0aCAhPSBudWxsKTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBjaGlsZCBmb3IgJSVpbmRleCUlLlxyXG4gICAgICovXHJcbiAgICBkZXJpdmVDaGlsZChfaW5kZXgpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihfaW5kZXgsIFwiaW5kZXhcIik7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPD0gMHhmZmZmZmZmZiwgXCJpbnZhbGlkIGluZGV4XCIsIFwiaW5kZXhcIiwgaW5kZXgpO1xyXG4gICAgICAgIC8vIEJhc2UgcGF0aFxyXG4gICAgICAgIGxldCBwYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgIGlmIChwYXRoKSB7XHJcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggJiBIYXJkZW5lZEJpdCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aCArPSBcIidcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IElSLCBJTCB9ID0gc2VyX0koaW5kZXgsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnB1YmxpY0tleSwgbnVsbCk7XHJcbiAgICAgICAgY29uc3QgS2kgPSBTaWduaW5nS2V5LmFkZFBvaW50cyhJTCwgdGhpcy5wdWJsaWNLZXksIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcyhLaSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgYWRkcmVzcywgS2ksIHRoaXMuZmluZ2VycHJpbnQsIGhleGxpZnkoSVIpLCBwYXRoLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIHRoaXMucHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJuIHRoZSBzaWduZXIgZm9yICUlcGF0aCUlIGZyb20gdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBkZXJpdmVQYXRoKHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gZGVyaXZlUGF0aCh0aGlzLCBwYXRoKTtcclxuICAgIH1cclxufVxyXG4vKlxyXG5leHBvcnQgY2xhc3MgSEROb2RlV2FsbGV0TWFuYWdlciB7XHJcbiAgICAjcm9vdDogSEROb2RlV2FsbGV0O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBocmFzZTogc3RyaW5nLCBwYXNzd29yZD86IG51bGwgfCBzdHJpbmcsIHBhdGg/OiBudWxsIHwgc3RyaW5nLCBsb2NhbGU/OiBudWxsIHwgV29yZGxpc3QpIHtcclxuICAgICAgICBpZiAocGFzc3dvcmQgPT0gbnVsbCkgeyBwYXNzd29yZCA9IFwiXCI7IH1cclxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7IHBhdGggPSBcIm0vNDQnLzYwJy8wJy8wXCI7IH1cclxuICAgICAgICBpZiAobG9jYWxlID09IG51bGwpIHsgbG9jYWxlID0gTGFuZ0VuLndvcmRsaXN0KCk7IH1cclxuICAgICAgICB0aGlzLiNyb290ID0gSEROb2RlV2FsbGV0LmZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgcGF0aCwgbG9jYWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTaWduZXIoaW5kZXg/OiBudW1iZXIpOiBIRE5vZGVXYWxsZXQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiNyb290LmRlcml2ZUNoaWxkKChpbmRleCA9PSBudWxsKSA/IDA6IGluZGV4KTtcclxuICAgIH1cclxufVxyXG4qL1xyXG4vKipcclxuICogIFJldHVybnMgdGhlIFtbbGluay1iaXAtMzJdXSBwYXRoIGZvciB0aGUgYWNjb3VudCBhdCAlJWluZGV4JSUuXHJcbiAqXHJcbiAqICBUaGlzIGlzIHRoZSBwYXR0ZXJuIHVzZWQgYnkgd2FsbGV0cyBsaWtlIExlZGdlci5cclxuICpcclxuICogIFRoZXJlIGlzIGFsc28gYW4gW2FsdGVybmF0ZSBwYXR0ZXJuXShnZXRJbmRleGVkQWNjb3VudFBhdGgpIHVzZWQgYnlcclxuICogIHNvbWUgc29mdHdhcmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjb3VudFBhdGgoX2luZGV4KSB7XHJcbiAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihfaW5kZXgsIFwiaW5kZXhcIik7XHJcbiAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwICYmIGluZGV4IDwgSGFyZGVuZWRCaXQsIFwiaW52YWxpZCBhY2NvdW50IGluZGV4XCIsIFwiaW5kZXhcIiwgaW5kZXgpO1xyXG4gICAgcmV0dXJuIGBtLzQ0Jy82MCcvJHtpbmRleH0nLzAvMGA7XHJcbn1cclxuLyoqXHJcbiAqICBSZXR1cm5zIHRoZSBwYXRoIHVzaW5nIGFuIGFsdGVybmF0aXZlIHBhdHRlcm4gZm9yIGRlcml2aW5nIGFjY291bnRzLFxyXG4gKiAgYXQgJSVpbmRleCUlLlxyXG4gKlxyXG4gKiAgVGhpcyBkZXJpdmF0aW9uIHBhdGggdXNlcyB0aGUgLy9pbmRleC8vIGNvbXBvbmVudCByYXRoZXIgdGhhbiB0aGVcclxuICogIC8vYWNjb3VudC8vIGNvbXBvbmVudCB0byBkZXJpdmUgc2VxdWVudGlhbCBhY2NvdW50cy5cclxuICpcclxuICogIFRoaXMgaXMgdGhlIHBhdHRlcm4gdXNlZCBieSB3YWxsZXRzIGxpa2UgTWV0YU1hc2suXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5kZXhlZEFjY291bnRQYXRoKF9pbmRleCkge1xyXG4gICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIoX2luZGV4LCBcImluZGV4XCIpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCAmJiBpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgYWNjb3VudCBpbmRleFwiLCBcImluZGV4XCIsIGluZGV4KTtcclxuICAgIHJldHVybiBgbS80NCcvNjAnLzAnLzAvJHtpbmRleH1gO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhkd2FsbGV0LmpzLm1hcCIsIi8qKlxyXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvd2FsbGV0OkpTT04gV2FsbGV0cyAgW2pzb24td2FsbGV0c11cclxuICovXHJcbmltcG9ydCB7IENCQywgcGtjczdTdHJpcCB9IGZyb20gXCJhZXMtanNcIjtcclxuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRCeXRlcywgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgZ2V0UGFzc3dvcmQsIGxvb3NlQXJyYXlpZnksIHNwZWx1bmsgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xyXG4vKipcclxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWpzb24lJSBpcyBhIHZhbGlkIEpTT04gQ3Jvd2RzYWxlIHdhbGxldC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Nyb3dkc2FsZUpzb24oanNvbikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcclxuICAgICAgICBpZiAoZGF0YS5lbmNzZWVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vcHlldGhzYWxldG9vbFxyXG4vKipcclxuICogIEJlZm9yZSBFdGhlcmV1bSBsYXVuY2hlZCwgaXQgd2FzIG5lY2Vzc2FyeSB0byBjcmVhdGUgYSB3YWxsZXRcclxuICogIGZvcm1hdCBmb3IgYmFja2VycyB0byB1c2UsIHdoaWNoIHdvdWxkIGJlIHVzZWQgdG8gcmVjZWl2ZSBldGhlclxyXG4gKiAgYXMgYSByZXdhcmQgZm9yIGNvbnRyaWJ1dGluZyB0byB0aGUgcHJvamVjdC5cclxuICpcclxuICogIFRoZSBbW2xpbmstY3Jvd2RzYWxlXV0gZm9ybWF0IGlzIG5vdyBvYnNvbGV0ZSwgYnV0IGl0IGlzIHN0aWxsXHJcbiAqICB1c2VmdWwgdG8gc3VwcG9ydCBhbmQgdGhlIGFkZGl0aW9uYWwgY29kZSBpcyBmYWlybHkgdHJpdmlhbCBhc1xyXG4gKiAgYWxsIHRoZSBwcmltaXRpdmVzIHJlcXVpcmVkIGFyZSB1c2VkIHRocm91Z2ggY29yZSBwb3J0aW9ucyBvZlxyXG4gKiAgdGhlIGxpYnJhcnkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdENyb3dkc2FsZUpzb24oanNvbiwgX3Bhc3N3b3JkKSB7XHJcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcclxuICAgIGNvbnN0IHBhc3N3b3JkID0gZ2V0UGFzc3dvcmQoX3Bhc3N3b3JkKTtcclxuICAgIC8vIEV0aGVyZXVtIEFkZHJlc3NcclxuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKHNwZWx1bmsoZGF0YSwgXCJldGhhZGRyOnN0cmluZyFcIikpO1xyXG4gICAgLy8gRW5jcnlwdGVkIFNlZWRcclxuICAgIGNvbnN0IGVuY3NlZWQgPSBsb29zZUFycmF5aWZ5KHNwZWx1bmsoZGF0YSwgXCJlbmNzZWVkOnN0cmluZyFcIikpO1xyXG4gICAgYXNzZXJ0QXJndW1lbnQoZW5jc2VlZCAmJiAoZW5jc2VlZC5sZW5ndGggJSAxNikgPT09IDAsIFwiaW52YWxpZCBlbmNzZWVkXCIsIFwianNvblwiLCBqc29uKTtcclxuICAgIGNvbnN0IGtleSA9IGdldEJ5dGVzKHBia2RmMihwYXNzd29yZCwgcGFzc3dvcmQsIDIwMDAsIDMyLCBcInNoYTI1NlwiKSkuc2xpY2UoMCwgMTYpO1xyXG4gICAgY29uc3QgaXYgPSBlbmNzZWVkLnNsaWNlKDAsIDE2KTtcclxuICAgIGNvbnN0IGVuY3J5cHRlZFNlZWQgPSBlbmNzZWVkLnNsaWNlKDE2KTtcclxuICAgIC8vIERlY3J5cHQgdGhlIHNlZWRcclxuICAgIGNvbnN0IGFlc0NiYyA9IG5ldyBDQkMoa2V5LCBpdik7XHJcbiAgICBjb25zdCBzZWVkID0gcGtjczdTdHJpcChnZXRCeXRlcyhhZXNDYmMuZGVjcnlwdChlbmNyeXB0ZWRTZWVkKSkpO1xyXG4gICAgLy8gVGhpcyB3YWxsZXQgZm9ybWF0IGlzIHdlaXJkLi4uIENvbnZlcnQgdGhlIGJpbmFyeSBlbmNvZGVkIGhleCB0byBhIHN0cmluZy5cclxuICAgIGxldCBzZWVkSGV4ID0gXCJcIjtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHNlZWRIZXggKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzZWVkW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGFkZHJlc3MsIHByaXZhdGVLZXk6IGlkKHNlZWRIZXgpIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1jcm93ZHNhbGUuanMubWFwIiwiaW1wb3J0IHsgU2lnbmluZ0tleSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcclxuaW1wb3J0IHsgQmFzZVdhbGxldCB9IGZyb20gXCIuL2Jhc2Utd2FsbGV0LmpzXCI7XHJcbmltcG9ydCB7IEhETm9kZVdhbGxldCB9IGZyb20gXCIuL2hkd2FsbGV0LmpzXCI7XHJcbmltcG9ydCB7IGRlY3J5cHRDcm93ZHNhbGVKc29uLCBpc0Nyb3dkc2FsZUpzb24gfSBmcm9tIFwiLi9qc29uLWNyb3dkc2FsZS5qc1wiO1xyXG5pbXBvcnQgeyBkZWNyeXB0S2V5c3RvcmVKc29uLCBkZWNyeXB0S2V5c3RvcmVKc29uU3luYywgZW5jcnlwdEtleXN0b3JlSnNvbiwgZW5jcnlwdEtleXN0b3JlSnNvblN5bmMsIGlzS2V5c3RvcmVKc29uIH0gZnJvbSBcIi4vanNvbi1rZXlzdG9yZS5qc1wiO1xyXG5pbXBvcnQgeyBNbmVtb25pYyB9IGZyb20gXCIuL21uZW1vbmljLmpzXCI7XHJcbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dCgoKSA9PiB7IHJlc29sdmUoKTsgfSwgZHVyYXRpb24pOyB9KTtcclxufVxyXG4vKipcclxuICogIEEgKipXYWxsZXQqKiBtYW5hZ2VzIGEgc2luZ2xlIHByaXZhdGUga2V5IHdoaWNoIGlzIHVzZWQgdG8gc2lnblxyXG4gKiAgdHJhbnNhY3Rpb25zLCBtZXNzYWdlcyBhbmQgb3RoZXIgY29tbW9uIHBheWxvYWRzLlxyXG4gKlxyXG4gKiAgVGhpcyBjbGFzcyBpcyBnZW5lcmFsbHkgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIGRldmVsb3BlcnNcclxuICogIHRoYXQgd2lzaCB0byB1c2UgYSBwcml2YXRlIGtleSBkaXJlY3RseSwgYXMgaXQgY2FuIGNyZWF0ZVxyXG4gKiAgaW5zdGFuY2VzIGZyb20gYSBsYXJnZSB2YXJpZXR5IG9mIGNvbW1vbiBzb3VyY2VzLCBpbmNsdWRpbmdcclxuICogIHJhdyBwcml2YXRlIGtleSwgW1tsaW5rLWJpcC0zOV1dIG1uZW1vbmljcyBhbmQgZW5jcnlwdGUgSlNPTlxyXG4gKiAgd2FsbGV0cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXYWxsZXQgZXh0ZW5kcyBCYXNlV2FsbGV0IHtcclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZSBhIG5ldyB3YWxsZXQgZm9yIHRoZSBwcml2YXRlICUla2V5JSUsIG9wdGlvbmFsbHkgY29ubmVjdGVkXHJcbiAgICAgKiAgdG8gJSVwcm92aWRlciUlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIiAmJiAha2V5LnN0YXJ0c1dpdGgoXCIweFwiKSkge1xyXG4gICAgICAgICAgICBrZXkgPSBcIjB4XCIgKyBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzaWduaW5nS2V5ID0gKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIikgPyBuZXcgU2lnbmluZ0tleShrZXkpIDoga2V5O1xyXG4gICAgICAgIHN1cGVyKHNpZ25pbmdLZXksIHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLnNpZ25pbmdLZXksIHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJlc29sdmVzIHRvIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cHRlZCB3aXRoXHJcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxyXG4gICAgICpcclxuICAgICAqICBJZiAlJXByb2dyZXNzQ2FsbGJhY2slJSBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVjZWl2ZSBwZXJpb2RpY1xyXG4gICAgICogIHVwZGF0ZXMgYXMgdGhlIGVuY3J5cHRpb24gcHJvY2VzcyBwcm9ncmVzZXMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGVuY3J5cHQocGFzc3dvcmQsIHByb2dyZXNzQ2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsIHByaXZhdGVLZXk6IHRoaXMucHJpdmF0ZUtleSB9O1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBlbmNyeXB0S2V5c3RvcmVKc29uKGFjY291bnQsIHBhc3N3b3JkLCB7IHByb2dyZXNzQ2FsbGJhY2sgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cGVkIHdpdGhcclxuICAgICAqICAlJXBhc3N3b3JkJSUuXHJcbiAgICAgKlxyXG4gICAgICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2ZXJzaW9uXShlbmNyeXB0KSBpbnN0ZWFkLFxyXG4gICAgICogIHdoaWNoIGFsbG93cyBhIFtbUHJvZ3Jlc3NDYWxsYmFja11dIHRvIGtlZXAgdGhlIHVzZXIgaW5mb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogIFRoaXMgbWV0aG9kIHdpbGwgYmxvY2sgdGhlIGV2ZW50IGxvb3AgKGZyZWV6aW5nIGFsbCBVSSkgdW50aWxcclxuICAgICAqICBpdCBpcyBjb21wbGV0ZSwgd2hpY2ggbWF5IGJlIGEgbm9uLXRyaXZpYWwgZHVyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGVuY3J5cHRTeW5jKHBhc3N3b3JkKSB7XHJcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHsgYWRkcmVzczogdGhpcy5hZGRyZXNzLCBwcml2YXRlS2V5OiB0aGlzLnByaXZhdGVLZXkgfTtcclxuICAgICAgICByZXR1cm4gZW5jcnlwdEtleXN0b3JlSnNvblN5bmMoYWNjb3VudCwgcGFzc3dvcmQpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljICNmcm9tQWNjb3VudChhY2NvdW50KSB7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWNjb3VudCwgXCJpbnZhbGlkIEpTT04gd2FsbGV0XCIsIFwianNvblwiLCBcIlsgUkVEQUNURUQgXVwiKTtcclxuICAgICAgICBpZiAoXCJtbmVtb25pY1wiIGluIGFjY291bnQgJiYgYWNjb3VudC5tbmVtb25pYyAmJiBhY2NvdW50Lm1uZW1vbmljLmxvY2FsZSA9PT0gXCJlblwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1uZW1vbmljID0gTW5lbW9uaWMuZnJvbUVudHJvcHkoYWNjb3VudC5tbmVtb25pYy5lbnRyb3B5KTtcclxuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gSEROb2RlV2FsbGV0LmZyb21NbmVtb25pYyhtbmVtb25pYywgYWNjb3VudC5tbmVtb25pYy5wYXRoKTtcclxuICAgICAgICAgICAgaWYgKHdhbGxldC5hZGRyZXNzID09PSBhY2NvdW50LmFkZHJlc3MgJiYgd2FsbGV0LnByaXZhdGVLZXkgPT09IGFjY291bnQucHJpdmF0ZUtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk5JTkc6IEpTT04gbWlzbWF0Y2ggYWRkcmVzcy9wcml2YXRlS2V5ICE9IG1uZW1vbmljOyBmYWxsYmFjayBvbnRvIHByaXZhdGUga2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0KGFjY291bnQucHJpdmF0ZUtleSk7XHJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQod2FsbGV0LmFkZHJlc3MgPT09IGFjY291bnQuYWRkcmVzcywgXCJhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xyXG4gICAgICAgIHJldHVybiB3YWxsZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIChhc3luY2hyb25vdXNseSkgYSAqKldhbGxldCoqIGJ5IGRlY3J5cHRpbmcgdGhlICUlanNvbiUlXHJcbiAgICAgKiAgd2l0aCAlJXBhc3N3b3JkJSUuXHJcbiAgICAgKlxyXG4gICAgICogIElmICUlcHJvZ3Jlc3MlJSBpcyBwcm92aWRlZCwgaXQgaXMgY2FsbGVkIHBlcmlvZGljYWxseSBkdXJpbmdcclxuICAgICAqICBkZWNyeXB0aW9uIHNvIHRoYXQgYW55IFVJIGNhbiBiZSB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXN5bmMgZnJvbUVuY3J5cHRlZEpzb24oanNvbiwgcGFzc3dvcmQsIHByb2dyZXNzKSB7XHJcbiAgICAgICAgbGV0IGFjY291bnQgPSBudWxsO1xyXG4gICAgICAgIGlmIChpc0tleXN0b3JlSnNvbihqc29uKSkge1xyXG4gICAgICAgICAgICBhY2NvdW50ID0gYXdhaXQgZGVjcnlwdEtleXN0b3JlSnNvbihqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0Nyb3dkc2FsZUpzb24oanNvbikpIHtcclxuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzcygwKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjY291bnQgPSBkZWNyeXB0Q3Jvd2RzYWxlSnNvbihqc29uLCBwYXNzd29yZCk7XHJcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcykge1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MoMSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBzdGFsbCgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gV2FsbGV0LiNmcm9tQWNjb3VudChhY2NvdW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENyZWF0ZXMgYSAqKldhbGxldCoqIGJ5IGRlY3J5cHRpbmcgdGhlICUlanNvbiUlIHdpdGggJSVwYXNzd29yZCUlLlxyXG4gICAgICpcclxuICAgICAqICBUaGUgW1tmcm9tRW5jcnlwdGVkSnNvbl1dIG1ldGhvZCBpcyBwcmVmZXJyZWQsIGFzIHRoaXMgbWV0aG9kXHJcbiAgICAgKiAgd2lsbCBsb2NrIHVwIGFuZCBmcmVlemUgdGhlIFVJIGR1cmluZyBkZWNyeXB0aW9uLCB3aGljaCBtYXkgdGFrZVxyXG4gICAgICogIHNvbWUgdGltZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21FbmNyeXB0ZWRKc29uU3luYyhqc29uLCBwYXNzd29yZCkge1xyXG4gICAgICAgIGxldCBhY2NvdW50ID0gbnVsbDtcclxuICAgICAgICBpZiAoaXNLZXlzdG9yZUpzb24oanNvbikpIHtcclxuICAgICAgICAgICAgYWNjb3VudCA9IGRlY3J5cHRLZXlzdG9yZUpzb25TeW5jKGpzb24sIHBhc3N3b3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNDcm93ZHNhbGVKc29uKGpzb24pKSB7XHJcbiAgICAgICAgICAgIGFjY291bnQgPSBkZWNyeXB0Q3Jvd2RzYWxlSnNvbihqc29uLCBwYXNzd29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIEpTT04gd2FsbGV0XCIsIFwianNvblwiLCBcIlsgUkVEQUNURUQgXVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFdhbGxldC4jZnJvbUFjY291bnQoYWNjb3VudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgbmV3IHJhbmRvbSBbW0hETm9kZVdhbGxldF1dIHVzaW5nIHRoZSBhdmFpbGFibGVcclxuICAgICAqICBbY3J5cHRvZ3JhcGhpYyByYW5kb20gc291cmNlXShyYW5kb21CeXRlcykuXHJcbiAgICAgKlxyXG4gICAgICogIElmIHRoZXJlIGlzIG5vIGNyeXRvZ3JhcGhpYyByYW5kb20gc291cmNlLCB0aGlzIHdpbGwgdGhyb3cuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVSYW5kb20ocHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCB3YWxsZXQgPSBIRE5vZGVXYWxsZXQuY3JlYXRlUmFuZG9tKCk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQuY29ubmVjdChwcm92aWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3YWxsZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBDcmVhdGVzIGEgW1tIRE5vZGVXYWxsZXRdXSBmb3IgJSVwaHJhc2UlJS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHdhbGxldCA9IEhETm9kZVdhbGxldC5mcm9tUGhyYXNlKHBocmFzZSk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQuY29ubmVjdChwcm92aWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3YWxsZXQ7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0LmpzLm1hcCIsIi8qKlxyXG4gKiBjb3JlL3N0b3JhZ2UuanNcclxuICpcclxuICogRW5jcnlwdGVkIHN0b3JhZ2Ugd3JhcHBlciBmb3IgQ2hyb21lIHN0b3JhZ2UgQVBJXHJcbiAqIEhhbmRsZXMgYm90aCBlbmNyeXB0ZWQgKGZvciBzZW5zaXRpdmUgZGF0YSkgYW5kIHVuZW5jcnlwdGVkIHN0b3JhZ2VcclxuICovXHJcblxyXG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xyXG5cclxuLyoqXHJcbiAqIFNhdmVzIHVuZW5jcnlwdGVkIGRhdGEgKGZvciBub24tc2Vuc2l0aXZlIGRhdGEpXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBTdG9yYWdlIGtleVxyXG4gKiBAcGFyYW0ge2FueX0gZGF0YSAtIERhdGEgdG8gc3RvcmVcclxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZShrZXksIGRhdGEpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHsgW2tleV06IGRhdGEgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBkYXRhOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgZGF0YScpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRzIHVuZW5jcnlwdGVkIGRhdGFcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFN0b3JhZ2Uga2V5XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFN0b3JlZCBkYXRhIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZChrZXkpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KGtleSk7XHJcbiAgICByZXR1cm4gcmVzdWx0W2tleV0gfHwgbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBkYXRhOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgZGF0YScpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgaXRlbSBmcm9tIHN0b3JhZ2VcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFN0b3JhZ2Uga2V5XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwucmVtb3ZlKGtleSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVtb3ZlIGRhdGEnKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhcnMgYWxsIHN0b3JhZ2UgKHVzZSB3aXRoIGNhdXRpb24hKVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhcigpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuY2xlYXIoKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgc3RvcmFnZTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjbGVhciBzdG9yYWdlJyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBhbGwga2V5cyBpbiBzdG9yYWdlXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxLZXlzKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBhbGwgPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQobnVsbCk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxsKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBrZXlzOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBzdG9yYWdlIGtleXMnKTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIGNvcmUvdmFsaWRhdGlvbi5qc1xyXG4gKlxyXG4gKiBJbnB1dCB2YWxpZGF0aW9uIGFuZCBzYW5pdGl6YXRpb24gZnVuY3Rpb25zXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgRXRoZXJldW0gYWRkcmVzc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBldGhlcnMuaXNBZGRyZXNzKGFkZHJlc3MpO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhbW91bnQgKG11c3QgYmUgcG9zaXRpdmUgbnVtYmVyKVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBbW91bnQoYW1vdW50KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IG51bSA9IHBhcnNlRmxvYXQoYW1vdW50KTtcclxuICAgIHJldHVybiAhaXNOYU4obnVtKSAmJiBudW0gPiAwICYmIGlzRmluaXRlKG51bSk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIG1uZW1vbmljIHBocmFzZSAoQklQMzkpXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtbmVtb25pY1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTW5lbW9uaWMobW5lbW9uaWMpIHtcclxuICB0cnkge1xyXG4gICAgLy8gVHJpbSBhbmQgbm9ybWFsaXplIHdoaXRlc3BhY2VcclxuICAgIGNvbnN0IGNsZWFuZWQgPSBtbmVtb25pYy50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xyXG5cclxuICAgIC8vIENoZWNrIGlmIGl0J3MgYSB2YWxpZCBtbmVtb25pYyB1c2luZyBldGhlcnNcclxuICAgIHJldHVybiBldGhlcnMuTW5lbW9uaWMuaXNWYWxpZE1uZW1vbmljKGNsZWFuZWQpO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBwcml2YXRlIGtleSAoaGV4IGZvcm1hdClcclxuICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXlcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBSZW1vdmUgMHggcHJlZml4IGlmIHByZXNlbnRcclxuICAgIGNvbnN0IGtleSA9IHByaXZhdGVLZXkuc3RhcnRzV2l0aCgnMHgnKSA/IHByaXZhdGVLZXkgOiAnMHgnICsgcHJpdmF0ZUtleTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBpdCdzIHZhbGlkIGhleCBhbmQgY29ycmVjdCBsZW5ndGggKDY2IGNoYXJzIHdpdGggMHgsIG9yIDY0IHdpdGhvdXQpXHJcbiAgICBpZiAoIS9eMHhbMC05YS1mQS1GXXs2NH0kLy50ZXN0KGtleSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSB0byBjcmVhdGUgYSB3YWxsZXQgd2l0aCBpdFxyXG4gICAgbmV3IGV0aGVycy5XYWxsZXQoa2V5KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBwYXNzd29yZCBzdHJlbmd0aFxyXG4gKiBSZXF1aXJlbWVudHM6XHJcbiAqIC0gTWluaW11bSAxMiBjaGFyYWN0ZXJzXHJcbiAqIC0gQXQgbGVhc3QgMSB1cHBlcmNhc2UgbGV0dGVyXHJcbiAqIC0gQXQgbGVhc3QgMSBsb3dlcmNhc2UgbGV0dGVyXHJcbiAqIC0gQXQgbGVhc3QgMSBudW1iZXJcclxuICogLSBBdCBsZWFzdCAxIHNwZWNpYWwgY2hhcmFjdGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB7IHZhbGlkOiBib29sZWFuLCBlcnJvcnM6IHN0cmluZ1tdIH1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBhc3N3b3JkU3RyZW5ndGgocGFzc3dvcmQpIHtcclxuICBjb25zdCBlcnJvcnMgPSBbXTtcclxuXHJcbiAgaWYgKCFwYXNzd29yZCB8fCBwYXNzd29yZC5sZW5ndGggPCAxMikge1xyXG4gICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgYmUgYXQgbGVhc3QgMTIgY2hhcmFjdGVycycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCEvW0EtWl0vLnRlc3QocGFzc3dvcmQpKSB7XHJcbiAgICBlcnJvcnMucHVzaCgnUGFzc3dvcmQgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSB1cHBlcmNhc2UgbGV0dGVyJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoIS9bYS16XS8udGVzdChwYXNzd29yZCkpIHtcclxuICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGxvd2VyY2FzZSBsZXR0ZXInKTtcclxuICB9XHJcblxyXG4gIGlmICghL1swLTldLy50ZXN0KHBhc3N3b3JkKSkge1xyXG4gICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgbnVtYmVyJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoIS9bIUAjJCVeJiooKV8rXFwtPVxcW1xcXXt9Oyc6XCJcXFxcfCwuPD5cXC8/XS8udGVzdChwYXNzd29yZCkpIHtcclxuICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHNwZWNpYWwgY2hhcmFjdGVyICghQCMkJV4mKiwgZXRjLiknKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB2YWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcclxuICAgIGVycm9yc1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTYW5pdGl6ZXMgdXNlciBpbnB1dCAocmVtb3ZlcyBwb3RlbnRpYWxseSBkYW5nZXJvdXMgY2hhcmFjdGVycylcclxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVJbnB1dChpbnB1dCkge1xyXG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSByZXR1cm4gJyc7XHJcblxyXG4gIC8vIFJlbW92ZSBudWxsIGJ5dGVzIGFuZCBjb250cm9sIGNoYXJhY3RlcnNcclxuICByZXR1cm4gaW5wdXRcclxuICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MUZcXHg3Rl0vZywgJycpXHJcbiAgICAudHJpbSgpO1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIGNoYWluIElEXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFpbklkXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRDaGFpbklkKGNoYWluSWQpIHtcclxuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjaGFpbklkKSAmJiBjaGFpbklkID4gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBkZWNpbWFsIHBsYWNlcyBzZXR0aW5nXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsc1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRGVjaW1hbFBsYWNlcyhkZWNpbWFscykge1xyXG4gIGNvbnN0IHZhbGlkID0gWzIsIDQsIDYsIDgsIDE4XTtcclxuICByZXR1cm4gdmFsaWQuaW5jbHVkZXMoZGVjaW1hbHMpO1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoZW1lIG5hbWVcclxuICogQHBhcmFtIHtzdHJpbmd9IHRoZW1lXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRUaGVtZSh0aGVtZSkge1xyXG4gIGNvbnN0IHZhbGlkID0gWydoaWdoLWNvbnRyYXN0JywgJ3Byb2Zlc3Npb25hbCcsICdhbWJlcicsICdjZ2EnLCAnY2xhc3NpYyddO1xyXG4gIHJldHVybiB2YWxpZC5pbmNsdWRlcyh0aGVtZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXRzIGFtb3VudCB0byBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXNcclxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBhbW91bnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QW1vdW50KGFtb3VudCwgZGVjaW1hbHMgPSA4KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IG51bSA9IHBhcnNlRmxvYXQoYW1vdW50KTtcclxuICAgIGlmIChpc05hTihudW0pKSByZXR1cm4gJzAnO1xyXG4gICAgcmV0dXJuIG51bS50b0ZpeGVkKGRlY2ltYWxzKTtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiAnMCc7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2hvcnRlbnMgYWRkcmVzcyBmb3IgZGlzcGxheSAoMHgxMjM0Li4uNTY3OClcclxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcclxuICogQHBhcmFtIHtudW1iZXJ9IGNoYXJzIC0gQ2hhcmFjdGVycyB0byBzaG93IG9uIGVhY2ggc2lkZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNob3J0ZW5BZGRyZXNzKGFkZHJlc3MsIGNoYXJzID0gNCkge1xyXG4gIGlmICghaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHJldHVybiBhZGRyZXNzO1xyXG4gIHJldHVybiBgJHthZGRyZXNzLnNsaWNlKDAsIGNoYXJzICsgMil9Li4uJHthZGRyZXNzLnNsaWNlKC1jaGFycyl9YDtcclxufVxyXG4iLCIvKipcclxuICogY29yZS93YWxsZXQuanNcclxuICpcclxuICogTXVsdGktd2FsbGV0IGNyZWF0aW9uLCBpbXBvcnQsIGFuZCBrZXkgbWFuYWdlbWVudFxyXG4gKlxyXG4gKiBTRUNVUklUWTogVXNlcyBzZWxmLWRlc2NyaWJpbmcgZW5jcnlwdGlvbiBmb3JtYXQgd2l0aCBpdGVyYXRpb24gbWV0YWRhdGFcclxuICogZm9yIGZ1dHVyZS1wcm9vZiBjcnlwdG9ncmFwaGljIGFnaWxpdHkuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcclxuaW1wb3J0IHsgc2F2ZSwgbG9hZCB9IGZyb20gJy4vc3RvcmFnZS5qcyc7XHJcbmltcG9ydCB7IGlzVmFsaWRNbmVtb25pYywgaXNWYWxpZFByaXZhdGVLZXksIHZhbGlkYXRlUGFzc3dvcmRTdHJlbmd0aCB9IGZyb20gJy4vdmFsaWRhdGlvbi5qcyc7XHJcblxyXG4vLyA9PT09PSBQQktERjIgSVRFUkFUSU9OIFJFQ09NTUVOREFUSU9OUyA9PT09PVxyXG4vLyBCYXNlZCBvbiBoaXN0b3JpY2FsIE9XQVNQIGRhdGEgYW5kIEdQVSBjcmFja2luZyBzcGVlZCB0cmVuZHNcclxuLy9cclxuLy8gSGlzdG9yaWNhbCBPV0FTUCBSZWNvbW1lbmRhdGlvbnM6XHJcbi8vIC0gMjAxNjogMTAsMDAwIGl0ZXJhdGlvbnNcclxuLy8gLSAyMDIxOiAzMTAsMDAwIGl0ZXJhdGlvbnMgKDMxeCBpbiA1IHllYXJzID0gOTclIENBR1IpXHJcbi8vIC0gMjAyMzogNjAwLDAwMCBpdGVyYXRpb25zICgxLjk0eCBpbiAyIHllYXJzID0gMzklIENBR1IpXHJcbi8vXHJcbi8vIEdQVSBDcmFja2luZyBTcGVlZCBHcm93dGggKDIwMTYtMjAyMik6XHJcbi8vIC0gR1RYIDEwODAg4oaSIFJUWCA0MDkwOiA4eCBpbXByb3ZlbWVudCA9IDM5JSBDQUdSXHJcbi8vXHJcbi8vIE1vZGVsOiAzNSUgQ0FHUiAoZG91YmxpbmcgZXZlcnkgfjIuMyB5ZWFycylcclxuLy8gUmF0aW9uYWxlOiBDb25zZXJ2YXRpdmUgZXN0aW1hdGUgbWF0Y2hpbmcgR1BVIGltcHJvdmVtZW50c1xyXG5jb25zdCBJVEVSQVRJT05fTUlMRVNUT05FUyA9IFtcclxuICAvLyBIaXN0b3JpY2FsIE9XQVNQIHJlY29tbWVuZGF0aW9ucyAoYWN0dWFsIGRhdGEpXHJcbiAgeyB5ZWFyOiAyMDE2LCBpdGVyYXRpb25zOiAxMDAwMCwgICBzb3VyY2U6ICdPV0FTUCAyMDE2JyB9LFxyXG4gIHsgeWVhcjogMjAyMSwgaXRlcmF0aW9uczogMzEwMDAwLCAgc291cmNlOiAnT1dBU1AgMjAyMScgfSxcclxuICB7IHllYXI6IDIwMjMsIGl0ZXJhdGlvbnM6IDYwMDAwMCwgIHNvdXJjZTogJ09XQVNQIDIwMjMnIH0sXHJcblxyXG4gIC8vIFByb2plY3RlZCB1c2luZyAzNSUgQ0FHUiBmcm9tIDIwMjMgYmFzZWxpbmVcclxuICB7IHllYXI6IDIwMjQsIGl0ZXJhdGlvbnM6IDgxMDAwMCwgIHNvdXJjZTogJ1Byb2plY3RlZCAoMzUlIENBR1IpJyB9LFxyXG4gIHsgeWVhcjogMjAyNSwgaXRlcmF0aW9uczogMTA5NDAwMCwgc291cmNlOiAnUHJvamVjdGVkICgzNSUgQ0FHUiknIH0sXHJcbiAgeyB5ZWFyOiAyMDI2LCBpdGVyYXRpb25zOiAxNDc3MDAwLCBzb3VyY2U6ICdQcm9qZWN0ZWQgKDM1JSBDQUdSKScgfSxcclxuICB7IHllYXI6IDIwMjcsIGl0ZXJhdGlvbnM6IDE5OTQwMDAsIHNvdXJjZTogJ1Byb2plY3RlZCAoMzUlIENBR1IpJyB9LFxyXG4gIHsgeWVhcjogMjAyOCwgaXRlcmF0aW9uczogMjY5MjAwMCwgc291cmNlOiAnUHJvamVjdGVkICgzNSUgQ0FHUiknIH0sXHJcbiAgeyB5ZWFyOiAyMDI5LCBpdGVyYXRpb25zOiAzNjM1MDAwLCBzb3VyY2U6ICdQcm9qZWN0ZWQgKDM1JSBDQUdSKScgfSxcclxuICB7IHllYXI6IDIwMzAsIGl0ZXJhdGlvbnM6IDQ5MDcwMDAsIHNvdXJjZTogJ1Byb2plY3RlZCAoMzUlIENBR1IpJyB9LFxyXG4gIHsgeWVhcjogMjAzMSwgaXRlcmF0aW9uczogNTAwMDAwMCwgc291cmNlOiAnQ2FwcGVkIGZvciBVWCAofjJzZWMgb24gc2xvdyBkZXZpY2VzKScgfSxcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHJlY29tbWVuZGVkIFBCS0RGMiBpdGVyYXRpb24gY291bnQgZm9yIGN1cnJlbnQgeWVhclxyXG4gKiBVc2VzIGhpc3RvcmljYWwgT1dBU1AgZGF0YSBhbmQgZXhwb25lbnRpYWwgZ3Jvd3RoIG1vZGVsXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5ZWFyIC0gWWVhciB0byBnZXQgcmVjb21tZW5kYXRpb24gZm9yIChkZWZhdWx0cyB0byBjdXJyZW50IHllYXIpXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlY29tbWVuZGVkIGl0ZXJhdGlvbiBjb3VudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRSZWNvbW1lbmRlZEl0ZXJhdGlvbnMoeWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSkge1xyXG4gIC8vIEZpbmQgZXhhY3QgbWF0Y2ggZmlyc3RcclxuICBjb25zdCBleGFjdE1hdGNoID0gSVRFUkFUSU9OX01JTEVTVE9ORVMuZmluZChtID0+IG0ueWVhciA9PT0geWVhcik7XHJcbiAgaWYgKGV4YWN0TWF0Y2gpIHJldHVybiBleGFjdE1hdGNoLml0ZXJhdGlvbnM7XHJcblxyXG4gIC8vIEZpbmQgc3Vycm91bmRpbmcgbWlsZXN0b25lcyBmb3IgaW50ZXJwb2xhdGlvblxyXG4gIGNvbnN0IGJlZm9yZSA9IElURVJBVElPTl9NSUxFU1RPTkVTXHJcbiAgICAuZmlsdGVyKG0gPT4gbS55ZWFyIDwgeWVhcilcclxuICAgIC5zb3J0KChhLCBiKSA9PiBiLnllYXIgLSBhLnllYXIpWzBdO1xyXG5cclxuICBjb25zdCBhZnRlciA9IElURVJBVElPTl9NSUxFU1RPTkVTXHJcbiAgICAuZmlsdGVyKG0gPT4gbS55ZWFyID4geWVhcilcclxuICAgIC5zb3J0KChhLCBiKSA9PiBhLnllYXIgLSBiLnllYXIpWzBdO1xyXG5cclxuICAvLyBCZWZvcmUgYWxsIG1pbGVzdG9uZXM6IHVzZSBlYXJsaWVzdFxyXG4gIGlmICghYmVmb3JlKSByZXR1cm4gSVRFUkFUSU9OX01JTEVTVE9ORVNbMF0uaXRlcmF0aW9ucztcclxuXHJcbiAgLy8gQWZ0ZXIgYWxsIG1pbGVzdG9uZXM6IHVzZSBsYXRlc3QgKGNhcHBlZClcclxuICBpZiAoIWFmdGVyKSByZXR1cm4gSVRFUkFUSU9OX01JTEVTVE9ORVNbSVRFUkFUSU9OX01JTEVTVE9ORVMubGVuZ3RoIC0gMV0uaXRlcmF0aW9ucztcclxuXHJcbiAgLy8gRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvbiAoYWNjdXJhdGUgZm9yIENBR1ItYmFzZWQgZ3Jvd3RoKVxyXG4gIGNvbnN0IHllYXJSYW5nZSA9IGFmdGVyLnllYXIgLSBiZWZvcmUueWVhcjtcclxuICBjb25zdCBpdGVyYXRpb25SYXRpbyA9IGFmdGVyLml0ZXJhdGlvbnMgLyBiZWZvcmUuaXRlcmF0aW9ucztcclxuICBjb25zdCB5ZWFyUHJvZ3Jlc3MgPSAoeWVhciAtIGJlZm9yZS55ZWFyKSAvIHllYXJSYW5nZTtcclxuXHJcbiAgcmV0dXJuIE1hdGguZmxvb3IoYmVmb3JlLml0ZXJhdGlvbnMgKiBNYXRoLnBvdyhpdGVyYXRpb25SYXRpbywgeWVhclByb2dyZXNzKSk7XHJcbn1cclxuXHJcbi8vIExlZ2FjeSBpdGVyYXRpb24gY291bnQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuY29uc3QgTEVHQUNZX0lURVJBVElPTlMgPSAxMDAwMDA7XHJcblxyXG4vLyA9PT09PSBTRUxGLURFU0NSSUJJTkcgRU5DUllQVElPTiBGT1JNQVQgPT09PT1cclxuLy8gRm9ybWF0OiBbNCBieXRlczogaXRlcmF0aW9uIGNvdW50XVsxNiBieXRlczogc2FsdF1bMTIgYnl0ZXM6IElWXVt2YXJpYWJsZTogY2lwaGVydGV4dF1cclxuLy8gVGhpcyBhbGxvd3MgaXRlcmF0aW9uIGNvdW50IHRvIGV2b2x2ZSBvdmVyIHRpbWUgd2l0aG91dCBicmVha2luZyBleGlzdGluZyB3YWxsZXRzXHJcblxyXG4vKipcclxuICogRGVyaXZlcyBhbiBlbmNyeXB0aW9uIGtleSBmcm9tIHBhc3N3b3JkIHVzaW5nIFBCS0RGMlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gc2FsdCAtIFNhbHQgZm9yIGtleSBkZXJpdmF0aW9uICgxNiBieXRlcylcclxuICogQHBhcmFtIHtudW1iZXJ9IGl0ZXJhdGlvbnMgLSBQQktERjIgaXRlcmF0aW9uIGNvdW50XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPENyeXB0b0tleT59XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZXJpdmVFbmNyeXB0aW9uS2V5KHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zKSB7XHJcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gIGNvbnN0IHBhc3N3b3JkQnVmZmVyID0gZW5jb2Rlci5lbmNvZGUocGFzc3dvcmQpO1xyXG5cclxuICAvLyBJbXBvcnQgcGFzc3dvcmQgYXMga2V5IG1hdGVyaWFsXHJcbiAgY29uc3Qga2V5TWF0ZXJpYWwgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcclxuICAgICdyYXcnLFxyXG4gICAgcGFzc3dvcmRCdWZmZXIsXHJcbiAgICB7IG5hbWU6ICdQQktERjInIH0sXHJcbiAgICBmYWxzZSxcclxuICAgIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXVxyXG4gICk7XHJcblxyXG4gIC8vIERlcml2ZSBBRVMtR0NNIGtleVxyXG4gIHJldHVybiBhd2FpdCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ1BCS0RGMicsXHJcbiAgICAgIHNhbHQ6IHNhbHQsXHJcbiAgICAgIGl0ZXJhdGlvbnM6IGl0ZXJhdGlvbnMsXHJcbiAgICAgIGhhc2g6ICdTSEEtMjU2J1xyXG4gICAgfSxcclxuICAgIGtleU1hdGVyaWFsLFxyXG4gICAgeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMjU2IH0sXHJcbiAgICBmYWxzZSxcclxuICAgIFsnZW5jcnlwdCcsICdkZWNyeXB0J11cclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogRW5jcnlwdHMgZGF0YSB3aXRoIEFFUy1HQ00gYW5kIHN0b3JlcyBpdGVyYXRpb24gY291bnQgaW4gbWV0YWRhdGFcclxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBEYXRhIHRvIGVuY3J5cHRcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVXNlciBwYXNzd29yZFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaXRlcmF0aW9ucyAtIFBCS0RGMiBpdGVyYXRpb25zIChkZWZhdWx0cyB0byBjdXJyZW50IHJlY29tbWVuZGF0aW9uKVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBCYXNlNjQgZW5jb2RlZCBlbmNyeXB0ZWQgZGF0YSB3aXRoIG1ldGFkYXRhXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0V2l0aEFFUyhkYXRhLCBwYXNzd29yZCwgaXRlcmF0aW9ucyA9IGdldEN1cnJlbnRSZWNvbW1lbmRlZEl0ZXJhdGlvbnMoKSkge1xyXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcclxuICBjb25zdCBkYXRhQnVmZmVyID0gZW5jb2Rlci5lbmNvZGUoZGF0YSk7XHJcblxyXG4gIC8vIFNFQ1VSSVRZOiBHZW5lcmF0ZSBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gc2FsdCBhbmQgSVZcclxuICAvLyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgdXNlcyB0aGUgYnJvd3NlcidzIENTUFJORyAoQ3J5cHRvZ3JhcGhpY2FsbHkgU2VjdXJlXHJcbiAgLy8gUHNldWRvLVJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yKSwgd2hpY2ggZW5zdXJlczpcclxuICAvLyAxLiBUcnVlIHJhbmRvbW5lc3MgZnJvbSBoYXJkd2FyZSBlbnRyb3B5IHNvdXJjZXNcclxuICAvLyAyLiBJViB1bmlxdWVuZXNzIGlzIGNyeXB0b2dyYXBoaWNhbGx5IGd1YXJhbnRlZWQgKGNvbGxpc2lvbiBwcm9iYWJpbGl0eSA8IDJeLTY0KVxyXG4gIC8vIDMuIFVucHJlZGljdGFiaWxpdHkgLSBjYW5ub3QgYmUgZ3Vlc3NlZCBieSBhdHRhY2tlcnNcclxuICAvLyBFYWNoIGVuY3J5cHRpb24gb3BlcmF0aW9uIGdldHMgYSB1bmlxdWUgSVYsIHdoaWNoIGlzIGNyaXRpY2FsIGZvciBBRVMtR0NNIHNlY3VyaXR5XHJcbiAgY29uc3Qgc2FsdCA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKTtcclxuICBjb25zdCBpdiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTIpKTtcclxuXHJcbiAgLy8gRGVyaXZlIGtleSB3aXRoIHNwZWNpZmllZCBpdGVyYXRpb25zXHJcbiAgY29uc3Qga2V5ID0gYXdhaXQgZGVyaXZlRW5jcnlwdGlvbktleShwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucyk7XHJcblxyXG4gIC8vIEVuY3J5cHRcclxuICBjb25zdCBlbmNyeXB0ZWRCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoXHJcbiAgICB7IG5hbWU6ICdBRVMtR0NNJywgaXY6IGl2IH0sXHJcbiAgICBrZXksXHJcbiAgICBkYXRhQnVmZmVyXHJcbiAgKTtcclxuXHJcbiAgLy8gUHJlcGVuZCBpdGVyYXRpb24gY291bnQgYXMgNC1ieXRlIGJpZy1lbmRpYW4gaW50ZWdlclxyXG4gIGNvbnN0IGl0ZXJhdGlvbkJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XHJcbiAgbmV3IERhdGFWaWV3KGl0ZXJhdGlvbkJ5dGVzLmJ1ZmZlcikuc2V0VWludDMyKDAsIGl0ZXJhdGlvbnMsIGZhbHNlKTsgLy8gQmlnLWVuZGlhblxyXG5cclxuICAvLyBDb21iaW5lOiBbaXRlcmF0aW9uc11bc2FsdF1bSVZdW2NpcGhlcnRleHRdXHJcbiAgY29uc3QgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShcclxuICAgIDQgKyBzYWx0Lmxlbmd0aCArIGl2Lmxlbmd0aCArIGVuY3J5cHRlZEJ1ZmZlci5ieXRlTGVuZ3RoXHJcbiAgKTtcclxuICBjb21iaW5lZC5zZXQoaXRlcmF0aW9uQnl0ZXMsIDApO1xyXG4gIGNvbWJpbmVkLnNldChzYWx0LCA0KTtcclxuICBjb21iaW5lZC5zZXQoaXYsIDQgKyBzYWx0Lmxlbmd0aCk7XHJcbiAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZEJ1ZmZlciksIDQgKyBzYWx0Lmxlbmd0aCArIGl2Lmxlbmd0aCk7XHJcblxyXG4gIC8vIFJldHVybiBhcyBiYXNlNjRcclxuICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNvbWJpbmVkKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNyeXB0cyBBRVMtR0NNIGVuY3J5cHRlZCBkYXRhLCByZWFkaW5nIGl0ZXJhdGlvbiBjb3VudCBmcm9tIG1ldGFkYXRhXHJcbiAqIEhhbmRsZXMgYm90aCBuZXcgZm9ybWF0ICh3aXRoIGl0ZXJhdGlvbiBtZXRhZGF0YSkgYW5kIGxlZ2FjeSBmb3JtYXRcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGVuY3J5cHRlZERhdGEgLSBCYXNlNjQgZW5jb2RlZCBlbmNyeXB0ZWQgZGF0YVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IERlY3J5cHRlZCBkYXRhXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0V2l0aEFFUyhlbmNyeXB0ZWREYXRhLCBwYXNzd29yZCkge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBEZWNvZGUgZnJvbSBiYXNlNjRcclxuICAgIGNvbnN0IGNvbWJpbmVkID0gVWludDhBcnJheS5mcm9tKGF0b2IoZW5jcnlwdGVkRGF0YSksIGMgPT4gYy5jaGFyQ29kZUF0KDApKTtcclxuXHJcbiAgICBsZXQgaXRlcmF0aW9uQ291bnQ7XHJcbiAgICBsZXQgc2FsdCwgaXYsIGVuY3J5cHRlZDtcclxuXHJcbiAgICAvLyBBdXRvLWRldGVjdCBmb3JtYXQ6IG5ldyAod2l0aCBtZXRhZGF0YSkgdnMgbGVnYWN5XHJcbiAgICBpZiAoY29tYmluZWQubGVuZ3RoID49IDQpIHtcclxuICAgICAgY29uc3QgcG9zc2libGVJdGVyYXRpb25zID0gbmV3IERhdGFWaWV3KGNvbWJpbmVkLmJ1ZmZlciwgMCwgNCkuZ2V0VWludDMyKDAsIGZhbHNlKTtcclxuXHJcbiAgICAgIC8vIEhldXJpc3RpYzogdmFsaWQgaXRlcmF0aW9uIGNvdW50cyBhcmUgMTAway01TVxyXG4gICAgICAvLyBJZiBmaXJzdCA0IGJ5dGVzIGFyZSBpbiB0aGlzIHJhbmdlLCBpdCdzIHRoZSBuZXcgc2VsZi1kZXNjcmliaW5nIGZvcm1hdFxyXG4gICAgICBpZiAocG9zc2libGVJdGVyYXRpb25zID49IDEwMDAwMCAmJiBwb3NzaWJsZUl0ZXJhdGlvbnMgPD0gNTAwMDAwMCkge1xyXG4gICAgICAgIC8vIOKchSBORVcgRk9STUFUIC0gcmVhZCBpdGVyYXRpb24gY291bnQgZnJvbSBtZXRhZGF0YVxyXG4gICAgICAgIGl0ZXJhdGlvbkNvdW50ID0gcG9zc2libGVJdGVyYXRpb25zO1xyXG4gICAgICAgIHNhbHQgPSBjb21iaW5lZC5zbGljZSg0LCAyMCk7XHJcbiAgICAgICAgaXYgPSBjb21iaW5lZC5zbGljZSgyMCwgMzIpO1xyXG4gICAgICAgIGVuY3J5cHRlZCA9IGNvbWJpbmVkLnNsaWNlKDMyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyDinIUgTEVHQUNZIEZPUk1BVCAtIHVzZSBoYXJkY29kZWQgbGVnYWN5IGl0ZXJhdGlvbiBjb3VudFxyXG4gICAgICAgIGl0ZXJhdGlvbkNvdW50ID0gTEVHQUNZX0lURVJBVElPTlM7XHJcbiAgICAgICAgc2FsdCA9IGNvbWJpbmVkLnNsaWNlKDAsIDE2KTtcclxuICAgICAgICBpdiA9IGNvbWJpbmVkLnNsaWNlKDE2LCAyOCk7XHJcbiAgICAgICAgZW5jcnlwdGVkID0gY29tYmluZWQuc2xpY2UoMjgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jcnlwdGVkIGRhdGEgZm9ybWF0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVyaXZlIGtleSB1c2luZyB0aGUgc3RvcmVkIGl0ZXJhdGlvbiBjb3VudFxyXG4gICAgY29uc3Qga2V5ID0gYXdhaXQgZGVyaXZlRW5jcnlwdGlvbktleShwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9uQ291bnQpO1xyXG5cclxuICAgIC8vIERlY3J5cHRcclxuICAgIGNvbnN0IGRlY3J5cHRlZEJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGVjcnlwdChcclxuICAgICAgeyBuYW1lOiAnQUVTLUdDTScsIGl2OiBpdiB9LFxyXG4gICAgICBrZXksXHJcbiAgICAgIGVuY3J5cHRlZFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xyXG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xyXG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGRlY3J5cHRlZEJ1ZmZlcik7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnSW52YWxpZCBlbmNyeXB0ZWQgZGF0YSBmb3JtYXQnKSB7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZCAtIGluY29ycmVjdCBwYXNzd29yZCBvciBjb3JydXB0ZWQgZGF0YScpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3RzIGl0ZXJhdGlvbiBjb3VudCBmcm9tIGVuY3J5cHRlZCBkYXRhIHdpdGhvdXQgZGVjcnlwdGluZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jcnlwdGVkRGF0YSAtIEJhc2U2NCBlbmNvZGVkIGVuY3J5cHRlZCBkYXRhXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEl0ZXJhdGlvbiBjb3VudCwgb3IgTEVHQUNZX0lURVJBVElPTlMgaWYgbGVnYWN5IGZvcm1hdFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SXRlcmF0aW9uc0Zyb21FbmNyeXB0ZWQoZW5jcnlwdGVkRGF0YSkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjb21iaW5lZCA9IFVpbnQ4QXJyYXkuZnJvbShhdG9iKGVuY3J5cHRlZERhdGEpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XHJcblxyXG4gICAgaWYgKGNvbWJpbmVkLmxlbmd0aCA+PSA0KSB7XHJcbiAgICAgIGNvbnN0IHBvc3NpYmxlSXRlcmF0aW9ucyA9IG5ldyBEYXRhVmlldyhjb21iaW5lZC5idWZmZXIsIDAsIDQpLmdldFVpbnQzMigwLCBmYWxzZSk7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBpdCBsb29rcyBsaWtlIGEgdmFsaWQgaXRlcmF0aW9uIGNvdW50XHJcbiAgICAgIGlmIChwb3NzaWJsZUl0ZXJhdGlvbnMgPj0gMTAwMDAwICYmIHBvc3NpYmxlSXRlcmF0aW9ucyA8PSA1MDAwMDAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHBvc3NpYmxlSXRlcmF0aW9ucztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIExlZ2FjeSBmb3JtYXRcclxuICAgIHJldHVybiBMRUdBQ1lfSVRFUkFUSU9OUztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIExFR0FDWV9JVEVSQVRJT05TO1xyXG4gIH1cclxufVxyXG5cclxuLy8gU3RvcmFnZSBrZXlzXHJcbmNvbnN0IE9MRF9XQUxMRVRfS0VZID0gJ3dhbGxldF9lbmNyeXB0ZWQnOyAvLyBMZWdhY3kgc2luZ2xlIHdhbGxldFxyXG5jb25zdCBXQUxMRVRTX0tFWSA9ICd3YWxsZXRzX211bHRpJzsgLy8gTmV3IG11bHRpLXdhbGxldCBzdHJ1Y3R1cmVcclxuXHJcbi8vID09PT09IENPTkNVUlJFTkNZIENPTlRST0wgPT09PT1cclxuLy8gUHJldmVudHMgcmFjZSBjb25kaXRpb25zIHdoZW4gbXVsdGlwbGUgdGFicyB1cGdyYWRlIHRoZSBzYW1lIHdhbGxldCBzaW11bHRhbmVvdXNseVxyXG4vLyBNYXBzIHdhbGxldCBJRCB0byB1cGdyYWRlIFByb21pc2VcclxuY29uc3Qgb25nb2luZ1VwZ3JhZGVzID0gbmV3IE1hcCgpO1xyXG5cclxuLyoqXHJcbiAqIE1pZ3JhdGlvbjogQ29udmVydHMgb2xkIHNpbmdsZS13YWxsZXQgZm9ybWF0IHRvIG5ldyBtdWx0aS13YWxsZXQgZm9ybWF0XHJcbiAqIFJ1bnMgYXV0b21hdGljYWxseSBvbiBmaXJzdCBsb2FkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBUcnVlIGlmIG1pZ3JhdGlvbiBvY2N1cnJlZCwgZmFsc2UgaWYgYWxyZWFkeSBtaWdyYXRlZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGVUb011bHRpV2FsbGV0KCkge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHVzaW5nIG5ldyBmb3JtYXRcclxuICAgIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgbG9hZChXQUxMRVRTX0tFWSk7XHJcbiAgICBpZiAod2FsbGV0c0RhdGEpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBBbHJlYWR5IG1pZ3JhdGVkXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIG9sZCBmb3JtYXQgd2FsbGV0XHJcbiAgICBjb25zdCBvbGRXYWxsZXQgPSBhd2FpdCBsb2FkKE9MRF9XQUxMRVRfS0VZKTtcclxuICAgIGlmICghb2xkV2FsbGV0KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gd2FsbGV0IHRvIG1pZ3JhdGVcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgYWRkcmVzcyBmcm9tIG9sZCB3YWxsZXQgKHdlJ2xsIG5lZWQgdG8gdGVtcG9yYXJpbHkgZGVjcnlwdCBpdClcclxuICAgIC8vIEZvciBub3csIHdlJ2xsIGNyZWF0ZSBhIHBsYWNlaG9sZGVyIC0gdGhlIGFkZHJlc3Mgd2lsbCBiZSBwb3B1bGF0ZWQgb24gZmlyc3QgdW5sb2NrXHJcbiAgICBjb25zdCBuZXdGb3JtYXQgPSB7XHJcbiAgICAgIGFjdGl2ZVdhbGxldElkOiAnd2FsbGV0X21pZ3JhdGVkXycgKyBEYXRlLm5vdygpLFxyXG4gICAgICB3YWxsZXRMaXN0OiBbe1xyXG4gICAgICAgIGlkOiAnd2FsbGV0X21pZ3JhdGVkXycgKyBEYXRlLm5vdygpLFxyXG4gICAgICAgIG5pY2tuYW1lOiAnTWFpbiBXYWxsZXQnLFxyXG4gICAgICAgIGFkZHJlc3M6IG51bGwsIC8vIFdpbGwgYmUgcG9wdWxhdGVkIG9uIHVubG9ja1xyXG4gICAgICAgIGVuY3J5cHRlZEtleXN0b3JlOiBvbGRXYWxsZXQsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxyXG4gICAgICAgIGltcG9ydE1ldGhvZDogJ21pZ3JhdGVkJ1xyXG4gICAgICB9XVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTYXZlIG5ldyBmb3JtYXRcclxuICAgIGF3YWl0IHNhdmUoV0FMTEVUU19LRVksIG5ld0Zvcm1hdCk7XHJcblxyXG4gICAgLy8gS2VlcCBvbGQgd2FsbGV0IGZvciBzYWZldHkgZHVyaW5nIHRyYW5zaXRpb25cclxuICAgIC8vIENhbiBiZSBjbGVhbmVkIHVwIGxhdGVyXHJcblxyXG4gICAgLy8gTWlncmF0ZWQgdG8gbXVsdGktd2FsbGV0IGZvcm1hdFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBtaWdyYXRpb246JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgYWxsIHdhbGxldHMgZGF0YVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7YWN0aXZlV2FsbGV0SWQ6IHN0cmluZywgd2FsbGV0TGlzdDogQXJyYXl9Pn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxXYWxsZXRzKCkge1xyXG4gIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgbG9hZChXQUxMRVRTX0tFWSk7XHJcbiAgaWYgKCF3YWxsZXRzRGF0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYWN0aXZlV2FsbGV0SWQ6IG51bGwsXHJcbiAgICAgIHdhbGxldExpc3Q6IFtdXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gd2FsbGV0c0RhdGE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIGFjdGl2ZSB3YWxsZXQgaW5mbyAod2l0aG91dCBkZWNyeXB0aW5nKVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8bnVsbD59IEFjdGl2ZSB3YWxsZXQgbWV0YWRhdGEgb3IgbnVsbFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjdGl2ZVdhbGxldCgpIHtcclxuICBjb25zdCB3YWxsZXRzRGF0YSA9IGF3YWl0IGdldEFsbFdhbGxldHMoKTtcclxuICBpZiAoIXdhbGxldHNEYXRhLmFjdGl2ZVdhbGxldElkIHx8IHdhbGxldHNEYXRhLndhbGxldExpc3QubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGFjdGl2ZVdhbGxldCA9IHdhbGxldHNEYXRhLndhbGxldExpc3QuZmluZChcclxuICAgIHcgPT4gdy5pZCA9PT0gd2FsbGV0c0RhdGEuYWN0aXZlV2FsbGV0SWRcclxuICApO1xyXG5cclxuICByZXR1cm4gYWN0aXZlV2FsbGV0IHx8IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYW55IHdhbGxldCBleGlzdHNcclxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FsbGV0RXhpc3RzKCkge1xyXG4gIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgZ2V0QWxsV2FsbGV0cygpO1xyXG4gIHJldHVybiB3YWxsZXRzRGF0YS53YWxsZXRMaXN0Lmxlbmd0aCA+IDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgd2FsbGV0IElEIHVzaW5nIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb21cclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlV2FsbGV0SWQoKSB7XHJcbiAgLy8gR2VuZXJhdGUgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbSBieXRlc1xyXG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XHJcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XHJcbiAgY29uc3QgcmFuZG9tU3RyID0gQXJyYXkuZnJvbShhcnJheSwgYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDM2KSkuam9pbignJyk7XHJcbiAgcmV0dXJuICd3YWxsZXRfJyArIERhdGUubm93KCkgKyAnXycgKyByYW5kb21TdHI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB3YWxsZXQgd2l0aCB0aGUgZ2l2ZW4gYWRkcmVzcyBhbHJlYWR5IGV4aXN0c1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEV0aGVyZXVtIGFkZHJlc3NcclxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBpc0R1cGxpY2F0ZUFkZHJlc3MoYWRkcmVzcykge1xyXG4gIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgZ2V0QWxsV2FsbGV0cygpO1xyXG4gIHJldHVybiB3YWxsZXRzRGF0YS53YWxsZXRMaXN0LnNvbWUoXHJcbiAgICB3ID0+IHcuYWRkcmVzcyAmJiB3LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIGRlZmF1bHQgbmlja25hbWUgZm9yIGEgbmV3IHdhbGxldFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVEZWZhdWx0Tmlja25hbWUoKSB7XHJcbiAgY29uc3Qgd2FsbGV0c0RhdGEgPSBhd2FpdCBnZXRBbGxXYWxsZXRzKCk7XHJcbiAgY29uc3QgY291bnQgPSB3YWxsZXRzRGF0YS53YWxsZXRMaXN0Lmxlbmd0aDtcclxuICByZXR1cm4gJ1dhbGxldCAnICsgKGNvdW50ICsgMSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgbmV3IHdhbGxldCB0byB0aGUgd2FsbGV0IGxpc3RcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSAnY3JlYXRlJywgJ21uZW1vbmljJywgb3IgJ3ByaXZhdGVrZXknXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0ge21uZW1vbmljPywgcHJpdmF0ZUtleT99XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFVzZXIgcGFzc3dvcmQgZm9yIGVuY3J5cHRpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IG5pY2tuYW1lIC0gT3B0aW9uYWwgY3VzdG9tIG5pY2tuYW1lXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHtpZDogc3RyaW5nLCBhZGRyZXNzOiBzdHJpbmcsIG1uZW1vbmljPzogc3RyaW5nfT59XHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB2YWxpZGF0aW9uIGZhaWxzIG9yIHdhbGxldCBjcmVhdGlvbiBmYWlsc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZFdhbGxldCh0eXBlLCBkYXRhLCBwYXNzd29yZCwgbmlja25hbWUgPSBudWxsKSB7XHJcbiAgLy8gVmFsaWRhdGUgcGFzc3dvcmQgc3RyZW5ndGhcclxuICBjb25zdCBwYXNzd29yZENoZWNrID0gdmFsaWRhdGVQYXNzd29yZFN0cmVuZ3RoKHBhc3N3b3JkKTtcclxuICBpZiAoIXBhc3N3b3JkQ2hlY2sudmFsaWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihwYXNzd29yZENoZWNrLmVycm9ycy5qb2luKCcsICcpKTtcclxuICB9XHJcblxyXG4gIGxldCB3YWxsZXQ7XHJcbiAgbGV0IG1uZW1vbmljID0gbnVsbDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIENyZWF0ZSBvciBpbXBvcnQgd2FsbGV0IGJhc2VkIG9uIHR5cGVcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlICdjcmVhdGUnOlxyXG4gICAgICAgIHdhbGxldCA9IGV0aGVycy5XYWxsZXQuY3JlYXRlUmFuZG9tKCk7XHJcbiAgICAgICAgbW5lbW9uaWMgPSB3YWxsZXQubW5lbW9uaWMucGhyYXNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnbW5lbW9uaWMnOlxyXG4gICAgICAgIGlmICghZGF0YS5tbmVtb25pYyB8fCAhaXNWYWxpZE1uZW1vbmljKGRhdGEubW5lbW9uaWMpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW5lbW9uaWMgcGhyYXNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNsZWFuTW5lbW9uaWMgPSBkYXRhLm1uZW1vbmljLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XHJcbiAgICAgICAgd2FsbGV0ID0gZXRoZXJzLldhbGxldC5mcm9tUGhyYXNlKGNsZWFuTW5lbW9uaWMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAncHJpdmF0ZWtleSc6XHJcbiAgICAgICAgaWYgKCFkYXRhLnByaXZhdGVLZXkgfHwgIWlzVmFsaWRQcml2YXRlS2V5KGRhdGEucHJpdmF0ZUtleSkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIGtleScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXkgPSBkYXRhLnByaXZhdGVLZXkuc3RhcnRzV2l0aCgnMHgnKSA/IGRhdGEucHJpdmF0ZUtleSA6ICcweCcgKyBkYXRhLnByaXZhdGVLZXk7XHJcbiAgICAgICAgd2FsbGV0ID0gbmV3IGV0aGVycy5XYWxsZXQoa2V5KTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdhbGxldCB0eXBlOiAnICsgdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSBhZGRyZXNzXHJcbiAgICBpZiAoYXdhaXQgaXNEdXBsaWNhdGVBZGRyZXNzKHdhbGxldC5hZGRyZXNzKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgd2FsbGV0IGFscmVhZHkgZXhpc3RzIGluIHlvdXIgd2FsbGV0IGxpc3QnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgY3VycmVudCByZWNvbW1lbmRlZCBpdGVyYXRpb25zXHJcbiAgICBjb25zdCBjdXJyZW50SXRlcmF0aW9ucyA9IGdldEN1cnJlbnRSZWNvbW1lbmRlZEl0ZXJhdGlvbnMoKTtcclxuXHJcbiAgICAvLyBEb3VibGUgZW5jcnlwdGlvbjpcclxuICAgIC8vIDEuIEVuY3J5cHQgd2FsbGV0IHdpdGggZXRoZXJzLmpzIChjcmVhdGVzIGVuY3J5cHRlZCBKU09OIGtleXN0b3JlKVxyXG4gICAgY29uc3QgZW5jcnlwdGVkSnNvbiA9IGF3YWl0IHdhbGxldC5lbmNyeXB0KHBhc3N3b3JkKTtcclxuXHJcbiAgICAvLyAyLiBFbmNyeXB0IHRoZSBrZXlzdG9yZSBhZ2FpbiB3aXRoIEFFUy1HQ00gdXNpbmcgY3VycmVudCBpdGVyYXRpb24gcmVjb21tZW5kYXRpb25zXHJcbiAgICBjb25zdCBkb3VibGVFbmNyeXB0ZWQgPSBhd2FpdCBlbmNyeXB0V2l0aEFFUyhlbmNyeXB0ZWRKc29uLCBwYXNzd29yZCwgY3VycmVudEl0ZXJhdGlvbnMpO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIG5pY2tuYW1lIGlmIG5vdCBwcm92aWRlZFxyXG4gICAgY29uc3QgZmluYWxOaWNrbmFtZSA9IG5pY2tuYW1lIHx8IGF3YWl0IGdlbmVyYXRlRGVmYXVsdE5pY2tuYW1lKCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHdhbGxldCBlbnRyeSB3aXRoIGRvdWJsZS1lbmNyeXB0ZWQga2V5c3RvcmVcclxuICAgIGNvbnN0IHdhbGxldEVudHJ5ID0ge1xyXG4gICAgICBpZDogZ2VuZXJhdGVXYWxsZXRJZCgpLFxyXG4gICAgICBuaWNrbmFtZTogZmluYWxOaWNrbmFtZSxcclxuICAgICAgYWRkcmVzczogd2FsbGV0LmFkZHJlc3MsXHJcbiAgICAgIGVuY3J5cHRlZEtleXN0b3JlOiBkb3VibGVFbmNyeXB0ZWQsXHJcbiAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcclxuICAgICAgaW1wb3J0TWV0aG9kOiB0eXBlLFxyXG4gICAgICBsYXN0U2VjdXJpdHlVcGdyYWRlOiBEYXRlLm5vdygpLCAvLyBUcmFjayB3aGVuIGVuY3J5cHRpb24gd2FzIGxhc3QgdXBncmFkZWRcclxuICAgICAgY3VycmVudEl0ZXJhdGlvbnM6IGN1cnJlbnRJdGVyYXRpb25zIC8vIFN0b3JlIGZvciBVSSBkaXNwbGF5XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEdldCBjdXJyZW50IHdhbGxldHMgZGF0YVxyXG4gICAgY29uc3Qgd2FsbGV0c0RhdGEgPSBhd2FpdCBnZXRBbGxXYWxsZXRzKCk7XHJcblxyXG4gICAgLy8gQ2hlY2sgd2FsbGV0IGxpbWl0IChtYXggMTApXHJcbiAgICBpZiAod2FsbGV0c0RhdGEud2FsbGV0TGlzdC5sZW5ndGggPj0gMTApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIHdhbGxldCBsaW1pdCAoMTApIHJlYWNoZWQuIFBsZWFzZSBkZWxldGUgYSB3YWxsZXQgdG8gYWRkIGEgbmV3IG9uZS4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdG8gbGlzdFxyXG4gICAgd2FsbGV0c0RhdGEud2FsbGV0TGlzdC5wdXNoKHdhbGxldEVudHJ5KTtcclxuXHJcbiAgICAvLyBTZXQgYXMgYWN0aXZlIGlmIGl0J3MgdGhlIGZpcnN0IHdhbGxldFxyXG4gICAgaWYgKHdhbGxldHNEYXRhLndhbGxldExpc3QubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIHdhbGxldHNEYXRhLmFjdGl2ZVdhbGxldElkID0gd2FsbGV0RW50cnkuaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2F2ZSB1cGRhdGVkIGRhdGFcclxuICAgIGF3YWl0IHNhdmUoV0FMTEVUU19LRVksIHdhbGxldHNEYXRhKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+UkCBXYWxsZXQgY3JlYXRlZCB3aXRoICR7Y3VycmVudEl0ZXJhdGlvbnMudG9Mb2NhbGVTdHJpbmcoKX0gUEJLREYyIGl0ZXJhdGlvbnNgKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gd2FsbGV0IGluZm9cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiB3YWxsZXRFbnRyeS5pZCxcclxuICAgICAgYWRkcmVzczogd2FsbGV0LmFkZHJlc3MsXHJcbiAgICAgIG1uZW1vbmljOiBtbmVtb25pYyAvLyBPbmx5IHNldCBmb3IgbmV3bHkgY3JlYXRlZCB3YWxsZXRzXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgd2FsbGV0OicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIGFjdGl2ZSB3YWxsZXRcclxuICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIC0gV2FsbGV0IElEIHRvIHN3aXRjaCB0b1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgbmV3IGFjdGl2ZSB3YWxsZXQgaW5mb1xyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgd2FsbGV0IElEIG5vdCBmb3VuZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldEFjdGl2ZVdhbGxldCh3YWxsZXRJZCkge1xyXG4gIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgZ2V0QWxsV2FsbGV0cygpO1xyXG5cclxuICAvLyBGaW5kIHdhbGxldFxyXG4gIGNvbnN0IHdhbGxldCA9IHdhbGxldHNEYXRhLndhbGxldExpc3QuZmluZCh3ID0+IHcuaWQgPT09IHdhbGxldElkKTtcclxuICBpZiAoIXdhbGxldCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGZvdW5kJyk7XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgYWN0aXZlIHdhbGxldFxyXG4gIHdhbGxldHNEYXRhLmFjdGl2ZVdhbGxldElkID0gd2FsbGV0SWQ7XHJcbiAgYXdhaXQgc2F2ZShXQUxMRVRTX0tFWSwgd2FsbGV0c0RhdGEpO1xyXG5cclxuICByZXR1cm4gd2FsbGV0O1xyXG59XHJcblxyXG4vKipcclxuICogUmVuYW1lcyBhIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgLSBXYWxsZXQgSUQgdG8gcmVuYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdOaWNrbmFtZSAtIE5ldyBuaWNrbmFtZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cclxuICogQHRocm93cyB7RXJyb3J9IElmIHdhbGxldCBub3QgZm91bmQgb3Igbmlja25hbWUgaXMgaW52YWxpZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmFtZVdhbGxldCh3YWxsZXRJZCwgbmV3Tmlja25hbWUpIHtcclxuICBpZiAoIW5ld05pY2tuYW1lIHx8IG5ld05pY2tuYW1lLnRyaW0oKS5sZW5ndGggPT09IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTmlja25hbWUgY2Fubm90IGJlIGVtcHR5Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAobmV3Tmlja25hbWUubGVuZ3RoID4gMzApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTmlja25hbWUgdG9vIGxvbmcgKG1heCAzMCBjaGFyYWN0ZXJzKScpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgd2FsbGV0c0RhdGEgPSBhd2FpdCBnZXRBbGxXYWxsZXRzKCk7XHJcbiAgY29uc3Qgd2FsbGV0ID0gd2FsbGV0c0RhdGEud2FsbGV0TGlzdC5maW5kKHcgPT4gdy5pZCA9PT0gd2FsbGV0SWQpO1xyXG5cclxuICBpZiAoIXdhbGxldCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGZvdW5kJyk7XHJcbiAgfVxyXG5cclxuICB3YWxsZXQubmlja25hbWUgPSBuZXdOaWNrbmFtZS50cmltKCk7XHJcbiAgYXdhaXQgc2F2ZShXQUxMRVRTX0tFWSwgd2FsbGV0c0RhdGEpO1xyXG59XHJcblxyXG4vKipcclxuICogRGVsZXRlcyBhIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgLSBXYWxsZXQgSUQgdG8gZGVsZXRlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFVzZXIgcGFzc3dvcmQgZm9yIHZlcmlmaWNhdGlvblxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cclxuICogQHRocm93cyB7RXJyb3J9IElmIHBhc3N3b3JkIGlzIGluY29ycmVjdCBvciB3YWxsZXQgbm90IGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlV2FsbGV0KHdhbGxldElkLCBwYXNzd29yZCkge1xyXG4gIC8vIFZlcmlmeSBwYXNzd29yZCBmaXJzdCBieSB0cnlpbmcgdG8gdW5sb2NrIGFjdGl2ZSB3YWxsZXRcclxuICBhd2FpdCB1bmxvY2tXYWxsZXQocGFzc3dvcmQpO1xyXG5cclxuICBjb25zdCB3YWxsZXRzRGF0YSA9IGF3YWl0IGdldEFsbFdhbGxldHMoKTtcclxuICBjb25zdCB3YWxsZXRJbmRleCA9IHdhbGxldHNEYXRhLndhbGxldExpc3QuZmluZEluZGV4KHcgPT4gdy5pZCA9PT0gd2FsbGV0SWQpO1xyXG5cclxuICBpZiAod2FsbGV0SW5kZXggPT09IC0xKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgZm91bmQnKTtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB3YWxsZXQgZnJvbSBsaXN0XHJcbiAgd2FsbGV0c0RhdGEud2FsbGV0TGlzdC5zcGxpY2Uod2FsbGV0SW5kZXgsIDEpO1xyXG5cclxuICAvLyBJZiB3ZSBkZWxldGVkIHRoZSBhY3RpdmUgd2FsbGV0LCBzd2l0Y2ggdG8gZmlyc3QgYXZhaWxhYmxlXHJcbiAgaWYgKHdhbGxldHNEYXRhLmFjdGl2ZVdhbGxldElkID09PSB3YWxsZXRJZCkge1xyXG4gICAgd2FsbGV0c0RhdGEuYWN0aXZlV2FsbGV0SWQgPSB3YWxsZXRzRGF0YS53YWxsZXRMaXN0Lmxlbmd0aCA+IDBcclxuICAgICAgPyB3YWxsZXRzRGF0YS53YWxsZXRMaXN0WzBdLmlkXHJcbiAgICAgIDogbnVsbDtcclxuICB9XHJcblxyXG4gIGF3YWl0IHNhdmUoV0FMTEVUU19LRVksIHdhbGxldHNEYXRhKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVubG9ja3MgdGhlIGFjdGl2ZSB3YWxsZXQgYW5kIHJldHVybnMgc2lnbmVyXHJcbiAqIEF1dG8tdXBncmFkZXMgZW5jcnlwdGlvbiBpZiB1c2luZyBvdXRkYXRlZCBpdGVyYXRpb24gY291bnRcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVXNlciBwYXNzd29yZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbmFsIHNldHRpbmdzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5za2lwVXBncmFkZSAtIFNraXAgYXV0by11cGdyYWRlIChmb3IgdGVzdGluZylcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblVwZ3JhZGVTdGFydCAtIENhbGxiYWNrIHdoZW4gdXBncmFkZSBzdGFydHNcclxuICogQHJldHVybnMge1Byb21pc2U8e2FkZHJlc3M6IHN0cmluZywgc2lnbmVyOiBldGhlcnMuV2FsbGV0LCB1cGdyYWRlZD86IGJvb2xlYW59Pn1cclxuICogQHRocm93cyB7RXJyb3J9IElmIHBhc3N3b3JkIGlzIGluY29ycmVjdCBvciBubyBhY3RpdmUgd2FsbGV0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdW5sb2NrV2FsbGV0KHBhc3N3b3JkLCBvcHRpb25zID0ge30pIHtcclxuICBjb25zdCBhY3RpdmVXYWxsZXQgPSBhd2FpdCBnZXRBY3RpdmVXYWxsZXQoKTtcclxuXHJcbiAgaWYgKCFhY3RpdmVXYWxsZXQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm8gd2FsbGV0IGZvdW5kLiBQbGVhc2UgY3JlYXRlIG9yIGltcG9ydCBhIHdhbGxldC4nKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhd2FpdCB1bmxvY2tTcGVjaWZpY1dhbGxldChhY3RpdmVXYWxsZXQuaWQsIHBhc3N3b3JkLCBvcHRpb25zKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVubG9ja3MgYSBzcGVjaWZpYyB3YWxsZXQgYnkgSUQgd2l0aCBhdXRvLXVwZ3JhZGUgY2FwYWJpbGl0eVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgLSBXYWxsZXQgSUQgdG8gdW5sb2NrXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFVzZXIgcGFzc3dvcmRcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25hbCBzZXR0aW5nc1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2tpcFVwZ3JhZGUgLSBTa2lwIGF1dG8tdXBncmFkZSAoZm9yIHRlc3RpbmcvZXhwb3J0KVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uVXBncmFkZVN0YXJ0IC0gQ2FsbGJhY2sgd2hlbiB1cGdyYWRlIHN0YXJ0c1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7YWRkcmVzczogc3RyaW5nLCBzaWduZXI6IGV0aGVycy5XYWxsZXQsIHVwZ3JhZGVkPzogYm9vbGVhbiwgaXRlcmF0aW9uc0JlZm9yZT86IG51bWJlciwgaXRlcmF0aW9uc0FmdGVyPzogbnVtYmVyfT59XHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBwYXNzd29yZCBpcyBpbmNvcnJlY3Qgb3Igd2FsbGV0IG5vdCBmb3VuZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVubG9ja1NwZWNpZmljV2FsbGV0KHdhbGxldElkLCBwYXNzd29yZCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgZ2V0QWxsV2FsbGV0cygpO1xyXG4gICAgY29uc3Qgd2FsbGV0ID0gd2FsbGV0c0RhdGEud2FsbGV0TGlzdC5maW5kKHcgPT4gdy5pZCA9PT0gd2FsbGV0SWQpO1xyXG5cclxuICAgIGlmICghd2FsbGV0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBmb3VuZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlY3J5cHQgdGhlIEFFUy1HQ00gbGF5ZXIgKGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyBpdGVyYXRpb24gY291bnQpXHJcbiAgICBjb25zdCBrZXlzdG9yZUpzb24gPSBhd2FpdCBkZWNyeXB0V2l0aEFFUyh3YWxsZXQuZW5jcnlwdGVkS2V5c3RvcmUsIHBhc3N3b3JkKTtcclxuXHJcbiAgICAvLyBUaGVuIGRlY3J5cHQgd2FsbGV0IHVzaW5nIGV0aGVycy5qcyBrZXlzdG9yZVxyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZXRoZXJzLldhbGxldC5mcm9tRW5jcnlwdGVkSnNvbihcclxuICAgICAga2V5c3RvcmVKc29uLFxyXG4gICAgICBwYXNzd29yZFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgYWRkcmVzcyBpZiBpdCdzIG51bGwgKG1pZ3JhdGlvbiBjYXNlKVxyXG4gICAgaWYgKCF3YWxsZXQuYWRkcmVzcykge1xyXG4gICAgICB3YWxsZXQuYWRkcmVzcyA9IHNpZ25lci5hZGRyZXNzO1xyXG4gICAgICBhd2FpdCBzYXZlKFdBTExFVFNfS0VZLCB3YWxsZXRzRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT0gQVVUTy1VUEdSQURFIFNZU1RFTSA9PT09PVxyXG4gICAgLy8gQ2hlY2sgaWYgd2FsbGV0IGVuY3J5cHRpb24gbmVlZHMgc2VjdXJpdHkgdXBncmFkZVxyXG4gICAgaWYgKCFvcHRpb25zLnNraXBVcGdyYWRlKSB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRJdGVyYXRpb25zID0gZ2V0SXRlcmF0aW9uc0Zyb21FbmNyeXB0ZWQod2FsbGV0LmVuY3J5cHRlZEtleXN0b3JlKTtcclxuICAgICAgY29uc3QgcmVjb21tZW5kZWRJdGVyYXRpb25zID0gZ2V0Q3VycmVudFJlY29tbWVuZGVkSXRlcmF0aW9ucygpO1xyXG5cclxuICAgICAgLy8gVXBncmFkZSBpZiBjdXJyZW50IGl0ZXJhdGlvbnMgYXJlIGJlbG93IHJlY29tbWVuZGF0aW9uXHJcbiAgICAgIGlmIChjdXJyZW50SXRlcmF0aW9ucyA8IHJlY29tbWVuZGVkSXRlcmF0aW9ucykge1xyXG4gICAgICAgIC8vIENPTkNVUlJFTkNZIENPTlRST0w6IENoZWNrIGlmIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgdGhpcyB3YWxsZXRcclxuICAgICAgICBpZiAob25nb2luZ1VwZ3JhZGVzLmhhcyh3YWxsZXRJZCkpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDij7MgV2FsbGV0IHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2FpdGluZyBmb3IgY29tcGxldGlvbi4uLmApO1xyXG5cclxuICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBvbmdvaW5nIHVwZ3JhZGUgdG8gY29tcGxldGVcclxuICAgICAgICAgIGF3YWl0IG9uZ29pbmdVcGdyYWRlcy5nZXQod2FsbGV0SWQpO1xyXG5cclxuICAgICAgICAgIC8vIFJlbG9hZCB3YWxsZXQgZGF0YSBhZnRlciB1cGdyYWRlIGNvbXBsZXRlc1xyXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFdhbGxldHNEYXRhID0gYXdhaXQgZ2V0QWxsV2FsbGV0cygpO1xyXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFdhbGxldCA9IHVwZGF0ZWRXYWxsZXRzRGF0YS53YWxsZXRMaXN0LmZpbmQodyA9PiB3LmlkID09PSB3YWxsZXRJZCk7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHdpdGggdXBncmFkZWQgZmxhZyBzZXQgdG8gdHJ1ZSAoYW5vdGhlciB0YWIgZGlkIHRoZSB1cGdyYWRlKVxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWRkcmVzczogc2lnbmVyLmFkZHJlc3MsXHJcbiAgICAgICAgICAgIHNpZ25lcjogc2lnbmVyLFxyXG4gICAgICAgICAgICB1cGdyYWRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgaXRlcmF0aW9uc0JlZm9yZTogY3VycmVudEl0ZXJhdGlvbnMsXHJcbiAgICAgICAgICAgIGl0ZXJhdGlvbnNBZnRlcjogcmVjb21tZW5kZWRJdGVyYXRpb25zLFxyXG4gICAgICAgICAgICB1cGdyYWRlZEJ5Q29uY3VycmVudFRhYjogdHJ1ZVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN0YXJ0IHVwZ3JhZGUgYW5kIHRyYWNrIGl0XHJcbiAgICAgICAgY29uc3QgdXBncmFkZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgaXRlcmF0aW9uc0JlZm9yZSA9IGN1cnJlbnRJdGVyYXRpb25zO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflJAgV2FsbGV0IGVuY3J5cHRpb24gdXBncmFkZSBhdmFpbGFibGU6YCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBDdXJyZW50OiAke2N1cnJlbnRJdGVyYXRpb25zLnRvTG9jYWxlU3RyaW5nKCl9IGl0ZXJhdGlvbnNgKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFJlY29tbWVuZGVkOiAke3JlY29tbWVuZGVkSXRlcmF0aW9ucy50b0xvY2FsZVN0cmluZygpfSBpdGVyYXRpb25zYCk7XHJcblxyXG4gICAgICAgICAgICAvLyBOb3RpZnkgdXNlciB2aWEgY2FsbGJhY2sgaWYgcHJvdmlkZWRcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25VcGdyYWRlU3RhcnQpIHtcclxuICAgICAgICAgICAgICBvcHRpb25zLm9uVXBncmFkZVN0YXJ0KHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgcmVjb21tZW5kZWRJdGVyYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkVGltZU1zOiBNYXRoLmZsb29yKChyZWNvbW1lbmRlZEl0ZXJhdGlvbnMgLyAxMDAwMDApICogMTAwKSAvLyB+MTAwbXMgcGVyIDEwMGsgaXRlcmF0aW9uc1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBVcGdyYWRpbmcgd2FsbGV0IHNlY3VyaXR5Li4uYCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZ3JhZGVTdGFydCA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZS1lbmNyeXB0IHdpdGggY3VycmVudCByZWNvbW1lbmRhdGlvbnNcclxuICAgICAgICAgICAgLy8gTGF5ZXIgMTogZXRoZXJzLmpzIGtleXN0b3JlICh1bmNoYW5nZWQpXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0tleXN0b3JlSnNvbiA9IGF3YWl0IHNpZ25lci5lbmNyeXB0KHBhc3N3b3JkKTtcclxuXHJcbiAgICAgICAgICAgIC8vIExheWVyIDI6IEFFUy1HQ00gd2l0aCBuZXcgaXRlcmF0aW9uIGNvdW50XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuY3J5cHRlZCA9IGF3YWl0IGVuY3J5cHRXaXRoQUVTKFxyXG4gICAgICAgICAgICAgIG5ld0tleXN0b3JlSnNvbixcclxuICAgICAgICAgICAgICBwYXNzd29yZCxcclxuICAgICAgICAgICAgICByZWNvbW1lbmRlZEl0ZXJhdGlvbnNcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB3YWxsZXQgKHJlbG9hZCB0byBnZXQgbGF0ZXN0IHN0YXRlKVxyXG4gICAgICAgICAgICBjb25zdCBsYXRlc3RXYWxsZXRzRGF0YSA9IGF3YWl0IGdldEFsbFdhbGxldHMoKTtcclxuICAgICAgICAgICAgY29uc3QgbGF0ZXN0V2FsbGV0ID0gbGF0ZXN0V2FsbGV0c0RhdGEud2FsbGV0TGlzdC5maW5kKHcgPT4gdy5pZCA9PT0gd2FsbGV0SWQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFsYXRlc3RXYWxsZXQpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgZm91bmQgZHVyaW5nIHVwZ3JhZGUnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGF0ZXN0V2FsbGV0LmVuY3J5cHRlZEtleXN0b3JlID0gbmV3RW5jcnlwdGVkO1xyXG4gICAgICAgICAgICBsYXRlc3RXYWxsZXQubGFzdFNlY3VyaXR5VXBncmFkZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGxhdGVzdFdhbGxldC5jdXJyZW50SXRlcmF0aW9ucyA9IHJlY29tbWVuZGVkSXRlcmF0aW9ucztcclxuICAgICAgICAgICAgYXdhaXQgc2F2ZShXQUxMRVRTX0tFWSwgbGF0ZXN0V2FsbGV0c0RhdGEpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdXBncmFkZVRpbWUgPSBEYXRlLm5vdygpIC0gdXBncmFkZVN0YXJ0O1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFdhbGxldCB1cGdyYWRlZCB0byAke3JlY29tbWVuZGVkSXRlcmF0aW9ucy50b0xvY2FsZVN0cmluZygpfSBpdGVyYXRpb25zICgke3VwZ3JhZGVUaW1lfW1zKWApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBpdGVyYXRpb25zQmVmb3JlLFxyXG4gICAgICAgICAgICAgIGl0ZXJhdGlvbnNBZnRlcjogcmVjb21tZW5kZWRJdGVyYXRpb25zXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0cmFja2luZ1xyXG4gICAgICAgICAgICBvbmdvaW5nVXBncmFkZXMuZGVsZXRlKHdhbGxldElkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICAvLyBUcmFjayB0aGUgb25nb2luZyB1cGdyYWRlXHJcbiAgICAgICAgb25nb2luZ1VwZ3JhZGVzLnNldCh3YWxsZXRJZCwgdXBncmFkZVByb21pc2UpO1xyXG5cclxuICAgICAgICAvLyBXYWl0IGZvciB1cGdyYWRlIHRvIGNvbXBsZXRlXHJcbiAgICAgICAgY29uc3QgdXBncmFkZVJlc3VsdCA9IGF3YWl0IHVwZ3JhZGVQcm9taXNlO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgYWRkcmVzczogc2lnbmVyLmFkZHJlc3MsXHJcbiAgICAgICAgICBzaWduZXI6IHNpZ25lcixcclxuICAgICAgICAgIHVwZ3JhZGVkOiB0cnVlLFxyXG4gICAgICAgICAgLi4udXBncmFkZVJlc3VsdFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhZGRyZXNzOiBzaWduZXIuYWRkcmVzcyxcclxuICAgICAgc2lnbmVyOiBzaWduZXIsXHJcbiAgICAgIHVwZ3JhZGVkOiBmYWxzZVxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2luY29ycmVjdCBwYXNzd29yZCcpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0RlY3J5cHRpb24gZmFpbGVkJykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgcGFzc3dvcmQnKTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVubG9jayB3YWxsZXQ6ICcgKyBlcnJvci5tZXNzYWdlKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHBvcnRzIHByaXZhdGUga2V5IGZvciB0aGUgYWN0aXZlIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEhleCBwcml2YXRlIGtleVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgcGFzc3dvcmQgaXMgaW5jb3JyZWN0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0UHJpdmF0ZUtleShwYXNzd29yZCkge1xyXG4gIC8vIFNraXAgdXBncmFkZSB3aGVuIGV4cG9ydGluZyAodXNlciBqdXN0IHdhbnRzIHRoZSBrZXkpXHJcbiAgY29uc3QgeyBzaWduZXIgfSA9IGF3YWl0IHVubG9ja1dhbGxldChwYXNzd29yZCwgeyBza2lwVXBncmFkZTogdHJ1ZSB9KTtcclxuICByZXR1cm4gc2lnbmVyLnByaXZhdGVLZXk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHBvcnRzIG1uZW1vbmljIGZvciB0aGUgYWN0aXZlIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ3xudWxsPn0gMTItd29yZCBtbmVtb25pYyBvciBudWxsIGlmIHdhbGxldCB3YXMgaW1wb3J0ZWQgZnJvbSBwcml2YXRlIGtleVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgcGFzc3dvcmQgaXMgaW5jb3JyZWN0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0TW5lbW9uaWMocGFzc3dvcmQpIHtcclxuICAvLyBTa2lwIHVwZ3JhZGUgd2hlbiBleHBvcnRpbmcgKHVzZXIganVzdCB3YW50cyB0aGUgbW5lbW9uaWMpXHJcbiAgY29uc3QgeyBzaWduZXIgfSA9IGF3YWl0IHVubG9ja1dhbGxldChwYXNzd29yZCwgeyBza2lwVXBncmFkZTogdHJ1ZSB9KTtcclxuICByZXR1cm4gc2lnbmVyLm1uZW1vbmljID8gc2lnbmVyLm1uZW1vbmljLnBocmFzZSA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHBvcnRzIHByaXZhdGUga2V5IGZvciBhIHNwZWNpZmljIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgLSBXYWxsZXQgSURcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVXNlciBwYXNzd29yZFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBIZXggcHJpdmF0ZSBrZXlcclxuICogQHRocm93cyB7RXJyb3J9IElmIHBhc3N3b3JkIGlzIGluY29ycmVjdCBvciB3YWxsZXQgbm90IGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0UHJpdmF0ZUtleUZvcldhbGxldCh3YWxsZXRJZCwgcGFzc3dvcmQpIHtcclxuICBjb25zdCB7IHNpZ25lciB9ID0gYXdhaXQgdW5sb2NrU3BlY2lmaWNXYWxsZXQod2FsbGV0SWQsIHBhc3N3b3JkLCB7IHNraXBVcGdyYWRlOiB0cnVlIH0pO1xyXG4gIHJldHVybiBzaWduZXIucHJpdmF0ZUtleTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4cG9ydHMgbW5lbW9uaWMgZm9yIGEgc3BlY2lmaWMgd2FsbGV0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCAtIFdhbGxldCBJRFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ3xudWxsPn0gMTItd29yZCBtbmVtb25pYyBvciBudWxsIGlmIG5vdCBhdmFpbGFibGVcclxuICogQHRocm93cyB7RXJyb3J9IElmIHBhc3N3b3JkIGlzIGluY29ycmVjdCBvciB3YWxsZXQgbm90IGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0TW5lbW9uaWNGb3JXYWxsZXQod2FsbGV0SWQsIHBhc3N3b3JkKSB7XHJcbiAgY29uc3QgeyBzaWduZXIgfSA9IGF3YWl0IHVubG9ja1NwZWNpZmljV2FsbGV0KHdhbGxldElkLCBwYXNzd29yZCwgeyBza2lwVXBncmFkZTogdHJ1ZSB9KTtcclxuICByZXR1cm4gc2lnbmVyLm1uZW1vbmljID8gc2lnbmVyLm1uZW1vbmljLnBocmFzZSA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHNlY3VyaXR5IGluZm9ybWF0aW9uIGZvciBhIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgLSBXYWxsZXQgSURcclxuICogQHJldHVybnMge1Byb21pc2U8e2N1cnJlbnRJdGVyYXRpb25zOiBudW1iZXIsIHJlY29tbWVuZGVkSXRlcmF0aW9uczogbnVtYmVyLCBuZWVkc1VwZ3JhZGU6IGJvb2xlYW4sIGxhc3RVcGdyYWRlOiBudW1iZXJ9Pn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRXYWxsZXRTZWN1cml0eUluZm8od2FsbGV0SWQpIHtcclxuICBjb25zdCB3YWxsZXRzRGF0YSA9IGF3YWl0IGdldEFsbFdhbGxldHMoKTtcclxuICBjb25zdCB3YWxsZXQgPSB3YWxsZXRzRGF0YS53YWxsZXRMaXN0LmZpbmQodyA9PiB3LmlkID09PSB3YWxsZXRJZCk7XHJcblxyXG4gIGlmICghd2FsbGV0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgZm91bmQnKTtcclxuICB9XHJcblxyXG4gIC8vIFVzZSBtZXRhZGF0YSBmaWVsZCBpZiBhdmFpbGFibGUgKG1vcmUgZWZmaWNpZW50KSwgb3RoZXJ3aXNlIHBhcnNlIGVuY3J5cHRlZCBkYXRhXHJcbiAgY29uc3QgY3VycmVudEl0ZXJhdGlvbnMgPSB3YWxsZXQuY3VycmVudEl0ZXJhdGlvbnMgfHwgZ2V0SXRlcmF0aW9uc0Zyb21FbmNyeXB0ZWQod2FsbGV0LmVuY3J5cHRlZEtleXN0b3JlKTtcclxuICBjb25zdCByZWNvbW1lbmRlZEl0ZXJhdGlvbnMgPSBnZXRDdXJyZW50UmVjb21tZW5kZWRJdGVyYXRpb25zKCk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBjdXJyZW50SXRlcmF0aW9ucyxcclxuICAgIHJlY29tbWVuZGVkSXRlcmF0aW9ucyxcclxuICAgIG5lZWRzVXBncmFkZTogY3VycmVudEl0ZXJhdGlvbnMgPCByZWNvbW1lbmRlZEl0ZXJhdGlvbnMsXHJcbiAgICBsYXN0VXBncmFkZTogd2FsbGV0Lmxhc3RTZWN1cml0eVVwZ3JhZGUgfHwgd2FsbGV0LmNyZWF0ZWRBdFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMRUdBQ1k6IENyZWF0ZXMgZmlyc3Qgd2FsbGV0IChmb3IgaW5pdGlhbCBzZXR1cCBjb21wYXRpYmlsaXR5KVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHthZGRyZXNzOiBzdHJpbmcsIG1uZW1vbmljOiBzdHJpbmd9Pn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVXYWxsZXQocGFzc3dvcmQpIHtcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZGRXYWxsZXQoJ2NyZWF0ZScsIHt9LCBwYXNzd29yZCwgJ01haW4gV2FsbGV0Jyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGFkZHJlc3M6IHJlc3VsdC5hZGRyZXNzLFxyXG4gICAgbW5lbW9uaWM6IHJlc3VsdC5tbmVtb25pY1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMRUdBQ1k6IEltcG9ydHMgZnJvbSBtbmVtb25pYyAoZm9yIGluaXRpYWwgc2V0dXAgY29tcGF0aWJpbGl0eSlcclxuICogQHBhcmFtIHtzdHJpbmd9IG1uZW1vbmljIC0gMTItd29yZCBzZWVkIHBocmFzZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHthZGRyZXNzOiBzdHJpbmd9Pn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRGcm9tTW5lbW9uaWMobW5lbW9uaWMsIHBhc3N3b3JkKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWRkV2FsbGV0KCdtbmVtb25pYycsIHsgbW5lbW9uaWMgfSwgcGFzc3dvcmQsICdNYWluIFdhbGxldCcpO1xyXG4gIHJldHVybiB7XHJcbiAgICBhZGRyZXNzOiByZXN1bHQuYWRkcmVzc1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMRUdBQ1k6IEltcG9ydHMgZnJvbSBwcml2YXRlIGtleSAoZm9yIGluaXRpYWwgc2V0dXAgY29tcGF0aWJpbGl0eSlcclxuICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXkgLSBIZXggcHJpdmF0ZSBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVXNlciBwYXNzd29yZFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7YWRkcmVzczogc3RyaW5nfT59XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0RnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSwgcGFzc3dvcmQpIHtcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZGRXYWxsZXQoJ3ByaXZhdGVrZXknLCB7IHByaXZhdGVLZXkgfSwgcGFzc3dvcmQsICdNYWluIFdhbGxldCcpO1xyXG4gIHJldHVybiB7XHJcbiAgICBhZGRyZXNzOiByZXN1bHQuYWRkcmVzc1xyXG4gIH07XHJcbn1cclxuIiwiLyoqXHJcbiAqIGNvcmUvcnBjLmpzXHJcbiAqXHJcbiAqIFJQQyBwcm92aWRlciBmb3IgYmxvY2tjaGFpbiBpbnRlcmFjdGlvbiB3aXRoIGF1dG9tYXRpYyBmYWlsb3ZlclxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XHJcblxyXG4vLyBOZXR3b3JrIFJQQyBlbmRwb2ludHMgLSBNdWx0aXBsZSBlbmRwb2ludHMgcGVyIG5ldHdvcmsgZm9yIHJlZHVuZGFuY3lcclxuY29uc3QgUlBDX0VORFBPSU5UUyA9IHtcclxuICAncHVsc2VjaGFpblRlc3RuZXQnOiBbXHJcbiAgICAnaHR0cHM6Ly9ycGMudjQudGVzdG5ldC5wdWxzZWNoYWluLmNvbScsXHJcbiAgICAnaHR0cHM6Ly9ycGMtdGVzdG5ldC1wdWxzZWNoYWluLmc0bW00LmlvJ1xyXG4gIF0sXHJcbiAgJ3B1bHNlY2hhaW4nOiBbXHJcbiAgICAnaHR0cHM6Ly9ycGMucHVsc2VjaGFpbi5jb20nLFxyXG4gICAgJ2h0dHBzOi8vcHVsc2VjaGFpbi1ycGMucHVibGljbm9kZS5jb20nLFxyXG4gICAgJ2h0dHBzOi8vcnBjLXB1bHNlY2hhaW4uZzRtbTQuaW8nLFxyXG4gICAgJ2h0dHBzOi8vcHVsc2VjaGFpbi5wdWJsaWNub2RlLmNvbSdcclxuICBdLFxyXG4gICdldGhlcmV1bSc6IFtcclxuICAgICdodHRwczovL2V0aC5sbGFtYXJwYy5jb20nLFxyXG4gICAgJ2h0dHBzOi8vZXRoZXJldW0ucHVibGljbm9kZS5jb20nLFxyXG4gICAgJ2h0dHBzOi8vcnBjLmFua3IuY29tL2V0aCcsXHJcbiAgICAnaHR0cHM6Ly9jbG91ZGZsYXJlLWV0aC5jb20nXHJcbiAgXSxcclxuICAnc2Vwb2xpYSc6IFtcclxuICAgICdodHRwczovL3JwYy5zZXBvbGlhLm9yZycsXHJcbiAgICAnaHR0cHM6Ly9ldGhlcmV1bS1zZXBvbGlhLnB1YmxpY25vZGUuY29tJyxcclxuICAgICdodHRwczovL3JwYy5hbmtyLmNvbS9ldGhfc2Vwb2xpYSdcclxuICBdXHJcbn07XHJcblxyXG4vLyBDYWNoZWQgcHJvdmlkZXJzIHBlciBuZXR3b3JrXHJcbmNvbnN0IHByb3ZpZGVycyA9IHt9O1xyXG5cclxuLy8gVHJhY2sgZmFpbGVkIGVuZHBvaW50cyB0byBhdm9pZCByZXBlYXRlZCBmYWlsdXJlc1xyXG5jb25zdCBlbmRwb2ludEhlYWx0aCA9IG5ldyBNYXAoKTsgLy8gZW5kcG9pbnQgLT4geyBmYWlsdXJlczogbnVtYmVyLCBsYXN0Q2hlY2s6IHRpbWVzdGFtcCwgYmxhY2tsaXN0ZWQ6IGJvb2xlYW4gfVxyXG5cclxuLy8gSGVhbHRoIGNoZWNrIGNvbmZpZ3VyYXRpb25cclxuY29uc3QgSEVBTFRIX0NPTkZJRyA9IHtcclxuICBNQVhfRkFJTFVSRVM6IDMsICAgICAgICAgICAgICAvLyBCbGFja2xpc3QgYWZ0ZXIgMyBmYWlsdXJlc1xyXG4gIEJMQUNLTElTVF9EVVJBVElPTjogMzAwMDAwLCAgIC8vIDUgbWludXRlcyBibGFja2xpc3RcclxuICBIRUFMVEhfQ0hFQ0tfVElNRU9VVDogNTAwMCwgICAvLyA1IHNlY29uZCB0aW1lb3V0IGZvciBoZWFsdGggY2hlY2tzXHJcbiAgUkVUUllfREVMQVk6IDEwMDAgICAgICAgICAgICAgLy8gMSBzZWNvbmQgZGVsYXkgYmV0d2VlbiBlbmRwb2ludCBhdHRlbXB0c1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlY29yZHMgYW4gZW5kcG9pbnQgZmFpbHVyZSBmb3IgaGVhbHRoIHRyYWNraW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIFJQQyBlbmRwb2ludCBVUkxcclxuICovXHJcbmZ1bmN0aW9uIHJlY29yZEVuZHBvaW50RmFpbHVyZShlbmRwb2ludCkge1xyXG4gIGNvbnN0IGhlYWx0aCA9IGVuZHBvaW50SGVhbHRoLmdldChlbmRwb2ludCkgfHwgeyBmYWlsdXJlczogMCwgbGFzdENoZWNrOiBEYXRlLm5vdygpLCBibGFja2xpc3RlZDogZmFsc2UgfTtcclxuICBoZWFsdGguZmFpbHVyZXMrKztcclxuICBoZWFsdGgubGFzdENoZWNrID0gRGF0ZS5ub3coKTtcclxuICBcclxuICBpZiAoaGVhbHRoLmZhaWx1cmVzID49IEhFQUxUSF9DT05GSUcuTUFYX0ZBSUxVUkVTKSB7XHJcbiAgICBoZWFsdGguYmxhY2tsaXN0ZWQgPSB0cnVlO1xyXG4gICAgY29uc29sZS53YXJuKGDwn6uAIFJQQyBlbmRwb2ludCBibGFja2xpc3RlZCBhZnRlciAke2hlYWx0aC5mYWlsdXJlc30gZmFpbHVyZXM6ICR7ZW5kcG9pbnR9YCk7XHJcbiAgICBcclxuICAgIC8vIEF1dG8tcmVjb3ZlciBhZnRlciBibGFja2xpc3QgZHVyYXRpb25cclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBjb25zdCBjdXJyZW50SGVhbHRoID0gZW5kcG9pbnRIZWFsdGguZ2V0KGVuZHBvaW50KTtcclxuICAgICAgaWYgKGN1cnJlbnRIZWFsdGgpIHtcclxuICAgICAgICBjdXJyZW50SGVhbHRoLmJsYWNrbGlzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgY3VycmVudEhlYWx0aC5mYWlsdXJlcyA9IDA7XHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfq4AgUlBDIGVuZHBvaW50IHJlY292ZXJlZCBmcm9tIGJsYWNrbGlzdDogJHtlbmRwb2ludH1gKTtcclxuICAgICAgfVxyXG4gICAgfSwgSEVBTFRIX0NPTkZJRy5CTEFDS0xJU1RfRFVSQVRJT04pO1xyXG4gIH1cclxuICBcclxuICBlbmRwb2ludEhlYWx0aC5zZXQoZW5kcG9pbnQsIGhlYWx0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWNvcmRzIGFuIGVuZHBvaW50IHN1Y2Nlc3MgZm9yIGhlYWx0aCB0cmFja2luZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnQgLSBSUEMgZW5kcG9pbnQgVVJMXHJcbiAqL1xyXG5mdW5jdGlvbiByZWNvcmRFbmRwb2ludFN1Y2Nlc3MoZW5kcG9pbnQpIHtcclxuICBjb25zdCBoZWFsdGggPSBlbmRwb2ludEhlYWx0aC5nZXQoZW5kcG9pbnQpIHx8IHsgZmFpbHVyZXM6IDAsIGxhc3RDaGVjazogRGF0ZS5ub3coKSwgYmxhY2tsaXN0ZWQ6IGZhbHNlIH07XHJcbiAgaGVhbHRoLmZhaWx1cmVzID0gTWF0aC5tYXgoMCwgaGVhbHRoLmZhaWx1cmVzIC0gMSk7IC8vIEdyYWR1YWxseSByZWR1Y2UgZmFpbHVyZSBjb3VudFxyXG4gIGhlYWx0aC5sYXN0Q2hlY2sgPSBEYXRlLm5vdygpO1xyXG4gIGVuZHBvaW50SGVhbHRoLnNldChlbmRwb2ludCwgaGVhbHRoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhbiBlbmRwb2ludCBpcyBibGFja2xpc3RlZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnQgLSBSUEMgZW5kcG9pbnQgVVJMXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNFbmRwb2ludEJsYWNrbGlzdGVkKGVuZHBvaW50KSB7XHJcbiAgY29uc3QgaGVhbHRoID0gZW5kcG9pbnRIZWFsdGguZ2V0KGVuZHBvaW50KTtcclxuICByZXR1cm4gaGVhbHRoPy5ibGFja2xpc3RlZCB8fCBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgaGVhbHRoIGNoZWNrIG9uIGFuIFJQQyBlbmRwb2ludFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnQgLSBSUEMgZW5kcG9pbnQgVVJMXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBUcnVlIGlmIGhlYWx0aHlcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNoZWNrRW5kcG9pbnRIZWFsdGgoZW5kcG9pbnQpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihlbmRwb2ludCk7XHJcbiAgICBcclxuICAgIC8vIFJhY2UgdGhlIGhlYWx0aCBjaGVjayBhZ2FpbnN0IHRpbWVvdXRcclxuICAgIGNvbnN0IGhlYWx0aENoZWNrUHJvbWlzZSA9IHByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IFxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0hlYWx0aCBjaGVjayB0aW1lb3V0JykpLCBIRUFMVEhfQ09ORklHLkhFQUxUSF9DSEVDS19USU1FT1VUKVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtoZWFsdGhDaGVja1Byb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgb3IgY3JlYXRlcyBhbiBSUEMgcHJvdmlkZXIgZm9yIGEgbmV0d29yayB3aXRoIGF1dG9tYXRpYyBmYWlsb3ZlclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5IChlLmcuLCAncHVsc2VjaGFpblRlc3RuZXQnKVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxldGhlcnMuSnNvblJwY1Byb3ZpZGVyPn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm92aWRlcihuZXR3b3JrKSB7XHJcbiAgY29uc3QgZW5kcG9pbnRzID0gUlBDX0VORFBPSU5UU1tuZXR3b3JrXTtcclxuICBcclxuICBpZiAoIWVuZHBvaW50cykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5ldHdvcms6ICR7bmV0d29ya31gKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gSWYgd2UgaGF2ZSBhIGNhY2hlZCB3b3JraW5nIHByb3ZpZGVyLCByZXR1cm4gaXRcclxuICBpZiAocHJvdmlkZXJzW25ldHdvcmtdKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBRdWljayBoZWFsdGggY2hlY2sgb24gY2FjaGVkIHByb3ZpZGVyXHJcbiAgICAgIGF3YWl0IHByb3ZpZGVyc1tuZXR3b3JrXS5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICByZXR1cm4gcHJvdmlkZXJzW25ldHdvcmtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGDwn6uAIENhY2hlZCBwcm92aWRlciBmYWlsZWQgZm9yICR7bmV0d29ya30sIHRyeWluZyBmYWlsb3Zlci4uLmApO1xyXG4gICAgICBkZWxldGUgcHJvdmlkZXJzW25ldHdvcmtdOyAvLyBDbGVhciBmYWlsZWQgcHJvdmlkZXJcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gVHJ5IGVhY2ggZW5kcG9pbnQgdW50aWwgb25lIHdvcmtzXHJcbiAgY29uc3QgZW5kcG9pbnRzTGlzdCA9IEFycmF5LmlzQXJyYXkoZW5kcG9pbnRzKSA/IGVuZHBvaW50cyA6IFtlbmRwb2ludHNdO1xyXG4gIFxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kcG9pbnRzTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgZW5kcG9pbnQgPSBlbmRwb2ludHNMaXN0W2ldO1xyXG4gICAgXHJcbiAgICAvLyBTa2lwIGJsYWNrbGlzdGVkIGVuZHBvaW50c1xyXG4gICAgaWYgKGlzRW5kcG9pbnRCbGFja2xpc3RlZChlbmRwb2ludCkpIHtcclxuICAgICAgY29uc29sZS53YXJuKGDwn6uAIFNraXBwaW5nIGJsYWNrbGlzdGVkIGVuZHBvaW50OiAke2VuZHBvaW50fWApO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYPCfq4AgVHJ5aW5nIFJQQyBlbmRwb2ludCAoJHtpICsgMX0vJHtlbmRwb2ludHNMaXN0Lmxlbmd0aH0pOiAke2VuZHBvaW50fWApO1xyXG4gICAgICBcclxuICAgICAgLy8gQ3JlYXRlIHByb3ZpZGVyIGFuZCB0ZXN0IGl0XHJcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoZW5kcG9pbnQpO1xyXG4gICAgICBcclxuICAgICAgLy8gVmVyaWZ5IGl0IHdvcmtzIHdpdGggYSBxdWljayBjYWxsXHJcbiAgICAgIGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdWNjZXNzISBDYWNoZSBhbmQgcmV0dXJuXHJcbiAgICAgIHByb3ZpZGVyc1tuZXR3b3JrXSA9IHByb3ZpZGVyO1xyXG4gICAgICByZWNvcmRFbmRwb2ludFN1Y2Nlc3MoZW5kcG9pbnQpO1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+rgCBDb25uZWN0ZWQgdG8gUlBDOiAke2VuZHBvaW50fWApO1xyXG4gICAgICByZXR1cm4gcHJvdmlkZXI7XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihg8J+rgCBSUEMgZW5kcG9pbnQgZmFpbGVkOiAke2VuZHBvaW50fWAsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICByZWNvcmRFbmRwb2ludEZhaWx1cmUoZW5kcG9pbnQpO1xyXG4gICAgICBcclxuICAgICAgLy8gQWRkIGRlbGF5IGJlZm9yZSB0cnlpbmcgbmV4dCBlbmRwb2ludCAoZXhjZXB0IG9uIGxhc3QgYXR0ZW1wdClcclxuICAgICAgaWYgKGkgPCBlbmRwb2ludHNMaXN0Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgSEVBTFRIX0NPTkZJRy5SRVRSWV9ERUxBWSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEFsbCBlbmRwb2ludHMgZmFpbGVkXHJcbiAgdGhyb3cgbmV3IEVycm9yKGBBbGwgUlBDIGVuZHBvaW50cyBmYWlsZWQgZm9yIG5ldHdvcms6ICR7bmV0d29ya30uIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uYCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMRUdBQ1k6IFN5bmNocm9ub3VzIHByb3ZpZGVyIGdldHRlciAoZGVwcmVjYXRlZCwgdXNlIGFzeW5jIGdldFByb3ZpZGVyIGluc3RlYWQpXHJcbiAqIEtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYnV0IG1heSBmYWlsIGlmIHByb3ZpZGVyIGlzbid0IGNhY2hlZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5XHJcbiAqIEByZXR1cm5zIHtldGhlcnMuSnNvblJwY1Byb3ZpZGVyfVxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgYXN5bmMgZ2V0UHJvdmlkZXIoKSBpbnN0ZWFkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvdmlkZXJTeW5jKG5ldHdvcmspIHtcclxuICBpZiAocHJvdmlkZXJzW25ldHdvcmtdKSB7XHJcbiAgICByZXR1cm4gcHJvdmlkZXJzW25ldHdvcmtdO1xyXG4gIH1cclxuICBcclxuICAvLyBGYWxsYmFjazogY3JlYXRlIHByb3ZpZGVyIHdpdGggZmlyc3QgZW5kcG9pbnQgKG5vIGhlYWx0aCBjaGVjaylcclxuICBjb25zdCBlbmRwb2ludHMgPSBSUENfRU5EUE9JTlRTW25ldHdvcmtdO1xyXG4gIGlmICghZW5kcG9pbnRzKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbmV0d29yazogJHtuZXR3b3JrfWApO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBlbmRwb2ludCA9IEFycmF5LmlzQXJyYXkoZW5kcG9pbnRzKSA/IGVuZHBvaW50c1swXSA6IGVuZHBvaW50cztcclxuICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKGVuZHBvaW50KTtcclxuICBwcm92aWRlcnNbbmV0d29ya10gPSBwcm92aWRlcjtcclxuICByZXR1cm4gcHJvdmlkZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYWtlcyBhIHJhdyBSUEMgY2FsbCB3aXRoIGF1dG9tYXRpYyBmYWlsb3ZlclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgLSBSUEMgbWV0aG9kIG5hbWVcclxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIC0gUlBDIHBhcmFtZXRlcnNcclxuICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gUlBDIHJlc3VsdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJwY0NhbGwobmV0d29yaywgbWV0aG9kLCBwYXJhbXMgPSBbXSkge1xyXG4gIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIobmV0d29yayk7XHJcbiAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBiYWxhbmNlIGZvciBhbiBhZGRyZXNzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBFdGhlcmV1bSBhZGRyZXNzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEJhbGFuY2UgaW4gd2VpIChoZXggc3RyaW5nKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJhbGFuY2UobmV0d29yaywgYWRkcmVzcykge1xyXG4gIHJldHVybiBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfZ2V0QmFsYW5jZScsIFthZGRyZXNzLCAnbGF0ZXN0J10pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0cmFuc2FjdGlvbiBjb3VudCAobm9uY2UpIGZvciBhbiBhZGRyZXNzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBFdGhlcmV1bSBhZGRyZXNzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRyYW5zYWN0aW9uIGNvdW50IChoZXggc3RyaW5nKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uQ291bnQobmV0d29yaywgYWRkcmVzcykge1xyXG4gIHJldHVybiBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCcsIFthZGRyZXNzLCAnbGF0ZXN0J10pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBjdXJyZW50IGdhcyBwcmljZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEdhcyBwcmljZSBpbiB3ZWkgKGhleCBzdHJpbmcpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0R2FzUHJpY2UobmV0d29yaykge1xyXG4gIHJldHVybiBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfZ2FzUHJpY2UnLCBbXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIGN1cnJlbnQgYmxvY2sgbnVtYmVyXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayBrZXlcclxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQmxvY2sgbnVtYmVyIChoZXggc3RyaW5nKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJsb2NrTnVtYmVyKG5ldHdvcmspIHtcclxuICByZXR1cm4gYXdhaXQgcnBjQ2FsbChuZXR3b3JrLCAnZXRoX2Jsb2NrTnVtYmVyJywgW10pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBhIGJsb2NrIGJ5IG51bWJlclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja051bWJlciAtIEJsb2NrIG51bWJlciAoaGV4IHN0cmluZyBvciAnbGF0ZXN0JywgJ2VhcmxpZXN0JywgJ3BlbmRpbmcnKVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVUcmFuc2FjdGlvbnMgLSBXaGV0aGVyIHRvIGluY2x1ZGUgZnVsbCB0cmFuc2FjdGlvbiBvYmplY3RzIChkZWZhdWx0IGZhbHNlKVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBCbG9jayBvYmplY3RcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCbG9ja0J5TnVtYmVyKG5ldHdvcmssIGJsb2NrTnVtYmVyLCBpbmNsdWRlVHJhbnNhY3Rpb25zID0gZmFsc2UpIHtcclxuICByZXR1cm4gYXdhaXQgcnBjQ2FsbChuZXR3b3JrLCAnZXRoX2dldEJsb2NrQnlOdW1iZXInLCBbYmxvY2tOdW1iZXIsIGluY2x1ZGVUcmFuc2FjdGlvbnNdKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgcmVjZW50IHRyYW5zYWN0aW9ucyBmb3IgYW4gYWRkcmVzc1xyXG4gKiBOT1RFOiBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgdGhhdCByZXR1cm5zIGVtcHR5IGFycmF5LlxyXG4gKiBTY2FubmluZyBibG9ja3MgdmlhIFJQQyBpcyB0b28gZXhwZW5zaXZlICh3b3VsZCBtYWtlIDEwMCsgcmVxdWVzdHMpLlxyXG4gKiBQcm9wZXIgdHJhbnNhY3Rpb24gaGlzdG9yeSByZXF1aXJlcyBhbiBpbmRleGVyL2Jsb2NrIGV4cGxvcmVyIEFQSS5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIGtleVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEV0aGVyZXVtIGFkZHJlc3NcclxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gTWF4aW11bSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIHRvIHJldHVybiAoZGVmYXVsdCAzKVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmxvY2tzVG9TY2FuIC0gTnVtYmVyIG9mIHJlY2VudCBibG9ja3MgdG8gc2NhbiAoZGVmYXVsdCA1MClcclxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiBvYmplY3RzXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVjZW50VHJhbnNhY3Rpb25zKG5ldHdvcmssIGFkZHJlc3MsIGxpbWl0ID0gMywgYmxvY2tzVG9TY2FuID0gNTApIHtcclxuICAvLyBUcmFuc2FjdGlvbiBoaXN0b3J5IGRpc2FibGVkIHRvIGF2b2lkIGV4Y2Vzc2l2ZSBSUEMgY2FsbHNcclxuICAvLyBXb3VsZCByZXF1aXJlIHNjYW5uaW5nIGh1bmRyZWRzL3Rob3VzYW5kcyBvZiBibG9ja3NcclxuICAvLyBVc2VycyBjYW4gdmlldyB0cmFuc2FjdGlvbnMgb24gYmxvY2sgZXhwbG9yZXIgaW5zdGVhZFxyXG4gIHJldHVybiBbXTtcclxuXHJcbiAgLyogT1JJR0lOQUwgSU1QTEVNRU5UQVRJT04gLSBESVNBQkxFRCBEVUUgVE8gRVhDRVNTSVZFIFJQQyBDQUxMU1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKG5ldHdvcmspO1xyXG4gICAgY29uc3QgY3VycmVudEJsb2NrID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgIGNvbnN0IGZyb21CbG9jayA9IE1hdGgubWF4KDAsIGN1cnJlbnRCbG9jayAtIGJsb2Nrc1RvU2Nhbik7XHJcblxyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gW107XHJcbiAgICBjb25zdCBhZGRyZXNzTG93ZXIgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgLy8gVGhpcyB3b3VsZCBtYWtlIGJsb2Nrc1RvU2NhbiBSUEMgcmVxdWVzdHMhXHJcbiAgICBmb3IgKGxldCBpID0gY3VycmVudEJsb2NrOyBpID49IGZyb21CbG9jayAmJiB0cmFuc2FjdGlvbnMubGVuZ3RoIDwgbGltaXQ7IGktLSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2soaSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLnRyYW5zYWN0aW9ucykge1xyXG4gICAgICAgICAgZm9yIChjb25zdCB0eCBvZiBibG9jay50cmFuc2FjdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9ucy5sZW5ndGggPj0gbGltaXQpIGJyZWFrO1xyXG4gICAgICAgICAgICBpZiAodHguZnJvbT8udG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzc0xvd2VyIHx8IHR4LnRvPy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzTG93ZXIpIHtcclxuICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxyXG4gICAgICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcclxuICAgICAgICAgICAgICAgIHRvOiB0eC50byxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0eC52YWx1ZS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBibG9jay50aW1lc3RhbXAsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eC5mcm9tPy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzTG93ZXIgPyAnc2VudCcgOiAncmVjZWl2ZWQnXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGJsb2NrRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nIGJsb2NrICR7aX06YCwgYmxvY2tFcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cmFuc2FjdGlvbnM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJlY2VudCB0cmFuc2FjdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICAqL1xyXG59XHJcblxyXG4vKipcclxuICogRXN0aW1hdGVzIGdhcyBmb3IgYSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIG9iamVjdFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBFc3RpbWF0ZWQgZ2FzIChoZXggc3RyaW5nKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVzdGltYXRlR2FzKG5ldHdvcmssIHRyYW5zYWN0aW9uKSB7XHJcbiAgcmV0dXJuIGF3YWl0IHJwY0NhbGwobmV0d29yaywgJ2V0aF9lc3RpbWF0ZUdhcycsIFt0cmFuc2FjdGlvbl0pO1xyXG59XHJcblxyXG4vKipcclxuICogRXhlY3V0ZXMgYSBjYWxsIChyZWFkLW9ubHkgdHJhbnNhY3Rpb24pXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayBrZXlcclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IENhbGwgcmVzdWx0IChoZXggc3RyaW5nKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGwobmV0d29yaywgdHJhbnNhY3Rpb24pIHtcclxuICByZXR1cm4gYXdhaXQgcnBjQ2FsbChuZXR3b3JrLCAnZXRoX2NhbGwnLCBbdHJhbnNhY3Rpb24sICdsYXRlc3QnXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZW5kcyBhIHNpZ25lZCByYXcgdHJhbnNhY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIGtleVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lnbmVkVHggLSBTaWduZWQgdHJhbnNhY3Rpb24gKGhleCBzdHJpbmcpXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRyYW5zYWN0aW9uIGhhc2hcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kUmF3VHJhbnNhY3Rpb24obmV0d29yaywgc2lnbmVkVHgpIHtcclxuICByZXR1cm4gYXdhaXQgcnBjQ2FsbChuZXR3b3JrLCAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicsIFtzaWduZWRUeF0pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBhIHRyYW5zYWN0aW9uIHJlY2VpcHRcclxuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIGtleVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHhIYXNoIC0gVHJhbnNhY3Rpb24gaGFzaFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUcmFuc2FjdGlvbiByZWNlaXB0IG9iamVjdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uUmVjZWlwdChuZXR3b3JrLCB0eEhhc2gpIHtcclxuICByZXR1cm4gYXdhaXQgcnBjQ2FsbChuZXR3b3JrLCAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsIFt0eEhhc2hdKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgYSB0cmFuc2FjdGlvbiBieSBoYXNoXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd9IHR4SGFzaCAtIFRyYW5zYWN0aW9uIGhhc2hcclxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVHJhbnNhY3Rpb24gb2JqZWN0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25CeUhhc2gobmV0d29yaywgdHhIYXNoKSB7XHJcbiAgcmV0dXJuIGF3YWl0IHJwY0NhbGwobmV0d29yaywgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsIFt0eEhhc2hdKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdHMgYmFsYW5jZSBmcm9tIHdlaSB0byBodW1hbi1yZWFkYWJsZSBzdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IGJhbGFuY2VXZWkgLSBCYWxhbmNlIGluIHdlaSAoaGV4IHN0cmluZylcclxuICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzIC0gTnVtYmVyIG9mIGRlY2ltYWxzIHRvIHNob3cgKGRlZmF1bHQgNClcclxuICogQHJldHVybnMge3N0cmluZ30gRm9ybWF0dGVkIGJhbGFuY2UgKGUuZy4sIFwiMS4yMzQ1XCIpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QmFsYW5jZShiYWxhbmNlV2VpLCBkZWNpbWFscyA9IDQpIHtcclxuICBjb25zdCBiYWxhbmNlID0gZXRoZXJzLmZvcm1hdEV0aGVyKGJhbGFuY2VXZWkpO1xyXG4gIGNvbnN0IG51bSA9IHBhcnNlRmxvYXQoYmFsYW5jZSk7XHJcbiAgcmV0dXJuIG51bS50b0ZpeGVkKGRlY2ltYWxzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgaGVhbHRoIHN0YXR1cyBvZiBhbGwgUlBDIGVuZHBvaW50c1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFsdGggc3RhdHVzIHBlciBlbmRwb2ludFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFJQQ0hlYWx0aFN0YXR1cygpIHtcclxuICBjb25zdCBzdGF0dXMgPSB7fTtcclxuICBcclxuICBmb3IgKGNvbnN0IFtuZXR3b3JrLCBlbmRwb2ludHNdIG9mIE9iamVjdC5lbnRyaWVzKFJQQ19FTkRQT0lOVFMpKSB7XHJcbiAgICBzdGF0dXNbbmV0d29ya10gPSBbXTtcclxuICAgIGNvbnN0IGVuZHBvaW50c0xpc3QgPSBBcnJheS5pc0FycmF5KGVuZHBvaW50cykgPyBlbmRwb2ludHMgOiBbZW5kcG9pbnRzXTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBlbmRwb2ludCBvZiBlbmRwb2ludHNMaXN0KSB7XHJcbiAgICAgIGNvbnN0IGhlYWx0aCA9IGVuZHBvaW50SGVhbHRoLmdldChlbmRwb2ludCkgfHwgeyBmYWlsdXJlczogMCwgbGFzdENoZWNrOiBudWxsLCBibGFja2xpc3RlZDogZmFsc2UgfTtcclxuICAgICAgc3RhdHVzW25ldHdvcmtdLnB1c2goe1xyXG4gICAgICAgIGVuZHBvaW50LFxyXG4gICAgICAgIGZhaWx1cmVzOiBoZWFsdGguZmFpbHVyZXMsXHJcbiAgICAgICAgYmxhY2tsaXN0ZWQ6IGhlYWx0aC5ibGFja2xpc3RlZCxcclxuICAgICAgICBsYXN0Q2hlY2s6IGhlYWx0aC5sYXN0Q2hlY2tcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBzdGF0dXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhcnMgdGhlIHByb3ZpZGVyIGNhY2hlICh1c2VmdWwgZm9yIGZvcmNpbmcgcmVjb25uZWN0aW9uKVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsgdG8gY2xlYXIsIG9yIG51bGwgZm9yIGFsbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyUHJvdmlkZXJDYWNoZShuZXR3b3JrID0gbnVsbCkge1xyXG4gIGlmIChuZXR3b3JrKSB7XHJcbiAgICBkZWxldGUgcHJvdmlkZXJzW25ldHdvcmtdO1xyXG4gICAgY29uc29sZS5sb2coYPCfq4AgQ2xlYXJlZCBwcm92aWRlciBjYWNoZSBmb3I6ICR7bmV0d29ya31gKTtcclxuICB9IGVsc2Uge1xyXG4gICAgT2JqZWN0LmtleXMocHJvdmlkZXJzKS5mb3JFYWNoKGtleSA9PiBkZWxldGUgcHJvdmlkZXJzW2tleV0pO1xyXG4gICAgY29uc29sZS5sb2coYPCfq4AgQ2xlYXJlZCBhbGwgcHJvdmlkZXIgY2FjaGVzYCk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJfaGVhZGVycyIsIl9ib2R5IiwiX2RhdGEiLCJfb2Zmc2V0IiwiX2lmYWNlIiwiX3VybCIsIl9jaGFpbklkIiwiX3Byb3ZpZGVyIiwiX2ZpbHRlciIsIl9wb2xsZXIiLCJfcnVubmluZyIsIl9ibG9ja051bWJlciIsInBvbGxfZm4iLCJfcGx1Z2lucyIsIl9vcHRpb25zIiwiX25ldHdvcmsiLCJjb3B5IiwiYnl0ZXMiLCJCTl8wIiwiQk5fMSIsIl92YWx1ZSIsIm1hc2siLCJOaWJibGVzIiwib3V0cHV0IiwiX3NpZ25hbCIsImluaXQiLCJfZXJyb3IiLCJsb2NrZWQiLCJnZXRUaW1lIiwiX3JlcXVlc3QiLCJfYSIsInJlc3BvbnNlIiwiZGVsYXkiLCJzdGFsbCIsIl9ndWFyZCIsIlplcm9zIiwic2lnbmVkIiwiYiIsIl9mb3JtYXQiLCJvZmZzZXQiLCJvYmplY3QiLCJsZW5ndGgiLCJwYXJzZVVuaXRzIiwicmFuZG9tQnl0ZXMiLCJwYXNzUHJvcGVydGllcyIsIm5hbWVzIiwiYXJncyIsIl9uYW1lcyIsImdldFZhbHVlIiwibiIsImhhc2giLCJjcnlwdG8iLCJ1OGEiLCJ1dGY4VG9CeXRlcyIsImNvbmNhdEJ5dGVzIiwiYXNzZXJ0SGFzaCIsImFzc2VydEV4aXN0cyIsImFzc2VydEJ5dGVzIiwiYXNzZXJ0TnVtYmVyIiwicGJrZGYyIiwiaXNMRSIsIl8zMm4iLCJUMSIsIlQyIiwic2hhMjU2Iiwic3BsaXQiLCJzaGE1MTIiLCJfMG4iLCJfMW4iLCJfMm4iLCJyb3RsIiwicmlwZW1kMTYwIiwibm9ibGVfcmlwZW1kMTYwIiwiY3J5cHRvX3JhbmRvbSIsIk4iLCJzY3J5cHQiLCJQaSIsIl9ub2JsZUFzeW5jIiwiX25vYmxlU3luYyIsIkgiLCJnZW4iLCJfM24iLCJudW1iZXIiLCJTIiwiRnAiLCJuMiIsImYiLCJiaXRMZW4iLCJ3aW5kb3ciLCJ1dC52YWxpZGF0ZU9iamVjdCIsInMiLCJ0b0J5dGVzIiwidXQuY29uY2F0Qnl0ZXMiLCJ1dC5ieXRlc1RvSGV4IiwidXQuYnl0ZXNUb051bWJlckJFIiwibW9kLm1vZCIsIlUxIiwiVTIiLCJhIiwibW9kLmludmVydCIsInV0Lm51bWJlclRvQnl0ZXNCRSIsIlNpZ25hdHVyZSIsInV0LmhleFRvQnl0ZXMiLCJtb2QuZ2V0TWluSGFzaExlbmd0aCIsIm1vZC5tYXBIYXNoVG9GaWVsZCIsInV0LmJpdE1hc2siLCJ1dC5jcmVhdGVIbWFjRHJiZyIsIl9zaWciLCJyIiwiQk5fMiIsIkJOXzI3IiwiQk5fMjgiLCJCTl8zNSIsInYiLCJfciIsIl92IiwiY2hlY2tzdW0iLCJCTl9NQVhfVUlOVDI1NiIsInZlcnNpb24iLCJfYmxvYnMiLCJkZWNvZGUiLCJhZGQiLCJWIiwiZyIsImRlY29tcG9zZWQiLCJuYW1lIiwiX3R5cGVzIiwidHlwZSIsInZhbHVlIiwidGhyb3dFcnJvciIsImludGVybmFsIiwicmVzdWx0IiwiaW5kZXhlZCIsImlucHV0cyIsIlBhbmljUmVhc29ucyIsImJsb2NrTnVtYmVyIiwiX3RpbWVvdXQiLCJyZWNlaXB0IiwiZ2V0UHJvdmlkZXIiLCJlc3RpbWF0ZUdhcyIsImZyYWdtZW50IiwidCIsImxpc3RlbmVyIiwiYWRkciIsInRhcmdldCIsImNvZGUiLCJkYXRhIiwiZXJyb3IiLCJhbGxvd051bGwiLCJfZXZlbnQiLCJkZWZhdWx0T3B0aW9ucyIsImZyb21CbG9jayIsInRvQmxvY2siLCJhZGRyZXNzIiwiZmlsdGVyIiwidHgiLCJmcm9tIiwiX3RvIiwiaWQiLCJhY2NvdW50cyIsInBheWxvYWQiLCJ3b3JkcyIsIndvcmRsaXN0IiwiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJpIiwienBhZCIsImRlZmF1bHRQYXRoIiwic2FsdCIsImRrTGVuIiwia2V5Iiwid2FsbGV0IiwiZXRoZXJzLmlzQWRkcmVzcyIsImV0aGVycy5NbmVtb25pYyIsImV0aGVycy5XYWxsZXQiLCJldGhlcnMuSnNvblJwY1Byb3ZpZGVyIiwiZXRoZXJzLmZvcm1hdEV0aGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseVBBQUFBLFdBQUFDLFFBQUEsNExBQUFDLFFBQUEsK0pBQUFBLFFBQUEsaVNBQUFDLFVBQUEsaVFBQUFDLFNBQUEsNEhBQUFDLE9BQUEscUJBQUFDLFdBQUEsbUdBQUFDLFlBQUEsbUNBQUFDLFVBQUEsT0FBQUQsWUFBQUMsVUFBQUMsVUFBQUMsV0FBQUMsZUFBQSxtQ0FBQUMsVUFBQSxPQUFBQyxXQUFBLGdJQUFBQyxXQUFBLHNLQUFBUCxZQUFBLGtCQUFBRSxVQUFBQyxX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QUMsRUFBRSxHQUFHLElBQUksR0FBRyxHQUFFLElBQUssSUFBSSxJQUFJLEtBQUssR0FBRyxLQUFLLEdBQUcsTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUM1RCxXQUFLLEtBQUs7QUFDVixXQUFLLEtBQUs7QUFDVixXQUFLLEtBQUs7QUFDVixXQUFLLEtBQUs7QUFDVixXQUFLLEtBQUs7QUFDVixXQUFLLEtBQUs7QUFDVixZQUFNLE1BQU0sSUFBSSxNQUFNLEtBQUssU0FBUyxJQUFJO0FBQ3hDLFdBQUssSUFBSSxNQUFNLEtBQUssS0FBSyxTQUFTLElBQUk7QUFDdEMsV0FBSyxNQUFNO0FBQUEsSUFDZjtBQUVBLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFB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LElBQUksTUFBTSxJQUFJO0FBQ2pFLE1BQUksTUFBTSxLQUFLLElBQUksSUFBSSxNQUFNLElBQUksR0FBRyxNQUFNLEtBQUssSUFBSSxJQUFJLE1BQU0sSUFBSTtBQUNqRSxNQUFJLE1BQU0sS0FBSyxJQUFJLElBQUksTUFBTSxJQUFJLEdBQUcsTUFBTSxLQUFLLElBQUksSUFBSSxNQUFNLElBQUk7QUFFakUsTUFBSSxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNO0FBRS9LLFdBQVMsSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLLEdBQUc7QUFDM0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFBQSxFQUNqQztBQUVBLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUMxQixNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDMUIsTUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQzFCLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUMxQixNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDMUIsTUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQzFCLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUMxQixNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDMUIsTUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQzFCLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUMxQixNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDMUIsTUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQzFCLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUMxQixNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDMUIsTUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQzFCLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUM5QjtBQUNBLFNBQVMsU0FBUyxPQUFPLElBQUksS0FBSyxJQUFJLEdBQUc7QUFFckMsTUFBSSxPQUFPLEtBQUs7QUFDaEIsTUFBSSxPQUFPLEtBQUssS0FBSztBQUNyQixXQUFTLElBQUksR0FBRyxJQUFJLElBQUk7QUFDcEIsUUFBSSxPQUFPLENBQUMsSUFBSSxNQUFNLE1BQU0sSUFBSSxJQUFJLEtBQUssS0FBSyxDQUFDO0FBQ25ELFdBQVMsSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLLFFBQVEsSUFBSSxNQUFNLElBQUk7QUFFOUMsZ0JBQVksS0FBSyxNQUFNLE9BQU8sSUFBSSxLQUFLLElBQUk7QUFDM0MsUUFBSSxJQUFJO0FBQ0osY0FBUTtBQUNaLGdCQUFZLEtBQUssTUFBTSxPQUFRLE1BQU0sSUFBSyxLQUFLLElBQUk7QUFBQSxFQUN2RDtBQUNKO0FBRUEsU0FBUyxXQUFXLFVBQVUsTUFBTSxPQUFPO0FBRXZDLFFBQU0sT0FBTyxVQUFVO0FBQUEsSUFDbkIsT0FBTztBQUFBLElBQ1AsV0FBVztBQUFBLElBQ1gsUUFBUSxRQUFRLElBQUk7QUFBQSxFQUM1QixHQUFPLEtBQUs7QUFDUixRQUFNLEVBQUUsR0FBQXFDLElBQUcsR0FBRyxHQUFHLE9BQU8sV0FBVyxRQUFRLFdBQVUsSUFBSztBQUMxRGhCLFNBQWFnQixFQUFDO0FBQ2RoQixTQUFhLENBQUM7QUFDZEEsU0FBYSxDQUFDO0FBQ2RBLFNBQWEsS0FBSztBQUNsQkEsU0FBYSxTQUFTO0FBQ3RCQSxTQUFhLE1BQU07QUFDbkIsTUFBSSxlQUFlLFVBQWEsT0FBTyxlQUFlO0FBQ2xELFVBQU0sSUFBSSxNQUFNLCtCQUErQjtBQUNuRCxRQUFNLFlBQVksTUFBTTtBQUN4QixRQUFNLGNBQWMsWUFBWTtBQUNoQyxNQUFJZ0IsTUFBSyxNQUFNQSxLQUFLQSxLQUFJLE9BQVEsS0FBS0EsTUFBSyxNQUFNLFlBQVksTUFBTUEsS0FBSSxLQUFLLElBQUk7QUFHM0UsVUFBTSxJQUFJLE1BQU0sNkZBQTZGO0FBQUEsRUFDakg7QUFDQSxNQUFJLElBQUksS0FBSyxLQUFNLEtBQUssS0FBSyxLQUFLLEtBQU0sV0FBVztBQUMvQyxVQUFNLElBQUksTUFBTSwwRkFBMEY7QUFBQSxFQUM5RztBQUNBLE1BQUksUUFBUSxLQUFLLFNBQVMsS0FBSyxLQUFLLEtBQUssSUFBSTtBQUN6QyxVQUFNLElBQUksTUFBTSxnRkFBZ0Y7QUFBQSxFQUNwRztBQUNBLFFBQU0sVUFBVSxhQUFhQSxLQUFJO0FBQ2pDLE1BQUksVUFBVSxRQUFRO0FBQ2xCLFVBQU0sSUFBSSxNQUFNLGlDQUFpQyxPQUFPLDBCQUEwQixNQUFNLFdBQVc7QUFBQSxFQUN2RztBQUdBLFFBQU0sSUFBSWYsU0FBT0ssVUFBUSxVQUFVLE1BQU0sRUFBRSxHQUFHLEdBQUcsT0FBTyxZQUFZLEVBQUMsQ0FBRTtBQUN2RSxRQUFNLE1BQU0sSUFBSSxDQUFDO0FBRWpCLFFBQU0sSUFBSSxJQUFJLElBQUksV0FBVyxZQUFZVSxFQUFDLENBQUM7QUFDM0MsUUFBTSxNQUFNLElBQUksSUFBSSxXQUFXLFNBQVMsQ0FBQztBQUN6QyxNQUFJLGFBQWEsTUFBTTtBQUFBLEVBQUU7QUFDekIsTUFBSSxZQUFZO0FBQ1osVUFBTSxnQkFBZ0IsSUFBSUEsS0FBSTtBQUc5QixVQUFNLGNBQWMsS0FBSyxJQUFJLEtBQUssTUFBTSxnQkFBZ0IsR0FBSyxHQUFHLENBQUM7QUFDakUsUUFBSSxjQUFjO0FBQ2xCLGlCQUFhLE1BQU07QUFDZjtBQUNBLFVBQUksZUFBZSxFQUFFLGNBQWMsZ0JBQWdCLGdCQUFnQjtBQUMvRCxtQkFBVyxjQUFjLGFBQWE7QUFBQSxJQUM5QztBQUFBLEVBQ0o7QUFDQSxTQUFPLEVBQUUsR0FBQUEsSUFBRyxHQUFHLEdBQUcsT0FBTyxhQUFhLEdBQUcsS0FBSyxHQUFHLEtBQUssWUFBWSxVQUFTO0FBQy9FO0FBQ0EsU0FBUyxhQUFhLFVBQVUsT0FBTyxHQUFHLEdBQUcsS0FBSztBQUM5QyxRQUFNLE1BQU1mLFNBQU9LLFVBQVEsVUFBVSxHQUFHLEVBQUUsR0FBRyxHQUFHLE1BQUssQ0FBRTtBQUN2RCxJQUFFLEtBQUssQ0FBQztBQUNSLElBQUUsS0FBSyxDQUFDO0FBQ1IsTUFBSSxLQUFLLENBQUM7QUFDVixTQUFPO0FBQ1g7QUFlTyxTQUFTVyxTQUFPLFVBQVUsTUFBTSxNQUFNO0FBQ3pDLFFBQU0sRUFBRSxHQUFBRCxJQUFHLEdBQUcsR0FBRyxPQUFPLGFBQWEsR0FBRyxLQUFLLEdBQUcsS0FBSyxlQUFlLFdBQVcsVUFBVSxNQUFNLElBQUk7QUFDbkcsV0FBUyxLQUFLLEdBQUcsS0FBSyxHQUFHLE1BQU07QUFDM0IsVUFBTUUsTUFBSyxjQUFjO0FBQ3pCLGFBQVMsSUFBSSxHQUFHLElBQUksYUFBYTtBQUM3QixRQUFFLENBQUMsSUFBSSxJQUFJQSxNQUFLLENBQUM7QUFDckIsYUFBUyxJQUFJLEdBQUcsTUFBTSxHQUFHLElBQUlGLEtBQUksR0FBRyxLQUFLO0FBQ3JDLGVBQVMsR0FBRyxLQUFLLEdBQUksT0FBTyxhQUFjLENBQUM7QUFDM0M7SUFDSjtBQUNBLGFBQVMsSUFBSUEsS0FBSSxLQUFLLGFBQWEsS0FBS0UsS0FBSSxDQUFDO0FBQzdDO0FBQ0EsYUFBUyxJQUFJLEdBQUcsSUFBSUYsSUFBRyxLQUFLO0FBRXhCLFlBQU0sSUFBSSxJQUFJRSxNQUFLLGNBQWMsRUFBRSxJQUFJRjtBQUN2QyxlQUFTLElBQUksR0FBRyxJQUFJLGFBQWE7QUFDN0IsWUFBSSxDQUFDLElBQUksSUFBSUUsTUFBSyxDQUFDLElBQUksRUFBRSxJQUFJLGNBQWMsQ0FBQztBQUNoRCxlQUFTLEtBQUssR0FBRyxLQUFLQSxLQUFJLENBQUM7QUFDM0I7SUFDSjtBQUFBLEVBQ0o7QUFDQSxTQUFPLGFBQWEsVUFBVSxPQUFPLEdBQUcsR0FBRyxHQUFHO0FBQ2xEO0FBSU8sZUFBZSxZQUFZLFVBQVUsTUFBTSxNQUFNO0FBQ3BELFFBQU0sRUFBRSxHQUFBRixJQUFHLEdBQUcsR0FBRyxPQUFPLGFBQWEsR0FBRyxLQUFLLEdBQUcsS0FBSyxZQUFZLFVBQVMsSUFBSyxXQUFXLFVBQVUsTUFBTSxJQUFJO0FBQzlHLFdBQVMsS0FBSyxHQUFHLEtBQUssR0FBRyxNQUFNO0FBQzNCLFVBQU1FLE1BQUssY0FBYztBQUN6QixhQUFTLElBQUksR0FBRyxJQUFJLGFBQWE7QUFDN0IsUUFBRSxDQUFDLElBQUksSUFBSUEsTUFBSyxDQUFDO0FBQ3JCLFFBQUksTUFBTTtBQUNWLFVBQU0sVUFBVUYsS0FBSSxHQUFHLFdBQVcsTUFBTTtBQUNwQyxlQUFTLEdBQUcsS0FBSyxHQUFJLE9BQU8sYUFBYyxDQUFDO0FBQzNDO0lBQ0osQ0FBQztBQUNELGFBQVMsSUFBSUEsS0FBSSxLQUFLLGFBQWEsS0FBS0UsS0FBSSxDQUFDO0FBQzdDO0FBQ0EsVUFBTSxVQUFVRixJQUFHLFdBQVcsTUFBTTtBQUVoQyxZQUFNLElBQUksSUFBSUUsTUFBSyxjQUFjLEVBQUUsSUFBSUY7QUFDdkMsZUFBUyxJQUFJLEdBQUcsSUFBSSxhQUFhO0FBQzdCLFlBQUksQ0FBQyxJQUFJLElBQUlFLE1BQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxjQUFjLENBQUM7QUFDaEQsZUFBUyxLQUFLLEdBQUcsS0FBS0EsS0FBSSxDQUFDO0FBQzNCO0lBQ0osQ0FBQztBQUFBLEVBQ0w7QUFDQSxTQUFPLGFBQWEsVUFBVSxPQUFPLEdBQUcsR0FBRyxHQUFHO0FBQ2xEO0FDdE5BLElBQUksYUFBYSxPQUFPLGNBQWM7QUFDdEMsTUFBTSxlQUFlLGVBQWdCLFFBQVEsTUFBTUYsSUFBRyxHQUFHLEdBQUcsT0FBTyxZQUFZO0FBQzNFLFNBQU8sTUFBTUcsWUFBWSxRQUFRLE1BQU0sRUFBRSxHQUFBSCxJQUFHLEdBQUcsR0FBRyxPQUFPLFdBQVUsQ0FBRTtBQUN6RTtBQUNBLE1BQU0sY0FBYyxTQUFVLFFBQVEsTUFBTUEsSUFBRyxHQUFHLEdBQUcsT0FBTztBQUN4RCxTQUFPSSxTQUFXLFFBQVEsTUFBTSxFQUFFLEdBQUFKLElBQUcsR0FBRyxHQUFHLE1BQUssQ0FBRTtBQUN0RDtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksZUFBZTtBQXNDWixlQUFlLE9BQU8sU0FBUyxPQUFPQSxJQUFHLEdBQUcsR0FBRyxPQUFPLFVBQVU7QUFDbkUsUUFBTSxTQUFTLFNBQVMsU0FBUyxRQUFRO0FBQ3pDLFFBQU0sT0FBTyxTQUFTLE9BQU8sTUFBTTtBQUNuQyxTQUFPSyxRQUFFLE1BQU0sY0FBYyxRQUFRLE1BQU1MLElBQUcsR0FBRyxHQUFHLE9BQU8sUUFBUSxDQUFDO0FBQ3hFO0FBQ0EsT0FBTyxJQUFJO0FBQ1gsT0FBTyxPQUFPLFdBQVk7QUFBRSxnQkFBYztBQUFNO0FBQ2hELE9BQU8sV0FBVyxTQUFVLE1BQU07QUFDOUIsTUFBSSxhQUFhO0FBQ2IsVUFBTSxJQUFJLE1BQU0sa0JBQWtCO0FBQUEsRUFDdEM7QUFDQSxrQkFBZ0I7QUFDcEI7QUFDQSxPQUFPLE9BQU8sTUFBTTtBQXVCYixTQUFTLFdBQVcsU0FBUyxPQUFPQSxJQUFHLEdBQUcsR0FBRyxPQUFPO0FBQ3ZELFFBQU0sU0FBUyxTQUFTLFNBQVMsUUFBUTtBQUN6QyxRQUFNLE9BQU8sU0FBUyxPQUFPLE1BQU07QUFDbkMsU0FBT0ssUUFBRSxhQUFhLFFBQVEsTUFBTUwsSUFBRyxHQUFHLEdBQUcsS0FBSyxDQUFDO0FBQ3ZEO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxPQUFPLFdBQVk7QUFBRSxlQUFhO0FBQU07QUFDbkQsV0FBVyxXQUFXLFNBQVUsTUFBTTtBQUNsQyxNQUFJLFlBQVk7QUFDWixVQUFNLElBQUksTUFBTSxzQkFBc0I7QUFBQSxFQUMxQztBQUNBLGlCQUFlO0FBQ25CO0FBQ0EsT0FBTyxPQUFPLFVBQVU7QUMvRnhCLE1BQU0sVUFBVSxTQUFVLE1BQU07QUFDNUIsU0FBTyxXQUFXLFFBQVEsRUFBRSxPQUFPLElBQUksRUFBRTtBQUM3QztBQUNBLE1BQU0sVUFBVSxTQUFVLE1BQU07QUFDNUIsU0FBTyxXQUFXLFFBQVEsRUFBRSxPQUFPLElBQUksRUFBRTtBQUM3QztBQUNBLElBQUksV0FBVztBQUNmLElBQUksV0FBVztBQUNmLElBQUksWUFBWSxPQUFPLFlBQVk7QUFrQjVCLFNBQVMsT0FBT3hFLFFBQU87QUFDMUIsUUFBTSxPQUFPLFNBQVNBLFFBQU8sTUFBTTtBQUNuQyxTQUFPLFFBQVEsU0FBUyxJQUFJLENBQUM7QUFDakM7QUFDQSxPQUFPLElBQUk7QUFDWCxPQUFPLE9BQU8sV0FBWTtBQUFFLGNBQVk7QUFBTTtBQUM5QyxPQUFPLFdBQVcsU0FBVSxNQUFNO0FBQzlCLE1BQUksV0FBVztBQUNYLFVBQU0sSUFBSSxNQUFNLGtCQUFrQjtBQUFBLEVBQ3RDO0FBQ0EsYUFBVztBQUNmO0FBQ0EsT0FBTyxPQUFPLE1BQU07QUFpQmIsU0FBUyxPQUFPQSxRQUFPO0FBQzFCLFFBQU0sT0FBTyxTQUFTQSxRQUFPLE1BQU07QUFDbkMsU0FBTyxRQUFRLFNBQVMsSUFBSSxDQUFDO0FBQ2pDO0FBQ0EsT0FBTyxJQUFJO0FBQ1gsT0FBTyxPQUFPLFdBQVk7QUFBRSxjQUFZO0FBQU07QUFDOUMsT0FBTyxXQUFXLFNBQVUsTUFBTTtBQUM5QixNQUFJLFdBQVc7QUFDWCxVQUFNLElBQUksTUFBTSxrQkFBa0I7QUFBQSxFQUN0QztBQUNBLGFBQVc7QUFDZjtBQUNBLE9BQU8sT0FBTyxNQUFNO0FDckVwQjtBQUtBLE1BQU1pRSxRQUFNLE9BQU8sQ0FBQztBQUNwQixNQUFNQyxRQUFNLE9BQU8sQ0FBQztBQUNwQixNQUFNQyxRQUFNLE9BQU8sQ0FBQztBQUNwQixNQUFNLE1BQU0sQ0FBQyxNQUFNLGFBQWE7QUFDaEMsTUFBTSxRQUF3QixzQkFBTSxLQUFLLEVBQUUsUUFBUSxJQUFHLEdBQUksQ0FBQyxHQUFHLE1BQU0sRUFBRSxTQUFTLEVBQUUsRUFBRSxTQUFTLEdBQUcsR0FBRyxDQUFDO0FBSTVGLFNBQVMsV0FBV3BELFFBQU87QUFDOUIsTUFBSSxDQUFDLElBQUlBLE1BQUs7QUFDVixVQUFNLElBQUksTUFBTSxxQkFBcUI7QUFFekMsTUFBSSxNQUFNO0FBQ1YsV0FBUyxJQUFJLEdBQUcsSUFBSUEsT0FBTSxRQUFRLEtBQUs7QUFDbkMsV0FBTyxNQUFNQSxPQUFNLENBQUMsQ0FBQztBQUFBLEVBQ3pCO0FBQ0EsU0FBTztBQUNYO0FBQ08sU0FBUyxvQkFBb0IsS0FBSztBQUNyQyxRQUFNLE1BQU0sSUFBSSxTQUFTLEVBQUU7QUFDM0IsU0FBTyxJQUFJLFNBQVMsSUFBSSxJQUFJLEdBQUcsS0FBSztBQUN4QztBQUNPLFNBQVMsWUFBWSxLQUFLO0FBQzdCLE1BQUksT0FBTyxRQUFRO0FBQ2YsVUFBTSxJQUFJLE1BQU0sOEJBQThCLE9BQU8sR0FBRztBQUU1RCxTQUFPLE9BQU8sUUFBUSxLQUFLLE1BQU0sS0FBSyxHQUFHLEVBQUU7QUFDL0M7QUFJTyxTQUFTLFdBQVcsS0FBSztBQUM1QixNQUFJLE9BQU8sUUFBUTtBQUNmLFVBQU0sSUFBSSxNQUFNLDhCQUE4QixPQUFPLEdBQUc7QUFDNUQsUUFBTSxNQUFNLElBQUk7QUFDaEIsTUFBSSxNQUFNO0FBQ04sVUFBTSxJQUFJLE1BQU0sNERBQTRELEdBQUc7QUFDbkYsUUFBTSxRQUFRLElBQUksV0FBVyxNQUFNLENBQUM7QUFDcEMsV0FBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNuQyxVQUFNLElBQUksSUFBSTtBQUNkLFVBQU0sVUFBVSxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUM7QUFDbEMsVUFBTSxPQUFPLE9BQU8sU0FBUyxTQUFTLEVBQUU7QUFDeEMsUUFBSSxPQUFPLE1BQU0sSUFBSSxLQUFLLE9BQU87QUFDN0IsWUFBTSxJQUFJLE1BQU0sdUJBQXVCO0FBQzNDLFVBQU0sQ0FBQyxJQUFJO0FBQUEsRUFDZjtBQUNBLFNBQU87QUFDWDtBQUVPLFNBQVMsZ0JBQWdCQSxRQUFPO0FBQ25DLFNBQU8sWUFBWSxXQUFXQSxNQUFLLENBQUM7QUFDeEM7QUFDTyxTQUFTLGdCQUFnQkEsUUFBTztBQUNuQyxNQUFJLENBQUMsSUFBSUEsTUFBSztBQUNWLFVBQU0sSUFBSSxNQUFNLHFCQUFxQjtBQUN6QyxTQUFPLFlBQVksV0FBVyxXQUFXLEtBQUtBLE1BQUssRUFBRSxRQUFPLENBQUUsQ0FBQztBQUNuRTtBQUNPLFNBQVMsZ0JBQWdCZ0MsSUFBRyxLQUFLO0FBQ3BDLFNBQU8sV0FBV0EsR0FBRSxTQUFTLEVBQUUsRUFBRSxTQUFTLE1BQU0sR0FBRyxHQUFHLENBQUM7QUFDM0Q7QUFDTyxTQUFTLGdCQUFnQkEsSUFBRyxLQUFLO0FBQ3BDLFNBQU8sZ0JBQWdCQSxJQUFHLEdBQUcsRUFBRSxRQUFPO0FBQzFDO0FBRU8sU0FBUyxtQkFBbUJBLElBQUc7QUFDbEMsU0FBTyxXQUFXLG9CQUFvQkEsRUFBQyxDQUFDO0FBQzVDO0FBVU8sU0FBUyxZQUFZLE9BQU8sS0FBSyxnQkFBZ0I7QUFDcEQsTUFBSTtBQUNKLE1BQUksT0FBTyxRQUFRLFVBQVU7QUFDekIsUUFBSTtBQUNBLFlBQU0sV0FBVyxHQUFHO0FBQUEsSUFDeEIsU0FDTyxHQUFHO0FBQ04sWUFBTSxJQUFJLE1BQU0sR0FBRyxLQUFLLG1DQUFtQyxHQUFHLGFBQWEsQ0FBQyxFQUFFO0FBQUEsSUFDbEY7QUFBQSxFQUNKLFdBQ1MsSUFBSSxHQUFHLEdBQUc7QUFHZixVQUFNLFdBQVcsS0FBSyxHQUFHO0FBQUEsRUFDN0IsT0FDSztBQUNELFVBQU0sSUFBSSxNQUFNLEdBQUcsS0FBSyxtQ0FBbUM7QUFBQSxFQUMvRDtBQUNBLFFBQU0sTUFBTSxJQUFJO0FBQ2hCLE1BQUksT0FBTyxtQkFBbUIsWUFBWSxRQUFRO0FBQzlDLFVBQU0sSUFBSSxNQUFNLEdBQUcsS0FBSyxhQUFhLGNBQWMsZUFBZSxHQUFHLEVBQUU7QUFDM0UsU0FBTztBQUNYO0FBSU8sU0FBUyxlQUFlLFFBQVE7QUFDbkMsUUFBTSxJQUFJLElBQUksV0FBVyxPQUFPLE9BQU8sQ0FBQyxLQUFLLE1BQU0sTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQ3JFLE1BQUksTUFBTTtBQUNWLFNBQU8sUUFBUSxDQUFDLE1BQU07QUFDbEIsUUFBSSxDQUFDLElBQUksQ0FBQztBQUNOLFlBQU0sSUFBSSxNQUFNLHFCQUFxQjtBQUN6QyxNQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osV0FBTyxFQUFFO0FBQUEsRUFDYixDQUFDO0FBQ0QsU0FBTztBQUNYO0FBQ08sU0FBUyxXQUFXLElBQUksSUFBSTtBQUUvQixNQUFJLEdBQUcsV0FBVyxHQUFHO0FBQ2pCLFdBQU87QUFDWCxXQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsUUFBUTtBQUMzQixRQUFJLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQztBQUNkLGFBQU87QUFDZixTQUFPO0FBQ1g7QUFJTyxTQUFTLFlBQVksS0FBSztBQUM3QixNQUFJLE9BQU8sUUFBUTtBQUNmLFVBQU0sSUFBSSxNQUFNLG9DQUFvQyxPQUFPLEdBQUcsRUFBRTtBQUNwRSxTQUFPLElBQUksV0FBVyxJQUFJLFlBQVcsRUFBRyxPQUFPLEdBQUcsQ0FBQztBQUN2RDtBQU1PLFNBQVMsT0FBT0EsSUFBRztBQUN0QixNQUFJO0FBQ0osT0FBSyxNQUFNLEdBQUdBLEtBQUlrQixPQUFLbEIsT0FBTW1CLE9BQUssT0FBTztBQUNyQztBQUNKLFNBQU87QUFDWDtBQU1PLFNBQVMsT0FBT25CLElBQUcsS0FBSztBQUMzQixTQUFRQSxNQUFLLE9BQU8sR0FBRyxJQUFLbUI7QUFDaEM7QUFJTyxNQUFNLFNBQVMsQ0FBQ25CLElBQUcsS0FBSyxVQUFVO0FBQ3JDLFNBQU9BLE1BQU0sUUFBUW1CLFFBQU1ELFVBQVEsT0FBTyxHQUFHO0FBQ2pEO0FBS08sTUFBTSxVQUFVLENBQUNsQixRQUFPb0IsU0FBTyxPQUFPcEIsS0FBSSxDQUFDLEtBQUttQjtBQUV2RCxNQUFNLE1BQU0sQ0FBQyxTQUFTLElBQUksV0FBVyxJQUFJO0FBQ3pDLE1BQU0sT0FBTyxDQUFDLFFBQVEsV0FBVyxLQUFLLEdBQUc7QUFRbEMsU0FBUyxlQUFlLFNBQVMsVUFBVSxRQUFRO0FBQ3RELE1BQUksT0FBTyxZQUFZLFlBQVksVUFBVTtBQUN6QyxVQUFNLElBQUksTUFBTSwwQkFBMEI7QUFDOUMsTUFBSSxPQUFPLGFBQWEsWUFBWSxXQUFXO0FBQzNDLFVBQU0sSUFBSSxNQUFNLDJCQUEyQjtBQUMvQyxNQUFJLE9BQU8sV0FBVztBQUNsQixVQUFNLElBQUksTUFBTSwyQkFBMkI7QUFFL0MsTUFBSSxJQUFJLElBQUksT0FBTztBQUNuQixNQUFJLElBQUksSUFBSSxPQUFPO0FBQ25CLE1BQUksSUFBSTtBQUNSLFFBQU0sUUFBUSxNQUFNO0FBQ2hCLE1BQUUsS0FBSyxDQUFDO0FBQ1IsTUFBRSxLQUFLLENBQUM7QUFDUixRQUFJO0FBQUEsRUFDUjtBQUNBLFFBQU0sSUFBSSxJQUFJL0IsT0FBTSxPQUFPLEdBQUcsR0FBRyxHQUFHQSxFQUFDO0FBQ3JDLFFBQU0sU0FBUyxDQUFDLE9BQU8sVUFBVTtBQUU3QixRQUFJLEVBQUUsS0FBSyxDQUFDLENBQUksQ0FBQyxHQUFHLElBQUk7QUFDeEIsUUFBSSxFQUFDO0FBQ0wsUUFBSSxLQUFLLFdBQVc7QUFDaEI7QUFDSixRQUFJLEVBQUUsS0FBSyxDQUFDLENBQUksQ0FBQyxHQUFHLElBQUk7QUFDeEIsUUFBSSxFQUFDO0FBQUEsRUFDVDtBQUNBLFFBQU0yQyxPQUFNLE1BQU07QUFFZCxRQUFJLE9BQU87QUFDUCxZQUFNLElBQUksTUFBTSx5QkFBeUI7QUFDN0MsUUFBSSxNQUFNO0FBQ1YsVUFBTSxNQUFNLENBQUE7QUFDWixXQUFPLE1BQU0sVUFBVTtBQUNuQixVQUFJLEVBQUM7QUFDTCxZQUFNLEtBQUssRUFBRTtBQUNiLFVBQUksS0FBSyxFQUFFO0FBQ1gsYUFBTyxFQUFFO0FBQUEsSUFDYjtBQUNBLFdBQU8sWUFBWSxHQUFHLEdBQUc7QUFBQSxFQUM3QjtBQUNBLFFBQU0sV0FBVyxDQUFDLE1BQU0sU0FBUztBQUM3QjtBQUNBLFdBQU8sSUFBSTtBQUNYLFFBQUksTUFBTTtBQUNWLFdBQU8sRUFBRSxNQUFNLEtBQUtBLEtBQUcsQ0FBRTtBQUNyQjtBQUNKO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFDQSxTQUFPO0FBQ1g7QUFFQSxNQUFNLGVBQWU7QUFBQSxFQUNqQixRQUFRLENBQUMsUUFBUSxPQUFPLFFBQVE7QUFBQSxFQUNoQyxVQUFVLENBQUMsUUFBUSxPQUFPLFFBQVE7QUFBQSxFQUNsQyxTQUFTLENBQUMsUUFBUSxPQUFPLFFBQVE7QUFBQSxFQUNqQyxRQUFRLENBQUMsUUFBUSxPQUFPLFFBQVE7QUFBQSxFQUNoQyxvQkFBb0IsQ0FBQyxRQUFRLE9BQU8sUUFBUSxZQUFZLGVBQWU7QUFBQSxFQUN2RSxlQUFlLENBQUMsUUFBUSxPQUFPLGNBQWMsR0FBRztBQUFBLEVBQ2hELE9BQU8sQ0FBQyxRQUFRLE1BQU0sUUFBUSxHQUFHO0FBQUEsRUFDakMsT0FBTyxDQUFDLEtBQUt4QyxZQUFXQSxRQUFPLEdBQUcsUUFBUSxHQUFHO0FBQUEsRUFDN0MsTUFBTSxDQUFDLFFBQVEsT0FBTyxRQUFRLGNBQWMsT0FBTyxjQUFjLElBQUksU0FBUztBQUNsRjtBQUVPLFNBQVMsZUFBZUEsU0FBUSxZQUFZLGdCQUFnQixDQUFBLEdBQUk7QUFDbkUsUUFBTSxhQUFhLENBQUMsV0FBVyxNQUFNLGVBQWU7QUFDaEQsVUFBTSxXQUFXLGFBQWEsSUFBSTtBQUNsQyxRQUFJLE9BQU8sYUFBYTtBQUNwQixZQUFNLElBQUksTUFBTSxzQkFBc0IsSUFBSSxzQkFBc0I7QUFDcEUsVUFBTSxNQUFNQSxRQUFPLFNBQVM7QUFDNUIsUUFBSSxjQUFjLFFBQVE7QUFDdEI7QUFDSixRQUFJLENBQUMsU0FBUyxLQUFLQSxPQUFNLEdBQUc7QUFDeEIsWUFBTSxJQUFJLE1BQU0saUJBQWlCLE9BQU8sU0FBUyxDQUFDLElBQUksR0FBRyxLQUFLLE9BQU8sR0FBRyxlQUFlLElBQUksRUFBRTtBQUFBLElBQ2pHO0FBQUEsRUFDSjtBQUNBLGFBQVcsQ0FBQyxXQUFXLElBQUksS0FBSyxPQUFPLFFBQVEsVUFBVTtBQUNyRCxlQUFXLFdBQVcsTUFBTSxLQUFLO0FBQ3JDLGFBQVcsQ0FBQyxXQUFXLElBQUksS0FBSyxPQUFPLFFBQVEsYUFBYTtBQUN4RCxlQUFXLFdBQVcsTUFBTSxJQUFJO0FBQ3BDLFNBQU9BO0FBQ1g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaFFBO0FBSUEsTUFBTTJCLFFBQU0sT0FBTyxDQUFDLEdBQUdDLFFBQU0sT0FBTyxDQUFDLEdBQUdDLFFBQU0sT0FBTyxDQUFDLEdBQUdZLFFBQU0sT0FBTyxDQUFDO0FBRXZFLE1BQU0sTUFBTSxPQUFPLENBQUMsR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDO0FBRTFDLE9BQU8sQ0FBQztBQUFVLE9BQU8sRUFBRTtBQUVoQyxTQUFTLElBQUksR0FBRzVDLElBQUc7QUFDdEIsUUFBTSxTQUFTLElBQUlBO0FBQ25CLFNBQU8sVUFBVThCLFFBQU0sU0FBUzlCLEtBQUk7QUFDeEM7QUFRTyxTQUFTLElBQUksS0FBSyxPQUFPLFFBQVE7QUFDcEMsTUFBSSxVQUFVOEIsU0FBTyxRQUFRQTtBQUN6QixVQUFNLElBQUksTUFBTSwyQkFBMkI7QUFDL0MsTUFBSSxXQUFXQztBQUNYLFdBQU9EO0FBQ1gsTUFBSSxNQUFNQztBQUNWLFNBQU8sUUFBUUQsT0FBSztBQUNoQixRQUFJLFFBQVFDO0FBQ1IsWUFBTyxNQUFNLE1BQU87QUFDeEIsVUFBTyxNQUFNLE1BQU87QUFDcEIsY0FBVUE7QUFBQUEsRUFDZDtBQUNBLFNBQU87QUFDWDtBQUVPLFNBQVMsS0FBSyxHQUFHLE9BQU8sUUFBUTtBQUNuQyxNQUFJLE1BQU07QUFDVixTQUFPLFVBQVVELE9BQUs7QUFDbEIsV0FBTztBQUNQLFdBQU87QUFBQSxFQUNYO0FBQ0EsU0FBTztBQUNYO0FBRU8sU0FBUyxPQUFPZSxTQUFRLFFBQVE7QUFDbkMsTUFBSUEsWUFBV2YsU0FBTyxVQUFVQSxPQUFLO0FBQ2pDLFVBQU0sSUFBSSxNQUFNLDZDQUE2Q2UsT0FBTSxRQUFRLE1BQU0sRUFBRTtBQUFBLEVBQ3ZGO0FBR0EsTUFBSSxJQUFJLElBQUlBLFNBQVEsTUFBTTtBQUMxQixNQUFJN0MsS0FBSTtBQUVMLE1BQUMsSUFBSThCLE9BQWMsSUFBSUM7QUFDMUIsU0FBTyxNQUFNRCxPQUFLO0FBRWQsVUFBTSxJQUFJOUIsS0FBSTtBQUNkLFVBQU0sSUFBSUEsS0FBSTtBQUNkLFVBQU0sSUFBSSxJQUFJLElBQUk7QUFHbEIsSUFBQUEsS0FBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQVUsSUFBSTtBQUFBLEVBQ3BDO0FBQ0EsUUFBTSxNQUFNQTtBQUNaLE1BQUksUUFBUStCO0FBQ1IsVUFBTSxJQUFJLE1BQU0sd0JBQXdCO0FBQzVDLFNBQU8sSUFBSSxHQUFHLE1BQU07QUFDeEI7QUFTTyxTQUFTLGNBQWMsR0FBRztBQU03QixRQUFNLGFBQWEsSUFBSUEsU0FBT0M7QUFDOUIsTUFBSSxHQUFHYyxJQUFHO0FBR1YsT0FBSyxJQUFJLElBQUlmLE9BQUtlLEtBQUksR0FBRyxJQUFJZCxVQUFRRixPQUFLLEtBQUtFLE9BQUtjO0FBQ2hEO0FBRUosT0FBSyxJQUFJZCxPQUFLLElBQUksS0FBSyxJQUFJLEdBQUcsV0FBVyxDQUFDLE1BQU0sSUFBSUQsT0FBSztBQUNyRDtBQUVKLE1BQUllLE9BQU0sR0FBRztBQUNULFVBQU0sVUFBVSxJQUFJZixTQUFPO0FBQzNCLFdBQU8sU0FBUyxZQUFZZ0IsS0FBSW5DLElBQUc7QUFDL0IsWUFBTSxPQUFPbUMsSUFBRyxJQUFJbkMsSUFBRyxNQUFNO0FBQzdCLFVBQUksQ0FBQ21DLElBQUcsSUFBSUEsSUFBRyxJQUFJLElBQUksR0FBR25DLEVBQUM7QUFDdkIsY0FBTSxJQUFJLE1BQU0seUJBQXlCO0FBQzdDLGFBQU87QUFBQSxJQUNYO0FBQUEsRUFDSjtBQUVBLFFBQU0sVUFBVSxJQUFJbUIsU0FBT0M7QUFDM0IsU0FBTyxTQUFTLFlBQVllLEtBQUluQyxJQUFHO0FBRS9CLFFBQUltQyxJQUFHLElBQUluQyxJQUFHLFNBQVMsTUFBTW1DLElBQUcsSUFBSUEsSUFBRyxHQUFHO0FBQ3RDLFlBQU0sSUFBSSxNQUFNLHlCQUF5QjtBQUM3QyxRQUFJLElBQUlEO0FBRVIsUUFBSSxJQUFJQyxJQUFHLElBQUlBLElBQUcsSUFBSUEsSUFBRyxLQUFLLENBQUMsR0FBRyxDQUFDO0FBQ25DLFFBQUksSUFBSUEsSUFBRyxJQUFJbkMsSUFBRyxNQUFNO0FBQ3hCLFFBQUlaLEtBQUkrQyxJQUFHLElBQUluQyxJQUFHLENBQUM7QUFDbkIsV0FBTyxDQUFDbUMsSUFBRyxJQUFJL0MsSUFBRytDLElBQUcsR0FBRyxHQUFHO0FBQ3ZCLFVBQUlBLElBQUcsSUFBSS9DLElBQUcrQyxJQUFHLElBQUk7QUFDakIsZUFBT0EsSUFBRztBQUVkLFVBQUksSUFBSTtBQUNSLGVBQVMsS0FBS0EsSUFBRyxJQUFJL0MsRUFBQyxHQUFHLElBQUksR0FBRyxLQUFLO0FBQ2pDLFlBQUkrQyxJQUFHLElBQUksSUFBSUEsSUFBRyxHQUFHO0FBQ2pCO0FBQ0osYUFBS0EsSUFBRyxJQUFJLEVBQUU7QUFBQSxNQUNsQjtBQUVBLFlBQU0sS0FBS0EsSUFBRyxJQUFJLEdBQUdoQixTQUFPLE9BQU8sSUFBSSxJQUFJLENBQUMsQ0FBQztBQUM3QyxVQUFJZ0IsSUFBRyxJQUFJLEVBQUU7QUFDYixVQUFJQSxJQUFHLElBQUksR0FBRyxFQUFFO0FBQ2hCLE1BQUEvQyxLQUFJK0MsSUFBRyxJQUFJL0MsSUFBRyxDQUFDO0FBQ2YsVUFBSTtBQUFBLElBQ1I7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUNKO0FBQ08sU0FBUyxPQUFPLEdBQUc7QUFLdEIsTUFBSSxJQUFJLFFBQVE0QyxPQUFLO0FBS2pCLFVBQU0sVUFBVSxJQUFJYixTQUFPO0FBQzNCLFdBQU8sU0FBUyxVQUFVZ0IsS0FBSW5DLElBQUc7QUFDN0IsWUFBTSxPQUFPbUMsSUFBRyxJQUFJbkMsSUFBRyxNQUFNO0FBRTdCLFVBQUksQ0FBQ21DLElBQUcsSUFBSUEsSUFBRyxJQUFJLElBQUksR0FBR25DLEVBQUM7QUFDdkIsY0FBTSxJQUFJLE1BQU0seUJBQXlCO0FBQzdDLGFBQU87QUFBQSxJQUNYO0FBQUEsRUFDSjtBQUVBLE1BQUksSUFBSSxRQUFRLEtBQUs7QUFDakIsVUFBTSxNQUFNLElBQUksT0FBTztBQUN2QixXQUFPLFNBQVMsVUFBVW1DLEtBQUluQyxJQUFHO0FBQzdCLFlBQU1vQyxNQUFLRCxJQUFHLElBQUluQyxJQUFHb0IsS0FBRztBQUN4QixZQUFNLElBQUllLElBQUcsSUFBSUMsS0FBSSxFQUFFO0FBQ3ZCLFlBQU0sS0FBS0QsSUFBRyxJQUFJbkMsSUFBRyxDQUFDO0FBQ3RCLFlBQU0sSUFBSW1DLElBQUcsSUFBSUEsSUFBRyxJQUFJLElBQUlmLEtBQUcsR0FBRyxDQUFDO0FBQ25DLFlBQU0sT0FBT2UsSUFBRyxJQUFJLElBQUlBLElBQUcsSUFBSSxHQUFHQSxJQUFHLEdBQUcsQ0FBQztBQUN6QyxVQUFJLENBQUNBLElBQUcsSUFBSUEsSUFBRyxJQUFJLElBQUksR0FBR25DLEVBQUM7QUFDdkIsY0FBTSxJQUFJLE1BQU0seUJBQXlCO0FBQzdDLGFBQU87QUFBQSxJQUNYO0FBQUEsRUFDSjtBQXdCQSxTQUFPLGNBQWMsQ0FBQztBQUMxQjtBQUlBLE1BQU0sZUFBZTtBQUFBLEVBQ2pCO0FBQUEsRUFBVTtBQUFBLEVBQVc7QUFBQSxFQUFPO0FBQUEsRUFBTztBQUFBLEVBQU87QUFBQSxFQUFRO0FBQUEsRUFDbEQ7QUFBQSxFQUFPO0FBQUEsRUFBTztBQUFBLEVBQU87QUFBQSxFQUFPO0FBQUEsRUFBTztBQUFBLEVBQ25DO0FBQUEsRUFBUTtBQUFBLEVBQVE7QUFBQSxFQUFRO0FBQzVCO0FBQ08sU0FBUyxjQUFjLE9BQU87QUFDakMsUUFBTSxVQUFVO0FBQUEsSUFDWixPQUFPO0FBQUEsSUFDUCxNQUFNO0FBQUEsSUFDTixPQUFPO0FBQUEsSUFDUCxNQUFNO0FBQUEsRUFDZDtBQUNJLFFBQU0sT0FBTyxhQUFhLE9BQU8sQ0FBQyxLQUFLLFFBQVE7QUFDM0MsUUFBSSxHQUFHLElBQUk7QUFDWCxXQUFPO0FBQUEsRUFDWCxHQUFHLE9BQU87QUFDVixTQUFPLGVBQWUsT0FBTyxJQUFJO0FBQ3JDO0FBTU8sU0FBUyxNQUFNcUMsSUFBRyxLQUFLLE9BQU87QUFHakMsTUFBSSxRQUFRbkI7QUFDUixVQUFNLElBQUksTUFBTSxvQkFBb0I7QUFDeEMsTUFBSSxVQUFVQTtBQUNWLFdBQU9tQixHQUFFO0FBQ2IsTUFBSSxVQUFVbEI7QUFDVixXQUFPO0FBQ1gsTUFBSSxJQUFJa0IsR0FBRTtBQUNWLE1BQUksSUFBSTtBQUNSLFNBQU8sUUFBUW5CLE9BQUs7QUFDaEIsUUFBSSxRQUFRQztBQUNSLFVBQUlrQixHQUFFLElBQUksR0FBRyxDQUFDO0FBQ2xCLFFBQUlBLEdBQUUsSUFBSSxDQUFDO0FBQ1gsY0FBVWxCO0FBQUFBLEVBQ2Q7QUFDQSxTQUFPO0FBQ1g7QUFLTyxTQUFTLGNBQWNrQixJQUFHLE1BQU07QUFDbkMsUUFBTSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU07QUFFakMsUUFBTSxpQkFBaUIsS0FBSyxPQUFPLENBQUMsS0FBSyxLQUFLLE1BQU07QUFDaEQsUUFBSUEsR0FBRSxJQUFJLEdBQUc7QUFDVCxhQUFPO0FBQ1gsUUFBSSxDQUFDLElBQUk7QUFDVCxXQUFPQSxHQUFFLElBQUksS0FBSyxHQUFHO0FBQUEsRUFDekIsR0FBR0EsR0FBRSxHQUFHO0FBRVIsUUFBTSxXQUFXQSxHQUFFLElBQUksY0FBYztBQUVyQyxPQUFLLFlBQVksQ0FBQyxLQUFLLEtBQUssTUFBTTtBQUM5QixRQUFJQSxHQUFFLElBQUksR0FBRztBQUNULGFBQU87QUFDWCxRQUFJLENBQUMsSUFBSUEsR0FBRSxJQUFJLEtBQUssSUFBSSxDQUFDLENBQUM7QUFDMUIsV0FBT0EsR0FBRSxJQUFJLEtBQUssR0FBRztBQUFBLEVBQ3pCLEdBQUcsUUFBUTtBQUNYLFNBQU87QUFDWDtBQWFPLFNBQVMsUUFBUXJDLElBQUcsWUFBWTtBQUVuQyxRQUFNLGNBQWMsZUFBZSxTQUFZLGFBQWFBLEdBQUUsU0FBUyxDQUFDLEVBQUU7QUFDMUUsUUFBTSxjQUFjLEtBQUssS0FBSyxjQUFjLENBQUM7QUFDN0MsU0FBTyxFQUFFLFlBQVksYUFBYTtBQUN0QztBQWFPLFNBQVMsTUFBTSxPQUFPc0MsU0FBUTNCLFFBQU8sT0FBTyxRQUFRLElBQUk7QUFDM0QsTUFBSSxTQUFTTztBQUNULFVBQU0sSUFBSSxNQUFNLGlDQUFpQyxLQUFLLEVBQUU7QUFDNUQsUUFBTSxFQUFFLFlBQVksTUFBTSxhQUFhLE1BQUssSUFBSyxRQUFRLE9BQU9vQixPQUFNO0FBQ3RFLE1BQUksUUFBUTtBQUNSLFVBQU0sSUFBSSxNQUFNLGlEQUFpRDtBQUNyRSxRQUFNLFFBQVEsT0FBTyxLQUFLO0FBQzFCLFFBQU1ELEtBQUksT0FBTyxPQUFPO0FBQUEsSUFDcEI7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0EsTUFBTSxRQUFRLElBQUk7QUFBQSxJQUNsQixNQUFNbkI7QUFBQUEsSUFDTixLQUFLQztBQUFBQSxJQUNMLFFBQVEsQ0FBQyxRQUFRLElBQUksS0FBSyxLQUFLO0FBQUEsSUFDL0IsU0FBUyxDQUFDLFFBQVE7QUFDZCxVQUFJLE9BQU8sUUFBUTtBQUNmLGNBQU0sSUFBSSxNQUFNLCtDQUErQyxPQUFPLEdBQUcsRUFBRTtBQUMvRSxhQUFPRCxTQUFPLE9BQU8sTUFBTTtBQUFBLElBQy9CO0FBQUEsSUFDQSxLQUFLLENBQUMsUUFBUSxRQUFRQTtBQUFBQSxJQUN0QixPQUFPLENBQUMsU0FBUyxNQUFNQyxXQUFTQTtBQUFBQSxJQUNoQyxLQUFLLENBQUMsUUFBUSxJQUFJLENBQUMsS0FBSyxLQUFLO0FBQUEsSUFDN0IsS0FBSyxDQUFDLEtBQUssUUFBUSxRQUFRO0FBQUEsSUFDM0IsS0FBSyxDQUFDLFFBQVEsSUFBSSxNQUFNLEtBQUssS0FBSztBQUFBLElBQ2xDLEtBQUssQ0FBQyxLQUFLLFFBQVEsSUFBSSxNQUFNLEtBQUssS0FBSztBQUFBLElBQ3ZDLEtBQUssQ0FBQyxLQUFLLFFBQVEsSUFBSSxNQUFNLEtBQUssS0FBSztBQUFBLElBQ3ZDLEtBQUssQ0FBQyxLQUFLLFFBQVEsSUFBSSxNQUFNLEtBQUssS0FBSztBQUFBLElBQ3ZDLEtBQUssQ0FBQyxLQUFLLFVBQVUsTUFBTWtCLElBQUcsS0FBSyxLQUFLO0FBQUEsSUFDeEMsS0FBSyxDQUFDLEtBQUssUUFBUSxJQUFJLE1BQU0sT0FBTyxLQUFLLEtBQUssR0FBRyxLQUFLO0FBQUE7QUFBQSxJQUV0RCxNQUFNLENBQUMsUUFBUSxNQUFNO0FBQUEsSUFDckIsTUFBTSxDQUFDLEtBQUssUUFBUSxNQUFNO0FBQUEsSUFDMUIsTUFBTSxDQUFDLEtBQUssUUFBUSxNQUFNO0FBQUEsSUFDMUIsTUFBTSxDQUFDLEtBQUssUUFBUSxNQUFNO0FBQUEsSUFDMUIsS0FBSyxDQUFDLFFBQVEsT0FBTyxLQUFLLEtBQUs7QUFBQSxJQUMvQixNQUFNLE1BQU0sU0FBUyxDQUFDckMsT0FBTSxNQUFNcUMsSUFBR3JDLEVBQUM7QUFBQSxJQUN0QyxhQUFhLENBQUMsUUFBUSxjQUFjcUMsSUFBRyxHQUFHO0FBQUE7QUFBQTtBQUFBLElBRzFDLE1BQU0sQ0FBQyxHQUFHakQsSUFBRyxNQUFPLElBQUlBLEtBQUk7QUFBQSxJQUM1QixTQUFTLENBQUMsUUFBU3VCLFFBQU8sZ0JBQWdCLEtBQUssS0FBSyxJQUFJLGdCQUFnQixLQUFLLEtBQUs7QUFBQSxJQUNsRixXQUFXLENBQUMzQyxXQUFVO0FBQ2xCLFVBQUlBLE9BQU0sV0FBVztBQUNqQixjQUFNLElBQUksTUFBTSwwQkFBMEIsS0FBSyxTQUFTQSxPQUFNLE1BQU0sRUFBRTtBQUMxRSxhQUFPMkMsUUFBTyxnQkFBZ0IzQyxNQUFLLElBQUksZ0JBQWdCQSxNQUFLO0FBQUEsSUFDaEU7QUFBQSxFQUNSLENBQUs7QUFDRCxTQUFPLE9BQU8sT0FBT3FFLEVBQUM7QUFDMUI7QUFrQ08sU0FBUyxvQkFBb0IsWUFBWTtBQUM1QyxNQUFJLE9BQU8sZUFBZTtBQUN0QixVQUFNLElBQUksTUFBTSw0QkFBNEI7QUFDaEQsUUFBTSxZQUFZLFdBQVcsU0FBUyxDQUFDLEVBQUU7QUFDekMsU0FBTyxLQUFLLEtBQUssWUFBWSxDQUFDO0FBQ2xDO0FBUU8sU0FBUyxpQkFBaUIsWUFBWTtBQUN6QyxRQUFNLFNBQVMsb0JBQW9CLFVBQVU7QUFDN0MsU0FBTyxTQUFTLEtBQUssS0FBSyxTQUFTLENBQUM7QUFDeEM7QUFjTyxTQUFTLGVBQWUsS0FBSyxZQUFZMUIsUUFBTyxPQUFPO0FBQzFELFFBQU0sTUFBTSxJQUFJO0FBQ2hCLFFBQU0sV0FBVyxvQkFBb0IsVUFBVTtBQUMvQyxRQUFNLFNBQVMsaUJBQWlCLFVBQVU7QUFFMUMsTUFBSSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU07QUFDbEMsVUFBTSxJQUFJLE1BQU0sWUFBWSxNQUFNLDZCQUE2QixHQUFHLEVBQUU7QUFDeEUsUUFBTSxNQUFNQSxRQUFPLGdCQUFnQixHQUFHLElBQUksZ0JBQWdCLEdBQUc7QUFFN0QsUUFBTSxVQUFVLElBQUksS0FBSyxhQUFhUSxLQUFHLElBQUlBO0FBQzdDLFNBQU9SLFFBQU8sZ0JBQWdCLFNBQVMsUUFBUSxJQUFJLGdCQUFnQixTQUFTLFFBQVE7QUFDeEY7QUM5WkE7QUFJQSxNQUFNTyxRQUFNLE9BQU8sQ0FBQztBQUNwQixNQUFNQyxRQUFNLE9BQU8sQ0FBQztBQVliLFNBQVMsS0FBSyxHQUFHLE1BQU07QUFDMUIsUUFBTSxrQkFBa0IsQ0FBQyxXQUFXLFNBQVM7QUFDekMsVUFBTSxNQUFNLEtBQUs7QUFDakIsV0FBTyxZQUFZLE1BQU07QUFBQSxFQUM3QjtBQUNBLFFBQU0sT0FBTyxDQUFDLE1BQU07QUFDaEIsVUFBTSxVQUFVLEtBQUssS0FBSyxPQUFPLENBQUMsSUFBSTtBQUN0QyxVQUFNLGFBQWEsTUFBTSxJQUFJO0FBQzdCLFdBQU8sRUFBRSxTQUFTO0VBQ3RCO0FBQ0EsU0FBTztBQUFBLElBQ0g7QUFBQTtBQUFBLElBRUEsYUFBYSxLQUFLbkIsSUFBRztBQUNqQixVQUFJLElBQUksRUFBRTtBQUNWLFVBQUksSUFBSTtBQUNSLGFBQU9BLEtBQUlrQixPQUFLO0FBQ1osWUFBSWxCLEtBQUltQjtBQUNKLGNBQUksRUFBRSxJQUFJLENBQUM7QUFDZixZQUFJLEVBQUU7QUFDTixRQUFBbkIsT0FBTW1CO0FBQUFBLE1BQ1Y7QUFDQSxhQUFPO0FBQUEsSUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFXQSxpQkFBaUIsS0FBSyxHQUFHO0FBQ3JCLFlBQU0sRUFBRSxTQUFTLFdBQVUsSUFBSyxLQUFLLENBQUM7QUFDdEMsWUFBTSxTQUFTLENBQUE7QUFDZixVQUFJLElBQUk7QUFDUixVQUFJLE9BQU87QUFDWCxlQUFTb0IsVUFBUyxHQUFHQSxVQUFTLFNBQVNBLFdBQVU7QUFDN0MsZUFBTztBQUNQLGVBQU8sS0FBSyxJQUFJO0FBRWhCLGlCQUFTLElBQUksR0FBRyxJQUFJLFlBQVksS0FBSztBQUNqQyxpQkFBTyxLQUFLLElBQUksQ0FBQztBQUNqQixpQkFBTyxLQUFLLElBQUk7QUFBQSxRQUNwQjtBQUNBLFlBQUksS0FBSztNQUNiO0FBQ0EsYUFBTztBQUFBLElBQ1g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBUUEsS0FBSyxHQUFHLGFBQWF2QyxJQUFHO0FBR3BCLFlBQU0sRUFBRSxTQUFTLFdBQVUsSUFBSyxLQUFLLENBQUM7QUFDdEMsVUFBSSxJQUFJLEVBQUU7QUFDVixVQUFJcUMsS0FBSSxFQUFFO0FBQ1YsWUFBTWpFLFFBQU8sT0FBTyxLQUFLLElBQUksQ0FBQztBQUM5QixZQUFNLFlBQVksS0FBSztBQUN2QixZQUFNLFVBQVUsT0FBTyxDQUFDO0FBQ3hCLGVBQVNtRSxVQUFTLEdBQUdBLFVBQVMsU0FBU0EsV0FBVTtBQUM3QyxjQUFNLFNBQVNBLFVBQVM7QUFFeEIsWUFBSSxRQUFRLE9BQU92QyxLQUFJNUIsS0FBSTtBQUUzQixRQUFBNEIsT0FBTTtBQUdOLFlBQUksUUFBUSxZQUFZO0FBQ3BCLG1CQUFTO0FBQ1QsVUFBQUEsTUFBS21CO0FBQUFBLFFBQ1Q7QUFRQSxjQUFNLFVBQVU7QUFDaEIsY0FBTSxVQUFVLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSTtBQUMzQyxjQUFNLFFBQVFvQixVQUFTLE1BQU07QUFDN0IsY0FBTSxRQUFRLFFBQVE7QUFDdEIsWUFBSSxVQUFVLEdBQUc7QUFFYixVQUFBRixLQUFJQSxHQUFFLElBQUksZ0JBQWdCLE9BQU8sWUFBWSxPQUFPLENBQUMsQ0FBQztBQUFBLFFBQzFELE9BQ0s7QUFDRCxjQUFJLEVBQUUsSUFBSSxnQkFBZ0IsT0FBTyxZQUFZLE9BQU8sQ0FBQyxDQUFDO0FBQUEsUUFDMUQ7QUFBQSxNQUNKO0FBTUEsYUFBTyxFQUFFLEdBQUcsR0FBQUE7SUFDaEI7QUFBQSxJQUNBLFdBQVcsR0FBRyxnQkFBZ0JyQyxJQUFHLFdBQVc7QUFFeEMsWUFBTSxJQUFJLEVBQUUsZ0JBQWdCO0FBRTVCLFVBQUksT0FBTyxlQUFlLElBQUksQ0FBQztBQUMvQixVQUFJLENBQUMsTUFBTTtBQUNQLGVBQU8sS0FBSyxpQkFBaUIsR0FBRyxDQUFDO0FBQ2pDLFlBQUksTUFBTSxHQUFHO0FBQ1QseUJBQWUsSUFBSSxHQUFHLFVBQVUsSUFBSSxDQUFDO0FBQUEsUUFDekM7QUFBQSxNQUNKO0FBQ0EsYUFBTyxLQUFLLEtBQUssR0FBRyxNQUFNQSxFQUFDO0FBQUEsSUFDL0I7QUFBQSxFQUNSO0FBQ0E7QUFDTyxTQUFTLGNBQWMsT0FBTztBQUNqQyxnQkFBYyxNQUFNLEVBQUU7QUFDdEIsaUJBQWUsT0FBTztBQUFBLElBQ2xCLEdBQUc7QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILElBQUk7QUFBQSxJQUNKLElBQUk7QUFBQSxFQUNaLEdBQU87QUFBQSxJQUNDLFlBQVk7QUFBQSxJQUNaLGFBQWE7QUFBQSxFQUNyQixDQUFLO0FBRUQsU0FBTyxPQUFPLE9BQU87QUFBQSxJQUNqQixHQUFHLFFBQVEsTUFBTSxHQUFHLE1BQU0sVUFBVTtBQUFBLElBQ3BDLEdBQUc7QUFBQSxJQUNILEdBQUcsRUFBRSxHQUFHLE1BQU0sR0FBRyxNQUFLO0FBQUEsRUFDOUIsQ0FBSztBQUNMO0FDMUpBO0FBTUEsU0FBUyxrQkFBa0IsT0FBTztBQUM5QixRQUFNLE9BQU8sY0FBYyxLQUFLO0FBQ2hDd0MsaUJBQWtCLE1BQU07QUFBQSxJQUNwQixHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsRUFDWCxHQUFPO0FBQUEsSUFDQywwQkFBMEI7QUFBQSxJQUMxQixnQkFBZ0I7QUFBQSxJQUNoQixlQUFlO0FBQUEsSUFDZixlQUFlO0FBQUEsSUFDZixvQkFBb0I7QUFBQSxJQUNwQixXQUFXO0FBQUEsSUFDWCxTQUFTO0FBQUEsRUFDakIsQ0FBSztBQUNELFFBQU0sRUFBRSxNQUFNLElBQUFMLEtBQUksRUFBQyxJQUFLO0FBQ3hCLE1BQUksTUFBTTtBQUNOLFFBQUksQ0FBQ0EsSUFBRyxJQUFJLEdBQUdBLElBQUcsSUFBSSxHQUFHO0FBQ3JCLFlBQU0sSUFBSSxNQUFNLG1FQUFtRTtBQUFBLElBQ3ZGO0FBQ0EsUUFBSSxPQUFPLFNBQVMsWUFDaEIsT0FBTyxLQUFLLFNBQVMsWUFDckIsT0FBTyxLQUFLLGdCQUFnQixZQUFZO0FBQ3hDLFlBQU0sSUFBSSxNQUFNLG1FQUFtRTtBQUFBLElBQ3ZGO0FBQUEsRUFDSjtBQUNBLFNBQU8sT0FBTyxPQUFPLEVBQUUsR0FBRyxLQUFJLENBQUU7QUFDcEM7QUFFQSxNQUFNLEVBQUUsaUJBQWlCLEtBQUssWUFBWSxJQUFHLElBQUs7QUFDM0MsTUFBTSxNQUFNO0FBQUE7QUFBQSxFQUVmLEtBQUssTUFBTSxlQUFlLE1BQU07QUFBQSxJQUM1QixZQUFZLElBQUksSUFBSTtBQUNoQixZQUFNLENBQUM7QUFBQSxJQUNYO0FBQUEsRUFDUjtBQUFBLEVBQ0ksVUFBVSxNQUFNO0FBQ1osVUFBTSxFQUFFLEtBQUssRUFBQyxJQUFLO0FBQ25CLFFBQUksS0FBSyxTQUFTLEtBQUssS0FBSyxDQUFDLE1BQU07QUFDL0IsWUFBTSxJQUFJLEVBQUUsK0JBQStCO0FBQy9DLFVBQU0sTUFBTSxLQUFLLENBQUM7QUFDbEIsVUFBTSxNQUFNLEtBQUssU0FBUyxHQUFHLE1BQU0sQ0FBQztBQUNwQyxRQUFJLENBQUMsT0FBTyxJQUFJLFdBQVc7QUFDdkIsWUFBTSxJQUFJLEVBQUUseUNBQXlDO0FBS3pELFFBQUksSUFBSSxDQUFDLElBQUk7QUFDVCxZQUFNLElBQUksRUFBRSxxQ0FBcUM7QUFDckQsUUFBSSxJQUFJLENBQUMsTUFBTSxLQUFRLEVBQUUsSUFBSSxDQUFDLElBQUk7QUFDOUIsWUFBTSxJQUFJLEVBQUUscURBQXFEO0FBQ3JFLFdBQU8sRUFBRSxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxTQUFTLE1BQU0sQ0FBQztFQUNsRDtBQUFBLEVBQ0EsTUFBTSxLQUFLO0FBRVAsVUFBTSxFQUFFLEtBQUssRUFBQyxJQUFLO0FBQ25CLFVBQU0sT0FBTyxPQUFPLFFBQVEsV0FBVyxJQUFJLEdBQUcsSUFBSTtBQUNsRCxRQUFJLEVBQUUsZ0JBQWdCO0FBQ2xCLFlBQU0sSUFBSSxNQUFNLGVBQWU7QUFDbkMsUUFBSSxJQUFJLEtBQUs7QUFDYixRQUFJLElBQUksS0FBSyxLQUFLLENBQUMsS0FBSztBQUNwQixZQUFNLElBQUksRUFBRSx1QkFBdUI7QUFDdkMsUUFBSSxLQUFLLENBQUMsTUFBTSxJQUFJO0FBQ2hCLFlBQU0sSUFBSSxFQUFFLHFDQUFxQztBQUNyRCxVQUFNLEVBQUUsR0FBRyxHQUFHLEdBQUcsT0FBTSxJQUFLLElBQUksVUFBVSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQzFELFVBQU0sRUFBRSxHQUFHLEdBQUcsR0FBRyxXQUFVLElBQUssSUFBSSxVQUFVLE1BQU07QUFDcEQsUUFBSSxXQUFXO0FBQ1gsWUFBTSxJQUFJLEVBQUUsNkNBQTZDO0FBQzdELFdBQU8sRUFBRSxHQUFHO0VBQ2hCO0FBQUEsRUFDQSxXQUFXLEtBQUs7QUFFWixVQUFNLFFBQVEsQ0FBQ00sT0FBTyxPQUFPLFNBQVNBLEdBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxJQUFTLE9BQU9BLEtBQUlBO0FBQ3RFLFVBQU0sSUFBSSxDQUFDLFFBQVE7QUFDZixZQUFNLE1BQU0sSUFBSSxTQUFTLEVBQUU7QUFDM0IsYUFBTyxJQUFJLFNBQVMsSUFBSSxJQUFJLEdBQUcsS0FBSztBQUFBLElBQ3hDO0FBQ0EsVUFBTSxJQUFJLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztBQUN4QixVQUFNLElBQUksTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3hCLFVBQU0sTUFBTSxFQUFFLFNBQVM7QUFDdkIsVUFBTSxNQUFNLEVBQUUsU0FBUztBQUN2QixVQUFNLEtBQUssRUFBRSxHQUFHO0FBQ2hCLFVBQU0sS0FBSyxFQUFFLEdBQUc7QUFDaEIsV0FBTyxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7QUFBQSxFQUN0RDtBQUNKO0FBR0ssTUFBQyxNQUFNLE9BQU8sQ0FBQyxHQUFHdEIsUUFBTSxPQUFPLENBQUM7QUFBUyxPQUFPLENBQUM7QUFBRSxNQUFDLE1BQU0sT0FBTyxDQUFDO0FBQVMsT0FBTyxDQUFDO0FBQ2pGLFNBQVMsa0JBQWtCLE1BQU07QUFDcEMsUUFBTSxRQUFRLGtCQUFrQixJQUFJO0FBQ3BDLFFBQU0sRUFBRSxJQUFBZ0IsSUFBRSxJQUFLO0FBQ2YsUUFBTU8sV0FBVSxNQUFNLFlBQ2pCLENBQUMsSUFBSSxPQUFPLGtCQUFrQjtBQUMzQixVQUFNLElBQUksTUFBTTtBQUNoQixXQUFPQyxZQUFlLFdBQVcsS0FBSyxDQUFDLENBQUksQ0FBQyxHQUFHUixJQUFHLFFBQVEsRUFBRSxDQUFDLEdBQUdBLElBQUcsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUFBLEVBQ25GO0FBQ0osUUFBTSxZQUFZLE1BQU0sY0FDbkIsQ0FBQ25FLFdBQVU7QUFFUixVQUFNLE9BQU9BLE9BQU0sU0FBUyxDQUFDO0FBRTdCLFVBQU0sSUFBSW1FLElBQUcsVUFBVSxLQUFLLFNBQVMsR0FBR0EsSUFBRyxLQUFLLENBQUM7QUFDakQsVUFBTSxJQUFJQSxJQUFHLFVBQVUsS0FBSyxTQUFTQSxJQUFHLE9BQU8sSUFBSUEsSUFBRyxLQUFLLENBQUM7QUFDNUQsV0FBTyxFQUFFLEdBQUc7RUFDaEI7QUFLSixXQUFTLG9CQUFvQixHQUFHO0FBQzVCLFVBQU0sRUFBRSxHQUFHLEdBQUEvQyxHQUFDLElBQUs7QUFDakIsVUFBTSxLQUFLK0MsSUFBRyxJQUFJLENBQUM7QUFDbkIsVUFBTSxLQUFLQSxJQUFHLElBQUksSUFBSSxDQUFDO0FBQ3ZCLFdBQU9BLElBQUcsSUFBSUEsSUFBRyxJQUFJLElBQUlBLElBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHL0MsRUFBQztBQUFBLEVBQzdDO0FBS0EsTUFBSSxDQUFDK0MsSUFBRyxJQUFJQSxJQUFHLElBQUksTUFBTSxFQUFFLEdBQUcsb0JBQW9CLE1BQU0sRUFBRSxDQUFDO0FBQ3ZELFVBQU0sSUFBSSxNQUFNLDZDQUE2QztBQUVqRSxXQUFTLG1CQUFtQixLQUFLO0FBQzdCLFdBQU8sT0FBTyxRQUFRLFlBQVksTUFBTSxPQUFPLE1BQU0sTUFBTTtBQUFBLEVBQy9EO0FBQ0EsV0FBUyxTQUFTLEtBQUs7QUFDbkIsUUFBSSxDQUFDLG1CQUFtQixHQUFHO0FBQ3ZCLFlBQU0sSUFBSSxNQUFNLDZDQUE2QztBQUFBLEVBQ3JFO0FBR0EsV0FBUyx1QkFBdUIsS0FBSztBQUNqQyxVQUFNLEVBQUUsMEJBQTBCLFNBQVMsYUFBYSxnQkFBZ0IsR0FBQW5DLEdBQUMsSUFBSztBQUM5RSxRQUFJLFdBQVcsT0FBTyxRQUFRLFVBQVU7QUFDcEMsVUFBSSxlQUFlO0FBQ2YsY0FBTTRDLFdBQWMsR0FBRztBQUUzQixVQUFJLE9BQU8sUUFBUSxZQUFZLENBQUMsUUFBUSxTQUFTLElBQUksTUFBTTtBQUN2RCxjQUFNLElBQUksTUFBTSxhQUFhO0FBQ2pDLFlBQU0sSUFBSSxTQUFTLGNBQWMsR0FBRyxHQUFHO0FBQUEsSUFDM0M7QUFDQSxRQUFJO0FBQ0osUUFBSTtBQUNBLFlBQ0ksT0FBTyxRQUFRLFdBQ1QsTUFDQUMsZ0JBQW1CLFlBQVksZUFBZSxLQUFLLFdBQVcsQ0FBQztBQUFBLElBQzdFLFNBQ08sT0FBTztBQUNWLFlBQU0sSUFBSSxNQUFNLHVCQUF1QixXQUFXLDhCQUE4QixPQUFPLEdBQUcsRUFBRTtBQUFBLElBQ2hHO0FBQ0EsUUFBSTtBQUNBLFlBQU1DLElBQVEsS0FBSzlDLEVBQUM7QUFDeEIsYUFBUyxHQUFHO0FBQ1osV0FBTztBQUFBLEVBQ1g7QUFDQSxRQUFNLG1CQUFtQixvQkFBSTtBQUM3QixXQUFTLGVBQWUsT0FBTztBQUMzQixRQUFJLEVBQUUsaUJBQWlCO0FBQ25CLFlBQU0sSUFBSSxNQUFNLDBCQUEwQjtBQUFBLEVBQ2xEO0FBQUEsRUFNQSxNQUFNLE1BQU07QUFBQSxJQUNSLFlBQVksSUFBSSxJQUFJLElBQUk7QUFDcEIsV0FBSyxLQUFLO0FBQ1YsV0FBSyxLQUFLO0FBQ1YsV0FBSyxLQUFLO0FBQ1YsVUFBSSxNQUFNLFFBQVEsQ0FBQ21DLElBQUcsUUFBUSxFQUFFO0FBQzVCLGNBQU0sSUFBSSxNQUFNLFlBQVk7QUFDaEMsVUFBSSxNQUFNLFFBQVEsQ0FBQ0EsSUFBRyxRQUFRLEVBQUU7QUFDNUIsY0FBTSxJQUFJLE1BQU0sWUFBWTtBQUNoQyxVQUFJLE1BQU0sUUFBUSxDQUFDQSxJQUFHLFFBQVEsRUFBRTtBQUM1QixjQUFNLElBQUksTUFBTSxZQUFZO0FBQUEsSUFDcEM7QUFBQTtBQUFBO0FBQUEsSUFHQSxPQUFPLFdBQVcsR0FBRztBQUNqQixZQUFNLEVBQUUsR0FBRyxNQUFNLEtBQUssQ0FBQTtBQUN0QixVQUFJLENBQUMsS0FBSyxDQUFDQSxJQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUNBLElBQUcsUUFBUSxDQUFDO0FBQ3JDLGNBQU0sSUFBSSxNQUFNLHNCQUFzQjtBQUMxQyxVQUFJLGFBQWE7QUFDYixjQUFNLElBQUksTUFBTSw4QkFBOEI7QUFDbEQsWUFBTSxNQUFNLENBQUMsTUFBTUEsSUFBRyxJQUFJLEdBQUdBLElBQUcsSUFBSTtBQUVwQyxVQUFJLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQztBQUNmLGVBQU8sTUFBTTtBQUNqQixhQUFPLElBQUksTUFBTSxHQUFHLEdBQUdBLElBQUcsR0FBRztBQUFBLElBQ2pDO0FBQUEsSUFDQSxJQUFJLElBQUk7QUFDSixhQUFPLEtBQUssU0FBUSxFQUFHO0FBQUEsSUFDM0I7QUFBQSxJQUNBLElBQUksSUFBSTtBQUNKLGFBQU8sS0FBSyxTQUFRLEVBQUc7QUFBQSxJQUMzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBT0EsT0FBTyxXQUFXLFFBQVE7QUFDdEIsWUFBTSxRQUFRQSxJQUFHLFlBQVksT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQztBQUNwRCxhQUFPLE9BQU8sSUFBSSxDQUFDLEdBQUcsTUFBTSxFQUFFLFNBQVMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksTUFBTSxVQUFVO0FBQUEsSUFDMUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBS0EsT0FBTyxRQUFRLEtBQUs7QUFDaEIsWUFBTSxJQUFJLE1BQU0sV0FBVyxVQUFVLFlBQVksWUFBWSxHQUFHLENBQUMsQ0FBQztBQUNsRSxRQUFFLGVBQWM7QUFDaEIsYUFBTztBQUFBLElBQ1g7QUFBQTtBQUFBLElBRUEsT0FBTyxlQUFlLFlBQVk7QUFDOUIsYUFBTyxNQUFNLEtBQUssU0FBUyx1QkFBdUIsVUFBVSxDQUFDO0FBQUEsSUFDakU7QUFBQTtBQUFBLElBRUEsZUFBZSxZQUFZO0FBQ3ZCLFdBQUssZUFBZTtBQUNwQix1QkFBaUIsT0FBTyxJQUFJO0FBQUEsSUFDaEM7QUFBQTtBQUFBLElBRUEsaUJBQWlCO0FBQ2IsVUFBSSxLQUFLLE9BQU87QUFJWixZQUFJLE1BQU0sc0JBQXNCLENBQUNBLElBQUcsSUFBSSxLQUFLLEVBQUU7QUFDM0M7QUFDSixjQUFNLElBQUksTUFBTSxpQkFBaUI7QUFBQSxNQUNyQztBQUVBLFlBQU0sRUFBRSxHQUFHLEVBQUMsSUFBSyxLQUFLLFNBQVE7QUFFOUIsVUFBSSxDQUFDQSxJQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUNBLElBQUcsUUFBUSxDQUFDO0FBQy9CLGNBQU0sSUFBSSxNQUFNLDBCQUEwQjtBQUM5QyxZQUFNLE9BQU9BLElBQUcsSUFBSSxDQUFDO0FBQ3JCLFlBQU0sUUFBUSxvQkFBb0IsQ0FBQztBQUNuQyxVQUFJLENBQUNBLElBQUcsSUFBSSxNQUFNLEtBQUs7QUFDbkIsY0FBTSxJQUFJLE1BQU0sbUNBQW1DO0FBQ3ZELFVBQUksQ0FBQyxLQUFLLGNBQWE7QUFDbkIsY0FBTSxJQUFJLE1BQU0sd0NBQXdDO0FBQUEsSUFDaEU7QUFBQSxJQUNBLFdBQVc7QUFDUCxZQUFNLEVBQUUsRUFBQyxJQUFLLEtBQUssU0FBUTtBQUMzQixVQUFJQSxJQUFHO0FBQ0gsZUFBTyxDQUFDQSxJQUFHLE1BQU0sQ0FBQztBQUN0QixZQUFNLElBQUksTUFBTSw2QkFBNkI7QUFBQSxJQUNqRDtBQUFBO0FBQUE7QUFBQTtBQUFBLElBSUEsT0FBTyxPQUFPO0FBQ1YscUJBQWUsS0FBSztBQUNwQixZQUFNLEVBQUUsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEdBQUUsSUFBSztBQUNuQyxZQUFNLEVBQUUsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEdBQUUsSUFBSztBQUNuQyxZQUFNWSxNQUFLWixJQUFHLElBQUlBLElBQUcsSUFBSSxJQUFJLEVBQUUsR0FBR0EsSUFBRyxJQUFJLElBQUksRUFBRSxDQUFDO0FBQ2hELFlBQU1hLE1BQUtiLElBQUcsSUFBSUEsSUFBRyxJQUFJLElBQUksRUFBRSxHQUFHQSxJQUFHLElBQUksSUFBSSxFQUFFLENBQUM7QUFDaEQsYUFBT1ksT0FBTUM7QUFBQSxJQUNqQjtBQUFBO0FBQUE7QUFBQTtBQUFBLElBSUEsU0FBUztBQUNMLGFBQU8sSUFBSSxNQUFNLEtBQUssSUFBSWIsSUFBRyxJQUFJLEtBQUssRUFBRSxHQUFHLEtBQUssRUFBRTtBQUFBLElBQ3REO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUtBLFNBQVM7QUFDTCxZQUFNLEVBQUUsR0FBRyxHQUFBL0MsR0FBQyxJQUFLO0FBQ2pCLFlBQU0sS0FBSytDLElBQUcsSUFBSS9DLElBQUcsR0FBRztBQUN4QixZQUFNLEVBQUUsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEdBQUUsSUFBSztBQUNuQyxVQUFJLEtBQUsrQyxJQUFHLE1BQU0sS0FBS0EsSUFBRyxNQUFNLEtBQUtBLElBQUc7QUFDeEMsVUFBSSxLQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ3RCLFVBQUksS0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUN0QixVQUFJLEtBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDdEIsVUFBSSxLQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ3RCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxHQUFHLEVBQUU7QUFDakIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksR0FBRyxFQUFFO0FBQ2pCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLEdBQUcsRUFBRTtBQUNqQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLGFBQU8sSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO0FBQUEsSUFDL0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBS0EsSUFBSSxPQUFPO0FBQ1AscUJBQWUsS0FBSztBQUNwQixZQUFNLEVBQUUsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEdBQUUsSUFBSztBQUNuQyxZQUFNLEVBQUUsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEdBQUUsSUFBSztBQUNuQyxVQUFJLEtBQUtBLElBQUcsTUFBTSxLQUFLQSxJQUFHLE1BQU0sS0FBS0EsSUFBRztBQUN4QyxZQUFNLElBQUksTUFBTTtBQUNoQixZQUFNLEtBQUtBLElBQUcsSUFBSSxNQUFNLEdBQUcsR0FBRztBQUM5QixVQUFJLEtBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDdEIsVUFBSSxLQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ3RCLFVBQUksS0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUN0QixVQUFJLEtBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDdEIsVUFBSSxLQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ3RCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsVUFBSSxLQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ3RCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksR0FBRyxFQUFFO0FBQ2pCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLEdBQUcsRUFBRTtBQUNqQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksR0FBRyxFQUFFO0FBQ2pCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLGFBQU8sSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO0FBQUEs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QUFBQSxFQUlwQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sS0FBSyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLEtBQUssR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbEMsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE1BQU0sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE1BQU0sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE1BQU0sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sSUFBSSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSW5DLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsQ0FBQztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSW5DLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsQ0FBQztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSW5DLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsQ0FBQztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxJQUFJLE9BQU0sUUFBUSxXQUFXLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJNUQsT0FBTyxLQUFLLEdBQUc7QUFBRSxXQUFPLElBQUksT0FBTSxRQUFRLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJeEQsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLElBQUksT0FBTSxRQUFRLFNBQVMsQ0FBQztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl4RCxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sSUFBSSxPQUFNLFFBQVEsVUFBVSxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSTFELE9BQU8sTUFBTSxHQUFHLFNBQVM7QUFDckIsVUFBTSxJQUFJLE1BQU0scUJBQXFCO0FBQUEsRUFFekM7QUFBQTtBQUFBO0FB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QU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sR0FBSTtBQUVoTSxNQUFNLElBQUksQ0FBQyxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxHQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxHQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxHQUFNLEtBQU0sR0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEdBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEdBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEdBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sSUFBTSxHQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sR0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxHQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxFQUFJO0FBQ3pnRCxNQUFNLEtBQUssQ0FBQyxJQUFNLEdBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxHQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxHQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sR0FBTSxLQUFNLEtBQU0sSUFBTSxHQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sR0FBTSxLQUFNLEtBQU0sS0FBTSxHQUFNLEdBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sR0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sR0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLElBQU0sSUFBTSxHQUFJO0FBRTFnRCxNQUFNLEtBQUssQ0FBQyxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLEdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxTQUFVO0FBQzFnRyxNQUFNLEtBQUssQ0FBQyxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLEdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFVBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxTQUFVO0FBQzFnRyxNQUFNLEtBQUssQ0FBQyxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxVQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxVQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxVQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLEdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxTQUFVO0FBQzFnRyxNQUFNLEtBQUssQ0FBQyxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxVQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxVQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxVQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLEdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxTQUFVO0FBRTFnRyxNQUFNLEtBQUssQ0FBQyxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxHQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFVO0FBQzFnRyxNQUFNLEtBQUssQ0FBQyxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxHQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFVO0FBQzFnRyxNQUFNLEtBQUssQ0FBQyxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxHQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFVO0FBQzFnRyxNQUFNLEtBQUssQ0FBQyxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxVQUFZLFlBQVksVUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxVQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxHQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxVQUFVO0FBRTFnRyxNQUFNLEtBQUssQ0FBQyxHQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFVO0FBQzFnRyxNQUFNLEtBQUssQ0FBQyxHQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFVO0FBQzFnRyxNQUFNLEtBQUssQ0FBQyxHQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFVO0FBQzFnRyxNQUFNLEtBQUssQ0FBQyxHQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksVUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFVO0FBQzFnRyxTQUFTLGVBQWVyRSxRQUFPO0FBQzNCLFFBQU0sU0FBUyxDQUFBO0FBQ2YsV0FBUyxJQUFJLEdBQUcsSUFBSUEsT0FBTSxRQUFRLEtBQUssR0FBRztBQUN0QyxXQUFPLEtBQU1BLE9BQU0sQ0FBQyxLQUFLLEtBQU9BLE9BQU0sSUFBSSxDQUFDLEtBQUssS0FBT0EsT0FBTSxJQUFJLENBQUMsS0FBSyxJQUFLQSxPQUFNLElBQUksQ0FBQyxDQUFDO0FBQUEsRUFDNUY7QUFDQSxTQUFPO0FBQ1g7QUFDTyxNQUFNLElBQUk7QUFBQSxFQUNiLElBQUksTUFBTTtBQUFFLFdBQU9rSix5QkFBdUIsTUFBTSxVQUFVLEdBQUcsRUFBRSxNQUFLO0FBQUEsRUFBSTtBQUFBLEVBQ3hFLFlBQVksS0FBSztBQUNiLGFBQVMsSUFBSSxNQUFNLE1BQU07QUFDekIsWUFBUSxJQUFJLE1BQU0sTUFBTTtBQUN4QixZQUFRLElBQUksTUFBTSxNQUFNO0FBQ3hCLFFBQUksRUFBRSxnQkFBZ0IsTUFBTTtBQUN4QixZQUFNLE1BQU0scUNBQXFDO0FBQUEsSUFDckQ7QUFDQUMsNkJBQXVCLE1BQU0sVUFBVSxJQUFJLFdBQVcsR0FBRyxHQUFHLEdBQUc7QUFDL0QsVUFBTSxTQUFTLGVBQWUsS0FBSyxJQUFJLE1BQU07QUFDN0MsUUFBSSxVQUFVLE1BQU07QUFDaEIsWUFBTSxJQUFJLFVBQVUsK0NBQStDO0FBQUEsSUFDdkU7QUFFQUEsNkJBQXVCLE1BQU0sU0FBUyxDQUFBLEdBQUksR0FBRztBQUU3Q0EsNkJBQXVCLE1BQU0sU0FBUyxDQUFBLEdBQUksR0FBRztBQUM3QyxhQUFTLElBQUksR0FBRyxLQUFLLFFBQVEsS0FBSztBQUM5QkQsK0JBQXVCLE1BQU0sU0FBUyxHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUM1REEsK0JBQXVCLE1BQU0sU0FBUyxHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUFBLElBQ2hFO0FBQ0EsVUFBTSxpQkFBaUIsU0FBUyxLQUFLO0FBQ3JDLFVBQU0sS0FBSyxLQUFLLElBQUksU0FBUztBQUU3QixVQUFNLEtBQUssZUFBZSxLQUFLLEdBQUc7QUFFbEMsUUFBSTtBQUNKLGFBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxLQUFLO0FBQ3pCLGNBQVEsS0FBSztBQUNiQSwrQkFBdUIsTUFBTSxTQUFTLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDO0FBQy9EQSwrQkFBdUIsTUFBTSxTQUFTLEdBQUcsRUFBRSxTQUFTLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUM7QUFBQSxJQUM1RTtBQUVBLFFBQUksY0FBYztBQUNsQixRQUFJLElBQUksSUFBSTtBQUNaLFdBQU8sSUFBSSxlQUFlO0FBQ3RCLFdBQUssR0FBRyxLQUFLLENBQUM7QUFDZCxTQUFHLENBQUMsS0FBTyxFQUFHLE1BQU0sS0FBTSxHQUFJLEtBQUssS0FDOUIsRUFBRyxNQUFNLElBQUssR0FBSSxLQUFLLEtBQ3ZCLEVBQUUsS0FBSyxHQUFJLEtBQUssSUFDakIsRUFBRyxNQUFNLEtBQU0sR0FBSSxJQUNsQixLQUFLLFdBQVcsS0FBSztBQUMxQixxQkFBZTtBQUVmLFVBQUksTUFBTSxHQUFHO0FBQ1QsaUJBQVNFLEtBQUksR0FBR0EsS0FBSSxJQUFJQSxNQUFLO0FBQ3pCLGFBQUdBLEVBQUMsS0FBSyxHQUFHQSxLQUFJLENBQUM7QUFBQSxRQUNyQjtBQUFBLE1BRUosT0FDSztBQUNELGlCQUFTQSxLQUFJLEdBQUdBLEtBQUssS0FBSyxHQUFJQSxNQUFLO0FBQy9CLGFBQUdBLEVBQUMsS0FBSyxHQUFHQSxLQUFJLENBQUM7QUFBQSxRQUNyQjtBQUNBLGFBQUssR0FBSSxLQUFLLElBQUssQ0FBQztBQUNwQixXQUFHLEtBQUssQ0FBQyxLQUFNLEVBQUUsS0FBSyxHQUFJLElBQ3JCLEVBQUcsTUFBTSxJQUFLLEdBQUksS0FBSyxJQUN2QixFQUFHLE1BQU0sS0FBTSxHQUFJLEtBQUssS0FDeEIsRUFBRyxNQUFNLEtBQU0sR0FBSSxLQUFLO0FBQzdCLGlCQUFTQSxLQUFLLEtBQUssSUFBSyxHQUFHQSxLQUFJLElBQUlBLE1BQUs7QUFDcEMsYUFBR0EsRUFBQyxLQUFLLEdBQUdBLEtBQUksQ0FBQztBQUFBLFFBQ3JCO0FBQUEsTUFDSjtBQUVBLFVBQUksSUFBSSxHQUFHLEdBQUc7QUFDZCxhQUFPLElBQUksTUFBTSxJQUFJLGVBQWU7QUFDaEMsWUFBSSxLQUFLO0FBQ1QsWUFBSSxJQUFJO0FBQ1JGLGlDQUF1QixNQUFNLFNBQVMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDO0FBQ3ZEQSxpQ0FBdUIsTUFBTSxTQUFTLEdBQUcsRUFBRSxTQUFTLENBQUMsRUFBRSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQ2xFO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFFQSxhQUFTLElBQUksR0FBRyxJQUFJLFFBQVEsS0FBSztBQUM3QixlQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSztBQUN4QixhQUFLQSx5QkFBdUIsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUNwREEsaUNBQXVCLE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSyxHQUFJLE1BQU0sS0FBTSxHQUFJLElBQ3BFLEdBQUksTUFBTSxLQUFNLEdBQUksSUFDcEIsR0FBSSxNQUFNLElBQUssR0FBSSxJQUNuQixHQUFHLEtBQUssR0FBSTtBQUFBLE1BQ3BCO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFBQSxFQUNBLFFBQVEsV0FBVztBQUNmLFFBQUksVUFBVSxVQUFVLElBQUk7QUFDeEIsWUFBTSxJQUFJLFVBQVUsMkNBQTJDO0FBQUEsSUFDbkU7QUFDQSxVQUFNLFNBQVNBLHlCQUF1QixNQUFNLFNBQVMsR0FBRyxFQUFFLFNBQVM7QUFDbkUsVUFBTSxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUVyQixRQUFJLElBQUksZUFBZSxTQUFTO0FBQ2hDLGFBQVMsSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLO0FBQ3hCLFFBQUUsQ0FBQyxLQUFLQSx5QkFBdUIsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUFBLElBQzNEO0FBRUEsYUFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEtBQUs7QUFDN0IsZUFBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDeEIsVUFBRSxDQUFDLElBQUssR0FBSSxFQUFFLENBQUMsS0FBSyxLQUFNLEdBQUksSUFDMUIsR0FBSSxHQUFHLElBQUksS0FBSyxDQUFDLEtBQUssS0FBTSxHQUFJLElBQ2hDLEdBQUksR0FBRyxJQUFJLEtBQUssQ0FBQyxLQUFLLElBQUssR0FBSSxJQUMvQixHQUFHLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxHQUFJLElBQ3hCQSx5QkFBdUIsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUFBLE1BQ3ZEO0FBQ0EsVUFBSSxFQUFFO0lBQ1Y7QUFFQSxVQUFNLFNBQVMsSUFBSSxXQUFXLEVBQUU7QUFDaEMsUUFBSSxLQUFLO0FBQ1QsYUFBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDeEIsV0FBS0EseUJBQXVCLE1BQU0sU0FBUyxHQUFHLEVBQUUsTUFBTSxFQUFFLENBQUM7QUFDekQsYUFBTyxJQUFJLENBQUMsS0FBSyxFQUFHLEVBQUUsQ0FBQyxLQUFLLEtBQU0sR0FBSSxJQUFLLE1BQU0sTUFBTztBQUN4RCxhQUFPLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRyxHQUFHLElBQUksS0FBSyxDQUFDLEtBQUssS0FBTSxHQUFJLElBQUssTUFBTSxNQUFPO0FBQ3RFLGFBQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFHLEdBQUcsSUFBSSxLQUFLLENBQUMsS0FBSyxJQUFLLEdBQUksSUFBSyxNQUFNLEtBQU07QUFDcEUsYUFBTyxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLEdBQUksSUFBSSxNQUFNO0FBQUEsSUFDMUQ7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsUUFBUSxZQUFZO0FBQ2hCLFFBQUksV0FBVyxVQUFVLElBQUk7QUFDekIsWUFBTSxJQUFJLFVBQVUsNENBQTRDO0FBQUEsSUFDcEU7QUFDQSxVQUFNLFNBQVNBLHlCQUF1QixNQUFNLFNBQVMsR0FBRyxFQUFFLFNBQVM7QUFDbkUsVUFBTSxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUVyQixRQUFJLElBQUksZUFBZSxVQUFVO0FBQ2pDLGFBQVMsSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLO0FBQ3hCLFFBQUUsQ0FBQyxLQUFLQSx5QkFBdUIsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUFBLElBQzNEO0FBRUEsYUFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEtBQUs7QUFDN0IsZUFBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDeEIsVUFBRSxDQUFDLElBQUssR0FBSSxFQUFFLENBQUMsS0FBSyxLQUFNLEdBQUksSUFDMUIsR0FBSSxHQUFHLElBQUksS0FBSyxDQUFDLEtBQUssS0FBTSxHQUFJLElBQ2hDLEdBQUksR0FBRyxJQUFJLEtBQUssQ0FBQyxLQUFLLElBQUssR0FBSSxJQUMvQixHQUFHLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxHQUFJLElBQ3hCQSx5QkFBdUIsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUFBLE1BQ3ZEO0FBQ0EsVUFBSSxFQUFFO0lBQ1Y7QUFFQSxVQUFNLFNBQVMsSUFBSSxXQUFXLEVBQUU7QUFDaEMsUUFBSSxLQUFLO0FBQ1QsYUFBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDeEIsV0FBS0EseUJBQXVCLE1BQU0sU0FBUyxHQUFHLEVBQUUsTUFBTSxFQUFFLENBQUM7QUFDekQsYUFBTyxJQUFJLENBQUMsS0FBSyxHQUFJLEVBQUUsQ0FBQyxLQUFLLEtBQU0sR0FBSSxJQUFLLE1BQU0sTUFBTztBQUN6RCxhQUFPLElBQUksSUFBSSxDQUFDLEtBQUssR0FBSSxHQUFHLElBQUksS0FBSyxDQUFDLEtBQUssS0FBTSxHQUFJLElBQUssTUFBTSxNQUFPO0FBQ3ZFLGFBQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFJLEdBQUcsSUFBSSxLQUFLLENBQUMsS0FBSyxJQUFLLEdBQUksSUFBSyxNQUFNLEtBQU07QUFDckUsYUFBTyxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLEdBQUksSUFBSSxNQUFNO0FBQUEsSUFDM0Q7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUNKO0FBQ0EsV0FBVyxvQkFBSSxRQUFPLEdBQUksVUFBVSxvQkFBSSxXQUFXLFVBQVUsb0JBQUksUUFBTztBQ25NakUsTUFBTSxnQkFBZ0I7QUFBQSxFQUN6QixZQUFZLE1BQU0sS0FBSyxLQUFLO0FBQ3hCLFFBQUksT0FBTyxFQUFFLGdCQUFnQixNQUFNO0FBQy9CLFlBQU0sSUFBSSxNQUFNLEdBQUcsSUFBSSxrQ0FBa0M7QUFBQSxJQUM3RDtBQUNBLFdBQU8saUJBQWlCLE1BQU07QUFBQSxNQUMxQixLQUFLLEVBQUUsWUFBWSxNQUFNLE9BQU8sSUFBSSxJQUFJLEdBQUcsRUFBQztBQUFBLE1BQzVDLE1BQU0sRUFBRSxZQUFZLE1BQU0sT0FBTyxLQUFJO0FBQUEsSUFDakQsQ0FBUztBQUFBLEVBQ0w7QUFDSjtBQ1ZBLElBQUlDLDJCQUFrRSxTQUFVLFVBQVUsT0FBTyxPQUFPLE1BQU05RSxJQUFHO0FBQzdHLE1BQUksU0FBUyxJQUFLLE9BQU0sSUFBSSxVQUFVLGdDQUFnQztBQUN0RSxNQUFJLFNBQVMsT0FBTyxDQUFDQSxHQUFHLE9BQU0sSUFBSSxVQUFVLCtDQUErQztBQUMzRixNQUFJLE9BQU8sVUFBVSxhQUFhLGFBQWEsU0FBUyxDQUFDQSxLQUFJLENBQUMsTUFBTSxJQUFJLFFBQVEsRUFBRyxPQUFNLElBQUksVUFBVSx5RUFBeUU7QUFDaEwsU0FBUSxTQUFTLE1BQU1BLEdBQUUsS0FBSyxVQUFVLEtBQUssSUFBSUEsS0FBSUEsR0FBRSxRQUFRLFFBQVEsTUFBTSxJQUFJLFVBQVUsS0FBSyxHQUFJO0FBQ3hHO0FBQ0EsSUFBSTZFLDJCQUFrRSxTQUFVLFVBQVUsT0FBTyxNQUFNN0UsSUFBRztBQUN0RyxNQUFJLFNBQVMsT0FBTyxDQUFDQSxHQUFHLE9BQU0sSUFBSSxVQUFVLCtDQUErQztBQUMzRixNQUFJLE9BQU8sVUFBVSxhQUFhLGFBQWEsU0FBUyxDQUFDQSxLQUFJLENBQUMsTUFBTSxJQUFJLFFBQVEsRUFBRyxPQUFNLElBQUksVUFBVSwwRUFBMEU7QUFDakwsU0FBTyxTQUFTLE1BQU1BLEtBQUksU0FBUyxNQUFNQSxHQUFFLEtBQUssUUFBUSxJQUFJQSxLQUFJQSxHQUFFLFFBQVEsTUFBTSxJQUFJLFFBQVE7QUFDaEc7QUFDQSxJQUFJLFNBQVM7QUFFTixNQUFNLFlBQVksZ0JBQWdCO0FBQUEsRUFDckMsWUFBWSxLQUFLLElBQUk7QUFDakIsVUFBTSxPQUFPLEtBQUssR0FBRztBQUNyQixZQUFRLElBQUksTUFBTSxNQUFNO0FBQ3hCLG1CQUFlLElBQUksTUFBTSxNQUFNO0FBQy9CLFFBQUksSUFBSTtBQUNKLFVBQUksR0FBRyxTQUFTLElBQUk7QUFDaEIsY0FBTSxJQUFJLFVBQVUsb0NBQW9DO0FBQUEsTUFDNUQ7QUFDQThFLCtCQUF1QixNQUFNLFNBQVMsSUFBSSxXQUFXLEVBQUUsR0FBRyxHQUFHO0FBQUEsSUFDakUsT0FDSztBQUNEQSwrQkFBdUIsTUFBTSxTQUFTLElBQUksV0FBVyxFQUFFLEdBQUcsR0FBRztBQUFBLElBQ2pFO0FBQ0FBLDZCQUF1QixNQUFNLGdCQUFnQixLQUFLLElBQUksR0FBRztBQUFBLEVBQzdEO0FBQUEsRUFDQSxJQUFJLEtBQUs7QUFBRSxXQUFPLElBQUksV0FBV0QseUJBQXVCLE1BQU0sU0FBUyxHQUFHLENBQUM7QUFBQSxFQUFHO0FBQUEsRUFDOUUsUUFBUSxXQUFXO0FBQ2YsUUFBSSxVQUFVLFNBQVMsSUFBSTtBQUN2QixZQUFNLElBQUksVUFBVSx1REFBdUQ7QUFBQSxJQUMvRTtBQUNBLFVBQU0sYUFBYSxJQUFJLFdBQVcsVUFBVSxNQUFNO0FBQ2xELGFBQVMsSUFBSSxHQUFHLElBQUksVUFBVSxRQUFRLEtBQUssSUFBSTtBQUMzQyxlQUFTLElBQUksR0FBRyxJQUFJLElBQUksS0FBSztBQUN6QkEsaUNBQXVCLE1BQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDLEtBQUssVUFBVSxJQUFJLENBQUM7QUFBQSxNQUMzRTtBQUNBQywrQkFBdUIsTUFBTSxnQkFBZ0IsS0FBSyxJQUFJLFFBQVFELHlCQUF1QixNQUFNLGdCQUFnQixHQUFHLENBQUMsR0FBRyxHQUFHO0FBQ3JILGlCQUFXLElBQUlBLHlCQUF1QixNQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQztBQUFBLElBQ3ZFO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUNBLFFBQVEsWUFBWTtBQUNoQixRQUFJLFdBQVcsU0FBUyxJQUFJO0FBQ3hCLFlBQU0sSUFBSSxVQUFVLHdEQUF3RDtBQUFBLElBQ2hGO0FBQ0EsVUFBTSxZQUFZLElBQUksV0FBVyxXQUFXLE1BQU07QUFDbEQsYUFBUyxJQUFJLEdBQUcsSUFBSSxXQUFXLFFBQVEsS0FBSyxJQUFJO0FBQzVDLFlBQU0sUUFBUSxLQUFLLElBQUksUUFBUSxXQUFXLFNBQVMsR0FBRyxJQUFJLEVBQUUsQ0FBQztBQUM3RCxlQUFTLElBQUksR0FBRyxJQUFJLElBQUksS0FBSztBQUN6QixrQkFBVSxJQUFJLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSUEseUJBQXVCLE1BQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO0FBQ2pGQSxpQ0FBdUIsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsSUFBSSxXQUFXLElBQUksQ0FBQztBQUFBLE1BQzNFO0FBQUEsSUFDSjtBQUNBLFdBQU87QUFBQSxFQUNYO0FBQ0o7QUFDQSxVQUFVLG9CQUFJLFFBQU8sR0FBSSxpQkFBaUIsb0JBQUksUUFBTztBQzNEckQsSUFBSSx5QkFBa0UsU0FBVSxVQUFVLE9BQU8sT0FBTyxNQUFNN0UsSUFBRztBQUM3RyxNQUFJLFNBQVMsSUFBSyxPQUFNLElBQUksVUFBVSxnQ0FBZ0M7QUFDdEUsTUFBSSxTQUFTLE9BQU8sQ0FBQ0EsR0FBRyxPQUFNLElBQUksVUFBVSwrQ0FBK0M7QUFDM0YsTUFBSSxPQUFPLFVBQVUsYUFBYSxhQUFhLFNBQVMsQ0FBQ0EsS0FBSSxDQUFDLE1BQU0sSUFBSSxRQUFRLEVBQUcsT0FBTSxJQUFJLFVBQVUseUVBQXlFO0FBQ2hMLFNBQVEsU0FBUyxNQUFNQSxHQUFFLEtBQUssVUFBVSxLQUFLLElBQUlBLEtBQUlBLEdBQUUsUUFBUSxRQUFRLE1BQU0sSUFBSSxVQUFVLEtBQUssR0FBSTtBQUN4RztBQUNBLElBQUkseUJBQWtFLFNBQVUsVUFBVSxPQUFPLE1BQU1BLElBQUc7QUFDdEcsTUFBSSxTQUFTLE9BQU8sQ0FBQ0EsR0FBRyxPQUFNLElBQUksVUFBVSwrQ0FBK0M7QUFDM0YsTUFBSSxPQUFPLFVBQVUsYUFBYSxhQUFhLFNBQVMsQ0FBQ0EsS0FBSSxDQUFDLE1BQU0sSUFBSSxRQUFRLEVBQUcsT0FBTSxJQUFJLFVBQVUsMEVBQTBFO0FBQ2pMLFNBQU8sU0FBUyxNQUFNQSxLQUFJLFNBQVMsTUFBTUEsR0FBRSxLQUFLLFFBQVEsSUFBSUEsS0FBSUEsR0FBRSxRQUFRLE1BQU0sSUFBSSxRQUFRO0FBQ2hHO0FBQ0EsSUFBSSxnQkFBZ0IscUJBQXFCO0FBRWxDLE1BQU0sWUFBWSxnQkFBZ0I7QUFBQSxFQUNyQyxZQUFZLEtBQUssY0FBYztBQUMzQixVQUFNLE9BQU8sS0FBSyxHQUFHO0FBRXJCLG1CQUFlLElBQUksTUFBTSxNQUFNO0FBQy9CLHdCQUFvQixJQUFJLE1BQU0sTUFBTTtBQUVwQyxpQkFBYSxJQUFJLE1BQU0sTUFBTTtBQUM3QiwyQkFBdUIsTUFBTSxjQUFjLElBQUksV0FBVyxFQUFFLEdBQUcsR0FBRztBQUNsRSwyQkFBdUIsTUFBTSxjQUFjLEdBQUcsRUFBRSxLQUFLLENBQUM7QUFDdEQsMkJBQXVCLE1BQU0sZ0JBQWdCLHVCQUF1QixNQUFNLGNBQWMsR0FBRyxHQUFHLEdBQUc7QUFDakcsMkJBQXVCLE1BQU0scUJBQXFCLElBQUksR0FBRztBQUN6RCxRQUFJLGdCQUFnQixNQUFNO0FBQ3RCLHFCQUFlO0FBQUEsSUFDbkI7QUFDQSxRQUFJLE9BQVEsaUJBQWtCLFVBQVU7QUFDcEMsV0FBSyxnQkFBZ0IsWUFBWTtBQUFBLElBQ3JDLE9BQ0s7QUFDRCxXQUFLLGdCQUFnQixZQUFZO0FBQUEsSUFDckM7QUFBQSxFQUNKO0FBQUEsRUFDQSxJQUFJLFVBQVU7QUFBRSxXQUFPLElBQUksV0FBVyx1QkFBdUIsTUFBTSxjQUFjLEdBQUcsQ0FBQztBQUFBLEVBQUc7QUFBQSxFQUN4RixnQkFBZ0IsT0FBTztBQUNuQixRQUFJLENBQUMsT0FBTyxVQUFVLEtBQUssS0FBSyxRQUFRLEtBQUssUUFBUSxPQUFPLGtCQUFrQjtBQUMxRSxZQUFNLElBQUksVUFBVSx1Q0FBdUM7QUFBQSxJQUMvRDtBQUNBLGFBQVMsUUFBUSxJQUFJLFNBQVMsR0FBRyxFQUFFLE9BQU87QUFDdEMsNkJBQXVCLE1BQU0sY0FBYyxHQUFHLEVBQUUsS0FBSyxJQUFJLFFBQVE7QUFDakUsY0FBUSxLQUFLLE1BQU0sUUFBUSxHQUFHO0FBQUEsSUFDbEM7QUFBQSxFQUNKO0FBQUEsRUFDQSxnQkFBZ0IsT0FBTztBQUNuQixRQUFJLE1BQU0sV0FBVyxJQUFJO0FBQ3JCLFlBQU0sSUFBSSxVQUFVLGlEQUFpRDtBQUFBLElBQ3pFO0FBQ0EsMkJBQXVCLE1BQU0sY0FBYyxHQUFHLEVBQUUsSUFBSSxLQUFLO0FBQUEsRUFDN0Q7QUFBQSxFQUNBLFlBQVk7QUFDUixhQUFTLElBQUksSUFBSSxLQUFLLEdBQUcsS0FBSztBQUMxQixVQUFJLHVCQUF1QixNQUFNLGNBQWMsR0FBRyxFQUFFLENBQUMsTUFBTSxLQUFLO0FBQzVELCtCQUF1QixNQUFNLGNBQWMsR0FBRyxFQUFFLENBQUMsSUFBSTtBQUFBLE1BQ3pELE9BQ0s7QUFDRCwrQkFBdUIsTUFBTSxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBQ2pEO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQUEsRUFDQSxRQUFRLFdBQVc7QUFDZixRQUFJeEQsS0FBSTtBQUNSLFVBQU0sWUFBWSxJQUFJLFdBQVcsU0FBUztBQUMxQyxhQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZDLFVBQUksdUJBQXVCLE1BQU0scUJBQXFCLEdBQUcsTUFBTSxJQUFJO0FBQy9ELCtCQUF1QixNQUFNLGdCQUFnQixLQUFLLElBQUksUUFBUSx1QkFBdUIsTUFBTSxjQUFjLEdBQUcsQ0FBQyxHQUFHLEdBQUc7QUFDbkgsK0JBQXVCLE1BQU0scUJBQXFCLEdBQUcsR0FBRztBQUN4RCxhQUFLLFVBQVM7QUFBQSxNQUNsQjtBQUNBLGdCQUFVLENBQUMsS0FBSyx1QkFBdUIsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLHVCQUF1QixNQUFNLHNCQUFzQixLQUFLLHVCQUF1QixNQUFNLHFCQUFxQixHQUFHLEdBQUdBLE1BQUssTUFBTSxLQUFLLEdBQUcsR0FBR0EsR0FBRTtBQUFBLElBQzlNO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUNBLFFBQVEsWUFBWTtBQUNoQixXQUFPLEtBQUssUUFBUSxVQUFVO0FBQUEsRUFDbEM7QUFDSjtBQUNBLGlCQUFpQixvQkFBSSxRQUFPLEdBQUksc0JBQXNCLG9CQUFJLFdBQVcsZUFBZSxvQkFBSSxRQUFPO0FDdkV4RixTQUFTLFdBQVcsTUFBTTtBQUM3QixNQUFJLEtBQUssU0FBUyxJQUFJO0FBQ2xCLFVBQU0sSUFBSSxVQUFVLHVCQUF1QjtBQUFBLEVBQy9DO0FBQ0EsUUFBTSxTQUFTLEtBQUssS0FBSyxTQUFTLENBQUM7QUFDbkMsTUFBSSxTQUFTLElBQUk7QUFDYixVQUFNLElBQUksVUFBVSxrQ0FBa0M7QUFBQSxFQUMxRDtBQUNBLFFBQU0sU0FBUyxLQUFLLFNBQVM7QUFDN0IsV0FBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEtBQUs7QUFDN0IsUUFBSSxLQUFLLFNBQVMsQ0FBQyxNQUFNLFFBQVE7QUFDN0IsWUFBTSxJQUFJLFVBQVUsNkJBQTZCO0FBQUEsSUFDckQ7QUFBQSxFQUNKO0FBQ0EsU0FBTyxJQUFJLFdBQVcsS0FBSyxTQUFTLEdBQUcsTUFBTSxDQUFDO0FBQ2xEO0FDcEJPLFNBQVMsY0FBYyxXQUFXO0FBQ3JDLE1BQUksT0FBUSxjQUFlLFlBQVksQ0FBQyxVQUFVLFdBQVcsSUFBSSxHQUFHO0FBQ2hFLGdCQUFZLE9BQU87QUFBQSxFQUN2QjtBQUNBLFNBQU8sYUFBYSxTQUFTO0FBQ2pDO0FBQ08sU0FBU3dJLE9BQUssT0FBTyxRQUFRO0FBQ2hDLFVBQVEsT0FBTyxLQUFLO0FBQ3BCLFNBQU8sTUFBTSxTQUFTLFFBQVE7QUFDMUIsWUFBUSxNQUFNO0FBQUEsRUFDbEI7QUFDQSxTQUFPO0FBQ1g7QUFDTyxTQUFTLFlBQVksVUFBVTtBQUNsQyxNQUFJLE9BQVEsYUFBYyxVQUFVO0FBQ2hDLFdBQU8sWUFBWSxVQUFVLE1BQU07QUFBQSxFQUN2QztBQUNBLFNBQU8sYUFBYSxRQUFRO0FBQ2hDO0FBQ08sU0FBUyxRQUFROUgsU0FBUSxPQUFPO0FBQ25DLFFBQU0sUUFBUSxNQUFNLE1BQU0sb0NBQW9DO0FBQzlELGlCQUFlLFNBQVMsTUFBTSxnQkFBZ0IsUUFBUSxLQUFLO0FBQzNELFFBQU0sT0FBTyxNQUFNLENBQUM7QUFDcEIsUUFBTSxPQUFPLE1BQU0sQ0FBQztBQUNwQixRQUFNLE9BQVEsTUFBTSxDQUFDLE1BQU07QUFDM0IsTUFBSSxNQUFNQTtBQUNWLGFBQVcsUUFBUSxLQUFLLFlBQVcsRUFBRyxNQUFNLEdBQUcsR0FBRztBQUU5QyxRQUFJLE1BQU0sUUFBUSxHQUFHLEdBQUc7QUFDcEIsVUFBSSxDQUFDLEtBQUssTUFBTSxVQUFVLEdBQUc7QUFDekI7QUFBQSxNQUNKO0FBQ0EsWUFBTSxJQUFJLFNBQVMsSUFBSSxDQUFDO0FBQUEsSUFDNUIsV0FDUyxPQUFRLFFBQVMsVUFBVTtBQUNoQyxVQUFJLFFBQVE7QUFDWixpQkFBVyxPQUFPLEtBQUs7QUFDbkIsWUFBSSxJQUFJLFlBQVcsTUFBTyxNQUFNO0FBQzVCLGtCQUFRLElBQUksR0FBRztBQUNmO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFDQSxZQUFNO0FBQUEsSUFDVixPQUNLO0FBQ0QsWUFBTTtBQUFBLElBQ1Y7QUFDQSxRQUFJLE9BQU8sTUFBTTtBQUNiO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDQSxpQkFBZSxDQUFDLFFBQVEsT0FBTyxNQUFNLDBCQUEwQixRQUFRLElBQUk7QUFDM0UsTUFBSSxRQUFRLE9BQU8sTUFBTTtBQUNyQixRQUFJLFNBQVMsT0FBTztBQUNoQixVQUFJLE9BQVEsUUFBUyxZQUFZLElBQUksTUFBTSxZQUFZLEdBQUc7QUFDdEQsZUFBTyxTQUFTLEdBQUc7QUFBQSxNQUN2QixXQUNTLE9BQU8sY0FBYyxHQUFHLEdBQUc7QUFDaEMsZUFBTztBQUFBLE1BQ1g7QUFBQSxJQUNKO0FBQ0EsUUFBSSxTQUFTLFVBQVU7QUFDbkIsVUFBSSxPQUFRLFFBQVMsWUFBWSxJQUFJLE1BQU0sYUFBYSxHQUFHO0FBQ3ZELGVBQU8sV0FBVyxHQUFHO0FBQUEsTUFDekI7QUFBQSxJQUNKO0FBQ0EsUUFBSSxTQUFTLFFBQVE7QUFDakIsVUFBSSxPQUFRLFFBQVMsVUFBVTtBQUMzQixlQUFPLGNBQWMsR0FBRztBQUFBLE1BQzVCO0FBQUEsSUFDSjtBQUNBLFFBQUksU0FBUyxXQUFXLE1BQU0sUUFBUSxHQUFHLEdBQUc7QUFDeEMsYUFBTztBQUFBLElBQ1g7QUFDQSxRQUFJLFNBQVMsT0FBUSxLQUFNO0FBQ3ZCLGFBQU87QUFBQSxJQUNYO0FBQ0EsbUJBQWUsT0FBTyx3QkFBd0IsSUFBSSxLQUFLLFFBQVEsSUFBSTtBQUFBLEVBQ3ZFO0FBQ0EsU0FBTztBQUNYO0FDbkVBLE1BQU0rSCxnQkFBYztBQUliLFNBQVMsZUFBZSxNQUFNO0FBQ2pDLE1BQUk7QUFDQSxVQUFNLE9BQU8sS0FBSyxNQUFNLElBQUk7QUFDNUIsVUFBTWpELFdBQVksS0FBSyxXQUFXLE9BQVEsU0FBUyxLQUFLLE9BQU8sSUFBSTtBQUNuRSxRQUFJQSxhQUFZLEdBQUc7QUFDZixhQUFPO0FBQUEsSUFDWDtBQUFBLEVBQ0osU0FDTyxPQUFPO0FBQUEsRUFBRTtBQUNoQixTQUFPO0FBQ1g7QUFDQSxTQUFTLFFBQVEsTUFBTSxLQUFLLFlBQVk7QUFDcEMsUUFBTSxTQUFTLFFBQVEsTUFBTSxzQkFBc0I7QUFDbkQsTUFBSSxXQUFXLGVBQWU7QUFDMUIsVUFBTSxLQUFLLFFBQVEsTUFBTSw4QkFBOEI7QUFDdkQsVUFBTSxTQUFTLElBQUksSUFBSSxLQUFLLEVBQUU7QUFDOUIsV0FBTyxRQUFRLE9BQU8sUUFBUSxVQUFVLENBQUM7QUFBQSxFQUM3QztBQUNBLFNBQU8sT0FBTyxzQkFBc0IseUJBQXlCO0FBQUEsSUFDekQsV0FBVztBQUFBLEVBQ25CLENBQUs7QUFDTDtBQUNBLFNBQVMsV0FBVyxNQUFNLE1BQU07QUFDNUIsUUFBTSxNQUFNLFNBQVMsSUFBSTtBQUN6QixRQUFNLGFBQWEsUUFBUSxNQUFNLHlCQUF5QjtBQUMxRCxRQUFNLGNBQWMsUUFBUSxVQUFVLE9BQU8sQ0FBQyxJQUFJLE1BQU0sSUFBSSxFQUFFLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQztBQUMzRixpQkFBZSxnQkFBZ0IsUUFBUSxNQUFNLG9CQUFvQixFQUFFLFlBQVcsR0FBSSxzQkFBc0IsWUFBWSxjQUFjO0FBQ2xJLFFBQU0sYUFBYSxRQUFRLE1BQU0sSUFBSSxNQUFNLEdBQUcsRUFBRSxHQUFHLFVBQVU7QUFDN0QsUUFBTSxVQUFVLGVBQWUsVUFBVTtBQUN6QyxNQUFJLEtBQUssU0FBUztBQUNkLFFBQUksUUFBUSxLQUFLLFFBQVEsWUFBVztBQUNwQyxRQUFJLENBQUMsTUFBTSxXQUFXLElBQUksR0FBRztBQUN6QixjQUFRLE9BQU87QUFBQSxJQUNuQjtBQUNBLG1CQUFlLFdBQVcsS0FBSyxNQUFNLFNBQVMsd0NBQXdDLFdBQVcsS0FBSyxPQUFPO0FBQUEsRUFDakg7QUFDQSxRQUFNLFVBQVUsRUFBRSxTQUFTO0FBRTNCLFFBQU1BLFdBQVUsUUFBUSxNQUFNLHlCQUF5QjtBQUN2RCxNQUFJQSxhQUFZLE9BQU87QUFDbkIsVUFBTSxjQUFjLElBQUksTUFBTSxJQUFJLEVBQUU7QUFDcEMsVUFBTSxxQkFBcUIsUUFBUSxNQUFNLG1DQUFtQztBQUM1RSxVQUFNLGFBQWEsUUFBUSxNQUFNLGdDQUFnQztBQUNqRSxVQUFNLGlCQUFpQixJQUFJLElBQUksYUFBYSxVQUFVO0FBQ3RELFlBQVEsV0FBVztBQUFBLE1BQ2YsTUFBTyxRQUFRLE1BQU0sc0JBQXNCLEtBQUtpRDtBQUFBQSxNQUNoRCxRQUFTLFFBQVEsTUFBTSx3QkFBd0IsS0FBSztBQUFBLE1BQ3BELFNBQVMsUUFBUSxTQUFTLGVBQWUsUUFBUSxrQkFBa0IsQ0FBQyxDQUFDO0FBQUEsSUFDakY7QUFBQSxFQUNJO0FBQ0EsU0FBTztBQUNYO0FBQ0EsU0FBUyxvQkFBb0IsTUFBTTtBQUMvQixRQUFNLE1BQU0sUUFBUSxNQUFNLG1CQUFtQjtBQUM3QyxNQUFJLE9BQU8sT0FBUSxRQUFTLFVBQVU7QUFDbEMsUUFBSSxJQUFJLFlBQVcsTUFBTyxVQUFVO0FBQ2hDLFlBQU0sT0FBTyxRQUFRLE1BQU0sNkJBQTZCO0FBQ3hELFlBQU03RixLQUFJLFFBQVEsTUFBTSx5QkFBeUI7QUFDakQsWUFBTSxJQUFJLFFBQVEsTUFBTSx5QkFBeUI7QUFDakQsWUFBTSxJQUFJLFFBQVEsTUFBTSx5QkFBeUI7QUFFakQscUJBQWVBLEtBQUksTUFBTUEsS0FBS0EsS0FBSSxPQUFRLEdBQUcsaUJBQWlCLFNBQVNBLEVBQUM7QUFDeEUscUJBQWUsSUFBSSxLQUFLLElBQUksR0FBRyxlQUFlLE9BQU8sR0FBRztBQUN4RCxZQUFNLFFBQVEsUUFBUSxNQUFNLDZCQUE2QjtBQUN6RCxxQkFBZSxVQUFVLElBQUkscUJBQXFCLGFBQWEsS0FBSztBQUNwRSxhQUFPLEVBQUUsTUFBTSxVQUFVLE1BQU0sR0FBQUEsSUFBRyxHQUFHLEdBQUcsT0FBTztJQUNuRCxXQUNTLElBQUksWUFBVyxNQUFPLFVBQVU7QUFDckMsWUFBTSxPQUFPLFFBQVEsTUFBTSw2QkFBNkI7QUFDeEQsWUFBTSxNQUFNLFFBQVEsTUFBTSw4QkFBOEI7QUFDeEQsWUFBTSxZQUFZLElBQUksTUFBTSxHQUFHLEVBQUUsSUFBRztBQUNwQyxxQkFBZSxjQUFjLFlBQVksY0FBYyxVQUFVLG1CQUFtQixXQUFXLEdBQUc7QUFDbEcsWUFBTSxRQUFRLFFBQVEsTUFBTSx5QkFBeUI7QUFDckQsWUFBTSxRQUFRLFFBQVEsTUFBTSw2QkFBNkI7QUFDekQscUJBQWUsVUFBVSxJQUFJLHFCQUFxQixhQUFhLEtBQUs7QUFDcEUsYUFBTyxFQUFFLE1BQU0sVUFBVSxNQUFNLE9BQU8sT0FBTztJQUNqRDtBQUFBLEVBQ0o7QUFDQSxpQkFBZSxPQUFPLHVDQUF1QyxPQUFPLEdBQUc7QUFDM0U7QUFhTyxTQUFTLHdCQUF3QixNQUFNLFdBQVc7QUFDckQsUUFBTSxPQUFPLEtBQUssTUFBTSxJQUFJO0FBQzVCLFFBQU0sV0FBVyxZQUFZLFNBQVM7QUFDdEMsUUFBTSxTQUFTLG9CQUFvQixJQUFJO0FBQ3ZDLE1BQUksT0FBTyxTQUFTLFVBQVU7QUFDMUIsVUFBTSxFQUFFLE1BQUE4RixPQUFNLE9BQU8sT0FBQUMsUUFBTyxVQUFTLElBQUs7QUFDMUMsVUFBTUMsT0FBTSxPQUFPLFVBQVVGLE9BQU0sT0FBT0MsUUFBTyxTQUFTO0FBQzFELFdBQU8sV0FBVyxNQUFNQyxJQUFHO0FBQUEsRUFDL0I7QUFDQSxTQUFPLE9BQU8sU0FBUyxVQUFVLHFCQUFxQixpQkFBaUIsRUFBRSxPQUFNLENBQUU7QUFDakYsUUFBTSxFQUFFLE1BQU0sR0FBQWhHLElBQUcsR0FBRyxHQUFHLE1BQUssSUFBSztBQUNqQyxRQUFNLE1BQU0sV0FBVyxVQUFVLE1BQU1BLElBQUcsR0FBRyxHQUFHLEtBQUs7QUFDckQsU0FBTyxXQUFXLE1BQU0sR0FBRztBQUMvQjtBQUNBLFNBQVN6QyxRQUFNLFVBQVU7QUFDckIsU0FBTyxJQUFJLFFBQVEsQ0FBQyxZQUFZO0FBQUUsZUFBVyxNQUFNO0FBQUUsY0FBTztBQUFBLElBQUksR0FBRyxRQUFRO0FBQUEsRUFBRyxDQUFDO0FBQ25GO0FBWU8sZUFBZSxvQkFBb0IsTUFBTSxXQUFXLFVBQVU7QUFDakUsUUFBTSxPQUFPLEtBQUssTUFBTSxJQUFJO0FBQzVCLFFBQU0sV0FBVyxZQUFZLFNBQVM7QUFDdEMsUUFBTSxTQUFTLG9CQUFvQixJQUFJO0FBQ3ZDLE1BQUksT0FBTyxTQUFTLFVBQVU7QUFDMUIsUUFBSSxVQUFVO0FBQ1YsZUFBUyxDQUFDO0FBQ1YsWUFBTUEsUUFBTSxDQUFDO0FBQUEsSUFDakI7QUFDQSxVQUFNLEVBQUUsTUFBQXVJLE9BQU0sT0FBTyxPQUFBQyxRQUFPLFVBQVMsSUFBSztBQUMxQyxVQUFNQyxPQUFNLE9BQU8sVUFBVUYsT0FBTSxPQUFPQyxRQUFPLFNBQVM7QUFDMUQsUUFBSSxVQUFVO0FBQ1YsZUFBUyxDQUFDO0FBQ1YsWUFBTXhJLFFBQU0sQ0FBQztBQUFBLElBQ2pCO0FBQ0EsV0FBTyxXQUFXLE1BQU15SSxJQUFHO0FBQUEsRUFDL0I7QUFDQSxTQUFPLE9BQU8sU0FBUyxVQUFVLHFCQUFxQixpQkFBaUIsRUFBRSxPQUFNLENBQUU7QUFDakYsUUFBTSxFQUFFLE1BQU0sR0FBQWhHLElBQUcsR0FBRyxHQUFHLE1BQUssSUFBSztBQUNqQyxRQUFNLE1BQU0sTUFBTSxPQUFPLFVBQVUsTUFBTUEsSUFBRyxHQUFHLEdBQUcsT0FBTyxRQUFRO0FBQ2pFLFNBQU8sV0FBVyxNQUFNLEdBQUc7QUFDL0I7QUFDQSxTQUFTLG9CQUFvQixTQUFTO0FBRWxDLFFBQU0sT0FBUSxRQUFRLFFBQVEsT0FBUSxTQUFTLFFBQVEsTUFBTSxjQUFjLElBQUksWUFBWSxFQUFFO0FBRTdGLE1BQUlBLEtBQUssS0FBSyxJQUFLLElBQUksR0FBRyxJQUFJO0FBQzlCLE1BQUksUUFBUSxRQUFRO0FBQ2hCLFFBQUksUUFBUSxPQUFPLEdBQUc7QUFDbEIsTUFBQUEsS0FBSSxRQUFRLE9BQU87QUFBQSxJQUN2QjtBQUNBLFFBQUksUUFBUSxPQUFPLEdBQUc7QUFDbEIsVUFBSSxRQUFRLE9BQU87QUFBQSxJQUN2QjtBQUNBLFFBQUksUUFBUSxPQUFPLEdBQUc7QUFDbEIsVUFBSSxRQUFRLE9BQU87QUFBQSxJQUN2QjtBQUFBLEVBQ0o7QUFDQSxpQkFBZSxPQUFRQSxPQUFPLFlBQVlBLEtBQUksS0FBSyxPQUFPLGNBQWNBLEVBQUMsTUFBTSxPQUFPQSxFQUFDLElBQUksT0FBT0EsS0FBSSxDQUFDLE9BQU8sT0FBTyxDQUFDLEdBQUcsOEJBQThCLGFBQWFBLEVBQUM7QUFDckssaUJBQWUsT0FBUSxNQUFPLFlBQVksSUFBSSxLQUFLLE9BQU8sY0FBYyxDQUFDLEdBQUcsOEJBQThCLGFBQWEsQ0FBQztBQUN4SCxpQkFBZSxPQUFRLE1BQU8sWUFBWSxJQUFJLEtBQUssT0FBTyxjQUFjLENBQUMsR0FBRyw4QkFBOEIsYUFBYSxDQUFDO0FBQ3hILFNBQU8sRUFBRSxNQUFNLFVBQVUsT0FBTyxJQUFJLE1BQU0sR0FBQUEsSUFBRyxHQUFHO0FBQ3BEO0FBQ0EsU0FBUyxpQkFBaUIsS0FBSyxLQUFLLFNBQVMsU0FBUztBQUNsRCxRQUFNLGFBQWEsU0FBUyxRQUFRLFlBQVksWUFBWTtBQUU1RCxRQUFNLEtBQU0sUUFBUSxNQUFNLE9BQVEsU0FBUyxRQUFRLElBQUksWUFBWSxJQUFJLFlBQVksRUFBRTtBQUNyRixpQkFBZSxHQUFHLFdBQVcsSUFBSSw2QkFBNkIsY0FBYyxRQUFRLEVBQUU7QUFFdEYsUUFBTSxhQUFjLFFBQVEsUUFBUSxPQUFRLFNBQVMsUUFBUSxNQUFNLGNBQWMsSUFBSSxZQUFZLEVBQUU7QUFDbkcsaUJBQWUsV0FBVyxXQUFXLElBQUksK0JBQStCLGdCQUFnQixRQUFRLEVBQUU7QUFJbEcsUUFBTSxhQUFhLElBQUksTUFBTSxHQUFHLEVBQUU7QUFDbEMsUUFBTSxZQUFZLElBQUksTUFBTSxJQUFJLEVBQUU7QUFFbEMsUUFBTSxTQUFTLElBQUksSUFBSSxZQUFZLEVBQUU7QUFDckMsUUFBTSxhQUFhLFNBQVMsT0FBTyxRQUFRLFVBQVUsQ0FBQztBQUV0RCxRQUFNLE1BQU0sVUFBVSxPQUFPLENBQUMsV0FBVyxVQUFVLENBQUMsQ0FBQztBQUVyRCxRQUFNLE9BQU87QUFBQSxJQUNULFNBQVMsUUFBUSxRQUFRLFVBQVUsQ0FBQyxFQUFFLFlBQVc7QUFBQSxJQUNqRCxJQUFJLE9BQU8sVUFBVTtBQUFBLElBQ3JCLFNBQVM7QUFBQSxJQUNULFFBQVE7QUFBQSxNQUNKLFFBQVE7QUFBQSxNQUNSLGNBQWM7QUFBQSxRQUNWLElBQUksUUFBUSxFQUFFLEVBQUUsVUFBVSxDQUFDO0FBQUEsTUFDM0M7QUFBQSxNQUNZLFlBQVksUUFBUSxVQUFVLEVBQUUsVUFBVSxDQUFDO0FBQUEsTUFDM0MsS0FBSztBQUFBLE1BQ0wsV0FBVztBQUFBLFFBQ1AsTUFBTSxRQUFRLElBQUksSUFBSSxFQUFFLFVBQVUsQ0FBQztBQUFBLFFBQ25DLEdBQUcsSUFBSTtBQUFBLFFBQ1AsT0FBTztBQUFBLFFBQ1AsR0FBRyxJQUFJO0FBQUEsUUFDUCxHQUFHLElBQUk7QUFBQSxNQUN2QjtBQUFBLE1BQ1ksS0FBSyxJQUFJLFVBQVUsQ0FBQztBQUFBLElBQ2hDO0FBQUEsRUFDQTtBQUVJLE1BQUksUUFBUSxVQUFVO0FBQ2xCLFVBQU0sU0FBVSxRQUFRLFVBQVUsT0FBUSxRQUFRLFNBQVMsVUFBVSxPQUFPO0FBQzVFLFVBQU0sT0FBTyxRQUFRLFNBQVMsUUFBUTZGO0FBQ3RDLFVBQU0sU0FBUyxRQUFRLFNBQVMsVUFBVTtBQUMxQyxVQUFNLGNBQWMsSUFBSSxNQUFNLElBQUksRUFBRTtBQUNwQyxVQUFNLFVBQVUsU0FBUyxRQUFRLFNBQVMsU0FBUywwQkFBMEI7QUFDN0UsVUFBTSxhQUFhLFlBQVksRUFBRTtBQUNqQyxVQUFNLGlCQUFpQixJQUFJLElBQUksYUFBYSxVQUFVO0FBQ3RELFVBQU0scUJBQXFCLFNBQVMsZUFBZSxRQUFRLE9BQU8sQ0FBQztBQUNuRSxVQUFNLE1BQU0sb0JBQUk7QUFDaEIsVUFBTSxZQUFhLElBQUksZUFBYyxJQUFLLE1BQ3RDRCxPQUFLLElBQUksWUFBVyxJQUFLLEdBQUcsQ0FBQyxJQUFJLE1BQ2pDQSxPQUFLLElBQUksY0FBYyxDQUFDLElBQUksTUFDNUJBLE9BQUssSUFBSSxlQUFlLENBQUMsSUFBSSxNQUM3QkEsT0FBSyxJQUFJLGlCQUFpQixDQUFDLElBQUksTUFDL0JBLE9BQUssSUFBSSxjQUFhLEdBQUksQ0FBQyxJQUFJO0FBQ25DLFVBQU0sZUFBZ0IsVUFBVSxZQUFZLE9BQU8sS0FBSztBQUN4RCxTQUFLLFVBQVUsSUFBSTtBQUFBLE1BQ2Y7QUFBQSxNQUFRO0FBQUEsTUFBYztBQUFBLE1BQU07QUFBQSxNQUM1QixpQkFBaUIsUUFBUSxVQUFVLEVBQUUsVUFBVSxDQUFDO0FBQUEsTUFDaEQsb0JBQW9CLFFBQVEsa0JBQWtCLEVBQUUsVUFBVSxDQUFDO0FBQUEsTUFDM0QsU0FBUztBQUFBLElBQ3JCO0FBQUEsRUFDSTtBQUNBLFNBQU8sS0FBSyxVQUFVLElBQUk7QUFDOUI7QUFTTyxTQUFTLHdCQUF3QixTQUFTLFVBQVUsU0FBUztBQUNoRSxNQUFJLFdBQVcsTUFBTTtBQUNqQixjQUFVLENBQUE7QUFBQSxFQUNkO0FBQ0EsUUFBTSxnQkFBZ0IsWUFBWSxRQUFRO0FBQzFDLFFBQU0sTUFBTSxvQkFBb0IsT0FBTztBQUN2QyxRQUFNLE1BQU0sV0FBVyxlQUFlLElBQUksTUFBTSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFO0FBQ3ZFLFNBQU8saUJBQWlCLFNBQVMsR0FBRyxHQUFHLEtBQUssU0FBUyxPQUFPO0FBQ2hFO0FBVU8sZUFBZSxvQkFBb0IsU0FBUyxVQUFVLFNBQVM7QUFDbEUsTUFBSSxXQUFXLE1BQU07QUFDakIsY0FBVSxDQUFBO0FBQUEsRUFDZDtBQUNBLFFBQU0sZ0JBQWdCLFlBQVksUUFBUTtBQUMxQyxRQUFNLE1BQU0sb0JBQW9CLE9BQU87QUFDdkMsUUFBTSxNQUFNLE1BQU0sT0FBTyxlQUFlLElBQUksTUFBTSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLFFBQVEsZ0JBQWdCO0FBQ25HLFNBQU8saUJBQWlCLFNBQVMsR0FBRyxHQUFHLEtBQUssU0FBUyxPQUFPO0FBQ2hFO0FDN1FZLE1BQUMsY0FBYztBQUUzQixNQUFNLGVBQWUsSUFBSSxXQUFXLENBQUMsSUFBSSxLQUFLLEtBQUssSUFBSSxLQUFLLEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSyxLQUFLLEdBQUcsQ0FBQztBQUM3RixNQUFNLGNBQWM7QUFDcEIsTUFBTSxJQUFJLE9BQU8sb0VBQW9FO0FBQ3JGLE1BQU0sVUFBVTtBQUNoQixTQUFTLEtBQUssT0FBTyxRQUFRO0FBQ3pCLE1BQUksU0FBUztBQUNiLFNBQU8sT0FBTztBQUNWLGFBQVMsUUFBUSxRQUFRLEVBQUUsSUFBSTtBQUMvQixZQUFRLEtBQUssTUFBTSxRQUFRLEVBQUU7QUFBQSxFQUNqQztBQUNBLFNBQU8sT0FBTyxTQUFTLFNBQVMsR0FBRztBQUMvQixhQUFTLE1BQU07QUFBQSxFQUNuQjtBQUNBLFNBQU8sT0FBTztBQUNsQjtBQUNBLFNBQVMsa0JBQWtCbEosU0FBUTtBQUMvQixRQUFNLFFBQVEsU0FBU0EsT0FBTTtBQUM3QixRQUFNLFFBQVEsVUFBVSxPQUFPLE9BQU8sS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQ25ELFFBQU1ILFNBQVEsT0FBTyxDQUFDLE9BQU8sS0FBSyxDQUFDO0FBQ25DLFNBQU8sYUFBYUEsTUFBSztBQUM3QjtBQUNBLE1BQU0sU0FBUyxDQUFBO0FBQ2YsU0FBUyxNQUFNLE9BQU8sV0FBVyxXQUFXLFlBQVk7QUFDcEQsUUFBTSxPQUFPLElBQUksV0FBVyxFQUFFO0FBQzlCLE1BQUksUUFBUSxhQUFhO0FBQ3JCLFdBQU8sY0FBYyxNQUFNLHdDQUF3Qyx5QkFBeUI7QUFBQSxNQUN4RixXQUFXO0FBQUEsSUFDdkIsQ0FBUztBQUVELFNBQUssSUFBSSxTQUFTLFVBQVUsR0FBRyxDQUFDO0FBQUEsRUFDcEMsT0FDSztBQUVELFNBQUssSUFBSSxTQUFTLFNBQVMsQ0FBQztBQUFBLEVBQ2hDO0FBRUEsV0FBUyxJQUFJLElBQUksS0FBSyxHQUFHLEtBQUssR0FBRztBQUM3QixTQUFLLE1BQU0sS0FBSyxFQUFFLElBQU0sU0FBVSxLQUFLLElBQU07QUFBQSxFQUNqRDtBQUNBLFFBQU0sSUFBSSxTQUFTLFlBQVksVUFBVSxXQUFXLElBQUksQ0FBQztBQUN6RCxTQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sR0FBRyxFQUFFLEdBQUcsSUFBSSxFQUFFLE1BQU0sRUFBRSxFQUFDO0FBQ2hEO0FBQ0EsU0FBUyxXQUFXLE1BQU0sTUFBTTtBQUM1QixRQUFNLGFBQWEsS0FBSyxNQUFNLEdBQUc7QUFDakMsaUJBQWUsV0FBVyxTQUFTLEdBQUcsZ0JBQWdCLFFBQVEsSUFBSTtBQUNsRSxNQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUs7QUFDdkIsbUJBQWUsS0FBSyxVQUFVLEdBQUcsdUZBQXVGLEtBQUssS0FBSyxJQUFJLFFBQVEsSUFBSTtBQUNsSixlQUFXLE1BQUs7QUFBQSxFQUNwQjtBQUNBLE1BQUksU0FBUztBQUNiLFdBQVMsSUFBSSxHQUFHLElBQUksV0FBVyxRQUFRLEtBQUs7QUFDeEMsVUFBTSxZQUFZLFdBQVcsQ0FBQztBQUM5QixRQUFJLFVBQVUsTUFBTSxXQUFXLEdBQUc7QUFDOUIsWUFBTSxRQUFRLFNBQVMsVUFBVSxVQUFVLEdBQUcsVUFBVSxTQUFTLENBQUMsQ0FBQztBQUNuRSxxQkFBZSxRQUFRLGFBQWEsc0JBQXNCLFFBQVEsQ0FBQyxLQUFLLFNBQVM7QUFDakYsZUFBUyxPQUFPLFlBQVksY0FBYyxLQUFLO0FBQUEsSUFDbkQsV0FDUyxVQUFVLE1BQU0sVUFBVSxHQUFHO0FBQ2xDLFlBQU0sUUFBUSxTQUFTLFNBQVM7QUFDaEMscUJBQWUsUUFBUSxhQUFhLHNCQUFzQixRQUFRLENBQUMsS0FBSyxTQUFTO0FBQ2pGLGVBQVMsT0FBTyxZQUFZLEtBQUs7QUFBQSxJQUNyQyxPQUNLO0FBQ0QscUJBQWUsT0FBTywwQkFBMEIsUUFBUSxDQUFDLEtBQUssU0FBUztBQUFBLElBQzNFO0FBQUEsRUFDSjtBQUNBLFNBQU87QUFDWDtBQVNPLE1BQU0sZ0JBQU4sTUFBTSxzQkFBcUIsV0FBVztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBa0R6QyxZQUFZLE9BQU8sWUFBWSxtQkFBbUIsV0FBVyxNQUFNLE9BQU8sT0FBTyxVQUFVLFVBQVU7QUFDakcsVUFBTSxZQUFZLFFBQVE7QUFuRDNCO0FBSUg7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNSSxrQkFBYyxPQUFPLFFBQVEsY0FBYztBQUMzQyxxQkFBaUIsTUFBTSxFQUFFLFdBQVcsV0FBVyxvQkFBbUIsQ0FBRTtBQUNwRSxVQUFNLGNBQWMsVUFBVSxVQUFVLE9BQU8sS0FBSyxTQUFTLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDckUscUJBQWlCLE1BQU07QUFBQSxNQUNuQjtBQUFBLE1BQW1CO0FBQUEsTUFDbkI7QUFBQSxNQUFXO0FBQUEsTUFBTTtBQUFBLE1BQU87QUFBQSxJQUNwQyxDQUFTO0FBQ0QscUJBQWlCLE1BQU0sRUFBRSxTQUFRLENBQUU7QUFBQSxFQUN2QztBQUFBLEVBQ0EsUUFBUSxVQUFVO0FBQ2QsV0FBTyxJQUFJLGNBQWEsUUFBUSxLQUFLLFlBQVksS0FBSyxtQkFBbUIsS0FBSyxXQUFXLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSyxPQUFPLEtBQUssVUFBVSxRQUFRO0FBQUEsRUFDdko7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBb0JBLE1BQU0sUUFBUSxVQUFVLGtCQUFrQjtBQUN0QyxXQUFPLE1BQU0sb0JBQW9CLHNCQUFLLHFDQUFMLFlBQWlCLFVBQVUsRUFBRSxpQkFBZ0IsQ0FBRTtBQUFBLEVBQ3BGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVdBLFlBQVksVUFBVTtBQUNsQixXQUFPLHdCQUF3QixzQkFBSyxxQ0FBTCxZQUFpQixRQUFRO0FBQUEsRUFDNUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLElBQUksY0FBYztBQU1kLFdBQU8sS0FBSyxRQUFRLEtBQUssa0JBQWtCLHlCQUF5QixFQUFFLFdBQVcsY0FBYSxDQUFFO0FBQ2hHLFdBQU8sa0JBQWtCLE9BQU87QUFBQSxNQUM1QjtBQUFBLE1BQWMsS0FBSyxLQUFLLE9BQU8sQ0FBQztBQUFBLE1BQUcsS0FBSztBQUFBLE1BQ3hDLEtBQUssS0FBSyxPQUFPLENBQUM7QUFBQSxNQUFHLEtBQUs7QUFBQSxNQUMxQixPQUFPLENBQUMsUUFBUSxLQUFLLFVBQVUsQ0FBQztBQUFBLElBQzVDLENBQVMsQ0FBQztBQUFBLEVBQ047QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsVUFBVTtBQUFFLFdBQVEsS0FBSyxRQUFRO0FBQUEsRUFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFReEMsU0FBUztBQUNMLFdBQU8sSUFBSSxpQkFBaUIsUUFBUSxLQUFLLFNBQVMsS0FBSyxXQUFXLEtBQUssbUJBQW1CLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssT0FBTyxLQUFLLFFBQVE7QUFBQSxFQUM5SjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUEsWUFBWSxRQUFRO0FBQ2hCLFVBQU0sUUFBUSxVQUFVLFFBQVEsT0FBTztBQUN2QyxtQkFBZSxTQUFTLFlBQVksaUJBQWlCLFNBQVMsS0FBSztBQUVuRSxRQUFJLE9BQU8sS0FBSztBQUNoQixRQUFJLE1BQU07QUFDTixjQUFRLE9BQU8sUUFBUSxDQUFDO0FBQ3hCLFVBQUksUUFBUSxhQUFhO0FBQ3JCLGdCQUFRO0FBQUEsTUFDWjtBQUFBLElBQ0o7QUFDQSxVQUFNLEVBQUUsSUFBSSxHQUFFLElBQUssTUFBTSxPQUFPLEtBQUssV0FBVyxLQUFLLFdBQVcsS0FBSyxVQUFVO0FBQy9FLFVBQU0sS0FBSyxJQUFJLFdBQVcsU0FBUyxTQUFTLEVBQUUsSUFBSSxPQUFPLEtBQUssVUFBVSxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ25GLFdBQU8sSUFBSSxjQUFhLFFBQVEsSUFBSSxLQUFLLGFBQWEsUUFBUSxFQUFFLEdBQUcsTUFBTSxPQUFPLEtBQUssUUFBUSxHQUFHLEtBQUssVUFBVSxLQUFLLFFBQVE7QUFBQSxFQUNoSTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUEsV0FBVyxNQUFNO0FBQ2IsV0FBTyxXQUFXLE1BQU0sSUFBSTtBQUFBLEVBQ2hDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQWdCQSxPQUFPLGdCQUFnQixhQUFhO0FBQ2hDLFVBQU1BLFNBQVEsVUFBVSxhQUFhLFdBQVcsQ0FBQztBQUNqRCxtQkFBZUEsT0FBTSxXQUFXLE1BQU0sa0JBQWtCQSxPQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsTUFBTSxhQUFhLHdCQUF3QixlQUFlLGNBQWM7QUFDbEosVUFBTSxRQUFRQSxPQUFNLENBQUM7QUFDckIsVUFBTSxvQkFBb0IsUUFBUUEsT0FBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ25ELFVBQU0sUUFBUSxTQUFTLFFBQVFBLE9BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUU7QUFDbkUsVUFBTSxZQUFZLFFBQVFBLE9BQU0sTUFBTSxJQUFJLEVBQUUsQ0FBQztBQUM3QyxVQUFNLE1BQU1BLE9BQU0sTUFBTSxJQUFJLEVBQUU7QUFDOUIsWUFBUSxRQUFRQSxPQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBQztBQUFBLE1BRTlCLEtBQUs7QUFBQSxNQUNMLEtBQUssY0FBYztBQUNmLGNBQU0sWUFBWSxRQUFRLEdBQUc7QUFDN0IsZUFBTyxJQUFJLGlCQUFpQixRQUFRLGVBQWUsU0FBUyxHQUFHLFdBQVcsbUJBQW1CLFdBQVcsTUFBTSxPQUFPLE9BQU8sSUFBSTtBQUFBLE1BQ3BJO0FBQUEsTUFFQSxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQ0QsWUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHO0FBQ2Q7QUFBQSxRQUNKO0FBQ0EsZUFBTyxJQUFJLGNBQWEsUUFBUSxJQUFJLFdBQVcsSUFBSSxNQUFNLENBQUMsQ0FBQyxHQUFHLG1CQUFtQixXQUFXLE1BQU0sT0FBTyxPQUFPLE1BQU0sSUFBSTtBQUFBLElBQzFJO0FBQ1EsbUJBQWUsT0FBTywrQkFBK0IsZUFBZSxjQUFjO0FBQUEsRUFDdEY7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlBLE9BQU8sYUFBYSxVQUFVLE1BQU1pSixXQUFVO0FwR3RTbEQsUUFBQXBJO0FvR3VTUSxRQUFJLFlBQVksTUFBTTtBQUNsQixpQkFBVztBQUFBLElBQ2Y7QUFDQSxRQUFJLFFBQVEsTUFBTTtBQUNkLGFBQU87QUFBQSxJQUNYO0FBQ0EsUUFBSW9JLGFBQVksTUFBTTtBQUNsQixNQUFBQSxZQUFXLE9BQU87SUFDdEI7QUFDQSxVQUFNLFdBQVcsU0FBUyxZQUFZLFlBQVksRUFBRSxHQUFHLFVBQVVBLFNBQVE7QUFDekUsV0FBTyxnQkFBQXBJLE1BQUEsZUFBYSxtQ0FBYixLQUFBQSxLQUF1QixTQUFTLFlBQVcsR0FBSSxVQUFVLFdBQVcsSUFBSTtBQUFBLEVBQ25GO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxPQUFPLGFBQWEsVUFBVSxNQUFNO0FwR3RUeEMsUUFBQUE7QW9HdVRRLFFBQUksQ0FBQyxNQUFNO0FBQ1AsYUFBTztBQUFBLElBQ1g7QUFDQSxXQUFPLGdCQUFBQSxNQUFBLGVBQWEsbUNBQWIsS0FBQUEsS0FBdUIsU0FBUyxZQUFXLEdBQUksVUFBVSxXQUFXLElBQUk7QUFBQSxFQUNuRjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUEsT0FBTyxXQUFXLFFBQVEsVUFBVSxNQUFNb0ksV0FBVTtBcEcvVHhELFFBQUFwSTtBb0dnVVEsUUFBSSxZQUFZLE1BQU07QUFDbEIsaUJBQVc7QUFBQSxJQUNmO0FBQ0EsUUFBSSxRQUFRLE1BQU07QUFDZCxhQUFPO0FBQUEsSUFDWDtBQUNBLFFBQUlvSSxhQUFZLE1BQU07QUFDbEIsTUFBQUEsWUFBVyxPQUFPO0lBQ3RCO0FBQ0EsVUFBTSxXQUFXLFNBQVMsV0FBVyxRQUFRLFVBQVVBLFNBQVE7QUFDL0QsV0FBTyxnQkFBQXBJLE1BQUEsZUFBYSxtQ0FBYixLQUFBQSxLQUF1QixTQUFTLFlBQVcsR0FBSSxVQUFVLFdBQVcsSUFBSTtBQUFBLEVBQ25GO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxPQUFPLFNBQVMsTUFBTTtBcEcvVTFCLFFBQUFBO0FvR2dWUSxXQUFPLGdCQUFBQSxNQUFBLGVBQWEsbUNBQWIsS0FBQUEsS0FBdUIsTUFBTTtBQUFBLEVBQ3hDO0FBQ0o7QUFwUE87QUFnRUgsYUFBUSxXQUFHO0FBQ1AsUUFBTSxVQUFVLEVBQUUsU0FBUyxLQUFLLFNBQVMsWUFBWSxLQUFLO0FBQzFELFFBQU0sSUFBSSxLQUFLO0FBQ2YsTUFBSSxLQUFLLFFBQVEsS0FBSyxFQUFFLFNBQVMsV0FBVyxRQUFRLEVBQUUsYUFBYSxJQUFJO0FBQ25FLFlBQVEsV0FBVztBQUFBLE1BQ2YsTUFBTSxLQUFLO0FBQUEsTUFDWCxRQUFRO0FBQUEsTUFDUixTQUFTLEVBQUU7QUFBQSxJQUMzQjtBQUFBLEVBQ1E7QUFDQSxTQUFPO0FBQ1g7QUEzRUc7QUE2SkksY0FBUyxTQUFDLE9BQU8sVUFBVTtBQUM5QixpQkFBZSxZQUFZLEtBQUssR0FBRyxnQkFBZ0IsUUFBUSxZQUFZO0FBQ3ZFLFFBQU0sT0FBTyxTQUFTLE9BQU8sTUFBTTtBQUNuQyxpQkFBZSxLQUFLLFVBQVUsTUFBTSxLQUFLLFVBQVUsSUFBSSxnQkFBZ0IsUUFBUSxZQUFZO0FBQzNGLFFBQU0sSUFBSSxTQUFTLFlBQVksVUFBVSxjQUFjLElBQUksQ0FBQztBQUM1RCxRQUFNLGFBQWEsSUFBSSxXQUFXLFFBQVEsRUFBRSxNQUFNLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDekQsU0FBTyxJQUFJLGNBQWEsUUFBUSxZQUFZLGNBQWMsUUFBUSxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsS0FBSyxHQUFHLEdBQUcsVUFBVSxJQUFJO0FBQzdHO0FBcEtHLGFBQU0sZUFBTjtBQUFBLElBQU0sZUFBTjtBQTZQQSxNQUFNLHlCQUF5QixXQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUEyQzdDLFlBQVksT0FBTyxTQUFTLFdBQVcsbUJBQW1CLFdBQVcsTUFBTSxPQUFPLE9BQU8sVUFBVTtBQUMvRixVQUFNLFNBQVMsUUFBUTtBQXhDM0I7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUksa0JBQWMsT0FBTyxRQUFRLGtCQUFrQjtBQUMvQyxxQkFBaUIsTUFBTSxFQUFFLFVBQVMsQ0FBRTtBQUNwQyxVQUFNLGNBQWMsVUFBVSxVQUFVLE9BQU8sU0FBUyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQ2hFLHFCQUFpQixNQUFNO0FBQUEsTUFDbkI7QUFBQSxNQUFXO0FBQUEsTUFBYTtBQUFBLE1BQW1CO0FBQUEsTUFBVztBQUFBLE1BQU07QUFBQSxNQUFPO0FBQUEsSUFDL0UsQ0FBUztBQUFBLEVBQ0w7QUFBQSxFQUNBLFFBQVEsVUFBVTtBQUNkLFdBQU8sSUFBSSxpQkFBaUIsUUFBUSxLQUFLLFNBQVMsS0FBSyxXQUFXLEtBQUssbUJBQW1CLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssT0FBTyxRQUFRO0FBQUEsRUFDeko7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLElBQUksY0FBYztBQU1kLFdBQU8sS0FBSyxRQUFRLEtBQUssa0JBQWtCLHlCQUF5QixFQUFFLFdBQVcsY0FBYSxDQUFFO0FBQ2hHLFdBQU8sa0JBQWtCLE9BQU87QUFBQSxNQUM1QjtBQUFBLE1BQ0EsS0FBSyxLQUFLLE9BQU8sQ0FBQztBQUFBLE1BQ2xCLEtBQUs7QUFBQSxNQUNMLEtBQUssS0FBSyxPQUFPLENBQUM7QUFBQSxNQUNsQixLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsSUFDakIsQ0FBUyxDQUFDO0FBQUEsRUFDTjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxVQUFVO0FBQUUsV0FBUSxLQUFLLFFBQVE7QUFBQSxFQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJeEMsWUFBWSxRQUFRO0FBQ2hCLFVBQU0sUUFBUSxVQUFVLFFBQVEsT0FBTztBQUN2QyxtQkFBZSxTQUFTLFlBQVksaUJBQWlCLFNBQVMsS0FBSztBQUVuRSxRQUFJLE9BQU8sS0FBSztBQUNoQixRQUFJLE1BQU07QUFDTixjQUFRLE9BQU8sUUFBUSxDQUFDO0FBQ3hCLFVBQUksUUFBUSxhQUFhO0FBQ3JCLGdCQUFRO0FBQUEsTUFDWjtBQUFBLElBQ0o7QUFDQSxVQUFNLEVBQUUsSUFBSSxHQUFFLElBQUssTUFBTSxPQUFPLEtBQUssV0FBVyxLQUFLLFdBQVcsSUFBSTtBQUNwRSxVQUFNLEtBQUssV0FBVyxVQUFVLElBQUksS0FBSyxXQUFXLElBQUk7QUFDeEQsVUFBTSxVQUFVLGVBQWUsRUFBRTtBQUNqQyxXQUFPLElBQUksaUJBQWlCLFFBQVEsU0FBUyxJQUFJLEtBQUssYUFBYSxRQUFRLEVBQUUsR0FBRyxNQUFNLE9BQU8sS0FBSyxRQUFRLEdBQUcsS0FBSyxRQUFRO0FBQUEsRUFDOUg7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlBLFdBQVcsTUFBTTtBQUNiLFdBQU8sV0FBVyxNQUFNLElBQUk7QUFBQSxFQUNoQztBQUNKO0FBeUJPLFNBQVMsZUFBZSxRQUFRO0FBQ25DLFFBQU0sUUFBUSxVQUFVLFFBQVEsT0FBTztBQUN2QyxpQkFBZSxTQUFTLEtBQUssUUFBUSxhQUFhLHlCQUF5QixTQUFTLEtBQUs7QUFDekYsU0FBTyxhQUFhLEtBQUs7QUFDN0I7QUFVTyxTQUFTLHNCQUFzQixRQUFRO0FBQzFDLFFBQU0sUUFBUSxVQUFVLFFBQVEsT0FBTztBQUN2QyxpQkFBZSxTQUFTLEtBQUssUUFBUSxhQUFhLHlCQUF5QixTQUFTLEtBQUs7QUFDekYsU0FBTyxrQkFBa0IsS0FBSztBQUNsQztBQ3JlTyxTQUFTLGdCQUFnQixNQUFNO0FBQ2xDLE1BQUk7QUFDQSxVQUFNLE9BQU8sS0FBSyxNQUFNLElBQUk7QUFDNUIsUUFBSSxLQUFLLFNBQVM7QUFDZCxhQUFPO0FBQUEsSUFDWDtBQUFBLEVBQ0osU0FDTyxPQUFPO0FBQUEsRUFBRTtBQUNoQixTQUFPO0FBQ1g7QUFZTyxTQUFTLHFCQUFxQixNQUFNLFdBQVc7QUFDbEQsUUFBTSxPQUFPLEtBQUssTUFBTSxJQUFJO0FBQzVCLFFBQU0sV0FBVyxZQUFZLFNBQVM7QUFFdEMsUUFBTSxVQUFVLFdBQVcsUUFBUSxNQUFNLGlCQUFpQixDQUFDO0FBRTNELFFBQU0sVUFBVSxjQUFjLFFBQVEsTUFBTSxpQkFBaUIsQ0FBQztBQUM5RCxpQkFBZSxXQUFZLFFBQVEsU0FBUyxPQUFRLEdBQUcsbUJBQW1CLFFBQVEsSUFBSTtBQUN0RixRQUFNLE1BQU0sU0FBUyxPQUFPLFVBQVUsVUFBVSxLQUFNLElBQUksUUFBUSxDQUFDLEVBQUUsTUFBTSxHQUFHLEVBQUU7QUFDaEYsUUFBTSxLQUFLLFFBQVEsTUFBTSxHQUFHLEVBQUU7QUFDOUIsUUFBTSxnQkFBZ0IsUUFBUSxNQUFNLEVBQUU7QUFFdEMsUUFBTSxTQUFTLElBQUksSUFBSSxLQUFLLEVBQUU7QUFDOUIsUUFBTSxPQUFPLFdBQVcsU0FBUyxPQUFPLFFBQVEsYUFBYSxDQUFDLENBQUM7QUFFL0QsTUFBSSxVQUFVO0FBQ2QsV0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNsQyxlQUFXLE9BQU8sYUFBYSxLQUFLLENBQUMsQ0FBQztBQUFBLEVBQzFDO0FBQ0EsU0FBTyxFQUFFLFNBQVMsWUFBWSxHQUFHLE9BQU8sRUFBQztBQUM3QztBQzlDQSxTQUFTLE1BQU0sVUFBVTtBQUNyQixTQUFPLElBQUksUUFBUSxDQUFDLFlBQVk7QUFBRSxlQUFXLE1BQU07QUFBRSxjQUFPO0FBQUEsSUFBSSxHQUFHLFFBQVE7QUFBQSxFQUFHLENBQUM7QUFDbkY7QUFXTyxNQUFNLFVBQU4sTUFBTSxnQkFBZSxXQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtuQyxZQUFZLEtBQUssVUFBVTtBQUN2QixRQUFJLE9BQVEsUUFBUyxZQUFZLENBQUMsSUFBSSxXQUFXLElBQUksR0FBRztBQUNwRCxZQUFNLE9BQU87QUFBQSxJQUNqQjtBQUNBLFFBQUksYUFBYyxPQUFRLFFBQVMsV0FBWSxJQUFJLFdBQVcsR0FBRyxJQUFJO0FBQ3JFLFVBQU0sWUFBWSxRQUFRO0FBQUEsRUFDOUI7QUFBQSxFQUNBLFFBQVEsVUFBVTtBQUNkLFdBQU8sSUFBSSxRQUFPLEtBQUssWUFBWSxRQUFRO0FBQUEsRUFDL0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBUUEsTUFBTSxRQUFRLFVBQVUsa0JBQWtCO0FBQ3RDLFVBQU0sVUFBVSxFQUFFLFNBQVMsS0FBSyxTQUFTLFlBQVksS0FBSztBQUMxRCxXQUFPLE1BQU0sb0JBQW9CLFNBQVMsVUFBVSxFQUFFLGlCQUFnQixDQUFFO0FBQUEsRUFDNUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBV0EsWUFBWSxVQUFVO0FBQ2xCLFVBQU0sVUFBVSxFQUFFLFNBQVMsS0FBSyxTQUFTLFlBQVksS0FBSztBQUMxRCxXQUFPLHdCQUF3QixTQUFTLFFBQVE7QUFBQSxFQUNwRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFzQkEsYUFBYSxrQkFBa0IsTUFBTSxVQUFVLFVBQVU7QXRHakY3RCxRQUFBQTtBc0drRlEsUUFBSSxVQUFVO0FBQ2QsUUFBSSxlQUFlLElBQUksR0FBRztBQUN0QixnQkFBVSxNQUFNLG9CQUFvQixNQUFNLFVBQVUsUUFBUTtBQUFBLElBQ2hFLFdBQ1MsZ0JBQWdCLElBQUksR0FBRztBQUM1QixVQUFJLFVBQVU7QUFDVixpQkFBUyxDQUFDO0FBQ1YsY0FBTSxNQUFNLENBQUM7QUFBQSxNQUNqQjtBQUNBLGdCQUFVLHFCQUFxQixNQUFNLFFBQVE7QUFDN0MsVUFBSSxVQUFVO0FBQ1YsaUJBQVMsQ0FBQztBQUNWLGNBQU0sTUFBTSxDQUFDO0FBQUEsTUFDakI7QUFBQSxJQUNKO0FBQ0EsV0FBTyxnQkFBQUEsTUFBQSxTQUFPLGdDQUFQLEtBQUFBLEtBQW9CO0FBQUEsRUFDL0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBUUEsT0FBTyxzQkFBc0IsTUFBTSxVQUFVO0F0RzFHakQsUUFBQUE7QXNHMkdRLFFBQUksVUFBVTtBQUNkLFFBQUksZUFBZSxJQUFJLEdBQUc7QUFDdEIsZ0JBQVUsd0JBQXdCLE1BQU0sUUFBUTtBQUFBLElBQ3BELFdBQ1MsZ0JBQWdCLElBQUksR0FBRztBQUM1QixnQkFBVSxxQkFBcUIsTUFBTSxRQUFRO0FBQUEsSUFDakQsT0FDSztBQUNELHFCQUFlLE9BQU8sdUJBQXVCLFFBQVEsY0FBYztBQUFBLElBQ3ZFO0FBQ0EsV0FBTyxnQkFBQUEsTUFBQSxTQUFPLGdDQUFQLEtBQUFBLEtBQW9CO0FBQUEsRUFDL0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLE9BQU8sYUFBYSxVQUFVO0FBQzFCLFVBQU0sU0FBUyxhQUFhO0FBQzVCLFFBQUksVUFBVTtBQUNWLGFBQU8sT0FBTyxRQUFRLFFBQVE7QUFBQSxJQUNsQztBQUNBLFdBQU87QUFBQSxFQUNYO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxPQUFPLFdBQVcsUUFBUSxVQUFVO0FBQ2hDLFVBQU0sU0FBUyxhQUFhLFdBQVcsTUFBTTtBQUM3QyxRQUFJLFVBQVU7QUFDVixhQUFPLE9BQU8sUUFBUSxRQUFRO0FBQUEsSUFDbEM7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUNKO0FBMUhPO0FBd0NJLGlCQUFZLFNBQUMsU0FBUztBQUN6QixpQkFBZSxTQUFTLHVCQUF1QixRQUFRLGNBQWM7QUFDckUsTUFBSSxjQUFjLFdBQVcsUUFBUSxZQUFZLFFBQVEsU0FBUyxXQUFXLE1BQU07QUFDL0UsVUFBTSxXQUFXLFNBQVMsWUFBWSxRQUFRLFNBQVMsT0FBTztBQUM5RCxVQUFNNkksVUFBUyxhQUFhLGFBQWEsVUFBVSxRQUFRLFNBQVMsSUFBSTtBQUN4RSxRQUFJQSxRQUFPLFlBQVksUUFBUSxXQUFXQSxRQUFPLGVBQWUsUUFBUSxZQUFZO0FBQ2hGLGFBQU9BO0FBQUEsSUFDWDtBQUNBLFlBQVEsSUFBSSxrRkFBa0Y7QUFBQSxFQUNsRztBQUNBLFFBQU0sU0FBUyxJQUFJLFFBQU8sUUFBUSxVQUFVO0FBQzVDLGlCQUFlLE9BQU8sWUFBWSxRQUFRLFNBQVMsK0JBQStCLFFBQVEsY0FBYztBQUN4RyxTQUFPO0FBQ1g7QUFyREcsYUFBTSxTQUFOO0FBQUEsSUFBTSxTQUFOO0FDTEEsZUFBZSxLQUFLLEtBQUssTUFBTTtBQUNwQyxNQUFJO0FBQ0YsVUFBTSxPQUFPLFFBQVEsTUFBTSxJQUFJLEVBQUUsQ0FBQyxHQUFHLEdBQUcsS0FBSSxDQUFFO0FBQUEsRUFDaEQsU0FBUyxPQUFPO0FBQ2QsWUFBUSxNQUFNLHNCQUFzQixLQUFLO0FBQ3pDLFVBQU0sSUFBSSxNQUFNLHFCQUFxQjtBQUFBLEVBQ3ZDO0FBQ0Y7QUFPTyxlQUFlLEtBQUssS0FBSztBQUM5QixNQUFJO0FBQ0YsVUFBTSxTQUFTLE1BQU0sT0FBTyxRQUFRLE1BQU0sSUFBSSxHQUFHO0FBQ2pELFdBQU8sT0FBTyxHQUFHLEtBQUs7QUFBQSxFQUN4QixTQUFTLE9BQU87QUFDZCxZQUFRLE1BQU0sdUJBQXVCLEtBQUs7QUFDMUMsVUFBTSxJQUFJLE1BQU0scUJBQXFCO0FBQUEsRUFDdkM7QUFDRjtBQ3hCTyxTQUFTLGVBQWUsU0FBUztBQUN0QyxNQUFJO0FBQ0YsV0FBT0MsVUFBaUIsT0FBTztBQUFBLEVBQ2pDLFFBQVE7QUFDTixXQUFPO0FBQUEsRUFDVDtBQUNGO0FBcUJPLFNBQVMsZ0JBQWdCLFVBQVU7QUFDeEMsTUFBSTtBQUVGLFVBQU0sVUFBVSxTQUFTLEtBQUksRUFBRyxRQUFRLFFBQVEsR0FBRztBQUduRCxXQUFPQyxTQUFnQixnQkFBZ0IsT0FBTztBQUFBLEVBQ2hELFFBQVE7QUFDTixXQUFPO0FBQUEsRUFDVDtBQUNGO0FBT08sU0FBUyxrQkFBa0IsWUFBWTtBQUM1QyxNQUFJO0FBRUYsVUFBTSxNQUFNLFdBQVcsV0FBVyxJQUFJLElBQUksYUFBYSxPQUFPO0FBRzlELFFBQUksQ0FBQyxzQkFBc0IsS0FBSyxHQUFHLEdBQUc7QUFDcEMsYUFBTztBQUFBLElBQ1Q7QUFHQSxRQUFJQyxPQUFjLEdBQUc7QUFDckIsV0FBTztBQUFBLEVBQ1QsUUFBUTtBQUNOLFdBQU87QUFBQSxFQUNUO0FBQ0Y7QUFjTyxTQUFTLHlCQUF5QixVQUFVO0FBQ2pELFFBQU0sU0FBUyxDQUFBO0FBRWYsTUFBSSxDQUFDLFlBQVksU0FBUyxTQUFTLElBQUk7QUFDckMsV0FBTyxLQUFLLHlDQUF5QztBQUFBLEVBQ3ZEO0FBRUEsTUFBSSxDQUFDLFFBQVEsS0FBSyxRQUFRLEdBQUc7QUFDM0IsV0FBTyxLQUFLLHFEQUFxRDtBQUFBLEVBQ25FO0FBRUEsTUFBSSxDQUFDLFFBQVEsS0FBSyxRQUFRLEdBQUc7QUFDM0IsV0FBTyxLQUFLLHFEQUFxRDtBQUFBLEVBQ25FO0FBRUEsTUFBSSxDQUFDLFFBQVEsS0FBSyxRQUFRLEdBQUc7QUFDM0IsV0FBTyxLQUFLLDJDQUEyQztBQUFBLEVBQ3pEO0FBRUEsTUFBSSxDQUFDLHdDQUF3QyxLQUFLLFFBQVEsR0FBRztBQUMzRCxXQUFPLEtBQUssdUVBQXVFO0FBQUEsRUFDckY7QUFFQSxTQUFPO0FBQUEsSUFDTCxPQUFPLE9BQU8sV0FBVztBQUFBLElBQ3pCO0FBQUEsRUFDSjtBQUNBO0FBbUVPLFNBQVMsZUFBZSxTQUFTLFFBQVEsR0FBRztBQUNqRCxNQUFJLENBQUMsZUFBZSxPQUFPLEVBQUcsUUFBTztBQUNyQyxTQUFPLEdBQUcsUUFBUSxNQUFNLEdBQUcsUUFBUSxDQUFDLENBQUMsTUFBTSxRQUFRLE1BQU0sQ0FBQyxLQUFLLENBQUM7QUFDbEU7QUM5SkEsTUFBTSx1QkFBdUI7QUFBQTtBQUFBLEVBRTNCLEVBQUUsTUFBTSxNQUFNLFlBQVksS0FBUyxRQUFRLGFBQVk7QUFBQSxFQUN2RCxFQUFFLE1BQU0sTUFBTSxZQUFZLE1BQVMsUUFBUSxhQUFZO0FBQUEsRUFDdkQsRUFBRSxNQUFNLE1BQU0sWUFBWSxLQUFTLFFBQVEsYUFBWTtBQUFBO0FBQUEsRUFHdkQsRUFBRSxNQUFNLE1BQU0sWUFBWSxNQUFTLFFBQVEsdUJBQXNCO0FBQUEsRUFDakUsRUFBRSxNQUFNLE1BQU0sWUFBWSxRQUFTLFFBQVEsdUJBQXNCO0FBQUEsRUFDakUsRUFBRSxNQUFNLE1BQU0sWUFBWSxRQUFTLFFBQVEsdUJBQXNCO0FBQUEsRUFDakUsRUFBRSxNQUFNLE1BQU0sWUFBWSxRQUFTLFFBQVEsdUJBQXNCO0FBQUEsRUFDakUsRUFBRSxNQUFNLE1BQU0sWUFBWSxRQUFTLFFBQVEsdUJBQXNCO0FBQUEsRUFDakUsRUFBRSxNQUFNLE1BQU0sWUFBWSxRQUFTLFFBQVEsdUJBQXNCO0FBQUEsRUFDakUsRUFBRSxNQUFNLE1BQU0sWUFBWSxRQUFTLFFBQVEsdUJBQXNCO0FBQUEsRUFDakUsRUFBRSxNQUFNLE1BQU0sWUFBWSxLQUFTLFFBQVEsd0NBQXVDO0FBQ3BGO0FBU08sU0FBUyxnQ0FBZ0MsUUFBTyxvQkFBSSxLQUFJLEdBQUcsWUFBVyxHQUFJO0FBRS9FLFFBQU0sYUFBYSxxQkFBcUIsS0FBSyxPQUFLLEVBQUUsU0FBUyxJQUFJO0FBQ2pFLE1BQUksV0FBWSxRQUFPLFdBQVc7QUFHbEMsUUFBTSxTQUFTLHFCQUNaLE9BQU8sT0FBSyxFQUFFLE9BQU8sSUFBSSxFQUN6QixLQUFLLENBQUMsR0FBR3pJLE9BQU1BLEdBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDO0FBRXBDLFFBQU0sUUFBUSxxQkFDWCxPQUFPLE9BQUssRUFBRSxPQUFPLElBQUksRUFDekIsS0FBSyxDQUFDLEdBQUdBLE9BQU0sRUFBRSxPQUFPQSxHQUFFLElBQUksRUFBRSxDQUFDO0FBR3BDLE1BQUksQ0FBQyxPQUFRLFFBQU8scUJBQXFCLENBQUMsRUFBRTtBQUc1QyxNQUFJLENBQUMsTUFBTyxRQUFPLHFCQUFxQixxQkFBcUIsU0FBUyxDQUFDLEVBQUU7QUFHekUsUUFBTSxZQUFZLE1BQU0sT0FBTyxPQUFPO0FBQ3RDLFFBQU0saUJBQWlCLE1BQU0sYUFBYSxPQUFPO0FBQ2pELFFBQU0sZ0JBQWdCLE9BQU8sT0FBTyxRQUFRO0FBRTVDLFNBQU8sS0FBSyxNQUFNLE9BQU8sYUFBYSxLQUFLLElBQUksZ0JBQWdCLFlBQVksQ0FBQztBQUM5RTtBQUdBLE1BQU0sb0JBQW9CO0FBYTFCLGVBQWUsb0JBQW9CLFVBQVUsTUFBTSxZQUFZO0FBQzdELFFBQU0sVUFBVSxJQUFJO0FBQ3BCLFFBQU0saUJBQWlCLFFBQVEsT0FBTyxRQUFRO0FBRzlDLFFBQU0sY0FBYyxNQUFNLE9BQU8sT0FBTztBQUFBLElBQ3RDO0FBQUEsSUFDQTtBQUFBLElBQ0EsRUFBRSxNQUFNLFNBQVE7QUFBQSxJQUNoQjtBQUFBLElBQ0EsQ0FBQyxjQUFjLFdBQVc7QUFBQSxFQUM5QjtBQUdFLFNBQU8sTUFBTSxPQUFPLE9BQU87QUFBQSxJQUN6QjtBQUFBLE1BQ0UsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBO0FBQUEsTUFDQSxNQUFNO0FBQUEsSUFDWjtBQUFBLElBQ0k7QUFBQSxJQUNBLEVBQUUsTUFBTSxXQUFXLFFBQVEsSUFBRztBQUFBLElBQzlCO0FBQUEsSUFDQSxDQUFDLFdBQVcsU0FBUztBQUFBLEVBQ3pCO0FBQ0E7QUFTQSxlQUFlLGVBQWUsTUFBTSxVQUFVLGFBQWEsZ0NBQStCLEdBQUk7QUFDNUYsUUFBTSxVQUFVLElBQUk7QUFDcEIsUUFBTSxhQUFhLFFBQVEsT0FBTyxJQUFJO0FBU3RDLFFBQU0sT0FBTyxPQUFPLGdCQUFnQixJQUFJLFdBQVcsRUFBRSxDQUFDO0FBQ3RELFFBQU0sS0FBSyxPQUFPLGdCQUFnQixJQUFJLFdBQVcsRUFBRSxDQUFDO0FBR3BELFFBQU0sTUFBTSxNQUFNLG9CQUFvQixVQUFVLE1BQU0sVUFBVTtBQUdoRSxRQUFNLGtCQUFrQixNQUFNLE9BQU8sT0FBTztBQUFBLElBQzFDLEVBQUUsTUFBTSxXQUFXLEdBQU07QUFBQSxJQUN6QjtBQUFBLElBQ0E7QUFBQSxFQUNKO0FBR0UsUUFBTSxpQkFBaUIsSUFBSSxXQUFXLENBQUM7QUFDdkMsTUFBSSxTQUFTLGVBQWUsTUFBTSxFQUFFLFVBQVUsR0FBRyxZQUFZLEtBQUs7QUFHbEUsUUFBTSxXQUFXLElBQUk7QUFBQSxJQUNuQixJQUFJLEtBQUssU0FBUyxHQUFHLFNBQVMsZ0JBQWdCO0FBQUEsRUFDbEQ7QUFDRSxXQUFTLElBQUksZ0JBQWdCLENBQUM7QUFDOUIsV0FBUyxJQUFJLE1BQU0sQ0FBQztBQUNwQixXQUFTLElBQUksSUFBSSxJQUFJLEtBQUssTUFBTTtBQUNoQyxXQUFTLElBQUksSUFBSSxXQUFXLGVBQWUsR0FBRyxJQUFJLEtBQUssU0FBUyxHQUFHLE1BQU07QUFHekUsU0FBTyxLQUFLLE9BQU8sYUFBYSxHQUFHLFFBQVEsQ0FBQztBQUM5QztBQVVBLGVBQWUsZUFBZSxlQUFlLFVBQVU7QUFDckQsTUFBSTtBQUVGLFVBQU0sV0FBVyxXQUFXLEtBQUssS0FBSyxhQUFhLEdBQUcsT0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBRTFFLFFBQUk7QUFDSixRQUFJLE1BQU0sSUFBSTtBQUdkLFFBQUksU0FBUyxVQUFVLEdBQUc7QUFDeEIsWUFBTSxxQkFBcUIsSUFBSSxTQUFTLFNBQVMsUUFBUSxHQUFHLENBQUMsRUFBRSxVQUFVLEdBQUcsS0FBSztBQUlqRixVQUFJLHNCQUFzQixPQUFVLHNCQUFzQixLQUFTO0FBRWpFLHlCQUFpQjtBQUNqQixlQUFPLFNBQVMsTUFBTSxHQUFHLEVBQUU7QUFDM0IsYUFBSyxTQUFTLE1BQU0sSUFBSSxFQUFFO0FBQzFCLG9CQUFZLFNBQVMsTUFBTSxFQUFFO0FBQUEsTUFDL0IsT0FBTztBQUVMLHlCQUFpQjtBQUNqQixlQUFPLFNBQVMsTUFBTSxHQUFHLEVBQUU7QUFDM0IsYUFBSyxTQUFTLE1BQU0sSUFBSSxFQUFFO0FBQzFCLG9CQUFZLFNBQVMsTUFBTSxFQUFFO0FBQUEsTUFDL0I7QUFBQSxJQUNGLE9BQU87QUFDTCxZQUFNLElBQUksTUFBTSwrQkFBK0I7QUFBQSxJQUNqRDtBQUdBLFVBQU0sTUFBTSxNQUFNLG9CQUFvQixVQUFVLE1BQU0sY0FBYztBQUdwRSxVQUFNLGtCQUFrQixNQUFNLE9BQU8sT0FBTztBQUFBLE1BQzFDLEVBQUUsTUFBTSxXQUFXLEdBQU07QUFBQSxNQUN6QjtBQUFBLE1BQ0E7QUFBQSxJQUNOO0FBR0ksVUFBTSxVQUFVLElBQUk7QUFDcEIsV0FBTyxRQUFRLE9BQU8sZUFBZTtBQUFBLEVBQ3ZDLFNBQVMsT0FBTztBQUNkLFFBQUksTUFBTSxZQUFZLGlDQUFpQztBQUNyRCxZQUFNO0FBQUEsSUFDUjtBQUNBLFVBQU0sSUFBSSxNQUFNLDBEQUEwRDtBQUFBLEVBQzVFO0FBQ0Y7QUFPQSxTQUFTLDJCQUEyQixlQUFlO0FBQ2pELE1BQUk7QUFDRixVQUFNLFdBQVcsV0FBVyxLQUFLLEtBQUssYUFBYSxHQUFHLE9BQUssRUFBRSxXQUFXLENBQUMsQ0FBQztBQUUxRSxRQUFJLFNBQVMsVUFBVSxHQUFHO0FBQ3hCLFlBQU0scUJBQXFCLElBQUksU0FBUyxTQUFTLFFBQVEsR0FBRyxDQUFDLEVBQUUsVUFBVSxHQUFHLEtBQUs7QUFHakYsVUFBSSxzQkFBc0IsT0FBVSxzQkFBc0IsS0FBUztBQUNqRSxlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0Y7QUFHQSxXQUFPO0FBQUEsRUFDVCxTQUFTLE9BQU87QUFDZCxXQUFPO0FBQUEsRUFDVDtBQUNGO0FBR0EsTUFBTSxpQkFBaUI7QUFDdkIsTUFBTSxjQUFjO0FBS3BCLE1BQU0sa0JBQWtCLG9CQUFJO0FBT3JCLGVBQWUsdUJBQXVCO0FBQzNDLE1BQUk7QUFFRixVQUFNLGNBQWMsTUFBTSxLQUFLLFdBQVc7QUFDMUMsUUFBSSxhQUFhO0FBQ2YsYUFBTztBQUFBLElBQ1Q7QUFHQSxVQUFNLFlBQVksTUFBTSxLQUFLLGNBQWM7QUFDM0MsUUFBSSxDQUFDLFdBQVc7QUFDZCxhQUFPO0FBQUEsSUFDVDtBQUlBLFVBQU0sWUFBWTtBQUFBLE1BQ2hCLGdCQUFnQixxQkFBcUIsS0FBSyxJQUFHO0FBQUEsTUFDN0MsWUFBWSxDQUFDO0FBQUEsUUFDWCxJQUFJLHFCQUFxQixLQUFLLElBQUc7QUFBQSxRQUNqQyxVQUFVO0FBQUEsUUFDVixTQUFTO0FBQUE7QUFBQSxRQUNULG1CQUFtQjtBQUFBLFFBQ25CLFdBQVcsS0FBSyxJQUFHO0FBQUEsUUFDbkIsY0FBYztBQUFBLE1BQ3RCLENBQU87QUFBQSxJQUNQO0FBR0ksVUFBTSxLQUFLLGFBQWEsU0FBUztBQU1qQyxXQUFPO0FBQUEsRUFDVCxTQUFTLE9BQU87QUFDZCxZQUFRLE1BQU0sMkJBQTJCLEtBQUs7QUFDOUMsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQU1PLGVBQWUsZ0JBQWdCO0FBQ3BDLFFBQU0sY0FBYyxNQUFNLEtBQUssV0FBVztBQUMxQyxNQUFJLENBQUMsYUFBYTtBQUNoQixXQUFPO0FBQUEsTUFDTCxnQkFBZ0I7QUFBQSxNQUNoQixZQUFZLENBQUE7QUFBQSxJQUNsQjtBQUFBLEVBQ0U7QUFDQSxTQUFPO0FBQ1Q7QUFNTyxlQUFlLGtCQUFrQjtBQUN0QyxRQUFNLGNBQWMsTUFBTTtBQUMxQixNQUFJLENBQUMsWUFBWSxrQkFBa0IsWUFBWSxXQUFXLFdBQVcsR0FBRztBQUN0RSxXQUFPO0FBQUEsRUFDVDtBQUVBLFFBQU0sZUFBZSxZQUFZLFdBQVc7QUFBQSxJQUMxQyxPQUFLLEVBQUUsT0FBTyxZQUFZO0FBQUEsRUFDOUI7QUFFRSxTQUFPLGdCQUFnQjtBQUN6QjtBQU1PLGVBQWUsZUFBZTtBQUNuQyxRQUFNLGNBQWMsTUFBTTtBQUMxQixTQUFPLFlBQVksV0FBVyxTQUFTO0FBQ3pDO0FBTUEsU0FBUyxtQkFBbUI7QUFFMUIsUUFBTSxRQUFRLElBQUksV0FBVyxDQUFDO0FBQzlCLFNBQU8sZ0JBQWdCLEtBQUs7QUFDNUIsUUFBTSxZQUFZLE1BQU0sS0FBSyxPQUFPLFVBQVEsS0FBSyxTQUFTLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRTtBQUN0RSxTQUFPLFlBQVksS0FBSyxJQUFHLElBQUssTUFBTTtBQUN4QztBQU9BLGVBQWUsbUJBQW1CLFNBQVM7QUFDekMsUUFBTSxjQUFjLE1BQU07QUFDMUIsU0FBTyxZQUFZLFdBQVc7QUFBQSxJQUM1QixPQUFLLEVBQUUsV0FBVyxFQUFFLFFBQVEsWUFBVyxNQUFPLFFBQVEsWUFBVztBQUFBLEVBQ3JFO0FBQ0E7QUFNQSxlQUFlLDBCQUEwQjtBQUN2QyxRQUFNLGNBQWMsTUFBTTtBQUMxQixRQUFNLFFBQVEsWUFBWSxXQUFXO0FBQ3JDLFNBQU8sYUFBYSxRQUFRO0FBQzlCO0FBV08sZUFBZSxVQUFVLE1BQU0sTUFBTSxVQUFVLFdBQVcsTUFBTTtBQUVyRSxRQUFNLGdCQUFnQix5QkFBeUIsUUFBUTtBQUN2RCxNQUFJLENBQUMsY0FBYyxPQUFPO0FBQ3hCLFVBQU0sSUFBSSxNQUFNLGNBQWMsT0FBTyxLQUFLLElBQUksQ0FBQztBQUFBLEVBQ2pEO0FBRUEsTUFBSTtBQUNKLE1BQUksV0FBVztBQUVmLE1BQUk7QUFFRixZQUFRLE1BQUk7QUFBQSxNQUNWLEtBQUs7QUFDSCxpQkFBU3lJLE9BQWM7QUFDdkIsbUJBQVcsT0FBTyxTQUFTO0FBQzNCO0FBQUEsTUFFRixLQUFLO0FBQ0gsWUFBSSxDQUFDLEtBQUssWUFBWSxDQUFDLGdCQUFnQixLQUFLLFFBQVEsR0FBRztBQUNyRCxnQkFBTSxJQUFJLE1BQU0seUJBQXlCO0FBQUEsUUFDM0M7QUFDQSxjQUFNLGdCQUFnQixLQUFLLFNBQVMsS0FBSSxFQUFHLFFBQVEsUUFBUSxHQUFHO0FBQzlELGlCQUFTQSxPQUFjLFdBQVcsYUFBYTtBQUMvQztBQUFBLE1BRUYsS0FBSztBQUNILFlBQUksQ0FBQyxLQUFLLGNBQWMsQ0FBQyxrQkFBa0IsS0FBSyxVQUFVLEdBQUc7QUFDM0QsZ0JBQU0sSUFBSSxNQUFNLHFCQUFxQjtBQUFBLFFBQ3ZDO0FBQ0EsY0FBTSxNQUFNLEtBQUssV0FBVyxXQUFXLElBQUksSUFBSSxLQUFLLGFBQWEsT0FBTyxLQUFLO0FBQzdFLGlCQUFTLElBQUlBLE9BQWMsR0FBRztBQUM5QjtBQUFBLE1BRUY7QUFDRSxjQUFNLElBQUksTUFBTSwwQkFBMEIsSUFBSTtBQUFBLElBQ3REO0FBR0ksUUFBSSxNQUFNLG1CQUFtQixPQUFPLE9BQU8sR0FBRztBQUM1QyxZQUFNLElBQUksTUFBTSxnREFBZ0Q7QUFBQSxJQUNsRTtBQUdBLFVBQU0sb0JBQW9CO0FBSTFCLFVBQU0sZ0JBQWdCLE1BQU0sT0FBTyxRQUFRLFFBQVE7QUFHbkQsVUFBTSxrQkFBa0IsTUFBTSxlQUFlLGVBQWUsVUFBVSxpQkFBaUI7QUFHdkYsVUFBTSxnQkFBZ0IsWUFBWSxNQUFNO0FBR3hDLFVBQU0sY0FBYztBQUFBLE1BQ2xCLElBQUksaUJBQWdCO0FBQUEsTUFDcEIsVUFBVTtBQUFBLE1BQ1YsU0FBUyxPQUFPO0FBQUEsTUFDaEIsbUJBQW1CO0FBQUEsTUFDbkIsV0FBVyxLQUFLLElBQUc7QUFBQSxNQUNuQixjQUFjO0FBQUEsTUFDZCxxQkFBcUIsS0FBSyxJQUFHO0FBQUE7QUFBQSxNQUM3QjtBQUFBO0FBQUEsSUFDTjtBQUdJLFVBQU0sY0FBYyxNQUFNO0FBRzFCLFFBQUksWUFBWSxXQUFXLFVBQVUsSUFBSTtBQUN2QyxZQUFNLElBQUksTUFBTSw2RUFBNkU7QUFBQSxJQUMvRjtBQUdBLGdCQUFZLFdBQVcsS0FBSyxXQUFXO0FBR3ZDLFFBQUksWUFBWSxXQUFXLFdBQVcsR0FBRztBQUN2QyxrQkFBWSxpQkFBaUIsWUFBWTtBQUFBLElBQzNDO0FBR0EsVUFBTSxLQUFLLGFBQWEsV0FBVztBQUVuQyxZQUFRLElBQUksMEJBQTBCLGtCQUFrQixlQUFjLENBQUUsb0JBQW9CO0FBRzVGLFdBQU87QUFBQSxNQUNMLElBQUksWUFBWTtBQUFBLE1BQ2hCLFNBQVMsT0FBTztBQUFBLE1BQ2hCO0FBQUE7QUFBQSxJQUNOO0FBQUEsRUFDRSxTQUFTLE9BQU87QUFDZCxZQUFRLE1BQU0sd0JBQXdCLEtBQUs7QUFDM0MsVUFBTTtBQUFBLEVBQ1I7QUFDRjtBQVFPLGVBQWUsZ0JBQWdCLFVBQVU7QUFDOUMsUUFBTSxjQUFjLE1BQU07QUFHMUIsUUFBTSxTQUFTLFlBQVksV0FBVyxLQUFLLE9BQUssRUFBRSxPQUFPLFFBQVE7QUFDakUsTUFBSSxDQUFDLFFBQVE7QUFDWCxVQUFNLElBQUksTUFBTSxrQkFBa0I7QUFBQSxFQUNwQztBQUdBLGNBQVksaUJBQWlCO0FBQzdCLFFBQU0sS0FBSyxhQUFhLFdBQVc7QUFFbkMsU0FBTztBQUNUO0FBU08sZUFBZSxhQUFhLFVBQVUsYUFBYTtBQUN4RCxNQUFJLENBQUMsZUFBZSxZQUFZLEtBQUksRUFBRyxXQUFXLEdBQUc7QUFDbkQsVUFBTSxJQUFJLE1BQU0sMEJBQTBCO0FBQUEsRUFDNUM7QUFFQSxNQUFJLFlBQVksU0FBUyxJQUFJO0FBQzNCLFVBQU0sSUFBSSxNQUFNLHVDQUF1QztBQUFBLEVBQ3pEO0FBRUEsUUFBTSxjQUFjLE1BQU07QUFDMUIsUUFBTSxTQUFTLFlBQVksV0FBVyxLQUFLLE9BQUssRUFBRSxPQUFPLFFBQVE7QUFFakUsTUFBSSxDQUFDLFFBQVE7QUFDWCxVQUFNLElBQUksTUFBTSxrQkFBa0I7QUFBQSxFQUNwQztBQUVBLFNBQU8sV0FBVyxZQUFZO0FBQzlCLFFBQU0sS0FBSyxhQUFhLFdBQVc7QUFDckM7QUFTTyxlQUFlLGFBQWEsVUFBVSxVQUFVO0FBRXJELFFBQU0sYUFBYSxRQUFRO0FBRTNCLFFBQU0sY0FBYyxNQUFNO0FBQzFCLFFBQU0sY0FBYyxZQUFZLFdBQVcsVUFBVSxPQUFLLEVBQUUsT0FBTyxRQUFRO0FBRTNFLE1BQUksZ0JBQWdCLElBQUk7QUFDdEIsVUFBTSxJQUFJLE1BQU0sa0JBQWtCO0FBQUEsRUFDcEM7QUFHQSxjQUFZLFdBQVcsT0FBTyxhQUFhLENBQUM7QUFHNUMsTUFBSSxZQUFZLG1CQUFtQixVQUFVO0FBQzNDLGdCQUFZLGlCQUFpQixZQUFZLFdBQVcsU0FBUyxJQUN6RCxZQUFZLFdBQVcsQ0FBQyxFQUFFLEtBQzFCO0FBQUEsRUFDTjtBQUVBLFFBQU0sS0FBSyxhQUFhLFdBQVc7QUFDckM7QUFhTyxlQUFlLGFBQWEsVUFBVSxVQUFVLElBQUk7QUFDekQsUUFBTSxlQUFlLE1BQU07QUFFM0IsTUFBSSxDQUFDLGNBQWM7QUFDakIsVUFBTSxJQUFJLE1BQU0sb0RBQW9EO0FBQUEsRUFDdEU7QUFFQSxTQUFPLE1BQU0scUJBQXFCLGFBQWEsSUFBSSxVQUFVLE9BQU87QUFDdEU7QUFhTyxlQUFlLHFCQUFxQixVQUFVLFVBQVUsVUFBVSxDQUFBLEdBQUk7QUFDM0UsTUFBSTtBQUNGLFVBQU0sY0FBYyxNQUFNO0FBQzFCLFVBQU0sU0FBUyxZQUFZLFdBQVcsS0FBSyxPQUFLLEVBQUUsT0FBTyxRQUFRO0FBRWpFLFFBQUksQ0FBQyxRQUFRO0FBQ1gsWUFBTSxJQUFJLE1BQU0sa0JBQWtCO0FBQUEsSUFDcEM7QUFHQSxVQUFNLGVBQWUsTUFBTSxlQUFlLE9BQU8sbUJBQW1CLFFBQVE7QUFHNUUsVUFBTSxTQUFTLE1BQU1BLE9BQWM7QUFBQSxNQUNqQztBQUFBLE1BQ0E7QUFBQSxJQUNOO0FBR0ksUUFBSSxDQUFDLE9BQU8sU0FBUztBQUNuQixhQUFPLFVBQVUsT0FBTztBQUN4QixZQUFNLEtBQUssYUFBYSxXQUFXO0FBQUEsSUFDckM7QUFJQSxRQUFJLENBQUMsUUFBUSxhQUFhO0FBQ3hCLFlBQU0sb0JBQW9CLDJCQUEyQixPQUFPLGlCQUFpQjtBQUM3RSxZQUFNLHdCQUF3QjtBQUc5QixVQUFJLG9CQUFvQix1QkFBdUI7QUFFN0MsWUFBSSxnQkFBZ0IsSUFBSSxRQUFRLEdBQUc7QUFDakMsa0JBQVEsSUFBSSxpRUFBaUU7QUFHN0UsZ0JBQU0sZ0JBQWdCLElBQUksUUFBUTtBQUdsQyxnQkFBTSxxQkFBcUIsTUFBTTtBQUNqQyxnQkFBTSxnQkFBZ0IsbUJBQW1CLFdBQVcsS0FBSyxPQUFLLEVBQUUsT0FBTyxRQUFRO0FBRy9FLGlCQUFPO0FBQUEsWUFDTCxTQUFTLE9BQU87QUFBQSxZQUNoQjtBQUFBLFlBQ0EsVUFBVTtBQUFBLFlBQ1Ysa0JBQWtCO0FBQUEsWUFDbEIsaUJBQWlCO0FBQUEsWUFDakIseUJBQXlCO0FBQUEsVUFDckM7QUFBQSxRQUNRO0FBR0EsY0FBTSxrQkFBa0IsWUFBWTtBQUNsQyxjQUFJO0FBQ0Ysa0JBQU0sbUJBQW1CO0FBRXpCLG9CQUFRLElBQUkseUNBQXlDO0FBQ3JELG9CQUFRLElBQUksZUFBZSxrQkFBa0IsZUFBYyxDQUFFLGFBQWE7QUFDMUUsb0JBQVEsSUFBSSxtQkFBbUIsc0JBQXNCLGVBQWMsQ0FBRSxhQUFhO0FBR2xGLGdCQUFJLFFBQVEsZ0JBQWdCO0FBQzFCLHNCQUFRLGVBQWU7QUFBQSxnQkFDckI7QUFBQSxnQkFDQTtBQUFBLGdCQUNBLGlCQUFpQixLQUFLLE1BQU8sd0JBQXdCLE1BQVUsR0FBRztBQUFBO0FBQUEsY0FDbEYsQ0FBZTtBQUFBLFlBQ0g7QUFFQSxvQkFBUSxJQUFJLGlDQUFpQztBQUM3QyxrQkFBTSxlQUFlLEtBQUs7QUFJMUIsa0JBQU0sa0JBQWtCLE1BQU0sT0FBTyxRQUFRLFFBQVE7QUFHckQsa0JBQU0sZUFBZSxNQUFNO0FBQUEsY0FDekI7QUFBQSxjQUNBO0FBQUEsY0FDQTtBQUFBLFlBQ2Q7QUFHWSxrQkFBTSxvQkFBb0IsTUFBTTtBQUNoQyxrQkFBTSxlQUFlLGtCQUFrQixXQUFXLEtBQUssT0FBSyxFQUFFLE9BQU8sUUFBUTtBQUU3RSxnQkFBSSxDQUFDLGNBQWM7QUFDakIsb0JBQU0sSUFBSSxNQUFNLGlDQUFpQztBQUFBLFlBQ25EO0FBRUEseUJBQWEsb0JBQW9CO0FBQ2pDLHlCQUFhLHNCQUFzQixLQUFLO0FBQ3hDLHlCQUFhLG9CQUFvQjtBQUNqQyxrQkFBTSxLQUFLLGFBQWEsaUJBQWlCO0FBRXpDLGtCQUFNLGNBQWMsS0FBSyxJQUFHLElBQUs7QUFDakMsb0JBQVEsSUFBSSx3QkFBd0Isc0JBQXNCLGVBQWMsQ0FBRSxnQkFBZ0IsV0FBVyxLQUFLO0FBRTFHLG1CQUFPO0FBQUEsY0FDTDtBQUFBLGNBQ0EsaUJBQWlCO0FBQUEsWUFDL0I7QUFBQSxVQUNVLFVBQUM7QUFFQyw0QkFBZ0IsT0FBTyxRQUFRO0FBQUEsVUFDakM7QUFBQSxRQUNGO0FBR0Esd0JBQWdCLElBQUksVUFBVSxjQUFjO0FBRzVDLGNBQU0sZ0JBQWdCLE1BQU07QUFFNUIsZUFBTztBQUFBLFVBQ0wsU0FBUyxPQUFPO0FBQUEsVUFDaEI7QUFBQSxVQUNBLFVBQVU7QUFBQSxVQUNWLEdBQUc7QUFBQSxRQUNiO0FBQUEsTUFDTTtBQUFBLElBQ0Y7QUFFQSxXQUFPO0FBQUEsTUFDTCxTQUFTLE9BQU87QUFBQSxNQUNoQjtBQUFBLE1BQ0EsVUFBVTtBQUFBLElBQ2hCO0FBQUEsRUFDRSxTQUFTLE9BQU87QUFDZCxRQUFJLE1BQU0sUUFBUSxTQUFTLG9CQUFvQixLQUFLLE1BQU0sUUFBUSxTQUFTLG1CQUFtQixHQUFHO0FBQy9GLFlBQU0sSUFBSSxNQUFNLG9CQUFvQjtBQUFBLElBQ3RDO0FBQ0EsVUFBTSxJQUFJLE1BQU0sOEJBQThCLE1BQU0sT0FBTztBQUFBLEVBQzdEO0FBQ0Y7QUFRTyxlQUFlLGlCQUFpQixVQUFVO0FBRS9DLFFBQU0sRUFBRSxPQUFNLElBQUssTUFBTSxhQUFhLFVBQVUsRUFBRSxhQUFhLEtBQUksQ0FBRTtBQUNyRSxTQUFPLE9BQU87QUFDaEI7QUFRTyxlQUFlLGVBQWUsVUFBVTtBQUU3QyxRQUFNLEVBQUUsT0FBTSxJQUFLLE1BQU0sYUFBYSxVQUFVLEVBQUUsYUFBYSxLQUFJLENBQUU7QUFDckUsU0FBTyxPQUFPLFdBQVcsT0FBTyxTQUFTLFNBQVM7QUFDcEQ7QUFTTyxlQUFlLDBCQUEwQixVQUFVLFVBQVU7QUFDbEUsUUFBTSxFQUFFLFdBQVcsTUFBTSxxQkFBcUIsVUFBVSxVQUFVLEVBQUUsYUFBYSxLQUFJLENBQUU7QUFDdkYsU0FBTyxPQUFPO0FBQ2hCO0FBU08sZUFBZSx3QkFBd0IsVUFBVSxVQUFVO0FBQ2hFLFFBQU0sRUFBRSxXQUFXLE1BQU0scUJBQXFCLFVBQVUsVUFBVSxFQUFFLGFBQWEsS0FBSSxDQUFFO0FBQ3ZGLFNBQU8sT0FBTyxXQUFXLE9BQU8sU0FBUyxTQUFTO0FBQ3BEO0FBOENPLGVBQWUsbUJBQW1CLFVBQVUsVUFBVTtBQUMzRCxRQUFNLFNBQVMsTUFBTSxVQUFVLFlBQVksRUFBRSxZQUFZLFVBQVUsYUFBYTtBQUNoRixTQUFPO0FBQUEsSUFDTCxTQUFTLE9BQU87QUFBQSxFQUNwQjtBQUNBO0FBUU8sZUFBZSxxQkFBcUIsWUFBWSxVQUFVO0FBQy9ELFFBQU0sU0FBUyxNQUFNLFVBQVUsY0FBYyxFQUFFLGNBQWMsVUFBVSxhQUFhO0FBQ3BGLFNBQU87QUFBQSxJQUNMLFNBQVMsT0FBTztBQUFBLEVBQ3BCO0FBQ0E7QUMvMEJBLE1BQU0sZ0JBQWdCO0FBQUEsRUFDcEIscUJBQXFCO0FBQUEsSUFDbkI7QUFBQSxJQUNBO0FBQUEsRUFDSjtBQUFBLEVBQ0UsY0FBYztBQUFBLElBQ1o7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNKO0FBQUEsRUFDRSxZQUFZO0FBQUEsSUFDVjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0o7QUFBQSxFQUNFLFdBQVc7QUFBQSxJQUNUO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNKO0FBQ0E7QUFHQSxNQUFNLFlBQVksQ0FBQTtBQUdsQixNQUFNLGlCQUFpQixvQkFBSTtBQUczQixNQUFNLGdCQUFnQjtBQUFBLEVBQ3BCLGNBQWM7QUFBQTtBQUFBLEVBQ2Qsb0JBQW9CO0FBQUE7QUFBQSxFQUVwQixhQUFhO0FBQUE7QUFDZjtBQU1BLFNBQVMsc0JBQXNCLFVBQVU7QUFDdkMsUUFBTSxTQUFTLGVBQWUsSUFBSSxRQUFRLEtBQUssRUFBRSxVQUFVLEdBQUcsV0FBVyxLQUFLLElBQUcsR0FBSSxhQUFhLE1BQUs7QUFDdkcsU0FBTztBQUNQLFNBQU8sWUFBWSxLQUFLO0FBRXhCLE1BQUksT0FBTyxZQUFZLGNBQWMsY0FBYztBQUNqRCxXQUFPLGNBQWM7QUFDckIsWUFBUSxLQUFLLHFDQUFxQyxPQUFPLFFBQVEsY0FBYyxRQUFRLEVBQUU7QUFHekYsZUFBVyxNQUFNO0FBQ2YsWUFBTSxnQkFBZ0IsZUFBZSxJQUFJLFFBQVE7QUFDakQsVUFBSSxlQUFlO0FBQ2pCLHNCQUFjLGNBQWM7QUFDNUIsc0JBQWMsV0FBVztBQUN6QixnQkFBUSxJQUFJLDZDQUE2QyxRQUFRLEVBQUU7QUFBQSxNQUNyRTtBQUFBLElBQ0YsR0FBRyxjQUFjLGtCQUFrQjtBQUFBLEVBQ3JDO0FBRUEsaUJBQWUsSUFBSSxVQUFVLE1BQU07QUFDckM7QUFNQSxTQUFTLHNCQUFzQixVQUFVO0FBQ3ZDLFFBQU0sU0FBUyxlQUFlLElBQUksUUFBUSxLQUFLLEVBQUUsVUFBVSxHQUFHLFdBQVcsS0FBSyxJQUFHLEdBQUksYUFBYSxNQUFLO0FBQ3ZHLFNBQU8sV0FBVyxLQUFLLElBQUksR0FBRyxPQUFPLFdBQVcsQ0FBQztBQUNqRCxTQUFPLFlBQVksS0FBSztBQUN4QixpQkFBZSxJQUFJLFVBQVUsTUFBTTtBQUNyQztBQU9BLFNBQVMsc0JBQXNCLFVBQVU7QUFDdkMsUUFBTSxTQUFTLGVBQWUsSUFBSSxRQUFRO0FBQzFDLFVBQU8saUNBQVEsZ0JBQWU7QUFDaEM7QUE2Qk8sZUFBZSxZQUFZLFNBQVM7QUFDekMsUUFBTSxZQUFZLGNBQWMsT0FBTztBQUV2QyxNQUFJLENBQUMsV0FBVztBQUNkLFVBQU0sSUFBSSxNQUFNLG9CQUFvQixPQUFPLEVBQUU7QUFBQSxFQUMvQztBQUdBLE1BQUksVUFBVSxPQUFPLEdBQUc7QUFDdEIsUUFBSTtBQUVGLFlBQU0sVUFBVSxPQUFPLEVBQUU7QUFDekIsYUFBTyxVQUFVLE9BQU87QUFBQSxJQUMxQixTQUFTLE9BQU87QUFDZCxjQUFRLEtBQUssaUNBQWlDLE9BQU8sc0JBQXNCO0FBQzNFLGFBQU8sVUFBVSxPQUFPO0FBQUEsSUFDMUI7QUFBQSxFQUNGO0FBR0EsUUFBTSxnQkFBZ0IsTUFBTSxRQUFRLFNBQVMsSUFBSSxZQUFZLENBQUMsU0FBUztBQUV2RSxXQUFTLElBQUksR0FBRyxJQUFJLGNBQWMsUUFBUSxLQUFLO0FBQzdDLFVBQU0sV0FBVyxjQUFjLENBQUM7QUFHaEMsUUFBSSxzQkFBc0IsUUFBUSxHQUFHO0FBQ25DLGNBQVEsS0FBSyxxQ0FBcUMsUUFBUSxFQUFFO0FBQzVEO0FBQUEsSUFDRjtBQUVBLFFBQUk7QUFDRixjQUFRLElBQUksMkJBQTJCLElBQUksQ0FBQyxJQUFJLGNBQWMsTUFBTSxNQUFNLFFBQVEsRUFBRTtBQUdwRixZQUFNLFdBQVcsSUFBSUMsZ0JBQXVCLFFBQVE7QUFHcEQsWUFBTSxTQUFTO0FBR2YsZ0JBQVUsT0FBTyxJQUFJO0FBQ3JCLDRCQUFzQixRQUFRO0FBQzlCLGNBQVEsSUFBSSx3QkFBd0IsUUFBUSxFQUFFO0FBQzlDLGFBQU87QUFBQSxJQUVULFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSwyQkFBMkIsUUFBUSxJQUFJLE1BQU0sT0FBTztBQUNsRSw0QkFBc0IsUUFBUTtBQUc5QixVQUFJLElBQUksY0FBYyxTQUFTLEdBQUc7QUFDaEMsY0FBTSxJQUFJLFFBQVEsYUFBVyxXQUFXLFNBQVMsY0FBYyxXQUFXLENBQUM7QUFBQSxNQUM3RTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBR0EsUUFBTSxJQUFJLE1BQU0seUNBQXlDLE9BQU8sMENBQTBDO0FBQzVHO0FBaUNPLGVBQWUsUUFBUSxTQUFTLFFBQVEsU0FBUyxDQUFBLEdBQUk7QUFDMUQsUUFBTSxXQUFXLE1BQU0sWUFBWSxPQUFPO0FBQzFDLFNBQU8sTUFBTSxTQUFTLEtBQUssUUFBUSxNQUFNO0FBQzNDO0FBUU8sZUFBZSxXQUFXLFNBQVMsU0FBUztBQUNqRCxTQUFPLE1BQU0sUUFBUSxTQUFTLGtCQUFrQixDQUFDLFNBQVMsUUFBUSxDQUFDO0FBQ3JFO0FBUU8sZUFBZSxvQkFBb0IsU0FBUyxTQUFTO0FBQzFELFNBQU8sTUFBTSxRQUFRLFNBQVMsMkJBQTJCLENBQUMsU0FBUyxRQUFRLENBQUM7QUFDOUU7QUFPTyxlQUFlLFlBQVksU0FBUztBQUN6QyxTQUFPLE1BQU0sUUFBUSxTQUFTLGdCQUFnQixDQUFBLENBQUU7QUFDbEQ7QUFPTyxlQUFlLGVBQWUsU0FBUztBQUM1QyxTQUFPLE1BQU0sUUFBUSxTQUFTLG1CQUFtQixDQUFBLENBQUU7QUFDckQ7QUFTTyxlQUFlLGlCQUFpQixTQUFTLGFBQWEsc0JBQXNCLE9BQU87QUFDeEYsU0FBTyxNQUFNLFFBQVEsU0FBUyx3QkFBd0IsQ0FBQyxhQUFhLG1CQUFtQixDQUFDO0FBQzFGO0FBa0VPLGVBQWUsWUFBWSxTQUFTLGFBQWE7QUFDdEQsU0FBTyxNQUFNLFFBQVEsU0FBUyxtQkFBbUIsQ0FBQyxXQUFXLENBQUM7QUFDaEU7QUFRTyxlQUFlLEtBQUssU0FBUyxhQUFhO0FBQy9DLFNBQU8sTUFBTSxRQUFRLFNBQVMsWUFBWSxDQUFDLGFBQWEsUUFBUSxDQUFDO0FBQ25FO0FBUU8sZUFBZSxtQkFBbUIsU0FBUyxVQUFVO0FBQzFELFNBQU8sTUFBTSxRQUFRLFNBQVMsMEJBQTBCLENBQUMsUUFBUSxDQUFDO0FBQ3BFO0FBUU8sZUFBZSxzQkFBc0IsU0FBUyxRQUFRO0FBQzNELFNBQU8sTUFBTSxRQUFRLFNBQVMsNkJBQTZCLENBQUMsTUFBTSxDQUFDO0FBQ3JFO0FBUU8sZUFBZSxxQkFBcUIsU0FBUyxRQUFRO0FBQzFELFNBQU8sTUFBTSxRQUFRLFNBQVMsNEJBQTRCLENBQUMsTUFBTSxDQUFDO0FBQ3BFO0FBUU8sU0FBUyxjQUFjLFlBQVksV0FBVyxHQUFHO0FBQ3RELFFBQU0sVUFBVUMsWUFBbUIsVUFBVTtBQUM3QyxRQUFNLE1BQU0sV0FBVyxPQUFPO0FBQzlCLFNBQU8sSUFBSSxRQUFRLFFBQVE7QUFDN0I7IiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTEsOTIsOTMsOTQsOTUsOTYsOTcsOTgsOTksMTAwLDEwMSwxMDJdfQ==

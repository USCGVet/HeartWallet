const version = "6.15.0";
function checkType(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v, index) => {
    accum[keys[index]] = v;
    return accum;
  }, {});
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}
function stringify(value, seen) {
  if (value == null) {
    return "null";
  }
  if (seen == null) {
    seen = /* @__PURE__ */ new Set();
  }
  if (typeof value === "object") {
    if (seen.has(value)) {
      return "[Circular]";
    }
    seen.add(value);
  }
  if (Array.isArray(value)) {
    return "[ " + value.map((v) => stringify(v, seen)).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON(), seen);
  }
  switch (typeof value) {
    case "boolean":
    case "number":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code) {
  return error && error.code === code;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
const _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertNormalize(form) {
  assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
function _getBytes(value, name, copy2) {
  if (value instanceof Uint8Array) {
    if (copy2) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
const HexCharacters = "0123456789abcdef";
function hexlify(data) {
  const bytes2 = getBytes(data);
  let result = "0x";
  for (let i = 0; i < bytes2.length; i++) {
    const v = bytes2[i];
    result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes2 = getBytes(data);
  if (end != null && end > bytes2.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes2,
      length: bytes2.length,
      offset: end
    });
  }
  return hexlify(bytes2.slice(start == null ? 0 : start, end == null ? bytes2.length : end));
}
function stripZerosLeft(data) {
  let bytes2 = hexlify(data).substring(2);
  while (bytes2.startsWith("00")) {
    bytes2 = bytes2.substring(2);
  }
  return "0x" + bytes2;
}
function zeroPad(data, length, left) {
  const bytes2 = getBytes(data);
  assert(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes2),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes2, length - bytes2.length);
  } else {
    result.set(bytes2, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}
const BN_0$a = BigInt(0);
const BN_1$4 = BigInt(1);
const maxValue = 9007199254740991;
function fromTwos(_value, _width) {
  const value = getUint(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value >> width === BN_0$a, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value
  });
  if (value >> width - BN_1$4) {
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return -((~value & mask2) + BN_1$4);
  }
  return value;
}
function toTwos(_value, _width) {
  let value = getBigInt(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1$4 << width - BN_1$4;
  if (value < BN_0$a) {
    value = -value;
    assert(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return (~value & mask2) + BN_1$4;
  } else {
    assert(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
  }
  return value;
}
function mask(_value, _bits) {
  const value = getUint(_value, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1$4 << bits) - BN_1$4;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert(result >= BN_0$a, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
const Nibbles$1 = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles$1[v >> 4];
      result += Nibbles$1[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e) {
        assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value, _width) {
  const value = getUint(_value, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value) {
  const value = getUint(_value, "value");
  if (value === BN_0$a) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
let Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
}
const BN_0$9 = BigInt(0);
const BN_58 = BigInt(58);
function encodeBase58(_value) {
  const bytes2 = getBytes(_value);
  let value = toBigInt(bytes2);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i = 0; i < bytes2.length; i++) {
    if (bytes2[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_0$9;
  for (let i = 0; i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}
function decodeBase64(textData) {
  textData = atob(textData);
  const data = new Uint8Array(textData.length);
  for (let i = 0; i < textData.length; i++) {
    data[i] = textData.charCodeAt(i);
  }
  return getBytes(data);
}
function encodeBase64(_data) {
  const data = getBytes(_data);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}
class EventPayload {
  /**
   *  The event filter.
   */
  filter;
  /**
   *  The **EventEmitterable**.
   */
  emitter;
  #listener;
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter) {
    this.#listener = listener;
    defineProperties(this, { emitter, filter });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (this.#listener == null) {
      return;
    }
    await this.emitter.off(this.filter, this.#listener);
  }
}
function errorFunc(reason, offset, bytes2, output2, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1; o < bytes2.length; o++) {
      if (bytes2[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset, bytes2);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes2 = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes2.length) {
    const c = bytes2[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes2, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes2, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes2.length) {
      i += onError("OVERRUN", i - 1, bytes2, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes2[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes2, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function toUtf8CodePoints(str, form) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
function createGetUrl(options) {
  async function getUrl(req, _signal) {
    assert(_signal == null || !_signal.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let error = null;
    const controller = new AbortController();
    const timer = setTimeout(() => {
      error = makeError("request timeout", "TIMEOUT");
      controller.abort();
    }, req.timeout);
    if (_signal) {
      _signal.addListener(() => {
        error = makeError("request cancelled", "CANCELLED");
        controller.abort();
      });
    }
    const init2 = Object.assign({}, options, {
      method: req.method,
      headers: new Headers(Array.from(req)),
      body: req.body || void 0,
      signal: controller.signal
    });
    let resp;
    try {
      resp = await fetch(req.url, init2);
    } catch (_error) {
      clearTimeout(timer);
      if (error) {
        throw error;
      }
      throw _error;
    }
    clearTimeout(timer);
    const headers = {};
    resp.headers.forEach((value, key) => {
      headers[key.toLowerCase()] = value;
    });
    const respBody = await resp.arrayBuffer();
    const body = respBody == null ? null : new Uint8Array(respBody);
    return {
      statusCode: resp.status,
      statusMessage: resp.statusText,
      headers,
      body
    };
  }
  return getUrl;
}
const MAX_ATTEMPTS = 12;
const SLOT_INTERVAL = 250;
let defaultGetUrlFunc = createGetUrl();
const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
const reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let locked$5 = false;
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
const Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
const fetchSignals = /* @__PURE__ */ new WeakMap();
class FetchCancelSignal {
  #listeners;
  #cancelled;
  constructor(request) {
    this.#listeners = [];
    this.#cancelled = false;
    fetchSignals.set(request, () => {
      if (this.#cancelled) {
        return;
      }
      this.#cancelled = true;
      for (const listener of this.#listeners) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      this.#listeners = [];
    });
  }
  addListener(listener) {
    assert(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    this.#listeners.push(listener);
  }
  get cancelled() {
    return this.#cancelled;
  }
  checkSignal() {
    assert(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
class FetchRequest {
  #allowInsecure;
  #gzip;
  #headers;
  #method;
  #timeout;
  #url;
  #body;
  #bodyType;
  #creds;
  // Hooks
  #preflight;
  #process;
  #retry;
  #signal;
  #throttle;
  #getUrlFunc;
  /**
   *  The fetch URL to request.
   */
  get url() {
    return this.#url;
  }
  set url(url) {
    this.#url = String(url);
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (this.#body == null) {
      return null;
    }
    return new Uint8Array(this.#body);
  }
  set body(body) {
    if (body == null) {
      this.#body = void 0;
      this.#bodyType = void 0;
    } else if (typeof body === "string") {
      this.#body = toUtf8Bytes(body);
      this.#bodyType = "text/plain";
    } else if (body instanceof Uint8Array) {
      this.#body = body;
      this.#bodyType = "application/octet-stream";
    } else if (typeof body === "object") {
      this.#body = toUtf8Bytes(JSON.stringify(body));
      this.#bodyType = "application/json";
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (this.#method) {
      return this.#method;
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    this.#method = String(method).toUpperCase();
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, this.#headers);
    if (this.#creds) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`;
    }
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && this.#bodyType) {
      headers["content-type"] = this.#bodyType;
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key, value) {
    this.#headers[String(key).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    this.#headers = {};
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return this.#creds || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    this.#creds = `${username}:${password}`;
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return this.#gzip;
  }
  set allowGzip(value) {
    this.#gzip = !!value;
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!this.#allowInsecure;
  }
  set allowInsecureAuthentication(value) {
    this.#allowInsecure = !!value;
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return this.#timeout;
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    this.#timeout = timeout;
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return this.#preflight || null;
  }
  set preflightFunc(preflight) {
    this.#preflight = preflight;
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return this.#process || null;
  }
  set processFunc(process) {
    this.#process = process;
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return this.#retry || null;
  }
  set retryFunc(retry) {
    this.#retry = retry;
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return this.#getUrlFunc || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    this.#getUrlFunc = value;
  }
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url) {
    this.#url = String(url);
    this.#allowInsecure = false;
    this.#gzip = true;
    this.#headers = {};
    this.#method = "";
    this.#timeout = 3e5;
    this.#throttle = {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    };
    this.#getUrlFunc = null;
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      this.#throttle.slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      this.#throttle.maxAttempts = params.maxAttempts;
    }
  }
  async #send(attempt, expires, delay, _request, _response) {
    if (attempt >= this.#throttle.maxAttempts) {
      return _response.makeServerError("exceeded maximum retry limit");
    }
    assert(getTime$1() <= expires, "timeout", "TIMEOUT", {
      operation: "request.send",
      reason: "timeout",
      request: _request
    });
    if (delay > 0) {
      await wait(delay);
    }
    let req = this.clone();
    const scheme = (req.url.split(":")[0] || "").toLowerCase();
    if (scheme in Gateways) {
      const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));
      if (result instanceof FetchResponse) {
        let response2 = result;
        if (this.processFunc) {
          checkSignal(_request.#signal);
          try {
            response2 = await this.processFunc(req, response2);
          } catch (error) {
            if (error.throttle == null || typeof error.stall !== "number") {
              response2.makeServerError("error in post-processing function", error).assertOk();
            }
          }
        }
        return response2;
      }
      req = result;
    }
    if (this.preflightFunc) {
      req = await this.preflightFunc(req);
    }
    const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));
    let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
    if (response.statusCode === 301 || response.statusCode === 302) {
      try {
        const location = response.headers.location || "";
        return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
      } catch (error) {
      }
      return response;
    } else if (response.statusCode === 429) {
      if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
        const retryAfter = response.headers["retry-after"];
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
          delay2 = parseInt(retryAfter);
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    if (this.processFunc) {
      checkSignal(_request.#signal);
      try {
        response = await this.processFunc(req, response);
      } catch (error) {
        if (error.throttle == null || typeof error.stall !== "number") {
          response.makeServerError("error in post-processing function", error).assertOk();
        }
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (error.stall >= 0) {
          delay2 = error.stall;
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    return response;
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    this.#signal = new FetchCancelSignal(this);
    return this.#send(0, getTime$1() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    req.#headers = Object.assign({}, this.#headers);
    if (this.#body) {
      req.#body = new Uint8Array(this.#body);
    }
    req.#bodyType = this.#bodyType;
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new FetchRequest(this.url);
    clone.#method = this.#method;
    if (this.#body) {
      clone.#body = this.#body;
    }
    clone.#bodyType = this.#bodyType;
    clone.#headers = Object.assign({}, this.#headers);
    clone.#creds = this.#creds;
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    clone.#preflight = this.#preflight;
    clone.#process = this.#process;
    clone.#retry = this.#retry;
    clone.#throttle = Object.assign({}, this.#throttle);
    clone.#getUrlFunc = this.#getUrlFunc;
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked$5 = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked$5) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl) {
    if (locked$5) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl(options);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
}
class FetchResponse {
  #statusCode;
  #statusMessage;
  #headers;
  #body;
  #request;
  #error;
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return this.#statusCode;
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return this.#statusMessage;
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, this.#headers);
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return this.#body == null ? null : new Uint8Array(this.#body);
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return this.#body == null ? "" : toUtf8String(this.#body);
    } catch (error) {
      assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  constructor(statusCode, statusMessage, headers, body, request) {
    this.#statusCode = statusCode;
    this.#statusMessage = statusMessage;
    this.#headers = Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {});
    this.#body = body == null ? null : new Uint8Array(body);
    this.#request = request || null;
    this.#error = { message: "" };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || void 0);
    response.#error = { message, error };
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall2) {
    if (stall2 == null) {
      stall2 = -1;
    } else {
      assertArgument(Number.isInteger(stall2) && stall2 >= 0, "invalid stall timeout", "stall", stall2);
    }
    const error = new Error(message || "throttling requests");
    defineProperties(error, { stall: stall2, throttle: true });
    throw error;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return this.#request;
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = this.#error;
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (this.#body) {
        responseBody = toUtf8String(this.#body);
      }
    } catch (e) {
    }
    assert(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
}
function getTime$1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
const BN_N1 = BigInt(-1);
const BN_0$8 = BigInt(0);
const BN_1$3 = BigInt(1);
const BN_5 = BigInt(5);
const _guard$5 = {};
let Zeros$1 = "0000";
while (Zeros$1.length < 80) {
  Zeros$1 += Zeros$1;
}
function getTens(decimals) {
  let result = Zeros$1;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format, safeOp) {
  const width = BigInt(format.width);
  if (format.signed) {
    const limit = BN_1$3 << width - BN_1$3;
    assert(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_0$8) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    const limit = BN_1$3 << width;
    assert(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_1$3;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed2 = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") ;
    else if (value === "ufixed") {
      signed2 = false;
    } else {
      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value);
      signed2 = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    const v = value;
    const check = (key, type, defaultValue) => {
      if (v[key] == null) {
        return defaultValue;
      }
      assertArgument(typeof v[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
      return v[key];
    };
    signed2 = check("signed", "boolean", signed2);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed: signed2, width, decimals, name };
}
function toString(val, decimals) {
  let negative = "";
  if (val < BN_0$8) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros$1 + str;
  }
  const index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
class FixedNumber {
  /**
   *  The specific fixed-point arithmetic field for this value.
   */
  format;
  #format;
  // The actual value (accounting for decimals)
  #val;
  // A base-10 value to multiple values by to maintain the magnitude
  #tens;
  /**
   *  This is a property so console.log shows a human-meaningful value.
   *
   *  @private
   */
  _value;
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(guard, value, format) {
    assertPrivate(guard, _guard$5, "FixedNumber");
    this.#val = value;
    this.#format = format;
    const _value = toString(value, format.decimals);
    defineProperties(this, { format: format.name, _value });
    this.#tens = getTens(format.decimals);
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return this.#format.signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return this.#format.width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return this.#format.decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return this.#val;
  }
  #checkFormat(other) {
    assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
  }
  #checkValue(val, safeOp) {
    val = checkValue(val, this.#format, safeOp);
    return new FixedNumber(_guard$5, val, this.#format);
  }
  #add(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val + o.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(other) {
    return this.#add(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(other) {
    return this.#add(other, "add");
  }
  #sub(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val - o.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(other) {
    return this.#sub(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(other) {
    return this.#sub(other, "sub");
  }
  #mul(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val * o.#val / this.#tens, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(other) {
    return this.#mul(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(other) {
    return this.#mul(other, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(other) {
    this.#checkFormat(other);
    const value = this.#val * other.#val;
    assert(value % this.#tens === BN_0$8, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / this.#tens, "mulSignal");
  }
  #div(o, safeOp) {
    assert(o.#val !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(o);
    return this.#checkValue(this.#val * this.#tens / o.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(other) {
    return this.#div(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(other) {
    return this.#div(other, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(other) {
    assert(other.#val !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(other);
    const value = this.#val * this.#tens;
    assert(value % other.#val === BN_0$8, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / other.#val, "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(other) {
    let a = this.value, b2 = other.value;
    const delta = this.decimals - other.decimals;
    if (delta > 0) {
      b2 *= getTens(delta);
    } else if (delta < 0) {
      a *= getTens(-delta);
    }
    if (a < b2) {
      return -1;
    }
    if (a > b2) {
      return 1;
    }
    return 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(other) {
    return this.cmp(other) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(other) {
    return this.cmp(other) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(other) {
    return this.cmp(other) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(other) {
    return this.cmp(other) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(other) {
    return this.cmp(other) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let val = this.#val;
    if (this.#val < BN_0$8) {
      val -= this.#tens - BN_1$3;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let val = this.#val;
    if (this.#val > BN_0$8) {
      val += this.#tens - BN_1$3;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta = this.decimals - decimals;
    const bump = BN_5 * getTens(delta - 1);
    let value = this.value + bump;
    const tens = getTens(delta);
    value = value / tens * tens;
    checkValue(value, this.#format, "round");
    return new FixedNumber(_guard$5, value, this.#format);
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return this.#val === BN_0$8;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return this.#val < BN_0$8;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(format) {
    return FixedNumber.fromString(this.toString(), format);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(_value, _decimals, _format) {
    const decimals = _decimals == null ? 0 : getNumber(_decimals);
    const format = getFormat(_format);
    let value = getBigInt(_value, "value");
    const delta = decimals - format.decimals;
    if (delta > 0) {
      const tens = getTens(delta);
      assert(value % tens === BN_0$8, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value
      });
      value /= tens;
    } else if (delta < 0) {
      value *= getTens(-delta);
    }
    checkValue(value, format, "fromValue");
    return new FixedNumber(_guard$5, value, format);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(_value, _format) {
    const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
    const format = getFormat(_format);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format.decimals) {
      decimal += Zeros$1;
    }
    assert(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value
    });
    decimal = decimal.substring(0, format.decimals);
    const value = BigInt(match[1] + whole + decimal);
    checkValue(value, format, "fromString");
    return new FixedNumber(_guard$5, value, format);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(_value, _format) {
    let value = toBigInt(getBytes(_value, "value"));
    const format = getFormat(_format);
    if (format.signed) {
      value = fromTwos(value, format.width);
    }
    checkValue(value, format, "fromBytes");
    return new FixedNumber(_guard$5, value, format);
  }
}
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  assert(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset2
    });
  };
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data[offset]) };
}
function decodeRlp(_data) {
  const data = getBytes(_data, "data");
  const decoded = _decode(data, 0);
  assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
  return decoded.result;
}
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data = Array.prototype.slice.call(getBytes(object2, "object"));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
const nibbles = "0123456789abcdef";
function encodeRlp(object2) {
  let result = "0x";
  for (const v of _encode(object2)) {
    result += nibbles[v >> 4];
    result += nibbles[v & 15];
  }
  return result;
}
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits(value, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
function parseUnits$1(value, unit) {
  assertArgument(typeof value === "string", "value must be a string", "value", value);
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits$1(ether, 18);
}
function uuidV4(randomBytes2) {
  const bytes2 = getBytes(randomBytes2, "randomBytes");
  bytes2[6] = bytes2[6] & 15 | 64;
  bytes2[8] = bytes2[8] & 63 | 128;
  const value = hexlify(bytes2);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
const WordSize = 32;
const Padding = new Uint8Array(WordSize);
const passProperties$1 = ["then"];
const _guard$4 = {};
const resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names2) {
  resultNames.set(result, names2);
}
function throwError(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
function toObject(names2, items, deep) {
  if (names2.indexOf(null) >= 0) {
    return items.map((item, index) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names2.reduce((accum, name, index) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
class Result extends Array {
  // No longer used; but cannot be removed as it will remove the
  // #private field from the .d.ts which may break backwards
  // compatibility
  #names;
  /**
   *  @private
   */
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names2 = (args[2] || []).slice();
    let wrap = true;
    if (guard !== _guard$4) {
      items = args;
      names2 = [];
      wrap = false;
    }
    super(items.length);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names2.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item, index) => {
      const name = names2[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    this.#names = [];
    if (this.#names == null) {
      void this.#names;
    }
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index = getNumber(prop, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties$1.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError(`index ${index}`, item);
      }
      if (deep && item instanceof Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names2 = getNames(this);
    return names2.reduce((accum, name, index) => {
      assert(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names2, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names = getNames(this);
    const result = [], names2 = [];
    for (let i = start; i < end; i++) {
      result.push(this[i]);
      names2.push(_names[i]);
    }
    return new Result(_guard$4, result, names2);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names = getNames(this);
    const result = [], names2 = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names2.push(_names[i]);
      }
    }
    return new Result(_guard$4, result, names2);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index = getNames(this).indexOf(name);
    if (index === -1) {
      return void 0;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new Result(_guard$4, items, keys);
  }
}
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object2) {
    if (!Array.isArray(object2)) {
      return;
    }
    for (let key in object2) {
      const childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object2[key]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
function getValue$1(value) {
  let bytes2 = toBeArray(value);
  assert(bytes2.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize, offset: bytes2.length });
  if (bytes2.length !== WordSize) {
    bytes2 = getBytesCopy(concat([Padding.slice(bytes2.length % WordSize), bytes2]));
  }
  return bytes2;
}
class Coder {
  // The coder name:
  //   - address, uint256, tuple, array, etc.
  name;
  // The fully expanded type, including composite types:
  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
  type;
  // The localName bound in the signature, in this example it is "baz":
  //   - tuple(address foo, uint bar) baz
  localName;
  // Whether this type is dynamic:
  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
  dynamic;
  constructor(name, type, localName, dynamic) {
    defineProperties(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
}
class Writer {
  // An array of WordSize lengthed objects to concatenation
  #data;
  #dataLength;
  constructor() {
    this.#data = [];
    this.#dataLength = 0;
  }
  get data() {
    return concat(this.#data);
  }
  get length() {
    return this.#dataLength;
  }
  #writeData(data) {
    this.#data.push(data);
    this.#dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this.#writeData(getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes2 = getBytesCopy(value);
    const paddingOffset = bytes2.length % WordSize;
    if (paddingOffset) {
      bytes2 = getBytesCopy(concat([bytes2, Padding.slice(paddingOffset)]));
    }
    return this.#writeData(bytes2);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return this.#writeData(getValue$1(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = this.#data.length;
    this.#data.push(Padding);
    this.#dataLength += WordSize;
    return (value) => {
      this.#data[offset] = getValue$1(value);
    };
  }
}
class Reader {
  // Allows incomplete unpadded data to be read; otherwise an error
  // is raised if attempting to overrun the buffer. This is required
  // to deal with an old Solidity bug, in which event data for
  // external (not public thoguh) was tightly packed.
  allowLoose;
  #data;
  #offset;
  #bytesRead;
  #parent;
  #maxInflation;
  constructor(data, allowLoose, maxInflation) {
    defineProperties(this, { allowLoose: !!allowLoose });
    this.#data = getBytesCopy(data);
    this.#bytesRead = 0;
    this.#parent = null;
    this.#maxInflation = maxInflation != null ? maxInflation : 1024;
    this.#offset = 0;
  }
  get data() {
    return hexlify(this.#data);
  }
  get dataLength() {
    return this.#data.length;
  }
  get consumed() {
    return this.#offset;
  }
  get bytes() {
    return new Uint8Array(this.#data);
  }
  #incrementBytesRead(count) {
    if (this.#parent) {
      return this.#parent.#incrementBytesRead(count);
    }
    this.#bytesRead += count;
    assert(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
      buffer: getBytesCopy(this.#data),
      offset: this.#offset,
      length: count,
      info: {
        bytesRead: this.#bytesRead,
        dataLength: this.dataLength
      }
    });
  }
  #peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / WordSize) * WordSize;
    if (this.#offset + alignedLength > this.#data.length) {
      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
        alignedLength = length;
      } else {
        assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
          buffer: getBytesCopy(this.#data),
          length: this.#data.length,
          offset: this.#offset + alignedLength
        });
      }
    }
    return this.#data.slice(this.#offset, this.#offset + alignedLength);
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
    reader.#parent = this;
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes2 = this.#peekBytes(0, length, !!loose);
    this.#incrementBytesRead(length);
    this.#offset += bytes2.length;
    return bytes2.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
}
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const crypto$2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
const u8a$1 = (a) => a instanceof Uint8Array;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift) => word << 32 - shift | word >>> shift;
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
const nextTick = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes$1(data);
  if (!u8a$1(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes$1(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a$1(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
const toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes$2(bytesLength = 32) {
  if (crypto$2 && typeof crypto$2.getRandomValues === "function") {
    return crypto$2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
class HMAC extends Hash {
  constructor(hash$1, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash$1);
    const key = toBytes(_key);
    this.iHash = hash$1.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash$1.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash$1.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);
function pbkdf2Init(hash$1, _password, _salt, _opts) {
  hash(hash$1);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number(c);
  number(dkLen);
  number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash$1, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf2$1(hash2, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
class SHA2 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}
const Chi = (a, b2, c) => a & b2 ^ ~a & c;
const Maj = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T12 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T22 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T12 | 0;
      D = C;
      C = B;
      B = A;
      A = T12 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
const sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split$1(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
const toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
const shrSH = (h, _l, s) => h >>> s;
const shrSL = (h, l, s) => h << 32 - s | l >>> s;
const rotrSH = (h, l, s) => h >>> s | l << 32 - s;
const rotrSL = (h, l, s) => h << 32 - s | l >>> s;
const rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
const rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
const rotr32H = (_h, l) => l;
const rotr32L = (h, _l) => h;
const rotlSH = (h, l, s) => h << s | l >>> 32 - s;
const rotlSL = (h, l, s) => l << s | h >>> 32 - s;
const rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
const u64 = {
  fromBig,
  split: split$1,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64.add3L(T1l, sigma0l, MAJl);
      Ah = u64.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512$1 = /* @__PURE__ */ wrapConstructor(() => new SHA512());
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
const crypto$1 = anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256$1.create();
    case "sha512":
      return sha512$1.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key) {
  const algo = { sha256: sha256$1, sha512: sha512$1 }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac.create(algo, key);
}
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  const algo = { sha256: sha256$1, sha512: sha512$1 }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf2$1(algo, password, salt, { c: iterations, dkLen: keylen });
}
function randomBytes$1(length) {
  assert(crypto$1 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  const result = new Uint8Array(length);
  crypto$1.getRandomValues(result);
  return result;
}
let locked$4 = false;
const _computeHmac = function(algorithm, key, data) {
  return createHmac(algorithm, key).update(data).digest();
};
let __computeHmac = _computeHmac;
function computeHmac(algorithm, _key, _data) {
  const key = getBytes(_key, "key");
  const data = getBytes(_data, "data");
  return hexlify(__computeHmac(algorithm, key, data));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked$4 = true;
};
computeHmac.register = function(func) {
  if (locked$4) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n$4 = /* @__PURE__ */ BigInt(0);
const _1n$5 = /* @__PURE__ */ BigInt(1);
const _2n$3 = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R = _1n$5, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n$4;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n$5 ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n$3)
      t ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(j)) - _1n$5;
  }
  _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split$1(_SHA3_IOTA, true);
const rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
let locked$3 = false;
const _keccak256 = function(data) {
  return keccak_256(data);
};
let __keccak256 = _keccak256;
function keccak256(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked$3 = true;
};
keccak256.register = function(func) {
  if (locked$3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
const Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
const rotl$1 = (word, shift) => word << shift | word >>> 32 - shift;
function f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  else if (group === 1)
    return x & y | ~x & z;
  else if (group === 2)
    return (x | ~y) ^ z;
  else if (group === 3)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
}
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl$1(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl$1(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl$1(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl$1(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
}
const ripemd160$1 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());
let locked$2 = false;
const _ripemd160 = function(data) {
  return ripemd160$1(data);
};
let __ripemd160 = _ripemd160;
function ripemd160(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__ripemd160(data));
}
ripemd160._ = _ripemd160;
ripemd160.lock = function() {
  locked$2 = true;
};
ripemd160.register = function(func) {
  if (locked$2) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd160);
let locked$1 = false;
const _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
let __pbkdf2 = _pbkdf2;
function pbkdf2(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf2._ = _pbkdf2;
pbkdf2.lock = function() {
  locked$1 = true;
};
pbkdf2.register = function(func) {
  if (locked$1) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf2);
let locked = false;
const _randomBytes = function(length) {
  return new Uint8Array(randomBytes$1(length));
};
let __randomBytes = _randomBytes;
function randomBytes(length) {
  return __randomBytes(length);
}
randomBytes._ = _randomBytes;
randomBytes.lock = function() {
  locked = true;
};
randomBytes.register = function(func) {
  if (locked) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes);
const rotl = (a, b2) => a << b2 | a >>> 32 - b2;
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0; i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N2, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  number(N2);
  number(r);
  number(p);
  number(dkLen);
  number(asyncTick);
  number(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N2 <= 1 || (N2 & N2 - 1) !== 0 || N2 >= 2 ** (blockSize / 8) || N2 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N2 + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf2$1(sha256$1, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N2));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N2 * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N2, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf2$1(sha256$1, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt$1(password, salt, opts) {
  const { N: N2, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0; i < N2 - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N2 - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    for (let i = 0; i < N2; i++) {
      const j = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N: N2, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    let pos = 0;
    await asyncLoop(N2 - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix(V, (N2 - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    await asyncLoop(N2, asyncTick, () => {
      const j = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
let lockedSync = false, lockedAsync = false;
const _scryptAsync = async function(passwd, salt, N2, r, p, dkLen, onProgress) {
  return await scryptAsync(passwd, salt, { N: N2, r, p, dkLen, onProgress });
};
const _scryptSync = function(passwd, salt, N2, r, p, dkLen) {
  return scrypt$1(passwd, salt, { N: N2, r, p, dkLen });
};
let __scryptAsync = _scryptAsync;
let __scryptSync = _scryptSync;
async function scrypt(_passwd, _salt, N2, r, p, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N2, r, p, dkLen, progress));
}
scrypt._ = _scryptAsync;
scrypt.lock = function() {
  lockedAsync = true;
};
scrypt.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt);
function scryptSync(_passwd, _salt, N2, r, p, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N2, r, p, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function() {
  lockedSync = true;
};
scryptSync.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);
const _sha256 = function(data) {
  return createHash("sha256").update(data).digest();
};
const _sha512 = function(data) {
  return createHash("sha512").update(data).digest();
};
let __sha256 = _sha256;
let __sha512 = _sha512;
let locked256 = false, locked512 = false;
function sha256(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__sha256(data));
}
sha256._ = _sha256;
sha256.lock = function() {
  locked256 = true;
};
sha256.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha256);
function sha512(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__sha512(data));
}
sha512._ = _sha512;
sha512.lock = function() {
  locked512 = true;
};
sha512.register = function(func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha256);
const _0n$3 = BigInt(0);
const _1n$4 = BigInt(1);
const _2n$2 = BigInt(2);
const u8a = (a) => a instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n$3; n2 >>= _1n$4, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n$4;
}
const bitSet = (n2, pos, value) => {
  return n2 | (value ? _1n$4 : _0n$3) << BigInt(pos);
};
const bitMask = (n2) => (_2n$2 << BigInt(n2 - 1)) - _1n$4;
const u8n = (data) => new Uint8Array(data);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b2) => hmacFn(k, v, ...b2);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3);
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a, b2) {
  const result = a % b2;
  return result >= _0n$2 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$2 || power < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$3)
    return _0n$2;
  let res = _1n$3;
  while (power > _0n$2) {
    if (power & _1n$3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n$2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$2 || modulo <= _0n$2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b2 = modulo;
  let x = _0n$2, u = _1n$3;
  while (a !== _0n$2) {
    const q = b2 / a;
    const r = b2 % a;
    const m = x - u * q;
    b2 = a, a = r, x = u, u = m;
  }
  const gcd = b2;
  if (gcd !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n$3) / _2n$1;
  let Q, S2, Z;
  for (Q = P - _1n$3, S2 = 0; Q % _2n$1 === _0n$2; Q /= _2n$1, S2++)
    ;
  for (Z = _2n$1; Z < P && pow(Z, legendreC, P) !== P - _1n$3; Z++)
    ;
  if (S2 === 1) {
    const p1div4 = (P + _1n$3) / _4n;
    return function tonelliFast(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n$3) / _2n$1;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S2;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b2); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge = Fp2.pow(g, _1n$3 << BigInt(r - m - 1));
      g = Fp2.sqr(ge);
      x = Fp2.mul(x, ge);
      b2 = Fp2.mul(b2, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n$1) {
    const p1div4 = (P + _1n$3) / _4n;
    return function sqrt3mod4(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n$1);
      const v = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n$1), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  return tonelliShanks(P);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n$2)
    throw new Error("Expected power > 0");
  if (power === _0n$2)
    return f2.ONE;
  if (power === _1n$3)
    return num;
  let p = f2.ONE;
  let d = num;
  while (power > _0n$2) {
    if (power & _1n$3)
      p = f2.mul(p, d);
    d = f2.sqr(d);
    power >>= _1n$3;
  }
  return p;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$2,
    isOdd: (num) => (num & _1n$3) === _1n$3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b2, c) => c ? b2 : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
const _0n$1 = BigInt(0);
const _1n$2 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p = c.ZERO;
      let d = elm;
      while (n2 > _0n$1) {
        if (n2 & _1n$2)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n$2;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n2) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f2 = c.BASE;
      const mask2 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$2;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFCached(P, precomputesMap, n2, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
const _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b: b2 } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I = Point.ZERO;
      if (n2 === _0n)
        return I;
      assertGE(n2);
      if (n2 === _1n$1)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n$1)
          k1p = k1p.add(d);
        if (k2 & _1n$1)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n$1;
        k2 >>= _1n$1;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(n2);
        point = p;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b2) {
      const G = Point.BASE;
      const mul = (P, a2) => a2 === _0n || a2 === _1n$1 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$1)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$1)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n < num && num < Fp2.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n$1) === _1n$1;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$1;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE(b2.slice(from, to));
  class Signature2 {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature2(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$1);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature2.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature2(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h * is);
    const u2 = modN(r * is);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature: Signature2,
    utils
  };
}
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes$1(...msgs)),
    randomBytes: randomBytes$2
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b2) => (a + b2 / _2n) / b2;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n2, P) * b3 % P;
  const b9 = pow2(b6, _3n2, P) * b3 % P;
  const b11 = pow2(b9, _2n, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n2, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n2);
      const c2 = divNearest(-b1 * k, n2);
      let k1 = mod(k - c1 * a1 - c2 * a2, n2);
      let k2 = mod(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k2 = n2 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256$1);
BigInt(0);
secp256k1.ProjectivePoint;
const ZeroAddress = "0x0000000000000000000000000000000000000000";
const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
const EtherSymbol = "";
const MessagePrefix = "Ethereum Signed Message:\n";
const BN_0$7 = BigInt(0);
const BN_1$2 = BigInt(1);
const BN_2$2 = BigInt(2);
const BN_27$1 = BigInt(27);
const BN_28$1 = BigInt(28);
const BN_35$1 = BigInt(35);
const _guard$3 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
class Signature {
  #r;
  #s;
  #v;
  #networkV;
  /**
   *  The ``r`` value for a signature.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return this.#r;
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    this.#r = hexlify(value);
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    assertArgument(parseInt(this.#s.substring(0, 3)) < 8, "non-canonical s; use ._s", "s", this.#s);
    return this.#s;
  }
  set s(_value) {
    assertArgument(dataLength(_value) === 32, "invalid s", "value", _value);
    this.#s = hexlify(_value);
  }
  /**
   *  Return the s value, unchecked for EIP-2 compliance.
   *
   *  This should generally not be used and is for situations where
   *  a non-canonical S value might be relevant, such as Frontier blocks
   *  that were mined prior to EIP-2 or invalid Authorization List
   *  signatures.
   */
  get _s() {
    return this.#s;
  }
  /**
   *  Returns true if the Signature is valid for [[link-eip-2]] signatures.
   */
  isValid() {
    return parseInt(this.#s.substring(0, 3)) < 8;
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return this.#v;
  }
  set v(value) {
    const v = getNumber(value, "value");
    assertArgument(v === 27 || v === 28, "invalid v", "v", value);
    this.#v = v;
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return this.#networkV;
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v = this.networkV;
    if (v == null) {
      return null;
    }
    return Signature.getChainId(v);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  /**
   *  @private
   */
  constructor(guard, r, s, v) {
    assertPrivate(guard, _guard$3, "Signature");
    this.#r = r;
    this.#s = s;
    this.#v = v;
    this.#networkV = null;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new Signature(_guard$3, this.r, this._s, this.v);
    if (this.networkV) {
      clone.#networkV = this.networkV;
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this._s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v) {
    const bv = getBigInt(v, "v");
    if (bv == BN_27$1 || bv == BN_28$1) {
      return BN_0$7;
    }
    assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v);
    return (bv - BN_35$1) / BN_2$2;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v) {
    return getBigInt(chainId) * BN_2$2 + BigInt(35 + v - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v) {
    const bv = getBigInt(v);
    if (bv === BN_0$7 || bv === BN_27$1) {
      return 27;
    }
    if (bv === BN_1$2 || bv === BN_28$1) {
      return 28;
    }
    assertArgument(bv >= BN_35$1, "invalid v", "v", v);
    return bv & BN_1$2 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    if (sig == null) {
      return new Signature(_guard$3, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes2 = getBytes(sig, "signature");
      if (bytes2.length === 64) {
        const r2 = hexlify(bytes2.slice(0, 32));
        const s2 = bytes2.slice(32, 64);
        const v2 = s2[0] & 128 ? 28 : 27;
        s2[0] &= 127;
        return new Signature(_guard$3, r2, hexlify(s2), v2);
      }
      if (bytes2.length === 65) {
        const r2 = hexlify(bytes2.slice(0, 32));
        const s2 = hexlify(bytes2.slice(32, 64));
        const v2 = Signature.getNormalizedV(bytes2[64]);
        return new Signature(_guard$3, r2, s2, v2);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof Signature) {
      return sig.clone();
    }
    const _r = sig.r;
    assertError(_r != null, "missing r");
    const r = toUint256(_r);
    const s = (function(s2, yParityAndS) {
      if (s2 != null) {
        return toUint256(s2);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes2 = getBytes(yParityAndS);
        bytes2[0] &= 127;
        return hexlify(bytes2);
      }
      assertError(false, "missing s");
    })(sig.s, sig.yParityAndS);
    const { networkV, v } = (function(_v, yParityAndS, yParity) {
      if (_v != null) {
        const v2 = getBigInt(_v);
        return {
          networkV: v2 >= BN_35$1 ? v2 : void 0,
          v: Signature.getNormalizedV(v2)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    })(sig.v, sig.yParityAndS, sig.yParity);
    const result = new Signature(_guard$3, r, s, v);
    if (networkV) {
      result.#networkV = networkV;
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
}
class SigningKey {
  #privateKey;
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    this.#privateKey = hexlify(privateKey);
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return this.#privateKey;
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return SigningKey.computePublicKey(this.#privateKey);
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return SigningKey.computePublicKey(this.#privateKey, true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(this.#privateKey), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes2 = getBytes(key, "key");
    if (bytes2.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes2, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes2.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes2, 1);
      bytes2 = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes2);
    return hexlify(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature.from(signature);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signature for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
}
const BN_0$6 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum2 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum2.length < 2) {
    checksum2 = "0" + checksum2;
  }
  return checksum2;
}
const Base36 = (function() {
  const result = {};
  for (let i = 0; i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
})();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_0$6;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getIcapAddress(address) {
  let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getCreateAddress(tx) {
  const from = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
function getCreate2Address(_from, _salt, _initCodeHash) {
  const from = getAddress(_from);
  const salt = getBytes(_salt, "salt");
  const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
  assertArgument(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  assertArgument(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return getAddress(dataSlice(keccak256(concat(["0xff", from, salt, initCodeHash])), 12));
}
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
function isAddress(value) {
  try {
    getAddress(value);
    return true;
  } catch (error) {
  }
  return false;
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
const _gaurd = {};
function n(value, width) {
  let signed2 = false;
  if (width < 0) {
    signed2 = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
}
function b(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
}
const _typedSymbol = Symbol.for("_ethers_typed");
class Typed {
  /**
   *  The type, as a Solidity-compatible type.
   */
  type;
  /**
   *  The actual value.
   */
  value;
  #options;
  /**
   *  @_ignore:
   */
  _typedSymbol;
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options) {
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type, value });
    this.#options = options;
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v) => v.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return this.#options;
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (this.#options === true) {
      return -1;
    }
    if (this.#options === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new Typed(_gaurd, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v) {
    return n(v, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v) {
    return n(v, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v) {
    return n(v, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v) {
    return n(v, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v) {
    return n(v, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v) {
    return n(v, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v) {
    return n(v, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v) {
    return n(v, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v) {
    return n(v, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v) {
    return n(v, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v) {
    return n(v, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v) {
    return n(v, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v) {
    return n(v, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v) {
    return n(v, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v) {
    return n(v, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v) {
    return n(v, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v) {
    return n(v, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v) {
    return n(v, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v) {
    return n(v, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v) {
    return n(v, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v) {
    return n(v, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v) {
    return n(v, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v) {
    return n(v, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v) {
    return n(v, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v) {
    return n(v, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v) {
    return n(v, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v) {
    return n(v, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v) {
    return n(v, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v) {
    return n(v, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v) {
    return n(v, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v) {
    return n(v, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v) {
    return n(v, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v) {
    return n(v, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v) {
    return n(v, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v) {
    return n(v, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v) {
    return n(v, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v) {
    return n(v, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v) {
    return n(v, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v) {
    return n(v, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v) {
    return n(v, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v) {
    return n(v, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v) {
    return n(v, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v) {
    return n(v, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v) {
    return n(v, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v) {
    return n(v, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v) {
    return n(v, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v) {
    return n(v, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v) {
    return n(v, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v) {
    return n(v, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v) {
    return n(v, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v) {
    return n(v, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v) {
    return n(v, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v) {
    return n(v, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v) {
    return n(v, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v) {
    return n(v, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v) {
    return n(v, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v) {
    return n(v, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v) {
    return n(v, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v) {
    return n(v, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v) {
    return n(v, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v) {
    return n(v, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v) {
    return n(v, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v) {
    return b(v, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v) {
    return b(v, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v) {
    return b(v, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v) {
    return b(v, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v) {
    return b(v, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v) {
    return b(v, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v) {
    return b(v, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v) {
    return b(v, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v) {
    return b(v, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v) {
    return b(v, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v) {
    return b(v, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v) {
    return b(v, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v) {
    return b(v, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v) {
    return b(v, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v) {
    return b(v, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v) {
    return b(v, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v) {
    return b(v, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v) {
    return b(v, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v) {
    return b(v, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v) {
    return b(v, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v) {
    return b(v, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v) {
    return b(v, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v) {
    return b(v, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v) {
    return b(v, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v) {
    return b(v, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v) {
    return b(v, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v) {
    return b(v, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v) {
    return b(v, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v) {
    return b(v, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v) {
    return b(v, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v) {
    return b(v, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v) {
    return b(v, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v) {
    return new Typed(_gaurd, "address", v);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v) {
    return new Typed(_gaurd, "bool", !!v);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v) {
    return new Typed(_gaurd, "bytes", v);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v) {
    return new Typed(_gaurd, "string", v);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v, dynamic) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v, name) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v) {
    return new Typed(_gaurd, "overrides", Object.assign({}, v));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
}
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value) {
    let value = Typed.dereference(_value, "string");
    try {
      value = getAddress(value);
    } catch (error) {
      return this._throwError(error.message, _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
}
class AnonymousCoder extends Coder {
  coder;
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}
class ArrayCoder extends Coder {
  coder;
  length;
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
}
class FixedBytesCoder extends Coder {
  size;
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    defineProperties(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value) {
    let data = getBytesCopy(Typed.dereference(_value, this.type));
    if (data.length !== this.size) {
      this._throwError("incorrect data length", _value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
}
const Empty = new Uint8Array([]);
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
}
const BN_0$5 = BigInt(0);
const BN_1$1 = BigInt(1);
const BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class NumberCoder extends Coder {
  size;
  signed;
  constructor(size, signed2, localName) {
    const name = (signed2 ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    defineProperties(this, { size, signed: signed2 }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value) {
    let value = getBigInt(Typed.dereference(_value, this.type));
    let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_1$1)) {
        this._throwError("value out-of-bounds", _value);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_0$5 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  coders;
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b2) => a.address.localeCompare(b2.address));
  return result;
}
function authorizationify(auth) {
  return {
    address: getAddress(auth.address),
    nonce: getBigInt(auth.nonce != null ? auth.nonce : 0),
    chainId: getBigInt(auth.chainId != null ? auth.chainId : 0),
    signature: Signature.from(auth.signature)
  };
}
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}
const BN_0$4 = BigInt(0);
const BN_2$1 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const BLOB_SIZE = 4096 * 32;
function getKzgLibrary(kzg) {
  const blobToKzgCommitment = (blob) => {
    if ("computeBlobProof" in kzg) {
      if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
        return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));
      }
    } else if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
      return getBytes(kzg.blobToKzgCommitment(blob));
    }
    if ("blobToKZGCommitment" in kzg && typeof kzg.blobToKZGCommitment === "function") {
      return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  const computeBlobKzgProof = (blob, commitment) => {
    if ("computeBlobProof" in kzg && typeof kzg.computeBlobProof === "function") {
      return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));
    }
    if ("computeBlobKzgProof" in kzg && typeof kzg.computeBlobKzgProof === "function") {
      return kzg.computeBlobKzgProof(blob, commitment);
    }
    if ("computeBlobKZGProof" in kzg && typeof kzg.computeBlobKZGProof === "function") {
      return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  return { blobToKzgCommitment, computeBlobKzgProof };
}
function getVersionedHash(version2, hash2) {
  let versioned = version2.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha256(hash2).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleAuthorizationList(value, param) {
  try {
    if (!Array.isArray(value)) {
      throw new Error("authorizationList: invalid array");
    }
    const result = [];
    for (let i = 0; i < value.length; i++) {
      const auth = value[i];
      if (!Array.isArray(auth)) {
        throw new Error(`authorization[${i}]: invalid array`);
      }
      if (auth.length !== 6) {
        throw new Error(`authorization[${i}]: wrong length`);
      }
      if (!auth[1]) {
        throw new Error(`authorization[${i}]: null address`);
      }
      result.push({
        address: handleAddress(auth[1]),
        nonce: handleUint(auth[2], "nonce"),
        chainId: handleUint(auth[0], "chainId"),
        signature: Signature.from({
          yParity: handleNumber(auth[3], "yParity"),
          r: zeroPadValue(auth[4], 32),
          s: zeroPadValue(auth[5], 32)
        })
      });
    }
    return result;
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value, param) {
  if (_value === "0x") {
    return 0;
  }
  return getNumber(_value, param);
}
function handleUint(_value, param) {
  if (_value === "0x") {
    return BN_0$4;
  }
  const value = getBigInt(_value, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value, name) {
  const value = getBigInt(_value, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function formatAuthorizationList(value) {
  return value.map((a) => {
    return [
      formatNumber(a.chainId, "chainId"),
      a.address,
      formatNumber(a.nonce, "nonce"),
      formatNumber(a.signature.yParity, "yParity"),
      toBeArray(a.signature.r),
      toBeArray(a.signature.s)
    ];
  });
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0; i < value.length; i++) {
    assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy(data) {
  const fields = decodeRlp(data);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_0$4
  };
  if (fields.length === 6) {
    return tx;
  }
  const v = handleUint(fields[6], "v");
  const r = handleUint(fields[7], "r");
  const s = handleUint(fields[8], "s");
  if (r === BN_0$4 && s === BN_0$4) {
    tx.chainId = v;
  } else {
    let chainId = (v - BN_35) / BN_2$1;
    if (chainId < BN_0$4) {
      chainId = BN_0$4;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_0$4 || (v === BN_27 || v === BN_28), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_0$4;
  if (tx.chainId != BN_0$4) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_0$4) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v = BigInt(27 + sig.yParity);
  if (chainId !== BN_0$4) {
    v = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r = zeroPadValue(fields[1], 32);
  const s = zeroPadValue(fields[2], 32);
  const signature = Signature.from({ r, s, yParity });
  tx.signature = signature;
}
function _parseEip1559(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data) {
  let fields = decodeRlp(getBytes(data).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i = 0; i < fields[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b2) => b2.data),
          blobs.map((b2) => b2.commitment),
          blobs.map((b2) => b2.proof)
        ])
      ]);
    }
  }
  return concat(["0x03", encodeRlp(fields)]);
}
function _parseEip7702(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), "invalid field count for transaction type: 4", "data", hexlify(data));
  const tx = {
    type: 4,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    authorizationList: handleAuthorizationList(fields[9], "authorizationList")
  };
  if (fields.length === 10) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(10));
  return tx;
}
function _serializeEip7702(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatAuthorizationList(tx.authorizationList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x04", encodeRlp(fields)]);
}
class Transaction {
  #type;
  #to;
  #data;
  #nonce;
  #gasLimit;
  #gasPrice;
  #maxPriorityFeePerGas;
  #maxFeePerGas;
  #value;
  #chainId;
  #sig;
  #accessList;
  #maxFeePerBlobGas;
  #blobVersionedHashes;
  #kzg;
  #blobs;
  #auths;
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return this.#type;
  }
  set type(value) {
    switch (value) {
      case null:
        this.#type = null;
        break;
      case 0:
      case "legacy":
        this.#type = 0;
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        this.#type = 1;
        break;
      case 2:
      case "london":
      case "eip-1559":
        this.#type = 2;
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        this.#type = 3;
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        this.#type = 4;
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = this.#to;
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    this.#to = value == null ? null : getAddress(value);
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return this.#nonce;
  }
  set nonce(value) {
    this.#nonce = getNumber(value, "value");
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return this.#gasLimit;
  }
  set gasLimit(value) {
    this.#gasLimit = getBigInt(value);
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = this.#gasPrice;
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_0$4;
    }
    return value;
  }
  set gasPrice(value) {
    this.#gasPrice = value == null ? null : getBigInt(value, "gasPrice");
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = this.#maxPriorityFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, "maxPriorityFeePerGas");
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = this.#maxFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    this.#maxFeePerGas = value == null ? null : getBigInt(value, "maxFeePerGas");
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return this.#data;
  }
  set data(value) {
    this.#data = hexlify(value);
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return this.#value;
  }
  set value(value) {
    this.#value = getBigInt(value, "value");
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value);
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return this.#sig || null;
  }
  set signature(value) {
    this.#sig = value == null ? null : Signature.from(value);
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = this.#accessList || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    this.#accessList = value == null ? null : accessListify(value);
  }
  get authorizationList() {
    const value = this.#auths || null;
    if (value == null) {
      if (this.type === 4) {
        return [];
      }
    }
    return value;
  }
  set authorizationList(auths) {
    this.#auths = auths == null ? null : auths.map((a) => authorizationify(a));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = this.#maxFeePerBlobGas;
    if (value == null && this.type === 3) {
      return BN_0$4;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    this.#maxFeePerBlobGas = value == null ? null : getBigInt(value, "maxFeePerBlobGas");
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = this.#blobVersionedHashes;
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0; i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    this.#blobVersionedHashes = value;
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (this.#blobs == null) {
      return null;
    }
    return this.#blobs.map((b2) => Object.assign({}, b2));
  }
  set blobs(_blobs) {
    if (_blobs == null) {
      this.#blobs = null;
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i = 0; i < _blobs.length; i++) {
      const blob = _blobs[i];
      if (isBytesLike(blob)) {
        assert(this.#kzg, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data = getBytes(blob);
        assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
        if (data.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data);
          data = padded;
        }
        const commit = this.#kzg.blobToKzgCommitment(data);
        const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));
        blobs.push({
          data: hexlify(data),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob.commitment);
        blobs.push({
          data: hexlify(blob.data),
          commitment: commit,
          proof: hexlify(blob.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    this.#blobs = blobs;
    this.#blobVersionedHashes = versionedHashes;
  }
  get kzg() {
    return this.#kzg;
  }
  set kzg(kzg) {
    if (kzg == null) {
      this.#kzg = null;
    } else {
      this.#kzg = getKzgLibrary(kzg);
    }
  }
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    this.#type = null;
    this.#to = null;
    this.#nonce = 0;
    this.#gasLimit = BN_0$4;
    this.#gasPrice = null;
    this.#maxPriorityFeePerGas = null;
    this.#maxFeePerGas = null;
    this.#data = "0x";
    this.#value = BN_0$4;
    this.#chainId = BN_0$4;
    this.#sig = null;
    this.#accessList = null;
    this.#maxFeePerBlobGas = null;
    this.#blobVersionedHashes = null;
    this.#kzg = null;
    this.#blobs = null;
    this.#auths = null;
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(this.#getSerialized(true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  #getSerialized(signed2, sidecar) {
    assert(!signed2 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    const sig = signed2 ? this.signature : null;
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy(this, sig);
      case 1:
        return _serializeEip2930(this, sig);
      case 2:
        return _serializeEip1559(this, sig);
      case 3:
        return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
      case 4:
        return _serializeEip7702(this, sig);
    }
    assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return this.#getSerialized(true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return this.#getSerialized(false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (this.authorizationList && this.authorizationList.length) {
        types.push(4);
      } else if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s = (v) => {
      if (v == null) {
        return null;
      }
      return v.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s(this.gasLimit),
      gasPrice: s(this.gasPrice),
      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
      maxFeePerGas: s(this.maxFeePerGas),
      value: s(this.value),
      chainId: s(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return Transaction.from(_parseEip2930(payload));
        case 2:
          return Transaction.from(_parseEip1559(payload));
        case 3:
          return Transaction.from(_parseEip4844(payload));
        case 4:
          return Transaction.from(_parseEip7702(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new Transaction();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.authorizationList != null) {
      result.authorizationList = tx.authorizationList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
}
function hashAuthorization(auth) {
  assertArgument(typeof auth.address === "string", "invalid address for hashAuthorization", "auth.address", auth);
  return keccak256(concat([
    "0x05",
    encodeRlp([
      auth.chainId != null ? toBeArray(auth.chainId) : "0x",
      getAddress(auth.address),
      auth.nonce != null ? toBeArray(auth.nonce) : "0x"
    ])
  ]));
}
function verifyAuthorization(auth, sig) {
  return recoverAddress(hashAuthorization(auth), sig);
}
function id(value) {
  return keccak256(toUtf8Bytes(value));
}
var COMPRESSED$1 = "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";
const FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
const NSM_MAX = 4;
function decode_arithmetic(bytes2) {
  let pos = 0;
  function u16() {
    return bytes2[pos++] << 8 | bytes2[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes2[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = 2 ** N2;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N2; i++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b2 - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 2:
        return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 1:
        return offset + bytes2[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
}
function unsafe_atob(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
  let n2 = s.length;
  let ret = new Uint8Array(6 * n2 >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0; i < n2; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n2, next) {
  let v = Array(n2);
  for (let i = 0, x = 0; i < n2; i++) v[i] = x += signed(next());
  return v;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n2 = next();
    if (!n2) break;
    prev += x;
    for (let i = 0; i < n2; i++) {
      ret.push(prev + i);
    }
    prev += n2 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v = read_sorted(next);
    if (v.length) return v;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0) break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0) break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x) break;
    v.push(x);
  }
  return v;
}
function read_transposed(n2, w, next) {
  let m = Array(n2).fill().map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n2, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
}
function read_replacement_table(w, next) {
  let n2 = 1 + next();
  let m = read_transposed(n2, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode2([]), []);
  return ret;
  function decode2(Q) {
    let S2 = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i) => sorted[i]);
      if (cps.length) return decode2(cps);
    });
    return { S: S2, B, Q };
  }
  function expand({ S: S2, B }, cps, saved) {
    if (S2 & 4 && saved === cps[cps.length - 1]) return;
    if (S2 & 2) saved = cps[cps.length - 1];
    if (S2 & 1) ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s) {
  let cps = [];
  for (let pos = 0, len = s.length; pos < len; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0; i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a, b2) {
  let n2 = a.length;
  let c = n2 - b2.length;
  for (let i = 0; c == 0 && i < n2; i++) c = a[i] - b2[i];
  return c;
}
var COMPRESSED = "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";
const S0 = 44032;
const L0 = 4352;
const V0 = 4449;
const T0 = 4519;
const L_COUNT = 19;
const V_COUNT = 21;
const T_COUNT = 28;
const N_COUNT = V_COUNT * T_COUNT;
const S_COUNT = L_COUNT * N_COUNT;
const S1 = S0 + S_COUNT;
const L1 = L0 + L_COUNT;
const V1 = V0 + V_COUNT;
const T1$1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
let SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;
function init$1() {
  let r = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a, b2] = cps;
      let bucket = RECOMP.get(a);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a, bucket);
      }
      bucket.set(b2, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a, b2) {
  if (a >= L0 && a < L1 && b2 >= V0 && b2 < V1) {
    return S0 + (a - L0) * N_COUNT + (b2 - V0) * T_COUNT;
  } else if (is_hangul(a) && b2 > T0 && b2 < T1$1 && (a - S0) % T_COUNT == 0) {
    return a + (b2 - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b2);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add2(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add2(L0 + l_index);
        add2(V0 + v_index);
        if (t_index > 0) add2(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add2(cp);
        }
      }
      if (!buf.length) break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1; i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j) break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc) break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
const HYPHEN = 45;
const STOP_CH = ".";
const FE0F = 65039;
const UNIQUE_PH = 1;
const Array_from = (x) => Array.from(x);
function group_has_cp(g, cp) {
  return g.P.has(cp) || g.Q.has(cp);
}
class Emoji extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
}
let MAPPED, IGNORED, CM, NSM, ESCAPE, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;
function init() {
  if (MAPPED) return;
  let r = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v) => v.forEach((x) => set.add(x));
  MAPPED = new Map(read_mapped(r));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  read_sorted_set();
  let chunks = read_sorted_arrays(r);
  let unrestricted = r();
  const read_chunked = () => {
    let set = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i) => {
    let N2 = read_array_while(r).map((x) => x + 96);
    if (N2.length) {
      let R = i >= unrestricted;
      N2[0] -= 32;
      N2 = str_from_cps(N2);
      if (R) N2 = `Restricted[${N2}]`;
      let P = read_chunked();
      let Q = read_chunked();
      let M = !r();
      return { N: N2, P, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b2) => a - b2);
  wholes.forEach((cp, i) => {
    let d = r();
    let w = wholes[i] = d ? wholes[i - d] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g) => group_has_cp(g, cp));
      let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x) => Array_from(x.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union.filter((g) => !G.has(g)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g of GROUPS) {
    for (let cp of g.P) add_to_union(cp);
    for (let cp of g.Q) add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r).map((v) => Emoji.from(v)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s) {
  return `"${s}"`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev) throw error_placement(`leading ${prev}`);
  let n2 = cps.length;
  let last = -1;
  for (let i = 1; i < n2; i++) {
    cp = cps[i];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i) throw error_placement(`${prev} + ${match}`);
      last = i + 1;
      prev = match;
    }
  }
  if (last == n2) throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0])) buf.push("");
  if (cps.length > max) {
    max >>= 1;
    cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
  }
  let prev = 0;
  let n2 = cps.length;
  for (let i = 0; i < n2; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n2)));
  return buf.join("");
}
function is_combining_mark(cp) {
  init();
  return CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
function ens_normalize(name) {
  return flatten(split(name, nfc, filter_fe0f));
}
function split(name, nf, ef) {
  if (!name) return [];
  init();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
      // codepoint, not substring!
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0])) throw error_placement("leading combining mark");
          for (let i = 1; i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g] = determine_group(unique);
          check_group(g, chars);
          check_whole(g, unique);
          type = g.N;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH) return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set);
      if (!maker.length) return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => group_has_cp(g, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => group_has_cp(g, cp));
    if (!gs.length) {
      if (!GROUPS.some((g) => group_has_cp(g, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1) break;
  }
  return groups;
}
function flatten(split2) {
  return split2.map(({ input, error, output: output2 }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split2.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g, cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (g.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e = decomposed2.length; i < e; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp; j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i; k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node) break;
    let { V } = node;
    if (V) {
      emoji = V;
      cps.length = pos;
    }
  }
  return emoji;
}
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  const bytes2 = toUtf8Bytes(ensNormalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes2.length; i++) {
    const d = bytes2[i];
    if (d === 46) {
      comps.push(checkComponent(bytes2.slice(last, i)));
      last = i + 1;
    }
  }
  assertArgument(last < bytes2.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes2.slice(last)));
  return comps;
}
function ensNormalize(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name);
  } catch (error) {
    assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
  }
}
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
  let result = Zeros;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name, _maxLength) {
  const length = _maxLength != null ? _maxLength : 63;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
function verifyMessage(message, sig) {
  const digest = hashMessage(message);
  return recoverAddress(digest, sig);
}
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0$3 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = getBytes(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return concat([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
const hexTrue = toBeHex(BN_1, 32);
const hexFalse = toBeHex(BN_0$3, 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value) {
    const value = getBigInt(_value, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes2 = getBytes(value, "domain.salt");
    assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes2);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT256, signed2 ? width - 1 : width);
      const boundsLower = signed2 ? (boundsUpper + BN_1) * BN__1 : BN_0$3;
      return function(_value) {
        const value = getBigInt(_value, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed2 ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes2 = getBytes(value);
        assertArgument(bytes2.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
function splitArray(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
class TypedDataEncoder {
  /**
   *  The primary type for the structured [[types]].
   *
   *  This is derived automatically from the [[types]], since no
   *  recursion is possible, once the DAG for the types is consturcted
   *  internally, the primary type must be the only remaining type with
   *  no parent nodes.
   */
  primaryType;
  #types;
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(this.#types);
  }
  #fullTypes;
  #encoderCache;
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types) {
    this.#fullTypes = /* @__PURE__ */ new Map();
    this.#encoderCache = /* @__PURE__ */ new Map();
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types = {};
    Object.keys(_types).forEach((type) => {
      types[type] = _types[type].map(({ name, type: type2 }) => {
        let { base, index } = splitArray(type2);
        if (base === "int" && !_types["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types["uint"]) {
          base = "uint256";
        }
        return { name, type: base + (index || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    this.#types = JSON.stringify(types);
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(""));
    }
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = this.#encoderCache.get(type);
    if (!encoder) {
      encoder = this.#getEncoder(type);
      this.#encoderCache.set(type, encoder);
    }
    return encoder;
  }
  #getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const array = splitArray(type).array;
    if (array) {
      const subtype = array.prefix;
      const subEncoder = this.getEncoder(subtype);
      return (value) => {
        assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
        let result = value.map(subEncoder);
        if (this.#fullTypes.has(subtype)) {
          result = result.map(keccak256);
        }
        return keccak256(concat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this.#fullTypes.get(type));
      return (value) => {
        const values = fields.map(({ name, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name]);
          if (this.#fullTypes.has(type2)) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return concat(values);
      };
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = this.#fullTypes.get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray(type).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v) => this._visit(array.prefix, v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new TypedDataEncoder(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return TypedDataEncoder.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return TypedDataEncoder.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type = domainFieldTypes[name];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type });
    }
    domainFields.sort((a, b2) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types, value) {
    return concat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types, value) {
    return keccak256(TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = TypedDataEncoder.from(types);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = TypedDataEncoder.from(types);
    types = encoder.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
}
function verifyTypedData(domain, types, value, signature) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);
}
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
const _kwVisib = "constant external internal payable private public pure view override";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
const SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
class TokenString {
  #offset;
  #tokens;
  get offset() {
    return this.#offset;
  }
  get length() {
    return this.#tokens.length - this.#offset;
  }
  constructor(tokens) {
    this.#offset = 0;
    this.#tokens = tokens.slice();
  }
  clone() {
    return new TokenString(this.#tokens);
  }
  reset() {
    this.#offset = 0;
  }
  #subTokenString(from = 0, to = 0) {
    return new TokenString(this.#tokens.slice(from, to).map((t) => {
      return Object.freeze(Object.assign({}, t, {
        match: t.match - from,
        linkBack: t.linkBack - from,
        linkNext: t.linkNext - from
      }));
    }));
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = this.#subTokenString(this.#offset + 1, top.match + 1);
    this.#offset = top.match + 1;
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (this.#offset < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(this.#subTokenString(this.#offset + 1, link));
      this.#offset = link;
    }
    this.#offset = top.match + 1;
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (this.#offset >= this.#tokens.length) {
      throw new Error("out-of-bounds");
    }
    return this.#tokens[this.#offset];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    this.#offset++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = this.#offset; i < this.#tokens.length; i++) {
      const token = this.#tokens[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
}
function lex(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t) => Object.freeze(t)));
}
function allowSingle(set, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
const _guard$2 = {};
const internal$1 = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
class ParamType {
  /**
   *  The local name of the parameter (or ``""`` if unbound)
   */
  name;
  /**
   *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
   *  ``"uint256[3][]"``)
   */
  type;
  /**
   *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
   */
  baseType;
  /**
   *  True if the parameters is indexed.
   *
   *  For non-indexable types this is ``null``.
   */
  indexed;
  /**
   *  The components for the tuple.
   *
   *  For non-tuple types this is ``null``.
   */
  components;
  /**
   *  The array length, or ``-1`` for dynamic-lengthed arrays.
   *
   *  For non-array types this is ``null``.
   */
  arrayLength;
  /**
   *  The type of each child in the array.
   *
   *  For non-array types this is ``null``.
   */
  arrayChildren;
  /**
   *  @private
   */
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    assertPrivate(guard, _guard$2, "ParamType");
    Object.defineProperty(this, internal$1, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c) => JSON.parse(c.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v) => _this.arrayChildren.walk(v, process));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v, i) => _this.components[i].walk(v, process));
    }
    return process(this.type, value);
  }
  #walkAsync(promises, value, process, setValue) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const childType = this.arrayChildren;
      const result2 = value.slice();
      result2.forEach((value2, index) => {
        childType.#walkAsync(promises, value2, process, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    if (this.isTuple()) {
      const components = this.components;
      let result2;
      if (Array.isArray(value)) {
        result2 = value.slice();
      } else {
        if (value == null || typeof value !== "object") {
          throw new Error("invalid tuple value");
        }
        result2 = components.map((param) => {
          if (!param.name) {
            throw new Error("cannot use object value with unnamed components");
          }
          if (!(param.name in value)) {
            throw new Error(`missing value for component ${param.name}`);
          }
          return value[param.name];
        });
      }
      if (result2.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      result2.forEach((value2, index) => {
        components[index].#walkAsync(promises, value2, process, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    const result = process(this.type, value);
    if (result.then) {
      promises.push((async function() {
        setValue(await result);
      })());
    } else {
      setValue(result);
    }
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process) {
    const promises = [];
    const result = [value];
    this.#walkAsync(promises, value, process, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ParamType.from(lex(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => ParamType.from(t));
        type2 = `tuple(${comps.map((c) => c.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new ParamType(_guard$2, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new ParamType(_guard$2, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new ParamType(_guard$2, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c) => ParamType.from(c)) : null;
      const tuple = new ParamType(_guard$2, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType(obj.type);
    return new ParamType(_guard$2, name || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal$1] === ParamTypeInternal;
  }
}
class Fragment {
  /**
   *  The type of the fragment.
   */
  type;
  /**
   *  The inputs for the fragment.
   */
  inputs;
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    assertPrivate(guard, _guard$2, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e) {
      }
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
}
class NamedFragment extends Fragment {
  /**
   *  The name of the fragment.
   */
  name;
  /**
   *  @private
   */
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
}
function joinParams(format, params) {
  return "(" + params.map((p) => p.format(format)).join(format === "full" ? ", " : ",") + ")";
}
class ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal$1, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard$2, name, inputs);
    }
    return new ErrorFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ErrorFragmentInternal;
  }
}
class EventFragment extends NamedFragment {
  /**
   *  Whether this event is anonymous.
   */
  anonymous;
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    Object.defineProperty(this, internal$1, { value: EventFragmentInternal });
    defineProperties(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new EventFragment(_guard$2, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return EventFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard$2, name, inputs, anonymous);
    }
    return new EventFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === EventFragmentInternal;
  }
}
class ConstructorFragment extends Fragment {
  /**
   *  Whether the constructor can receive an endowment.
   */
  payable;
  /**
   *  The recommended gas limit for deployment or ``null``.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    Object.defineProperty(this, internal$1, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format) {
    assert(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [`constructor${joinParams(format, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ConstructorFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard$2, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard$2, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ConstructorFragmentInternal;
  }
}
class FallbackFragment extends Fragment {
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    Object.defineProperty(this, internal$1, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FallbackFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard$2, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard$2, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard$2, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard$2, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FallbackFragmentInternal;
  }
}
class FunctionFragment extends NamedFragment {
  /**
   *  If the function is constant (e.g. ``pure`` or ``view`` functions).
   */
  constant;
  /**
   *  The returned types for the result of calling this function.
   */
  outputs;
  /**
   *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
   *  or ``pure``)
   */
  stateMutability;
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  /**
   *  The recommended gas limit to send when calling this function.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    Object.defineProperty(this, internal$1, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new FunctionFragment(_guard$2, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FunctionFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard$2, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard$2, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FunctionFragmentInternal;
  }
}
class StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal$1, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return StructFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard$2, name, inputs);
    }
    return new StructFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === StructFragmentInternal;
  }
}
const PanicReasons$1 = /* @__PURE__ */ new Map();
PanicReasons$1.set(0, "GENERIC_PANIC");
PanicReasons$1.set(1, "ASSERT_FALSE");
PanicReasons$1.set(17, "OVERFLOW");
PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
PanicReasons$1.set(34, "BAD_STORAGE_DATA");
PanicReasons$1.set(49, "STACK_UNDERFLOW");
PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(65, "OUT_OF_MEMORY");
PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data) {
    message = "execution reverted";
    const bytes2 = getBytes(data);
    data = hexlify(data);
    if (bytes2.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes2.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes2.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes2.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes2.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes2.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons$1.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data,
    reason,
    transaction,
    invocation,
    revert
  });
}
class AbiCoder {
  #getCoder(param) {
    if (param.isArray()) {
      return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
      return new TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);
    }
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
      return new FixedBytesCoder(size, param.name);
    }
    assertArgument(false, "invalid type", "type", param.type);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types) {
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types, values) {
    assertArgumentCount(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types, data, loose) {
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data) {
    return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
  }
}
class LogDescription {
  /**
   *  The matching fragment for the ``topic0``.
   */
  fragment;
  /**
   *  The name of the Event.
   */
  name;
  /**
   *  The full Event signature.
   */
  signature;
  /**
   *  The topic hash for the Event.
   */
  topic;
  /**
   *  The arguments passed into the Event with ``emit``.
   */
  args;
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature,
      topic,
      args
    });
  }
}
class TransactionDescription {
  /**
   *  The matching fragment from the transaction ``data``.
   */
  fragment;
  /**
   *  The name of the Function from the transaction ``data``.
   */
  name;
  /**
   *  The arguments passed to the Function from the transaction ``data``.
   */
  args;
  /**
   *  The full Function signature from the transaction ``data``.
   */
  signature;
  /**
   *  The selector for the Function from the transaction ``data``.
   */
  selector;
  /**
   *  The ``value`` (in wei) from the transaction.
   */
  value;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector,
      value
    });
  }
}
class ErrorDescription {
  /**
   *  The matching fragment.
   */
  fragment;
  /**
   *  The name of the Error.
   */
  name;
  /**
   *  The arguments passed to the Error with ``revert``.
   */
  args;
  /**
   *  The full Error signature.
   */
  signature;
  /**
   *  The selector for the Error.
   */
  selector;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector
    });
  }
}
class Indexed {
  /**
   *  The ``keccak256`` of the value logged.
   */
  hash;
  /**
   *  @_ignore:
   */
  _isIndexed;
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
  /**
   *  @_ignore:
   */
  constructor(hash2) {
    defineProperties(this, { hash: hash2, _isIndexed: true });
  }
}
const PanicReasons = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons[code.toString()]) {
        reason = PanicReasons[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};
class Interface {
  /**
   *  All the Contract ABI members (i.e. methods, events, errors, etc).
   */
  fragments;
  /**
   *  The Contract constructor.
   */
  deploy;
  /**
   *  The Fallback method, if any.
   */
  fallback;
  /**
   *  If receiving ether is supported.
   */
  receive;
  #errors;
  #events;
  #functions;
  //    #structs: Map<string, StructFragment>;
  #abiCoder;
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    this.#functions = /* @__PURE__ */ new Map();
    this.#errors = /* @__PURE__ */ new Map();
    this.#events = /* @__PURE__ */ new Map();
    const frags = [];
    for (const a of abi) {
      try {
        frags.push(Fragment.from(a));
      } catch (error) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    this.#abiCoder = this.getAbiCoder();
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = this.#functions;
          break;
        case "event":
          bucket = this.#events;
          break;
        case "error":
          bucket = this.#errors;
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f2) => f2.format(format));
    return abi;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi.map((j) => JSON.parse(j)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  #getFunction(key, values, forceUnique) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      for (const fragment of this.#functions.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#functions) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        const lastValue = values.length > 0 ? values[values.length - 1] : null;
        let valueLength = values.length;
        let allowOptions = true;
        if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
          allowOptions = false;
          valueLength--;
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs.length;
          if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (j >= inputs.length) {
              if (values[j].type === "overrides") {
                continue;
              }
              matching.splice(i, 1);
              break;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
        const lastArg = values[values.length - 1];
        if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
          matching.splice(0, 1);
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#functions.get(FunctionFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = this.#getFunction(key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!this.#getFunction(key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return this.#getFunction(key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names2 = Array.from(this.#functions.keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(this.#functions.get(name), i);
    }
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  #getEvent(key, values, forceUnique) {
    if (isHexString(key)) {
      const eventTopic = key.toLowerCase();
      for (const fragment of this.#events.values()) {
        if (eventTopic === fragment.topicHash) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#events) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        for (let i = matching.length - 1; i >= 0; i--) {
          if (matching[i].inputs.length < values.length) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#events.get(EventFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = this.#getEvent(key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!this.#getEvent(key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return this.#getEvent(key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names2 = Array.from(this.#events.keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(this.#events.get(name), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of this.#errors.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#errors) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = this.#errors.get(key);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names2 = Array.from(this.#errors.keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(this.#errors.get(name), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data) {
    return this.#abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this.#abiCoder.encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes2 = getBytesCopy(data);
    if (bytes2.length % 32 === 0) {
      try {
        return this.#abiCoder.decode(fragment.outputs, bytes2);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes2),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data, tx) {
    const data = getBytes(_data, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = this.#abiCoder.decode(ef.inputs, data.slice(4));
          error.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        this.#abiCoder.encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this.#abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this.#abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, concat(topics)) : null;
    const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data) {
    const hexData = hexlify(data);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new Interface(value.format("json"));
    }
    return new Interface(value);
  }
}
const BN_0$2 = BigInt(0);
function getValue(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
class FeeData {
  /**
   *  The gas price for legacy networks.
   */
  gasPrice;
  /**
   *  The maximum fee to pay per gas.
   *
   *  The base fee per gas is defined by the network and based on
   *  congestion, increasing the cost during times of heavy load
   *  and lowering when less busy.
   *
   *  The actual fee per gas will be the base fee for the block
   *  and the priority fee, up to the max fee per gas.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxFeePerGas;
  /**
   *  The additional amout to pay per gas to encourage a validator
   *  to include the transaction.
   *
   *  The purpose of this is to compensate the validator for the
   *  adjusted risk for including a given transaction.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxPriorityFeePerGas;
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    defineProperties(this, {
      gasPrice: getValue(gasPrice),
      maxFeePerGas: getValue(maxFeePerGas),
      maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if (req.authorizationList) {
    result.authorizationList = req.authorizationList.slice();
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b2) => {
      if (isBytesLike(b2)) {
        return hexlify(b2);
      }
      return Object.assign({}, b2);
    });
  }
  return result;
}
class Block {
  /**
   *  The provider connected to the block used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The block number, sometimes called the block height. This is a
   *  sequential number that is one higher than the parent block.
   */
  number;
  /**
   *  The block hash.
   *
   *  This hash includes all properties, so can be safely used to identify
   *  an exact set of block properties.
   */
  hash;
  /**
   *  The timestamp for this block, which is the number of seconds since
   *  epoch that this block was included.
   */
  timestamp;
  /**
   *  The block hash of the parent block.
   */
  parentHash;
  /**
   *  The hash tree root of the parent beacon block for the given
   *  execution block. See [[link-eip-4788]].
   */
  parentBeaconBlockRoot;
  /**
   *  The nonce.
   *
   *  On legacy networks, this is the random number inserted which
   *  permitted the difficulty target to be reached.
   */
  nonce;
  /**
   *  The difficulty target.
   *
   *  On legacy networks, this is the proof-of-work target required
   *  for a block to meet the protocol rules to be included.
   *
   *  On modern networks, this is a random number arrived at using
   *  randao.  @TODO: Find links?
   */
  difficulty;
  /**
   *  The total gas limit for this block.
   */
  gasLimit;
  /**
   *  The total gas used in this block.
   */
  gasUsed;
  /**
   *  The root hash for the global state after applying changes
   *  in this block.
   */
  stateRoot;
  /**
   *  The hash of the transaction receipts trie.
   */
  receiptsRoot;
  /**
   *  The total amount of blob gas consumed by the transactions
   *  within the block. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The running total of blob gas consumed in excess of the
   *  target, prior to the block. See [[link-eip-4844]].
   */
  excessBlobGas;
  /**
   *  The miner coinbase address, wihch receives any subsidies for
   *  including this block.
   */
  miner;
  /**
   *  The latest RANDAO mix of the post beacon state of
   *  the previous block.
   */
  prevRandao;
  /**
   *  Any extra data the validator wished to include.
   */
  extraData;
  /**
   *  The base fee per gas that all transactions in this block were
   *  charged.
   *
   *  This adjusts after each block, depending on how congested the network
   *  is.
   */
  baseFeePerGas;
  #transactions;
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block, provider) {
    this.#transactions = block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    });
    defineProperties(this, {
      provider,
      hash: getValue(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return this.#transactions.map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = this.#transactions.slice();
    if (txs.length === 0) {
      return [];
    }
    assert(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash2, miner, prevRandao, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash: hash2,
      miner,
      prevRandao,
      nonce,
      number: number2,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return this.#transactions.length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = this.#transactions[indexOrHash];
    } else {
      const hash2 = indexOrHash.toLowerCase();
      for (const v of this.#transactions) {
        if (typeof v === "string") {
          if (v !== hash2) {
            continue;
          }
          tx = v;
          break;
        } else {
          if (v.hash !== hash2) {
            continue;
          }
          tx = v;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
}
class Log {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The transaction hash of the transaction this log occurred in. Use the
   *  [[Log-getTransaction]] to get the [[TransactionResponse]].
   */
  transactionHash;
  /**
   *  The block hash of the block this log occurred in. Use the
   *  [[Log-getBlock]] to get the [[Block]].
   */
  blockHash;
  /**
   *  The block number of the block this log occurred in. It is preferred
   *  to use the [[Block-hash]] when fetching the related [[Block]],
   *  since in the case of an orphaned block, the block at that height may
   *  have changed.
   */
  blockNumber;
  /**
   *  If the **Log** represents a block that was removed due to an orphaned
   *  block, this will be true.
   *
   *  This can only happen within an orphan event listener.
   */
  removed;
  /**
   *  The address of the contract that emitted this log.
   */
  address;
  /**
   *  The data included in this log when it was emitted.
   */
  data;
  /**
   *  The indexed topics included in this log when it was emitted.
   *
   *  All topics are included in the bloom filters, so they can be
   *  efficiently filtered using the [[Provider-getLogs]] method.
   */
  topics;
  /**
   *  The index within the block this log occurred at. This is generally
   *  not useful to developers, but can be used with the various roots
   *  to proof inclusion within a block.
   */
  index;
  /**
   *  The index within the transaction of this log.
   */
  transactionIndex;
  /**
   *  @_ignore:
   */
  constructor(log, provider) {
    this.provider = provider;
    const topics = Object.freeze(log.topics.slice());
    defineProperties(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter(this);
  }
}
class TransactionReceipt {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The address the transaction was sent to.
   */
  to;
  /**
   *  The sender of the transaction.
   */
  from;
  /**
   *  The address of the contract if the transaction was directly
   *  responsible for deploying one.
   *
   *  This is non-null **only** if the ``to`` is empty and the ``data``
   *  was successfully executed as initcode.
   */
  contractAddress;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The index of this transaction within the block transactions.
   */
  index;
  /**
   *  The block hash of the [[Block]] this transaction was included in.
   */
  blockHash;
  /**
   *  The block number of the [[Block]] this transaction was included in.
   */
  blockNumber;
  /**
   *  The bloom filter bytes that represent all logs that occurred within
   *  this transaction. This is generally not useful for most developers,
   *  but can be used to validate the included logs.
   */
  logsBloom;
  /**
   *  The actual amount of gas used by this transaction.
   *
   *  When creating a transaction, the amount of gas that will be used can
   *  only be approximated, but the sender must pay the gas fee for the
   *  entire gas limit. After the transaction, the difference is refunded.
   */
  gasUsed;
  /**
   *  The gas used for BLObs. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The amount of gas used by all transactions within the block for this
   *  and all transactions with a lower ``index``.
   *
   *  This is generally not useful for developers but can be used to
   *  validate certain aspects of execution.
   */
  cumulativeGasUsed;
  /**
   *  The actual gas price used during execution.
   *
   *  Due to the complexity of [[link-eip-1559]] this value can only
   *  be caluclated after the transaction has been mined, snce the base
   *  fee is protocol-enforced.
   */
  gasPrice;
  /**
   *  The price paid per BLOB in gas. See [[link-eip-4844]].
   */
  blobGasPrice;
  /**
   *  The [[link-eip-2718]] transaction type.
   */
  type;
  //readonly byzantium!: boolean;
  /**
   *  The status of this transaction, indicating success (i.e. ``1``) or
   *  a revert (i.e. ``0``).
   *
   *  This is available in post-byzantium blocks, but some backends may
   *  backfill this value.
   */
  status;
  /**
   *  The root hash of this transaction.
   *
   *  This is no present and was only included in pre-byzantium blocks, but
   *  could be used to validate certain parts of the receipt.
   */
  root;
  #logs;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.#logs = Object.freeze(tx.logs.map((log) => {
      return new Log(log, provider);
    }));
    let gasPrice = BN_0$2;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return this.#logs;
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash2,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash2,
      index,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
}
class TransactionResponse {
  /**
   *  The provider this is connected to, which will influence how its
   *  methods will resolve its async inspection methods.
   */
  provider;
  /**
   *  The block number of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockNumber;
  /**
   *  The blockHash of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockHash;
  /**
   *  The index within the block that this transaction resides at.
   */
  index;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The [[link-eip-2718]] transaction envelope type. This is
   *  ``0`` for legacy transactions types.
   */
  type;
  /**
   *  The receiver of this transaction.
   *
   *  If ``null``, then the transaction is an initcode transaction.
   *  This means the result of executing the [[data]] will be deployed
   *  as a new contract on chain (assuming it does not revert) and the
   *  address may be computed using [[getCreateAddress]].
   */
  to;
  /**
   *  The sender of this transaction. It is implicitly computed
   *  from the transaction pre-image hash (as the digest) and the
   *  [[signature]] using ecrecover.
   */
  from;
  /**
   *  The nonce, which is used to prevent replay attacks and offer
   *  a method to ensure transactions from a given sender are explicitly
   *  ordered.
   *
   *  When sending a transaction, this must be equal to the number of
   *  transactions ever sent by [[from]].
   */
  nonce;
  /**
   *  The maximum units of gas this transaction can consume. If execution
   *  exceeds this, the entries transaction is reverted and the sender
   *  is charged for the full amount, despite not state changes being made.
   */
  gasLimit;
  /**
   *  The gas price can have various values, depending on the network.
   *
   *  In modern networks, for transactions that are included this is
   *  the //effective gas price// (the fee per gas that was actually
   *  charged), while for transactions that have not been included yet
   *  is the [[maxFeePerGas]].
   *
   *  For legacy transactions, or transactions on legacy networks, this
   *  is the fee that will be charged per unit of gas the transaction
   *  consumes.
   */
  gasPrice;
  /**
   *  The maximum priority fee (per unit of gas) to allow a
   *  validator to charge the sender. This is inclusive of the
   *  [[maxFeeFeePerGas]].
   */
  maxPriorityFeePerGas;
  /**
   *  The maximum fee (per unit of gas) to allow this transaction
   *  to charge the sender.
   */
  maxFeePerGas;
  /**
   *  The [[link-eip-4844]] max fee per BLOb gas.
   */
  maxFeePerBlobGas;
  /**
   *  The data.
   */
  data;
  /**
   *  The value, in wei. Use [[formatEther]] to format this value
   *  as ether.
   */
  value;
  /**
   *  The chain ID.
   */
  chainId;
  /**
   *  The signature.
   */
  signature;
  /**
   *  The [[link-eip-2930]] access list for transaction types that
   *  support it, otherwise ``null``.
   */
  accessList;
  /**
   *  The [[link-eip-4844]] BLOb versioned hashes.
   */
  blobVersionedHashes;
  /**
   *  The [[link-eip-7702]] authorizations (if any).
   */
  authorizationList;
  #startBlock;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;
    this.#startBlock = -1;
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index, hash: hash2, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash2,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature,
      to,
      index,
      type,
      value: toJson(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout == null ? 0 : _timeout;
    let startBlock = this.#startBlock;
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < this.#startBlock) {
          nextScan = this.#startBlock;
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash2 of block) {
          if (hash2 === this.hash) {
            return;
          }
        }
        for (let i = 0; i < block.length; i++) {
          const tx = await block.getTransaction(i);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$2) {
              reason = "cancelled";
            }
            assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (confirms === 1 || await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c) => c());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new TransactionResponse(this, this.provider);
    tx.#startBlock = startBlock;
    return tx;
  }
}
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
}
class EventLog extends Log {
  /**
   *  The Contract Interface.
   */
  interface;
  /**
   *  The matching event.
   */
  fragment;
  /**
   *  The parsed arguments passed to the event by ``emit``.
   */
  args;
  /**
   * @_ignore:
   */
  constructor(log, iface, fragment) {
    super(log, log.provider);
    const args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties(this, { args, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class UndecodedEventLog extends Log {
  /**
   *  The error encounted when trying to decode the log.
   */
  error;
  /**
   * @_ignore:
   */
  constructor(log, error) {
    super(log, log.provider);
    defineProperties(this, { error });
  }
}
class ContractTransactionReceipt extends TransactionReceipt {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log) => {
      const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log, this.#iface, fragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return log;
    });
  }
}
class ContractTransactionResponse extends TransactionResponse {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
  }
}
class ContractUnknownEventPayload extends EventPayload {
  /**
   *  The log with no matching events.
   */
  log;
  /**
   *  @_event:
   */
  constructor(contract, listener, filter, log) {
    super(contract, listener, filter);
    defineProperties(this, { log });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class ContractEventPayload extends ContractUnknownEventPayload {
  /**
   *  @_ignore:
   */
  constructor(contract, listener, filter, fragment, _log) {
    super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const BN_0$1 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
class PreparedTopicFilter {
  #filter;
  fragment;
  constructor(contract, fragment, args) {
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    this.#filter = (async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v) => resolveAddress(v, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    })();
  }
  getTopicFilter() {
    return this.#filter;
  }
}
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider$1(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_0$1, "overrides.value") === BN_0$1;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider$1(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas2 = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract,
    estimateGas: estimateGas2,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider = getProvider$1(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas2 = async function(...args) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract.interface.getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment,
    estimateGas: estimateGas2,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract.interface.getEventName(key),
    _contract: contract,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
const internal = Symbol.for("_ethersInternal_contract");
const internalValues = /* @__PURE__ */ new WeakMap();
function setInternal(contract, values) {
  internalValues.set(contract[internal], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e) => {
      if (e == null) {
        return null;
      }
      if (Array.isArray(e)) {
        return e.map(topicHashify);
      }
      return topicHashify(e);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider = getProvider$1(contract.runner);
  assert(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter = { address, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
let lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error) {
    }
    return !once;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {
  }
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
const passProperties = ["then"];
class BaseContract {
  /**
   *  The target to connect to.
   *
   *  This can be an address, ENS name or any [[Addressable]], such as
   *  another contract. To get the resovled address, use the ``getAddress``
   *  method.
   */
  target;
  /**
   *  The contract Interface.
   */
  interface;
  /**
   *  The connected runner. This is generally a [[Provider]] or a
   *  [[Signer]], which dictates what operations are supported.
   *
   *  For example, a **Contract** connected to a [[Provider]] may
   *  only execute read-only operations.
   */
  runner;
  /**
   *  All the Events available on this contract.
   */
  filters;
  /**
   *  @_ignore:
   */
  [internal];
  /**
   *  The fallback or receive function if any.
   */
  fallback;
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi, runner, _deployTx) {
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider$1(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider = getProvider$1(this.runner);
    assert(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider = getProvider$1(this.runner);
    assert(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve(this);
          }
          provider.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash2) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider = getProvider$1(this.runner);
    assert(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter)).map((log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return new Log(log, provider);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi) {
    class CustomContract extends BaseContract {
      constructor(address, runner = null) {
        super(address, abi, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi, runner);
    return contract;
  }
}
function _ContractBase() {
  return BaseContract;
}
class Contract extends _ContractBase() {
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
class MulticoinProviderPlugin {
  /**
   *  The name.
   */
  name;
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data) {
    throw new Error("unsupported coin");
  }
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
class EnsResolver {
  /**
   *  The connected provider.
   */
  provider;
  /**
   *  The address of the resolver.
   */
  address;
  /**
   *  The name this resolver was resolved against.
   */
  name;
  // For EIP-2544 names, the ancestor that provided the resolver
  #supports2544;
  #resolver;
  constructor(provider, address, name) {
    defineProperties(this, { provider, address, name });
    this.#supports2544 = null;
    this.#resolver = new Contract(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider);
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (this.#supports2544 == null) {
      this.#supports2544 = (async () => {
        try {
          return await this.#resolver.supportsInterface("0x9061b923");
        } catch (error) {
          if (isError(error, "CALL_EXCEPTION")) {
            return false;
          }
          this.#supports2544 = null;
          throw error;
        }
      })();
    }
    return await this.#supports2544;
  }
  async #fetch(funcName, params) {
    params = (params || []).slice();
    const iface = this.#resolver.interface;
    params.unshift(namehash(this.name));
    let fragment = null;
    if (await this.supportsWildcard()) {
      fragment = iface.getFunction(funcName);
      assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
        info: { funcName }
      });
      params = [
        dnsEncode(this.name, 255),
        iface.encodeFunctionData(fragment, params)
      ];
      funcName = "resolve(bytes,bytes)";
    }
    params.push({
      enableCcipRead: true
    });
    try {
      const result = await this.#resolver[funcName](...params);
      if (fragment) {
        return iface.decodeFunctionResult(fragment, result)[0];
      }
      return result;
    } catch (error) {
      if (!isError(error, "CALL_EXCEPTION")) {
        throw error;
      }
    }
    return null;
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await this.#fetch("addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error) {
        if (isError(error, "CALL_EXCEPTION")) {
          return null;
        }
        throw error;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data2 = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data2, 20)) {
        return getAddress(data2);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data = await this.#fetch("addr(bytes32,uint)", [coinType]);
    if (data == null || data === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data);
    if (address != null) {
      return address;
    }
    assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key) {
    const data = await this.#fetch("text(bytes32,string)", [key]);
    if (data == null || data === "0x") {
      return null;
    }
    return data;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data = await this.#fetch("contenthash(bytes32)");
    if (data == null || data === "0x") {
      return null;
    }
    const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i = 0; i < matchers.length; i++) {
        const match = avatar.match(matchers[i]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract = new Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error2) {
                const bytes2 = response.body;
                if (bytes2) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes2) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider) {
    const network = await provider.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  static async #getResolver(provider, name) {
    const ensAddr = await EnsResolver.getEnsAddress(provider);
    try {
      const contract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], provider);
      const addr = await contract.resolver(namehash(name), {
        enableCcipRead: true
      });
      if (addr === ZeroAddress) {
        return null;
      }
      return addr;
    } catch (error) {
      throw error;
    }
    return null;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider, name) {
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await EnsResolver.#getResolver(provider, currentName);
      if (addr != null) {
        const resolver = new EnsResolver(provider, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
}
const BN_0 = BigInt(0);
function allowNull(format, nullValue) {
  return (function(value) {
    if (value == null) {
      return nullValue;
    }
    return format(value);
  });
}
function arrayOf(format, allowNull2) {
  return ((array) => {
    if (allowNull2 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format(i));
  });
}
function object(format, altNames) {
  return ((value) => {
    const result = {};
    for (const key in format) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format[key](value[srcKey]);
        if (nv !== void 0) {
          result[key] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  });
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
const _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
const _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
const _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
const _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_0) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object({
    hash: formatHash,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull(getNumber, void 0),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    authorizationList: allowNull(arrayOf((v) => {
      let sig;
      if (v.signature) {
        sig = v.signature;
      } else {
        let yParity = v.yParity;
        if (yParity === "0x1b") {
          yParity = 0;
        } else if (yParity === "0x1c") {
          yParity = 1;
        }
        sig = Object.assign({}, v, { yParity });
      }
      return {
        address: getAddress(v.address),
        chainId: getBigInt(v.chainId),
        nonce: getBigInt(v.nonce),
        signature: Signature.from(sig)
      };
    }, false), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature.from(value.signature);
  } else {
    result.signature = Signature.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
    result.blockHash = null;
  }
  return result;
}
const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class NetworkPlugin {
  /**
   *  The name of the plugin.
   *
   *  It is recommended to use reverse-domain-notation, which permits
   *  unique names with a known authority as well as hierarchal entries.
   */
  name;
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new NetworkPlugin(this.name);
  }
}
class GasCostPlugin extends NetworkPlugin {
  /**
   *  The block number to treat these values as valid from.
   *
   *  This allows a hardfork to have updated values included as well as
   *  mulutiple hardforks to be supported.
   */
  effectiveBlock;
  /**
   *  The transactions base fee.
   */
  txBase;
  /**
   *  The fee for creating a new account.
   */
  txCreate;
  /**
   *  The fee per zero-byte in the data.
   */
  txDataZero;
  /**
   *  The fee per non-zero-byte in the data.
   */
  txDataNonzero;
  /**
   *  The fee per storage key in the [[link-eip-2930]] access list.
   */
  txAccessListStorageKey;
  /**
   *  The fee per address in the [[link-eip-2930]] access list.
   */
  txAccessListAddress;
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    const props = { effectiveBlock };
    function set(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set("txBase", 21e3);
    set("txCreate", 32e3);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}
class EnsPlugin extends NetworkPlugin {
  /**
   *  The ENS Registrty Contract address.
   */
  address;
  /**
   *  The chain ID that the ENS contract lives on.
   */
  targetNetwork;
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    defineProperties(this, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}
class FeeDataNetworkPlugin extends NetworkPlugin {
  #feeDataFunc;
  /**
   *  The fee data function provided to the constructor.
   */
  get feeDataFunc() {
    return this.#feeDataFunc;
  }
  /**
   *  Creates a new **FeeDataNetworkPlugin**.
   */
  constructor(feeDataFunc) {
    super("org.ethers.plugins.network.FeeData");
    this.#feeDataFunc = feeDataFunc;
  }
  /**
   *  Resolves to the fee data.
   */
  async getFeeData(provider) {
    return await this.#feeDataFunc(provider);
  }
  clone() {
    return new FeeDataNetworkPlugin(this.#feeDataFunc);
  }
}
class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  #url;
  #processFunc;
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return this.#url;
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return this.#processFunc;
  }
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    this.#url = url;
    this.#processFunc = processFunc;
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
const Networks = /* @__PURE__ */ new Map();
class Network {
  #name;
  #chainId;
  #plugins;
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name, chainId) {
    this.#name = name;
    this.#chainId = getBigInt(chainId);
    this.#plugins = /* @__PURE__ */ new Map();
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return this.#name;
  }
  set name(value) {
    this.#name = value;
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value, "chainId");
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename) {
    return this.plugins.filter((p) => p.name.split("#")[0] === basename);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i = 2; i < tx.data.length; i += 2) {
        if (tx.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom = new Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
}
function parseUnits(_value, decimals) {
  const value = String(_value);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
    }
  });
}
let injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin());
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}
function copy$2(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class PollingBlockSubscriber {
  #provider;
  #poller;
  #interval;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#poller = null;
    this.#interval = 4e3;
    this.#blockNumber = -2;
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return this.#interval;
  }
  set pollingInterval(value) {
    this.#interval = value;
  }
  async #poll() {
    try {
      const blockNumber = await this.#provider.getBlockNumber();
      if (this.#blockNumber === -2) {
        this.#blockNumber = blockNumber;
        return;
      }
      if (blockNumber !== this.#blockNumber) {
        for (let b2 = this.#blockNumber + 1; b2 <= blockNumber; b2++) {
          if (this.#poller == null) {
            return;
          }
          await this.#provider.emit("block", b2);
        }
        this.#blockNumber = blockNumber;
      }
    } catch (error) {
    }
    if (this.#poller == null) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
  }
  start() {
    if (this.#poller) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    this.#poll();
  }
  stop() {
    if (!this.#poller) {
      return;
    }
    this.#provider._clearTimeout(this.#poller);
    this.#poller = null;
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
}
class OnBlockSubscriber {
  #provider;
  #poll;
  #running;
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#running = false;
    this.#poll = (blockNumber) => {
      this._poll(blockNumber, this.#provider);
    };
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
    this.#provider.on("block", this.#poll);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poll);
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
class PollingBlockTagSubscriber extends OnBlockSubscriber {
  #tag;
  #lastBlock;
  constructor(provider, tag) {
    super(provider);
    this.#tag = tag;
    this.#lastBlock = -2;
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#lastBlock = -2;
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider) {
    const block = await provider.getBlock(this.#tag);
    if (block == null) {
      return;
    }
    if (this.#lastBlock === -2) {
      this.#lastBlock = block.number;
    } else if (block.number > this.#lastBlock) {
      provider.emit(this.#tag, block.number);
      this.#lastBlock = block.number;
    }
  }
}
class PollingOrphanSubscriber extends OnBlockSubscriber {
  #filter;
  constructor(provider, filter) {
    super(provider);
    this.#filter = copy$2(filter);
  }
  async _poll(blockNumber, provider) {
    throw new Error("@TODO");
  }
}
class PollingTransactionSubscriber extends OnBlockSubscriber {
  #hash;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider, hash2) {
    super(provider);
    this.#hash = hash2;
  }
  async _poll(blockNumber, provider) {
    const tx = await provider.getTransactionReceipt(this.#hash);
    if (tx) {
      provider.emit(this.#hash, tx);
    }
  }
}
class PollingEventSubscriber {
  #provider;
  #filter;
  #poller;
  #running;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = copy$2(filter);
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#blockNumber = -2;
  }
  async #poll(blockNumber) {
    if (this.#blockNumber === -2) {
      return;
    }
    const filter = copy$2(this.#filter);
    filter.fromBlock = this.#blockNumber + 1;
    filter.toBlock = blockNumber;
    const logs = await this.#provider.getLogs(filter);
    if (logs.length === 0) {
      if (this.#blockNumber < blockNumber - 60) {
        this.#blockNumber = blockNumber - 60;
      }
      return;
    }
    for (const log of logs) {
      this.#provider.emit(this.#filter, log);
      this.#blockNumber = log.blockNumber;
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    if (this.#blockNumber === -2) {
      this.#provider.getBlockNumber().then((blockNumber) => {
        this.#blockNumber = blockNumber;
      });
    }
    this.#provider.on("block", this.#poller);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
}
const BN_2 = BigInt(2);
const MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k, v) => {
    if (v == null) {
      return "null";
    }
    if (typeof v === "bigint") {
      return `bigint:${v.toString()}`;
    }
    if (typeof v === "string") {
      return v.toLowerCase();
    }
    if (typeof v === "object" && !Array.isArray(v)) {
      const keys = Object.keys(v);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v[key];
        return accum;
      }, {});
    }
    return v;
  });
}
class UnmanagedSubscriber {
  /**
   *  The name fof the event.
   */
  name;
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
}
function copy$1(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event, provider) {
  if (_event == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event)) {
    _event = { topics: _event };
  }
  if (typeof _event === "string") {
    switch (_event) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event, tag: _event };
      }
    }
  }
  if (isHexString(_event, 32)) {
    const hash2 = _event.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash: hash2 }), hash: hash2 };
  }
  if (_event.orphan) {
    const event = _event;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy$1(event) };
  }
  if (_event.address || _event.topics) {
    const event = _event;
    const filter = {
      topics: (event.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter.address = concisify(addresses.map((a) => a.toLowerCase()));
    }
    return { filter, tag: getTag("event", filter), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const defaultOptions$1 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class AbstractProvider {
  #subs;
  #plugins;
  // null=unpaused, true=paused+dropWhilePaused, false=paused
  #pausedState;
  #destroyed;
  #networkPromise;
  #anyNetwork;
  #performCache;
  // The most recent block number if running an event or -1 if no "block" event
  #lastBlockNumber;
  #nextTimer;
  #timers;
  #disableCcipRead;
  #options;
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network, options) {
    this.#options = Object.assign({}, defaultOptions$1, options || {});
    if (_network === "any") {
      this.#anyNetwork = true;
      this.#networkPromise = null;
    } else if (_network) {
      const network = Network.from(_network);
      this.#anyNetwork = false;
      this.#networkPromise = Promise.resolve(network);
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      this.#anyNetwork = false;
      this.#networkPromise = null;
    }
    this.#lastBlockNumber = -1;
    this.#performCache = /* @__PURE__ */ new Map();
    this.#subs = /* @__PURE__ */ new Map();
    this.#plugins = /* @__PURE__ */ new Map();
    this.#pausedState = null;
    this.#destroyed = false;
    this.#nextTimer = 1;
    this.#timers = /* @__PURE__ */ new Map();
    this.#disableCcipRead = false;
  }
  get pollingInterval() {
    return this.#options.pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return this.#disableCcipRead;
  }
  set disableCcipRead(value) {
    this.#disableCcipRead = !!value;
  }
  // Shares multiple identical requests made during the same 250ms
  async #perform(req) {
    const timeout = this.#options.cacheTimeout;
    if (timeout < 0) {
      return await this._perform(req);
    }
    const tag = getTag(req.method, req);
    let perform = this.#performCache.get(tag);
    if (!perform) {
      perform = this._perform(req);
      this.#performCache.set(tag, perform);
      setTimeout(() => {
        if (this.#performCache.get(tag) === perform) {
          this.#performCache.delete(tag);
        }
      }, timeout);
    }
    return await perform;
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data = calldata.toLowerCase();
    const errorMessages = [];
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const href = url.replace("{sender}", sender).replace("{data}", data);
      const request = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request.body = { data, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
      let errorMessage = "unknown error";
      let resp;
      try {
        resp = await request.send();
      } catch (error) {
        errorMessages.push(error.message);
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error } });
        continue;
      }
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
      } catch (error) {
      }
      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network) {
    return new Block(formatBlock(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network) {
    return new Log(formatLog(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber(await this.#perform({ method: "getBlockNumber" }), "%response");
    if (this.#lastBlockNumber >= 0) {
      this.#lastBlockNumber = blockNumber;
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (this.#lastBlockNumber >= 0) {
        return toQuantity(this.#lastBlockNumber + blockTag);
      }
      return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        return concisify(t.map((t2) => t2.toLowerCase()));
      }
      return t.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a) => typeof a !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request) {
    const request = copyRequest(_request);
    const promises = [];
    ["to", "from"].forEach((key) => {
      if (request[key] == null) {
        return;
      }
      const addr = resolveAddress(request[key], this);
      if (isPromise(addr)) {
        promises.push((async function() {
          request[key] = await addr;
        })());
      } else {
        request[key] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise(blockTag)) {
        promises.push((async function() {
          request.blockTag = await blockTag;
        })());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return (async function() {
        await Promise.all(promises);
        return request;
      })();
    }
    return request;
  }
  async getNetwork() {
    if (this.#networkPromise == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error) {
          if (this.#networkPromise === detectNetwork) {
            this.#networkPromise = null;
          }
          throw error;
        }
      })();
      this.#networkPromise = detectNetwork;
      return (await detectNetwork).clone();
    }
    const networkPromise = this.#networkPromise;
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (this.#anyNetwork) {
        this.emit("network", actual, expected);
        if (this.#networkPromise === networkPromise) {
          this.#networkPromise = Promise.resolve(actual);
        }
      } else {
        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties({
        _block: this.#getBlock("latest", false),
        gasPrice: (async () => {
          try {
            const value = await this.#perform({ method: "getGasPrice" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await this.#perform({ method: "getPriorityFee" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise(tx)) {
      tx = await tx;
    }
    return getBigInt(await this.#perform({
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async #call(tx, blockTag, attempt) {
    assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
      reason: "TOO_MANY_REDIRECTS",
      transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
    });
    const transaction = copyRequest(tx);
    try {
      return hexlify(await this._perform({ method: "call", transaction, blockTag }));
    } catch (error) {
      if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
        const data = error.data;
        const txSender = await resolveAddress(transaction.to, this);
        let ccipArgs;
        try {
          ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
        } catch (error2) {
          assert(false, error2.message, "OFFCHAIN_FAULT", {
            reason: "BAD_DATA",
            transaction,
            info: { data }
          });
        }
        assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
          action: "call",
          data,
          reason: "OffchainLookup",
          transaction,
          invocation: null,
          revert: {
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            name: "OffchainLookup",
            args: ccipArgs.errorArgs
          }
        });
        const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
        assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
          reason: "FETCH_FAILED",
          transaction,
          info: { data: error.data, errorArgs: ccipArgs.errorArgs }
        });
        const tx2 = {
          to: txSender,
          data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
        };
        this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
        try {
          const result = await this.#call(tx2, blockTag, attempt + 1);
          this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
          return result;
        } catch (error2) {
          this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
          throw error2;
        }
      }
      throw error;
    }
  }
  async #checkNetwork(promise) {
    const { value } = await resolveProperties({
      network: this.getNetwork(),
      value: promise
    });
    return value;
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  // Account
  async #getAccountValue(request, _address, _blockTag) {
    let address = this._getAddress(_address);
    let blockTag = this._getBlockTag(_blockTag);
    if (typeof address !== "string" || typeof blockTag !== "string") {
      [address, blockTag] = await Promise.all([address, blockTag]);
    }
    return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));
  }
  async getBalance(address, blockTag) {
    return getBigInt(await this.#getAccountValue({ method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber(await this.#getAccountValue({ method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify(await this.#getAccountValue({ method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await this.#getAccountValue({ method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash2, network } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash2) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  async #getBlock(block, includeTransactions) {
    if (isHexString(block, 32)) {
      return await this.#perform({
        method: "getBlock",
        blockHash: block,
        includeTransactions
      });
    }
    let blockTag = this._getBlockTag(block);
    if (typeof blockTag !== "string") {
      blockTag = await blockTag;
    }
    return await this.#perform({
      method: "getBlock",
      blockTag,
      includeTransactions
    });
  }
  // Queries
  async getBlock(block, prefetchTxs) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#getBlock(block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash2) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransaction", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash2) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransactionReceipt", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await this.#perform({ method: "getTransaction", hash: hash2 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash2) {
    const { result } = await resolveProperties({
      network: this.getNetwork(),
      result: this.#perform({ method: "getTransactionResult", hash: hash2 })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  // Bloom-filter Queries
  async getLogs(_filter) {
    let filter = this._getFilter(_filter);
    if (isPromise(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getLogs", filter })
    });
    return params.map((p) => this._wrapLog(p, network));
  }
  // ENS
  _getProvider(chainId) {
    assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress(address);
    const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check = await this.resolveName(name);
      if (check !== address) {
        return null;
      }
      return name;
    } catch (error) {
      if (isError(error, "BAD_DATA") && error.value === "0x") {
        return null;
      }
      if (isError(error, "CALL_EXCEPTION")) {
        return null;
      }
      throw error;
    }
    return null;
  }
  async waitForTransaction(hash2, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash2);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = (async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash2);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error) {
          console.log("EEE", error);
        }
        this.once("block", listener);
      });
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = this.#timers.get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    this.#timers.delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = this.#nextTimer++;
    const func = () => {
      this.#timers.delete(timerId);
      _func();
    };
    if (this.paused) {
      this.#timers.set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      this.#timers.set(timerId, { timer, func, time: getTime() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub of this.#subs.values()) {
      func(sub.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub.type);
      case "event":
        return new PollingEventSubscriber(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of this.#subs.values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (this.#pausedState != null) {
          newSub.pause(this.#pausedState);
        }
        break;
      }
    }
  }
  async #hasSub(event, emitArgs) {
    let sub = await getSubscription(event, this);
    if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
      sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
    }
    return this.#subs.get(sub.tag) || null;
  }
  async #getSub(event) {
    const subscription = await getSubscription(event, this);
    const tag = subscription.tag;
    let sub = this.#subs.get(tag);
    if (!sub) {
      const subscriber = this._getSubscriber(subscription);
      const addressableMap = /* @__PURE__ */ new WeakMap();
      const nameMap = /* @__PURE__ */ new Map();
      sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
      this.#subs.set(tag, sub);
    }
    return sub;
  }
  async on(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub = await this.#hasSub(event, args);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once }) => {
      const payload = new EventPayload(this, once ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error) {
      }
      return !once;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners } of this.#subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners } of this.#subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await this.#hasSub(event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await this.#getSub(event);
      if (started) {
        subscriber.stop();
      }
      this.#subs.delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of this.#subs) {
        if (started) {
          subscriber.stop();
        }
        this.#subs.delete(tag);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of this.#timers.keys()) {
      this._clearTimeout(timerId);
    }
    this.#destroyed = true;
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return this.#pausedState != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    this.#lastBlockNumber = -1;
    if (this.#pausedState != null) {
      if (this.#pausedState == !!dropWhilePaused) {
        return;
      }
      assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s) => s.pause(dropWhilePaused));
    this.#pausedState = !!dropWhilePaused;
    for (const timer of this.#timers.values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (this.#pausedState == null) {
      return;
    }
    this._forEachSubscriber((s) => s.resume());
    this.#pausedState = null;
    for (const timer of this.#timers.values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime();
      setTimeout(timer.func, timeout);
    }
  }
}
function _parseString(result, start) {
  try {
    const bytes2 = _parseBytes(result, start);
    if (bytes2) {
      return toUtf8String(bytes2);
    }
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error) {
  }
  return null;
}
function numPad(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
const empty = new Uint8Array([]);
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data = getBytes(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return concat(result);
}
const zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data, 0, 32);
  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data, 32, 64));
    const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data, urlsOffset + 32);
    for (let u = 0; u < urlsLength; u++) {
      const url = _parseString(urlsData, u * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data, 96, 100);
  try {
    const extraData = _parseBytes(data, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
  return result;
}
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}
class AbstractSigner {
  /**
   *  The provider this signer is connected to.
   */
  provider;
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    defineProperties(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          if (pop.authorizationList && pop.authorizationList.length) {
            pop.type = 4;
          } else {
            pop.type = 2;
          }
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async populateAuthorization(_auth) {
    const auth = Object.assign({}, _auth);
    if (auth.chainId == null) {
      auth.chainId = (await checkProvider(this, "getNetwork").getNetwork()).chainId;
    }
    if (auth.nonce == null) {
      auth.nonce = await this.getNonce();
    }
    return auth;
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
  // @TODO: in v7 move this to be abstract
  authorize(authorization) {
    assert(false, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
  }
}
class VoidSigner extends AbstractSigner {
  /**
   *  The signer address.
   */
  address;
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  constructor(address, provider) {
    super(provider);
    defineProperties(this, { address });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
  #throwUnsupported(suffix, operation) {
    assert(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
  }
  async signTransaction(tx) {
    this.#throwUnsupported("transactions", "signTransaction");
  }
  async signMessage(message) {
    this.#throwUnsupported("messages", "signMessage");
  }
  async signTypedData(domain, types, value) {
    this.#throwUnsupported("typed-data", "signTypedData");
  }
}
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class FilterIdSubscriber {
  #provider;
  #filterIdPromise;
  #poller;
  #running;
  #network;
  #hault;
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#filterIdPromise = null;
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#network = null;
    this.#hault = false;
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider, result) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider) {
    throw new Error("subclasses must override this");
  }
  async #poll(blockNumber) {
    try {
      if (this.#filterIdPromise == null) {
        this.#filterIdPromise = this._subscribe(this.#provider);
      }
      let filterId = null;
      try {
        filterId = await this.#filterIdPromise;
      } catch (error) {
        if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
          throw error;
        }
      }
      if (filterId == null) {
        this.#filterIdPromise = null;
        this.#provider._recoverSubscriber(this, this._recover(this.#provider));
        return;
      }
      const network = await this.#provider.getNetwork();
      if (!this.#network) {
        this.#network = network;
      }
      if (this.#network.chainId !== network.chainId) {
        throw new Error("chaid changed");
      }
      if (this.#hault) {
        return;
      }
      const result = await this.#provider.send("eth_getFilterChanges", [filterId]);
      await this._emitResults(this.#provider, result);
    } catch (error) {
      console.log("@TODO", error);
    }
    this.#provider.once("block", this.#poller);
  }
  #teardown() {
    const filterIdPromise = this.#filterIdPromise;
    if (filterIdPromise) {
      this.#filterIdPromise = null;
      filterIdPromise.then((filterId) => {
        if (this.#provider.destroyed) {
          return;
        }
        this.#provider.send("eth_uninstallFilter", [filterId]);
      });
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#hault = true;
    this.#teardown();
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#teardown();
    }
    this.#provider.off("block", this.#poller);
  }
  resume() {
    this.start();
  }
}
class FilterIdEventSubscriber extends FilterIdSubscriber {
  #event;
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider, filter) {
    super(provider);
    this.#event = copy(filter);
  }
  _recover(provider) {
    return new PollingEventSubscriber(provider, this.#event);
  }
  async _subscribe(provider) {
    const filterId = await provider.send("eth_newFilter", [this.#event]);
    return filterId;
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit(this.#event, provider._wrapLog(result, provider._network));
    }
  }
}
class FilterIdPendingSubscriber extends FilterIdSubscriber {
  async _subscribe(provider) {
    return await provider.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit("pending", result);
    }
  }
}
const Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall$2(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
const defaultOptions = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class JsonRpcSigner extends AbstractSigner {
  address;
  constructor(provider, address) {
    super(provider);
    address = getAddress(address);
    defineProperties(this, { address });
  }
  connect(provider) {
    assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises = [];
    if (tx.from) {
      const _from = tx.from;
      promises.push((async () => {
        const from = await resolveAddress(_from, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to = tx.to;
      promises.push((async () => {
        tx.to = await resolveAddress(_to, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash2 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash2);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error) {
          if (isError(error, "CANCELLED") || isError(error, "BAD_DATA") || isError(error, "NETWORK_ERROR") || isError(error, "UNSUPPORTED_OPERATION")) {
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash2;
            reject(error);
            return;
          }
          if (isError(error, "INVALID_ARGUMENT")) {
            invalids++;
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash2;
            if (invalids > 10) {
              reject(error);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from = await resolveAddress(tx.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain, types, _value) {
    const value = deepCopy(_value);
    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value2) => {
      const address = await resolveAddress(value2);
      assertArgument(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
}
class JsonRpcApiProvider extends AbstractProvider {
  #options;
  // The next ID to use for the JSON-RPC ID field
  #nextId;
  // Payloads are queued and triggered in batches using the drainTimer
  #payloads;
  #drainTimer;
  #notReady;
  #network;
  #pendingDetectNetwork;
  #scheduleDrain() {
    if (this.#drainTimer) {
      return;
    }
    const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    this.#drainTimer = setTimeout(() => {
      this.#drainTimer = null;
      const payloads = this.#payloads;
      this.#payloads = [];
      while (payloads.length) {
        const batch = [payloads.shift()];
        while (payloads.length) {
          if (batch.length === this.#options.batchMaxCount) {
            break;
          }
          batch.push(payloads.shift());
          const bytes2 = JSON.stringify(batch.map((p) => p.payload));
          if (bytes2.length > this.#options.batchMaxSize) {
            payloads.unshift(batch.pop());
            break;
          }
        }
        (async () => {
          const payload = batch.length === 1 ? batch[0].payload : batch.map((p) => p.payload);
          this.emit("debug", { action: "sendRpcPayload", payload });
          try {
            const result = await this._send(payload);
            this.emit("debug", { action: "receiveRpcResult", result });
            for (const { resolve, reject, payload: payload2 } of batch) {
              if (this.destroyed) {
                reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                continue;
              }
              const resp = result.filter((r) => r.id === payload2.id)[0];
              if (resp == null) {
                const error = makeError("missing response for request", "BAD_DATA", {
                  value: result,
                  info: { payload: payload2 }
                });
                this.emit("error", error);
                reject(error);
                continue;
              }
              if ("error" in resp) {
                reject(this.getRpcError(payload2, resp));
                continue;
              }
              resolve(resp.result);
            }
          } catch (error) {
            this.emit("debug", { action: "receiveRpcError", error });
            for (const { reject } of batch) {
              reject(error);
            }
          }
        })();
      }
    }, stallTime);
  }
  constructor(network, options) {
    super(network, options);
    this.#nextId = 1;
    this.#options = Object.assign({}, defaultOptions, options || {});
    this.#payloads = [];
    this.#drainTimer = null;
    this.#network = null;
    this.#pendingDetectNetwork = null;
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      this.#notReady = { promise, resolve };
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        this.#network = Network.from(network);
      }
    } else if (staticNetwork) {
      assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      this.#network = staticNetwork;
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key) {
    return this.#options[key];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert(this.#network, "network is not available yet", "NETWORK_ERROR");
    return this.#network;
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (this.#network) {
          return this.#network;
        }
      } else {
        return network;
      }
    }
    if (this.#pendingDetectNetwork) {
      return await this.#pendingDetectNetwork;
    }
    if (this.ready) {
      this.#pendingDetectNetwork = (async () => {
        try {
          const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
          this.#pendingDetectNetwork = null;
          return result;
        } catch (error) {
          this.#pendingDetectNetwork = null;
          throw error;
        }
      })();
      return await this.#pendingDetectNetwork;
    }
    this.#pendingDetectNetwork = (async () => {
      const payload = {
        id: this.#nextId++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        this.#pendingDetectNetwork = null;
      } catch (error) {
        this.#pendingDetectNetwork = null;
        this.emit("debug", { action: "receiveRpcError", error });
        throw error;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network.from(getBigInt(result.result));
      }
      throw this.getRpcError(payload, result);
    })();
    return await this.#pendingDetectNetwork;
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (this.#notReady == null || this.#notReady.resolve == null) {
      return;
    }
    this.#notReady.resolve();
    this.#notReady = null;
    (async () => {
      while (this.#network == null && !this.destroyed) {
        try {
          this.#network = await this._detectNetwork();
        } catch (error) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
          await stall$2(1e3);
        }
      }
      this.#scheduleDrain();
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (this.#notReady == null) {
      return;
    }
    return await this.#notReady.promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub.filter);
      }
      return new FilterIdEventSubscriber(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return this.#notReady == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result[key] = hexlify(tx[key]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h) => h.toLowerCase());
    }
    if (tx.authorizationList) {
      result["authorizationList"] = tx.authorizationList.map((_a) => {
        const a = authorizationify(_a);
        return {
          address: a.address,
          nonce: toQuantity(a.nonce),
          chainId: toQuantity(a.chainId),
          yParity: toQuantity(a.signature.yParity),
          r: toQuantity(a.signature.r),
          s: toQuantity(a.signature.s)
        };
      });
    }
    return result;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error) {
    const { method } = payload;
    const { error } = _error;
    if (method === "eth_estimateGas" && error.message) {
      const msg = error.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      } else if (msg.match(/nonce/i) && msg.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error);
      const e = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e.info = { error, payload };
      return e;
    }
    const message = JSON.stringify(spelunkMessage(error));
    if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error && error.details && error.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id2 = this.#nextId++;
    const promise = new Promise((resolve, reject) => {
      this.#payloads.push({
        resolve,
        reject,
        payload: { method, params, id: id2, jsonrpc: "2.0" }
      });
    });
    this.#scheduleDrain();
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress(address);
    for (const account of accounts) {
      if (getAddress(account) === address) {
        return new JsonRpcSigner(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a) => new JsonRpcSigner(this, a));
  }
  destroy() {
    if (this.#drainTimer) {
      clearTimeout(this.#drainTimer);
      this.#drainTimer = null;
    }
    for (const { payload, reject } of this.#payloads) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    this.#payloads = [];
    super.destroy();
  }
}
class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
  #pollingInterval;
  constructor(network, options) {
    super(network, options);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions.pollingInterval;
    }
    this.#pollingInterval = pollingInterval;
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = this.#pollingInterval;
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return this.#pollingInterval;
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    this.#pollingInterval = value;
    this._forEachSubscriber((sub) => {
      if (isPollable(sub)) {
        sub.pollingInterval = this.#pollingInterval;
      }
    });
  }
}
class JsonRpcProvider extends JsonRpcApiPollingProvider {
  #connect;
  constructor(url, network, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network, options);
    if (typeof url === "string") {
      this.#connect = new FetchRequest(url);
    } else {
      this.#connect = url.clone();
    }
  }
  _getConnection() {
    return this.#connect.clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
}
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunkData(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {
    }
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage(value[key], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {
    }
  }
}
function spelunkMessage(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
}
class BaseWallet extends AbstractSigner {
  /**
   *  The wallet address.
   */
  address;
  #signingKey;
  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  constructor(privateKey, provider) {
    super(provider);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    this.#signingKey = privateKey;
    const address = computeAddress(this.signingKey.publicKey);
    defineProperties(this, { address });
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  get signingKey() {
    return this.#signingKey;
  }
  /**
   *  The private key for this wallet.
   */
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new BaseWallet(this.#signingKey, provider);
  }
  async signTransaction(tx) {
    tx = copyRequest(tx);
    const { to, from } = await resolveProperties({
      to: tx.to ? resolveAddress(tx.to, this) : void 0,
      from: tx.from ? resolveAddress(tx.from, this) : void 0
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  // @TODO: Add a secialized signTx and signTyped sync that enforces
  // all parameters are known?
  /**
   *  Returns the signature for %%message%% signed with this wallet.
   */
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage(message)).serialized;
  }
  /**
   *  Returns the Authorization for %%auth%%.
   */
  authorizeSync(auth) {
    assertArgument(typeof auth.address === "string", "invalid address for authorizeSync", "auth.address", auth);
    const signature = this.signingKey.sign(hashAuthorization(auth));
    return Object.assign({}, {
      address: getAddress(auth.address),
      nonce: getBigInt(auth.nonce || 0),
      chainId: getBigInt(auth.chainId || 0)
    }, { signature });
  }
  /**
   *  Resolves to the Authorization for %%auth%%.
   */
  async authorize(auth) {
    auth = Object.assign({}, auth, {
      address: await resolveAddress(auth.address, this)
    });
    return this.authorizeSync(await this.populateAuthorization(auth));
  }
  async signTypedData(domain, types, value) {
    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name) => {
      assert(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name }
      });
      const address = await this.provider.resolveName(name);
      assert(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name
      });
      return address;
    });
    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;
  }
}
const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
const Word = /^[a-z]*$/i;
function unfold(words2, sep) {
  let initial = 97;
  return words2.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode(data, subs) {
  for (let i = subsChrs.length - 1; i >= 0; i--) {
    data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  const clumps = [];
  const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
    if (semi) {
      for (let i = parseInt(semi); i >= 0; i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data) {
  assertArgument(data[0] === "0", "unsupported auwl data", "data", data);
  return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}
class Wordlist {
  locale;
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  constructor(locale) {
    defineProperties(this, { locale });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  /**
   *  Sub-classes may override this to provider a language-specific
   *  method for joining %%words%% into a phrase.
   *
   *  By default, %%words%% are joined by a single space.
   */
  join(words2) {
    return words2.join(" ");
  }
}
class WordlistOwl extends Wordlist {
  #data;
  #checksum;
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  constructor(locale, data, checksum2) {
    super(locale);
    this.#data = data;
    this.#checksum = checksum2;
    this.#words = null;
  }
  /**
   *  The OWL-encoded data.
   */
  get _data() {
    return this.#data;
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwl(this.#data);
  }
  #words;
  #loadWords() {
    if (this.#words == null) {
      const words2 = this._decodeWords();
      const checksum2 = id(words2.join("\n") + "\n");
      if (checksum2 !== this.#checksum) {
        throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
      }
      this.#words = words2;
    }
    return this.#words;
  }
  getWord(index) {
    const words2 = this.#loadWords();
    assertArgument(index >= 0 && index < words2.length, `invalid word index: ${index}`, "index", index);
    return words2[index];
  }
  getWordIndex(word) {
    return this.#loadWords().indexOf(word);
  }
}
const words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
const checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
let wordlist = null;
class LangEn extends WordlistOwl {
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("en", words, checksum);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist == null) {
      wordlist = new LangEn();
    }
    return wordlist;
  }
}
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits & 255;
}
function getLowerMask(bits) {
  return (1 << bits) - 1 & 255;
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  assertNormalize("NFKD");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const words2 = wordlist2.split(mnemonic);
  assertArgument(words2.length % 3 === 0 && words2.length >= 12 && words2.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words2.length / 8));
  let offset = 0;
  for (let i = 0; i < words2.length; i++) {
    let index = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
const _guard$1 = {};
class Mnemonic {
  /**
   *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
   *
   *  Use the [[wordlist]] ``split`` method to get the individual words.
   */
  phrase;
  /**
   *  The password used for this mnemonic. If no password is used this
   *  is the empty string (i.e. ``""``) as per the specification.
   */
  password;
  /**
   *  The wordlist for this mnemonic.
   */
  wordlist;
  /**
   *  The underlying entropy which the mnemonic encodes.
   */
  entropy;
  /**
   *  @private
   */
  constructor(guard, entropy, phrase, password, wordlist2) {
    if (password == null) {
      password = "";
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    assertPrivate(guard, _guard$1, "Mnemonic");
    defineProperties(this, { phrase, password, wordlist: wordlist2, entropy });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf2(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  /**
   *  Creates a new Mnemonic for the %%phrase%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromPhrase(phrase, password, wordlist2) {
    const entropy = mnemonicToEntropy(phrase, wordlist2);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist2);
    return new Mnemonic(_guard$1, entropy, phrase, password, wordlist2);
  }
  /**
   *  Create a new **Mnemonic** from the %%entropy%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromEntropy(_entropy, password, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist2);
    return new Mnemonic(_guard$1, hexlify(entropy), phrase, password, wordlist2);
  }
  /**
   *  Returns the phrase for %%mnemonic%%.
   */
  static entropyToPhrase(_entropy, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist2);
  }
  /**
   *  Returns the entropy for %%phrase%%.
   */
  static phraseToEntropy(phrase, wordlist2) {
    return mnemonicToEntropy(phrase, wordlist2);
  }
  /**
   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
   *
   *  This checks all the provided words belong to the %%wordlist%%,
   *  that the length is valid and the checksum is correct.
   */
  static isValidMnemonic(phrase, wordlist2) {
    try {
      mnemonicToEntropy(phrase, wordlist2);
      return true;
    } catch (error) {
    }
    return false;
  }
}
var __classPrivateFieldGet$2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet$2 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AES_key, _AES_Kd, _AES_Ke;
const numberOfRounds = { 16: 10, 24: 12, 32: 14 };
const rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
const S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
const Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
const T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
const T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
const T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
const T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
const T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
const T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
const T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
const T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
const U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
const U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
const U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
const U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function convertToInt32(bytes2) {
  const result = [];
  for (let i = 0; i < bytes2.length; i += 4) {
    result.push(bytes2[i] << 24 | bytes2[i + 1] << 16 | bytes2[i + 2] << 8 | bytes2[i + 3]);
  }
  return result;
}
class AES {
  get key() {
    return __classPrivateFieldGet$2(this, _AES_key, "f").slice();
  }
  constructor(key) {
    _AES_key.set(this, void 0);
    _AES_Kd.set(this, void 0);
    _AES_Ke.set(this, void 0);
    if (!(this instanceof AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet$2(this, _AES_key, new Uint8Array(key), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet$2(this, _AES_Ke, [], "f");
    __classPrivateFieldSet$2(this, _AES_Kd, [], "f");
    for (let i = 0; i <= rounds; i++) {
      __classPrivateFieldGet$2(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet$2(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk = convertToInt32(this.key);
    let index;
    for (let i = 0; i < KC; i++) {
      index = i >> 2;
      __classPrivateFieldGet$2(this, _AES_Ke, "f")[index][i % 4] = tk[i];
      __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
    }
    let rconpointer = 0;
    let t = KC, tt;
    while (t < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i2 = 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      } else {
        for (let i2 = 1; i2 < KC / 2; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i2 = KC / 2 + 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      }
      let i = 0, r, c;
      while (i < KC && t < roundKeyCount) {
        r = t >> 2;
        c = t % 4;
        __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][c] = tk[i];
        __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - r][c] = tk[i++];
        t++;
      }
    }
    for (let r = 1; r < rounds; r++) {
      for (let c = 0; c < 4; c++) {
        tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c];
        __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$2(this, _AES_Ke, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(plaintext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet$2(this, _AES_Ke, "f")[0][i];
    }
    for (let r = 1; r < rounds; r++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T1[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$2(this, _AES_Ke, "f")[rounds][i];
      result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$2(this, _AES_Kd, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(ciphertext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet$2(this, _AES_Kd, "f")[0][i];
    }
    for (let r = 1; r < rounds; r++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds][i];
      result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
}
_AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();
class ModeOfOperation {
  constructor(name, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key) },
      name: { enumerable: true, value: name }
    });
  }
}
var __classPrivateFieldSet$1 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$1 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CBC_iv, _CBC_lastBlock;
class CBC extends ModeOfOperation {
  constructor(key, iv) {
    super("ECC", key, CBC);
    _CBC_iv.set(this, void 0);
    _CBC_lastBlock.set(this, void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet$1(this, _CBC_lastBlock, this.iv, "f");
  }
  get iv() {
    return new Uint8Array(__classPrivateFieldGet$1(this, _CBC_iv, "f"));
  }
  encrypt(plaintext) {
    if (plaintext.length % 16) {
      throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
    }
    const ciphertext = new Uint8Array(plaintext.length);
    for (let i = 0; i < plaintext.length; i += 16) {
      for (let j = 0; j < 16; j++) {
        __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
      }
      __classPrivateFieldSet$1(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet$1(this, _CBC_lastBlock, "f")), "f");
      ciphertext.set(__classPrivateFieldGet$1(this, _CBC_lastBlock, "f"), i);
    }
    return ciphertext;
  }
  decrypt(ciphertext) {
    if (ciphertext.length % 16) {
      throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
    }
    const plaintext = new Uint8Array(ciphertext.length);
    for (let i = 0; i < ciphertext.length; i += 16) {
      const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
      for (let j = 0; j < 16; j++) {
        plaintext[i + j] = block[j] ^ __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j];
        __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
      }
    }
    return plaintext;
  }
}
_CBC_iv = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
class CTR extends ModeOfOperation {
  constructor(key, initialValue) {
    super("CTR", key, CTR);
    _CTR_remaining.set(this, void 0);
    _CTR_remainingIndex.set(this, void 0);
    _CTR_counter.set(this, void 0);
    __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index = 15; index >= 0; --index) {
      __classPrivateFieldGet(this, _CTR_counter, "f")[index] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
  }
  increment() {
    for (let i = 15; i >= 0; i--) {
      if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
      } else {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a, _b;
    const crypttext = new Uint8Array(plaintext);
    for (let i = 0; i < crypttext.length; i++) {
      if (__classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, "f"), _a = _b++, _b), "f"), _a];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
}
_CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();
function pkcs7Strip(data) {
  if (data.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data[data.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data.length - padder;
  for (let i = 0; i < padder; i++) {
    if (data[length + i] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data.subarray(0, length));
}
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad$1(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk(object2, _path) {
  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match != null, "invalid path", "path", _path);
  const path = match[1];
  const type = match[3];
  const reqd = match[4] === "!";
  let cur = object2;
  for (const comp of path.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key in cur) {
        if (key.toLowerCase() === comp) {
          found = cur[key];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === typeof cur) {
      return cur;
    }
    assertArgument(false, `wrong type found for ${type} `, "path", path);
  }
  return cur;
}
const defaultPath$1 = "m/44'/60'/0'/0/0";
function isKeystoreJson(json) {
  try {
    const data = JSON.parse(json);
    const version2 = data.version != null ? parseInt(data.version) : 0;
    if (version2 === 3) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decrypt(data, key, ciphertext) {
  const cipher = spelunk(data, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk(data, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR(key, iv);
    return hexlify(aesCtr.decrypt(ciphertext));
  }
  assert(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount(data, _key) {
  const key = getBytes(_key);
  const ciphertext = spelunk(data, "crypto.ciphertext:data!");
  const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    assertArgument(getAddress(check) === address, "keystore address/privateKey mismatch", "address", data.address);
  }
  const account = { address, privateKey };
  const version2 = spelunk(data, "x-ethers.version:string");
  if (version2 === "0.1") {
    const mnemonicKey = key.slice(32, 64);
    const mnemonicCiphertext = spelunk(data, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk(data, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: spelunk(data, "x-ethers.path:string") || defaultPath$1,
      locale: spelunk(data, "x-ethers.locale:string") || "en",
      entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams(data) {
  const kdf = spelunk(data, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const N2 = spelunk(data, "crypto.kdfparams.n:int!");
      const r = spelunk(data, "crypto.kdfparams.r:int!");
      const p = spelunk(data, "crypto.kdfparams.p:int!");
      assertArgument(N2 > 0 && (N2 & N2 - 1) === 0, "invalid kdf.N", "kdf.N", N2);
      assertArgument(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N2, r, p, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const prf = spelunk(data, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count = spelunk(data, "crypto.kdfparams.c:int!");
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count, dkLen, algorithm };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
}
function decryptKeystoreJsonSync(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count, dkLen2, algorithm);
    return getAccount(data, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r, p, dkLen } = params;
  const key = scryptSync(password, salt, N2, r, p, dkLen);
  return getAccount(data, key);
}
function stall$1(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
async function decryptKeystoreJson(json, _password, progress) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    if (progress) {
      progress(0);
      await stall$1(0);
    }
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count, dkLen2, algorithm);
    if (progress) {
      progress(1);
      await stall$1(0);
    }
    return getAccount(data, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r, p, dkLen } = params;
  const key = await scrypt(password, salt, N2, r, p, dkLen, progress);
  return getAccount(data, key);
}
function getEncryptKdfParams(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes(32);
  let N2 = 1 << 17, r = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  assertArgument(typeof N2 === "number" && N2 > 0 && Number.isSafeInteger(N2) && (BigInt(N2) & BigInt(N2 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N2);
  assertArgument(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
  assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return { name: "scrypt", dkLen: 32, salt, N: N2, r, p };
}
function _encryptKeystore(key, kdf, account, options) {
  const privateKey = getBytes(account.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak256(concat([macPrefix, ciphertext]));
  const data = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client = options.client != null ? options.client : `ethers/${version}`;
    const path = account.mnemonic.path || defaultPath$1;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = /* @__PURE__ */ new Date();
    const timestamp = now.getUTCFullYear() + "-" + zpad$1(now.getUTCMonth() + 1, 2) + "-" + zpad$1(now.getUTCDate(), 2) + "T" + zpad$1(now.getUTCHours(), 2) + "-" + zpad$1(now.getUTCMinutes(), 2) + "-" + zpad$1(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data.address;
    data["x-ethers"] = {
      client,
      gethFilename,
      path,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data);
}
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
async function encryptKeystoreJson(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = await scrypt(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
const defaultPath = "m/44'/60'/0'/0/0";
const MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
const HardenedBit = 2147483648;
const N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const Nibbles = "0123456789abcdef";
function zpad(value, length) {
  let result = "";
  while (value) {
    result = Nibbles[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value) {
  const value = getBytes(_value);
  const check = dataSlice(sha256(sha256(value)), 0, 4);
  const bytes2 = concat([value, check]);
  return encodeBase58(bytes2);
}
const _guard = {};
function ser_I(index, chainCode, publicKey, privateKey) {
  const data = new Uint8Array(37);
  if (index & HardenedBit) {
    assert(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data.set(getBytes(privateKey), 1);
  } else {
    data.set(getBytes(publicKey));
  }
  for (let i = 24; i >= 0; i -= 8) {
    data[33 + (i >> 3)] = index >> 24 - i & 255;
  }
  const I = getBytes(computeHmac("sha512", chainCode, data));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath(node, path) {
  const components = path.split("/");
  assertArgument(components.length > 0, "invalid path", "path", path);
  if (components[0] === "m") {
    assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path);
    components.shift();
  }
  let result = node;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      const index = parseInt(component.substring(0, component.length - 1));
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(HardenedBit + index);
    } else if (component.match(/^[0-9]+$/)) {
      const index = parseInt(component);
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(index);
    } else {
      assertArgument(false, "invalid path component", `path[${i}]`, component);
    }
  }
  return result;
}
class HDNodeWallet extends BaseWallet {
  /**
   *  The compressed public key.
   */
  publicKey;
  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */
  fingerprint;
  /**
   *  The parent fingerprint.
   */
  parentFingerprint;
  /**
   *  The mnemonic used to create this HD Node, if available.
   *
   *  Sources such as extended keys do not encode the mnemonic, in
   *  which case this will be ``null``.
   */
  mnemonic;
  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */
  chainCode;
  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provide full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  encode it.
   */
  path;
  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */
  index;
  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */
  depth;
  /**
   *  @private
   */
  constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
    super(signingKey, provider);
    assertPrivate(guard, _guard, "HDNodeWallet");
    defineProperties(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd160(sha256(this.publicKey)), 0, 4);
    defineProperties(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path,
      index,
      depth
    });
    defineProperties(this, { mnemonic });
  }
  connect(provider) {
    return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
  }
  #account() {
    const account = { address: this.address, privateKey: this.privateKey };
    const m = this.mnemonic;
    if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
      account.mnemonic = {
        path: this.path,
        locale: "en",
        entropy: m.entropy
      };
    }
    return account;
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(this.#account(), password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    return encryptKeystoreJsonSync(this.#account(), password);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpriv`` and can be used to
   *  reconstruct this HD Node to derive its children.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488ADE4",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      concat(["0x00", this.privateKey])
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Returns a neutered HD Node, which removes the private details
   *  of an HD Node.
   *
   *  A neutered node has no private key, but can be used to derive
   *  child addresses and other public data about the HD Node.
   */
  neuter() {
    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
    const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));
    return new HDNodeWallet(_guard, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
  }
  /**
   *  Return the HDNode for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
  static #fromSeed(_seed, mnemonic) {
    assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
    const seed = getBytes(_seed, "seed");
    assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
    const I = getBytes(computeHmac("sha512", MasterSecret, seed));
    const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
    return new HDNodeWallet(_guard, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic, null);
  }
  /**
   *  Creates a new HD Node from %%extendedKey%%.
   *
   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
   *  or full HD Node ([[HDNodeWallet) respectively.
   */
  static fromExtendedKey(extendedKey) {
    const bytes2 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes2.length === 82 || encodeBase58Check(bytes2.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes2[4];
    const parentFingerprint = hexlify(bytes2.slice(5, 9));
    const index = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes2.slice(13, 45));
    const key = bytes2.slice(45, 78);
    switch (hexlify(bytes2.slice(0, 4))) {
      // Public Key
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify(key);
        return new HDNodeVoidWallet(_guard, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
      }
      // Private Key
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new HDNodeWallet(_guard, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  /**
   *  Creates a new random HDNode.
   */
  static createRandom(password, path, wordlist2) {
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist2);
    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Create an HD Node from %%mnemonic%%.
   */
  static fromMnemonic(mnemonic, path) {
    if (!path) {
      path = defaultPath;
    }
    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a mnemonic %%phrase%%.
   */
  static fromPhrase(phrase, password, path, wordlist2) {
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist2);
    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a %%seed%%.
   */
  static fromSeed(seed) {
    return HDNodeWallet.#fromSeed(seed, null);
  }
}
class HDNodeVoidWallet extends VoidSigner {
  /**
   *  The compressed public key.
   */
  publicKey;
  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */
  fingerprint;
  /**
   *  The parent node fingerprint.
   */
  parentFingerprint;
  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */
  chainCode;
  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provider full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  enocde it.
   */
  path;
  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */
  index;
  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */
  depth;
  /**
   *  @private
   */
  constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
    super(address, provider);
    assertPrivate(guard, _guard, "HDNodeVoidWallet");
    defineProperties(this, { publicKey });
    const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);
    defineProperties(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path,
      index,
      depth
    });
  }
  connect(provider) {
    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpub`` and can be used to
   *  reconstruct this neutered key to derive its children addresses.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488B21E",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
    const Ki = SigningKey.addPoints(IL, this.publicKey, true);
    const address = computeAddress(Ki);
    return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);
  }
  /**
   *  Return the signer for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
}
function getAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/${index}'/0/0`;
}
function getIndexedAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/0'/0/${index}`;
}
function isCrowdsaleJson(json) {
  try {
    const data = JSON.parse(json);
    if (data.encseed) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decryptCrowdsaleJson(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const address = getAddress(spelunk(data, "ethaddr:string!"));
  const encseed = looseArrayify(spelunk(data, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  const key = getBytes(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC(key, iv);
  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  return { address, privateKey: id(seedHex) };
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
class Wallet extends BaseWallet {
  /**
   *  Create a new wallet for the private %%key%%, optionally connected
   *  to %%provider%%.
   */
  constructor(key, provider) {
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    let signingKey = typeof key === "string" ? new SigningKey(key) : key;
    super(signingKey, provider);
  }
  connect(provider) {
    return new Wallet(this.signingKey, provider);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    const account = { address: this.address, privateKey: this.privateKey };
    return await encryptKeystoreJson(account, password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    const account = { address: this.address, privateKey: this.privateKey };
    return encryptKeystoreJsonSync(account, password);
  }
  static #fromAccount(account) {
    assertArgument(account, "invalid JSON wallet", "json", "[ REDACTED ]");
    if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
      const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
      const wallet2 = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
      if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
        return wallet2;
      }
      console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
    }
    const wallet = new Wallet(account.privateKey);
    assertArgument(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
    return wallet;
  }
  /**
   *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
   *  with %%password%%.
   *
   *  If %%progress%% is provided, it is called periodically during
   *  decryption so that any UI can be updated.
   */
  static async fromEncryptedJson(json, password, progress) {
    let account = null;
    if (isKeystoreJson(json)) {
      account = await decryptKeystoreJson(json, password, progress);
    } else if (isCrowdsaleJson(json)) {
      if (progress) {
        progress(0);
        await stall(0);
      }
      account = decryptCrowdsaleJson(json, password);
      if (progress) {
        progress(1);
        await stall(0);
      }
    }
    return Wallet.#fromAccount(account);
  }
  /**
   *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
   *
   *  The [[fromEncryptedJson]] method is preferred, as this method
   *  will lock up and freeze the UI during decryption, which may take
   *  some time.
   */
  static fromEncryptedJsonSync(json, password) {
    let account = null;
    if (isKeystoreJson(json)) {
      account = decryptKeystoreJsonSync(json, password);
    } else if (isCrowdsaleJson(json)) {
      account = decryptCrowdsaleJson(json, password);
    } else {
      assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
    }
    return Wallet.#fromAccount(account);
  }
  /**
   *  Creates a new random [[HDNodeWallet]] using the available
   *  [cryptographic random source](randomBytes).
   *
   *  If there is no crytographic random source, this will throw.
   */
  static createRandom(provider) {
    const wallet = HDNodeWallet.createRandom();
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
  /**
   *  Creates a [[HDNodeWallet]] for %%phrase%%.
   */
  static fromPhrase(phrase, provider) {
    const wallet = HDNodeWallet.fromPhrase(phrase);
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
}
async function save(key, data) {
  try {
    await chrome.storage.local.set({ [key]: data });
  } catch (error) {
    console.error("Error saving data:", error);
    throw new Error("Failed to save data");
  }
}
async function load(key) {
  try {
    const result = await chrome.storage.local.get(key);
    return result[key] || null;
  } catch (error) {
    console.error("Error loading data:", error);
    throw new Error("Failed to load data");
  }
}
function isValidAddress(address) {
  try {
    return isAddress(address);
  } catch {
    return false;
  }
}
function isValidMnemonic(mnemonic) {
  try {
    const cleaned = mnemonic.trim().replace(/\s+/g, " ");
    return Mnemonic.isValidMnemonic(cleaned);
  } catch {
    return false;
  }
}
function isValidPrivateKey(privateKey) {
  try {
    const key = privateKey.startsWith("0x") ? privateKey : "0x" + privateKey;
    if (!/^0x[0-9a-fA-F]{64}$/.test(key)) {
      return false;
    }
    new Wallet(key);
    return true;
  } catch {
    return false;
  }
}
function validatePasswordStrength(password) {
  const errors = [];
  if (!password || password.length < 12) {
    errors.push("Password must be at least 12 characters");
  }
  if (!/[A-Z]/.test(password)) {
    errors.push("Password must contain at least one uppercase letter");
  }
  if (!/[a-z]/.test(password)) {
    errors.push("Password must contain at least one lowercase letter");
  }
  if (!/[0-9]/.test(password)) {
    errors.push("Password must contain at least one number");
  }
  if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
    errors.push("Password must contain at least one special character (!@#$%^&*, etc.)");
  }
  return {
    valid: errors.length === 0,
    errors
  };
}
function shortenAddress(address, chars = 4) {
  if (!isValidAddress(address)) return address;
  return `${address.slice(0, chars + 2)}...${address.slice(-chars)}`;
}
const ITERATION_MILESTONES = [
  // Historical OWASP recommendations (actual data)
  { year: 2016, iterations: 1e4, source: "OWASP 2016" },
  { year: 2021, iterations: 31e4, source: "OWASP 2021" },
  { year: 2023, iterations: 6e5, source: "OWASP 2023" },
  // Projected using 35% CAGR from 2023 baseline
  { year: 2024, iterations: 81e4, source: "Projected (35% CAGR)" },
  { year: 2025, iterations: 1094e3, source: "Projected (35% CAGR)" },
  { year: 2026, iterations: 1477e3, source: "Projected (35% CAGR)" },
  { year: 2027, iterations: 1994e3, source: "Projected (35% CAGR)" },
  { year: 2028, iterations: 2692e3, source: "Projected (35% CAGR)" },
  { year: 2029, iterations: 3635e3, source: "Projected (35% CAGR)" },
  { year: 2030, iterations: 4907e3, source: "Projected (35% CAGR)" },
  { year: 2031, iterations: 5e6, source: "Capped for UX (~2sec on slow devices)" }
];
function getCurrentRecommendedIterations(year = (/* @__PURE__ */ new Date()).getFullYear()) {
  const safeYear = Math.max(year, BUILD_YEAR);
  const exactMatch = ITERATION_MILESTONES.find((m) => m.year === safeYear);
  if (exactMatch) {
    return Math.max(exactMatch.iterations, MINIMUM_ITERATIONS);
  }
  const before = ITERATION_MILESTONES.filter((m) => m.year < safeYear).sort((a, b2) => b2.year - a.year)[0];
  const after = ITERATION_MILESTONES.filter((m) => m.year > safeYear).sort((a, b2) => a.year - b2.year)[0];
  if (!before) {
    return Math.max(ITERATION_MILESTONES[0].iterations, MINIMUM_ITERATIONS);
  }
  if (!after) {
    return Math.max(ITERATION_MILESTONES[ITERATION_MILESTONES.length - 1].iterations, MINIMUM_ITERATIONS);
  }
  const yearRange = after.year - before.year;
  const iterationRatio = after.iterations / before.iterations;
  const yearProgress = (safeYear - before.year) / yearRange;
  const calculated = Math.floor(before.iterations * Math.pow(iterationRatio, yearProgress));
  return Math.max(calculated, MINIMUM_ITERATIONS);
}
const LEGACY_ITERATIONS = 1e5;
const BUILD_YEAR = 2025;
const MINIMUM_ITERATIONS = 1094e3;
async function deriveEncryptionKey(password, salt, iterations) {
  const encoder = new TextEncoder();
  const passwordBuffer = encoder.encode(password);
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    passwordBuffer,
    { name: "PBKDF2" },
    false,
    ["deriveBits", "deriveKey"]
  );
  return await crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt,
      iterations,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}
async function encryptWithAES(data, password, iterations = getCurrentRecommendedIterations()) {
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(data);
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveEncryptionKey(password, salt, iterations);
  const encryptedBuffer = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    dataBuffer
  );
  const iterationBytes = new Uint8Array(4);
  new DataView(iterationBytes.buffer).setUint32(0, iterations, false);
  const combined = new Uint8Array(
    4 + salt.length + iv.length + encryptedBuffer.byteLength
  );
  combined.set(iterationBytes, 0);
  combined.set(salt, 4);
  combined.set(iv, 4 + salt.length);
  combined.set(new Uint8Array(encryptedBuffer), 4 + salt.length + iv.length);
  return btoa(String.fromCharCode(...combined));
}
async function decryptWithAES(encryptedData, password) {
  try {
    const combined = Uint8Array.from(atob(encryptedData), (c) => c.charCodeAt(0));
    let iterationCount;
    let salt, iv, encrypted;
    if (combined.length >= 4) {
      const possibleIterations = new DataView(combined.buffer, 0, 4).getUint32(0, false);
      if (possibleIterations >= 1e5 && possibleIterations <= 5e6) {
        iterationCount = possibleIterations;
        salt = combined.slice(4, 20);
        iv = combined.slice(20, 32);
        encrypted = combined.slice(32);
      } else {
        iterationCount = LEGACY_ITERATIONS;
        salt = combined.slice(0, 16);
        iv = combined.slice(16, 28);
        encrypted = combined.slice(28);
      }
    } else {
      throw new Error("Invalid encrypted data format");
    }
    const key = await deriveEncryptionKey(password, salt, iterationCount);
    const decryptedBuffer = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
    );
    const decoder = new TextDecoder();
    return decoder.decode(decryptedBuffer);
  } catch (error) {
    if (error.message === "Invalid encrypted data format") {
      throw error;
    }
    throw new Error("Decryption failed - incorrect password or corrupted data");
  }
}
function getIterationsFromEncrypted(encryptedData) {
  try {
    const combined = Uint8Array.from(atob(encryptedData), (c) => c.charCodeAt(0));
    if (combined.length >= 4) {
      const possibleIterations = new DataView(combined.buffer, 0, 4).getUint32(0, false);
      if (possibleIterations >= 1e5 && possibleIterations <= 5e6) {
        return possibleIterations;
      }
    }
    return LEGACY_ITERATIONS;
  } catch (error) {
    return LEGACY_ITERATIONS;
  }
}
const OLD_WALLET_KEY = "wallet_encrypted";
const WALLETS_KEY = "wallets_multi";
const ongoingUpgrades = /* @__PURE__ */ new Map();
async function migrateToMultiWallet() {
  try {
    const walletsData = await load(WALLETS_KEY);
    if (walletsData) {
      return false;
    }
    const oldWallet = await load(OLD_WALLET_KEY);
    if (!oldWallet) {
      return false;
    }
    const newFormat = {
      activeWalletId: "wallet_migrated_" + Date.now(),
      walletList: [{
        id: "wallet_migrated_" + Date.now(),
        nickname: "Main Wallet",
        address: null,
        // Will be populated on unlock
        encryptedKeystore: oldWallet,
        createdAt: Date.now(),
        importMethod: "migrated"
      }]
    };
    await save(WALLETS_KEY, newFormat);
    return true;
  } catch (error) {
    console.error("Error during migration:", error);
    return false;
  }
}
async function getAllWallets() {
  const walletsData = await load(WALLETS_KEY);
  if (!walletsData) {
    return {
      activeWalletId: null,
      walletList: []
    };
  }
  return walletsData;
}
async function getActiveWallet() {
  const walletsData = await getAllWallets();
  if (!walletsData.activeWalletId || walletsData.walletList.length === 0) {
    return null;
  }
  const activeWallet = walletsData.walletList.find(
    (w) => w.id === walletsData.activeWalletId
  );
  return activeWallet || null;
}
async function walletExists() {
  const walletsData = await getAllWallets();
  return walletsData.walletList.length > 0;
}
function generateWalletId() {
  const array = new Uint8Array(8);
  crypto.getRandomValues(array);
  const randomStr = Array.from(array, (byte) => byte.toString(36)).join("");
  return "wallet_" + Date.now() + "_" + randomStr;
}
async function isDuplicateAddress(address) {
  const walletsData = await getAllWallets();
  return walletsData.walletList.some(
    (w) => w.address && w.address.toLowerCase() === address.toLowerCase()
  );
}
async function generateDefaultNickname() {
  const walletsData = await getAllWallets();
  const count = walletsData.walletList.length;
  return "Wallet " + (count + 1);
}
async function addWallet(type, data, password, nickname = null) {
  const passwordCheck = validatePasswordStrength(password);
  if (!passwordCheck.valid) {
    throw new Error(passwordCheck.errors.join(", "));
  }
  let wallet;
  let mnemonic = null;
  try {
    switch (type) {
      case "create":
        wallet = Wallet.createRandom();
        mnemonic = wallet.mnemonic.phrase;
        break;
      case "mnemonic":
        if (!data.mnemonic || !isValidMnemonic(data.mnemonic)) {
          throw new Error("Invalid mnemonic phrase");
        }
        const cleanMnemonic = data.mnemonic.trim().replace(/\s+/g, " ");
        wallet = Wallet.fromPhrase(cleanMnemonic);
        break;
      case "privatekey":
        if (!data.privateKey || !isValidPrivateKey(data.privateKey)) {
          throw new Error("Invalid private key");
        }
        const key = data.privateKey.startsWith("0x") ? data.privateKey : "0x" + data.privateKey;
        wallet = new Wallet(key);
        break;
      default:
        throw new Error("Invalid wallet type: " + type);
    }
    if (await isDuplicateAddress(wallet.address)) {
      throw new Error("This wallet already exists in your wallet list");
    }
    const currentIterations = getCurrentRecommendedIterations();
    const encryptedJson = await wallet.encrypt(password);
    const doubleEncrypted = await encryptWithAES(encryptedJson, password, currentIterations);
    const finalNickname = nickname || await generateDefaultNickname();
    const walletEntry = {
      id: generateWalletId(),
      nickname: finalNickname,
      address: wallet.address,
      encryptedKeystore: doubleEncrypted,
      createdAt: Date.now(),
      importMethod: type,
      lastSecurityUpgrade: Date.now(),
      // Track when encryption was last upgraded
      currentIterations
      // Store for UI display
    };
    const walletsData = await getAllWallets();
    if (walletsData.walletList.length >= 10) {
      throw new Error("Maximum wallet limit (10) reached. Please delete a wallet to add a new one.");
    }
    walletsData.walletList.push(walletEntry);
    if (walletsData.walletList.length === 1) {
      walletsData.activeWalletId = walletEntry.id;
    }
    await save(WALLETS_KEY, walletsData);
    console.log(` Wallet created with ${currentIterations.toLocaleString()} PBKDF2 iterations`);
    return {
      id: walletEntry.id,
      address: wallet.address,
      mnemonic
      // Only set for newly created wallets
    };
  } catch (error) {
    console.error("Error adding wallet:", error);
    throw error;
  }
}
async function setActiveWallet(walletId) {
  const walletsData = await getAllWallets();
  const wallet = walletsData.walletList.find((w) => w.id === walletId);
  if (!wallet) {
    throw new Error("Wallet not found");
  }
  walletsData.activeWalletId = walletId;
  await save(WALLETS_KEY, walletsData);
  return wallet;
}
async function renameWallet(walletId, newNickname) {
  if (!newNickname || newNickname.trim().length === 0) {
    throw new Error("Nickname cannot be empty");
  }
  if (newNickname.length > 30) {
    throw new Error("Nickname too long (max 30 characters)");
  }
  const walletsData = await getAllWallets();
  const wallet = walletsData.walletList.find((w) => w.id === walletId);
  if (!wallet) {
    throw new Error("Wallet not found");
  }
  wallet.nickname = newNickname.trim();
  await save(WALLETS_KEY, walletsData);
}
async function deleteWallet(walletId, password) {
  await unlockWallet(password);
  const walletsData = await getAllWallets();
  const walletIndex = walletsData.walletList.findIndex((w) => w.id === walletId);
  if (walletIndex === -1) {
    throw new Error("Wallet not found");
  }
  walletsData.walletList.splice(walletIndex, 1);
  if (walletsData.activeWalletId === walletId) {
    walletsData.activeWalletId = walletsData.walletList.length > 0 ? walletsData.walletList[0].id : null;
  }
  await save(WALLETS_KEY, walletsData);
}
async function unlockWallet(password, options = {}) {
  const activeWallet = await getActiveWallet();
  if (!activeWallet) {
    throw new Error("No wallet found. Please create or import a wallet.");
  }
  return await unlockSpecificWallet(activeWallet.id, password, options);
}
async function unlockSpecificWallet(walletId, password, options = {}) {
  try {
    const walletsData = await getAllWallets();
    const wallet = walletsData.walletList.find((w) => w.id === walletId);
    if (!wallet) {
      throw new Error("Wallet not found");
    }
    const keystoreJson = await decryptWithAES(wallet.encryptedKeystore, password);
    const signer = await Wallet.fromEncryptedJson(
      keystoreJson,
      password
    );
    if (!wallet.address) {
      wallet.address = signer.address;
      await save(WALLETS_KEY, walletsData);
    }
    if (!options.skipUpgrade) {
      const currentIterations = getIterationsFromEncrypted(wallet.encryptedKeystore);
      const recommendedIterations = getCurrentRecommendedIterations();
      if (currentIterations < recommendedIterations) {
        if (ongoingUpgrades.has(walletId)) {
          console.log(` Wallet upgrade already in progress, waiting for completion...`);
          await ongoingUpgrades.get(walletId);
          const updatedWalletsData = await getAllWallets();
          const updatedWallet = updatedWalletsData.walletList.find((w) => w.id === walletId);
          return {
            address: signer.address,
            signer,
            upgraded: true,
            iterationsBefore: currentIterations,
            iterationsAfter: recommendedIterations,
            upgradedByConcurrentTab: true
          };
        }
        const upgradePromise = (async () => {
          try {
            const iterationsBefore = currentIterations;
            console.log(` Wallet encryption upgrade available:`);
            console.log(`   Current: ${currentIterations.toLocaleString()} iterations`);
            console.log(`   Recommended: ${recommendedIterations.toLocaleString()} iterations`);
            if (options.onUpgradeStart) {
              options.onUpgradeStart({
                currentIterations,
                recommendedIterations,
                estimatedTimeMs: Math.floor(recommendedIterations / 1e5 * 100)
                // ~100ms per 100k iterations
              });
            }
            console.log(` Upgrading wallet security...`);
            const upgradeStart = Date.now();
            const newKeystoreJson = await signer.encrypt(password);
            const newEncrypted = await encryptWithAES(
              newKeystoreJson,
              password,
              recommendedIterations
            );
            const latestWalletsData = await getAllWallets();
            const latestWallet = latestWalletsData.walletList.find((w) => w.id === walletId);
            if (!latestWallet) {
              throw new Error("Wallet not found during upgrade");
            }
            latestWallet.encryptedKeystore = newEncrypted;
            latestWallet.lastSecurityUpgrade = Date.now();
            latestWallet.currentIterations = recommendedIterations;
            await save(WALLETS_KEY, latestWalletsData);
            const upgradeTime = Date.now() - upgradeStart;
            console.log(` Wallet upgraded to ${recommendedIterations.toLocaleString()} iterations (${upgradeTime}ms)`);
            return {
              iterationsBefore,
              iterationsAfter: recommendedIterations
            };
          } finally {
            ongoingUpgrades.delete(walletId);
          }
        })();
        ongoingUpgrades.set(walletId, upgradePromise);
        const upgradeResult = await upgradePromise;
        return {
          address: signer.address,
          signer,
          upgraded: true,
          ...upgradeResult
        };
      }
    }
    return {
      address: signer.address,
      signer,
      upgraded: false
    };
  } catch (error) {
    if (error.message.includes("incorrect password") || error.message.includes("Decryption failed")) {
      throw new Error("Incorrect password");
    }
    throw new Error("Failed to unlock wallet: " + error.message);
  }
}
async function exportPrivateKey(password) {
  const { signer } = await unlockWallet(password, { skipUpgrade: true });
  return signer.privateKey;
}
async function exportMnemonic(password) {
  const { signer } = await unlockWallet(password, { skipUpgrade: true });
  return signer.mnemonic ? signer.mnemonic.phrase : null;
}
async function exportPrivateKeyForWallet(walletId, password) {
  const { signer } = await unlockSpecificWallet(walletId, password, { skipUpgrade: true });
  return signer.privateKey;
}
async function exportMnemonicForWallet(walletId, password) {
  const { signer } = await unlockSpecificWallet(walletId, password, { skipUpgrade: true });
  return signer.mnemonic ? signer.mnemonic.phrase : null;
}
async function importFromMnemonic(mnemonic, password) {
  const result = await addWallet("mnemonic", { mnemonic }, password, "Main Wallet");
  return {
    address: result.address
  };
}
async function importFromPrivateKey(privateKey, password) {
  const result = await addWallet("privatekey", { privateKey }, password, "Main Wallet");
  return {
    address: result.address
  };
}
const RPC_ENDPOINTS = {
  "pulsechainTestnet": [
    "https://rpc.v4.testnet.pulsechain.com",
    "https://rpc-testnet-pulsechain.g4mm4.io"
  ],
  "pulsechain": [
    "https://rpc.pulsechain.com",
    "https://pulsechain-rpc.publicnode.com",
    "https://rpc-pulsechain.g4mm4.io",
    "https://pulsechain.publicnode.com"
  ],
  "ethereum": [
    "https://eth.llamarpc.com",
    "https://ethereum.publicnode.com",
    "https://rpc.ankr.com/eth",
    "https://cloudflare-eth.com"
  ],
  "sepolia": [
    "https://rpc.sepolia.org",
    "https://ethereum-sepolia.publicnode.com",
    "https://rpc.ankr.com/eth_sepolia"
  ]
};
const providers = {};
const endpointHealth = /* @__PURE__ */ new Map();
const HEALTH_CONFIG = {
  MAX_FAILURES: 3,
  // Blacklist after 3 failures
  BLACKLIST_DURATION: 3e5,
  // 5 minutes blacklist
  RETRY_DELAY: 1e3
  // 1 second delay between endpoint attempts
};
function recordEndpointFailure(endpoint) {
  const health = endpointHealth.get(endpoint) || { failures: 0, lastCheck: Date.now(), blacklisted: false };
  health.failures++;
  health.lastCheck = Date.now();
  if (health.failures >= HEALTH_CONFIG.MAX_FAILURES) {
    health.blacklisted = true;
    console.warn(` RPC endpoint blacklisted after ${health.failures} failures: ${endpoint}`);
    setTimeout(() => {
      const currentHealth = endpointHealth.get(endpoint);
      if (currentHealth) {
        currentHealth.blacklisted = false;
        currentHealth.failures = 0;
        console.log(` RPC endpoint recovered from blacklist: ${endpoint}`);
      }
    }, HEALTH_CONFIG.BLACKLIST_DURATION);
  }
  endpointHealth.set(endpoint, health);
}
function recordEndpointSuccess(endpoint) {
  const health = endpointHealth.get(endpoint) || { failures: 0, lastCheck: Date.now(), blacklisted: false };
  health.failures = Math.max(0, health.failures - 1);
  health.lastCheck = Date.now();
  endpointHealth.set(endpoint, health);
}
function isEndpointBlacklisted(endpoint) {
  const health = endpointHealth.get(endpoint);
  return health?.blacklisted || false;
}
async function getProvider(network) {
  const endpoints = RPC_ENDPOINTS[network];
  if (!endpoints) {
    throw new Error(`Unknown network: ${network}`);
  }
  if (providers[network]) {
    try {
      await providers[network].getBlockNumber();
      return providers[network];
    } catch (error) {
      console.warn(` Cached provider failed for ${network}, trying failover...`);
      delete providers[network];
    }
  }
  const endpointsList = Array.isArray(endpoints) ? endpoints : [endpoints];
  for (let i = 0; i < endpointsList.length; i++) {
    const endpoint = endpointsList[i];
    if (isEndpointBlacklisted(endpoint)) {
      console.warn(` Skipping blacklisted endpoint: ${endpoint}`);
      continue;
    }
    try {
      console.log(` Trying RPC endpoint (${i + 1}/${endpointsList.length}): ${endpoint}`);
      const provider = new JsonRpcProvider(endpoint);
      await provider.getBlockNumber();
      providers[network] = provider;
      recordEndpointSuccess(endpoint);
      console.log(` Connected to RPC: ${endpoint}`);
      return provider;
    } catch (error) {
      console.error(` RPC endpoint failed: ${endpoint}`, error.message);
      recordEndpointFailure(endpoint);
      if (i < endpointsList.length - 1) {
        await new Promise((resolve) => setTimeout(resolve, HEALTH_CONFIG.RETRY_DELAY));
      }
    }
  }
  throw new Error(`All RPC endpoints failed for network: ${network}. Please check your internet connection.`);
}
async function rpcCall(network, method, params = []) {
  const provider = await getProvider(network);
  return await provider.send(method, params);
}
async function getBalance(network, address) {
  return await rpcCall(network, "eth_getBalance", [address, "latest"]);
}
async function getTransactionCount(network, address) {
  return await rpcCall(network, "eth_getTransactionCount", [address, "latest"]);
}
async function getGasPrice(network) {
  return await rpcCall(network, "eth_gasPrice", []);
}
async function getBaseFee(network) {
  try {
    const latestBlock = await rpcCall(network, "eth_getBlockByNumber", ["latest", false]);
    if (latestBlock && latestBlock.baseFeePerGas) {
      return latestBlock.baseFeePerGas;
    }
    return await rpcCall(network, "eth_gasPrice", []);
  } catch (error) {
    console.warn("Error getting base fee, falling back to eth_gasPrice:", error);
    return await rpcCall(network, "eth_gasPrice", []);
  }
}
async function getSafeGasPrice(network) {
  try {
    const [gasPrice, baseFee] = await Promise.all([
      rpcCall(network, "eth_gasPrice", []),
      getBaseFee(network)
    ]);
    const gasPriceWei = BigInt(gasPrice);
    const baseFeeWei = BigInt(baseFee);
    const safeGasPrice = gasPriceWei > baseFeeWei * 2n ? gasPriceWei : baseFeeWei * 2n;
    return "0x" + safeGasPrice.toString(16);
  } catch (error) {
    console.warn("Error getting safe gas price, falling back to eth_gasPrice:", error);
    return await rpcCall(network, "eth_gasPrice", []);
  }
}
async function getBlockNumber(network) {
  return await rpcCall(network, "eth_blockNumber", []);
}
async function getBlockByNumber(network, blockNumber, includeTransactions = false) {
  return await rpcCall(network, "eth_getBlockByNumber", [blockNumber, includeTransactions]);
}
async function estimateGas(network, transaction) {
  return await rpcCall(network, "eth_estimateGas", [transaction]);
}
async function call(network, transaction) {
  return await rpcCall(network, "eth_call", [transaction, "latest"]);
}
async function sendRawTransaction(network, signedTx) {
  return await rpcCall(network, "eth_sendRawTransaction", [signedTx]);
}
async function getTransactionReceipt(network, txHash) {
  return await rpcCall(network, "eth_getTransactionReceipt", [txHash]);
}
async function getTransactionByHash(network, txHash) {
  return await rpcCall(network, "eth_getTransactionByHash", [txHash]);
}
function formatBalance(balanceWei, decimals = 4) {
  const balance = formatEther(balanceWei);
  const num = parseFloat(balance);
  return num.toFixed(decimals);
}
export {
  toUtf8Bytes as $,
  formatEther as A,
  getBytes as B,
  Contract as C,
  toUtf8String as D,
  deleteWallet as E,
  exportMnemonicForWallet as F,
  exportPrivateKeyForWallet as G,
  getAddress as H,
  Interface as I,
  getTransactionByHash as J,
  getTransactionReceipt as K,
  sendRawTransaction as L,
  call as M,
  getBlockByNumber as N,
  getBlockNumber as O,
  computeHmac as P,
  keccak256 as Q,
  pbkdf2 as R,
  randomBytes as S,
  ripemd160 as T,
  scrypt as U,
  scryptSync as V,
  sha256 as W,
  sha512 as X,
  assertArgument as Y,
  hexlify as Z,
  concat as _,
  setActiveWallet as a,
  LogDescription as a$,
  toTwos as a0,
  zeroPadValue as a1,
  toBeArray as a2,
  dataLength as a3,
  zeroPadBytes as a4,
  defineProperties as a5,
  BaseContract as a6,
  copyOverrides as a7,
  resolveArgs as a8,
  assert as a9,
  ContractEventPayload as aA,
  ContractTransactionReceipt as aB,
  ContractTransactionResponse as aC,
  ContractUnknownEventPayload as aD,
  EnsPlugin as aE,
  EnsResolver as aF,
  ErrorDescription as aG,
  ErrorFragment as aH,
  EtherSymbol as aI,
  EventFragment as aJ,
  EventLog as aK,
  EventPayload as aL,
  FallbackFragment as aM,
  FeeData as aN,
  FeeDataNetworkPlugin as aO,
  FetchCancelSignal as aP,
  FetchResponse as aQ,
  FetchUrlFeeDataNetworkPlugin as aR,
  FixedNumber as aS,
  Fragment as aT,
  FunctionFragment as aU,
  GasCostPlugin as aV,
  HDNodeVoidWallet as aW,
  HDNodeWallet as aX,
  Indexed as aY,
  JsonRpcSigner as aZ,
  Log as a_,
  getCreateAddress as aa,
  JsonRpcProvider as ab,
  Network as ac,
  FetchRequest as ad,
  resolveProperties as ae,
  AbstractProvider as af,
  toQuantity as ag,
  accessListify as ah,
  isError as ai,
  AbiCoder as aj,
  Transaction as ak,
  NetworkPlugin as al,
  JsonRpcApiProvider as am,
  UnmanagedSubscriber as an,
  makeError as ao,
  getBigInt as ap,
  getNumber as aq,
  AbstractSigner as ar,
  JsonRpcApiPollingProvider as as,
  isHexString as at,
  decodeOwl as au,
  WordlistOwl as av,
  LangEn as aw,
  BaseWallet as ax,
  Block as ay,
  ConstructorFragment as az,
  getActiveWallet as b,
  stripZerosLeft as b$,
  MessagePrefix as b0,
  Mnemonic as b1,
  MulticoinProviderPlugin as b2,
  NamedFragment as b3,
  ParamType as b4,
  Result as b5,
  Signature as b6,
  SigningKey as b7,
  StructFragment as b8,
  TransactionDescription as b9,
  dnsEncode as bA,
  encodeBase58 as bB,
  encodeBase64 as bC,
  encodeRlp as bD,
  encryptKeystoreJson as bE,
  encryptKeystoreJsonSync as bF,
  ensNormalize as bG,
  fromTwos as bH,
  getAccountPath as bI,
  getBytesCopy as bJ,
  getCreate2Address as bK,
  getIcapAddress as bL,
  getIndexedAccountPath as bM,
  getUint as bN,
  hashAuthorization as bO,
  hashMessage as bP,
  id as bQ,
  isAddressable as bR,
  isBytesLike as bS,
  isCallException as bT,
  isCrowdsaleJson as bU,
  isKeystoreJson as bV,
  isValidName as bW,
  mask as bX,
  namehash as bY,
  recoverAddress as bZ,
  resolveAddress as b_,
  TransactionReceipt as ba,
  TransactionResponse as bb,
  Typed as bc,
  TypedDataEncoder as bd,
  UndecodedEventLog as be,
  Utf8ErrorFuncs as bf,
  VoidSigner as bg,
  Wallet as bh,
  Wordlist as bi,
  ZeroAddress as bj,
  ZeroHash as bk,
  assertArgumentCount as bl,
  assertNormalize as bm,
  assertPrivate as bn,
  authorizationify as bo,
  checkResultErrors as bp,
  computeAddress as bq,
  copyRequest as br,
  dataSlice as bs,
  decodeBase58 as bt,
  decodeBase64 as bu,
  decodeRlp as bv,
  decryptCrowdsaleJson as bw,
  decryptKeystoreJson as bx,
  decryptKeystoreJsonSync as by,
  defaultPath as bz,
  importFromMnemonic as c,
  toBeHex as c0,
  toBigInt as c1,
  toNumber as c2,
  toUtf8CodePoints as c3,
  uuidV4 as c4,
  verifyAuthorization as c5,
  verifyMessage as c6,
  verifyTypedData as c7,
  version as c8,
  importFromPrivateKey as d,
  shortenAddress as e,
  formatUnits as f,
  getProvider as g,
  getAllWallets as h,
  isAddress as i,
  getBalance as j,
  formatBalance as k,
  load as l,
  migrateToMultiWallet as m,
  getTransactionCount as n,
  parseEther as o,
  parseUnits$1 as p,
  getGasPrice as q,
  exportMnemonic as r,
  save as s,
  exportPrivateKey as t,
  unlockWallet as u,
  addWallet as v,
  walletExists as w,
  renameWallet as x,
  getSafeGasPrice as y,
  estimateGas as z
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnBjLmpzIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9lcnJvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9tYXRocy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNTguanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTY0LWJyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXZlbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3V0ZjguanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZ2V0dXJsLWJyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZmV0Y2guanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWRlY29kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ybHAtZW5jb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3VuaXRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3V1aWQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3Bia2RmMi5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2NyeXB0by1icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9obWFjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2tlY2Nhay5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9yaXBlbWQxNjAuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3JpcGVtZDE2MC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vcGJrZGYyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9yYW5kb20uanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2NyeXB0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zY3J5cHQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NoYTIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvYWRkcmVzc2VzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9oYXNoZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL3N0cmluZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25hdHVyZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2lnbmluZy1rZXkuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvY29udHJhY3QtYWRkcmVzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NoZWNrcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvdHlwZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hZGRyZXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYW5vbnltb3VzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ib29sZWFuLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYnl0ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9maXhlZC1ieXRlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL251bGwuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udW1iZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9zdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy90dXBsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hY2Nlc3NsaXN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2F1dGhvcml6YXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWRkcmVzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL2F1dGhvcml6YXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AYWRyYWZmeS9lbnMtbm9ybWFsaXplL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvbmFtZWhhc2guanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9tZXNzYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvdHlwZWQtZGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvZnJhZ21lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9hYmktY29kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3Qvd3JhcHBlcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Vucy1yZXNvbHZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZm9ybWF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wbHVnaW5zLW5ldHdvcmsuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItcG9sbGluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvYmFzZS13YWxsZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL2RlY29kZS1vd2wuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL3dvcmRsaXN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy93b3JkbGlzdC1vd2wuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL2xhbmctZW4uanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L21uZW1vbmljLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuZXNtL2Flcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuZXNtL21vZGUtY2JjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuZXNtL21vZGUtY3RyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuZXNtL3BhZGRpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9qc29uLWtleXN0b3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9oZHdhbGxldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvanNvbi1jcm93ZHNhbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L3dhbGxldC5qcyIsIi4uL3NyYy9jb3JlL3N0b3JhZ2UuanMiLCIuLi9zcmMvY29yZS92YWxpZGF0aW9uLmpzIiwiLi4vc3JjL2NvcmUvd2FsbGV0LmpzIiwiLi4vc3JjL2NvcmUvcnBjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIERvIE5PVCBtb2RpZnkgdGhpcyBmaWxlOyBzZWUgL3NyYy50cy9fYWRtaW4vdXBkYXRlLXZlcnNpb24udHMgKi9cbi8qKlxuICogIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXRoZXJzLlxuICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiNi4xNS4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCIvKipcbiAqICBQcm9wZXJ0eSBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlByb3BlcnRpZXMgIFthYm91dC1wcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpLm1hcCh0ID0+IHQudHJpbSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xuICAgIGVycm9yLmNvZGUgPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xuICAgIHRocm93IGVycm9yO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mICUldmFsdWUlJSwgYnV0IHdpdGggYWxsXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXModmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcCgoaykgPT4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlW2tdKSkpO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0sIHYsIGluZGV4KSA9PiB7XG4gICAgICAgIGFjY3VtW2tleXNbaW5kZXhdXSA9IHY7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqICBBc3NpZ25zIHRoZSAlJXZhbHVlcyUlIHRvICUldGFyZ2V0JSUgYXMgcmVhZC1vbmx5IHZhbHVlcy5cbiAqXG4gKiAgSXQgJSV0eXBlcyUlIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlcyBhcmUgY2hlY2tlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCB2YWx1ZXMsIHR5cGVzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHZhbHVlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgY29uc3QgdHlwZSA9ICh0eXBlcyA/IHR5cGVzW2tleV0gOiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCIsIi8qKlxuICogIEFsbCBlcnJvcnMgaW4gZXRoZXJzIGluY2x1ZGUgcHJvcGVydGllcyB0byBlbnN1cmUgdGhleSBhcmUgYm90aFxuICogIGh1bWFuLXJlYWRhYmxlIChpLmUuIGBgLm1lc3NhZ2VgYCkgYW5kIG1hY2hpbmUtcmVhZGFibGUgKGkuZS4gYGAuY29kZWBgKS5cbiAqXG4gKiAgVGhlIFtbaXNFcnJvcl1dIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoZSBlcnJvciBgYGNvZGVgYCBhbmRcbiAqICBwcm92aWRlIGEgdHlwZSBndWFyZCBmb3IgdGhlIHByb3BlcnRpZXMgcHJlc2VudCBvbiB0aGF0IGVycm9yIGludGVyZmFjZS5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvdXRpbHMvZXJyb3JzOkVycm9ycyAgW2Fib3V0LWVycm9yc11cbiAqL1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fdmVyc2lvbi5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgc2Vlbikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgaWYgKHNlZW4gPT0gbnVsbCkge1xuICAgICAgICBzZWVuID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyXVwiO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uYWRkKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBcIlsgXCIgKyAodmFsdWUubWFwKCh2KSA9PiBzdHJpbmdpZnkodiwgc2VlbikpKS5qb2luKFwiLCBcIikgKyBcIiBdXCI7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgY29uc3QgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gPj4gNF07XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldICYgMHhmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mICh2YWx1ZS50b0pTT04pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh2YWx1ZS50b0pTT04oKSwgc2Vlbik7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gXCJ7IFwiICsga2V5cy5tYXAoKGspID0+IGAke3N0cmluZ2lmeShrLCBzZWVuKX06ICR7c3RyaW5naWZ5KHZhbHVlW2tdLCBzZWVuKX1gKS5qb2luKFwiLCBcIikgKyBcIiB9XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGBbIENPVUxEIE5PVCBTRVJJQUxJWkUgXWA7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgdGhlICUlZXJyb3IlJSBtYXRjaGVzIGFuIGVycm9yIHRocm93biBieSBldGhlcnNcbiAqICB0aGF0IG1hdGNoZXMgdGhlIGVycm9yICUlY29kZSUlLlxuICpcbiAqICBJbiBUeXBlU2NyaXB0IGVudmlyb25tZW50cywgdGhpcyBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGF0ICUlZXJyb3IlJVxuICogIG1hdGNoZXMgYW4gRXRoZXJzRXJyb3IgdHlwZSwgd2hpY2ggbWVhbnMgdGhlIGV4cGVjdGVkIHByb3BlcnRpZXMgd2lsbFxuICogIGJlIHNldC5cbiAqXG4gKiAgQFNlZSBbRXJyb3JDb2Rlc10oYXBpOkVycm9yQ29kZSlcbiAqICBAZXhhbXBsZVxuICogICAgdHJ5IHtcbiAqICAgICAgLy8gY29kZS4uLi5cbiAqICAgIH0gY2F0Y2ggKGUpIHtcbiAqICAgICAgaWYgKGlzRXJyb3IoZSwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICogICAgICAgICAgLy8gVGhlIFR5cGUgR3VhcmQgaGFzIHZhbGlkYXRlZCB0aGlzIG9iamVjdFxuICogICAgICAgICAgY29uc29sZS5sb2coZS5kYXRhKTtcbiAqICAgICAgfVxuICogICAgfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcihlcnJvciwgY29kZSkge1xuICAgIHJldHVybiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gY29kZSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSVlcnJvciUlIGlzIGEgW1tDYWxsRXhjZXB0aW9uRXJyb3JdLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDYWxsRXhjZXB0aW9uKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIik7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgbmV3IEVycm9yIGNvbmZpZ3VyZWQgdG8gdGhlIGZvcm1hdCBldGhlcnMgZW1pdHMgZXJyb3JzLCB3aXRoXG4gKiAgdGhlICUlbWVzc2FnZSUlLCBbW2FwaTpFcnJvckNvZGVdXSAlJWNvZGUlJSBhbmQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiAgZm9yIHRoZSBjb3JyZXNwb25kaW5nIEV0aGVyc0Vycm9yLlxuICpcbiAqICBFYWNoIGVycm9yIGluIGV0aGVycyBpbmNsdWRlcyB0aGUgdmVyc2lvbiBvZiBldGhlcnMsIGFcbiAqICBtYWNoaW5lLXJlYWRhYmxlIFtbRXJyb3JDb2RlXV0sIGFuZCBkZXBlbmRpbmcgb24gJSVjb2RlJSUsIGFkZGl0aW9uYWxcbiAqICByZXF1aXJlZCBwcm9wZXJ0aWVzLiBUaGUgZXJyb3IgbWVzc2FnZSB3aWxsIGFsc28gaW5jbHVkZSB0aGUgJSVtZXNzYWdlJSUsXG4gKiAgZXRoZXJzIHZlcnNpb24sICUlY29kZSUlIGFuZCBhbGwgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLCBzZXJpYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBsZXQgc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICB7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGlmIChcIm1lc3NhZ2VcIiBpbiBpbmZvIHx8IFwiY29kZVwiIGluIGluZm8gfHwgXCJuYW1lXCIgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgd2lsbCBvdmVyd3JpdGUgcG9wdWxhdGVkIHZhbHVlczogJHtzdHJpbmdpZnkoaW5mbyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJzaG9ydE1lc3NhZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoaW5mb1trZXldKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIHN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1NTVwiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVtjb3VsZCBub3Qgc2VyaWFsaXplIG9iamVjdF1cIik7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XG4gICAgICAgIGRldGFpbHMucHVzaChgdmVyc2lvbj0ke3ZlcnNpb259YCk7XG4gICAgICAgIGlmIChkZXRhaWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBkZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlcnJvcjtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSBcIklOVkFMSURfQVJHVU1FTlRcIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTlVNRVJJQ19GQVVMVFwiOlxuICAgICAgICBjYXNlIFwiQlVGRkVSX09WRVJSVU5cIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKGVycm9yLCB7IGNvZGUgfSk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlcnJvciwgaW5mbyk7XG4gICAgfVxuICAgIGlmIChlcnJvci5zaG9ydE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKGVycm9yLCB7IHNob3J0TWVzc2FnZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuLyoqXG4gKiAgVGhyb3dzIGFuIEV0aGVyc0Vycm9yIHdpdGggJSVtZXNzYWdlJSUsICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIGVycm9yXG4gKiAgJSVpbmZvJSUgd2hlbiAlJWNoZWNrJSUgaXMgZmFsc2lzaC4uXG4gKlxuICogIEBzZWUgW1thcGk6bWFrZUVycm9yXV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChjaGVjaywgbWVzc2FnZSwgY29kZSwgaW5mbykge1xuICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgdGhyb3cgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgc2ltcGxlIGhlbHBlciB0byBzaW1wbHkgZW5zdXJpbmcgcHJvdmlkZWQgYXJndW1lbnRzIG1hdGNoIGV4cGVjdGVkXG4gKiAgY29uc3RyYWludHMsIHRocm93aW5nIGlmIG5vdC5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoZSAlJWNoZWNrJSUgaGFzIGJlZW4gYXNzZXJ0ZWQgdHJ1ZSwgc29cbiAqICBhbnkgZnVydGhlciBjb2RlIGRvZXMgbm90IG5lZWQgYWRkaXRpb25hbCBjb21waWxlLXRpbWUgY2hlY2tzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnQoY2hlY2ssIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gXCI6IFwiICsgbWVzc2FnZTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvdW50ID49IGV4cGVjdGVkQ291bnQsIFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgXCJNSVNTSU5HX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG4gICAgYXNzZXJ0KGNvdW50IDw9IGV4cGVjdGVkQ291bnQsIFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBcIlVORVhQRUNURURfQVJHVU1FTlRcIiwge1xuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICB9KTtcbn1cbmNvbnN0IF9ub3JtYWxpemVGb3JtcyA9IFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLnJlZHVjZSgoYWNjdW0sIGZvcm0pID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBHZW5lcmFsIHRlc3QgZm9yIG5vcm1hbGl6ZVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShmb3JtKSAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZFwiKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmIChmb3JtID09PSBcIk5GRFwiKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChjaGVjayAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtLnB1c2goZm9ybSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGFjY3VtO1xufSwgW10pO1xuLyoqXG4gKiAgVGhyb3dzIGlmIHRoZSBub3JtYWxpemF0aW9uICUlZm9ybSUlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3JtYWxpemUoZm9ybSkge1xuICAgIGFzc2VydChfbm9ybWFsaXplRm9ybXMuaW5kZXhPZihmb3JtKSA+PSAwLCBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgaW5mbzogeyBmb3JtIH1cbiAgICB9KTtcbn1cbi8qKlxuICogIE1hbnkgY2xhc3NlcyB1c2UgZmlsZS1zY29wZWQgdmFsdWVzIHRvIGd1YXJkIHRoZSBjb25zdHJ1Y3RvcixcbiAqICBtYWtpbmcgaXQgZWZmZWN0aXZlbHkgcHJpdmF0ZS4gVGhpcyBmYWNpbGl0YXRlcyB0aGF0IHBhdHRlcm5cbiAqICBieSBlbnN1cmluZyB0aGUgJSVnaXZlbkdhdXJkJSUgbWF0Y2hlcyB0aGUgZmlsZS1zY29wZWQgJSVndWFyZCUlLFxuICogIHRocm93aW5nIGlmIG5vdCwgaW5kaWNhdGluZyB0aGUgJSVjbGFzc05hbWUlJSBpZiBwcm92aWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFByaXZhdGUoZ2l2ZW5HdWFyZCwgZ3VhcmQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWUgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoZ2l2ZW5HdWFyZCAhPT0gZ3VhcmQpIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IGNsYXNzTmFtZSwgb3BlcmF0aW9uID0gXCJuZXdcIjtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgbWV0aG9kICs9IFwiLlwiO1xuICAgICAgICAgICAgb3BlcmF0aW9uICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYHByaXZhdGUgY29uc3RydWN0b3I7IHVzZSAke21ldGhvZH1mcm9tKiBtZXRob2RzYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCIvKipcbiAqICBTb21lIGRhdGEgaGVscGVycy5cbiAqXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6RGF0YSBIZWxwZXJzICBbYWJvdXQtZGF0YV1cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBjb3B5KSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tYXRjaCgvXjB4KD86WzAtOWEtZl1bMC05YS1mXSkqJC9pKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyAyKSwgMTYpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCeXRlc0xpa2UgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJS4gSWYgYWxyZWFkeSBhIFVpbnQ4QXJyYXlcbiAqICB0aGUgb3JpZ2luYWwgJSV2YWx1ZSUlIGlzIHJldHVybmVkOyBpZiBhIGNvcHkgaXMgcmVxdWlyZWQgdXNlXG4gKiAgW1tnZXRCeXRlc0NvcHldXS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNDb3B5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGZhbHNlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJSwgY3JlYXRpbmcgYSBjb3B5IGlmIG5lY2Vzc2FyeVxuICogIHRvIHByZXZlbnQgYW55IG1vZGlmaWNhdGlvbnMgb2YgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gYmVpbmdcbiAqICByZWZsZWN0ZWQgZWxzZXdoZXJlLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qnl0ZXNDb3B5KHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgdHJ1ZSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tIZXhTdHJpbmddXS5cbiAqXG4gKiAgSWYgJSVsZW5ndGglJSBpcyBgYHRydWVgYCBvciBhIC8vbnVtYmVyLy8sIGl0IGFsc28gY2hlY2tzIHRoYXRcbiAqICAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWxlbmd0aCUlIChpZiBhIC8vbnVtYmVyLy8pXG4gKiAgYnl0ZXMgb2YgZGF0YSAoZS5nLiBgYDB4MTIzNGBgIGlzIDIgYnl0ZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGxlbmd0aCkgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IHRydWUgJiYgKHZhbHVlLmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYXJiaXRyYXJ5XG4gKiAgZGF0YSAoaS5lLiBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9yIGEgVWludDhBcnJheSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKTtcbn1cbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSByZXByZXNlbnRhdGlvbiBvZiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleGxpZnkoZGF0YSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBieXRlc1tpXTtcbiAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IGNvbmNhdGVuYXRpbmcgYWxsIHZhbHVlc1xuICogIHdpdGhpbiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChkYXRhcykge1xuICAgIHJldHVybiBcIjB4XCIgKyBkYXRhcy5tYXAoKGQpID0+IGhleGxpZnkoZCkuc3Vic3RyaW5nKDIpKS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLCBpbiBieXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFMZW5ndGgoZGF0YSkge1xuICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSkubGVuZ3RoO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IHNsaWNpbmcgJSVkYXRhJSUgZnJvbSB0aGUgJSVzdGFydCUlXG4gKiAgb2Zmc2V0IHRvIHRoZSAlJWVuZCUlIG9mZnNldC5cbiAqXG4gKiAgQnkgZGVmYXVsdCAlJXN0YXJ0JSUgaXMgMCBhbmQgJSVlbmQlJSBpcyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YVNsaWNlKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGlmIChlbmQgIT0gbnVsbCAmJiBlbmQgPiBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBzbGljZSBiZXlvbmQgZGF0YSBib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IGJ5dGVzLmxlbmd0aCwgb2Zmc2V0OiBlbmRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzLnNsaWNlKChzdGFydCA9PSBudWxsKSA/IDAgOiBzdGFydCwgKGVuZCA9PSBudWxsKSA/IGJ5dGVzLmxlbmd0aCA6IGVuZCkpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSByZXN1bHQgYnkgc3RyaXBwaW5nIGFsbCAqKmxlYWRpbmcqKlxuICoqIHplcm8gYnl0ZXMgZnJvbSAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3NMZWZ0KGRhdGEpIHtcbiAgICBsZXQgYnl0ZXMgPSBoZXhsaWZ5KGRhdGEpLnN1YnN0cmluZygyKTtcbiAgICB3aGlsZSAoYnl0ZXMuc3RhcnRzV2l0aChcIjAwXCIpKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgYnl0ZXM7XG59XG5mdW5jdGlvbiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgbGVmdCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgYXNzZXJ0KGxlbmd0aCA+PSBieXRlcy5sZW5ndGgsIFwicGFkZGluZyBleGNlZWRzIGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KGJ5dGVzKSxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIG9mZnNldDogbGVuZ3RoICsgMVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LmZpbGwoMCk7XG4gICAgaWYgKGxlZnQpIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgbGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIDApO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqbGVmdCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKip2YWx1ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYHVpbnQxMjhgYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkVmFsdWUoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCB0cnVlKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKnJpZ2h0KipcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxuICpcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXG4gKiAgdGhyb3duLlxuICpcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKmJ5dGVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGBieXRlczE2YGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZEJ5dGVzKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgZmFsc2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiLCIvKipcbiAqICBTb21lIG1hdGhlbWF0aWMgb3BlcmF0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6TWF0aCBIZWxwZXJzICBbYWJvdXQtbWF0aHNdXG4gKi9cbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG4vL2NvbnN0IEJOX01heDI1NiA9IChCTl8xIDw8IEJpZ0ludCgyNTYpKSAtIEJOXzE7XG4vLyBJRUVFIDc1NCBzdXBwb3J0IDUzLWJpdHMgb2YgbWFudGlzc2FcbmNvbnN0IG1heFZhbHVlID0gMHgxZmZmZmZmZmZmZmZmZjtcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIGZyb20gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2YgJSV3aWR0aCUlXG4gKiAgYml0cyB0byBpdHMgdmFsdWUuXG4gKlxuICogIElmIHRoZSBoaWdoZXN0IGJpdCBpcyBgYDFgYCwgdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGFzc2VydCgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgIGlmICh2YWx1ZSA8IEJOXzApIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8PSBsaW1pdCwgXCJ0b28gbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gKCh+dmFsdWUpICYgbWFzaykgKyBCTl8xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiAgTWFzayAlJXZhbHVlJSUgd2l0aCBhIGJpdG1hc2sgb2YgJSViaXRzJSUgb25lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2soX3ZhbHVlLCBfYml0cykge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgYml0cyA9IEJpZ0ludChnZXROdW1iZXIoX2JpdHMsIFwiYml0c1wiKSk7XG4gICAgcmV0dXJuIHZhbHVlICYgKChCTl8xIDw8IGJpdHMpIC0gQk5fMSk7XG59XG4vKipcbiAqICBHZXRzIGEgQmlnSW50IGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxuICogIGEgQmlnSW50LCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6IHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIgJiYgdmFsdWVbMV0gIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtQmlnSW50KHZhbHVlLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgQmlnTnVtYmVyaXNoIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgJSV2YWx1ZSUlIGFzIGEgYmlnaW50LCB2YWxpZGF0aW5nIGl0IGlzIHZhbGlkIGFzIGEgYmlnaW50XG4gKiAgdmFsdWUgYW5kIHRoYXQgaXQgaXMgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50KHZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKTtcbiAgICBhc3NlcnQocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qXG4gKiBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXIodmFsdWUsIG5hbWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcihCaWdJbnQodmFsdWUpLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIG51bWVyaWMgc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIG51bWJlci4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcbiAqICBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS4gVGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc2FmZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldE51bWJlcih0b0JpZ0ludCh2YWx1ZSkpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBoZXhzdHJpbmcsIG9wdGlvbmFsbHkgcGFkZGVkIHRvXG4gKiAgJSV3aWR0aCUlIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgIGFzc2VydCh3aWR0aCAqIDIgPj0gcmVzdWx0Lmxlbmd0aCwgYHZhbHVlIGV4Y2VlZHMgd2lkdGggKCR7d2lkdGh9IGJ5dGVzKWAsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9CZUhleFwiLFxuICAgICAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIixcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFBhZCB0aGUgdmFsdWUgdG8gdGhlIHJlcXVpcmVkIHdpZHRoXG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgKHdpZHRoICogMikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JlQXJyYXkoX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAodmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICB9XG4gICAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogMjtcbiAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tIZXhTdHJpbmddXSBmb3IgJSV2YWx1ZSUlIHNhZmUgdG8gdXNlIGFzIGEgLy9RdWFudGl0eS8vLlxuICpcbiAqICBBIC8vUXVhbnRpdHkvLyBkb2VzIG5vdCBoYXZlIGFuZCBsZWFkaW5nIDAgdmFsdWVzIHVubGVzcyB0aGUgdmFsdWUgaXNcbiAqICB0aGUgbGl0ZXJhbCB2YWx1ZSBgMHgwYC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgZm9yIEpTU09OLVJQQ1xuICogIG51bWVyaWMgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9RdWFudGl0eSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBoZXhsaWZ5KGlzQnl0ZXNMaWtlKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChyZXN1bHQuc3RhcnRzV2l0aChcIjBcIikpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhzLmpzLm1hcCIsIi8qKlxuICogIFRoZSBbQmFzZTU4IEVuY29kaW5nXShsaW5rLWJhc2U1OCkgc2NoZW1lIGFsbG93cyBhICoqbnVtZXJpYyoqIHZhbHVlXG4gKiAgdG8gYmUgZW5jb2RlZCBhcyBhIGNvbXBhY3Qgc3RyaW5nIHVzaW5nIGEgcmFkaXggb2YgNTggdXNpbmcgb25seVxuICogIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy4gQ29uZnVzaW5nbHkgc2ltaWxhciBjaGFyYWN0ZXJzIGFyZSBvbWl0dGVkXG4gKiAgKGkuZS4gYGBcImwwT1wiYGApLlxuICpcbiAqICBOb3RlIHRoYXQgQmFzZTU4IGVuY29kZXMgYSAqKm51bWVyaWMqKiB2YWx1ZSwgbm90IGFyYml0cmFyeSBieXRlcyxcbiAqICBzaW5jZSBhbnkgemVyby1ieXRlcyBvbiB0aGUgbGVmdCB3b3VsZCBnZXQgcmVtb3ZlZC4gVG8gbWl0aWdhdGUgdGhpc1xuICogIGlzc3VlIG1vc3Qgc2NoZW1lcyB0aGF0IHVzZSBCYXNlNTggY2hvb3NlIHNwZWNpZmljIGhpZ2gtb3JkZXIgdmFsdWVzXG4gKiAgdG8gZW5zdXJlIG5vbi16ZXJvIHByZWZpeGVzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNTggRW5jb2RpbmcgW2Fib3V0LWJhc2U1OF1cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgdG9CaWdJbnQgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuY29uc3QgQWxwaGFiZXQgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjtcbmxldCBMb29rdXAgPSBudWxsO1xuZnVuY3Rpb24gZ2V0QWxwaGEobGV0dGVyKSB7XG4gICAgaWYgKExvb2t1cCA9PSBudWxsKSB7XG4gICAgICAgIExvb2t1cCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBMb29rdXBbQWxwaGFiZXRbaV1dID0gQmlnSW50KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IExvb2t1cFtsZXR0ZXJdO1xuICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdCAhPSBudWxsLCBgaW52YWxpZCBiYXNlNTggdmFsdWVgLCBcImxldHRlclwiLCBsZXR0ZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fNTggPSBCaWdJbnQoNTgpO1xuLyoqXG4gKiAgRW5jb2RlICUldmFsdWUlJSBhcyBhIEJhc2U1OC1lbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJhc2U1OChfdmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKF92YWx1ZSk7XG4gICAgbGV0IHZhbHVlID0gdG9CaWdJbnQoYnl0ZXMpO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICByZXN1bHQgPSBBbHBoYWJldFtOdW1iZXIodmFsdWUgJSBCTl81OCldICsgcmVzdWx0O1xuICAgICAgICB2YWx1ZSAvPSBCTl81ODtcbiAgICB9XG4gICAgLy8gQWNjb3VudCBmb3IgbGVhZGluZyBwYWRkaW5nIHplcm9zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYnl0ZXNbaV0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IEFscGhhYmV0WzBdICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgRGVjb2RlIHRoZSBCYXNlNTgtZW5jb2RlZCAlJXZhbHVlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNTgodmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCAqPSBCTl81ODtcbiAgICAgICAgcmVzdWx0ICs9IGdldEFscGhhKHZhbHVlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U1OC5qcy5tYXAiLCIvLyB1dGlscy9iYXNlNjQtYnJvd3NlclxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTY0KHRleHREYXRhKSB7XG4gICAgdGV4dERhdGEgPSBhdG9iKHRleHREYXRhKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dERhdGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSB0ZXh0RGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTY0KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhKTtcbiAgICBsZXQgdGV4dERhdGEgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZXh0RGF0YSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYSh0ZXh0RGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQtYnJvd3Nlci5qcy5tYXAiLCIvKipcbiAqICBFdmVudHMgYWxsb3cgZm9yIGFwcGxpY2F0aW9ucyB0byB1c2UgdGhlIG9ic2VydmVyIHBhdHRlcm4sIHdoaWNoXG4gKiAgYWxsb3dzIHN1YnNjcmliaW5nIGFuZCBwdWJsaXNoaW5nIGV2ZW50cywgb3V0c2lkZSB0aGUgbm9ybWFsXG4gKiAgZXhlY3V0aW9uIHBhdGhzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2V2ZW50czpFdmVudHMgIFthYm91dC1ldmVudHNdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG4vKipcbiAqICBXaGVuIGFuIFtbRXZlbnRFbWl0dGVyYWJsZV1dIHRyaWdnZXJzIGEgW1tMaXN0ZW5lcl1dLCB0aGVcbiAqICBjYWxsYmFjayBhbHdheXMgYWhhcyBvbmUgYWRkaXRpb25hbCBhcmd1bWVudCBwYXNzZWQsIHdoaWNoIGlzXG4gKiAgYW4gKipFdmVudFBheWxvYWQqKi5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBmaWx0ZXIuXG4gICAgICovXG4gICAgZmlsdGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgKipFdmVudEVtaXR0ZXJhYmxlKiouXG4gICAgICovXG4gICAgZW1pdHRlcjtcbiAgICAjbGlzdGVuZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkV2ZW50UGF5bG9hZCoqIGZvciAlJWVtaXR0ZXIlJSB3aXRoXG4gICAgICogIHRoZSAlJWxpc3RlbmVyJSUgYW5kIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVtaXR0ZXIsIGxpc3RlbmVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGVtaXR0ZXIsIGZpbHRlciB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVucmVnaXN0ZXIgdGhlIHRyaWdnZXJlZCBsaXN0ZW5lciBmb3IgZnV0dXJlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuI2xpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmVtaXR0ZXIub2ZmKHRoaXMuZmlsdGVyLCB0aGlzLiNsaXN0ZW5lcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCIsIi8qKlxuICogIFVzaW5nIHN0cmluZ3MgaW4gRXRoZXJldW0gKG9yIGFueSBzZWN1cml0eS1iYXNkIHN5c3RlbSkgcmVxdWlyZXNcbiAqICBhZGRpdGlvbmFsIGNhcmUuIFRoZXNlIHV0aWxpdGllcyBhdHRlbXB0IHRvIG1pdGlnYXRlIHNvbWUgb2YgdGhlXG4gKiAgc2FmZXR5IGlzc3VlcyBhcyB3ZWxsIGFzIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gcmVjb3ZlciBhbmQgYW5hbHlzZVxuICogIHN0cmluZ3MuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6U3RyaW5ncyBhbmQgVVRGLTggIFthYm91dC1zdHJpbmdzXVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBhc3NlcnROb3JtYWxpemUgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLCBcImJ5dGVzXCIsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGludmFsaWQgcHJlZml4IChpbmNsdWRpbmcgc3RyYXkgY29udGludWF0aW9uKSwgc2tpcCBhbnkgYWRkaXRpb25hbCBjb250aW51YXRpb24gYnl0ZXNcbiAgICBpZiAocmVhc29uID09PSBcIkJBRF9QUkVGSVhcIiB8fCByZWFzb24gPT09IFwiVU5FWFBFQ1RFRF9DT05USU5VRVwiKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgbyA9IG9mZnNldCArIDE7IG8gPCBieXRlcy5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG4gICAgLy8gKGJ1dCB0aGUgZmlyc3QgYnl0ZSB3YXMgcmVhZCBhbHJlYWR5IHJlYWQgYW5kIHRoZXJlZm9yZSBza2lwcGVkKVxuICAgIGlmIChyZWFzb24gPT09IFwiT1ZFUlJVTlwiKSB7XG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuICAgIH1cbiAgICAvLyBOb3RoaW5nIHRvIHNraXBcbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSTE9OR1wiKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoYmFkQ29kZXBvaW50KSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIGJhZCBjb2RlIHBvaW50IGZvciByZXBsYWNlbWVudFwiLCBcImJhZENvZGVwb2ludFwiLCBiYWRDb2RlcG9pbnQpO1xuICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XG4gICAgb3V0cHV0LnB1c2goMHhmZmZkKTtcbiAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgYXMgaWYgaWdub3JpbmcgZXJyb3JzXG4gICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XG59XG4vKipcbiAqICBBIGhhbmRmdWwgb2YgcG9wdWxhciwgYnVpbHQtaW4gVVRGLTggZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ2llcy5cbiAqXG4gKiAgKipgYFwiZXJyb3JcImBgKiogLSB0aHJvd3Mgb24gQU5ZIGlsbGVnYWwgVVRGLTggc2VxdWVuY2Ugb3JcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50cyAodGhpcyBpcyB0aGUgZGVmYXVsdClcbiAqXG4gKiAgKipgYFwiaWdub3JlXCJgYCoqIC0gc2lsZW50bHkgZHJvcHMgYW55IGlsbGVnYWwgVVRGLTggc2VxdWVuY2VcbiAqICBhbmQgYWNjZXB0cyBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICAqKmBgXCJyZXBsYWNlXCJgYCoqIC0gcmVwbGFjZSBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSB3aXRoIHRoZVxuICogIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoaS5lLiBgYFwiXFxcXHVmZmZkXCJgYCkgYW5kIGFjY2VwdHNcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICBAcmV0dXJuczogUmVjb3JkPFwiZXJyb3JcIiB8IFwiaWdub3JlXCIgfCBcInJlcGxhY2VcIiwgVXRmOEVycm9yRnVuYz5cbiAqL1xuZXhwb3J0IGNvbnN0IFV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhfYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG4gICAgICAgIG9uRXJyb3IgPSBVdGY4RXJyb3JGdW5jcy5lcnJvcjtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhfYnl0ZXMsIFwiYnl0ZXNcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgLy8gMHh4eCB4eHh4XG4gICAgICAgIGlmIChjID4+IDcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlieXRlOyBob3cgbWFueSBieXRlcyBsZWZ0IGZvciB0aGlzIGNoYXJhY3Rlcj9cbiAgICAgICAgbGV0IGV4dHJhTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgbGV0IG92ZXJsb25nTWFzayA9IG51bGw7XG4gICAgICAgIC8vIDExMHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgaWYgKChjICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2Y7XG4gICAgICAgICAgICAvLyAxMTEwIHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2ZmO1xuICAgICAgICAgICAgLy8gMTExMSAweHh4IDEweHggeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAzO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHhmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChjICYgMHhjMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIkJBRF9QUkVGSVhcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG4gICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1ZFUlJVTlwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgICBsZXQgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk1JU1NJTkdfQ09OVElOVUVcIiwgaSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgNikgfCAobmV4dENoYXIgJiAweDNmKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgYWJvdmUgbG9vcCBmb3IgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXhpbXVtIGNvZGUgcG9pbnRcbiAgICAgICAgaWYgKHJlcyA+IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVVRfT0ZfUkFOR0VcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVVEYxNl9TVVJST0dBVEVcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG4gICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSTE9OR1wiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggYnl0ZSByZXByZXNlbnRhdGlvbiBvZiAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoc3RyKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZyB2YWx1ZVwiLCBcInN0clwiLCBzdHIpO1xuICAgIGlmIChmb3JtICE9IG51bGwpIHtcbiAgICAgICAgYXNzZXJ0Tm9ybWFsaXplKGZvcm0pO1xuICAgICAgICBzdHIgPSBzdHIubm9ybWFsaXplKGZvcm0pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaSA8IHN0ci5sZW5ndGggJiYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCksIFwiaW52YWxpZCBzdXJyb2dhdGUgcGFpclwiLCBcInN0clwiLCBzdHIpO1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG47XG4vL2V4cG9ydCBcbmZ1bmN0aW9uIF90b1V0ZjhTdHJpbmcoY29kZVBvaW50cykge1xuICAgIHJldHVybiBjb2RlUG9pbnRzLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSwgKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApKTtcbiAgICB9KS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5IHRoZSBVVEYtOCBkYXRhICUlYnl0ZXMlJS5cbiAqXG4gKiAgV2hlbiAlJW9uRXJyb3IlJSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IGlzIGNhbGxlZCBvbiBVVEYtOFxuICogIGVycm9ycyBhbGxvd2luZyByZWNvdmVyeSB1c2luZyB0aGUgW1tVdGY4RXJyb3JGdW5jXV0gQVBJLlxuICogIChkZWZhdWx0OiBbZXJyb3JdKFV0ZjhFcnJvckZ1bmNzKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBjb2RlLXBvaW50cyBmb3IgJSVzdHIlJS5cbiAqXG4gKiAgSWYgJSVmb3JtJSUgaXMgc3BlY2lmaWVkLCB0aGUgc3RyaW5nIGlzIG5vcm1hbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhDb2RlUG9pbnRzKHN0ciwgZm9ybSkge1xuICAgIHJldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0LCBtYWtlRXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHZXRVcmwob3B0aW9ucykge1xuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFVybChyZXEsIF9zaWduYWwpIHtcbiAgICAgICAgYXNzZXJ0KF9zaWduYWwgPT0gbnVsbCB8fCAhX3NpZ25hbC5jYW5jZWxsZWQsIFwicmVxdWVzdCBjYW5jZWxsZWQgYmVmb3JlIHNlbmRpbmdcIiwgXCJDQU5DRUxMRURcIik7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gcmVxLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYXNzZXJ0KHByb3RvY29sID09PSBcImh0dHBcIiB8fCBwcm90b2NvbCA9PT0gXCJodHRwc1wiLCBgdW5zdXBwb3J0ZWQgcHJvdG9jb2wgJHtwcm90b2NvbH1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBpbmZvOiB7IHByb3RvY29sIH0sXG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBhc3NlcnQocHJvdG9jb2wgPT09IFwiaHR0cHNcIiB8fCAhcmVxLmNyZWRlbnRpYWxzIHx8IHJlcS5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24sIFwiaW5zZWN1cmUgYXV0aG9yaXplZCBjb25uZWN0aW9ucyB1bnN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZXJyb3IgPSBtYWtlRXJyb3IoXCJyZXF1ZXN0IHRpbWVvdXRcIiwgXCJUSU1FT1VUXCIpO1xuICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9LCByZXEudGltZW91dCk7XG4gICAgICAgIGlmIChfc2lnbmFsKSB7XG4gICAgICAgICAgICBfc2lnbmFsLmFkZExpc3RlbmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG1ha2VFcnJvcihcInJlcXVlc3QgY2FuY2VsbGVkXCIsIFwiQ0FOQ0VMTEVEXCIpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXQgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhBcnJheS5mcm9tKHJlcSkpLFxuICAgICAgICAgICAgYm9keTogcmVxLmJvZHkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlc3A7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwID0gYXdhaXQgZmV0Y2gocmVxLnVybCwgaW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgX2Vycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmVzcC5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwQm9keSA9IGF3YWl0IHJlc3AuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgYm9keSA9IChyZXNwQm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheShyZXNwQm9keSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2U6IHJlc3Auc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnMsIGJvZHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFVybDtcbn1cbi8vIEBUT0RPOiByZW1vdmUgaW4gdjc7IHByb3ZpZGVkIGZvciBiYWNrd2FyZHMgY29tcGF0XG5jb25zdCBkZWZhdWx0R2V0VXJsID0gY3JlYXRlR2V0VXJsKHt9KTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVcmwocmVxLCBfc2lnbmFsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRHZXRVcmwocmVxLCBfc2lnbmFsKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHVybC1icm93c2VyLmpzLm1hcCIsIi8qKlxuICogIEZldGNoaW5nIGNvbnRlbnQgZnJvbSB0aGUgd2ViIGlzIGVudmlyb25tZW50LXNwZWNpZmljLCBzbyBFdGhlcnNcbiAqICBwcm92aWRlcyBhbiBhYnN0cmFjdGlvbiB0aGF0IGVhY2ggZW52aXJvbm1lbnQgY2FuIGltcGxlbWVudCB0byBwcm92aWRlXG4gKiAgdGhpcyBzZXJ2aWNlLlxuICpcbiAqICBPbiBbTm9kZS5qc10obGluay1ub2RlKSwgdGhlIGBgaHR0cGBgIGFuZCBgYGh0dHBzYGAgbGlicyBhcmUgdXNlZCB0b1xuICogIGNyZWF0ZSBhIHJlcXVlc3Qgb2JqZWN0LCByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgYW5kIHByb2Nlc3MgZGF0YVxuICogIGFuZCBwb3B1bGF0ZSB0aGUgW1tGZXRjaFJlc3BvbnNlXV0uXG4gKlxuICogIEluIGEgYnJvd3NlciwgdGhlIFtET00gZmV0Y2hdKGxpbmstanMtZmV0Y2gpIGlzIHVzZWQsIGFuZCB0aGUgcmVzdWx0aW5nXG4gKiAgYGBQcm9taXNlYGAgaXMgd2FpdGVkIG9uIHRvIHJldHJpZXZlIHRoZSBwYXlsb2FkLlxuICpcbiAqICBUaGUgW1tGZXRjaFJlcXVlc3RdXSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgbWFueSBjb21tb24gc2l0dWF0aW9ucyxcbiAqICBzdWNoIGFzIHJlZGlyZWN0cywgc2VydmVyIHRocm90dGxpbmcsIGF1dGhlbnRpY2F0aW9uLCBldGMuXG4gKlxuICogIEl0IGFsc28gaGFuZGxlcyBjb21tb24gZ2F0ZXdheXMsIHN1Y2ggYXMgSVBGUyBhbmQgZGF0YSBVUklzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2ZldGNoaW5nOkZldGNoaW5nIFdlYiBDb250ZW50ICBbYWJvdXQtZmV0Y2hdXG4gKi9cbmltcG9ydCB7IGRlY29kZUJhc2U2NCwgZW5jb2RlQmFzZTY0IH0gZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi91dGY4LmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVHZXRVcmwgfSBmcm9tIFwiLi9nZXR1cmwuanNcIjtcbmNvbnN0IE1BWF9BVFRFTVBUUyA9IDEyO1xuY29uc3QgU0xPVF9JTlRFUlZBTCA9IDI1MDtcbi8vIFRoZSBnbG9iYWwgRmV0Y2hHZXRVcmxGdW5jIGltcGxlbWVudGF0aW9uLlxubGV0IGRlZmF1bHRHZXRVcmxGdW5jID0gY3JlYXRlR2V0VXJsKCk7XG5jb25zdCByZURhdGEgPSBuZXcgUmVnRXhwKFwiXmRhdGE6KFteOzpdKik/KDtiYXNlNjQpPywoLiopJFwiLCBcImlcIik7XG5jb25zdCByZUlwZnMgPSBuZXcgUmVnRXhwKFwiXmlwZnM6L1xcLyhpcGZzLyk/KC4qKSRcIiwgXCJpXCIpO1xuLy8gSWYgbG9ja2VkLCBuZXcgR2F0ZXdheXMgY2Fubm90IGJlIGFkZGVkXG5sZXQgbG9ja2VkID0gZmFsc2U7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJMc1xuYXN5bmMgZnVuY3Rpb24gZGF0YUdhdGV3YXlGdW5jKHVybCwgc2lnbmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVEYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSgyMDAsIFwiT0tcIiwge1xuICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogKG1hdGNoWzFdIHx8IFwidGV4dC9wbGFpblwiKSxcbiAgICAgICAgfSwgKG1hdGNoWzJdID8gZGVjb2RlQmFzZTY0KG1hdGNoWzNdKSA6IHVucGVyY2VudChtYXRjaFszXSkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIFwiQkFEIFJFUVVFU1QgKGludmFsaWQgZGF0YTogVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tGZXRjaEdhdGV3YXlGdW5jXV0gZm9yIGZldGNoaW5nIGNvbnRlbnQgZnJvbSBhIHN0YW5kYXJkXG4gKiAgSVBGUyBnYXRld2F5IGhvc3RlZCBhdCAlJWJhc2VVcmwlJS5cbiAqL1xuZnVuY3Rpb24gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnYXRld2F5SXBmcyh1cmwsIHNpZ25hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVJcGZzKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGxpbmtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVxdWVzdChgJHtiYXNlVXJsfSR7bWF0Y2hbMl19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIElQRlMgVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2F0ZXdheUlwZnM7XG59XG5jb25zdCBHYXRld2F5cyA9IHtcbiAgICBcImRhdGFcIjogZGF0YUdhdGV3YXlGdW5jLFxuICAgIFwiaXBmc1wiOiBnZXRJcGZzR2F0ZXdheUZ1bmMoXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCIpXG59O1xuY29uc3QgZmV0Y2hTaWduYWxzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaENhbmNlbFNpZ25hbCB7XG4gICAgI2xpc3RlbmVycztcbiAgICAjY2FuY2VsbGVkO1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBmZXRjaFNpZ25hbHMuc2V0KHJlcXVlc3QsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgbGlzdGVuZXIoKTsgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy4jY2FuY2VsbGVkLCBcInNpbmdhbCBhbHJlYWR5IGNhbmNlbGxlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZmV0Y2hDYW5jZWxTaWduYWwuYWRkQ2FuY2VsTGlzdGVuZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICBnZXQgY2FuY2VsbGVkKCkgeyByZXR1cm4gdGhpcy4jY2FuY2VsbGVkOyB9XG4gICAgY2hlY2tTaWduYWwoKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5jYW5jZWxsZWQsIFwiY2FuY2VsbGVkXCIsIFwiQ0FOQ0VMTEVEXCIsIHt9KTtcbiAgICB9XG59XG4vLyBDaGVjayB0aGUgc2lnbmFsLCB0aHJvd2luZyBpZiBpdCBpcyBjYW5jZWxsZWRcbmZ1bmN0aW9uIGNoZWNrU2lnbmFsKHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgfVxuICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xuICAgIHJldHVybiBzaWduYWw7XG59XG4vKipcbiAqICBSZXByZXNlbnRzIGEgcmVxdWVzdCBmb3IgYSByZXNvdXJjZSB1c2luZyBhIFVSSS5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgdGhlIHN1cHBvcnRlZCBzY2hlbWVzIGFyZSBgYEhUVFBgYCwgYGBIVFRQU2BgLCBgYGRhdGE6YGAsXG4gKiAgYW5kIGBgSVBGUzpgYC5cbiAqXG4gKiAgQWRkaXRpb25hbCBzY2hlbWVzIGNhbiBiZSBhZGRlZCBnbG9iYWxseSB1c2luZyBbW3JlZ2lzdGVyR2F0ZXdheV1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QoXCJodHRwczovL3d3dy5yaWNtb28uY29tXCIpXG4gKiAgICByZXNwID0gYXdhaXQgcmVxLnNlbmQoKVxuICogICAgcmVzcC5ib2R5Lmxlbmd0aFxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hSZXF1ZXN0IHtcbiAgICAjYWxsb3dJbnNlY3VyZTtcbiAgICAjZ3ppcDtcbiAgICAjaGVhZGVycztcbiAgICAjbWV0aG9kO1xuICAgICN0aW1lb3V0O1xuICAgICN1cmw7XG4gICAgI2JvZHk7XG4gICAgI2JvZHlUeXBlO1xuICAgICNjcmVkcztcbiAgICAvLyBIb29rc1xuICAgICNwcmVmbGlnaHQ7XG4gICAgI3Byb2Nlc3M7XG4gICAgI3JldHJ5O1xuICAgICNzaWduYWw7XG4gICAgI3Rocm90dGxlO1xuICAgICNnZXRVcmxGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmV0Y2ggVVJMIHRvIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxuICAgIHNldCB1cmwodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGZldGNoIGJvZHksIGlmIGFueSwgdG8gc2VuZCBhcyB0aGUgcmVxdWVzdCBib2R5LiAvLyhkZWZhdWx0OiBudWxsKS8vXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGEgYm9keSwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiAgc2V0IGFuZCB3aWxsIGJlIHVzZWQgaWYgKipub3Qgb3ZlcnJpZGRlbioqIGJ5IHNldHRpbmcgYSBjdXN0b21cbiAgICAgKiAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIElmICUlYm9keSUlIGlzIG51bGwsIHRoZSBib2R5IGlzIGNsZWFyZWQgKGFsb25nIHdpdGggdGhlXG4gICAgICogIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgKS5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIHN0cmluZywgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIHNldCB0b1xuICAgICAqICBgYHRleHQvcGxhaW5gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIFVpbnQ4QXJyYXksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhbnkgb3RoZXIgb2JqZWN0LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXNcbiAgICAgKiAgc2V0IHRvIGBgYXBwbGljYXRpb24vanNvbmBgLlxuICAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICBpZiAodGhpcy4jYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICAgIHNldCBib2R5KGJvZHkpIHtcbiAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhib2R5KTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhKU09OLnN0cmluZ2lmeShib2R5KSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib2R5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBJZiBubyBtZXRob2RcbiAgICAgKiAgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQsIHRoZW4gYGBHRVRgYCBpcyB1c2VkIGlmIHRoZSBib2R5IGlzXG4gICAgICogIG51bGwgYW5kIGBgUE9TVGBgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICBpZiAodGhpcy4jbWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0JvZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUE9TVFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkdFVFwiO1xuICAgIH1cbiAgICBzZXQgbWV0aG9kKG1ldGhvZCkge1xuICAgICAgICBpZiAobWV0aG9kID09IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWV0aG9kID0gU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBBbGxcbiAgICAgKiAga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKlxuICAgICAqICBUaGlzIG9iamVjdCBpcyBhIGNvcHksIHNvIGFueSBjaGFuZ2VzIHdpbGwgKipOT1QqKiBiZSByZWZsZWN0ZWRcbiAgICAgKiAgaW4gdGhlIGBgRmV0Y2hSZXF1ZXN0YGAuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IGEgaGVhZGVyIGVudHJ5LCB1c2UgdGhlIGBgc2V0SGVhZGVyYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNjcmVkcykge1xuICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmFzaWMgJHtlbmNvZGVCYXNlNjQodG9VdGY4Qnl0ZXModGhpcy4jY3JlZHMpKX1gO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdID0gXCJnemlwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPT0gbnVsbCAmJiB0aGlzLiNib2R5VHlwZSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHRoaXMuI2JvZHlUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IFN0cmluZyh0aGlzLmJvZHkubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgaGVhZGVyIGZvciAlJWtleSUlLCBpZ25vcmluZyBjYXNlLlxuICAgICAqL1xuICAgIGdldEhlYWRlcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSB0byAlJXZhbHVlJSUuIEFsbCB2YWx1ZXMgYXJlIGNvZXJjZWRcbiAgICAgKiAgdG8gYSBzdHJpbmcuXG4gICAgICovXG4gICAgc2V0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy4jaGVhZGVyc1tTdHJpbmcoa2V5KS50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDbGVhciBhbGwgaGVhZGVycywgcmVzZXR0aW5nIGFsbCBpbnRyaW5zaWMgaGVhZGVycy5cbiAgICAgKi9cbiAgICBjbGVhckhlYWRlcnMoKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtrZXksIGhlYWRlcnNba2V5XV0sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgc2VudCBmb3IgdGhlIGBgQXV0aG9yaXphdGlvbmBgIGhlYWRlci5cbiAgICAgKlxuICAgICAqICBUbyBzZXQgdGhlIGNyZWRlbnRpYWxzLCB1c2UgdGhlIGBgc2V0Q3JlZGVudGlhbHNgYCBtZXRob2QuXG4gICAgICovXG4gICAgZ2V0IGNyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY3JlZHMgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldHMgYW4gYGBBdXRob3JpemF0aW9uYGAgZm9yICUldXNlcm5hbWUlJSB3aXRoICUlcGFzc3dvcmQlJS5cbiAgICAgKi9cbiAgICBzZXRDcmVkZW50aWFscyh1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXVzZXJuYW1lLm1hdGNoKC86LyksIFwiaW52YWxpZCBiYXNpYyBhdXRoZW50aWNhdGlvbiB1c2VybmFtZVwiLCBcInVzZXJuYW1lXCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgdGhpcy4jY3JlZHMgPSBgJHt1c2VybmFtZX06JHtwYXNzd29yZH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5hYmxlIGFuZCByZXF1ZXN0IGd6aXAtZW5jb2RlZCByZXNwb25zZXMuIFRoZSByZXNwb25zZSB3aWxsXG4gICAgICogIGF1dG9tYXRpY2FsbHkgYmUgZGVjb21wcmVzc2VkLiAvLyhkZWZhdWx0OiB0cnVlKS8vXG4gICAgICovXG4gICAgZ2V0IGFsbG93R3ppcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2d6aXA7XG4gICAgfVxuICAgIHNldCBhbGxvd0d6aXAodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ3ppcCA9ICEhdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGxvdyBgYEF1dGhlbnRpY2F0aW9uYGAgY3JlZGVudGlhbHMgdG8gYmUgc2VudCBvdmVyIGluc2VjdXJlXG4gICAgICogIGNoYW5uZWxzLiAvLyhkZWZhdWx0OiBmYWxzZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2FsbG93SW5zZWN1cmU7XG4gICAgfVxuICAgIHNldCBhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jYWxsb3dJbnNlY3VyZSA9ICEhdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKSB0byB3YWl0IGZvciBhIGNvbXBsZXRlIHJlc3BvbnNlLlxuICAgICAqICAvLyhkZWZhdWx0OiA1IG1pbnV0ZXMpLy9cbiAgICAgKi9cbiAgICBnZXQgdGltZW91dCgpIHsgcmV0dXJuIHRoaXMuI3RpbWVvdXQ7IH1cbiAgICBzZXQgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHRpbWVvdXQgPj0gMCwgXCJ0aW1lb3V0IG11c3QgYmUgbm9uLXplcm9cIiwgXCJ0aW1lb3V0XCIsIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHByaW9yIHRvIGVhY2ggcmVxdWVzdCwgZm9yIGV4YW1wbGVcbiAgICAgKiAgZHVyaW5nIGEgcmVkaXJlY3Rpb24gb3IgcmV0cnkgaW4gY2FzZSBvZiBzZXJ2ZXIgdGhyb3R0bGluZy5cbiAgICAgKlxuICAgICAqICBUaGlzIG9mZmVycyBhbiBvcHBvcnR1bml0eSB0byBwb3B1bGF0ZSBoZWFkZXJzIG9yIHVwZGF0ZVxuICAgICAqICBjb250ZW50IGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXQgcHJlZmxpZ2h0RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3ByZWZsaWdodCB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcHJlZmxpZ2h0RnVuYyhwcmVmbGlnaHQpIHtcbiAgICAgICAgdGhpcy4jcHJlZmxpZ2h0ID0gcHJlZmxpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCByZXNwb25zZSwgb2ZmZXJpbmcgYW5cbiAgICAgKiAgb3Bwb3J0dW5pdHkgdG8gcHJvdmlkZSBjbGllbnQtbGV2ZWwgdGhyb3R0bGluZyBvciB1cGRhdGluZ1xuICAgICAqICByZXNwb25zZSBkYXRhLlxuICAgICAqXG4gICAgICogIEFueSBlcnJvciB0aHJvd24gaW4gdGhpcyBjYXVzZXMgdGhlIGBgc2VuZCgpYGAgdG8gdGhyb3cuXG4gICAgICpcbiAgICAgKiAgVG8gc2NoZWR1bGUgYSByZXRyeSBhdHRlbXB0IChhc3N1bWluZyB0aGUgbWF4aW11bSByZXRyeSBsaW1pdFxuICAgICAqICBoYXMgbm90IGJlZW4gcmVhY2hlZCksIHVzZSBbW3Jlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcl1dLlxuICAgICAqL1xuICAgIGdldCBwcm9jZXNzRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3MgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByb2Nlc3NGdW5jKHByb2Nlc3MpIHtcbiAgICAgICAgdGhpcy4jcHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIHJldHJ5IGF0dGVtcHQuXG4gICAgICovXG4gICAgZ2V0IHJldHJ5RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JldHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIHNldCByZXRyeUZ1bmMocmV0cnkpIHtcbiAgICAgICAgdGhpcy4jcmV0cnkgPSByZXRyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGZldGNoIGNvbnRlbnQgZnJvbSBIVFRQIGFuZFxuICAgICAqICBIVFRQUyBVUkxzIGFuZCBpcyBwbGF0Zm9ybSBzcGVjaWZpYyAoZS5nLiBub2RlanMgdnNcbiAgICAgKiAgYnJvd3NlcnMpLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYnkgZGVmYXVsdCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybFxuICAgICAqICBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIGNoYW5nZWQgdXNpbmcgW1tyZWdpc3RlckdldFVybF1dLlxuICAgICAqICBJZiB0aGlzIGhhcyBiZWVuIHNldCwgc2V0dGluZyBpcyB0byBgYG51bGxgYCB3aWxsIGNhdXNlXG4gICAgICogIHRoaXMgRmV0Y2hSZXF1ZXN0IChhbmQgYW55IGZ1dHVyZSBjbG9uZXMpIHRvIHJldmVydCBiYWNrIHRvXG4gICAgICogIHVzaW5nIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBnbG9iYWwgZ2V0VXJsIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgdGhpcyBpcyBnZW5lcmFsbHkgbm90IG5lY2Vzc2FyeSwgYnV0IG1heSBiZSB1c2VmdWxcbiAgICAgKiAgZm9yIGRldmVsb3BlcnMgdGhhdCB3aXNoIHRvIGludGVyY2VwdCByZXF1ZXN0cyBvciB0b1xuICAgICAqICBjb25maWd1cmVnZSBhIHByb3h5IG9yIG90aGVyIGFnZW50LlxuICAgICAqL1xuICAgIGdldCBnZXRVcmxGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0VXJsRnVuYyB8fCBkZWZhdWx0R2V0VXJsRnVuYztcbiAgICB9XG4gICAgc2V0IGdldFVybEZ1bmModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2V0VXJsRnVuYyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEZldGNoUmVxdWVzdCBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIE9uY2UgY3JlYXRlZCwgZWFjaCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGJlZm9yZSBpc3N1aW5nIGFcbiAgICAgKiAgYGAuc2VuZCgpYGAgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy4jdXJsID0gU3RyaW5nKHVybCk7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jZ3ppcCA9IHRydWU7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gXCJcIjtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IDMwMDAwMDtcbiAgICAgICAgdGhpcy4jdGhyb3R0bGUgPSB7XG4gICAgICAgICAgICBzbG90SW50ZXJ2YWw6IFNMT1RfSU5URVJWQUwsXG4gICAgICAgICAgICBtYXhBdHRlbXB0czogTUFYX0FUVEVNUFRTXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSBudWxsO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXF1ZXN0IG1ldGhvZD0ke0pTT04uc3RyaW5naWZ5KHRoaXMubWV0aG9kKX0gdXJsPSR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSBoZWFkZXJzPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKX0gYm9keT0ke3RoaXMuI2JvZHkgPyBoZXhsaWZ5KHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVcGRhdGUgdGhlIHRocm90dGxlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXRlcm1pbmUgbWF4aW11bVxuICAgICAqICBhdHRlbXB0cyBhbmQgZXhwb25lbnRpYWwtYmFja29mZiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNldFRocm90dGxlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnNsb3RJbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgPSBwYXJhbXMuc2xvdEludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWF4QXR0ZW1wdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMgPSBwYXJhbXMubWF4QXR0ZW1wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI3NlbmQoYXR0ZW1wdCwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCBfcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGF0dGVtcHQgPj0gdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXhjZWVkZWQgbWF4aW11bSByZXRyeSBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZ2V0VGltZSgpIDw9IGV4cGlyZXMsIFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3Quc2VuZFwiLCByZWFzb246IFwidGltZW91dFwiLCByZXF1ZXN0OiBfcmVxdWVzdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgd2FpdChkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgc2NoZW1lID0gKHJlcS51cmwuc3BsaXQoXCI6XCIpWzBdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIFByb2Nlc3MgYW55IEdhdGV3YXlzXG4gICAgICAgIGlmIChzY2hlbWUgaW4gR2F0ZXdheXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEdhdGV3YXlzW3NjaGVtZV0ocmVxLnVybCwgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZldGNoUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc0Z1bmMocmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgcHJvY2Vzc2luZzsgdGhyb3cgYSA1eHggc2VydmVyIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IudGhyb3R0bGUgPT0gbnVsbCB8fCB0eXBlb2YgKGVycm9yLnN0YWxsKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aHJvdHRsaW5nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgYSBwcmVmbGlnaHQgZnVuY3Rpb247IHVwZGF0ZSB0aGUgcmVxdWVzdFxuICAgICAgICBpZiAodGhpcy5wcmVmbGlnaHRGdW5jKSB7XG4gICAgICAgICAgICByZXEgPSBhd2FpdCB0aGlzLnByZWZsaWdodEZ1bmMocmVxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5nZXRVcmxGdW5jKHJlcSwgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCkpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBuZXcgRmV0Y2hSZXNwb25zZShyZXNwLnN0YXR1c0NvZGUsIHJlc3Auc3RhdHVzTWVzc2FnZSwgcmVzcC5oZWFkZXJzLCByZXNwLmJvZHksIF9yZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpIHtcbiAgICAgICAgICAgIC8vIFJlZGlyZWN0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXEucmVkaXJlY3QobG9jYXRpb24pLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCAwLCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIFRoaW5ncyB3b24ndCBnZXQgYW55IGJldHRlciBvbiBhbm90aGVyIGF0dGVtcHQ7IGFib3J0XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDI5KSB7XG4gICAgICAgICAgICAvLyBUaHJvdHRsZVxuICAgICAgICAgICAgaWYgKHRoaXMucmV0cnlGdW5jID09IG51bGwgfHwgKGF3YWl0IHRoaXMucmV0cnlGdW5jKHJlcSwgcmVzcG9uc2UsIGF0dGVtcHQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzW1wicmV0cnktYWZ0ZXJcIl07XG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsICogTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5QWZ0ZXIpID09PSBcInN0cmluZ1wiICYmIHJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKCkuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZSA9PSBudWxsIHx8IHR5cGVvZiAoZXJyb3Iuc3RhbGwpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhyb3R0bGVcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgKiBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5zdGFsbCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gZXJyb3Iuc3RhbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXEuY2xvbmUoKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIGJ5IHNlbmRpbmcgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgc2VuZCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI3NpZ25hbCA9PSBudWxsLCBcInJlcXVlc3QgYWxyZWFkeSBzZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZldGNoUmVxdWVzdC5zZW5kXCIgfSk7XG4gICAgICAgIHRoaXMuI3NpZ25hbCA9IG5ldyBGZXRjaENhbmNlbFNpZ25hbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3NlbmQoMCwgZ2V0VGltZSgpICsgdGhpcy50aW1lb3V0LCAwLCB0aGlzLCBuZXcgRmV0Y2hSZXNwb25zZSgwLCBcIlwiLCB7fSwgbnVsbCwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FuY2VscyB0aGUgaW5mbGlnaHQgcmVzcG9uc2UsIGNhdXNpbmcgYSBgYENBTkNFTExFRGBgXG4gICAgICogIGVycm9yIHRvIGJlIHJlamVjdGVkIGZyb20gdGhlIFtbc2VuZF1dLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI3NpZ25hbCAhPSBudWxsLCBcInJlcXVlc3QgaGFzIG5vdCBiZWVuIHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LmNhbmNlbFwiIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBmZXRjaFNpZ25hbHMuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAoIXNpZ25hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZldGNoUmVxdWVzdF1dIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVkaXJlY3Rpb25cbiAgICAgKiAgdG8gJSVsb2NhdGlvbiUlLlxuICAgICAqL1xuICAgIHJlZGlyZWN0KGxvY2F0aW9uKSB7XG4gICAgICAgIC8vIFJlZGlyZWN0aW9uOyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBhYnNvbHV0ZSBsb2NhdGlvbnNcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhdGlvbi5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcmVkaXJlY3Rpbmc6XG4gICAgICAgIC8vIC0gbm9uLUdFVCByZXF1ZXN0c1xuICAgICAgICAvLyAtIGRvd25ncmFkaW5nIHRoZSBzZWN1cml0eSAoZS5nLiBodHRwcyA9PiBodHRwKVxuICAgICAgICAvLyAtIHRvIG5vbi1IVFRQIChvciBub24tSFRUUFMpIHByb3RvY29scyBbdGhpcyBjb3VsZCBiZSByZWxheGVkP11cbiAgICAgICAgYXNzZXJ0KHRoaXMubWV0aG9kID09PSBcIkdFVFwiICYmIChjdXJyZW50ICE9PSBcImh0dHBzXCIgfHwgdGFyZ2V0ICE9PSBcImh0dHBcIikgJiYgbG9jYXRpb24ubWF0Y2goL15odHRwcz86LyksIGB1bnN1cHBvcnRlZCByZWRpcmVjdGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlZGlyZWN0KCR7dGhpcy5tZXRob2R9ICR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSA9PiAke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0pYFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHJlcXVlc3QsIHdpdGggYSBuZXcgVVJMXG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QobG9jYXRpb24pO1xuICAgICAgICByZXEubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgcmVxLmFsbG93R3ppcCA9IHRoaXMuYWxsb3dHemlwO1xuICAgICAgICByZXEudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgcmVxLiNoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICByZXEuI2JvZHkgPSBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXEuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIERvIG5vdCBmb3J3YXJkIGNyZWRlbnRpYWxzIHVubGVzcyBvbiB0aGUgc2FtZSBkb21haW47IG9ubHkgYWJzb2x1dGVcbiAgICAgICAgLy9yZXEuYWxsb3dJbnNlY3VyZSA9IGZhbHNlO1xuICAgICAgICAvLyBwYXRocyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZDsgbWF5IHdhbnQgYSB3YXkgdG8gc3BlY2lmeSB0byBmb3J3YXJkP1xuICAgICAgICAvL3NldFN0b3JlKHJlcS4jcHJvcHMsIFwiY3JlZHNcIiwgZ2V0U3RvcmUodGhpcy4jcHJvcywgXCJjcmVkc1wiKSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgY29weSBvZiB0aGlzIHJlcXVlc3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IEZldGNoUmVxdWVzdCh0aGlzLnVybCk7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBtZXRob2RcIiAoaS5lLiBudWxsKVxuICAgICAgICBjbG9uZS4jbWV0aG9kID0gdGhpcy4jbWV0aG9kO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgYm9keVwiIHdpdGggdHlwZSwgY29weWluZyB0aGUgVWludDhBcnJheSBpcyBwcmVzZW50XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICBjbG9uZS4jYm9keSA9IHRoaXMuI2JvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBoZWFkZXJzXCJcbiAgICAgICAgY2xvbmUuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgLy8gQ3JlZGVudGlhbHMgaXMgcmVhZG9ubHksIHNvIHdlIGNvcHkgaW50ZXJuYWxseVxuICAgICAgICBjbG9uZS4jY3JlZHMgPSB0aGlzLiNjcmVkcztcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBjbG9uZS5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGlmICh0aGlzLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbikge1xuICAgICAgICAgICAgY2xvbmUuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS4jcHJlZmxpZ2h0ID0gdGhpcy4jcHJlZmxpZ2h0O1xuICAgICAgICBjbG9uZS4jcHJvY2VzcyA9IHRoaXMuI3Byb2Nlc3M7XG4gICAgICAgIGNsb25lLiNyZXRyeSA9IHRoaXMuI3JldHJ5O1xuICAgICAgICBjbG9uZS4jdGhyb3R0bGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiN0aHJvdHRsZSk7XG4gICAgICAgIGNsb25lLiNnZXRVcmxGdW5jID0gdGhpcy4jZ2V0VXJsRnVuYztcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgTG9ja3MgYWxsIHN0YXRpYyBjb25maWd1cmF0aW9uIGZvciBnYXRld2F5cyBhbmQgRmV0Y2hHZXRVcmxGdW5jXG4gICAgICogIHJlZ2lzdHJhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9ja0NvbmZpZygpIHtcbiAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgY3VycmVudCBHYXRld2F5IGZ1bmN0aW9uIGZvciAlJXNjaGVtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRHYXRld2F5KHNjaGVtZSkge1xuICAgICAgICByZXR1cm4gR2F0ZXdheXNbc2NoZW1lLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVc2UgdGhlICUlZnVuYyUlIHdoZW4gZmV0Y2hpbmcgVVJJcyB1c2luZyAlJXNjaGVtZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdhdGV3YXkoc2NoZW1lLCBmdW5jKSB7XG4gICAgICAgIHNjaGVtZSA9IHNjaGVtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc2NoZW1lID09PSBcImh0dHBcIiB8fCBzY2hlbWUgPT09IFwiaHR0cHNcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgaW50ZXJjZXB0ICR7c2NoZW1lfTsgdXNlIHJlZ2lzdGVyR2V0VXJsYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIEdhdGV3YXlzW3NjaGVtZV0gPSBmdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlICUlZ2V0VXJsJSUgd2hlbiBmZXRjaGluZyBVUklzIG92ZXIgSFRUUCBhbmQgSFRUUFMgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgYWZmZWN0cyBhbGwgcmVxdWVzdHMgZ2xvYmFsbHkuXG4gICAgICpcbiAgICAgKiAgSWYgW1tsb2NrQ29uZmlnXV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjaGFuZ2UgaXMgbWFkZSBhbmQgdGhpc1xuICAgICAqICB0aHJvd3MuXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyR2V0VXJsKGdldFVybCkge1xuICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYXRld2F5cyBsb2NrZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdEdldFVybEZ1bmMgPSBnZXRVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZ2V0VXJsIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyBjb250ZW50IGZyb20gSFRUUCBhbmRcbiAgICAgKiAgSFRUUFMgVVJMcy5cbiAgICAgKlxuICAgICAqICBUaGUgYXZhaWxhYmxlICUlb3B0aW9ucyUlIGFyZSBkZXBlbmRlbnQgb24gdGhlIHBsYXRmb3JtXG4gICAgICogIGltcGxlbWVudGF0aW9uIG9mIHRoZSBkZWZhdWx0IGdldFVybCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgaXMgdXNlZnVsXG4gICAgICogIHdoZW4gdHJ5aW5nIHRvIGN1c3RvbWl6ZSBzaW1wbGUgYmVoYXZpb3VyIHdoZW4gZmV0Y2hpbmcgSFRUUFxuICAgICAqICBjb250ZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVHZXRVcmxGdW5jKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUdldFVybChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBcImZldGNoXCIgZGF0YSBVUklzLlxuICAgICAqXG4gICAgICogIE5vdGUgdGhhdCB0aGlzIGlzIGF1dG9tYXRpY2FsbHkgZG9uZSBpbnRlcm5hbGx5IHRvIHN1cHBvcnRcbiAgICAgKiAgZGF0YSBVUklzLCBzbyBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHJlZ2lzdGVyIGl0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGdlbmVyYWxseSBzb21ldGhpbmcgdGhhdCBpcyBuZWVkZWQsIGJ1dCBtYXlcbiAgICAgKiAgYmUgdXNlZnVsIGluIGEgd3JhcHBlciB0byBwZXJmb20gY3VzdG9tIGRhdGEgVVJJIGZ1bmN0aW9uYWxpdHkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURhdGFHYXRld2F5KCkge1xuICAgICAgICByZXR1cm4gZGF0YUdhdGV3YXlGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBmZXRjaCBJUEZTICh1bnZhbGlkYXRlZCkgZnJvbVxuICAgICAqICBhIGN1c3RvbSBnYXRld2F5IGJhc2VVcmwuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgSVBGUyBnYXRld2F5IHVzZWQgaW50ZXJuYWxseSBpc1xuICAgICAqICBgYFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiYGAuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUlwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgICAgIHJldHVybiBnZXRJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCk7XG4gICAgfVxufVxuO1xuLyoqXG4gKiAgVGhlIHJlc3BvbnNlIGZvciBhIEZldGNoUmVxdWVzdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoUmVzcG9uc2Uge1xuICAgICNzdGF0dXNDb2RlO1xuICAgICNzdGF0dXNNZXNzYWdlO1xuICAgICNoZWFkZXJzO1xuICAgICNib2R5O1xuICAgICNyZXF1ZXN0O1xuICAgICNlcnJvcjtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXNwb25zZSBzdGF0dXM9JHt0aGlzLnN0YXR1c0NvZGV9IGJvZHk9JHt0aGlzLiNib2R5ID8gaGV4bGlmeSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNDb2RlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzQ29kZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2Ugc3RhdHVzIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c01lc3NhZ2UoKSB7IHJldHVybiB0aGlzLiNzdGF0dXNNZXNzYWdlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBoZWFkZXJzLiBBbGwga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5LCBvciBgYG51bGxgYCBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHkgYXMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZywgb3IgdGhlIGVtcHR5XG4gICAgICogIHN0cmluZyAoaS5lLiBgYFwiXCJgYCkgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICpcbiAgICAgKiAgQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBib2R5IGlzIGludmFsaWQgVVRGLTggZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYm9keVRleHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgPT0gbnVsbCkgPyBcIlwiIDogdG9VdGY4U3RyaW5nKHRoaXMuI2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIFVURi04IGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5VGV4dFwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgZGVjb2RlZCBhcyBKU09OLlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIEpTT04tZW5jb2RlZCBkYXRhXG4gICAgICogIG9yIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqL1xuICAgIGdldCBib2R5SnNvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYm9keVRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIEpTT05cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5SnNvblwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHksIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIHRoaXMuI3N0YXR1c01lc3NhZ2UgPSBzdGF0dXNNZXNzYWdlO1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChhY2N1bSwgaykgPT4ge1xuICAgICAgICAgICAgYWNjdW1bay50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyhoZWFkZXJzW2tdKTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLiNib2R5ID0gKChib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KGJvZHkpKTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IChyZXF1ZXN0IHx8IG51bGwpO1xuICAgICAgICB0aGlzLiNlcnJvciA9IHsgbWVzc2FnZTogXCJcIiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgUmVzcG9uc2Ugd2l0aCBtYXRjaGluZyBoZWFkZXJzIGFuZCBib2R5LCBidXQgd2l0aFxuICAgICAqICBhbiBlcnJvciBzdGF0dXMgY29kZSAoaS5lLiA1OTkpIGFuZCAlJW1lc3NhZ2UlJSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUlZXJyb3IlJS5cbiAgICAgKi9cbiAgICBtYWtlU2VydmVyRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgbGV0IHN0YXR1c01lc3NhZ2U7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YDtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX07ICR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgc3RhdHVzTWVzc2FnZSwgdGhpcy5oZWFkZXJzLCB0aGlzLmJvZHksIHRoaXMuI3JlcXVlc3QgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzcG9uc2UuI2Vycm9yID0geyBtZXNzYWdlLCBlcnJvciB9O1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBjYWxsZWQgd2l0aGluIGEgW3JlcXVlc3QucHJvY2Vzc0Z1bmNdKEZldGNoUmVxdWVzdC1wcm9jZXNzRnVuYylcbiAgICAgKiAgY2FsbCwgY2F1c2VzIHRoZSByZXF1ZXN0IHRvIHJldHJ5IGFzIGlmIHRocm90dGxlZCBmb3IgJSVzdGFsbCUlXG4gICAgICogIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICB0aHJvd1Rocm90dGxlRXJyb3IobWVzc2FnZSwgc3RhbGwpIHtcbiAgICAgICAgaWYgKHN0YWxsID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YWxsID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YWxsKSAmJiBzdGFsbCA+PSAwLCBcImludmFsaWQgc3RhbGwgdGltZW91dFwiLCBcInN0YWxsXCIsIHN0YWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwidGhyb3R0bGluZyByZXF1ZXN0c1wiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzdGFsbCwgdGhyb3R0bGU6IHRydWUgfSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBoZWFkZXIgdmFsdWUgZm9yICUla2V5JSUsIGlnbm9yaW5nIGNhc2UuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVxdWVzdCBtYWRlIGZvciB0aGlzIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkgeyByZXR1cm4gdGhpcy4jcmVxdWVzdDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyByZXNwb25zZSB3YXMgYSBzdWNjZXNzIHN0YXR1c0NvZGUuXG4gICAgICovXG4gICAgb2soKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jZXJyb3IubWVzc2FnZSA9PT0gXCJcIiAmJiB0aGlzLnN0YXR1c0NvZGUgPj0gMjAwICYmIHRoaXMuc3RhdHVzQ29kZSA8IDMwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaHJvd3MgYSBgYFNFUlZFUl9FUlJPUmBgIGlmIHRoaXMgcmVzcG9uc2UgaXMgbm90IG9rLlxuICAgICAqL1xuICAgIGFzc2VydE9rKCkge1xuICAgICAgICBpZiAodGhpcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgbWVzc2FnZSwgZXJyb3IgfSA9IHRoaXMuI2Vycm9yO1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGBzZXJ2ZXIgcmVzcG9uc2UgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RVcmwgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXF1ZXN0VXJsID0gdGhpcy5yZXF1ZXN0LnVybDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2VCb2R5ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VCb2R5ID0gdG9VdGY4U3RyaW5nKHRoaXMuI2JvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBtZXNzYWdlLCBcIlNFUlZFUl9FUlJPUlwiLCB7XG4gICAgICAgICAgICByZXF1ZXN0OiAodGhpcy5yZXF1ZXN0IHx8IFwidW5rbm93biByZXF1ZXN0XCIpLCByZXNwb25zZTogdGhpcywgZXJyb3IsXG4gICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFVybCwgcmVzcG9uc2VCb2R5LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlU3RhdHVzOiBgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmZ1bmN0aW9uIHVucGVyY2VudCh2YWx1ZSkge1xuICAgIHJldHVybiB0b1V0ZjhCeXRlcyh2YWx1ZS5yZXBsYWNlKC8lKFswLTlhLWZdWzAtOWEtZl0pL2dpLCAoYWxsLCBjb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNvZGUsIDE2KSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gd2FpdChkZWxheSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIiwiLyoqXG4gKiAgVGhlICoqRml4ZWROdW1iZXIqKiBjbGFzcyBwZXJtaXRzIHVzaW5nIHZhbHVlcyB3aXRoIGRlY2ltYWwgcGxhY2VzLFxuICogIHVzaW5nIGZpeGVkLXBvbnQgbWF0aC5cbiAqXG4gKiAgRml4ZWQtcG9pbnQgbWF0aCBpcyBzdGlsbCBiYXNlZCBvbiBpbnRlZ2VycyB1bmRlci10aGUtaG9vZCwgYnV0IHVzZXMgYW5cbiAqICBpbnRlcm5hbCBvZmZzZXQgdG8gc3RvcmUgZnJhY3Rpb25hbCBjb21wb25lbnRzIGJlbG93LCBhbmQgZWFjaCBvcGVyYXRpb25cbiAqICBjb3JyZWN0cyBmb3IgdGhpcyBhZnRlciBlYWNoIG9wZXJhdGlvbi5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvdXRpbHMvZml4ZWQtcG9pbnQtbWF0aDpGaXhlZC1Qb2ludCBNYXRocyAgW2Fib3V0LWZpeGVkLXBvaW50LW1hdGhdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgYXNzZXJ0UHJpdmF0ZSB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGZyb21Ud29zLCBtYXNrLCB0b0JpZ0ludCB9IGZyb20gXCIuL21hdGhzLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuY29uc3QgQk5fTjEgPSBCaWdJbnQoLTEpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl81ID0gQmlnSW50KDUpO1xuY29uc3QgX2d1YXJkID0ge307XG4vLyBDb25zdGFudCB0byBwdWxsIHplcm9zIGZyb20gZm9yIG11bHRpcGxpZXJzXG5sZXQgWmVyb3MgPSBcIjAwMDBcIjtcbndoaWxlIChaZXJvcy5sZW5ndGggPCA4MCkge1xuICAgIFplcm9zICs9IFplcm9zO1xufVxuLy8gUmV0dXJucyBhIHN0cmluZyBcIjFcIiBmb2xsb3dlZCBieSBkZWNpbWFsIFwiMFwic1xuZnVuY3Rpb24gZ2V0VGVucyhkZWNpbWFscykge1xuICAgIGxldCByZXN1bHQgPSBaZXJvcztcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGRlY2ltYWxzKSB7XG4gICAgICAgIHJlc3VsdCArPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoXCIxXCIgKyByZXN1bHQuc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSk7XG59XG5mdW5jdGlvbiBjaGVja1ZhbHVlKHZhbCwgZm9ybWF0LCBzYWZlT3ApIHtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChmb3JtYXQud2lkdGgpO1xuICAgIGlmIChmb3JtYXQuc2lnbmVkKSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IHNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbCA+IEJOXzApIHtcbiAgICAgICAgICAgIHZhbCA9IGZyb21Ud29zKG1hc2sodmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IC1mcm9tVHdvcyhtYXNrKC12YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8IHdpZHRoKTtcbiAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gMCAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgICB2YWwgPSAoKCh2YWwgJSBsaW1pdCkgKyBsaW1pdCkgJSBsaW1pdCkgJiAobGltaXQgLSBCTl8xKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGdldEZvcm1hdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YWx1ZSA9IGBmaXhlZDEyOHgke3ZhbHVlfWA7XG4gICAgfVxuICAgIGxldCBzaWduZWQgPSB0cnVlO1xuICAgIGxldCB3aWR0aCA9IDEyODtcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gUGFyc2UgdGhlIGZvcm1hdCBzdHJpbmdcbiAgICAgICAgaWYgKHZhbHVlID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHRzLi4uXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwidWZpeGVkXCIpIHtcbiAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXih1PylmaXhlZChbMC05XSspeChbMC05XSspJC8pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQobWF0Y2gsIFwiaW52YWxpZCBmaXhlZCBmb3JtYXRcIiwgXCJmb3JtYXRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgc2lnbmVkID0gKG1hdGNoWzFdICE9PSBcInVcIik7XG4gICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHZhbHVlcyBmcm9tIHRoZSBvYmplY3RcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlO1xuICAgICAgICBjb25zdCBjaGVjayA9IChrZXksIHR5cGUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodltrZXldKSA9PT0gdHlwZSwgXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCAoXCIgKyBrZXkgKyBcIiBub3QgXCIgKyB0eXBlICsgXCIpXCIsIFwiZm9ybWF0LlwiICsga2V5LCB2W2tleV0pO1xuICAgICAgICAgICAgcmV0dXJuIHZba2V5XTtcbiAgICAgICAgfTtcbiAgICAgICAgc2lnbmVkID0gY2hlY2soXCJzaWduZWRcIiwgXCJib29sZWFuXCIsIHNpZ25lZCk7XG4gICAgICAgIHdpZHRoID0gY2hlY2soXCJ3aWR0aFwiLCBcIm51bWJlclwiLCB3aWR0aCk7XG4gICAgICAgIGRlY2ltYWxzID0gY2hlY2soXCJkZWNpbWFsc1wiLCBcIm51bWJlclwiLCBkZWNpbWFscyk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KCh3aWR0aCAlIDgpID09PSAwLCBcImludmFsaWQgRml4ZWROdW1iZXIgd2lkdGggKG5vdCBieXRlIGFsaWduZWQpXCIsIFwiZm9ybWF0LndpZHRoXCIsIHdpZHRoKTtcbiAgICBhc3NlcnRBcmd1bWVudChkZWNpbWFscyA8PSA4MCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIGRlY2ltYWxzICh0b28gbGFyZ2UpXCIsIFwiZm9ybWF0LmRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcbiAgICBjb25zdCBuYW1lID0gKHNpZ25lZCA/IFwiXCIgOiBcInVcIikgKyBcImZpeGVkXCIgKyBTdHJpbmcod2lkdGgpICsgXCJ4XCIgKyBTdHJpbmcoZGVjaW1hbHMpO1xuICAgIHJldHVybiB7IHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzLCBuYW1lIH07XG59XG5mdW5jdGlvbiB0b1N0cmluZyh2YWwsIGRlY2ltYWxzKSB7XG4gICAgbGV0IG5lZ2F0aXZlID0gXCJcIjtcbiAgICBpZiAodmFsIDwgQk5fMCkge1xuICAgICAgICBuZWdhdGl2ZSA9IFwiLVwiO1xuICAgICAgICB2YWwgKj0gQk5fTjE7XG4gICAgfVxuICAgIGxldCBzdHIgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAvLyBObyBkZWNpbWFsIHBvaW50IGZvciB3aG9sZSB2YWx1ZXNcbiAgICBpZiAoZGVjaW1hbHMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XG4gICAgfVxuICAgIC8vIFBhZCBvdXQgdG8gdGhlIHdob2xlIGNvbXBvbmVudCAoaW5jbHVkaW5nIGEgd2hvbGUgZGlnaXQpXG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPD0gZGVjaW1hbHMpIHtcbiAgICAgICAgc3RyID0gWmVyb3MgKyBzdHI7XG4gICAgfVxuICAgIC8vIEluc2VydCB0aGUgZGVjaW1hbCBwb2ludFxuICAgIGNvbnN0IGluZGV4ID0gc3RyLmxlbmd0aCAtIGRlY2ltYWxzO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpICsgXCIuXCIgKyBzdHIuc3Vic3RyaW5nKGluZGV4KTtcbiAgICAvLyBUcmltIHRoZSB3aG9sZSBjb21wb25lbnQgKGxlYXZpbmcgYXQgbGVhc3Qgb25lIDApXG4gICAgd2hpbGUgKHN0clswXSA9PT0gXCIwXCIgJiYgc3RyWzFdICE9PSBcIi5cIikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICAvLyBUcmltIHRoZSBkZWNpbWFsIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcbiAgICB3aGlsZSAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gXCIwXCIgJiYgc3RyW3N0ci5sZW5ndGggLSAyXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiAobmVnYXRpdmUgKyBzdHIpO1xufVxuLyoqXG4gKiAgQSBGaXhlZE51bWJlciByZXByZXNlbnRzIGEgdmFsdWUgb3ZlciBpdHMgW1tGaXhlZEZvcm1hdF1dXG4gKiAgYXJpdGhtZXRpYyBmaWVsZC5cbiAqXG4gKiAgQSBGaXhlZE51bWJlciBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIG1hdGgsIGxvc3NsZXNzbHksIG9uXG4gKiAgdmFsdWVzIHdoaWNoIGhhdmUgZGVjbWlhbCBwbGFjZXMuXG4gKlxuICogIEEgRml4ZWROdW1iZXIgaGFzIGEgZml4ZWQgYml0LXdpZHRoIHRvIHN0b3JlIHZhbHVlcyBpbiwgYW5kIHN0b3JlcyBhbGxcbiAqICB2YWx1ZXMgaW50ZXJuYWxseSBieSBtdWx0aXBseWluZyB0aGUgdmFsdWUgYnkgMTAgcmFpc2VkIHRvIHRoZSBwb3dlciBvZlxuICogICUlZGVjaW1hbHMlJS5cbiAqXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBncm93IHRvbyBoaWdoIChjbG9zZSB0b1xuICogIHBvc2l0aXZlIGluZmluaXR5KSBvciB0b28gbG93IChjbG9zZSB0byBuZWdhdGl2ZSBpbmZpbml0eSksIHRoZSB2YWx1ZVxuICogIGlzIHNhaWQgdG8gLy9vdmVyZmxvdy8vLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgYW4gOC1iaXQgc2lnbmVkIHZhbHVlLCB3aXRoIDAgZGVjaW1hbHMgbWF5IG9ubHkgYmUgd2l0aGluXG4gKiAgdGhlIHJhbmdlIGBgLTEyOGBgIHRvIGBgMTI3YGA7IHNvIGBgLTEyOCAtIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWVcbiAqICBgYDEyN2BgLiBMaWtld2lzZSwgYGAxMjcgKyAxYGAgd2lsbCBvdmVyZmxvdyBhbmQgYmVjb21lIGBgLTEyN2BgLlxuICpcbiAqICBNYW55IG9wZXJhdGlvbiBoYXZlIGEgbm9ybWFsIGFuZCAvL3Vuc2FmZS8vIHZhcmlhbnQuIFRoZSBub3JtYWwgdmFyaWFudFxuICogIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gYW55IG92ZXJmbG93LCB3aGlsZSB0aGUgLy91bnNhZmUvL1xuICogIHZhcmlhbnQgd2lsbCBzaWxlbnRseSBhbGxvdyBvdmVyZmxvdywgY29ycnVwdGluZyBpdHMgdmFsdWUgdmFsdWUuXG4gKlxuICogIElmIG9wZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCB0aGF0IGNhdXNlIGEgdmFsdWUgdG8gYmVjb21lIHRvbyBzbWFsbFxuICogIChjbG9zZSB0byB6ZXJvKSwgdGhlIHZhbHVlIGxvc2VzIHByZWNpc29uIGFuZCBpcyBzYWlkIHRvIC8vdW5kZXJmbG93Ly8uXG4gKlxuICogIEZvciBleGFtcGxlLCBhIHZhbHVlIHdpdGggMSBkZWNpbWFsIHBsYWNlIG1heSBzdG9yZSBhIG51bWJlciBhcyBzbWFsbFxuICogIGFzIGBgMC4xYGAsIGJ1dCB0aGUgdmFsdWUgb2YgYGAwLjEgLyAyYGAgaXMgYGAwLjA1YGAsIHdoaWNoIGNhbm5vdCBmaXRcbiAqICBpbnRvIDEgZGVjaW1hbCBwbGFjZSwgc28gdW5kZXJmbG93IG9jY3VycyB3aGljaCBtZWFucyBwcmVjaXNpb24gaXMgbG9zdFxuICogIGFuZCB0aGUgdmFsdWUgYmVjb21lcyBgYDBgYC5cbiAqXG4gKiAgU29tZSBvcGVyYXRpb25zIGhhdmUgYSBub3JtYWwgYW5kIC8vc2lnbmFsbGluZy8vIHZhcmlhbnQuIFRoZSBub3JtYWxcbiAqICB2YXJpYW50IHdpbGwgc2lsZW50bHkgaWdub3JlIHVuZGVyZmxvdywgd2hpbGUgdGhlIC8vc2lnbmFsbGluZy8vIHZhcmlhbnRcbiAqICB3aWxsIHRob3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gdW5kZXJmbG93LlxuICovXG5leHBvcnQgY2xhc3MgRml4ZWROdW1iZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc3BlY2lmaWMgZml4ZWQtcG9pbnQgYXJpdGhtZXRpYyBmaWVsZCBmb3IgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBmb3JtYXQ7XG4gICAgI2Zvcm1hdDtcbiAgICAvLyBUaGUgYWN0dWFsIHZhbHVlIChhY2NvdW50aW5nIGZvciBkZWNpbWFscylcbiAgICAjdmFsO1xuICAgIC8vIEEgYmFzZS0xMCB2YWx1ZSB0byBtdWx0aXBsZSB2YWx1ZXMgYnkgdG8gbWFpbnRhaW4gdGhlIG1hZ25pdHVkZVxuICAgICN0ZW5zO1xuICAgIC8qKlxuICAgICAqICBUaGlzIGlzIGEgcHJvcGVydHkgc28gY29uc29sZS5sb2cgc2hvd3MgYSBodW1hbi1tZWFuaW5nZnVsIHZhbHVlLlxuICAgICAqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgX3ZhbHVlO1xuICAgIC8vIFVzZSB0aGlzIHdoZW4gY2hhbmdpbmcgdGhpcyBmaWxlIHRvIGdldCBzb21lIHR5cGluZyBpbmZvLFxuICAgIC8vIGJ1dCB0aGVuIHN3aXRjaCB0byBhbnkgdG8gbWFzayB0aGUgaW50ZXJuYWwgdHlwZVxuICAgIC8vY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgdmFsdWU6IGJpZ2ludCwgZm9ybWF0OiBfRml4ZWRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRml4ZWROdW1iZXJcIik7XG4gICAgICAgIHRoaXMuI3ZhbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLiNmb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIGNvbnN0IF92YWx1ZSA9IHRvU3RyaW5nKHZhbHVlLCBmb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZm9ybWF0OiBmb3JtYXQubmFtZSwgX3ZhbHVlIH0pO1xuICAgICAgICB0aGlzLiN0ZW5zID0gZ2V0VGVucyhmb3JtYXQuZGVjaW1hbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdHJ1ZSwgbmVnYXRpdmUgdmFsdWVzIGFyZSBwZXJtaXR0ZWQsIG90aGVyd2lzZSBvbmx5XG4gICAgICogIHBvc2l0aXZlIHZhbHVlcyBhbmQgemVybyBhcmUgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmVkKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LnNpZ25lZDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGJpdHMgYXZhaWxhYmxlIHRvIHN0b3JlIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQud2lkdGg7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpbiB0aGUgZml4ZWQtcG9pbnQgYXJpdGhtZW50IGZpZWxkLlxuICAgICAqL1xuICAgIGdldCBkZWNpbWFscygpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC5kZWNpbWFsczsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUgYXMgYW4gaW50ZWdlciwgYmFzZWQgb24gdGhlIHNtYWxsZXN0IHVuaXQgdGhlXG4gICAgICogIFtbZGVjaW1hbHNdXSBhbGxvdy5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLiN2YWw7IH1cbiAgICAjY2hlY2tGb3JtYXQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodGhpcy5mb3JtYXQgPT09IG90aGVyLmZvcm1hdCwgXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG4gICAgfVxuICAgICNjaGVja1ZhbHVlKHZhbCwgc2FmZU9wKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBCaWdJbnQodGhpcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmcm9tVHdvcyhtYXNrKHZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAtZnJvbVR3b3MobWFzaygtdmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrZWQgPSBtYXNrKHZhbCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA9PT0gbWFza2VkKSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbWFza2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsID0gY2hlY2tWYWx1ZSh2YWwsIHRoaXMuI2Zvcm1hdCwgc2FmZU9wKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbCwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgI2FkZChvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHRoaXMuI3ZhbCArIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBhZGRlZFxuICAgICAqICB0byAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93LlxuICAgICAqL1xuICAgIGFkZFVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgYWRkZWRcbiAgICAgKiAgdG8gJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIGFkZChvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyLCBcImFkZFwiKTsgfVxuICAgICNzdWIobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh0aGlzLiN2YWwgLSBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSVvdGhlciUlIHN1YnRyYWN0ZWRcbiAgICAgKiAgZnJvbSAlJXRoaXMlJSwgaWdub3Jpbmcgb3ZlcmZsb3cuXG4gICAgICovXG4gICAgc3ViVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNzdWIob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxuICAgICAqICBmcm9tICUldGhpcyUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIHN1YihvdGhlcikgeyByZXR1cm4gdGhpcy4jc3ViKG90aGVyLCBcInN1YlwiKTsgfVxuICAgICNtdWwobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSgodGhpcy4jdmFsICogby4jdmFsKSAvIHRoaXMuI3RlbnMsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93IGFuZCB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBtdWxVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI211bChvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bChvdGhlcikgeyByZXR1cm4gdGhpcy4jbXVsKG90aGVyLCBcIm11bFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMgb3IgaWYgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bFNpZ25hbChvdGhlcikge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmFsICogb3RoZXIuI3ZhbDtcbiAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIHRoaXMuI3RlbnMpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIG11bFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm11bFNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gdGhpcy4jdGVucywgXCJtdWxTaWduYWxcIik7XG4gICAgfVxuICAgICNkaXYobywgc2FmZU9wKSB7XG4gICAgICAgIGFzc2VydChvLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKCh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKSAvIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcbiAgICAgKiAgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvdyBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2VW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcbiAgICAgKiAgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvdyBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2KG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIsIFwiZGl2XCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIHVuZGVyZmxvd1xuICAgICAqICAocHJlY2lzaW9uIGxvc3MpIG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXZTaWduYWwob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KG90aGVyLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKTtcbiAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIG90aGVyLiN2YWwpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIGRpdlwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gb3RoZXIuI3ZhbCwgXCJkaXZTaWduYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgY29tcGFyaXNvbiByZXN1bHQgYmV0d2VlbiAlJXRoaXMlJSBhbmQgJSVvdGhlciUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgc3VpdGFibGUgZm9yIHVzZSBpbiBzb3J0aW5nLCB3aGVyZSBgYC0xYGAgaW1wbGllcyAlJXRoaXMlJVxuICAgICAqICBpcyBzbWFsbGVyLCBgYDFgYCBpbXBsaWVzICUldGhpcyUlIGlzIGxhcmdlciBhbmQgYGAwYGAgaW1wbGllc1xuICAgICAqICBib3RoIGFyZSBlcXVhbC5cbiAgICAgKi9cbiAgICBjbXAob3RoZXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLnZhbHVlLCBiID0gb3RoZXIudmFsdWU7XG4gICAgICAgIC8vIENvZXJjZSBhIGFuZCBiIHRvIHRoZSBzYW1lIG1hZ25pdHVkZVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBvdGhlci5kZWNpbWFscztcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgYiAqPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIGEgKj0gZ2V0VGVucygtZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbW5wYXJlXG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPT09IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHQob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHRlKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPD0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndChvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID4gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA+PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBsYXJnZXN0ICoqaW50ZWdlcioqXG4gICAgICogIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxuICAgICAqL1xuICAgIGZsb29yKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsIDwgQk5fMCkge1xuICAgICAgICAgICAgdmFsIC09IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJmbG9vclwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBzbWFsbGVzdCAqKmludGVnZXIqKlxuICAgICAqICB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVjaW1hbCBjb21wb25lbnQgb2YgdGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBgYDBgYC5cbiAgICAgKi9cbiAgICBjZWlsaW5nKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsID4gQk5fMCkge1xuICAgICAgICAgICAgdmFsICs9IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJjZWlsaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgZGVjaW1hbCBjb21wb25lbnRcbiAgICAgKiAgcm91bmRlZCB1cCBvbiB0aWVzIGF0ICUlZGVjaW1hbHMlJSBwbGFjZXMuXG4gICAgICovXG4gICAgcm91bmQoZGVjaW1hbHMpIHtcbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgZW5vdWdoIHByZWNpc2lvbiB0byBub3QgYWxyZWFkeSBiZSByb3VuZGVkXG4gICAgICAgIGlmIChkZWNpbWFscyA+PSB0aGlzLmRlY2ltYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBkZWNpbWFscztcbiAgICAgICAgY29uc3QgYnVtcCA9IEJOXzUgKiBnZXRUZW5zKGRlbHRhIC0gMSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWUgKyBidW1wO1xuICAgICAgICBjb25zdCB0ZW5zID0gZ2V0VGVucyhkZWx0YSk7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIC8gdGVucykgKiB0ZW5zO1xuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCB0aGlzLiNmb3JtYXQsIFwicm91bmRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBlcXVhbCB0byBgYDBgYC5cbiAgICAgKi9cbiAgICBpc1plcm8oKSB7IHJldHVybiAodGhpcy4jdmFsID09PSBCTl8wKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgbGVzcyB0aGFuIGBgMGBgLlxuICAgICAqL1xuICAgIGlzTmVnYXRpdmUoKSB7IHJldHVybiAodGhpcy4jdmFsIDwgQk5fMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mICUldGhpcyUlLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZsb2F0IGFwcHJveGltYXRpb24uXG4gICAgICpcbiAgICAgKiAgRHVlIHRvIElFRUUgNzU0IHByZWNpc3Npb24gKG9yIGxhY2sgdGhlcmVvZiksIHRoaXMgZnVuY3Rpb25cbiAgICAgKiAgY2FuIG9ubHkgcmV0dXJuIGFuIGFwcHJveGltYXRpb24gYW5kIG1vc3QgdmFsdWVzIHdpbGwgY29udGFpblxuICAgICAqICByb3VuZGluZyBlcnJvcnMuXG4gICAgICovXG4gICAgdG9VbnNhZmVGbG9hdCgpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy50b1N0cmluZygpKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHNhbWUgdmFsdWUgYnV0IGhhcyBoYWRcbiAgICAgKiAgaXRzIGZpZWxkIHNldCB0byAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGUgdmFsdWUgY2Fubm90IGZpdCBpbnRvICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgdG9Gb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHRoaXMudG9TdHJpbmcoKSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIGZvciAlJXZhbHVlJSUgZGl2aWRlZCBieVxuICAgICAqICAlJWRlY2ltYWwlJSBwbGFjZXMgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgKG9uY2UgYWRqdXN0ZWRcbiAgICAgKiAgZm9yICUlZGVjaW1hbHMlJSkgY2Fubm90IGZpdCBpbiAlJWZvcm1hdCUlLCBlaXRoZXIgZHVlIHRvIG92ZXJmbG93XG4gICAgICogIG9yIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVmFsdWUoX3ZhbHVlLCBfZGVjaW1hbHMsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSAoX2RlY2ltYWxzID09IG51bGwpID8gMCA6IGdldE51bWJlcihfZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZGVjaW1hbHMgLSBmb3JtYXQuZGVjaW1hbHM7XG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbnMgPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgICAgIGFzc2VydCgodmFsdWUgJSB0ZW5zKSA9PT0gQk5fMCwgXCJ2YWx1ZSBsb3NlcyBwcmVjaXNpb24gZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVmFsdWVcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWUgLz0gdGVucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlICo9IGdldFRlbnMoLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbVZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSBmb3IgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSwgZWl0aGVyIGR1ZSB0byBvdmVyZmxvdyBvciB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhfdmFsdWUsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBfdmFsdWUubWF0Y2goL14oLT8pKFswLTldKilcXC4/KFswLTldKikkLyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoICYmIChtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGgpID4gMCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHN0cmluZyB2YWx1ZVwiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgbGV0IHdob2xlID0gKG1hdGNoWzJdIHx8IFwiMFwiKSwgZGVjaW1hbCA9IChtYXRjaFszXSB8fCBcIlwiKTtcbiAgICAgICAgLy8gUGFkIG91dCB0aGUgZGVjaW1hbHNcbiAgICAgICAgd2hpbGUgKGRlY2ltYWwubGVuZ3RoIDwgZm9ybWF0LmRlY2ltYWxzKSB7XG4gICAgICAgICAgICBkZWNpbWFsICs9IFplcm9zO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHByZWNpc2lvbiBpcyBzYWZlXG4gICAgICAgIGFzc2VydChkZWNpbWFsLnN1YnN0cmluZyhmb3JtYXQuZGVjaW1hbHMpLm1hdGNoKC9eMCokLyksIFwidG9vIG1hbnkgZGVjaW1hbHMgZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyb21TdHJpbmdcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlbW92ZSBleHRyYSBwYWRkaW5nXG4gICAgICAgIGRlY2ltYWwgPSBkZWNpbWFsLnN1YnN0cmluZygwLCBmb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChtYXRjaFsxXSArIHdob2xlICsgZGVjaW1hbCk7XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tU3RyaW5nXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBiaWctZW5kaWFuIHJlcHJlc2VudGF0aW9uXG4gICAgICogICUldmFsdWUlJSB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSBjYW5ub3QgZml0XG4gICAgICogIGluICUlZm9ybWF0JSUgZHVlIHRvIG92ZXJmbG93LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXMoX3ZhbHVlLCBfZm9ybWF0KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRvQmlnSW50KGdldEJ5dGVzKF92YWx1ZSwgXCJ2YWx1ZVwiKSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbVR3b3ModmFsdWUsIGZvcm1hdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21CeXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbn1cbi8vY29uc3QgZjEgPSBGaXhlZE51bWJlci5mcm9tU3RyaW5nKFwiMTIuNTZcIiwgXCJmaXhlZDE2eDJcIik7XG4vL2NvbnN0IGYyID0gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhcIjAuM1wiLCBcImZpeGVkMTZ4MlwiKTtcbi8vY29uc29sZS5sb2coZjEuZGl2U2lnbmFsKGYyKSk7XG4vL2NvbnN0IEJVTVAgPSBGaXhlZE51bWJlci5mcm9tKFwiMC41XCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWRudW1iZXIuanMubWFwIiwiLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5mdW5jdGlvbiBoZXhsaWZ5Qnl0ZSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIGNoaWxkT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoY2hpbGRPZmZzZXQgPCBvZmZzZXQgKyAxICsgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGRhdGEsIGNoaWxkT2Zmc2V0KTtcbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xuICAgICAgICBjaGlsZE9mZnNldCArPSBkZWNvZGVkLmNvbnN1bWVkO1xuICAgICAgICBhc3NlcnQoY2hpbGRPZmZzZXQgPD0gb2Zmc2V0ICsgMSArIGxlbmd0aCwgXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBhc3NlcnQoZGF0YS5sZW5ndGggIT09IDAsIFwiZGF0YSB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoOiAwLCBvZmZzZXQ6IDFcbiAgICB9KTtcbiAgICBjb25zdCBjaGVja09mZnNldCA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgYXNzZXJ0KG9mZnNldCA8PSBkYXRhLmxlbmd0aCwgXCJkYXRhIHNob3J0IHNlZ21lbnQgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IGRhdGEubGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBBcnJheSB3aXRoIGV4dHJhIGxlbmd0aCBwcmVmaXhcbiAgICBpZiAoZGF0YVtvZmZzZXRdID49IDB4ZjgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhmNztcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhiOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGI3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBoZXhsaWZ5KGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMSArIGxlbmd0aCkpO1xuICAgICAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGgpLCByZXN1bHQ6IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjb25zdW1lZDogMSwgcmVzdWx0OiBoZXhsaWZ5Qnl0ZShkYXRhW29mZnNldF0pIH07XG59XG4vKipcbiAqICBEZWNvZGVzICUlZGF0YSUlIGludG8gdGhlIHN0cnVjdHVyZWQgZGF0YSBpdCByZXByZXNlbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmxwKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgMCk7XG4gICAgYXNzZXJ0QXJndW1lbnQoZGVjb2RlZC5jb25zdW1lZCA9PT0gZGF0YS5sZW5ndGgsIFwidW5leHBlY3RlZCBqdW5rIGFmdGVyIHJscCBwYXlsb2FkXCIsIFwiZGF0YVwiLCBfZGF0YSk7XG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmxwLWRlY29kZS5qcy5tYXAiLCIvL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgIHZhbHVlID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGxldCBwYXlsb2FkID0gW107XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgcGF5bG9hZC51bnNoaWZ0KDB4YzAgKyBwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIocGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICBsZW5ndGgudW5zaGlmdCgweGY3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ2V0Qnl0ZXMob2JqZWN0LCBcIm9iamVjdFwiKSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0gPD0gMHg3Zikge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgZGF0YS51bnNoaWZ0KDB4ODAgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIoZGF0YS5sZW5ndGgpO1xuICAgIGxlbmd0aC51bnNoaWZ0KDB4YjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChkYXRhKTtcbn1cbmNvbnN0IG5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIEVuY29kZXMgJSVvYmplY3QlJSBhcyBhbiBSTFAtZW5jb2RlZCBbW0RhdGFIZXhTdHJpbmddXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJscChvYmplY3QpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGZvciAoY29uc3QgdiBvZiBfZW5jb2RlKG9iamVjdCkpIHtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiA+PiA0XTtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiAmIDB4Zl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZW5jb2RlLmpzLm1hcCIsIi8qKlxuICogIE1vc3QgaW50ZXJhY3Rpb25zIHdpdGggRXRoZXJldW0gcmVxdWlyZXMgaW50ZWdlciB2YWx1ZXMsIHdoaWNoIHVzZVxuICogIHRoZSBzbWFsbGVzdCBtYWduaXR1ZGUgdW5pdC5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgZGVhbGluZyB3aXRoIGRvbGxhcnMgYW5kIGNlbnRzLiBTaW5jZSBkb2xsYXJzXG4gKiAgYXJlIGRpdmlzaWJsZSwgbm9uLWludGVnZXIgdmFsdWVzIGFyZSBwb3NzaWJsZSwgc3VjaCBhcyBgYCQxMC43N2BgLlxuICogIEJ5IHVzaW5nIHRoZSBzbWFsbGVzdCBpbmRpdmlzaWJsZSB1bml0IChpLmUuIGNlbnRzKSwgdGhlIHZhbHVlIGNhblxuICogIGJlIGtlcHQgYXMgdGhlIGludGVnZXIgYGAxMDc3YGAuXG4gKlxuICogIFdoZW4gcmVjZWl2aW5nIGRlY2ltYWwgaW5wdXQgZnJvbSB0aGUgdXNlciAoYXMgYSBkZWNpbWFsIHN0cmluZyksXG4gKiAgdGhlIHZhbHVlIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBhbmQgd2hlbiBzaG93aW5nIGEgdXNlclxuICogIGEgdmFsdWUsIHRoZSBpbnRlZ2VyIHZhbHVlIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiAgVGhpcyBjcmVhdGVzIGEgY2xlYXIgZGlzdGluY3Rpb24sIGJldHdlZW4gdmFsdWVzIHRvIGJlIHVzZWQgYnkgY29kZVxuICogIChpbnRlZ2VycykgYW5kIHZhbHVlcyB1c2VkIGZvciBkaXNwbGF5IGxvZ2ljIHRvIHVzZXJzIChkZWNpbWFscykuXG4gKlxuICogIFRoZSBuYXRpdmUgdW5pdCBpbiBFdGhlcmV1bSwgLy9ldGhlci8vIGlzIGRpdmlzaWJsZSB0byAxOCBkZWNpbWFsIHBsYWNlcyxcbiAqICB3aGVyZSBlYWNoIGluZGl2aWR1YWwgdW5pdCBpcyBjYWxsZWQgYSAvL3dlaS8vLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlVuaXQgQ29udmVyc2lvbiAgW2Fib3V0LXVuaXRzXVxuICovXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgRml4ZWROdW1iZXIgfSBmcm9tIFwiLi9maXhlZG51bWJlci5qc1wiO1xuaW1wb3J0IHsgZ2V0TnVtYmVyIH0gZnJvbSBcIi4vbWF0aHMuanNcIjtcbmNvbnN0IG5hbWVzID0gW1xuICAgIFwid2VpXCIsXG4gICAgXCJrd2VpXCIsXG4gICAgXCJtd2VpXCIsXG4gICAgXCJnd2VpXCIsXG4gICAgXCJzemFib1wiLFxuICAgIFwiZmlubmV5XCIsXG4gICAgXCJldGhlclwiLFxuXTtcbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSBpbnRvIGEgLy9kZWNpbWFsIHN0cmluZy8vLCBhc3N1bWluZyAlJXVuaXQlJSBkZWNpbWFsXG4gKiAgcGxhY2VzLiBUaGUgJSV1bml0JSUgbWF5IGJlIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb3IgdGhlIG5hbWUgb2ZcbiAqICBhIHVuaXQgKGUuZy4gYGBcImd3ZWlcImBgIGZvciA5IGRlY2ltYWwgcGxhY2VzKS5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVbml0cyh2YWx1ZSwgdW5pdCkge1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHVuaXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xuICAgICAgICBkZWNpbWFscyA9IDMgKiBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gZ2V0TnVtYmVyKHVuaXQsIFwidW5pdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwgZGVjaW1hbHMsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSV2YWx1ZSUlIHRvIGEgQmlnSW50LCBhc3N1bWluZ1xuICogICUldW5pdCUlIGRlY2ltYWwgcGxhY2VzLiBUaGUgJSV1bml0JSUgbWF5IHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAqICBvciB0aGUgbmFtZSBvZiBhIHVuaXQgKGUuZy4gYGBcImd3ZWlcImBgIGZvciA5IGRlY2ltYWwgcGxhY2VzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVW5pdHModmFsdWUsIHVuaXQpIHtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHVuaXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xuICAgICAgICBkZWNpbWFscyA9IDMgKiBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gZ2V0TnVtYmVyKHVuaXQsIFwidW5pdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodmFsdWUsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudmFsdWU7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgaW50byBhIC8vZGVjaW1hbCBzdHJpbmcvLyB1c2luZyAxOCBkZWNpbWFsIHBsYWNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSkge1xuICAgIHJldHVybiBmb3JtYXRVbml0cyh3ZWksIDE4KTtcbn1cbi8qKlxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSVldGhlciUlIHRvIGEgQmlnSW50LCB1c2luZyAxOFxuICogIGRlY2ltYWwgcGxhY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdGhlcihldGhlcikge1xuICAgIHJldHVybiBwYXJzZVVuaXRzKGV0aGVyLCAxOCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bml0cy5qcy5tYXAiLCIvKipcbiAqICBFeHBsYWluIFVVSUQgYW5kIGxpbmsgdG8gUkZDIGhlcmUuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOlVVSUQgIFthYm91dC11dWlkXVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuL2RhdGEuanNcIjtcbi8qKlxuICogIFJldHVybnMgdGhlIHZlcnNpb24gNCBbW2xpbmstdXVpZF1dIGZvciB0aGUgJSVyYW5kb21CeXRlcyUlLlxuICpcbiAqICBAc2VlOiBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHQgKFNlY3Rpb24gNC40KVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXVpZFY0KHJhbmRvbUJ5dGVzKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhyYW5kb21CeXRlcywgXCJyYW5kb21CeXRlc1wiKTtcbiAgICAvLyBTZWN0aW9uOiA0LjEuMzpcbiAgICAvLyAtIHRpbWVfaGlfYW5kX3ZlcnNpb25bMTI6MTZdID0gMGIwMTAwXG4gICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgLy8gU2VjdGlvbiA0LjRcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbNl0gPSAwYjBcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbN10gPSAwYjFcbiAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICBjb25zdCB2YWx1ZSA9IGhleGxpZnkoYnl0ZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygyLCAxMCksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygxMCwgMTQpLFxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTQsIDE4KSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDE4LCAyMiksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygyMiwgMzQpLFxuICAgIF0uam9pbihcIi1cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dWlkLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGNvbmNhdCwgZ2V0Qnl0ZXNDb3B5LCBnZXROdW1iZXIsIGhleGxpZnksIHRvQmVBcnJheSwgdG9CaWdJbnQsIHRvTnVtYmVyLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50XG4vKiwgaXNFcnJvciovXG4gfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbi8qKlxuICogQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBjb25zdCBXb3JkU2l6ZSA9IDMyO1xuY29uc3QgUGFkZGluZyA9IG5ldyBVaW50OEFycmF5KFdvcmRTaXplKTtcbi8vIFByb3BlcnRpZXMgdXNlZCB0byBpbW1lZGlhdGUgcGFzcyB0aHJvdWdoIHRvIHRoZSB1bmRlcmx5aW5nIG9iamVjdFxuLy8gLSBgdGhlbmAgaXMgdXNlZCB0byBkZXRlY3QgaWYgYW4gb2JqZWN0IGlzIGEgUHJvbWlzZSBmb3IgYXdhaXRcbmNvbnN0IHBhc3NQcm9wZXJ0aWVzID0gW1widGhlblwiXTtcbmNvbnN0IF9ndWFyZCA9IHt9O1xuY29uc3QgcmVzdWx0TmFtZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0TmFtZXMocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdE5hbWVzLmdldChyZXN1bHQpO1xufVxuZnVuY3Rpb24gc2V0TmFtZXMocmVzdWx0LCBuYW1lcykge1xuICAgIHJlc3VsdE5hbWVzLnNldChyZXN1bHQsIG5hbWVzKTtcbn1cbmZ1bmN0aW9uIHRocm93RXJyb3IobmFtZSwgZXJyb3IpIHtcbiAgICBjb25zdCB3cmFwcGVkID0gbmV3IEVycm9yKGBkZWZlcnJlZCBlcnJvciBkdXJpbmcgQUJJIGRlY29kaW5nIHRyaWdnZXJlZCBhY2Nlc3NpbmcgJHtuYW1lfWApO1xuICAgIHdyYXBwZWQuZXJyb3IgPSBlcnJvcjtcbiAgICB0aHJvdyB3cmFwcGVkO1xufVxuZnVuY3Rpb24gdG9PYmplY3QobmFtZXMsIGl0ZW1zLCBkZWVwKSB7XG4gICAgaWYgKG5hbWVzLmluZGV4T2YobnVsbCkgPj0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9PYmplY3QoZ2V0TmFtZXMoaXRlbSksIGl0ZW0sIGRlZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMucmVkdWNlKChhY2N1bSwgbmFtZSwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IGl0ZW0gPSBpdGVtcy5nZXRWYWx1ZShuYW1lKTtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBhY2N1bSkpIHtcbiAgICAgICAgICAgIGlmIChkZWVwICYmIGl0ZW0gaW5zdGFuY2VvZiBSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdG9PYmplY3QoZ2V0TmFtZXMoaXRlbSksIGl0ZW0sIGRlZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqICBBIFtbUmVzdWx0XV0gaXMgYSBzdWItY2xhc3Mgb2YgQXJyYXksIHdoaWNoIGFsbG93cyBhY2Nlc3NpbmcgYW55XG4gKiAgb2YgaXRzIHZhbHVlcyBlaXRoZXIgcG9zaXRpb25hbGx5IGJ5IGl0cyBpbmRleCBvciwgaWYga2V5cyBhcmVcbiAqICBwcm92aWRlZCBieSBpdHMgbmFtZS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9hYmlcbiAqL1xuZXhwb3J0IGNsYXNzIFJlc3VsdCBleHRlbmRzIEFycmF5IHtcbiAgICAvLyBObyBsb25nZXIgdXNlZDsgYnV0IGNhbm5vdCBiZSByZW1vdmVkIGFzIGl0IHdpbGwgcmVtb3ZlIHRoZVxuICAgIC8vICNwcml2YXRlIGZpZWxkIGZyb20gdGhlIC5kLnRzIHdoaWNoIG1heSBicmVhayBiYWNrd2FyZHNcbiAgICAvLyBjb21wYXRpYmlsaXR5XG4gICAgI25hbWVzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVG8gcHJvcGVybHkgc3ViLWNsYXNzIEFycmF5IHNvIHRoZSBvdGhlciBidWlsdC1pblxuICAgICAgICAvLyBmdW5jdGlvbnMgd29yaywgdGhlIGNvbnN0cnVjdG9yIGhhcyB0byBiZWhhdmUgZmFpcmx5XG4gICAgICAgIC8vIHdlbGwuIFNvLCBpbiB0aGUgZXZlbnQgd2UgYXJlIGNyZWF0ZWQgdmlhIGZyb21JdGVtcygpXG4gICAgICAgIC8vIHdlIGJ1aWxkIHRoZSByZWFkLW9ubHkgUmVzdWx0IG9iamVjdCB3ZSB3YW50LCBidXQgb25cbiAgICAgICAgLy8gYW55IG90aGVyIGlucHV0LCB3ZSB1c2UgdGhlIGRlZmF1bHQgY29uc3RydWN0b3JcbiAgICAgICAgLy8gY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgaXRlbXM6IEFycmF5PGFueT4sIGtleXM/OiBBcnJheTxudWxsIHwgc3RyaW5nPik7XG4gICAgICAgIGNvbnN0IGd1YXJkID0gYXJnc1swXTtcbiAgICAgICAgbGV0IGl0ZW1zID0gYXJnc1sxXTtcbiAgICAgICAgbGV0IG5hbWVzID0gKGFyZ3NbMl0gfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGxldCB3cmFwID0gdHJ1ZTtcbiAgICAgICAgaWYgKGd1YXJkICE9PSBfZ3VhcmQpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gYXJncztcbiAgICAgICAgICAgIG5hbWVzID0gW107XG4gICAgICAgICAgICB3cmFwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuJ3QganVzdCBwYXNzIGluIC4uLml0ZW1zIHNpbmNlIGFuIGFycmF5IG9mIGxlbmd0aCAxXG4gICAgICAgIC8vIGlzIGEgc3BlY2lhbCBjYXNlIGluIHRoZSBzdXBlci5cbiAgICAgICAgc3VwZXIoaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHsgdGhpc1tpbmRleF0gPSBpdGVtOyB9KTtcbiAgICAgICAgLy8gRmluZCBhbGwgdW5pcXVlIGtleXNcbiAgICAgICAgY29uc3QgbmFtZUNvdW50cyA9IG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYWNjdW0uc2V0KG5hbWUsIChhY2N1bS5nZXQobmFtZSkgfHwgMCkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwgKG5ldyBNYXAoKSkpO1xuICAgICAgICAvLyBSZW1vdmUgYW55IGtleSB0aGF0cyBub3QgdW5pcXVlXG4gICAgICAgIHNldE5hbWVzKHRoaXMsIE9iamVjdC5mcmVlemUoaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgbmFtZUNvdW50cy5nZXQobmFtZSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KSkpO1xuICAgICAgICAvLyBEdW1teSBvcGVyYXRpb25zIHRvIHByZXZlbnQgVHlwZVNjcmlwdCBmcm9tIGNvbXBsYWluaW5nXG4gICAgICAgIHRoaXMuI25hbWVzID0gW107XG4gICAgICAgIGlmICh0aGlzLiNuYW1lcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB2b2lkICh0aGlzLiNuYW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3cmFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSB3cmFwcGVkIFJlc3VsdCBpcyBpbW11dGFibGVcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgLy8gUHJveHkgaW5kaWNlcyBhbmQgbmFtZXMgc28gd2UgY2FuIHRyYXAgZGVmZXJyZWQgZXJyb3JzXG4gICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmRleCBhY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIocHJvcCwgXCIlaW5kZXhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmVzdWx0IHJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpbmRleH1gLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGZ1bmN0aW9ucyB3b3JrIHdpdGggcHJpdmF0ZSB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkjbm9fcHJpdmF0ZV9wcm9wZXJ0eV9mb3J3YXJkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkoKHRoaXMgPT09IHJlY2VpdmVyKSA/IHRhcmdldCA6IHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghKHByb3AgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libGUgbmFtZSBhY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRWYWx1ZS5hcHBseSgodGhpcyA9PT0gcmVjZWl2ZXIpID8gdGFyZ2V0IDogdGhpcywgW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZXROYW1lcyhwcm94eSwgZ2V0TmFtZXModGhpcykpO1xuICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYSBub3JtYWwgQXJyYXkuIElmICUlZGVlcCUlLCBhbnkgY2hpbGRyZW5cbiAgICAgKiAgd2hpY2ggYXJlIFJlc3VsdCBvYmplY3RzIGFyZSBhbHNvIGNvbnZlcnRlZCB0byBhIG5vcm1hbCBBcnJheS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIGFueSBvdXRzdGFuZGluZyBkZWZlcnJlZFxuICAgICAqICBlcnJvcnMuXG4gICAgICovXG4gICAgdG9BcnJheShkZWVwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpbmRleH1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWVwICYmIGl0ZW0gaW5zdGFuY2VvZiBSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS50b0FycmF5KGRlZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgUmVzdWx0IGFzIGFuIE9iamVjdCB3aXRoIGVhY2ggbmFtZS12YWx1ZSBwYWlyLiBJZlxuICAgICAqICAlJWRlZXAlJSwgYW55IGNoaWxkcmVuIHdoaWNoIGFyZSBSZXN1bHQgb2JqZWN0cyBhcmUgYWxzb1xuICAgICAqICBjb252ZXJ0ZWQgdG8gYW4gT2JqZWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiBhbnkgdmFsdWUgaXMgdW5uYW1lZCwgb3IgaWYgdGhlcmUgYXJlXG4gICAgICogIGFueSBvdXRzdGFuZGluZyBkZWZlcnJlZCBlcnJvcnMuXG4gICAgICovXG4gICAgdG9PYmplY3QoZGVlcCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IGdldE5hbWVzKHRoaXMpO1xuICAgICAgICByZXR1cm4gbmFtZXMucmVkdWNlKChhY2N1bSwgbmFtZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydChuYW1lICE9IG51bGwsIGB2YWx1ZSBhdCBpbmRleCAke2luZGV4fSB1bm5hbWVkYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b09iamVjdCgpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRvT2JqZWN0KG5hbWVzLCB0aGlzLCBkZWVwKTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgIGVuZCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9uYW1lcyA9IGdldE5hbWVzKHRoaXMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXNbaV0pO1xuICAgICAgICAgICAgbmFtZXMucHVzaChfbmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIGZpbHRlcihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCBfbmFtZXMgPSBnZXROYW1lcyh0aGlzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW10sIG5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpfWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlbSwgaSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKF9uYW1lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCByZXN1bHQsIG5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgbWFwKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aX1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlbSwgaSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgJSVuYW1lJSUuXG4gICAgICpcbiAgICAgKiAgU2luY2UgaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBhIGtleSB3aG9zZSBuYW1lIGNvbmZsaWN0cyB3aXRoXG4gICAgICogIGEgbWV0aG9kIG9uIGEgW1tSZXN1bHRdXSBvciBpdHMgc3VwZXJjbGFzcyBBcnJheSwgb3IgYW55XG4gICAgICogIEphdmFTY3JpcHQga2V5d29yZCwgdGhpcyBlbnN1cmVzIGFsbCBuYW1lZCB2YWx1ZXMgYXJlIHN0aWxsXG4gICAgICogIGFjY2Vzc2libGUgYnkgbmFtZS5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0TmFtZXModGhpcykuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCB2YWx1ZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW1Jlc3VsdF1dIGZvciAlJWl0ZW1zJSUgd2l0aCBlYWNoIGVudHJ5XG4gICAgICogIGFsc28gYWNjZXNzaWJsZSBieSBpdHMgY29ycmVzcG9uZGluZyBuYW1lIGluICUla2V5cyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSXRlbXMoaXRlbXMsIGtleXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCBpdGVtcywga2V5cyk7XG4gICAgfVxufVxuLyoqXG4gKiAgUmV0dXJucyBhbGwgZXJyb3JzIGZvdW5kIGluIGEgW1tSZXN1bHRdXS5cbiAqXG4gKiAgU2luY2UgY2VydGFpbiBlcnJvcnMgZW5jb3VudGVyZWQgd2hlbiBjcmVhdGluZyBhIFtbUmVzdWx0XV0gZG9cbiAqICBub3QgaW1wYWN0IHRoZSBhYmlsaXR5IHRvIGNvbnRpbnVlIHBhcnNpbmcgZGF0YSwgdGhleSBhcmVcbiAqICBkZWZlcnJlZCB1bnRpbCB0aGV5IGFyZSBhY3R1YWxseSBhY2Nlc3NlZC4gSGVuY2UgYSBmYXVsdHkgc3RyaW5nXG4gKiAgaW4gYW4gRXZlbnQgdGhhdCBpcyBuZXZlciB1c2VkIGRvZXMgbm90IGltcGFjdCB0aGUgcHJvZ3JhbSBmbG93LlxuICpcbiAqICBIb3dldmVyLCBzb21ldGltZXMgaXQgbWF5IGJlIHVzZWZ1bCB0byBhY2Nlc3MsIGlkZW50aWZ5IG9yXG4gKiAgdmFsaWRhdGUgY29ycmVjdG5lc3Mgb2YgYSBbW1Jlc3VsdF1dLlxuICpcbiAqICBAX2RvY2xvYyBhcGkvYWJpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Jlc3VsdEVycm9ycyhyZXN1bHQpIHtcbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBlcnJvciAoaWYgYW55KVxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IGNoZWNrRXJyb3JzID0gZnVuY3Rpb24gKHBhdGgsIG9iamVjdCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGguc2xpY2UoKTtcbiAgICAgICAgICAgIGNoaWxkUGF0aC5wdXNoKGtleSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoZWNrRXJyb3JzKGNoaWxkUGF0aCwgb2JqZWN0W2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBwYXRoOiBjaGlsZFBhdGgsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY2hlY2tFcnJvcnMoW10sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlKSB7XG4gICAgbGV0IGJ5dGVzID0gdG9CZUFycmF5KHZhbHVlKTtcbiAgICBhc3NlcnQoYnl0ZXMubGVuZ3RoIDw9IFdvcmRTaXplLCBcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7IGJ1ZmZlcjogYnl0ZXMsIGxlbmd0aDogV29yZFNpemUsIG9mZnNldDogYnl0ZXMubGVuZ3RoIH0pO1xuICAgIGlmIChieXRlcy5sZW5ndGggIT09IFdvcmRTaXplKSB7XG4gICAgICAgIGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbUGFkZGluZy5zbGljZShieXRlcy5sZW5ndGggJSBXb3JkU2l6ZSksIGJ5dGVzXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQ29kZXIge1xuICAgIC8vIFRoZSBjb2RlciBuYW1lOlxuICAgIC8vICAgLSBhZGRyZXNzLCB1aW50MjU2LCB0dXBsZSwgYXJyYXksIGV0Yy5cbiAgICBuYW1lO1xuICAgIC8vIFRoZSBmdWxseSBleHBhbmRlZCB0eXBlLCBpbmNsdWRpbmcgY29tcG9zaXRlIHR5cGVzOlxuICAgIC8vICAgLSBhZGRyZXNzLCB1aW50MjU2LCB0dXBsZShhZGRyZXNzLGJ5dGVzKSwgdWludDI1NlszXVs0XVtdLCAgZXRjLlxuICAgIHR5cGU7XG4gICAgLy8gVGhlIGxvY2FsTmFtZSBib3VuZCBpbiB0aGUgc2lnbmF0dXJlLCBpbiB0aGlzIGV4YW1wbGUgaXQgaXMgXCJiYXpcIjpcbiAgICAvLyAgIC0gdHVwbGUoYWRkcmVzcyBmb28sIHVpbnQgYmFyKSBiYXpcbiAgICBsb2NhbE5hbWU7XG4gICAgLy8gV2hldGhlciB0aGlzIHR5cGUgaXMgZHluYW1pYzpcbiAgICAvLyAgLSBEeW5hbWljOiBieXRlcywgc3RyaW5nLCBhZGRyZXNzW10sIHR1cGxlKGJvb2xlYW5bXSksIGV0Yy5cbiAgICAvLyAgLSBOb3QgRHluYW1pYzogYWRkcmVzcywgdWludDI1NiwgYm9vbGVhblszXSwgdHVwbGUoYWRkcmVzcywgdWludDgpXG4gICAgZHluYW1pYztcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcInN0cmluZ1wiLCB0eXBlOiBcInN0cmluZ1wiLCBsb2NhbE5hbWU6IFwic3RyaW5nXCIsIGR5bmFtaWM6IFwiYm9vbGVhblwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfdGhyb3dFcnJvcihtZXNzYWdlLCB2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgbWVzc2FnZSwgdGhpcy5sb2NhbE5hbWUsIHZhbHVlKTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgV3JpdGVyIHtcbiAgICAvLyBBbiBhcnJheSBvZiBXb3JkU2l6ZSBsZW5ndGhlZCBvYmplY3RzIHRvIGNvbmNhdGVuYXRpb25cbiAgICAjZGF0YTtcbiAgICAjZGF0YUxlbmd0aDtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy4jZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQodGhpcy4jZGF0YSk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLiNkYXRhTGVuZ3RoOyB9XG4gICAgI3dyaXRlRGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuI2RhdGEucHVzaChkYXRhKTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBhcHBlbmRXcml0ZXIod3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0Qnl0ZXNDb3B5KHdyaXRlci5kYXRhKSk7XG4gICAgfVxuICAgIC8vIEFycmF5aXNoIGl0ZW07IHBhZCBvbiB0aGUgcmlnaHQgdG8gKm5lYXJlc3QqIFdvcmRTaXplXG4gICAgd3JpdGVCeXRlcyh2YWx1ZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSBnZXRCeXRlc0NvcHkodmFsdWUpO1xuICAgICAgICBjb25zdCBwYWRkaW5nT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgV29yZFNpemU7XG4gICAgICAgIGlmIChwYWRkaW5nT2Zmc2V0KSB7XG4gICAgICAgICAgICBieXRlcyA9IGdldEJ5dGVzQ29weShjb25jYXQoW2J5dGVzLCBQYWRkaW5nLnNsaWNlKHBhZGRpbmdPZmZzZXQpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoYnl0ZXMpO1xuICAgIH1cbiAgICAvLyBOdW1lcmljIGl0ZW07IHBhZCBvbiB0aGUgbGVmdCAqdG8qIFdvcmRTaXplXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGdldFZhbHVlKHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIEluc2VydHMgYSBudW1lcmljIHBsYWNlLWhvbGRlciwgcmV0dXJuaW5nIGEgY2FsbGJhY2sgdGhhdCBjYW5cbiAgICAvLyBiZSB1c2VkIHRvIGFzanVzdCB0aGUgdmFsdWUgbGF0ZXJcbiAgICB3cml0ZVVwZGF0YWJsZVZhbHVlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLiNkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKFBhZGRpbmcpO1xuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoICs9IFdvcmRTaXplO1xuICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNkYXRhW29mZnNldF0gPSBnZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFJlYWRlciB7XG4gICAgLy8gQWxsb3dzIGluY29tcGxldGUgdW5wYWRkZWQgZGF0YSB0byBiZSByZWFkOyBvdGhlcndpc2UgYW4gZXJyb3JcbiAgICAvLyBpcyByYWlzZWQgaWYgYXR0ZW1wdGluZyB0byBvdmVycnVuIHRoZSBidWZmZXIuIFRoaXMgaXMgcmVxdWlyZWRcbiAgICAvLyB0byBkZWFsIHdpdGggYW4gb2xkIFNvbGlkaXR5IGJ1ZywgaW4gd2hpY2ggZXZlbnQgZGF0YSBmb3JcbiAgICAvLyBleHRlcm5hbCAobm90IHB1YmxpYyB0aG9ndWgpIHdhcyB0aWdodGx5IHBhY2tlZC5cbiAgICBhbGxvd0xvb3NlO1xuICAgICNkYXRhO1xuICAgICNvZmZzZXQ7XG4gICAgI2J5dGVzUmVhZDtcbiAgICAjcGFyZW50O1xuICAgICNtYXhJbmZsYXRpb247XG4gICAgY29uc3RydWN0b3IoZGF0YSwgYWxsb3dMb29zZSwgbWF4SW5mbGF0aW9uKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhbGxvd0xvb3NlOiAhIWFsbG93TG9vc2UgfSk7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XG4gICAgICAgIHRoaXMuI2J5dGVzUmVhZCA9IDA7XG4gICAgICAgIHRoaXMuI3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heEluZmxhdGlvbiA9IChtYXhJbmZsYXRpb24gIT0gbnVsbCkgPyBtYXhJbmZsYXRpb24gOiAxMDI0O1xuICAgICAgICB0aGlzLiNvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHsgcmV0dXJuIGhleGxpZnkodGhpcy4jZGF0YSk7IH1cbiAgICBnZXQgZGF0YUxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI2RhdGEubGVuZ3RoOyB9XG4gICAgZ2V0IGNvbnN1bWVkKCkgeyByZXR1cm4gdGhpcy4jb2Zmc2V0OyB9XG4gICAgZ2V0IGJ5dGVzKCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jZGF0YSk7IH1cbiAgICAjaW5jcmVtZW50Qnl0ZXNSZWFkKGNvdW50KSB7XG4gICAgICAgIGlmICh0aGlzLiNwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwYXJlbnQuI2luY3JlbWVudEJ5dGVzUmVhZChjb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYnl0ZXNSZWFkICs9IGNvdW50O1xuICAgICAgICAvLyBDaGVjayBmb3IgZXhjZXNzaXZlIGluZmxhdGlvbiAoc2VlOiAjNDUzNylcbiAgICAgICAgYXNzZXJ0KHRoaXMuI21heEluZmxhdGlvbiA8IDEgfHwgdGhpcy4jYnl0ZXNSZWFkIDw9IHRoaXMuI21heEluZmxhdGlvbiAqIHRoaXMuZGF0YUxlbmd0aCwgYGNvbXByZXNzZWQgQUJJIGRhdGEgZXhjZWVkcyBpbmZsYXRpb24gcmF0aW8gb2YgJHt0aGlzLiNtYXhJbmZsYXRpb259ICggc2VlOiBodHRwczovXFwvZ2l0aHViLmNvbS9ldGhlcnMtaW8vZXRoZXJzLmpzL2lzc3Vlcy80NTM3IClgLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogZ2V0Qnl0ZXNDb3B5KHRoaXMuI2RhdGEpLCBvZmZzZXQ6IHRoaXMuI29mZnNldCxcbiAgICAgICAgICAgIGxlbmd0aDogY291bnQsIGluZm86IHtcbiAgICAgICAgICAgICAgICBieXRlc1JlYWQ6IHRoaXMuI2J5dGVzUmVhZCxcbiAgICAgICAgICAgICAgICBkYXRhTGVuZ3RoOiB0aGlzLmRhdGFMZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgICNwZWVrQnl0ZXMob2Zmc2V0LCBsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBhbGlnbmVkTGVuZ3RoID0gTWF0aC5jZWlsKGxlbmd0aCAvIFdvcmRTaXplKSAqIFdvcmRTaXplO1xuICAgICAgICBpZiAodGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCA+IHRoaXMuI2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd0xvb3NlICYmIGxvb3NlICYmIHRoaXMuI29mZnNldCArIGxlbmd0aCA8PSB0aGlzLiNkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFsaWduZWRMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiZGF0YSBvdXQtb2YtYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IGdldEJ5dGVzQ29weSh0aGlzLiNkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLiNkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI2RhdGEuc2xpY2UodGhpcy4jb2Zmc2V0LCB0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgc3ViLXJlYWRlciB3aXRoIHRoZSBzYW1lIHVuZGVybHlpbmcgZGF0YSwgYnV0IG9mZnNldFxuICAgIHN1YlJlYWRlcihvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IFJlYWRlcih0aGlzLiNkYXRhLnNsaWNlKHRoaXMuI29mZnNldCArIG9mZnNldCksIHRoaXMuYWxsb3dMb29zZSwgdGhpcy4jbWF4SW5mbGF0aW9uKTtcbiAgICAgICAgcmVhZGVyLiNwYXJlbnQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gcmVhZGVyO1xuICAgIH1cbiAgICAvLyBSZWFkIGJ5dGVzXG4gICAgcmVhZEJ5dGVzKGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gdGhpcy4jcGVla0J5dGVzKDAsIGxlbmd0aCwgISFsb29zZSk7XG4gICAgICAgIHRoaXMuI2luY3JlbWVudEJ5dGVzUmVhZChsZW5ndGgpO1xuICAgICAgICB0aGlzLiNvZmZzZXQgKz0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAvLyBAVE9ETzogTWFrZSBzdXJlIHRoZSBsZW5ndGguLmVuZCBieXRlcyBhcmUgYWxsIDA/XG4gICAgICAgIHJldHVybiBieXRlcy5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cbiAgICAvLyBSZWFkIGEgbnVtZXJpYyB2YWx1ZXNcbiAgICByZWFkVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ0ludCh0aGlzLnJlYWRCeXRlcyhXb3JkU2l6ZSkpO1xuICAgIH1cbiAgICByZWFkSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0b051bWJlcih0aGlzLnJlYWRCeXRlcyhXb3JkU2l6ZSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0LWNvZGVyLmpzLm1hcCIsImZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIiwiZXhwb3J0IGNvbnN0IGNyeXB0byA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIiwiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBieXRlcyBhcyBhc3NlcnRCeXRlcywgZXhpc3RzIGFzIGFzc2VydEV4aXN0cyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnRCeXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIiwiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBudW1iZXIgYXMgYXNzZXJ0TnVtYmVyIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IGhtYWMgfSBmcm9tICcuL2htYWMuanMnO1xuaW1wb3J0IHsgY3JlYXRlVmlldywgdG9CeXRlcywgY2hlY2tPcHRzLCBhc3luY0xvb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIENvbW1vbiBwcm9sb2d1ZSBhbmQgZXBpbG9ndWUgZm9yIHN5bmMvYXN5bmMgZnVuY3Rpb25zXG5mdW5jdGlvbiBwYmtkZjJJbml0KGhhc2gsIF9wYXNzd29yZCwgX3NhbHQsIF9vcHRzKSB7XG4gICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICBjb25zdCBvcHRzID0gY2hlY2tPcHRzKHsgZGtMZW46IDMyLCBhc3luY1RpY2s6IDEwIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBhc3luY1RpY2sgfSA9IG9wdHM7XG4gICAgYXNzZXJ0TnVtYmVyKGMpO1xuICAgIGFzc2VydE51bWJlcihka0xlbik7XG4gICAgYXNzZXJ0TnVtYmVyKGFzeW5jVGljayk7XG4gICAgaWYgKGMgPCAxKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BCS0RGMjogaXRlcmF0aW9ucyAoYykgc2hvdWxkIGJlID49IDEnKTtcbiAgICBjb25zdCBwYXNzd29yZCA9IHRvQnl0ZXMoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBzYWx0ID0gdG9CeXRlcyhfc2FsdCk7XG4gICAgLy8gREsgPSBQQktERjIoUFJGLCBQYXNzd29yZCwgU2FsdCwgYywgZGtMZW4pO1xuICAgIGNvbnN0IERLID0gbmV3IFVpbnQ4QXJyYXkoZGtMZW4pO1xuICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgIGNvbnN0IFBSRiA9IGhtYWMuY3JlYXRlKGhhc2gsIHBhc3N3b3JkKTtcbiAgICBjb25zdCBQUkZTYWx0ID0gUFJGLl9jbG9uZUludG8oKS51cGRhdGUoc2FsdCk7XG4gICAgcmV0dXJuIHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9O1xufVxuZnVuY3Rpb24gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpIHtcbiAgICBQUkYuZGVzdHJveSgpO1xuICAgIFBSRlNhbHQuZGVzdHJveSgpO1xuICAgIGlmIChwcmZXKVxuICAgICAgICBwcmZXLmRlc3Ryb3koKTtcbiAgICB1LmZpbGwoMCk7XG4gICAgcmV0dXJuIERLO1xufVxuLyoqXG4gKiBQQktERjItSE1BQzogUkZDIDI4OTgga2V5IGRlcml2YXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3N3b3JkIGZyb20gd2hpY2ggYSBkZXJpdmVkIGtleSBpcyBnZW5lcmF0ZWRcbiAqIEBwYXJhbSBzYWx0IC0gY3J5cHRvZ3JhcGhpYyBzYWx0XG4gKiBAcGFyYW0gb3B0cyAtIHtjLCBka0xlbn0gd2hlcmUgYyBpcyB3b3JrIGZhY3RvciBhbmQgZGtMZW4gaXMgb3V0cHV0IG1lc3NhZ2Ugc2l6ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGJrZGYyKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgbGV0IHByZlc7IC8vIFdvcmtpbmcgY29weVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgZm9yIChsZXQgdWkgPSAxOyB1aSA8IGM7IHVpKyspIHtcbiAgICAgICAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY+KIkjEpXG4gICAgICAgICAgICBQUkYuX2Nsb25lSW50byhwcmZXKS51cGRhdGUodSkuZGlnZXN0SW50byh1KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgVGlbaV0gXj0gdVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBia2RmMkFzeW5jKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBhd2FpdCBhc3luY0xvb3AoYyAtIDEsIGFzeW5jVGljaywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiLCJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiLCJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIiwiY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsIHNoclNILCBzaHJTTCwgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLCByb3RyMzJILCByb3RyMzJMLCByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCwgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCIsImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB1NjQgZnJvbSAnLi9fdTY0LmpzJztcbmltcG9ydCB7IHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUm91bmQgY29udGFudHMgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBbU0hBNTEyX0toLCBTSEE1MTJfS2xdID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB1NjQuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpKSgpO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG5jb25zdCBTSEE1MTJfV19IID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5jb25zdCBTSEE1MTJfV19MID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5leHBvcnQgY2xhc3MgU0hBNTEyIGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDEyOCwgNjQsIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGUgd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBBbHNvIGxvb2tzIGNsZWFuZXIgYW5kIGVhc2llciB0byB2ZXJpZnkgd2l0aCBzcGVjLlxuICAgICAgICAvLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4NmEwOWU2NjcgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmM2JjYzkwOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweGJiNjdhZTg1IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODRjYWE3M2IgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgzYzZlZjM3MiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweGZlOTRmODJiIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4YTU0ZmY1M2EgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ZjFkMzZmMSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDUxMGU1MjdmIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YWRlNjgyZDEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg5YjA1Njg4YyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDJiM2U2YzFmIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MWY4M2Q5YWIgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHhmYjQxYmQ2YiB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDViZTBjZDE5IHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4MTM3ZTIxNzkgfCAwO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IHU2NC5yb3RyU0woVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG4gICAgICAgICAgICBjb25zdCBTVU1oID0gdTY0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gdTY0LnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0goRWgsIEVsLCAxOCkgXiB1NjQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IHU2NC5yb3RyU0woRWgsIEVsLCAxNCkgXiB1NjQucm90clNMKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSB1NjQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQuYWRkNUgoVDFsbCwgSGgsIHNpZ21hMWgsIENISWgsIFNIQTUxMl9LaFtpXSwgU0hBNTEyX1dfSFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcbiAgICAgICAgICAgIC8vIFMwIDo9IChhIHJpZ2h0cm90YXRlIDI4KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzQpIHhvciAoYSByaWdodHJvdGF0ZSAzOSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGggPSB1NjQucm90clNIKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gdTY0LnJvdHJTTChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3QgTUFKaCA9IChBaCAmIEJoKSBeIChBaCAmIENoKSBeIChCaCAmIENoKTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmwgPSAoQWwgJiBCbCkgXiAoQWwgJiBDbCkgXiAoQmwgJiBDbCk7XG4gICAgICAgICAgICBIaCA9IEdoIHwgMDtcbiAgICAgICAgICAgIEhsID0gR2wgfCAwO1xuICAgICAgICAgICAgR2ggPSBGaCB8IDA7XG4gICAgICAgICAgICBHbCA9IEZsIHwgMDtcbiAgICAgICAgICAgIEZoID0gRWggfCAwO1xuICAgICAgICAgICAgRmwgPSBFbCB8IDA7XG4gICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IHU2NC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSB1NjQuYWRkM0goQWxsLCBUMWgsIHNpZ21hMGgsIE1BSmgpO1xuICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gdTY0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gdTY0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XG4gICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gdTY0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XG4gICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gdTY0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gdTY0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBNTEyX1dfSC5maWxsKDApO1xuICAgICAgICBTSEE1MTJfV19MLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg4YzNkMzdjOCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweDE5NTQ0ZGEyIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NzNlMTk5NjYgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4OWRjZDRkNiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDFkZmFiN2FlIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzJmZjljODIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg2NzlkZDUxNCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU4MmY5ZmNmIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4MGY2ZDJiNjkgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHg3YmQ0NGRhOCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDc3ZTM2ZjczIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MDRjNDg5NDIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgzZjlkODVhOCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDZhMWQzNmM4IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MTExMmU2YWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg5MWQ2OTJhMSB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDIyMzEyMTk0IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZmMyYmY3MmMgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg5ZjU1NWZhMyB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweGM4NGM2NGMyIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MjM5M2I4NmIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHg2ZjUzYjE1MSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDk2Mzg3NzE5IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTk0MGVhYmQgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg5NjI4M2VlMiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGE4OGVmZmUzIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4YmU1ZTFlMjUgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg1Mzg2Mzk5MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDJiMDE5OWZjIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4MmM4NWI4YWEgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgwZWI3MmRkYyB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDgxYzUyY2EyIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAzMjtcbiAgICB9XG59XG5jbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHhjYmJiOWQ1ZCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NjI5YTI5MmEgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDkxNTkwMTVhIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHgxNTJmZWNkOCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NjczMzI2NjcgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDhlYjQ0YTg3IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHhkYjBjMmUwZCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NDdiNTQ4MWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gNDg7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMigpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEzODQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEzODQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGE1MTIuanMubWFwIiwiLyogQnJvd3NlciBDcnlwdG8gU2hpbXMgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9obWFjXCI7XG5pbXBvcnQgeyBwYmtkZjIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9wYmtkZjJcIjtcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuaW1wb3J0IHsgc2hhNTEyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhNTEyXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCcpO1xufVxuO1xuY29uc3QgYW55R2xvYmFsID0gZ2V0R2xvYmFsKCk7XG5jb25zdCBjcnlwdG8gPSBhbnlHbG9iYWwuY3J5cHRvIHx8IGFueUdsb2JhbC5tc0NyeXB0bztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoKGFsZ28pIHtcbiAgICBzd2l0Y2ggKGFsZ28pIHtcbiAgICAgICAgY2FzZSBcInNoYTI1NlwiOiByZXR1cm4gc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICBjYXNlIFwic2hhNTEyXCI6IHJldHVybiBzaGE1MTIuY3JlYXRlKCk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgaGFzaGluZyBhbGdvcml0aG0gbmFtZVwiLCBcImFsZ29yaXRobVwiLCBhbGdvKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjKF9hbGdvLCBrZXkpIHtcbiAgICBjb25zdCBhbGdvID0gKHsgc2hhMjU2LCBzaGE1MTIgfVtfYWxnb10pO1xuICAgIGFzc2VydEFyZ3VtZW50KGFsZ28gIT0gbnVsbCwgXCJpbnZhbGlkIGhtYWMgYWxnb3JpdGhtXCIsIFwiYWxnb3JpdGhtXCIsIF9hbGdvKTtcbiAgICByZXR1cm4gaG1hYy5jcmVhdGUoYWxnbywga2V5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIF9hbGdvKSB7XG4gICAgY29uc3QgYWxnbyA9ICh7IHNoYTI1Niwgc2hhNTEyIH1bX2FsZ29dKTtcbiAgICBhc3NlcnRBcmd1bWVudChhbGdvICE9IG51bGwsIFwiaW52YWxpZCBwYmtkZjIgYWxnb3JpdGhtXCIsIFwiYWxnb3JpdGhtXCIsIF9hbGdvKTtcbiAgICByZXR1cm4gcGJrZGYyKGFsZ28sIHBhc3N3b3JkLCBzYWx0LCB7IGM6IGl0ZXJhdGlvbnMsIGRrTGVuOiBrZXlsZW4gfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMobGVuZ3RoKSB7XG4gICAgYXNzZXJ0KGNyeXB0byAhPSBudWxsLCBcInBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgc2VjdXJlIHJhbmRvbSBudW1iZXJzXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcInJhbmRvbUJ5dGVzXCJcbiAgICB9KTtcbiAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkgJiYgbGVuZ3RoID4gMCAmJiBsZW5ndGggPD0gMTAyNCwgXCJpbnZhbGlkIGxlbmd0aFwiLCBcImxlbmd0aFwiLCBsZW5ndGgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8tYnJvd3Nlci5qcy5tYXAiLCIvKipcbiAqICBBbiAqKkhNQUMqKiBlbmFibGVzIHZlcmlmaWNhdGlvbiB0aGF0IGEgZ2l2ZW4ga2V5IHdhcyB1c2VkXG4gKiAgdG8gYXV0aGVudGljYXRlIGEgcGF5bG9hZC5cbiAqXG4gKiAgU2VlOiBbW2xpbmstd2lraS1obWFjXV1cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOkhNQUMgIFthYm91dC1obWFjXVxuICovXG5pbXBvcnQgeyBjcmVhdGVIbWFjIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX2NvbXB1dGVIbWFjID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhtYWMoYWxnb3JpdGhtLCBrZXkpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5sZXQgX19jb21wdXRlSG1hYyA9IF9jb21wdXRlSG1hYztcbi8qKlxuICogIFJldHVybiB0aGUgSE1BQyBmb3IgJSVkYXRhJSUgdXNpbmcgdGhlICUla2V5JSUga2V5IHdpdGggdGhlIHVuZGVybHlpbmdcbiAqICAlJWFsZ28lJSB1c2VkIGZvciBjb21wcmVzc2lvbi5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBrZXkgPSBpZChcInNvbWUtc2VjcmV0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgSE1BQ1xuICogICAgY29tcHV0ZUhtYWMoXCJzaGEyNTZcIiwga2V5LCBcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRvIGNvbXB1dGUgdGhlIEhNQUMgb2YgVVRGLTggZGF0YSwgdGhlIGRhdGEgbXVzdCBiZVxuICogICAgLy8gY29udmVydGVkIHRvIFVURi04IGJ5dGVzXG4gKiAgICBjb21wdXRlSG1hYyhcInNoYTI1NlwiLCBrZXksIHRvVXRmOEJ5dGVzKFwiSGVsbG8gV29ybGRcIikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBfa2V5LCBfZGF0YSkge1xuICAgIGNvbnN0IGtleSA9IGdldEJ5dGVzKF9rZXksIFwia2V5XCIpO1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBrZXksIGRhdGEpKTtcbn1cbmNvbXB1dGVIbWFjLl8gPSBfY29tcHV0ZUhtYWM7XG5jb21wdXRlSG1hYy5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xuY29tcHV0ZUhtYWMucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29tcHV0ZUhtYWMgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX2NvbXB1dGVIbWFjID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKGNvbXB1dGVIbWFjKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIiwiaW1wb3J0IHsgYnl0ZXMsIGV4aXN0cywgbnVtYmVyLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCBzcGxpdCB9IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB1MzIsIHRvQnl0ZXMsIHdyYXBDb25zdHJ1Y3Rvciwgd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEzIChrZWNjYWspIGlzIGJhc2VkIG9uIGEgbmV3IGRlc2lnbjogYmFzaWNhbGx5LCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4vLyBJdCdzIGNhbGxlZCBhIHNwb25nZSBmdW5jdGlvbi5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xuY29uc3QgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgweDcxKTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSAvKiBAX19QVVJFX18gKi8gc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCTChoLCBsLCBzKSA6IHJvdGxTTChoLCBsLCBzKSk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBudW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSB1MzIodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIG51bWJlcihieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhM18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnQgY29uc3Qgc2hha2UxMjggPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiLCIvKipcbiAqICBDcnlwdG9ncmFwaGljIGhhc2hpbmcgZnVuY3Rpb25zXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9ucyBbYWJvdXQtY3J5cHRvLWhhc2hpbmddXG4gKi9cbmltcG9ydCB7IGtlY2Nha18yNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX2tlY2NhazI1NiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGtlY2Nha18yNTYoZGF0YSk7XG59O1xubGV0IF9fa2VjY2FrMjU2ID0gX2tlY2NhazI1Njtcbi8qKlxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgS0VDQ0FLMjU2IGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIFRoZSAlJWRhdGElJSAqKm11c3QqKiBiZSBhIGRhdGEgcmVwcmVzZW50YXRpb24sIHRvIGNvbXB1dGUgdGhlXG4gKiAgaGFzaCBvZiBVVEYtOCBkYXRhIHVzZSB0aGUgW1tpZF1dIGZ1bmN0aW9uLlxuICpcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBrZWNjYWsyNTYoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIGtlY2NhazI1NihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIGtlY2NhazI1NihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gU3RyaW5ncyBhcmUgYXNzdW1lZCB0byBiZSBEYXRhSGV4U3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbFxuICogICAgLy8gdGhyb3cuIFRvIGhhc2ggVVRGLTggZGF0YSwgc2VlIHRoZSBub3RlIGFib3ZlLlxuICogICAga2VjY2FrMjU2KFwiSGVsbG8gV29ybGRcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19rZWNjYWsyNTYoZGF0YSkpO1xufVxua2VjY2FrMjU2Ll8gPSBfa2VjY2FrMjU2O1xua2VjY2FrMjU2LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5rZWNjYWsyNTYucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtlY2NhazI1NiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fa2VjY2FrMjU2ID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKGtlY2NhazI1Nik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZWNjYWsuanMubWFwIiwiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC5odG1sXG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuY29uc3QgUmhvID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50OEFycmF5KFs3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4XSk7XG5jb25zdCBJZCA9IC8qIEBfX1BVUkVfXyAqLyBVaW50OEFycmF5LmZyb20oeyBsZW5ndGg6IDE2IH0sIChfLCBpKSA9PiBpKTtcbmNvbnN0IFBpID0gLyogQF9fUFVSRV9fICovIElkLm1hcCgoaSkgPT4gKDkgKiBpICsgNSkgJSAxNik7XG5sZXQgaWR4TCA9IFtJZF07XG5sZXQgaWR4UiA9IFtQaV07XG5mb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICBmb3IgKGxldCBqIG9mIFtpZHhMLCBpZHhSXSlcbiAgICAgICAgai5wdXNoKGpbaV0ubWFwKChrKSA9PiBSaG9ba10pKTtcbmNvbnN0IHNoaWZ0cyA9IC8qIEBfX1BVUkVfXyAqLyBbXG4gICAgWzExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOF0sXG4gICAgWzEyLCAxMywgMTEsIDE1LCA2LCA5LCA5LCA3LCAxMiwgMTUsIDExLCAxMywgNywgOCwgNywgN10sXG4gICAgWzEzLCAxNSwgMTQsIDExLCA3LCA3LCA2LCA4LCAxMywgMTQsIDEzLCAxMiwgNSwgNSwgNiwgOV0sXG4gICAgWzE0LCAxMSwgMTIsIDE0LCA4LCA2LCA1LCA1LCAxNSwgMTIsIDE1LCAxNCwgOSwgOSwgOCwgNl0sXG4gICAgWzE1LCAxMiwgMTMsIDEzLCA5LCA1LCA4LCA2LCAxNCwgMTEsIDEyLCAxMSwgOCwgNiwgNSwgNV0sXG5dLm1hcCgoaSkgPT4gbmV3IFVpbnQ4QXJyYXkoaSkpO1xuY29uc3Qgc2hpZnRzTCA9IC8qIEBfX1BVUkVfXyAqLyBpZHhMLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHNbaV1bal0pKTtcbmNvbnN0IHNoaWZ0c1IgPSAvKiBAX19QVVJFX18gKi8gaWR4Ui5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBLbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4MDAwMDAwMDAsIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4YTk1M2ZkNGUsXG5dKTtcbmNvbnN0IEtyID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg1MGEyOGJlNiwgMHg1YzRkZDEyNCwgMHg2ZDcwM2VmMywgMHg3YTZkNzZlOSwgMHgwMDAwMDAwMCxcbl0pO1xuLy8gVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3Qgcm90bCA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgc2hpZnQpIHwgKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSk7XG4vLyBJdCdzIGNhbGxlZCBmKCkgaW4gc3BlYy5cbmZ1bmN0aW9uIGYoZ3JvdXAsIHgsIHksIHopIHtcbiAgICBpZiAoZ3JvdXAgPT09IDApXG4gICAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gICAgZWxzZSBpZiAoZ3JvdXAgPT09IDEpXG4gICAgICAgIHJldHVybiAoeCAmIHkpIHwgKH54ICYgeik7XG4gICAgZWxzZSBpZiAoZ3JvdXAgPT09IDIpXG4gICAgICAgIHJldHVybiAoeCB8IH55KSBeIHo7XG4gICAgZWxzZSBpZiAoZ3JvdXAgPT09IDMpXG4gICAgICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiB+eik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4geCBeICh5IHwgfnopO1xufVxuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG5jb25zdCBCVUYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmV4cG9ydCBjbGFzcyBSSVBFTUQxNjAgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDIwLCA4LCB0cnVlKTtcbiAgICAgICAgdGhpcy5oMCA9IDB4Njc0NTIzMDEgfCAwO1xuICAgICAgICB0aGlzLmgxID0gMHhlZmNkYWI4OSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSAweDk4YmFkY2ZlIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IDB4MTAzMjU0NzYgfCAwO1xuICAgICAgICB0aGlzLmg0ID0gMHhjM2QyZTFmMCB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBoMCwgaDEsIGgyLCBoMywgaDQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbaDAsIGgxLCBoMiwgaDMsIGg0XTtcbiAgICB9XG4gICAgc2V0KGgwLCBoMSwgaDIsIGgzLCBoNCkge1xuICAgICAgICB0aGlzLmgwID0gaDAgfCAwO1xuICAgICAgICB0aGlzLmgxID0gaDEgfCAwO1xuICAgICAgICB0aGlzLmgyID0gaDIgfCAwO1xuICAgICAgICB0aGlzLmgzID0gaDMgfCAwO1xuICAgICAgICB0aGlzLmg0ID0gaDQgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgQlVGW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBhbCA9IHRoaXMuaDAgfCAwLCBhciA9IGFsLCBibCA9IHRoaXMuaDEgfCAwLCBiciA9IGJsLCBjbCA9IHRoaXMuaDIgfCAwLCBjciA9IGNsLCBkbCA9IHRoaXMuaDMgfCAwLCBkciA9IGRsLCBlbCA9IHRoaXMuaDQgfCAwLCBlciA9IGVsO1xuICAgICAgICAvLyBJbnN0ZWFkIG9mIGl0ZXJhdGluZyAwIHRvIDgwLCB3ZSBzcGxpdCBpdCBpbnRvIDUgZ3JvdXBzXG4gICAgICAgIC8vIEFuZCB1c2UgdGhlIGdyb3VwcyBpbiBjb25zdGFudHMsIGZ1bmN0aW9ucywgZXRjLiBNdWNoIHNpbXBsZXJcbiAgICAgICAgZm9yIChsZXQgZ3JvdXAgPSAwOyBncm91cCA8IDU7IGdyb3VwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJHcm91cCA9IDQgLSBncm91cDtcbiAgICAgICAgICAgIGNvbnN0IGhibCA9IEtsW2dyb3VwXSwgaGJyID0gS3JbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHJsID0gaWR4TFtncm91cF0sIHJyID0gaWR4Ultncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgc2wgPSBzaGlmdHNMW2dyb3VwXSwgc3IgPSBzaGlmdHNSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bCA9IChyb3RsKGFsICsgZihncm91cCwgYmwsIGNsLCBkbCkgKyBCVUZbcmxbaV1dICsgaGJsLCBzbFtpXSkgKyBlbCkgfCAwO1xuICAgICAgICAgICAgICAgIGFsID0gZWwsIGVsID0gZGwsIGRsID0gcm90bChjbCwgMTApIHwgMCwgY2wgPSBibCwgYmwgPSB0bDsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyIGxvb3BzIGFyZSAxMCUgZmFzdGVyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ciA9IChyb3RsKGFyICsgZihyR3JvdXAsIGJyLCBjciwgZHIpICsgQlVGW3JyW2ldXSArIGhiciwgc3JbaV0pICsgZXIpIHwgMDtcbiAgICAgICAgICAgICAgICBhciA9IGVyLCBlciA9IGRyLCBkciA9IHJvdGwoY3IsIDEwKSB8IDAsIGNyID0gYnIsIGJyID0gdHI7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0KCh0aGlzLmgxICsgY2wgKyBkcikgfCAwLCAodGhpcy5oMiArIGRsICsgZXIpIHwgMCwgKHRoaXMuaDMgKyBlbCArIGFyKSB8IDAsICh0aGlzLmg0ICsgYWwgKyBicikgfCAwLCAodGhpcy5oMCArIGJsICsgY3IpIHwgMCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIEJVRi5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbi8qKlxuICogUklQRU1ELTE2MCAtIGEgaGFzaCBmdW5jdGlvbiBmcm9tIDE5OTBzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBtc2cgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHJpcGVtZDE2MCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFJJUEVNRDE2MCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpcGVtZDE2MC5qcy5tYXAiLCJpbXBvcnQgeyByaXBlbWQxNjAgYXMgbm9ibGVfcmlwZW1kMTYwIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvcmlwZW1kMTYwXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX3JpcGVtZDE2MCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5vYmxlX3JpcGVtZDE2MChkYXRhKTtcbn07XG5sZXQgX19yaXBlbWQxNjAgPSBfcmlwZW1kMTYwO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBSSVBFTUQtMTYwIGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJpcGVtZDE2MChcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgcmlwZW1kMTYwKFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgcmlwZW1kMTYwKG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByaXBlbWQxNjAoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX3JpcGVtZDE2MChkYXRhKSk7XG59XG5yaXBlbWQxNjAuXyA9IF9yaXBlbWQxNjA7XG5yaXBlbWQxNjAubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbnJpcGVtZDE2MC5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmlwZW1kMTYwIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19yaXBlbWQxNjAgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUocmlwZW1kMTYwKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpcGVtZDE2MC5qcy5tYXAiLCIvKipcbiAqICBBICoqUGFzc3dvcmQtQmFzZWQgS2V5LURlcml2YXRpb24gRnVuY3Rpb24qKiBpcyBkZXNpZ25lZCB0byBjcmVhdGVcbiAqICBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN1aXRpYmxlIGFzIGEgKiprZXkqKiBmcm9tIGEgaHVtYW4tcmVtZW1iZXJhYmxlXG4gKiAgcGFzc3dvcmQuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpQYXNzd29yZHMgIFthYm91dC1wYmtkZl1cbiAqL1xuaW1wb3J0IHsgcGJrZGYyU3luYyB9IGZyb20gXCIuL2NyeXB0by5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9wYmtkZjIgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbykge1xuICAgIHJldHVybiBwYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pO1xufTtcbmxldCBfX3Bia2RmMiA9IF9wYmtkZjI7XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbbGluay1wYmtkZjJdXSBmb3IgJSVrZXlsZW4lJSBieXRlcyBmb3IgJSVwYXNzd29yZCUlIHVzaW5nXG4gKiAgdGhlICUlc2FsdCUlIGFuZCB1c2luZyAlJWl0ZXJhdGlvbnMlJSBvZiAlJWFsZ28lJS5cbiAqXG4gKiAgVGhpcyBQQktERiBpcyBvdXRkYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGluIG5ldyBwcm9qZWN0cywgYnV0IGlzXG4gKiAgcmVxdWlyZWQgdG8gZGVjcnlwdCBvbGRlciBmaWxlcy5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBUaGUgcGFzc3dvcmQgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMsIGFuZCBpdCBpcyBnZW5lcmFsbHlcbiAqICAgIC8vIGJlc3QgcHJhY3RpY2VzIHRvIGVuc3VyZSB0aGUgc3RyaW5nIGhhcyBiZWVuIG5vcm1hbGl6ZWQuIE1hbnlcbiAqICAgIC8vIGZvcm1hdHMgZXhwbGljaXRseSBpbmRpY2F0ZSB0aGUgbm9ybWFsaXphdGlvbiBmb3JtIHRvIHVzZS5cbiAqICAgIHBhc3N3b3JkID0gXCJoZWxsb1wiXG4gKiAgICBwYXNzd29yZEJ5dGVzID0gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFwiTkZLQ1wiKVxuICpcbiAqICAgIHNhbHQgPSBpZChcInNvbWUtc2FsdFwiKVxuICpcbiAqICAgIC8vIENvbXB1dGUgdGhlIFBCS0RGMlxuICogICAgcGJrZGYyKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIDEwMjQsIDE2LCBcInNoYTI1NlwiKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGJrZGYyKF9wYXNzd29yZCwgX3NhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbykge1xuICAgIGNvbnN0IHBhc3N3b3JkID0gZ2V0Qnl0ZXMoX3Bhc3N3b3JkLCBcInBhc3N3b3JkXCIpO1xuICAgIGNvbnN0IHNhbHQgPSBnZXRCeXRlcyhfc2FsdCwgXCJzYWx0XCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fcGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pKTtcbn1cbnBia2RmMi5fID0gX3Bia2RmMjtcbnBia2RmMi5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xucGJrZGYyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBia2RmMiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fcGJrZGYyID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHBia2RmMik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYmtkZjIuanMubWFwIiwiLyoqXG4gKiAgQSAqKkNyeXB0b2dyYXBoaWNhbGx5IFNlY3VyZSBSYW5kb20gVmFsdWUqKiBpcyBvbmUgdGhhdCBoYXMgYmVlblxuICogIGdlbmVyYXRlZCB3aXRoIGFkZGl0aW9uYWwgY2FyZSB0YWtlIHRvIHByZXZlbnQgc2lkZS1jaGFubmVsc1xuICogIGZyb20gYWxsb3dpbmcgb3RoZXJzIHRvIGRldGVjdCBpdCBhbmQgcHJldmVudCBvdGhlcnMgZnJvbSB0aHJvdWdoXG4gKiAgY29pbmNpZGVuY2UgZ2VuZXJhdGUgdGhlIHNhbWUgdmFsdWVzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86UmFuZG9tIFZhbHVlcyAgW2Fib3V0LWNyeXB0by1yYW5kb21dXG4gKi9cbmltcG9ydCB7IHJhbmRvbUJ5dGVzIGFzIGNyeXB0b19yYW5kb20gfSBmcm9tIFwiLi9jcnlwdG8uanNcIjtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9yYW5kb21CeXRlcyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3JhbmRvbShsZW5ndGgpKTtcbn07XG5sZXQgX19yYW5kb21CeXRlcyA9IF9yYW5kb21CeXRlcztcbi8qKlxuICogIFJldHVybiAlJWxlbmd0aCUlIGJ5dGVzIG9mIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb20gZGF0YS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICByYW5kb21CeXRlcyg4KVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMobGVuZ3RoKSB7XG4gICAgcmV0dXJuIF9fcmFuZG9tQnl0ZXMobGVuZ3RoKTtcbn1cbnJhbmRvbUJ5dGVzLl8gPSBfcmFuZG9tQnl0ZXM7XG5yYW5kb21CeXRlcy5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xucmFuZG9tQnl0ZXMucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmFuZG9tQnl0ZXMgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3JhbmRvbUJ5dGVzID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHJhbmRvbUJ5dGVzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmRvbS5qcy5tYXAiLCJpbXBvcnQgeyBudW1iZXIgYXMgYXNzZXJ0TnVtYmVyIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJy4vc2hhMjU2LmpzJztcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gJy4vcGJrZGYyLmpzJztcbmltcG9ydCB7IGFzeW5jTG9vcCwgY2hlY2tPcHRzLCB1MzIgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFJGQyA3OTE0IFNjcnlwdCBLREZcbi8vIExlZnQgcm90YXRlIGZvciB1aW50MzJcbmNvbnN0IHJvdGwgPSAoYSwgYikgPT4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpO1xuLy8gVGhlIG1haW4gU2NyeXB0IGxvb3A6IHVzZXMgU2Fsc2EgZXh0ZW5zaXZlbHkuXG4vLyBTaXggdmVyc2lvbnMgb2YgdGhlIGZ1bmN0aW9uIHdlcmUgdHJpZWQsIHRoaXMgaXMgdGhlIGZhc3Rlc3Qgb25lLlxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBYb3JBbmRTYWxzYShwcmV2LCBwaSwgaW5wdXQsIGlpLCBvdXQsIG9pKSB7XG4gICAgLy8gQmFzZWQgb24gaHR0cHM6Ly9jci55cC50by9zYWxzYTIwLmh0bWxcbiAgICAvLyBYb3IgYmxvY2tzXG4gICAgbGV0IHkwMCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTAxID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDIgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwMyA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTA0ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDUgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwNiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTA3ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDggPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwOSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTEwID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MTEgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkxMiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTEzID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MTQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICAvLyBTYXZlIHN0YXRlIHRvIHRlbXBvcmFyeSB2YXJpYWJsZXMgKHNhbHNhKVxuICAgIGxldCB4MDAgPSB5MDAsIHgwMSA9IHkwMSwgeDAyID0geTAyLCB4MDMgPSB5MDMsIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNywgeDA4ID0geTA4LCB4MDkgPSB5MDksIHgxMCA9IHkxMCwgeDExID0geTExLCB4MTIgPSB5MTIsIHgxMyA9IHkxMywgeDE0ID0geTE0LCB4MTUgPSB5MTU7XG4gICAgLy8gTWFpbiBsb29wIChzYWxzYSlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMikge1xuICAgICAgICB4MDQgXj0gcm90bCh4MDAgKyB4MTIgfCAwLCA3KTtcbiAgICAgICAgeDA4IF49IHJvdGwoeDA0ICsgeDAwIHwgMCwgOSk7XG4gICAgICAgIHgxMiBePSByb3RsKHgwOCArIHgwNCB8IDAsIDEzKTtcbiAgICAgICAgeDAwIF49IHJvdGwoeDEyICsgeDA4IHwgMCwgMTgpO1xuICAgICAgICB4MDkgXj0gcm90bCh4MDUgKyB4MDEgfCAwLCA3KTtcbiAgICAgICAgeDEzIF49IHJvdGwoeDA5ICsgeDA1IHwgMCwgOSk7XG4gICAgICAgIHgwMSBePSByb3RsKHgxMyArIHgwOSB8IDAsIDEzKTtcbiAgICAgICAgeDA1IF49IHJvdGwoeDAxICsgeDEzIHwgMCwgMTgpO1xuICAgICAgICB4MTQgXj0gcm90bCh4MTAgKyB4MDYgfCAwLCA3KTtcbiAgICAgICAgeDAyIF49IHJvdGwoeDE0ICsgeDEwIHwgMCwgOSk7XG4gICAgICAgIHgwNiBePSByb3RsKHgwMiArIHgxNCB8IDAsIDEzKTtcbiAgICAgICAgeDEwIF49IHJvdGwoeDA2ICsgeDAyIHwgMCwgMTgpO1xuICAgICAgICB4MDMgXj0gcm90bCh4MTUgKyB4MTEgfCAwLCA3KTtcbiAgICAgICAgeDA3IF49IHJvdGwoeDAzICsgeDE1IHwgMCwgOSk7XG4gICAgICAgIHgxMSBePSByb3RsKHgwNyArIHgwMyB8IDAsIDEzKTtcbiAgICAgICAgeDE1IF49IHJvdGwoeDExICsgeDA3IHwgMCwgMTgpO1xuICAgICAgICB4MDEgXj0gcm90bCh4MDAgKyB4MDMgfCAwLCA3KTtcbiAgICAgICAgeDAyIF49IHJvdGwoeDAxICsgeDAwIHwgMCwgOSk7XG4gICAgICAgIHgwMyBePSByb3RsKHgwMiArIHgwMSB8IDAsIDEzKTtcbiAgICAgICAgeDAwIF49IHJvdGwoeDAzICsgeDAyIHwgMCwgMTgpO1xuICAgICAgICB4MDYgXj0gcm90bCh4MDUgKyB4MDQgfCAwLCA3KTtcbiAgICAgICAgeDA3IF49IHJvdGwoeDA2ICsgeDA1IHwgMCwgOSk7XG4gICAgICAgIHgwNCBePSByb3RsKHgwNyArIHgwNiB8IDAsIDEzKTtcbiAgICAgICAgeDA1IF49IHJvdGwoeDA0ICsgeDA3IHwgMCwgMTgpO1xuICAgICAgICB4MTEgXj0gcm90bCh4MTAgKyB4MDkgfCAwLCA3KTtcbiAgICAgICAgeDA4IF49IHJvdGwoeDExICsgeDEwIHwgMCwgOSk7XG4gICAgICAgIHgwOSBePSByb3RsKHgwOCArIHgxMSB8IDAsIDEzKTtcbiAgICAgICAgeDEwIF49IHJvdGwoeDA5ICsgeDA4IHwgMCwgMTgpO1xuICAgICAgICB4MTIgXj0gcm90bCh4MTUgKyB4MTQgfCAwLCA3KTtcbiAgICAgICAgeDEzIF49IHJvdGwoeDEyICsgeDE1IHwgMCwgOSk7XG4gICAgICAgIHgxNCBePSByb3RsKHgxMyArIHgxMiB8IDAsIDEzKTtcbiAgICAgICAgeDE1IF49IHJvdGwoeDE0ICsgeDEzIHwgMCwgMTgpO1xuICAgIH1cbiAgICAvLyBXcml0ZSBvdXRwdXQgKHNhbHNhKVxuICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAxICsgeDAxKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMiArIHgwMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA0ICsgeDA0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNSArIHgwNSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA3ICsgeDA3KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOCArIHgwOCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEwICsgeDEwKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMSArIHgxMSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEzICsgeDEzKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNCArIHgxNCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcbn1cbmZ1bmN0aW9uIEJsb2NrTWl4KGlucHV0LCBpaSwgb3V0LCBvaSwgcikge1xuICAgIC8vIFRoZSBibG9jayBCIGlzIHIgMTI4LWJ5dGUgY2h1bmtzICh3aGljaCBpcyBlcXVpdmFsZW50IG9mIDJyIDY0LWJ5dGUgY2h1bmtzKVxuICAgIGxldCBoZWFkID0gb2kgKyAwO1xuICAgIGxldCB0YWlsID0gb2kgKyAxNiAqIHI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgICAgICBvdXRbdGFpbCArIGldID0gaW5wdXRbaWkgKyAoMiAqIHIgLSAxKSAqIDE2ICsgaV07IC8vIFgg4oaQIEJbMnLiiJIxXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjsgaSsrLCBoZWFkICs9IDE2LCBpaSArPSAxNikge1xuICAgICAgICAvLyBXZSB3cml0ZSBvZGQgJiBldmVuIFlpIGF0IHNhbWUgdGltZS4gRXZlbjogMGJYWFhYWDAgT2RkOiAgMGJYWFhYWDFcbiAgICAgICAgWG9yQW5kU2Fsc2Eob3V0LCB0YWlsLCBpbnB1dCwgaWksIG91dCwgaGVhZCk7IC8vIGhlYWRbaV0gPSBTYWxzYShibG9ja0luWzIqaV0gXiB0YWlsW2ktMV0pXG4gICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgIHRhaWwgKz0gMTY7IC8vIEZpcnN0IGl0ZXJhdGlvbiBvdmVyd3JpdGVzIHRtcCB2YWx1ZSBpbiB0YWlsXG4gICAgICAgIFhvckFuZFNhbHNhKG91dCwgaGVhZCwgaW5wdXQsIChpaSArPSAxNiksIG91dCwgdGFpbCk7IC8vIHRhaWxbaV0gPSBTYWxzYShibG9ja0luWzIqaSsxXSBeIGhlYWRbaV0pXG4gICAgfVxufVxuLy8gQ29tbW9uIHByb2xvZ3VlIGFuZCBlcGlsb2d1ZSBmb3Igc3luYy9hc3luYyBmdW5jdGlvbnNcbmZ1bmN0aW9uIHNjcnlwdEluaXQocGFzc3dvcmQsIHNhbHQsIF9vcHRzKSB7XG4gICAgLy8gTWF4bWVtIC0gMUdCKzFLQiBieSBkZWZhdWx0XG4gICAgY29uc3Qgb3B0cyA9IGNoZWNrT3B0cyh7XG4gICAgICAgIGRrTGVuOiAzMixcbiAgICAgICAgYXN5bmNUaWNrOiAxMCxcbiAgICAgICAgbWF4bWVtOiAxMDI0ICoqIDMgKyAxMDI0LFxuICAgIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBhc3luY1RpY2ssIG1heG1lbSwgb25Qcm9ncmVzcyB9ID0gb3B0cztcbiAgICBhc3NlcnROdW1iZXIoTik7XG4gICAgYXNzZXJ0TnVtYmVyKHIpO1xuICAgIGFzc2VydE51bWJlcihwKTtcbiAgICBhc3NlcnROdW1iZXIoZGtMZW4pO1xuICAgIGFzc2VydE51bWJlcihhc3luY1RpY2spO1xuICAgIGFzc2VydE51bWJlcihtYXhtZW0pO1xuICAgIGlmIChvblByb2dyZXNzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9uUHJvZ3Jlc3MgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvZ3Jlc3NDYiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICBjb25zdCBibG9ja1NpemUgPSAxMjggKiByO1xuICAgIGNvbnN0IGJsb2NrU2l6ZTMyID0gYmxvY2tTaXplIC8gNDtcbiAgICBpZiAoTiA8PSAxIHx8IChOICYgKE4gLSAxKSkgIT09IDAgfHwgTiA+PSAyICoqIChibG9ja1NpemUgLyA4KSB8fCBOID4gMiAqKiAzMikge1xuICAgICAgICAvLyBOT1RFOiB3ZSBsaW1pdCBOIHRvIGJlIGxlc3MgdGhhbiAyKiozMiBiZWNhdXNlIG9mIDMyIGJpdCB2YXJpYW50IG9mIEludGVncmlmeSBmdW5jdGlvblxuICAgICAgICAvLyBUaGVyZSBpcyBubyBKUyBlbmdpbmVzIHRoYXQgYWxsb3dzIGFsb2NhdGUgbW9yZSB0aGFuIDRHQiBwZXIgc2luZ2xlIFVpbnQ4QXJyYXkgZm9yIG5vdywgYnV0IGNhbiBjaGFuZ2UgaW4gZnV0dXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogTiBtdXN0IGJlIGxhcmdlciB0aGFuIDEsIGEgcG93ZXIgb2YgMiwgbGVzcyB0aGFuIDJeKDEyOCAqIHIgLyA4KSBhbmQgbGVzcyB0aGFuIDJeMzInKTtcbiAgICB9XG4gICAgaWYgKHAgPCAwIHx8IHAgPiAoKDIgKiogMzIgLSAxKSAqIDMyKSAvIGJsb2NrU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogcCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gKCgyXjMyIC0gMSkgKiAzMikgLyAoMTI4ICogciknKTtcbiAgICB9XG4gICAgaWYgKGRrTGVuIDwgMCB8fCBka0xlbiA+ICgyICoqIDMyIC0gMSkgKiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogZGtMZW4gc2hvdWxkIGJlIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICgyXjMyIC0gMSkgKiAzMicpO1xuICAgIH1cbiAgICBjb25zdCBtZW1Vc2VkID0gYmxvY2tTaXplICogKE4gKyBwKTtcbiAgICBpZiAobWVtVXNlZCA+IG1heG1lbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjcnlwdDogcGFyYW1ldGVycyB0b28gbGFyZ2UsICR7bWVtVXNlZH0gKDEyOCAqIHIgKiAoTiArIHApKSA+ICR7bWF4bWVtfSAobWF4bWVtKWApO1xuICAgIH1cbiAgICAvLyBbQjAuLi5CcOKIkjFdIOKGkCBQQktERjJITUFDLVNIQTI1NihQYXNzcGhyYXNlLCBTYWx0LCAxLCBibG9ja1NpemUqUGFyYWxsZWxpemF0aW9uRmFjdG9yKVxuICAgIC8vIFNpbmNlIGl0IGhhcyBvbmx5IG9uZSBpdGVyYXRpb24gdGhlcmUgaXMgbm8gcmVhc29uIHRvIHVzZSBhc3luYyB2YXJpYW50XG4gICAgY29uc3QgQiA9IHBia2RmMihzaGEyNTYsIHBhc3N3b3JkLCBzYWx0LCB7IGM6IDEsIGRrTGVuOiBibG9ja1NpemUgKiBwIH0pO1xuICAgIGNvbnN0IEIzMiA9IHUzMihCKTtcbiAgICAvLyBSZS11c2VkIGJldHdlZW4gcGFyYWxsZWwgaXRlcmF0aW9ucy4gQXJyYXkoaXRlcmF0aW9ucykgb2YgQlxuICAgIGNvbnN0IFYgPSB1MzIobmV3IFVpbnQ4QXJyYXkoYmxvY2tTaXplICogTikpO1xuICAgIGNvbnN0IHRtcCA9IHUzMihuZXcgVWludDhBcnJheShibG9ja1NpemUpKTtcbiAgICBsZXQgYmxvY2tNaXhDYiA9ICgpID0+IHsgfTtcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICBjb25zdCB0b3RhbEJsb2NrTWl4ID0gMiAqIE4gKiBwO1xuICAgICAgICAvLyBJbnZva2UgY2FsbGJhY2sgaWYgcHJvZ3Jlc3MgY2hhbmdlcyBmcm9tIDEwLjAxIHRvIDEwLjAyXG4gICAgICAgIC8vIEFsbG93cyB0byBkcmF3IHNtb290aCBwcm9ncmVzcyBiYXIgb24gdXAgdG8gOEsgc2NyZWVuXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrUGVyID0gTWF0aC5tYXgoTWF0aC5mbG9vcih0b3RhbEJsb2NrTWl4IC8gMTAwMDApLCAxKTtcbiAgICAgICAgbGV0IGJsb2NrTWl4Q250ID0gMDtcbiAgICAgICAgYmxvY2tNaXhDYiA9ICgpID0+IHtcbiAgICAgICAgICAgIGJsb2NrTWl4Q250Kys7XG4gICAgICAgICAgICBpZiAob25Qcm9ncmVzcyAmJiAoIShibG9ja01peENudCAlIGNhbGxiYWNrUGVyKSB8fCBibG9ja01peENudCA9PT0gdG90YWxCbG9ja01peCkpXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhibG9ja01peENudCAvIHRvdGFsQmxvY2tNaXgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBOLCByLCBwLCBka0xlbiwgYmxvY2tTaXplMzIsIFYsIEIzMiwgQiwgdG1wLCBibG9ja01peENiLCBhc3luY1RpY2sgfTtcbn1cbmZ1bmN0aW9uIHNjcnlwdE91dHB1dChwYXNzd29yZCwgZGtMZW4sIEIsIFYsIHRtcCkge1xuICAgIGNvbnN0IHJlcyA9IHBia2RmMihzaGEyNTYsIHBhc3N3b3JkLCBCLCB7IGM6IDEsIGRrTGVuIH0pO1xuICAgIEIuZmlsbCgwKTtcbiAgICBWLmZpbGwoMCk7XG4gICAgdG1wLmZpbGwoMCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogU2NyeXB0IEtERiBmcm9tIFJGQyA3OTE0LlxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc1xuICogQHBhcmFtIHNhbHQgLSBzYWx0XG4gKiBAcGFyYW0gb3B0cyAtIHBhcmFtZXRlcnNcbiAqIC0gYE5gIGlzIGNwdS9tZW0gd29yayBmYWN0b3IgKHBvd2VyIG9mIDIgZS5nLiAyKioxOClcbiAqIC0gYHJgIGlzIGJsb2NrIHNpemUgKDggaXMgY29tbW9uKSwgZmluZS10dW5lcyBzZXF1ZW50aWFsIG1lbW9yeSByZWFkIHNpemUgYW5kIHBlcmZvcm1hbmNlXG4gKiAtIGBwYCBpcyBwYXJhbGxlbGl6YXRpb24gZmFjdG9yICgxIGlzIGNvbW1vbilcbiAqIC0gYGRrTGVuYCBpcyBvdXRwdXQga2V5IGxlbmd0aCBpbiBieXRlcyBlLmcuIDMyLlxuICogLSBgYXN5bmNUaWNrYCAtIChkZWZhdWx0OiAxMCkgbWF4IHRpbWUgaW4gbXMgZm9yIHdoaWNoIGFzeW5jIGZ1bmN0aW9uIGNhbiBibG9jayBleGVjdXRpb25cbiAqIC0gYG1heG1lbWAgLSAoZGVmYXVsdDogYDEwMjQgKiogMyArIDEwMjRgIGFrYSAxR0IrMUtCKS4gQSBsaW1pdCB0aGF0IHRoZSBhcHAgY291bGQgdXNlIGZvciBzY3J5cHRcbiAqIC0gYG9uUHJvZ3Jlc3NgIC0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSBleGVjdXRlZCBmb3IgcHJvZ3Jlc3MgcmVwb3J0XG4gKiBAcmV0dXJucyBEZXJpdmVkIGtleVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBOLCByLCBwLCBka0xlbiwgYmxvY2tTaXplMzIsIFYsIEIzMiwgQiwgdG1wLCBibG9ja01peENiIH0gPSBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBmb3IgKGxldCBwaSA9IDA7IHBpIDwgcDsgcGkrKykge1xuICAgICAgICBjb25zdCBQaSA9IGJsb2NrU2l6ZTMyICogcGk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplMzI7IGkrKylcbiAgICAgICAgICAgIFZbaV0gPSBCMzJbUGkgKyBpXTsgLy8gVlswXSA9IEJbaV1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBOIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBCbG9ja01peChWLCBwb3MsIFYsIChwb3MgKz0gYmxvY2tTaXplMzIpLCByKTsgLy8gVltpXSA9IEJsb2NrTWl4KFZbaS0xXSk7XG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH1cbiAgICAgICAgQmxvY2tNaXgoViwgKE4gLSAxKSAqIGJsb2NrU2l6ZTMyLCBCMzIsIFBpLCByKTsgLy8gUHJvY2VzcyBsYXN0IGVsZW1lbnRcbiAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICAgICAgLy8gRmlyc3QgdTMyIG9mIHRoZSBsYXN0IDY0LWJ5dGUgYmxvY2sgKHUzMiBpcyBMRSlcbiAgICAgICAgICAgIGNvbnN0IGogPSBCMzJbUGkgKyBibG9ja1NpemUzMiAtIDE2XSAlIE47IC8vIGogPSBJbnRlZ3JpZnkoWCkgJSBpdGVyYXRpb25zXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGJsb2NrU2l6ZTMyOyBrKyspXG4gICAgICAgICAgICAgICAgdG1wW2tdID0gQjMyW1BpICsga10gXiBWW2ogKiBibG9ja1NpemUzMiArIGtdOyAvLyB0bXAgPSBCIF4gVltqXVxuICAgICAgICAgICAgQmxvY2tNaXgodG1wLCAwLCBCMzIsIFBpLCByKTsgLy8gQiA9IEJsb2NrTWl4KEIgXiBWW2pdKVxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xufVxuLyoqXG4gKiBTY3J5cHQgS0RGIGZyb20gUkZDIDc5MTQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzY3J5cHRBc3luYyhwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgTiwgciwgcCwgZGtMZW4sIGJsb2NrU2l6ZTMyLCBWLCBCMzIsIEIsIHRtcCwgYmxvY2tNaXhDYiwgYXN5bmNUaWNrIH0gPSBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBmb3IgKGxldCBwaSA9IDA7IHBpIDwgcDsgcGkrKykge1xuICAgICAgICBjb25zdCBQaSA9IGJsb2NrU2l6ZTMyICogcGk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplMzI7IGkrKylcbiAgICAgICAgICAgIFZbaV0gPSBCMzJbUGkgKyBpXTsgLy8gVlswXSA9IEJbaV1cbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChOIC0gMSwgYXN5bmNUaWNrLCAoKSA9PiB7XG4gICAgICAgICAgICBCbG9ja01peChWLCBwb3MsIFYsIChwb3MgKz0gYmxvY2tTaXplMzIpLCByKTsgLy8gVltpXSA9IEJsb2NrTWl4KFZbaS0xXSk7XG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBCbG9ja01peChWLCAoTiAtIDEpICogYmxvY2tTaXplMzIsIEIzMiwgUGksIHIpOyAvLyBQcm9jZXNzIGxhc3QgZWxlbWVudFxuICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChOLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHUzMiBvZiB0aGUgbGFzdCA2NC1ieXRlIGJsb2NrICh1MzIgaXMgTEUpXG4gICAgICAgICAgICBjb25zdCBqID0gQjMyW1BpICsgYmxvY2tTaXplMzIgLSAxNl0gJSBOOyAvLyBqID0gSW50ZWdyaWZ5KFgpICUgaXRlcmF0aW9uc1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBibG9ja1NpemUzMjsgaysrKVxuICAgICAgICAgICAgICAgIHRtcFtrXSA9IEIzMltQaSArIGtdIF4gVltqICogYmxvY2tTaXplMzIgKyBrXTsgLy8gdG1wID0gQiBeIFZbal1cbiAgICAgICAgICAgIEJsb2NrTWl4KHRtcCwgMCwgQjMyLCBQaSwgcik7IC8vIEIgPSBCbG9ja01peChCIF4gVltqXSlcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyeXB0LmpzLm1hcCIsImltcG9ydCB7IHNjcnlwdCBhcyBfbm9ibGVTeW5jLCBzY3J5cHRBc3luYyBhcyBfbm9ibGVBc3luYyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NjcnlwdFwiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgYXMgSCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZFN5bmMgPSBmYWxzZSwgbG9ja2VkQXN5bmMgPSBmYWxzZTtcbmNvbnN0IF9zY3J5cHRBc3luYyA9IGFzeW5jIGZ1bmN0aW9uIChwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBvblByb2dyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0IF9ub2JsZUFzeW5jKHBhc3N3ZCwgc2FsdCwgeyBOLCByLCBwLCBka0xlbiwgb25Qcm9ncmVzcyB9KTtcbn07XG5jb25zdCBfc2NyeXB0U3luYyA9IGZ1bmN0aW9uIChwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKSB7XG4gICAgcmV0dXJuIF9ub2JsZVN5bmMocGFzc3dkLCBzYWx0LCB7IE4sIHIsIHAsIGRrTGVuIH0pO1xufTtcbmxldCBfX3NjcnlwdEFzeW5jID0gX3NjcnlwdEFzeW5jO1xubGV0IF9fc2NyeXB0U3luYyA9IF9zY3J5cHRTeW5jO1xuLyoqXG4gKiAgVGhlIFtbbGluay13aWtpLXNjcnlwdF1dIHVzZXMgYSBtZW1vcnkgYW5kIGNwdSBoYXJkIG1ldGhvZCBvZlxuICogIGRlcml2YXRpb24gdG8gaW5jcmVhc2UgdGhlIHJlc291cmNlIGNvc3QgdG8gYnJ1dGUtZm9yY2UgYSBwYXNzd29yZFxuICogIGZvciBhIGdpdmVuIGtleS5cbiAqXG4gKiAgVGhpcyBtZWFucyB0aGlzIGFsZ29yaXRobSBpcyBpbnRlbnRpb25hbGx5IHNsb3csIGFuZCBjYW4gYmUgdHVuZWQgdG9cbiAqICBiZWNvbWUgc2xvd2VyLiBBcyBjb21wdXRhdGlvbiBhbmQgbWVtb3J5IHNwZWVkIGltcHJvdmUgb3ZlciB0aW1lLFxuICogIGluY3JlYXNpbmcgdGhlIGRpZmZpY3VsdHkgbWFpbnRhaW5zIHRoZSBjb3N0IG9mIGFuIGF0dGFja2VyLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaWYgYSB0YXJnZXQgdGltZSBvZiA1IHNlY29uZHMgaXMgdXNlZCwgYSBsZWdpdGltYXRlIHVzZXJcbiAqICB3aGljaCBrbm93cyB0aGVpciBwYXNzd29yZCByZXF1aXJlcyBvbmx5IDUgc2Vjb25kcyB0byB1bmxvY2sgdGhlaXJcbiAqICBhY2NvdW50LiBBIDYgY2hhcmFjdGVyIHBhc3N3b3JkIGhhcyA2OCBiaWxsaW9uIHBvc3NpYmlsaXRpZXMsIHdoaWNoXG4gKiAgd291bGQgcmVxdWlyZSBhbiBhdHRhY2tlciB0byBpbnZlc3Qgb3ZlciAxMCwwMDAgeWVhcnMgb2YgQ1BVIHRpbWUuIFRoaXNcbiAqICBpcyBvZiBjb3Vyc2UgYSBjcnVkZSBleGFtcGxlIChhcyBwYXNzd29yZCBnZW5lcmFsbHkgYXJlbid0IHJhbmRvbSksXG4gKiAgYnV0IGRlbW9uc3RyYXRlcyB0byB2YWx1ZSBvZiBpbXBvc2luZyBsYXJnZSBjb3N0cyB0byBkZWNyeXB0aW9uLlxuICpcbiAqICBGb3IgdGhpcyByZWFzb24sIGlmIGJ1aWxkaW5nIGEgVUkgd2hpY2ggaW52b2x2ZWQgZGVjcnlwdGluZyBvclxuICogIGVuY3J5cHRpbmcgZGF0c2EgdXNpbmcgc2NyeXB0LCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYVxuICogIFtbUHJvZ3Jlc3NDYWxsYmFja11dIChhcyBldmVudCBzaG9ydCBwZXJpb2RzIGNhbiBzZWVtIGxpayBhbiBldGVybml0eVxuICogIGlmIHRoZSBVSSBmcmVlemVzKS4gSW5jbHVkaW5nIHRoZSBwaHJhc2UgLy9cImRlY3J5cHRpbmdcIi8vIGluIHRoZSBVSVxuICogIGNhbiBhbHNvIGhlbHAsIGFzc3VyaW5nIHRoZSB1c2VyIHRoZWlyIHdhaXRpbmcgaXMgZm9yIGEgZ29vZCByZWFzb24uXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlBhc3N3b3Jkc1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBwYXNzd29yZCBtdXN0IGJlIGNvbnZlcnRlZCB0byBieXRlcywgYW5kIGl0IGlzIGdlbmVyYWxseVxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxuICogICAgLy8gZm9ybWF0cyBleHBsaWNpdGx5IGluZGljYXRlIHRoZSBub3JtYWxpemF0aW9uIGZvcm0gdG8gdXNlLlxuICogICAgcGFzc3dvcmQgPSBcImhlbGxvXCJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXG4gKlxuICogICAgc2FsdCA9IGlkKFwic29tZS1zYWx0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgc2NyeXB0XG4gKiAgICBzY3J5cHQocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgOCwgMSwgMTYpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzY3J5cHQoX3Bhc3N3ZCwgX3NhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzcykge1xuICAgIGNvbnN0IHBhc3N3ZCA9IGdldEJ5dGVzKF9wYXNzd2QsIFwicGFzc3dkXCIpO1xuICAgIGNvbnN0IHNhbHQgPSBnZXRCeXRlcyhfc2FsdCwgXCJzYWx0XCIpO1xuICAgIHJldHVybiBIKGF3YWl0IF9fc2NyeXB0QXN5bmMocGFzc3dkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3MpKTtcbn1cbnNjcnlwdC5fID0gX3NjcnlwdEFzeW5jO1xuc2NyeXB0LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZEFzeW5jID0gdHJ1ZTsgfTtcbnNjcnlwdC5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZEFzeW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjcnlwdCBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fc2NyeXB0QXN5bmMgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoc2NyeXB0KTtcbi8qKlxuICogIFByb3ZpZGVzIGEgc3luY2hyb25vdXMgdmFyaWFudCBvZiBbW3NjcnlwdF1dLlxuICpcbiAqICBUaGlzIHdpbGwgY29tcGxldGVseSBsb2NrIHVwIGFuZCBmcmVlemUgdGhlIFVJIGluIGEgYnJvd3NlciBhbmQgd2lsbFxuICogIHByZXZlbnQgYW55IGV2ZW50IGxvb3AgZnJvbSBwcm9ncmVzc2luZy4gRm9yIHRoaXMgcmVhc29uLCBpdCBpc1xuICogIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2YXJpYW50XShzY3J5cHQpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpQYXNzd29yZHNcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBUaGUgcGFzc3dvcmQgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMsIGFuZCBpdCBpcyBnZW5lcmFsbHlcbiAqICAgIC8vIGJlc3QgcHJhY3RpY2VzIHRvIGVuc3VyZSB0aGUgc3RyaW5nIGhhcyBiZWVuIG5vcm1hbGl6ZWQuIE1hbnlcbiAqICAgIC8vIGZvcm1hdHMgZXhwbGljaXRseSBpbmRpY2F0ZSB0aGUgbm9ybWFsaXphdGlvbiBmb3JtIHRvIHVzZS5cbiAqICAgIHBhc3N3b3JkID0gXCJoZWxsb1wiXG4gKiAgICBwYXNzd29yZEJ5dGVzID0gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFwiTkZLQ1wiKVxuICpcbiAqICAgIHNhbHQgPSBpZChcInNvbWUtc2FsdFwiKVxuICpcbiAqICAgIC8vIENvbXB1dGUgdGhlIHNjcnlwdFxuICogICAgc2NyeXB0U3luYyhwYXNzd29yZEJ5dGVzLCBzYWx0LCAxMDI0LCA4LCAxLCAxNilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcnlwdFN5bmMoX3Bhc3N3ZCwgX3NhbHQsIE4sIHIsIHAsIGRrTGVuKSB7XG4gICAgY29uc3QgcGFzc3dkID0gZ2V0Qnl0ZXMoX3Bhc3N3ZCwgXCJwYXNzd2RcIik7XG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XG4gICAgcmV0dXJuIEgoX19zY3J5cHRTeW5jKHBhc3N3ZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pKTtcbn1cbnNjcnlwdFN5bmMuXyA9IF9zY3J5cHRTeW5jO1xuc2NyeXB0U3luYy5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWRTeW5jID0gdHJ1ZTsgfTtcbnNjcnlwdFN5bmMucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWRTeW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjcnlwdFN5bmMgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NjcnlwdFN5bmMgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoc2NyeXB0U3luYyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3J5cHQuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gXCIuL2NyeXB0by5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IF9zaGEyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKFwic2hhMjU2XCIpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5jb25zdCBfc2hhNTEyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaChcInNoYTUxMlwiKS51cGRhdGUoZGF0YSkuZGlnZXN0KCk7XG59O1xubGV0IF9fc2hhMjU2ID0gX3NoYTI1NjtcbmxldCBfX3NoYTUxMiA9IF9zaGE1MTI7XG5sZXQgbG9ja2VkMjU2ID0gZmFsc2UsIGxvY2tlZDUxMiA9IGZhbHNlO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBTSEEyLTI1NiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBzaGEyNTYoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTI1NihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTI1NihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19zaGEyNTYoZGF0YSkpO1xufVxuc2hhMjU2Ll8gPSBfc2hhMjU2O1xuc2hhMjU2LmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZDI1NiA9IHRydWU7IH07XG5zaGEyNTYucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQyNTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hhMjU2IGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19zaGEyNTYgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoc2hhMjU2KTtcbi8qKlxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgU0hBMi01MTIgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnNcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgc2hhNTEyKFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGE1MTIoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGE1MTIobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhNTEyKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19zaGE1MTIoZGF0YSkpO1xufVxuc2hhNTEyLl8gPSBfc2hhNTEyO1xuc2hhNTEyLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZDUxMiA9IHRydWU7IH07XG5zaGE1MTIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQ1MTIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hhNTEyIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19zaGE1MTIgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoc2hhMjU2KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTIuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmltcG9ydCB7IGJpdE1hc2ssIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAobW9kdWxvIDw9IF8wbiB8fCBwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIERvZXMgeCBeICgyIF4gcG93ZXIpIG1vZCBwLiBwb3cyKDMwLCA0KSA9PSAzMCBeICgyIF4gNClcbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIFdpbGwgc3RhcnQgYW4gaW5maW5pdGUgbG9vcCBpZiBmaWVsZCBvcmRlciBQIGlzIG5vdCBwcmltZS5cbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG4gICAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xuICAgIGxldCBRLCBTLCBaO1xuICAgIC8vIFN0ZXAgMTogQnkgZmFjdG9yaW5nIG91dCBwb3dlcnMgb2YgMiBmcm9tIHAgLSAxLFxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspXG4gICAgICAgIDtcbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRmllbGQgT1JERVIgPiAwLCBnb3QgJHtPUkRFUn1gKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3Qgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZwLmZyb21CeXRlczogZXhwZWN0ZWQgJHtCWVRFU30sIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBtYXBLZXlUb0ZpZWxkIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7aGFzaExlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGhhc2gpIDogYnl0ZXNUb051bWJlckJFKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2xlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckJFKGtleSkgOiBieXRlc1RvTnVtYmVyTEUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCIsIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXG5pbXBvcnQgeyB2YWxpZGF0ZUZpZWxkLCBuTGVuZ3RoIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4vLyBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4vLyBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbi8vIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuLy8gLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4vLyAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4vLyAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4vLyAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbi8vIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbi8vIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4vLyBUT0RPOiBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuIFRoaXMgd291bGQgYWxsb3dcbi8vIHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbikge1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVGaWVsZChjdXJ2ZS5GcCk7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgbjogJ2JpZ2ludCcsXG4gICAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgICAgR3k6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5uTGVuZ3RoKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxuICAgICAgICAuLi5jdXJ2ZSxcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBzZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiLCIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIiwiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gYWRkcmVzcy5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzc2VzLmpzLm1hcCIsIi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSB6ZXJvIGhhc2guXG4gKlxuICogICgqKmkuZS4qKiBgYFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJgYClcbiAqL1xuZXhwb3J0IGNvbnN0IFplcm9IYXNoID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2hlcy5qcy5tYXAiLCIvLyBORktDIChjb21wb3NlZCkgICAgICAgICAgICAgLy8gKGRlY29tcG9zZWQpXG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgZXRoZXIgc3ltYm9sIChub3JtYWxpemVkIHVzaW5nIE5GS0MpLlxuICpcbiAqICAoKippLmUuKiogYGBcIlxcXFx1MDM5ZVwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBFdGhlclN5bWJvbCA9IFwiXFx1MDM5ZVwiOyAvLyBcIlxcdUQ4MzVcXHVERjYzXCI7XG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgW1tsaW5rLWVpcC0xOTFdXSBwZXJzb25hbCBtZXNzYWdlIHByZWZpeC5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCJcXFxceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxcXG5cImBgKVxuICovXG5leHBvcnQgY29uc3QgTWVzc2FnZVByZWZpeCA9IFwiXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG5cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwIiwiaW1wb3J0IHsgWmVyb0hhc2ggfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFMZW5ndGgsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGdldE51bWJlciwgaGV4bGlmeSwgdG9CZUFycmF5LCBpc0hleFN0cmluZywgemVyb1BhZFZhbHVlLCBhc3NlcnRBcmd1bWVudCwgYXNzZXJ0UHJpdmF0ZSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gQ29uc3RhbnRzXG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBCTl8yNyA9IEJpZ0ludCgyNyk7XG5jb25zdCBCTl8yOCA9IEJpZ0ludCgyOCk7XG5jb25zdCBCTl8zNSA9IEJpZ0ludCgzNSk7XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmZ1bmN0aW9uIHRvVWludDI1Nih2YWx1ZSkge1xuICAgIHJldHVybiB6ZXJvUGFkVmFsdWUodG9CZUFycmF5KHZhbHVlKSwgMzIpO1xufVxuLyoqXG4gKiAgQSBTaWduYXR1cmUgIEBUT0RPXG4gKlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpTaWduaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduYXR1cmUge1xuICAgICNyO1xuICAgICNzO1xuICAgICN2O1xuICAgICNuZXR3b3JrVjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBgcmBgIHZhbHVlIGZvciBhIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHJlcHJlc2VudHMgdGhlIGBgeGBgIGNvb3JkaW5hdGUgb2YgYSBcInJlZmVyZW5jZVwiIG9yXG4gICAgICogIGNoYWxsZW5nZSBwb2ludCwgZnJvbSB3aGljaCB0aGUgYGB5YGAgY2FuIGJlIGNvbXB1dGVkLlxuICAgICAqL1xuICAgIGdldCByKCkgeyByZXR1cm4gdGhpcy4jcjsgfVxuICAgIHNldCByKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgodmFsdWUpID09PSAzMiwgXCJpbnZhbGlkIHJcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3IgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHNgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IHMoKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHBhcnNlSW50KHRoaXMuI3Muc3Vic3RyaW5nKDAsIDMpKSA8IDgsIFwibm9uLWNhbm9uaWNhbCBzOyB1c2UgLl9zXCIsIFwic1wiLCB0aGlzLiNzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3M7XG4gICAgfVxuICAgIHNldCBzKF92YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKF92YWx1ZSkgPT09IDMyLCBcImludmFsaWQgc1wiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIHRoaXMuI3MgPSBoZXhsaWZ5KF92YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHMgdmFsdWUsIHVuY2hlY2tlZCBmb3IgRUlQLTIgY29tcGxpYW5jZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQgYW5kIGlzIGZvciBzaXR1YXRpb25zIHdoZXJlXG4gICAgICogIGEgbm9uLWNhbm9uaWNhbCBTIHZhbHVlIG1pZ2h0IGJlIHJlbGV2YW50LCBzdWNoIGFzIEZyb250aWVyIGJsb2Nrc1xuICAgICAqICB0aGF0IHdlcmUgbWluZWQgcHJpb3IgdG8gRUlQLTIgb3IgaW52YWxpZCBBdXRob3JpemF0aW9uIExpc3RcbiAgICAgKiAgc2lnbmF0dXJlcy5cbiAgICAgKi9cbiAgICBnZXQgX3MoKSB7IHJldHVybiB0aGlzLiNzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgU2lnbmF0dXJlIGlzIHZhbGlkIGZvciBbW2xpbmstZWlwLTJdXSBzaWduYXR1cmVzLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiAocGFyc2VJbnQodGhpcy4jcy5zdWJzdHJpbmcoMCwgMykpIDwgOCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGEgZ2l2ZW4gYGB4YGAgdmFsdWUgZm9yIGBgcmBgIGhhcyB0d28gcG9zc2libGUgdmFsdWVzIGZvclxuICAgICAqICBpdHMgY29ycmVzcG9uZGluIGBgeWBgLCB0aGUgYGB2YGAgaW5kaWNhdGVzIHdoaWNoIG9mIHRoZSB0d28gYGB5YGBcbiAgICAgKiAgdmFsdWVzIHRvIHVzZS5cbiAgICAgKlxuICAgICAqICBJdCBpcyBub3JtYWxpemVkIHRvIHRoZSB2YWx1ZXMgYGAyN2BgIG9yIGBgMjhgYCBmb3IgbGVnYWN5XG4gICAgICogIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIGdldCB2KCkgeyByZXR1cm4gdGhpcy4jdjsgfVxuICAgIHNldCB2KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHYgPSBnZXROdW1iZXIodmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHYgPT09IDI3IHx8IHYgPT09IDI4LCBcImludmFsaWQgdlwiLCBcInZcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiN2ID0gdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBFSVAtMTU1IGBgdmBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLiBGb3Igbm9uLWxlZ2FjeVxuICAgICAqICB0cmFuc2FjdGlvbnMsIHRoaXMgdmFsdWUgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IG5ldHdvcmtWKCkgeyByZXR1cm4gdGhpcy4jbmV0d29ya1Y7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIGZvciBFSVAtMTU1IGxlZ2FjeSB0cmFuc2FjdGlvbnMuIEZvciBub24tbGVnYWN5XG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbGVnYWN5Q2hhaW5JZCgpIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZ2V0Q2hhaW5JZCh2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHlQYXJpdHlgYCBmb3IgdGhlIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqICBTZWUgYGB2YGAgZm9yIG1vcmUgZGV0YWlscyBvbiBob3cgdGhpcyB2YWx1ZSBpcyB1c2VkLlxuICAgICAqL1xuICAgIGdldCB5UGFyaXR5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudiA9PT0gMjcpID8gMCA6IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yMDk4XV0gY29tcGFjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYGB5UGFyaXR5YGBcbiAgICAgKiAgYW5kIGBgc2BgIGNvbXBhY3RlZCBpbnRvIGEgc2luZ2xlIGBgYnl0ZXMzMmBgLlxuICAgICAqL1xuICAgIGdldCB5UGFyaXR5QW5kUygpIHtcbiAgICAgICAgLy8gVGhlIEVJUC0yMDk4IGNvbXBhY3QgcmVwcmVzZW50YXRpb25cbiAgICAgICAgY29uc3QgeVBhcml0eUFuZFMgPSBnZXRCeXRlcyh0aGlzLnMpO1xuICAgICAgICBpZiAodGhpcy55UGFyaXR5KSB7XG4gICAgICAgICAgICB5UGFyaXR5QW5kU1swXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHlQYXJpdHlBbmRTKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBjb21wYWN0U2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbdGhpcy5yLCB0aGlzLnlQYXJpdHlBbmRTXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbdGhpcy5yLCB0aGlzLnMsICh0aGlzLnlQYXJpdHkgPyBcIjB4MWNcIiA6IFwiMHgxYlwiKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgciwgcywgdikge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiU2lnbmF0dXJlXCIpO1xuICAgICAgICB0aGlzLiNyID0gcjtcbiAgICAgICAgdGhpcy4jcyA9IHM7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgICAgICB0aGlzLiNuZXR3b3JrViA9IG51bGw7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIGBTaWduYXR1cmUgeyByOiBcIiR7dGhpcy5yfVwiLCBzOiBcIiR7dGhpcy5fc31cIiR7dGhpcy5pc1ZhbGlkKCkgPyBcIlwiIDogJywgdmFsaWQ6IFwiZmFsc2VcIid9LCB5UGFyaXR5OiAke3RoaXMueVBhcml0eX0sIG5ldHdvcmtWOiAke3RoaXMubmV0d29ya1Z9IH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBpZGVudGljYWwgW1tTaWduYXR1cmVdXS5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgdGhpcy5yLCB0aGlzLl9zLCB0aGlzLnYpO1xuICAgICAgICBpZiAodGhpcy5uZXR3b3JrVikge1xuICAgICAgICAgICAgY2xvbmUuI25ldHdvcmtWID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggYGBKU09OLnN0cmluZ2lmeWBgLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgbmV0d29ya1YgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwic2lnbmF0dXJlXCIsXG4gICAgICAgICAgICBuZXR3b3JrVjogKChuZXR3b3JrViAhPSBudWxsKSA/IG5ldHdvcmtWLnRvU3RyaW5nKCkgOiBudWxsKSxcbiAgICAgICAgICAgIHI6IHRoaXMuciwgczogdGhpcy5fcywgdjogdGhpcy52LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgY2hhaW4gSUQgZnJvbSB0aGUgYGB2YGAgaW4gYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDUpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDYpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGFpbklkKHYpIHtcbiAgICAgICAgY29uc3QgYnYgPSBnZXRCaWdJbnQodiwgXCJ2XCIpO1xuICAgICAgICAvLyBUaGUgdiBpcyBub3QgYW4gRUlQLTE1NSB2LCBzbyBpdCBpcyB0aGUgdW5zcGVjaWZpZWQgY2hhaW4gSURcbiAgICAgICAgaWYgKChidiA9PSBCTl8yNykgfHwgKGJ2ID09IEJOXzI4KSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFkIHZhbHVlIGZvciBhbiBFSVAtMTU1IHZcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnYgPj0gQk5fMzUsIFwiaW52YWxpZCBFSVAtMTU1IHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICByZXR1cm4gKGJ2IC0gQk5fMzUpIC8gQk5fMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGBgdmBgIGZvciBhIGNoYWluIElEIGZvciBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBMZWdhY3kgdHJhbnNhY3Rpb25zIHdoaWNoIHVzZSBbW2xpbmstZWlwLTE1NV1dIGhpamFjayB0aGUgYGB2YGBcbiAgICAgKiAgcHJvcGVydHkgdG8gaW5jbHVkZSB0aGUgY2hhaW4gSUQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWRWKDUsIDI3KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyOClcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgdikge1xuICAgICAgICByZXR1cm4gKGdldEJpZ0ludChjaGFpbklkKSAqIEJOXzIpICsgQmlnSW50KDM1ICsgdiAtIDI3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIG5vcm1hbGl6ZWQgbGVnYWN5IHRyYW5zYWN0aW9uIGBgdmBgIGZyb20gYSBgYHlQYXJpcnR5YGAsXG4gICAgICogIGEgbGVnYWN5IHRyYW5zYWN0aW9uIGBgdmBgIG9yIGEgbGVnYWN5IFtbbGluay1laXAtMTU1XV0gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgLy8gVGhlIHZhbHVlcyAwIGFuZCAxIGltcGx5IHYgaXMgYWN0dWFsbHkgeVBhcml0eVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigwKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIExlZ2FjeSBub24tRUlQLTE1NTkgdHJhbnNhY3Rpb24gKGkuZS4gMjcgb3IgMjgpXG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDI3KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIExlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9uIChpLmUuID49IDM1KVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig0NilcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBJbnZhbGlkIHZhbHVlcyB0aHJvd1xuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig1KVxuICAgICAqICAgIC8vX2Vycm9yOlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXROb3JtYWxpemVkVih2KSB7XG4gICAgICAgIGNvbnN0IGJ2ID0gZ2V0QmlnSW50KHYpO1xuICAgICAgICBpZiAoYnYgPT09IEJOXzAgfHwgYnYgPT09IEJOXzI3KSB7XG4gICAgICAgICAgICByZXR1cm4gMjc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ2ID09PSBCTl8xIHx8IGJ2ID09PSBCTl8yOCkge1xuICAgICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ2ID49IEJOXzM1LCBcImludmFsaWQgdlwiLCBcInZcIiwgdik7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgRUlQLTE1NSB2IG1lYW5zIG9kZCBpcyAyNyBhbmQgZXZlbiBpcyAyOFxuICAgICAgICByZXR1cm4gKGJ2ICYgQk5fMSkgPyAyNyA6IDI4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW1NpZ25hdHVyZV1dLlxuICAgICAqXG4gICAgICogIElmIG5vICUlc2lnJSUgaXMgcHJvdmlkZWQsIGEgbmV3IFtbU2lnbmF0dXJlXV0gaXMgY3JlYXRlZFxuICAgICAqICB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlc2lnJSUgaXMgYSBzdHJpbmcsIGl0IGlzIHBhcnNlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShzaWcpIHtcbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0RXJyb3IoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBcInNpZ25hdHVyZVwiLCBzaWcpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHNpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIFplcm9IYXNoLCBaZXJvSGFzaCwgMjcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHNpZykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoc2lnLCBcInNpZ25hdHVyZVwiKTtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYnl0ZXMuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gKHNbMF0gJiAweDgwKSA/IDI4IDogMjc7XG4gICAgICAgICAgICAgICAgc1swXSAmPSAweDdmO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgaGV4bGlmeShzKSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVihieXRlc1s2NF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgcywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJpbnZhbGlkIHJhdyBzaWduYXR1cmUgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWcgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWcuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgclxuICAgICAgICBjb25zdCBfciA9IHNpZy5yO1xuICAgICAgICBhc3NlcnRFcnJvcihfciAhPSBudWxsLCBcIm1pc3NpbmcgclwiKTtcbiAgICAgICAgY29uc3QgciA9IHRvVWludDI1Nihfcik7XG4gICAgICAgIC8vIEdldCBzOyBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh3ZSBjaGVjayBjb25zaXN0ZW5jeSBiZWxvdylcbiAgICAgICAgY29uc3QgcyA9IChmdW5jdGlvbiAocywgeVBhcml0eUFuZFMpIHtcbiAgICAgICAgICAgIGlmIChzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9VaW50MjU2KHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihpc0hleFN0cmluZyh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh5UGFyaXR5QW5kUyk7XG4gICAgICAgICAgICAgICAgYnl0ZXNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJtaXNzaW5nIHNcIik7XG4gICAgICAgIH0pKHNpZy5zLCBzaWcueVBhcml0eUFuZFMpO1xuICAgICAgICAvLyBHZXQgdjsgYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAod2UgY2hlY2sgY29uc2lzdGVuY3kgYmVsb3cpXG4gICAgICAgIGNvbnN0IHsgbmV0d29ya1YsIHYgfSA9IChmdW5jdGlvbiAoX3YsIHlQYXJpdHlBbmRTLCB5UGFyaXR5KSB7XG4gICAgICAgICAgICBpZiAoX3YgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRCaWdJbnQoX3YpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtWOiAoKHYgPj0gQk5fMzUpID8gdiA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIHY6IFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVih2KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eUFuZFMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGlzSGV4U3RyaW5nKHlQYXJpdHlBbmRTLCAzMiksIFwiaW52YWxpZCB5UGFyaXR5QW5kU1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2OiAoKGdldEJ5dGVzKHlQYXJpdHlBbmRTKVswXSAmIDB4ODApID8gMjggOiAyNykgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGdldE51bWJlcih5UGFyaXR5LCBcInNpZy55UGFyaXR5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHsgdjogMjcgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4geyB2OiAyOCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJpbnZhbGlkIHlQYXJpdHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJtaXNzaW5nIHZcIik7XG4gICAgICAgIH0pKHNpZy52LCBzaWcueVBhcml0eUFuZFMsIHNpZy55UGFyaXR5KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIHMsIHYpO1xuICAgICAgICBpZiAobmV0d29ya1YpIHtcbiAgICAgICAgICAgIHJlc3VsdC4jbmV0d29ya1YgPSBuZXR3b3JrVjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBtdWx0aXBsZSBvZiB2LCB5UGFyaXR5LCB5UGFyaXR5QW5kUyB3ZSBnaXZlbiwgY2hlY2sgdGhleSBtYXRjaFxuICAgICAgICBhc3NlcnRFcnJvcihzaWcueVBhcml0eSA9PSBudWxsIHx8IGdldE51bWJlcihzaWcueVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSA9PT0gcmVzdWx0LnlQYXJpdHksIFwieVBhcml0eSBtaXNtYXRjaFwiKTtcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHlBbmRTID09IG51bGwgfHwgc2lnLnlQYXJpdHlBbmRTID09PSByZXN1bHQueVBhcml0eUFuZFMsIFwieVBhcml0eUFuZFMgbWlzbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlLmpzLm1hcCIsIi8qKlxuICogIEFkZCBkZXRhaWxzIGFib3V0IHNpZ25pbmcgaGVyZS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOlNpZ25pbmcgIFthYm91dC1zaWduaW5nXVxuICovXG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZ2V0Qnl0ZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSwgdG9CZUhleCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuL3NpZ25hdHVyZS5qc1wiO1xuLyoqXG4gKiAgQSAqKlNpZ25pbmdLZXkqKiBwcm92aWRlcyBoaWdoLWxldmVsIGFjY2VzcyB0byB0aGUgZWxsaXB0aWMgY3VydmVcbiAqICBjcnlwdG9ncmFwaHkgKEVDQykgb3BlcmF0aW9ucyBhbmQga2V5IG1hbmFnZW1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduaW5nS2V5IHtcbiAgICAjcHJpdmF0ZUtleTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlNpZ25pbmdLZXkqKiBmb3IgJSVwcml2YXRlS2V5JSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZUtleSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKHByaXZhdGVLZXkpID09PSAzMiwgXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI3ByaXZhdGVLZXkgPSBoZXhsaWZ5KHByaXZhdGVLZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHByaXZhdGUga2V5LlxuICAgICAqL1xuICAgIGdldCBwcml2YXRlS2V5KCkgeyByZXR1cm4gdGhpcy4jcHJpdmF0ZUtleTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgYWx3YXlzIGJlZ2luIHdpdGggdGhlIHByZWZpeCBgYDB4MDRgYCBhbmQgYmUgMTMyXG4gICAgICogY2hhcmFjdGVycyBsb25nICh0aGUgYGAweGBgIHByZWZpeCBhbmQgMTMwIGhleGFkZWNpbWFsIG5pYmJsZXMpLlxuICAgICAqL1xuICAgIGdldCBwdWJsaWNLZXkoKSB7IHJldHVybiBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkodGhpcy4jcHJpdmF0ZUtleSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYWx3YXlzIGJlZ2luIHdpdGggZWl0aGVyIHRoZSBwcmVmaXggYGAweDAyYGAgb3IgYGAweDAzYGBcbiAgICAgKiAgYW5kIGJlIDY4IGNoYXJhY3RlcnMgbG9uZyAodGhlIGBgMHhgYCBwcmVmaXggYW5kIDMzIGhleGFkZWNpbWFsXG4gICAgICogIG5pYmJsZXMpXG4gICAgICovXG4gICAgZ2V0IGNvbXByZXNzZWRQdWJsaWNLZXkoKSB7IHJldHVybiBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkodGhpcy4jcHJpdmF0ZUtleSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCAlJWRpZ2VzdCUlLlxuICAgICAqL1xuICAgIHNpZ24oZGlnZXN0KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgoZGlnZXN0KSA9PT0gMzIsIFwiaW52YWxpZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNlY3AyNTZrMS5zaWduKGdldEJ5dGVzQ29weShkaWdlc3QpLCBnZXRCeXRlc0NvcHkodGhpcy4jcHJpdmF0ZUtleSksIHtcbiAgICAgICAgICAgIGxvd1M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiB0b0JlSGV4KHNpZy5yLCAzMiksXG4gICAgICAgICAgICBzOiB0b0JlSGV4KHNpZy5zLCAzMiksXG4gICAgICAgICAgICB2OiAoc2lnLnJlY292ZXJ5ID8gMHgxYyA6IDB4MWIpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgW1tsaW5rLXdpa2ktZWNkaF1dIHNoYXJlZCBzZWNyZXQgYmV0d2VlbiB0aGlzXG4gICAgICogIHByaXZhdGUga2V5IGFuZCB0aGUgJSVvdGhlciUlIGtleS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVvdGhlciUlIGtleSBtYXkgYmUgYW55IHR5cGUgb2Yga2V5LCBhIHJhdyBwdWJsaWMga2V5LFxuICAgICAqICBhIGNvbXByZXNzZWQvdW5jb21wcmVzc2VkIHB1YmljIGtleSBvciBhcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiAgQmVzdCBwcmFjdGljZSBpcyB1c3VhbGx5IHRvIHVzZSBhIGNyeXB0b2dyYXBoaWMgaGFzaCBvbiB0aGVcbiAgICAgKiAgcmV0dXJuZWQgdmFsdWUgYmVmb3JlIHVzaW5nIGl0IGFzIGEgc3ltZXRyaWMgc2VjcmV0LlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIHNpZ24xID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldC0xXCIpKVxuICAgICAqICAgIHNpZ24yID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldC0yXCIpKVxuICAgICAqXG4gICAgICogICAgLy8gTm90aWNlIHRoYXQgcHJpdkEuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJCKS4uLlxuICAgICAqICAgIHNpZ24xLmNvbXB1dGVTaGFyZWRTZWNyZXQoc2lnbjIucHVibGljS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHByaXZCLmNvbXB1dGVTaGFyZWRTZWNyZXQocHViQSkuXG4gICAgICogICAgc2lnbjIuY29tcHV0ZVNoYXJlZFNlY3JldChzaWduMS5wdWJsaWNLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIGNvbXB1dGVTaGFyZWRTZWNyZXQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgcHViS2V5ID0gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KG90aGVyKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChnZXRCeXRlc0NvcHkodGhpcy4jcHJpdmF0ZUtleSksIGdldEJ5dGVzKHB1YktleSksIGZhbHNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBwdWJsaWMga2V5IGZvciAlJWtleSUlLCBvcHRpb25hbGx5ICUlY29tcHJlc3NlZCUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJWtleSUlIG1heSBiZSBhbnkgdHlwZSBvZiBrZXksIGEgcmF3IHB1YmxpYyBrZXksIGFcbiAgICAgKiAgY29tcHJlc3NlZC91bmNvbXByZXNzZWQgcHVibGljIGtleSBvciBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBzaWduID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldFwiKSk7XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnByaXZhdGVLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgY29tcHJlc3NlZCBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHJpdmF0ZUtleSwgdHJ1ZSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnB1YmxpY0tleSwgZmFsc2UpO1xuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIENvbXByZXNzZWQgYSBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHVibGljS2V5LCB0cnVlKTtcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgc3RhdGljIGNvbXB1dGVQdWJsaWNLZXkoa2V5LCBjb21wcmVzc2VkKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGdldEJ5dGVzKGtleSwgXCJrZXlcIik7XG4gICAgICAgIC8vIHByaXZhdGUga2V5XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwMjU2azEuZ2V0UHVibGljS2V5KGJ5dGVzLCAhIWNvbXByZXNzZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocHViS2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByYXcgcHVibGljIGtleTsgdXNlIHVuY29tcHJlc3NlZCBrZXkgd2l0aCAweDA0IHByZWZpeFxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgY29uc3QgcHViID0gbmV3IFVpbnQ4QXJyYXkoNjUpO1xuICAgICAgICAgICAgcHViWzBdID0gMHgwNDtcbiAgICAgICAgICAgIHB1Yi5zZXQoYnl0ZXMsIDEpO1xuICAgICAgICAgICAgYnl0ZXMgPSBwdWI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShwb2ludC50b1Jhd0J5dGVzKGNvbXByZXNzZWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHB1YmxpYyBrZXkgZm9yIHRoZSBwcml2YXRlIGtleSB3aGljaCBwcm9kdWNlZCB0aGVcbiAgICAgKiAgJSVzaWduYXR1cmUlJSBmb3IgdGhlIGdpdmVuICUlZGlnZXN0JSUuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAga2V5ID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldFwiKSlcbiAgICAgKiAgICBkaWdlc3QgPSBpZChcImhlbGxvIHdvcmxkXCIpXG4gICAgICogICAgc2lnID0ga2V5LnNpZ24oZGlnZXN0KVxuICAgICAqXG4gICAgICogICAgLy8gTm90aWNlIHRoZSBzaWduZXIgcHVibGljIGtleS4uLlxuICAgICAqICAgIGtleS5wdWJsaWNLZXlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyAuLi5pcyBlcXVhbCB0byB0aGUgcmVjb3ZlcmVkIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWcpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChkaWdlc3QpID09PSAzMiwgXCJpbnZhbGlkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgY29uc3Qgc2lnID0gU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKTtcbiAgICAgICAgbGV0IHNlY3BTaWcgPSBzZWNwMjU2azEuU2lnbmF0dXJlLmZyb21Db21wYWN0KGdldEJ5dGVzQ29weShjb25jYXQoW3NpZy5yLCBzaWcuc10pKSk7XG4gICAgICAgIHNlY3BTaWcgPSBzZWNwU2lnLmFkZFJlY292ZXJ5Qml0KHNpZy55UGFyaXR5KTtcbiAgICAgICAgY29uc3QgcHViS2V5ID0gc2VjcFNpZy5yZWNvdmVyUHVibGljS2V5KGdldEJ5dGVzQ29weShkaWdlc3QpKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHViS2V5ICE9IG51bGwsIFwiaW52YWxpZCBzaWduYXR1cmUgZm9yIGRpZ2VzdFwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4gXCIweFwiICsgcHViS2V5LnRvSGV4KGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHBvaW50IHJlc3VsdGluZyBmcm9tIGFkZGluZyB0aGUgZWxsaXBpYyBjdXJ2ZSBwb2ludHNcbiAgICAgKiAgJSVwMCUlIGFuZCAlJXAxJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub3QgYSBjb21tb24gZnVuY3Rpb24gbW9zdCBkZXZlbG9wZXJzIHNob3VsZCByZXF1aXJlLCBidXRcbiAgICAgKiAgY2FuIGJlIHVzZWZ1bCBmb3IgY2VydGFpbiBwcml2YWN5LXNwZWNpZmljIHRlY2huaXF1ZXMuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGl0IGlzIHVzZWQgYnkgW1tIRE5vZGVXYWxsZXRdXSB0byBjb21wdXRlIGNoaWxkXG4gICAgICogIGFkZHJlc3NlcyBmcm9tIHBhcmVudCBwdWJsaWMga2V5cyBhbmQgY2hhaW4gY29kZXMuXG4gICAgICovXG4gICAgc3RhdGljIGFkZFBvaW50cyhwMCwgcDEsIGNvbXByZXNzZWQpIHtcbiAgICAgICAgY29uc3QgcHViMCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkocDApLnN1YnN0cmluZygyKSk7XG4gICAgICAgIGNvbnN0IHB1YjEgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHAxKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICByZXR1cm4gXCIweFwiICsgcHViMC5hZGQocHViMSkudG9IZXgoISFjb21wcmVzc2VkKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduaW5nLWtleS5qcy5tYXAiLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8zNiA9IEJpZ0ludCgzNik7XG5mdW5jdGlvbiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICAgIC8vICAgIGlmICghaXNIZXhTdHJpbmcoYWRkcmVzcywgMjApKSB7XG4gICAgLy8gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIC8vICAgIH1cbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGNoYXJzID0gYWRkcmVzcy5zdWJzdHJpbmcoMikuc3BsaXQoXCJcIik7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBuZXcgVWludDhBcnJheSg0MCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSsrKSB7XG4gICAgICAgIGV4cGFuZGVkW2ldID0gY2hhcnNbaV0uY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVkID0gZ2V0Qnl0ZXMoa2VjY2FrMjU2KGV4cGFuZGVkKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSArPSAyKSB7XG4gICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gPj4gNCkgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaV0gPSBjaGFyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gJiAweDBmKSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgY2hhcnMuam9pbihcIlwiKTtcbn1cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJuYXRpb25hbF9CYW5rX0FjY291bnRfTnVtYmVyXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlXG5jb25zdCBpYmFuTG9va3VwID0ge307XG5mb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICBpYmFuTG9va3VwW1N0cmluZyhpKV0gPSBTdHJpbmcoaSk7XG59XG5mb3IgKGxldCBpID0gMDsgaSA8IDI2OyBpKyspIHtcbiAgICBpYmFuTG9va3VwW1N0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBpKV0gPSBTdHJpbmcoMTAgKyBpKTtcbn1cbi8vIEhvdyBtYW55IGRlY2ltYWwgZGlnaXRzIGNhbiB3ZSBwcm9jZXNzPyAoZm9yIDY0LWJpdCBmbG9hdCwgdGhpcyBpcyAxNSlcbi8vIGkuZS4gTWF0aC5mbG9vcihNYXRoLmxvZzEwKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSk7XG5jb25zdCBzYWZlRGlnaXRzID0gMTU7XG5mdW5jdGlvbiBpYmFuQ2hlY2tzdW0oYWRkcmVzcykge1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvVXBwZXJDYXNlKCk7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3Muc3Vic3RyaW5nKDQpICsgYWRkcmVzcy5zdWJzdHJpbmcoMCwgMikgKyBcIjAwXCI7XG4gICAgbGV0IGV4cGFuZGVkID0gYWRkcmVzcy5zcGxpdChcIlwiKS5tYXAoKGMpID0+IHsgcmV0dXJuIGliYW5Mb29rdXBbY107IH0pLmpvaW4oXCJcIik7XG4gICAgLy8gSmF2YXNjcmlwdCBjYW4gaGFuZGxlIGludGVnZXJzIHNhZmVseSB1cCB0byAxNSAoZGVjaW1hbCkgZGlnaXRzXG4gICAgd2hpbGUgKGV4cGFuZGVkLmxlbmd0aCA+PSBzYWZlRGlnaXRzKSB7XG4gICAgICAgIGxldCBibG9jayA9IGV4cGFuZGVkLnN1YnN0cmluZygwLCBzYWZlRGlnaXRzKTtcbiAgICAgICAgZXhwYW5kZWQgPSBwYXJzZUludChibG9jaywgMTApICUgOTcgKyBleHBhbmRlZC5zdWJzdHJpbmcoYmxvY2subGVuZ3RoKTtcbiAgICB9XG4gICAgbGV0IGNoZWNrc3VtID0gU3RyaW5nKDk4IC0gKHBhcnNlSW50KGV4cGFuZGVkLCAxMCkgJSA5NykpO1xuICAgIHdoaWxlIChjaGVja3N1bS5sZW5ndGggPCAyKSB7XG4gICAgICAgIGNoZWNrc3VtID0gXCIwXCIgKyBjaGVja3N1bTtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrc3VtO1xufVxuO1xuY29uc3QgQmFzZTM2ID0gKGZ1bmN0aW9uICgpIHtcbiAgICA7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzNjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCJbaV07XG4gICAgICAgIHJlc3VsdFtrZXldID0gQmlnSW50KGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufSkoKTtcbmZ1bmN0aW9uIGZyb21CYXNlMzYodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IHJlc3VsdCA9IEJOXzA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgKiBCTl8zNiArIEJhc2UzNlt2YWx1ZVtpXV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgbm9ybWFsaXplZCBhbmQgY2hlY2tzdW1lZCBhZGRyZXNzIGZvciAlJWFkZHJlc3MlJS5cbiAqICBUaGlzIGFjY2VwdHMgbm9uLWNoZWNrc3VtIGFkZHJlc3NlcywgY2hlY2tzdW0gYWRkcmVzc2VzIGFuZFxuICogIFtbZ2V0SWNhcEFkZHJlc3NdXSBmb3JtYXRzLlxuICpcbiAqICBUaGUgY2hlY2tzdW0gaW4gRXRoZXJldW0gdXNlcyB0aGUgY2FwaXRhbGl6YXRpb24gKHVwcGVyLWNhc2VcbiAqICB2cyBsb3dlci1jYXNlKSBvZiB0aGUgY2hhcmFjdGVycyB3aXRoaW4gYW4gYWRkcmVzcyB0byBlbmNvZGVcbiAqICBpdHMgY2hlY2tzdW0sIHdoaWNoIG9mZmVycywgb24gYXZlcmFnZSwgYSBjaGVja3N1bSBvZiAxNS1iaXRzLlxuICpcbiAqICBJZiAlJWFkZHJlc3MlJSBjb250YWlucyBib3RoIHVwcGVyLWNhc2UgYW5kIGxvd2VyLWNhc2UsIGl0IGlzXG4gKiAgYXNzdW1lZCB0byBhbHJlYWR5IGJlIGEgY2hlY2tzdW0gYWRkcmVzcyBhbmQgaXRzIGNoZWNrc3VtIGlzXG4gKiAgdmFsaWRhdGVkLCBhbmQgaWYgdGhlIGFkZHJlc3MgZmFpbHMgaXRzIGV4cGVjdGVkIGNoZWNrc3VtIGFuXG4gKiAgZXJyb3IgaXMgdGhyb3duLlxuICpcbiAqICBJZiB5b3Ugd2lzaCB0aGUgY2hlY2tzdW0gb2YgJSVhZGRyZXNzJSUgdG8gYmUgaWdub3JlLCBpdCBzaG91bGRcbiAqICBiZSBjb252ZXJ0ZWQgdG8gbG93ZXItY2FzZSAoaS5lLiBgYC50b0xvd2VyY2FzZSgpYGApIGJlZm9yZVxuICogIGJlaW5nIHBhc3NlZCBpbi4gVGhpcyBzaG91bGQgYmUgYSB2ZXJ5IHJhcmUgc2l0dWF0aW9uIHRob3VnaCxcbiAqICB0aGF0IHlvdSB3aXNoIHRvIGJ5cGFzcyB0aGUgc2FmZWdhdXJkcyBpbiBwbGFjZSB0byBwcm90ZWN0XG4gKiAgYWdhaW5zdCBhbiBhZGRyZXNzIHRoYXQgaGFzIGJlZW4gaW5jb3JyZWN0bHkgY29waWVkIGZyb20gYW5vdGhlclxuICogIHNvdXJjZS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBBZGRzIHRoZSBjaGVja3N1bSAodmlhIHVwcGVyLWNhc2luZyBzcGVjaWZpYyBsZXR0ZXJzKVxuICogICAgZ2V0QWRkcmVzcyhcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIENvbnZlcnRzIElDQVAgYWRkcmVzcyBhbmQgYWRkcyBjaGVja3N1bVxuICogICAgZ2V0QWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpO1xuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBhbiBhZGRyZXNzIGNvbnRhaW5zIG1peGVkIGNhc2UsXG4gKiAgICAvLyBidXQgdGhlIGNoZWNrc3VtIGZhaWxzXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoYWRkcmVzcykgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKSB7XG4gICAgICAgIC8vIE1pc3NpbmcgdGhlIDB4IHByZWZpeFxuICAgICAgICBpZiAoIWFkZHJlc3Muc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gXCIweFwiICsgYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIC8vIEl0IGlzIGEgY2hlY2tzdW1tZWQgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFhZGRyZXNzLm1hdGNoKC8oW0EtRl0uKlthLWZdKXwoW2EtZl0uKltBLUZdKS8pIHx8IHJlc3VsdCA9PT0gYWRkcmVzcywgXCJiYWQgYWRkcmVzcyBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIE1heWJlIElDQVA/ICh3ZSBvbmx5IHN1cHBvcnQgZGlyZWN0IG1vZGUpXG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL15YRVswLTldezJ9WzAtOUEtWmEtel17MzAsMzF9JC8pKSB7XG4gICAgICAgIC8vIEl0IGlzIGFuIElDQVAgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGFkZHJlc3Muc3Vic3RyaW5nKDIsIDQpID09PSBpYmFuQ2hlY2tzdW0oYWRkcmVzcyksIFwiYmFkIGljYXAgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZnJvbUJhc2UzNihhZGRyZXNzLnN1YnN0cmluZyg0KSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDQwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tzdW1BZGRyZXNzKFwiMHhcIiArIHJlc3VsdCk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG59XG4vKipcbiAqICBUaGUgW0lDQVAgQWRkcmVzcyBmb3JtYXRdKGxpbmstaWNhcCkgZm9ybWF0IGlzIGFuIGVhcmx5IGNoZWNrc3VtXG4gKiAgZm9ybWF0IHdoaWNoIGF0dGVtcHRzIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgYmFua2luZ1xuICogIGluZHVzdHJ5IFtJQkFOIGZvcm1hdF0obGluay13aWtpLWliYW4pIGZvciBiYW5rIGFjY291bnRzLlxuICpcbiAqICBJdCBpcyBubyBsb25nZXIgY29tbW9uIG9yIGEgcmVjb21tZW5kZWQgZm9ybWF0LlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpO1xuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBJQ0FQIGNoZWNrc3VtIGlzIHdyb25nXG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM3XCIpO1xuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJY2FwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgLy9sZXQgYmFzZTM2ID0gX2Jhc2UxNlRvMzYoZ2V0QWRkcmVzcyhhZGRyZXNzKS5zdWJzdHJpbmcoMikpLnRvVXBwZXJDYXNlKCk7XG4gICAgbGV0IGJhc2UzNiA9IEJpZ0ludChnZXRBZGRyZXNzKGFkZHJlc3MpKS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKTtcbiAgICB3aGlsZSAoYmFzZTM2Lmxlbmd0aCA8IDMwKSB7XG4gICAgICAgIGJhc2UzNiA9IFwiMFwiICsgYmFzZTM2O1xuICAgIH1cbiAgICByZXR1cm4gXCJYRVwiICsgaWJhbkNoZWNrc3VtKFwiWEUwMFwiICsgYmFzZTM2KSArIGJhc2UzNjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIiwiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhU2xpY2UsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGVuY29kZVJscCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBhIGBgQ1JFQVRFYGAgZm9yICUldHglJS5cbiAqXG4gKiAgVGhpcyBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGFuIEVPQSB3aGVuIHNlbmRpbmcgYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uIChpLmUuXG4gKiAgd2hlbiB0aGUgYGB0b2BgIGFkZHJlc3MgaXMgYGBudWxsYGApLlxuICpcbiAqICBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcyBhIGNvbnRyYWN0IHdpbGwgYmVcbiAqICBkZXBsb3llZCB0byBieSBhIGNvbnRyYWN0LCBieSB1c2luZyB0aGUgY29udHJhY3QncyBhZGRyZXNzIGFzIHRoZVxuICogIGBgdG9gYCBhbmQgdGhlIGNvbnRyYWN0J3Mgbm9uY2UuXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBmcm9tID0gXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIjtcbiAqICAgIG5vbmNlID0gNTtcbiAqXG4gKiAgICBnZXRDcmVhdGVBZGRyZXNzKHsgZnJvbSwgbm9uY2UgfSk7XG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGVBZGRyZXNzKHR4KSB7XG4gICAgY29uc3QgZnJvbSA9IGdldEFkZHJlc3ModHguZnJvbSk7XG4gICAgY29uc3Qgbm9uY2UgPSBnZXRCaWdJbnQodHgubm9uY2UsIFwidHgubm9uY2VcIik7XG4gICAgbGV0IG5vbmNlSGV4ID0gbm9uY2UudG9TdHJpbmcoMTYpO1xuICAgIGlmIChub25jZUhleCA9PT0gXCIwXCIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vbmNlSGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4MFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIiArIG5vbmNlSGV4O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhU2xpY2Uoa2VjY2FrMjU2KGVuY29kZVJscChbZnJvbSwgbm9uY2VIZXhdKSksIDEyKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURTJgYCBvcGVyYXRpb25cbiAqICB3aXRoIHRoZSBnaXZlbiAlJWZyb20lJSwgJSVzYWx0JSUgYW5kICUlaW5pdENvZGVIYXNoJSUuXG4gKlxuICogIFRvIGNvbXB1dGUgdGhlICUlaW5pdENvZGVIYXNoJSUgZnJvbSBhIGNvbnRyYWN0J3MgaW5pdCBjb2RlLCB1c2VcbiAqICB0aGUgW1trZWNjYWsyNTZdXSBmdW5jdGlvbi5cbiAqXG4gKiAgRm9yIGEgcXVpY2sgb3ZlcnZpZXcgYW5kIGV4YW1wbGUgb2YgYGBDUkVBVEUyYGAsIHNlZSBbW2xpbmstcmljbW9vLXdpc3BzXV0uXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3RcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiXG4gKlxuICogICAgLy8gVGhlIHNhbHRcbiAqICAgIHNhbHQgPSBpZChcIkhlbGxvV29ybGRcIilcbiAqXG4gKiAgICAvLyBUaGUgaGFzaCBvZiB0aGUgaW5pdENvZGVcbiAqICAgIGluaXRDb2RlID0gXCIweDYzOTQxOThkZjE2MDAwNTI2MTAzZmY2MDIwNjAwNDYwMWMzMzVhZmE2MDQwNTE2MDYwZjNcIjtcbiAqICAgIGluaXRDb2RlSGFzaCA9IGtlY2NhazI1Nihpbml0Q29kZSlcbiAqXG4gKiAgICBnZXRDcmVhdGUyQWRkcmVzcyhmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2gpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhfZnJvbSwgX3NhbHQsIF9pbml0Q29kZUhhc2gpIHtcbiAgICBjb25zdCBmcm9tID0gZ2V0QWRkcmVzcyhfZnJvbSk7XG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XG4gICAgY29uc3QgaW5pdENvZGVIYXNoID0gZ2V0Qnl0ZXMoX2luaXRDb2RlSGFzaCwgXCJpbml0Q29kZUhhc2hcIik7XG4gICAgYXNzZXJ0QXJndW1lbnQoc2FsdC5sZW5ndGggPT09IDMyLCBcInNhbHQgbXVzdCBiZSAzMiBieXRlc1wiLCBcInNhbHRcIiwgX3NhbHQpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluaXRDb2RlSGFzaC5sZW5ndGggPT09IDMyLCBcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIF9pbml0Q29kZUhhc2gpO1xuICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtcIjB4ZmZcIiwgZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QtYWRkcmVzcy5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzcy5qc1wiO1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBvYmplY3Qgd2hpY2ggaW1wbGVtZW50cyB0aGVcbiAqICBbW0FkZHJlc3NhYmxlXV0gaW50ZXJmYWNlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFdhbGxldHMgYW5kIEFic3RyYWN0U2lnbmVyIHN1Yi1jbGFzc2VzXG4gKiAgICBpc0FkZHJlc3NhYmxlKFdhbGxldC5jcmVhdGVSYW5kb20oKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBDb250cmFjdHNcbiAqICAgIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIFsgXSwgcHJvdmlkZXIpXG4gKiAgICBpc0FkZHJlc3NhYmxlKGNvbnRyYWN0KVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5nZXRBZGRyZXNzKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCBhZGRyZXNzLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFZhbGlkIGFkZHJlc3NcbiAqICAgIGlzQWRkcmVzcyhcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFZhbGlkIElDQVAgYWRkcmVzc1xuICogICAgaXNBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBJbnZhbGlkIGNoZWNrc3VtXG4gKiAgICBpc0FkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJhNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBJbnZhbGlkIElDQVAgY2hlY2tzdW1cbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIE5vdCBhbiBhZGRyZXNzIChhbiBFTlMgbmFtZSByZXF1aXJlcyBhIHByb3ZpZGVkIGFuZCBhblxuICogICAgLy8gYXN5bmNocm9ub3VzIEFQSSB0byBhY2Nlc3MpXG4gKiAgICBpc0FkZHJlc3MoXCJyaWNtb28uZXRoXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3ModmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBnZXRBZGRyZXNzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuYXN5bmMgZnVuY3Rpb24gY2hlY2tBZGRyZXNzKHRhcmdldCwgcHJvbWlzZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb21pc2U7XG4gICAgaWYgKHJlc3VsdCA9PSBudWxsIHx8IHJlc3VsdCA9PT0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikge1xuICAgICAgICBhc3NlcnQodHlwZW9mICh0YXJnZXQpICE9PSBcInN0cmluZ1wiLCBcInVuY29uZmlndXJlZCBuYW1lXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwgeyB2YWx1ZTogdGFyZ2V0IH0pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIEFkZHJlc3NMaWtlIHZhbHVlOyBkaWQgbm90IHJlc29sdmUgdG8gYSB2YWx1ZSBhZGRyZXNzXCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKHJlc3VsdCk7XG59XG4vKipcbiAqICBSZXNvbHZlcyB0byBhbiBhZGRyZXNzIGZvciB0aGUgJSV0YXJnZXQlJSwgd2hpY2ggbWF5IGJlIGFueVxuICogIHN1cHBvcnRlZCBhZGRyZXNzIHR5cGUsIGFuIFtbQWRkcmVzc2FibGVdXSBvciBhIFByb21pc2Ugd2hpY2hcbiAqICByZXNvbHZlcyB0byBhbiBhZGRyZXNzLlxuICpcbiAqICBJZiBhbiBFTlMgbmFtZSBpcyBwcm92aWRlZCwgYnV0IHRoYXQgbmFtZSBoYXMgbm90IGJlZW4gY29ycmVjdGx5XG4gKiAgY29uZmlndXJlZCBhIFtbVW5jb25maWd1cmVkTmFtZUVycm9yXV0gaXMgdGhyb3duLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGFkZHIgPSBcIjB4NkIxNzU0NzRFODkwOTRDNDREYTk4Yjk1NEVlZGVBQzQ5NTI3MWQwRlwiXG4gKlxuICogICAgLy8gQWRkcmVzc2VzIGFyZSByZXR1cm4gc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoYWRkciwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQWRkcmVzcyBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKFByb21pc2UucmVzb2x2ZShhZGRyKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBFTlMgbmFtZXMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhcImRhaS50b2tlbnMuZXRoZXJzLmV0aFwiLCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBBZGRyZXNzYWJsZSBvYmplY3RzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoYWRkciwgWyBdKVxuICogICAgcmVzb2x2ZUFkZHJlc3MoY29udHJhY3QsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFVuY29uZmlndXJlZCBFTlMgbmFtZXMgcmVqZWN0XG4gKiAgICByZXNvbHZlQWRkcmVzcyhcIm5vdGhpbmctaGVyZS5yaWNtb28uZXRoXCIsIHByb3ZpZGVyKVxuICogICAgLy9fZXJyb3I6XG4gKlxuICogICAgLy8gRU5TIG5hbWVzIHJlcXVpcmUgYSBOYW1lUmVzb2x2ZXIgb2JqZWN0IHBhc3NlZCBpblxuICogICAgLy8gKG5vdGljZSB0aGUgcHJvdmlkZXIgd2FzIG9taXR0ZWQpXG4gKiAgICByZXNvbHZlQWRkcmVzcyhcIm5vdGhpbmctaGVyZS5yaWNtb28uZXRoXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVBZGRyZXNzKHRhcmdldCwgcmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0YXJnZXQubWF0Y2goL14weFswLTlhLWZdezQwfSQvaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KHJlc29sdmVyICE9IG51bGwsIFwiRU5TIHJlc29sdXRpb24gcmVxdWlyZXMgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiIH0pO1xuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgcmVzb2x2ZXIucmVzb2x2ZU5hbWUodGFyZ2V0KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQWRkcmVzc2FibGUodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgdGFyZ2V0LmdldEFkZHJlc3MoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhcmdldCAmJiB0eXBlb2YgKHRhcmdldC50aGVuKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBhZGRyZXNzYWJsZSB2YWx1ZVwiLCBcInRhcmdldFwiLCB0YXJnZXQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tzLmpzLm1hcCIsIi8qKlxuICogIEEgVHlwZWQgb2JqZWN0IGFsbG93cyBhIHZhbHVlIHRvIGhhdmUgaXRzIHR5cGUgZXhwbGljaXRseVxuICogIHNwZWNpZmllZC5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGluIFNvbGlkaXR5LCB0aGUgdmFsdWUgYGA0NWBgIGNvdWxkIHJlcHJlc2VudCBhXG4gKiAgYGB1aW50OGBgIG9yIGEgYGB1aW50MjU2YGAuIFRoZSB2YWx1ZSBgYDB4MTIzNGBgIGNvdWxkIHJlcHJlc2VudFxuICogIGEgYGBieXRlczJgYCBvciBgYGJ5dGVzYGAuXG4gKlxuICogIFNpbmNlIEphdmFTY3JpcHQgaGFzIG5vIG1lYW5pbmdmdWwgd2F5IHRvIGV4cGxpY2l0bHkgaW5mb3JtIGFueVxuICogIEFQSXMgd2hpY2ggd2hhdCB0aGUgdHlwZSBpcywgdGhpcyBhbGxvd3MgdHJhbnNwYXJlbnQgaW50ZXJvcGVyYXRpb25cbiAqICB3aXRoIFNvbGRpdHkuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2FiaTpUeXBlZCBWYWx1ZXNcbiAqL1xuaW1wb3J0IHsgYXNzZXJ0UHJpdmF0ZSwgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgX2dhdXJkID0ge307XG5mdW5jdGlvbiBuKHZhbHVlLCB3aWR0aCkge1xuICAgIGxldCBzaWduZWQgPSBmYWxzZTtcbiAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgIHNpZ25lZCA9IHRydWU7XG4gICAgICAgIHdpZHRoICo9IC0xO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQ2hlY2sgcmFuZ2UgaXMgdmFsaWQgZm9yIHZhbHVlXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGAke3NpZ25lZCA/IFwiXCIgOiBcInVcIn1pbnQke3dpZHRofWAsIHZhbHVlLCB7IHNpZ25lZCwgd2lkdGggfSk7XG59XG5mdW5jdGlvbiBiKHZhbHVlLCBzaXplKSB7XG4gICAgLy8gQFRPRE86IENoZWNrIHJhbmdlIGlzIHZhbGlkIGZvciB2YWx1ZVxuICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBgYnl0ZXMkeyhzaXplKSA/IHNpemUgOiBcIlwifWAsIHZhbHVlLCB7IHNpemUgfSk7XG59XG5jb25zdCBfdHlwZWRTeW1ib2wgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc190eXBlZFwiKTtcbi8qKlxuICogIFRoZSAqKlR5cGVkKiogY2xhc3MgdG8gd3JhcCB2YWx1ZXMgcHJvdmlkaW5nIGV4cGxpY2l0IHR5cGUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBUeXBlZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlLCBhcyBhIFNvbGlkaXR5LWNvbXBhdGlibGUgdHlwZS5cbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIHZhbHVlLlxuICAgICAqL1xuICAgIHZhbHVlO1xuICAgICNvcHRpb25zO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfdHlwZWRTeW1ib2w7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdhdXJkLCB0eXBlLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRQcml2YXRlKF9nYXVyZCwgZ2F1cmQsIFwiVHlwZWRcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBfdHlwZWRTeW1ib2wsIHR5cGUsIHZhbHVlIH0pO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHZhbHVlIGlzIHZhbGlkXG4gICAgICAgIHRoaXMuZm9ybWF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBGb3JtYXQgdGhlIHR5cGUgYXMgYSBIdW1hbi1SZWFkYWJsZSB0eXBlLlxuICAgICAqL1xuICAgIGZvcm1hdCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSBcImR5bmFtaWNBcnJheVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBgdHVwbGUoJHt0aGlzLnZhbHVlLm1hcCgodikgPT4gdi5mb3JtYXQoKSkuam9pbihcIixcIil9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBkZWZhdWx0IHZhbHVlIHJldHVybmVkIGJ5IHRoaXMgdHlwZS5cbiAgICAgKi9cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1pbmltdW0gdmFsdWUgZm9yIG51bWVyaWMgdHlwZXMuXG4gICAgICovXG4gICAgbWluVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gdmFsdWUgZm9yIG51bWVyaWMgdHlwZXMuXG4gICAgICovXG4gICAgbWF4VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkQmlnSW50XV0uXG4gICAgICovXG4gICAgaXNCaWdJbnQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLnR5cGUubWF0Y2goL151P2ludFswLTldKyQvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWREYXRhXV0uXG4gICAgICovXG4gICAgaXNEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLnN0YXJ0c1dpdGgoXCJieXRlc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZFN0cmluZ11dLlxuICAgICAqL1xuICAgIGlzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gXCJzdHJpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0dXBsZSBuYW1lLCBpZiB0aGlzIGlzIGEgdHVwbGUuIFRocm93cyBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0IHR1cGxlTmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJub3QgYSB0dXBsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9ucztcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoaXMgdHlwZSBhcyBhbiBhcnJheVxuICAgIC8vIC0gYG51bGxgIGluZGljYXRlcyB0aGUgbGVuZ3RoIGlzIHVuZm9yY2VkLCBpdCBjb3VsZCBiZSBkeW5hbWljXG4gICAgLy8gLSBgLTFgIGluZGljYXRlcyB0aGUgbGVuZ3RoIGlzIGR5bmFtaWNcbiAgICAvLyAtIGFueSBvdGhlciB2YWx1ZSBpbmRpY2F0ZXMgaXQgaXMgYSBzdGF0aWMgYXJyYXkgYW5kIGlzIGl0cyBsZW5ndGhcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSB0eXBlIG9yIGBgLTFgYCBpZiBpdCBpcyBkeW5hbWljLlxuICAgICAqXG4gICAgICogIFRocm93cyBpZiB0aGUgdHlwZSBpcyBub3QgYW4gYXJyYXkuXG4gICAgICovXG4gICAgZ2V0IGFycmF5TGVuZ3RoKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jb3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlKS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqVHlwZWQqKiBvZiAlJXR5cGUlJSB3aXRoIHRoZSAlJXZhbHVlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHlwZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4KHYpIHsgcmV0dXJuIG4odiwgOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNih2KSB7IHJldHVybiBuKHYsIDE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0KHYpIHsgcmV0dXJuIG4odiwgMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MzIodikgeyByZXR1cm4gbih2LCAzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ0MCh2KSB7IHJldHVybiBuKHYsIDQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDQ4KHYpIHsgcmV0dXJuIG4odiwgNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NTYodikgeyByZXR1cm4gbih2LCA1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDY0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ2NCh2KSB7IHJldHVybiBuKHYsIDY0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDcyKHYpIHsgcmV0dXJuIG4odiwgNzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50ODAodikgeyByZXR1cm4gbih2LCA4MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDg4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4OCh2KSB7IHJldHVybiBuKHYsIDg4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDk2KHYpIHsgcmV0dXJuIG4odiwgOTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEwNCh2KSB7IHJldHVybiBuKHYsIDEwNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDExMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTEyKHYpIHsgcmV0dXJuIG4odiwgMTEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMjAodikgeyByZXR1cm4gbih2LCAxMjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEyOCh2KSB7IHJldHVybiBuKHYsIDEyOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTM2KHYpIHsgcmV0dXJuIG4odiwgMTM2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTQ0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNDQodikgeyByZXR1cm4gbih2LCAxNDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE1Mih2KSB7IHJldHVybiBuKHYsIDE1Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTYwKHYpIHsgcmV0dXJuIG4odiwgMTYwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTY4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNjgodikgeyByZXR1cm4gbih2LCAxNjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE3Nih2KSB7IHJldHVybiBuKHYsIDE3Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE4NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTg0KHYpIHsgcmV0dXJuIG4odiwgMTg0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTkyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxOTIodikgeyByZXR1cm4gbih2LCAxOTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIwMCh2KSB7IHJldHVybiBuKHYsIDIwMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjA4KHYpIHsgcmV0dXJuIG4odiwgMjA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMTYodikgeyByZXR1cm4gbih2LCAyMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIyNCh2KSB7IHJldHVybiBuKHYsIDIyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjMyKHYpIHsgcmV0dXJuIG4odiwgMjMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNDAodikgeyByZXR1cm4gbih2LCAyNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0OCh2KSB7IHJldHVybiBuKHYsIDI0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjU2KHYpIHsgcmV0dXJuIG4odiwgMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50OCh2KSB7IHJldHVybiBuKHYsIC04KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNih2KSB7IHJldHVybiBuKHYsIC0xNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjQodikgeyByZXR1cm4gbih2LCAtMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDMyKHYpIHsgcmV0dXJuIG4odiwgLTMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ0MCh2KSB7IHJldHVybiBuKHYsIC00MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NDgodikgeyByZXR1cm4gbih2LCAtNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDU2KHYpIHsgcmV0dXJuIG4odiwgLTU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ2NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ2NCh2KSB7IHJldHVybiBuKHYsIC02NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NzIodikgeyByZXR1cm4gbih2LCAtNzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDgwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDgwKHYpIHsgcmV0dXJuIG4odiwgLTgwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4OCh2KSB7IHJldHVybiBuKHYsIC04OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50OTYodikgeyByZXR1cm4gbih2LCAtOTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEwNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMDQodikgeyByZXR1cm4gbih2LCAtMTA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTEyKHYpIHsgcmV0dXJuIG4odiwgLTExMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEyMCh2KSB7IHJldHVybiBuKHYsIC0xMjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMjgodikgeyByZXR1cm4gbih2LCAtMTI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTM2KHYpIHsgcmV0dXJuIG4odiwgLTEzNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTQ0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE0NCh2KSB7IHJldHVybiBuKHYsIC0xNDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDUyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE1Mih2KSB7IHJldHVybiBuKHYsIC0xNTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNjAodikgeyByZXR1cm4gbih2LCAtMTYwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTY4KHYpIHsgcmV0dXJuIG4odiwgLTE2OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTc2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE3Nih2KSB7IHJldHVybiBuKHYsIC0xNzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE4NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxODQodikgeyByZXR1cm4gbih2LCAtMTg0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxOTIodikgeyByZXR1cm4gbih2LCAtMTkyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjAwKHYpIHsgcmV0dXJuIG4odiwgLTIwMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjA4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIwOCh2KSB7IHJldHVybiBuKHYsIC0yMDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMTYodikgeyByZXR1cm4gbih2LCAtMjE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjI0KHYpIHsgcmV0dXJuIG4odiwgLTIyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIzMih2KSB7IHJldHVybiBuKHYsIC0yMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNDAodikgeyByZXR1cm4gbih2LCAtMjQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgLTI0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI1Nih2KSB7IHJldHVybiBuKHYsIC0yNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQodikgeyByZXR1cm4gbih2LCAtMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxKHYpIHsgcmV0dXJuIGIodiwgMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMih2KSB7IHJldHVybiBiKHYsIDIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzM2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczModikgeyByZXR1cm4gYih2LCAzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM0KHYpIHsgcmV0dXJuIGIodiwgNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM1YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNSh2KSB7IHJldHVybiBiKHYsIDUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczYodikgeyByZXR1cm4gYih2LCA2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM3KHYpIHsgcmV0dXJuIGIodiwgNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzOCh2KSB7IHJldHVybiBiKHYsIDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzOWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczkodikgeyByZXR1cm4gYih2LCA5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczEwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTAodikgeyByZXR1cm4gYih2LCAxMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczExKHYpIHsgcmV0dXJuIGIodiwgMTEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMih2KSB7IHJldHVybiBiKHYsIDEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczEzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTModikgeyByZXR1cm4gYih2LCAxMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE0KHYpIHsgcmV0dXJuIGIodiwgMTQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNSh2KSB7IHJldHVybiBiKHYsIDE1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTYodikgeyByZXR1cm4gYih2LCAxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE3KHYpIHsgcmV0dXJuIGIodiwgMTcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMThgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxOCh2KSB7IHJldHVybiBiKHYsIDE4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTkodikgeyByZXR1cm4gYih2LCAxOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIwKHYpIHsgcmV0dXJuIGIodiwgMjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMSh2KSB7IHJldHVybiBiKHYsIDIxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjIodikgeyByZXR1cm4gYih2LCAyMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyM2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIzKHYpIHsgcmV0dXJuIGIodiwgMjMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNCh2KSB7IHJldHVybiBiKHYsIDI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI1YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjUodikgeyByZXR1cm4gYih2LCAyNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI2KHYpIHsgcmV0dXJuIGIodiwgMjYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNyh2KSB7IHJldHVybiBiKHYsIDI3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjgodikgeyByZXR1cm4gYih2LCAyOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyOWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI5KHYpIHsgcmV0dXJuIGIodiwgMjkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMCh2KSB7IHJldHVybiBiKHYsIDMwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzEodikgeyByZXR1cm4gYih2LCAzMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMyKHYpIHsgcmV0dXJuIGIodiwgMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFkZHJlc3NgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkcmVzcyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImFkZHJlc3NcIiwgdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYm9vbGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBib29sKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYm9vbFwiLCAhIXYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYnl0ZXNcIiwgdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgc3RyaW5nYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInN0cmluZ1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBhcnJheWBgIHR5cGUgZm9yICUldiUlLCBhbGxvd2luZyAlJWR5bmFtaWMlJSBsZW5ndGguXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5KHYsIGR5bmFtaWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYXJyYXlcIiwgdiwgZHluYW1pYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB0dXBsZWBgIHR5cGUgZm9yICUldiUlLCB3aXRoIHRoZSBvcHRpb25hbCAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdHVwbGUodiwgbmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJ0dXBsZVwiLCB2LCBuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIG92ZXJyaWRlcyh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcIm92ZXJyaWRlc1wiLCBPYmplY3QuYXNzaWduKHt9LCB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgb25seSBpZiAlJXZhbHVlJSUgaXMgYSBbW1R5cGVkXV0gaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIGlzVHlwZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZVxuICAgICAgICAgICAgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICYmIFwiX3R5cGVkU3ltYm9sXCIgaW4gdmFsdWVcbiAgICAgICAgICAgICYmIHZhbHVlLl90eXBlZFN5bWJvbCA9PT0gX3R5cGVkU3ltYm9sKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIHRoZSB2YWx1ZSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZSwgdmFsaWRhdGVzIHRoZSB1bmRlcmx5aW5nIHZhbHVlXG4gICAgICogIGFuZCByZXR1cm5zIGl0LCBvdGhlcndpc2UgcmV0dXJucyB2YWx1ZSBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgZnVuY3Rpb25zIHRoYXQgd2l0aCB0byBhY2NlcHQgZWl0aGVyIGEgW1tUeXBlZF1dXG4gICAgICogIG9iamVjdCBvciB2YWx1ZXMuXG4gICAgICovXG4gICAgc3RhdGljIGRlcmVmZXJlbmNlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGlmIChUeXBlZC5pc1R5cGVkKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdHlwZTogZXhwZWNldGQgJHt0eXBlfSwgZ290ICR7dmFsdWUudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWQuanMubWFwIiwiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi8uLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB0b0JlSGV4IH0gZnJvbSBcIi4uLy4uL3V0aWxzL21hdGhzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEFkZHJlc3NDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJzdHJpbmdcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93RXJyb3IoZXJyb3IubWVzc2FnZSwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHRvQmVIZXgocmVhZGVyLnJlYWRWYWx1ZSgpLCAyMCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIiwiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQ2xvbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIGV4aXN0aW5nIENvZGVyLCBidXQgd2l0aG91dCBhIGxvY2FsTmFtZVxuICpcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXI7XG4gICAgY29uc3RydWN0b3IoY29kZXIpIHtcbiAgICAgICAgc3VwZXIoY29kZXIubmFtZSwgY29kZXIudHlwZSwgXCJfXCIsIGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbm9ueW1vdXMuanMubWFwIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgaXNFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgYXNzZXJ0QXJndW1lbnRDb3VudCB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyLCBSZXN1bHQsIFdvcmRTaXplLCBXcml0ZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgQW5vbnltb3VzQ29kZXIgfSBmcm9tIFwiLi9hbm9ueW1vdXMuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZXMpIHtcbiAgICBsZXQgYXJyYXlWYWx1ZXMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIGFycmF5VmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZXMgJiYgdHlwZW9mICh2YWx1ZXMpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxldCB1bmlxdWUgPSB7fTtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSBjb2RlcnMubWFwKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGFzc2VydChuYW1lLCBcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBtaXNzaW5nIG5hbWVzXCIsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBcInZhbHVlc1wiLCBpbmZvOiB7IGNvZGVyIH0sIHZhbHVlOiB2YWx1ZXMgfSk7XG4gICAgICAgICAgICBhc3NlcnQoIXVuaXF1ZVtuYW1lXSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggZHVwbGljYXRlIG5hbWVzXCIsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBcInZhbHVlc1wiLCBpbmZvOiB7IGNvZGVyIH0sIHZhbHVlOiB2YWx1ZXMgfSk7XG4gICAgICAgICAgICB1bmlxdWVbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoY29kZXJzLmxlbmd0aCA9PT0gYXJyYXlWYWx1ZXMubGVuZ3RoLCBcInR5cGVzL3ZhbHVlIGxlbmd0aCBtaXNtYXRjaFwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgbGV0IHN0YXRpY1dyaXRlciA9IG5ldyBXcml0ZXIoKTtcbiAgICBsZXQgZHluYW1pY1dyaXRlciA9IG5ldyBXcml0ZXIoKTtcbiAgICBsZXQgdXBkYXRlRnVuY3MgPSBbXTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGFycmF5VmFsdWVzW2luZGV4XTtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGR5bmFtaWMgb2Zmc2V0IChmb3IgdGhlIGZ1dHVyZSBwb2ludGVyKVxuICAgICAgICAgICAgbGV0IGR5bmFtaWNPZmZzZXQgPSBkeW5hbWljV3JpdGVyLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgZHluYW1pYyB2YWx1ZSBpbnRvIHRoZSBkeW5hbWljV3JpdGVyXG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoZHluYW1pY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgLy8gUHJlcGFyZSB0byBwb3B1bGF0ZSB0aGUgY29ycmVjdCBvZmZzZXQgb25jZSB3ZSBhcmUgZG9uZVxuICAgICAgICAgICAgbGV0IHVwZGF0ZUZ1bmMgPSBzdGF0aWNXcml0ZXIud3JpdGVVcGRhdGFibGVWYWx1ZSgpO1xuICAgICAgICAgICAgdXBkYXRlRnVuY3MucHVzaCgoYmFzZU9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZ1bmMoYmFzZU9mZnNldCArIGR5bmFtaWNPZmZzZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoc3RhdGljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBCYWNrZmlsbCBhbGwgdGhlIGR5bmFtaWMgb2Zmc2V0cywgbm93IHRoYXQgd2Uga25vdyB0aGUgc3RhdGljIGxlbmd0aFxuICAgIHVwZGF0ZUZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHsgZnVuYyhzdGF0aWNXcml0ZXIubGVuZ3RoKTsgfSk7XG4gICAgbGV0IGxlbmd0aCA9IHdyaXRlci5hcHBlbmRXcml0ZXIoc3RhdGljV3JpdGVyKTtcbiAgICBsZW5ndGggKz0gd3JpdGVyLmFwcGVuZFdyaXRlcihkeW5hbWljV3JpdGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVucGFjayhyZWFkZXIsIGNvZGVycykge1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIC8vIEEgcmVhZGVyIGFuY2hvcmVkIHRvIHRoaXMgYmFzZVxuICAgIGxldCBiYXNlUmVhZGVyID0gcmVhZGVyLnN1YlJlYWRlcigwKTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByZWFkZXIucmVhZEluZGV4KCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0UmVhZGVyID0gYmFzZVJlYWRlci5zdWJSZWFkZXIob2Zmc2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUob2Zmc2V0UmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJVRkZFUl9PVkVSUlVOXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShyZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQlVGRkVSX09WRVJSVU5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52ZXN0aWdhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICBrZXlzLnB1c2goY29kZXIubG9jYWxOYW1lIHx8IG51bGwpO1xuICAgIH0pO1xuICAgIHJldHVybiBSZXN1bHQuZnJvbUl0ZW1zKHZhbHVlcywga2V5cyk7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQXJyYXlDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb2RlcjtcbiAgICBsZW5ndGg7XG4gICAgY29uc3RydWN0b3IoY29kZXIsIGxlbmd0aCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoY29kZXIudHlwZSArIFwiW1wiICsgKGxlbmd0aCA+PSAwID8gbGVuZ3RoIDogXCJcIikgKyBcIl1cIik7XG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSAobGVuZ3RoID09PSAtMSB8fCBjb2Rlci5keW5hbWljKTtcbiAgICAgICAgc3VwZXIoXCJhcnJheVwiLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgY29kZXIsIGxlbmd0aCB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAvLyBWZXJpZmllcyB0aGUgY2hpbGQgY29kZXIgaXMgdmFsaWQgKGV2ZW4gaWYgdGhlIGFycmF5IGlzIGR5bmFtaWMgb3IgMC1sZW5ndGgpXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDaGlsZCA9IHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlZmF1bHRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcImFycmF5XCIpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiZXhwZWN0ZWQgYXJyYXkgdmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnRDb3VudCh2YWx1ZS5sZW5ndGgsIGNvdW50LCBcImNvZGVyIGFycmF5XCIgKyAodGhpcy5sb2NhbE5hbWUgPyAoXCIgXCIgKyB0aGlzLmxvY2FsTmFtZSkgOiBcIlwiKSk7XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2godGhpcy5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSByZWFkZXIucmVhZEluZGV4KCk7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZXJlIGlzICpyb3VnaGx5KiBlbm91Z2ggZGF0YSB0byBlbnN1cmVcbiAgICAgICAgICAgIC8vIHN0cmF5IHJhbmRvbSBkYXRhIGlzIG5vdCBiZWluZyByZWFkIGFzIGEgbGVuZ3RoLiBFYWNoXG4gICAgICAgICAgICAvLyBzbG90IHJlcXVpcmVzIGF0IGxlYXN0IDMyIGJ5dGVzIGZvciB0aGVpciB2YWx1ZSAob3IgMzJcbiAgICAgICAgICAgIC8vIGJ5dGVzIGFzIGEgbGluayB0byB0aGUgZGF0YSkuIFRoaXMgY291bGQgdXNlIGEgbXVjaFxuICAgICAgICAgICAgLy8gdGlnaHRlciBib3VuZCwgYnV0IHdlIGFyZSBlcnJvcmluZyBvbiB0aGUgc2lkZSBvZiBzYWZldHkuXG4gICAgICAgICAgICBhc3NlcnQoY291bnQgKiBXb3JkU2l6ZSA8PSByZWFkZXIuZGF0YUxlbmd0aCwgXCJpbnN1ZmZpY2llbnQgZGF0YSBsZW5ndGhcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7IGJ1ZmZlcjogcmVhZGVyLmJ5dGVzLCBvZmZzZXQ6IGNvdW50ICogV29yZFNpemUsIGxlbmd0aDogcmVhZGVyLmRhdGFMZW5ndGggfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKG5ldyBBbm9ueW1vdXNDb2Rlcih0aGlzLmNvZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIGNvZGVycyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIiwiaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBCb29sZWFuQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwiYm9vbFwiLCBcImJvb2xcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYm9vbFwiKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlID8gMSA6IDApO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiAhIXJlYWRlci5yZWFkVmFsdWUoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sZWFuLmpzLm1hcCIsImltcG9ydCB7IGdldEJ5dGVzQ29weSwgaGV4bGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIER5bmFtaWNCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcih0eXBlLCB0eXBlLCBsb2NhbE5hbWUsIHRydWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRJbmRleCgpLCB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQnl0ZXNDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJieXRlc1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRml4ZWRCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIHNpemU7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpemUgfSwgeyBzaXplOiBcIm51bWJlclwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAoXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikuc3Vic3RyaW5nKDAsIDIgKyB0aGlzLnNpemUgKiAyKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gZ2V0Qnl0ZXNDb3B5KFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlYWRlci5yZWFkQnl0ZXModGhpcy5zaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWQtYnl0ZXMuanMubWFwIiwiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuY29uc3QgRW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgTnVsbENvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwibm90IG51bGxcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhFbXB0eSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVsbC5qcy5tYXAiLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBmcm9tVHdvcywgZ2V0QmlnSW50LCBtYXNrLCB0b1R3b3MgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciwgV29yZFNpemUgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBOdW1iZXJDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBzaXplO1xuICAgIHNpZ25lZDtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBzaWduZWQsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gKChzaWduZWQgPyBcImludFwiIDogXCJ1aW50XCIpICsgKHNpemUgKiA4KSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgc2l6ZSwgc2lnbmVkIH0sIHsgc2l6ZTogXCJudW1iZXJcIiwgc2lnbmVkOiBcImJvb2xlYW5cIiB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIHRoaXMudHlwZSkpO1xuICAgICAgICAvLyBDaGVjayBib3VuZHMgYXJlIHNhZmUgZm9yIGVuY29kaW5nXG4gICAgICAgIGxldCBtYXhVaW50VmFsdWUgPSBtYXNrKEJOX01BWF9VSU5UMjU2LCBXb3JkU2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSBtYXNrKG1heFVpbnRWYWx1ZSwgKHRoaXMuc2l6ZSAqIDgpIC0gMSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBib3VuZHMgfHwgdmFsdWUgPCAtKGJvdW5kcyArIEJOXzEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgX3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdG9Ud29zKHZhbHVlLCA4ICogV29yZFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgQk5fMCB8fCB2YWx1ZSA+IG1hc2sobWF4VWludFZhbHVlLCB0aGlzLnNpemUgKiA4KSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG1hc2socmVhZGVyLnJlYWRWYWx1ZSgpLCB0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZyb21Ud29zKHZhbHVlLCB0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCIsImltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRmOC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IER5bmFtaWNCeXRlc0NvZGVyIH0gZnJvbSBcIi4vYnl0ZXMuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJpbmdcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmNvZGUod3JpdGVyLCB0b1V0ZjhCeXRlcyhUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvcHJvcGVydGllcy5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IHBhY2ssIHVucGFjayB9IGZyb20gXCIuL2FycmF5LmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgVHVwbGVDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb2RlcnM7XG4gICAgY29uc3RydWN0b3IoY29kZXJzLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXMucHVzaChjb2Rlci50eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoXCJ0dXBsZShcIiArIHR5cGVzLmpvaW4oXCIsXCIpICsgXCIpXCIpO1xuICAgICAgICBzdXBlcihcInR1cGxlXCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb2RlcnM6IE9iamVjdC5mcmVlemUoY29kZXJzLnNsaWNlKCkpIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goY29kZXIuZGVmYXVsdFZhbHVlKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2Ugb25seSBvdXRwdXQgbmFtZWQgcHJvcGVydGllcyBmb3IgdW5pcXVlbHkgbmFtZWQgY29kZXJzXG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gdGhpcy5jb2RlcnMucmVkdWNlKChhY2N1bSwgY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghYWNjdW1bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIEFkZCBuYW1lZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmICghbmFtZSB8fCB1bmlxdWVOYW1lc1tuYW1lXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiX2xlbmd0aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJ0dXBsZVwiKTtcbiAgICAgICAgcmV0dXJuIHBhY2sod3JpdGVyLCB0aGlzLmNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB1bnBhY2socmVhZGVyLCB0aGlzLmNvZGVycyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHVwbGUuanMubWFwIiwiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLCBzdG9yYWdlS2V5cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYWRkciksXG4gICAgICAgIHN0b3JhZ2VLZXlzOiBzdG9yYWdlS2V5cy5tYXAoKHN0b3JhZ2VLZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyhzdG9yYWdlS2V5LCAzMiksIFwiaW52YWxpZCBzbG90XCIsIGBzdG9yYWdlS2V5c1ske2luZGV4fV1gLCBzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlS2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0FjY2Vzc0xpc3RdXSBmcm9tIGFueSBldGhlcnMtc3VwcG9ydGVkIGFjY2Vzcy1saXN0IHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFjY2Vzc0xpc3RpZnkodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoc2V0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0KSkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNldC5sZW5ndGggPT09IDIsIFwiaW52YWxpZCBzbG90IHNldFwiLCBgdmFsdWVbJHtpbmRleH1dYCwgc2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldFswXSwgc2V0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNldCAhPSBudWxsICYmIHR5cGVvZiAoc2V0KSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIGFkZHJlc3Mtc2xvdCBzZXRcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIGFjY2VzcyBsaXN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGFkZHIpID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB2YWx1ZVthZGRyXS5yZWR1Y2UoKGFjY3VtLCBzdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtzdG9yYWdlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShhZGRyLCBPYmplY3Qua2V5cyhzdG9yYWdlS2V5cykuc29ydCgpKTtcbiAgICB9KTtcbiAgICByZXN1bHQuc29ydCgoYSwgYikgPT4gKGEuYWRkcmVzcy5sb2NhbGVDb21wYXJlKGIuYWRkcmVzcykpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzbGlzdC5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJpZ0ludCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGF1dGhvcml6YXRpb25pZnkoYXV0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYXV0aC5hZGRyZXNzKSxcbiAgICAgICAgbm9uY2U6IGdldEJpZ0ludCgoYXV0aC5ub25jZSAhPSBudWxsKSA/IGF1dGgubm9uY2UgOiAwKSxcbiAgICAgICAgY2hhaW5JZDogZ2V0QmlnSW50KChhdXRoLmNoYWluSWQgIT0gbnVsbCkgPyBhdXRoLmNoYWluSWQgOiAwKSxcbiAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbShhdXRoLnNpZ25hdHVyZSlcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aG9yaXphdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiwgU2lnbmluZ0tleSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgZm9yIHRoZSAlJWtleSUlLlxuICpcbiAqICBUaGUga2V5IG1heSBiZSBhbnkgc3RhbmRhcmQgZm9ybSBvZiBwdWJsaWMga2V5IG9yIGEgcHJpdmF0ZSBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcbiAgICBsZXQgcHVia2V5O1xuICAgIGlmICh0eXBlb2YgKGtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHVia2V5ID0gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KGtleSwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHVia2V5ID0ga2V5LnB1YmxpY0tleTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3Moa2VjY2FrMjU2KFwiMHhcIiArIHB1YmtleS5zdWJzdHJpbmcoNCkpLnN1YnN0cmluZygyNikpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgcmVjb3ZlcmVkIGFkZHJlc3MgZm9yIHRoZSBwcml2YXRlIGtleSB0aGF0IHdhc1xuICogIHVzZWQgdG8gc2lnbiAlJWRpZ2VzdCUlIHRoYXQgcmVzdWx0ZWQgaW4gJSVzaWduYXR1cmUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVBZGRyZXNzKFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9hZGRyZXNzZXMuanNcIjtcbmltcG9ydCB7IGtlY2NhazI1Niwgc2hhMjU2LCBTaWduYXR1cmUsIFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRlY29kZVJscCwgZW5jb2RlUmxwLCBnZXRCeXRlcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzQnl0ZXNMaWtlLCBpc0hleFN0cmluZywgdG9CZUFycmF5LCB6ZXJvUGFkVmFsdWUgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi9hY2Nlc3NsaXN0LmpzXCI7XG5pbXBvcnQgeyBhdXRob3JpemF0aW9uaWZ5IH0gZnJvbSBcIi4vYXV0aG9yaXphdGlvbi5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IEJOX01BWF9VSU5UID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuY29uc3QgQkxPQl9TSVpFID0gNDA5NiAqIDMyO1xuZnVuY3Rpb24gZ2V0S3pnTGlicmFyeShremcpIHtcbiAgICBjb25zdCBibG9iVG9LemdDb21taXRtZW50ID0gKGJsb2IpID0+IHtcbiAgICAgICAgaWYgKFwiY29tcHV0ZUJsb2JQcm9vZlwiIGluIGt6Zykge1xuICAgICAgICAgICAgLy8gbWljcm8tZWNjLXNpZ25lcjsgY2hlY2sgZm9yIGNvbXB1dGVCbG9iUHJvb2Ygc2luY2UgdGhpcyBBUElcbiAgICAgICAgICAgIC8vIGV4cGVjdHMgYSBzdHJpbmcgd2hpbGUgdGhlIGt6Zy13YXNtIGJlbG93IGV4cGVjdHMgYSBVbml0OEFycmF5XG4gICAgICAgICAgICBpZiAoXCJibG9iVG9LemdDb21taXRtZW50XCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQoaGV4bGlmeShibG9iKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiYmxvYlRvS3pnQ29tbWl0bWVudFwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBremctd2FzbSA8MC41LjA7IGJsb2JUb0t6Z0NvbW1pdG1lbnQoVWludDhBcnJheSkgPT4gVWludDhBcnJheVxuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KGJsb2IpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBremctd2FzbSA+PSAwLjUuMDsgYmxvYlRvS1pHQ29tbWl0bWVudChzdHJpbmcpID0+IHN0cmluZ1xuICAgICAgICBpZiAoXCJibG9iVG9LWkdDb21taXRtZW50XCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmJsb2JUb0taR0NvbW1pdG1lbnQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuYmxvYlRvS1pHQ29tbWl0bWVudChoZXhsaWZ5KGJsb2IpKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgS1pHIGxpYnJhcnlcIiwgXCJremdcIiwga3pnKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbXB1dGVCbG9iS3pnUHJvb2YgPSAoYmxvYiwgY29tbWl0bWVudCkgPT4ge1xuICAgICAgICAvLyBtaWNyby1lY2Mtc2lnbmVyXG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iUHJvb2ZcIiBpbiBremcgJiYgdHlwZW9mIChremcuY29tcHV0ZUJsb2JQcm9vZikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5jb21wdXRlQmxvYlByb29mKGhleGxpZnkoYmxvYiksIGhleGxpZnkoY29tbWl0bWVudCkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBremctd2FzbSA8MC41LjA7IGNvbXB1dGVCbG9iS3pnUHJvb2YoVWludDhBcnJheSwgVWludDhBcnJheSkgPT4gVWludDhBcnJheVxuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYkt6Z1Byb29mXCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmNvbXB1dGVCbG9iS3pnUHJvb2YpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBremcuY29tcHV0ZUJsb2JLemdQcm9vZihibG9iLCBjb21taXRtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBremctd2FzbSA+PSAwLjUuMDsgY29tcHV0ZUJsb2JLWkdQcm9vZihzdHJpbmcsIHN0cmluZykgPT4gc3RyaW5nXG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iS1pHUHJvb2ZcIiBpbiBremcgJiYgdHlwZW9mIChremcuY29tcHV0ZUJsb2JLWkdQcm9vZikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5jb21wdXRlQmxvYktaR1Byb29mKGhleGxpZnkoYmxvYiksIGhleGxpZnkoY29tbWl0bWVudCkpKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBLWkcgbGlicmFyeVwiLCBcImt6Z1wiLCBremcpO1xuICAgIH07XG4gICAgcmV0dXJuIHsgYmxvYlRvS3pnQ29tbWl0bWVudCwgY29tcHV0ZUJsb2JLemdQcm9vZiB9O1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbmVkSGFzaCh2ZXJzaW9uLCBoYXNoKSB7XG4gICAgbGV0IHZlcnNpb25lZCA9IHZlcnNpb24udG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlICh2ZXJzaW9uZWQubGVuZ3RoIDwgMikge1xuICAgICAgICB2ZXJzaW9uZWQgPSBcIjBcIiArIHZlcnNpb25lZDtcbiAgICB9XG4gICAgdmVyc2lvbmVkICs9IHNoYTI1NihoYXNoKS5zdWJzdHJpbmcoNCk7XG4gICAgcmV0dXJuIFwiMHhcIiArIHZlcnNpb25lZDtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFkZHJlc3ModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzTGlzdCh2YWx1ZSwgcGFyYW0pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgZXJyb3IubWVzc2FnZSwgcGFyYW0sIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVBdXRob3JpemF0aW9uTGlzdCh2YWx1ZSwgcGFyYW0pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdXRob3JpemF0aW9uTGlzdDogaW52YWxpZCBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYXV0aCA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGF1dGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdXRob3JpemF0aW9uWyR7aX1dOiBpbnZhbGlkIGFycmF5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXV0aC5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF1dGhvcml6YXRpb25bJHtpfV06IHdyb25nIGxlbmd0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdXRoWzFdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdXRob3JpemF0aW9uWyR7aX1dOiBudWxsIGFkZHJlc3NgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBoYW5kbGVBZGRyZXNzKGF1dGhbMV0pLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBoYW5kbGVVaW50KGF1dGhbMl0sIFwibm9uY2VcIiksXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChhdXRoWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICAgICAgICAgIHlQYXJpdHk6IGhhbmRsZU51bWJlcihhdXRoWzNdLCBcInlQYXJpdHlcIiksXG4gICAgICAgICAgICAgICAgICAgIHI6IHplcm9QYWRWYWx1ZShhdXRoWzRdLCAzMiksXG4gICAgICAgICAgICAgICAgICAgIHM6IHplcm9QYWRWYWx1ZShhdXRoWzVdLCAzMilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBwYXJhbSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZU51bWJlcihfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TnVtYmVyKF92YWx1ZSwgcGFyYW0pO1xufVxuZnVuY3Rpb24gaGFuZGxlVWludChfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBCTl8wO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIHBhcmFtKTtcbiAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA8PSBCTl9NQVhfVUlOVCwgXCJ2YWx1ZSBleGNlZWRzIHVpbnQgc2l6ZVwiLCBwYXJhbSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihfdmFsdWUsIG5hbWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcbiAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQubGVuZ3RoIDw9IDMyLCBgdmFsdWUgdG9vIGxhcmdlYCwgYHR4LiR7bmFtZX1gLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKChzZXQpID0+IFtzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzXSk7XG59XG5mdW5jdGlvbiBmb3JtYXRBdXRob3JpemF0aW9uTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoKGEpID0+IHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZvcm1hdE51bWJlcihhLmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgICAgIGEuYWRkcmVzcyxcbiAgICAgICAgICAgIGZvcm1hdE51bWJlcihhLm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICAgICAgZm9ybWF0TnVtYmVyKGEuc2lnbmF0dXJlLnlQYXJpdHksIFwieVBhcml0eVwiKSxcbiAgICAgICAgICAgIHRvQmVBcnJheShhLnNpZ25hdHVyZS5yKSxcbiAgICAgICAgICAgIHRvQmVBcnJheShhLnNpZ25hdHVyZS5zKVxuICAgICAgICBdO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0SGFzaGVzKHZhbHVlLCBwYXJhbSkge1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkodmFsdWUpLCBgaW52YWxpZCAke3BhcmFtfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWVbaV0sIDMyKSwgXCJpbnZhbGlkICR7IHBhcmFtIH0gaGFzaFwiLCBgdmFsdWVbJHtpfV1gLCB2YWx1ZVtpXSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUxlZ2FjeShkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGRhdGEpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSA2KSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciBsZWdhY3kgdHJhbnNhY3Rpb25cIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAwLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1swXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzFdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1szXSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbNV0pLFxuICAgICAgICBjaGFpbklkOiBCTl8wXG4gICAgfTtcbiAgICAvLyBMZWdhY3kgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gNikge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIGNvbnN0IHYgPSBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2XCIpO1xuICAgIGNvbnN0IHIgPSBoYW5kbGVVaW50KGZpZWxkc1s3XSwgXCJyXCIpO1xuICAgIGNvbnN0IHMgPSBoYW5kbGVVaW50KGZpZWxkc1s4XSwgXCJzXCIpO1xuICAgIGlmIChyID09PSBCTl8wICYmIHMgPT09IEJOXzApIHtcbiAgICAgICAgLy8gRUlQLTE1NSB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgICAgICB0eC5jaGFpbklkID0gdjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIEVJUC0xNTUgY2hhaW4gSUQgKG9yIDAgZm9yIGxlZ2FjeSlcbiAgICAgICAgbGV0IGNoYWluSWQgPSAodiAtIEJOXzM1KSAvIEJOXzI7XG4gICAgICAgIGlmIChjaGFpbklkIDwgQk5fMCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgdHguY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIC8vIFNpZ25lZCBMZWdhY3kgVHJhbnNhY3Rpb25cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoY2hhaW5JZCAhPT0gQk5fMCB8fCAodiA9PT0gQk5fMjcgfHwgdiA9PT0gQk5fMjgpLCBcIm5vbi1jYW5vbmljYWwgbGVnYWN5IHZcIiwgXCJ2XCIsIGZpZWxkc1s2XSk7XG4gICAgICAgIHR4LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgIHI6IHplcm9QYWRWYWx1ZShmaWVsZHNbN10sIDMyKSxcbiAgICAgICAgICAgIHM6IHplcm9QYWRWYWx1ZShmaWVsZHNbOF0sIDMyKSxcbiAgICAgICAgICAgIHZcbiAgICAgICAgfSk7XG4gICAgICAgIC8vdHguaGFzaCA9IGtlY2NhazI1NihkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUxlZ2FjeSh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNQcmljZSB8fCAwLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgXTtcbiAgICBsZXQgY2hhaW5JZCA9IEJOXzA7XG4gICAgaWYgKHR4LmNoYWluSWQgIT0gQk5fMCkge1xuICAgICAgICAvLyBBIGNoYWluSWQgd2FzIHByb3ZpZGVkOyBpZiBub24temVybyB3ZSdsbCB1c2UgRUlQLTE1NVxuICAgICAgICBjaGFpbklkID0gZ2V0QmlnSW50KHR4LmNoYWluSWQsIFwidHguY2hhaW5JZFwiKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBhIGNoYWluSWQgaW4gdGhlIHR4IGFuZCBhbiBFSVAtMTU1IHYgaW4gdGhlIHNpZ25hdHVyZSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXkgYWdyZWUgd2l0aCBlYWNoIG90aGVyXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFzaWcgfHwgc2lnLm5ldHdvcmtWID09IG51bGwgfHwgc2lnLmxlZ2FjeUNoYWluSWQgPT09IGNoYWluSWQsIFwidHguY2hhaW5JZC9zaWcudiBtaXNtYXRjaFwiLCBcInNpZ1wiLCBzaWcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eC5zaWduYXR1cmUpIHtcbiAgICAgICAgLy8gTm8gZXhwbGljaXQgY2hhaW5JZCwgYnV0IEVJUC0xNTUgaGF2ZSBhIGRlcml2ZWQgaW1wbGljaXQgY2hhaW5JZFxuICAgICAgICBjb25zdCBsZWdhY3kgPSB0eC5zaWduYXR1cmUubGVnYWN5Q2hhaW5JZDtcbiAgICAgICAgaWYgKGxlZ2FjeSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gbGVnYWN5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlcXVlc3RpbmcgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICBpZiAoIXNpZykge1xuICAgICAgICAvLyBXZSBoYXZlIGFuIEVJUC0xNTUgdHJhbnNhY3Rpb24gKGNoYWluSWQgd2FzIHNwZWNpZmllZCBhbmQgbm9uLXplcm8pXG4gICAgICAgIGlmIChjaGFpbklkICE9PSBCTl8wKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoY2hhaW5JZCkpO1xuICAgICAgICAgICAgZmllbGRzLnB1c2goXCIweFwiKTtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKFwiMHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVJscChmaWVsZHMpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoYXQgdHguc2lnbmF0dXJlLCBjaGFpbklkLCBhbmQgc2lnXG4gICAgLy8gICAgICAgIG1hdGNoIGJ1dCB0aGF0IGxvZ2ljIGNvdWxkIGJyZWFrIGV4aXN0aW5nIGNvZGUsIHNvIHNjaGVkdWxlXG4gICAgLy8gICAgICAgIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIGJ1bXAuXG4gICAgLy8gQ29tcHV0ZSB0aGUgRUlQLTE1NSB2XG4gICAgbGV0IHYgPSBCaWdJbnQoMjcgKyBzaWcueVBhcml0eSk7XG4gICAgaWYgKGNoYWluSWQgIT09IEJOXzApIHtcbiAgICAgICAgdiA9IFNpZ25hdHVyZS5nZXRDaGFpbklkVihjaGFpbklkLCBzaWcudik7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJpZ0ludChzaWcudikgIT09IHYpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidHguY2hhaW5JZC9zaWcudiBtaXNtYXRjaFwiLCBcInNpZ1wiLCBzaWcpO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIHNpZ25hdHVyZVxuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheSh2KSk7XG4gICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgcmV0dXJuIGVuY29kZVJscChmaWVsZHMpO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMpIHtcbiAgICBsZXQgeVBhcml0eTtcbiAgICB0cnkge1xuICAgICAgICB5UGFyaXR5ID0gaGFuZGxlTnVtYmVyKGZpZWxkc1swXSwgXCJ5UGFyaXR5XCIpO1xuICAgICAgICBpZiAoeVBhcml0eSAhPT0gMCAmJiB5UGFyaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgeVBhcml0eVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB5UGFyaXR5XCIsIFwieVBhcml0eVwiLCBmaWVsZHNbMF0pO1xuICAgIH1cbiAgICBjb25zdCByID0gemVyb1BhZFZhbHVlKGZpZWxkc1sxXSwgMzIpO1xuICAgIGNvbnN0IHMgPSB6ZXJvUGFkVmFsdWUoZmllbGRzWzJdLCAzMik7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oeyByLCBzLCB5UGFyaXR5IH0pO1xuICAgIHR4LnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDE1NTkoZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA5IHx8IGZpZWxkcy5sZW5ndGggPT09IDEyKSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAyXCIsIFwiZGF0YVwiLCBoZXhsaWZ5KGRhdGEpKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMixcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s1XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbN10pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s4XSwgXCJhY2Nlc3NMaXN0XCIpLFxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTE1NTkgVHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8vdHguaGFzaCA9IGtlY2NhazI1NihkYXRhKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSg5KSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDE1NTkodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxuICAgICAgICB0eC5kYXRhLFxuICAgICAgICBmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJ5UGFyaXR5XCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDJcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDI5MzAoZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA4IHx8IGZpZWxkcy5sZW5ndGggPT09IDExKSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAxXCIsIFwiZGF0YVwiLCBoZXhsaWZ5KGRhdGEpKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIGdhc1ByaWNlOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNF0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNV0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzZdKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbN10sIFwiYWNjZXNzTGlzdFwiKVxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTI5MzAgVHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8vdHguaGFzaCA9IGtlY2NhazI1NihkYXRhKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSg4KSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDI5MzAodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxuICAgICAgICB0eC5kYXRhLFxuICAgICAgICBmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJyZWNvdmVyeVBhcmFtXCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDFcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDQ4NDQoZGF0YSkge1xuICAgIGxldCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xuICAgIGxldCB0eXBlTmFtZSA9IFwiM1wiO1xuICAgIGxldCBibG9icyA9IG51bGw7XG4gICAgLy8gUGFyc2UgdGhlIG5ldHdvcmsgZm9ybWF0XG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDQgJiYgQXJyYXkuaXNBcnJheShmaWVsZHNbMF0pKSB7XG4gICAgICAgIHR5cGVOYW1lID0gXCIzIChuZXR3b3JrIGZvcm1hdClcIjtcbiAgICAgICAgY29uc3QgZkJsb2JzID0gZmllbGRzWzFdLCBmQ29tbWl0cyA9IGZpZWxkc1syXSwgZlByb29mcyA9IGZpZWxkc1szXTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmQmxvYnMpLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGJsb2JzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1sxXVwiLCBmQmxvYnMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZDb21taXRzKSwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBjb21taXRtZW50cyBub3QgYW4gYXJyYXlcIiwgXCJmaWVsZHNbMl1cIiwgZkNvbW1pdHMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZQcm9vZnMpLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IHByb29mcyBub3QgYW4gYXJyYXlcIiwgXCJmaWVsZHNbM11cIiwgZlByb29mcyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZCbG9icy5sZW5ndGggPT09IGZDb21taXRzLmxlbmd0aCwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBibG9icy9jb21taXRtZW50cyBsZW5ndGggbWlzbWF0Y2hcIiwgXCJmaWVsZHNcIiwgZmllbGRzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZkJsb2JzLmxlbmd0aCA9PT0gZlByb29mcy5sZW5ndGgsIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogYmxvYnMvcHJvb2ZzIGxlbmd0aCBtaXNtYXRjaFwiLCBcImZpZWxkc1wiLCBmaWVsZHMpO1xuICAgICAgICBibG9icyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkc1sxXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYmxvYnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogZkJsb2JzW2ldLFxuICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGZDb21taXRzW2ldLFxuICAgICAgICAgICAgICAgIHByb29mOiBmUHJvb2ZzW2ldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRzID0gZmllbGRzWzBdO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDExIHx8IGZpZWxkcy5sZW5ndGggPT09IDE0KSwgYGludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHlwZU5hbWV9YCwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAzLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzZdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s3XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzhdLCBcImFjY2Vzc0xpc3RcIiksXG4gICAgICAgIG1heEZlZVBlckJsb2JHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzldLCBcIm1heEZlZVBlckJsb2JHYXNcIiksXG4gICAgICAgIGJsb2JWZXJzaW9uZWRIYXNoZXM6IGZpZWxkc1sxMF1cbiAgICB9O1xuICAgIGlmIChibG9icykge1xuICAgICAgICB0eC5ibG9icyA9IGJsb2JzO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudCh0eC50byAhPSBudWxsLCBgaW52YWxpZCBhZGRyZXNzIGZvciB0cmFuc2FjdGlvbiB0eXBlOiAke3R5cGVOYW1lfWAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMpLCBcImludmFsaWQgYmxvYlZlcnNpb25lZEhhc2hlczogbXVzdCBiZSBhbiBhcnJheVwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXNbaV0sIDMyKSwgYGludmFsaWQgYmxvYlZlcnNpb25lZEhhc2ggYXQgaW5kZXggJHtpfTogbXVzdCBiZSBsZW5ndGggMzJgLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgfVxuICAgIC8vIFVuc2lnbmVkIEVJUC00ODQ0IFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDExKSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy8gQFRPRE86IERvIHdlIG5lZWQgdG8gZG8gdGhpcz8gVGhpcyBpcyBvbmx5IGNhbGxlZCBpbnRlcm5hbGx5XG4gICAgLy8gYW5kIHVzZWQgdG8gdmVyaWZ5IGhhc2hlczsgaXQgbWlnaHQgc2F2ZSB0aW1lIHRvIG5vdCBkbyB0aGlzXG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGNvbmNhdChbIFwiMHgwM1wiLCBlbmNvZGVSbHAoZmllbGRzKSBdKSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoMTEpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwNDg0NCh0eCwgc2lnLCBibG9icykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgWmVyb0FkZHJlc3MpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJCbG9iR2FzIHx8IDAsIFwibWF4RmVlUGVyQmxvYkdhc1wiKSxcbiAgICAgICAgZm9ybWF0SGFzaGVzKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgfHwgW10sIFwiYmxvYlZlcnNpb25lZEhhc2hlc1wiKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBibG9iczsgcmV0dXJuIHRoZSBuZXR3b3JrIHdyYXBwZWQgZm9ybWF0XG4gICAgICAgIGlmIChibG9icykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICAgICAgXCIweDAzXCIsXG4gICAgICAgICAgICAgICAgZW5jb2RlUmxwKFtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLFxuICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGJsb2JzLm1hcCgoYikgPT4gYi5jb21taXRtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgYmxvYnMubWFwKChiKSA9PiBiLnByb29mKSxcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDAzXCIsIGVuY29kZVJscChmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXA3NzAyKGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gMTAgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTMpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDRcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiA0LFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzZdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s3XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzhdLCBcImFjY2Vzc0xpc3RcIiksXG4gICAgICAgIGF1dGhvcml6YXRpb25MaXN0OiBoYW5kbGVBdXRob3JpemF0aW9uTGlzdChmaWVsZHNbOV0sIFwiYXV0aG9yaXphdGlvbkxpc3RcIiksXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtNzcwMiBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDEwKSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDc3MDIodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxuICAgICAgICB0eC5kYXRhLFxuICAgICAgICBmb3JtYXRBY2Nlc3NMaXN0KHR4LmFjY2Vzc0xpc3QgfHwgW10pLFxuICAgICAgICBmb3JtYXRBdXRob3JpemF0aW9uTGlzdCh0eC5hdXRob3JpemF0aW9uTGlzdCB8fCBbXSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwNFwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuLyoqXG4gKiAgQSAqKlRyYW5zYWN0aW9uKiogZGVzY3JpYmVzIGFuIG9wZXJhdGlvbiB0byBiZSBleGVjdXRlZCBvblxuICogIEV0aGVyZXVtIGJ5IGFuIEV4dGVybmFsbHkgT3duZWQgQWNjb3VudCAoRU9BKS4gSXQgaW5jbHVkZXNcbiAqICB3aG8gKHRoZSBbW3RvXV0gYWRkcmVzcyksIHdoYXQgKHRoZSBbW2RhdGFdXSkgYW5kIGhvdyBtdWNoICh0aGVcbiAqICBbW3ZhbHVlXV0gaW4gZXRoZXIpIHRoZSBvcGVyYXRpb24gc2hvdWxkIGVudGFpbC5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICB0eCA9IG5ldyBUcmFuc2FjdGlvbigpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgdHguZGF0YSA9IFwiMHgxMjM0XCI7XG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbiB7XG4gICAgI3R5cGU7XG4gICAgI3RvO1xuICAgICNkYXRhO1xuICAgICNub25jZTtcbiAgICAjZ2FzTGltaXQ7XG4gICAgI2dhc1ByaWNlO1xuICAgICNtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAjbWF4RmVlUGVyR2FzO1xuICAgICN2YWx1ZTtcbiAgICAjY2hhaW5JZDtcbiAgICAjc2lnO1xuICAgICNhY2Nlc3NMaXN0O1xuICAgICNtYXhGZWVQZXJCbG9iR2FzO1xuICAgICNibG9iVmVyc2lvbmVkSGFzaGVzO1xuICAgICNremc7XG4gICAgI2Jsb2JzO1xuICAgICNhdXRocztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICpcbiAgICAgKiAgSWYgbnVsbCwgdGhlIHR5cGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluZmVycmVkIGJhc2VkIG9uXG4gICAgICogIGV4cGxpY2l0IHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLiN0eXBlOyB9XG4gICAgc2V0IHR5cGUodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSBcImxlZ2FjeVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSBcImJlcmxpblwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC0yOTMwXCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIFwibG9uZG9uXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTE1NTlcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jdW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtNDg0NFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgY2FzZSBcInBlY3RyYVwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC03NzAyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJ0eXBlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgZ2V0IHR5cGVOYW1lKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gXCJsZWdhY3lcIjtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFwiZWlwLTI5MzBcIjtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFwiZWlwLTE1NTlcIjtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFwiZWlwLTQ4NDRcIjtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFwiZWlwLTc3MDJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHRvYGAgYWRkcmVzcyBmb3IgdGhlIHRyYW5zYWN0aW9uIG9yIGBgbnVsbGBgIGlmIHRoZVxuICAgICAqICB0cmFuc2FjdGlvbiBpcyBhbiBgYGluaXRgYCB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgdG8oKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdG87XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIFplcm9BZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IHRvKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3RvID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEFkZHJlc3ModmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIG5vbmNlLlxuICAgICAqL1xuICAgIGdldCBub25jZSgpIHsgcmV0dXJuIHRoaXMuI25vbmNlOyB9XG4gICAgc2V0IG5vbmNlKHZhbHVlKSB7IHRoaXMuI25vbmNlID0gZ2V0TnVtYmVyKHZhbHVlLCBcInZhbHVlXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgbGltaXQuXG4gICAgICovXG4gICAgZ2V0IGdhc0xpbWl0KCkgeyByZXR1cm4gdGhpcy4jZ2FzTGltaXQ7IH1cbiAgICBzZXQgZ2FzTGltaXQodmFsdWUpIHsgdGhpcy4jZ2FzTGltaXQgPSBnZXRCaWdJbnQodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzIHRoaXMgZGVmaW5lcyB0aGUgZmVlIHRoYXQgd2lsbCBiZSBwYWlkLiBPblxuICAgICAqICBFSVAtMTU1OSBuZXR3b3JrcywgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGdhc1ByaWNlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2dhc1ByaWNlO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAodGhpcy50eXBlID09PSAwIHx8IHRoaXMudHlwZSA9PT0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGdhc1ByaWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2dhc1ByaWNlID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEJpZ0ludCh2YWx1ZSwgXCJnYXNQcmljZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHByaW9yaXR5IGZlZSBwZXIgdW5pdCBvZiBnYXMgdG8gcGF5LiBPbiBsZWdhY3lcbiAgICAgKiAgbmV0d29ya3MgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IG1heFByaW9yaXR5RmVlUGVyR2FzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heFByaW9yaXR5RmVlUGVyR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEJpZ0ludCh2YWx1ZSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHRvdGFsIGZlZSBwZXIgdW5pdCBvZiBnYXMgdG8gcGF5LiBPbiBsZWdhY3lcbiAgICAgKiAgbmV0d29ya3MgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IG1heEZlZVBlckdhcygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXhGZWVQZXJHYXM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAyIHx8IHRoaXMudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgbWF4RmVlUGVyR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4RmVlUGVyR2FzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGRhdGEuIEZvciBgYGluaXRgYCB0cmFuc2FjdGlvbnMgdGhpcyBpcyB0aGVcbiAgICAgKiAgZGVwbG95bWVudCBjb2RlLlxuICAgICAqL1xuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gdGhpcy4jZGF0YTsgfVxuICAgIHNldCBkYXRhKHZhbHVlKSB7IHRoaXMuI2RhdGEgPSBoZXhsaWZ5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGV0aGVyIChpbiB3ZWkpIHRvIHNlbmQgaW4gdGhpcyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy4jdmFsdWU7IH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBnZXRCaWdJbnQodmFsdWUsIFwidmFsdWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgdGhpcyB0cmFuc2FjdGlvbiBpcyB2YWxpZCBvbi5cbiAgICAgKi9cbiAgICBnZXQgY2hhaW5JZCgpIHsgcmV0dXJuIHRoaXMuI2NoYWluSWQ7IH1cbiAgICBzZXQgY2hhaW5JZCh2YWx1ZSkgeyB0aGlzLiNjaGFpbklkID0gZ2V0QmlnSW50KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqICBJZiBzaWduZWQsIHRoZSBzaWduYXR1cmUgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHNpZ25hdHVyZSgpIHsgcmV0dXJuIHRoaXMuI3NpZyB8fCBudWxsOyB9XG4gICAgc2V0IHNpZ25hdHVyZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNzaWcgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogU2lnbmF0dXJlLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGFjY2VzcyBsaXN0LlxuICAgICAqXG4gICAgICogIEFuIGFjY2VzcyBsaXN0IHBlcm1pdHMgZGlzY291bnRlZCAoYnV0IHByZS1wYWlkKSBhY2Nlc3MgdG9cbiAgICAgKiAgYnl0ZWNvZGUgYW5kIHN0YXRlIHZhcmlhYmxlIGFjY2VzcyB3aXRoaW4gY29udHJhY3QgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGdldCBhY2Nlc3NMaXN0KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2FjY2Vzc0xpc3QgfHwgbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDEgfHwgdGhpcy50eXBlID09PSAyIHx8IHRoaXMudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBpbiB2NywgdGhpcyBzaG91bGQgYXNzaWduIHRoZSB2YWx1ZSBvciBiZWNvbWVcbiAgICAgICAgICAgICAgICAvLyBhIGxpdmUgb2JqZWN0IGl0c2VsZiwgb3RoZXJ3aXNlIG11dGF0aW9uIGlzIGluY29uc2lzdGVudFxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jYWNjZXNzTGlzdCA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGF1dGhvcml6YXRpb25MaXN0KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2F1dGhzIHx8IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IGluIHY3LCB0aGlzIHNob3VsZCBiZWNvbWUgYSBsaXZlIG9iamVjdCBpdHNlbGYsXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIG11dGF0aW9uIGlzIGluY29uc2lzdGVudFxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBhdXRob3JpemF0aW9uTGlzdChhdXRocykge1xuICAgICAgICB0aGlzLiNhdXRocyA9IChhdXRocyA9PSBudWxsKSA/IG51bGwgOiBhdXRocy5tYXAoKGEpID0+IGF1dGhvcml6YXRpb25pZnkoYSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heCBmZWUgcGVyIGJsb2IgZ2FzIGZvciBDYW5jdW4gdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldCBtYXhGZWVQZXJCbG9iR2FzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heEZlZVBlckJsb2JHYXM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgbWF4RmVlUGVyQmxvYkdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJCbG9iR2FzID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEJpZ0ludCh2YWx1ZSwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEJMT2IgdmVyc2lvbmVkIGhhc2hlcyBmb3IgQ2FuY3VuIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgYmxvYlZlcnNpb25lZEhhc2hlcygpIHtcbiAgICAgICAgLy8gQFRPRE86IE11dGF0aW9uIGlzIGluY29uc2lzdGVudDsgaWYgdW5zZXQsIHRoZSByZXR1cm5lZCB2YWx1ZVxuICAgICAgICAvLyBjYW5ub3QgbXV0YXRlIHRoZSBvYmplY3QsIGlmIHNldCBpdCBjYW5cbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYmxvYlZlcnNpb25lZEhhc2hlcyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSksIFwiYmxvYlZlcnNpb25lZEhhc2hlcyBtdXN0IGJlIGFuIEFycmF5XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlW2ldLCAzMiksIFwiaW52YWxpZCBibG9iVmVyc2lvbmVkSGFzaFwiLCBgdmFsdWVbJHtpfV1gLCB2YWx1ZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEJMT2JzIGZvciB0aGUgVHJhbnNhY3Rpb24sIGlmIGFueS5cbiAgICAgKlxuICAgICAqICBJZiBgYGJsb2JzYGAgaXMgbm9uLWBgbnVsbGBgLCB0aGVuIHRoZSBbW3NlcmlhaWxpemVkXV1cbiAgICAgKiAgd2lsbCByZXR1cm4gdGhlIG5ldHdvcmsgZm9ybWF0dGVkIHNpZGVjYXIsIG90aGVyd2lzZSBpdFxuICAgICAqICB3aWxsIHJldHVybiB0aGUgc3RhbmRhcmQgW1tsaW5rLWVpcC0yNzE4XV0gcGF5bG9hZC4gVGhlXG4gICAgICogIFtbdW5zaWduZWRTZXJpYWxpemVkXV0gaXMgdW5hZmZlY3RlZCByZWdhcmRsZXNzLlxuICAgICAqXG4gICAgICogIFdoZW4gc2V0dGluZyBgYGJsb2JzYGAsIGVpdGhlciBmdWxseSB2YWxpZCBbW0Jsb2JdXSBvYmplY3RzXG4gICAgICogIG1heSBiZSBzcGVjaWZpZWQgKGkuZS4gY29ycmVjdGx5IHBhZGRlZCwgd2l0aCBjb3JyZWN0XG4gICAgICogIGNvbW1pdHRtZW50cyBhbmQgcHJvb2ZzKSBvciBhIHJhdyBbW0J5dGVzTGlrZV1dIG1heVxuICAgICAqICBiZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqICBJZiByYXcgW1tCeXRlc0xpa2VdXSBhcmUgcHJvdmlkZWQsIHRoZSBbW2t6Z11dIHByb3BlcnR5ICoqbXVzdCoqXG4gICAgICogIGJlIGFscmVhZHkgc2V0LiBUaGUgYmxvYiB3aWxsIGJlIGNvcnJlY3RseSBwYWRkZWQgYW5kIHRoZVxuICAgICAqICBbW0t6Z0xpYnJhcnldXSB3aWxsIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgY29tbWl0dG1lbnQgYW5kXG4gICAgICogIHByb29mIGZvciB0aGUgYmxvYi5cbiAgICAgKlxuICAgICAqICBBIEJMT2IgaXMgYSBzZXF1ZW5jZSBvZiBmaWVsZCBlbGVtZW50cywgZWFjaCBvZiB3aGljaCBtdXN0XG4gICAgICogIGJlIHdpdGhpbiB0aGUgQkxTIGZpZWxkIG1vZHVsbywgc28gc29tZSBhZGRpdGlvbmFsIHByb2Nlc3NpbmdcbiAgICAgKiAgbWF5IGJlIHJlcXVpcmVkIHRvIGVuY29kZSBhcmJpdHJhcnkgZGF0YSB0byBlbnN1cmUgZWFjaCAzMiBieXRlXG4gICAgICogIGZpZWxkIGlzIHdpdGhpbiB0aGUgdmFsaWQgcmFuZ2UuXG4gICAgICpcbiAgICAgKiAgU2V0dGluZyB0aGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVzIFtbYmxvYlZlcnNpb25lZEhhc2hlc11dLFxuICAgICAqICBvdmVyd3JpdGluZyBhbnkgZXhpc3RpbmcgdmFsdWVzLiBTZXR0aW5nIHRoaXMgdG8gYGBudWxsYGBcbiAgICAgKiAgZG9lcyAqKm5vdCoqIHJlbW92ZSB0aGUgW1tibG9iVmVyc2lvbmVkSGFzaGVzXV0sIGxlYXZpbmcgdGhlbVxuICAgICAqICBwcmVzZW50LlxuICAgICAqL1xuICAgIGdldCBibG9icygpIHtcbiAgICAgICAgaWYgKHRoaXMuI2Jsb2JzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNibG9icy5tYXAoKGIpID0+IE9iamVjdC5hc3NpZ24oe30sIGIpKTtcbiAgICB9XG4gICAgc2V0IGJsb2JzKF9ibG9icykge1xuICAgICAgICBpZiAoX2Jsb2JzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2Jsb2JzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9icyA9IFtdO1xuICAgICAgICBjb25zdCB2ZXJzaW9uZWRIYXNoZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYmxvYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBfYmxvYnNbaV07XG4gICAgICAgICAgICBpZiAoaXNCeXRlc0xpa2UoYmxvYikpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQodGhpcy4ja3pnLCBcImFkZGluZyBhIHJhdyBibG9iIHJlcXVpcmVzIGEgS1pHIGxpYnJhcnlcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0IGJsb2JzKClcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gZ2V0Qnl0ZXMoYmxvYik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YS5sZW5ndGggPD0gQkxPQl9TSVpFLCBcImJsb2IgaXMgdG9vIGxhcmdlXCIsIGBibG9ic1ske2l9XWAsIGJsb2IpO1xuICAgICAgICAgICAgICAgIC8vIFBhZCBibG9iIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gQkxPQl9TSVpFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRlZCA9IG5ldyBVaW50OEFycmF5KEJMT0JfU0laRSk7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRlZC5zZXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwYWRkZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1pdCA9IHRoaXMuI2t6Zy5ibG9iVG9LemdDb21taXRtZW50KGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb29mID0gaGV4bGlmeSh0aGlzLiNremcuY29tcHV0ZUJsb2JLemdQcm9vZihkYXRhLCBjb21taXQpKTtcbiAgICAgICAgICAgICAgICBibG9icy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4bGlmeShkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogaGV4bGlmeShjb21taXQpLFxuICAgICAgICAgICAgICAgICAgICBwcm9vZlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZlcnNpb25lZEhhc2hlcy5wdXNoKGdldFZlcnNpb25lZEhhc2goMSwgY29tbWl0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21taXQgPSBoZXhsaWZ5KGJsb2IuY29tbWl0bWVudCk7XG4gICAgICAgICAgICAgICAgYmxvYnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleGxpZnkoYmxvYi5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogY29tbWl0LFxuICAgICAgICAgICAgICAgICAgICBwcm9vZjogaGV4bGlmeShibG9iLnByb29mKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZlcnNpb25lZEhhc2hlcy5wdXNoKGdldFZlcnNpb25lZEhhc2goMSwgY29tbWl0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYmxvYnMgPSBibG9icztcbiAgICAgICAgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyA9IHZlcnNpb25lZEhhc2hlcztcbiAgICB9XG4gICAgZ2V0IGt6ZygpIHsgcmV0dXJuIHRoaXMuI2t6ZzsgfVxuICAgIHNldCBremcoa3pnKSB7XG4gICAgICAgIGlmIChremcgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4ja3pnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2t6ZyA9IGdldEt6Z0xpYnJhcnkoa3pnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBUcmFuc2FjdGlvbiB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiN0eXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jdG8gPSBudWxsO1xuICAgICAgICB0aGlzLiNub25jZSA9IDA7XG4gICAgICAgIHRoaXMuI2dhc0xpbWl0ID0gQk5fMDtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBcIjB4XCI7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gQk5fMDtcbiAgICAgICAgdGhpcy4jY2hhaW5JZCA9IEJOXzA7XG4gICAgICAgIHRoaXMuI3NpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJCbG9iR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2t6ZyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Jsb2JzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYXV0aHMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2gsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy4jZ2V0U2VyaWFsaXplZCh0cnVlLCBmYWxzZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHByZS1pbWFnZSBoYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB0aGUgZGlnZXN0IHRoYXQgYSBbW1NpZ25lcl1dIG11c3Qgc2lnbiB0byBhdXRob3JpemVcbiAgICAgKiAgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgdW5zaWduZWRIYXNoKCkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMudW5zaWduZWRTZXJpYWxpemVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kaW5nIGFkZHJlc3MsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZnJvbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyh0aGlzLnVuc2lnbmVkSGFzaCwgdGhpcy5zaWduYXR1cmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIHNlbmRlciwgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBmcm9tUHVibGljS2V5KCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleSh0aGlzLnVuc2lnbmVkSGFzaCwgdGhpcy5zaWduYXR1cmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHNpZ25lZC5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHByb3BlcnRpZXMgcmVxdWlyaW5nIGEgc2lnbmVkXG4gICAgICogIHRyYW5zYWN0aW9uIGFyZSBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc1NpZ25lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlICE9IG51bGw7XG4gICAgfVxuICAgICNnZXRTZXJpYWxpemVkKHNpZ25lZCwgc2lkZWNhcikge1xuICAgICAgICBhc3NlcnQoIXNpZ25lZCB8fCB0aGlzLnNpZ25hdHVyZSAhPSBudWxsLCBcImNhbm5vdCBzZXJpYWxpemUgdW5zaWduZWQgdHJhbnNhY3Rpb247IG1heWJlIHlvdSBtZWFudCAudW5zaWduZWRTZXJpYWxpemVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi5zZXJpYWxpemVkXCIgfSk7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNpZ25lZCA/IHRoaXMuc2lnbmF0dXJlIDogbnVsbDtcbiAgICAgICAgc3dpdGNoICh0aGlzLmluZmVyVHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVMZWdhY3kodGhpcywgc2lnKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDI5MzAodGhpcywgc2lnKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDE1NTkodGhpcywgc2lnKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDQ4NDQodGhpcywgc2lnLCBzaWRlY2FyID8gdGhpcy5ibG9icyA6IG51bGwpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwNzcwMih0aGlzLCBzaWcpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi5zZXJpYWxpemVkXCIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHRocm93cyBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgdW5zaWduZWQuIEZvciB0aGUgcHJlLWltYWdlLFxuICAgICAqICB1c2UgW1t1bnNpZ25lZFNlcmlhbGl6ZWRdXS5cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFNlcmlhbGl6ZWQodHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlLlxuICAgICAqXG4gICAgICogIFRoZSBoYXNoIG9mIHRoaXMgaXMgdGhlIGRpZ2VzdCB3aGljaCBuZWVkcyB0byBiZSBzaWduZWQgdG9cbiAgICAgKiAgYXV0aG9yaXplIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkU2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFNlcmlhbGl6ZWQoZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgbW9zdCBcImxpa2VseVwiIHR5cGU7IGN1cnJlbnRseSB0aGUgaGlnaGVzdFxuICAgICAqICBzdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBpbmZlclR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy5pbmZlclR5cGVzKCk7XG4gICAgICAgIC8vIFByZWZlciBMb25kb24gKEVJUC0xNTU5KSBvdmVyIENhbmN1biAoQkxPYilcbiAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YoMikgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBoaWdoZXN0IGluZmVycmVkIHR5cGVcbiAgICAgICAgcmV0dXJuICh0eXBlcy5wb3AoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBWYWxpZGF0ZXMgdGhlIGV4cGxpY2l0IHByb3BlcnRpZXMgYW5kIHJldHVybnMgYSBsaXN0IG9mIGNvbXBhdGlibGVcbiAgICAgKiAgdHJhbnNhY3Rpb24gdHlwZXMuXG4gICAgICovXG4gICAgaW5mZXJUeXBlcygpIHtcbiAgICAgICAgLy8gQ2hlY2tzIHRoYXQgdGhlcmUgYXJlIG5vIGNvbmZsaWN0aW5nIHByb3BlcnRpZXMgc2V0XG4gICAgICAgIGNvbnN0IGhhc0dhc1ByaWNlID0gdGhpcy5nYXNQcmljZSAhPSBudWxsO1xuICAgICAgICBjb25zdCBoYXNGZWUgPSAodGhpcy5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpO1xuICAgICAgICBjb25zdCBoYXNBY2Nlc3NMaXN0ID0gKHRoaXMuYWNjZXNzTGlzdCAhPSBudWxsKTtcbiAgICAgICAgY29uc3QgaGFzQmxvYiA9ICh0aGlzLiNtYXhGZWVQZXJCbG9iR2FzICE9IG51bGwgfHwgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyk7XG4gICAgICAgIC8vaWYgKGhhc0dhc1ByaWNlICYmIGhhc0ZlZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZSBhbmQgbWF4RmVlUGVyR2FzXCIpO1xuICAgICAgICAvL31cbiAgICAgICAgaWYgKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5tYXhGZWVQZXJHYXMgPj0gdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcywgXCJwcmlvcml0eUZlZSBjYW5ub3QgYmUgbW9yZSB0aGFuIG1heEZlZVwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9pZiAodGhpcy50eXBlID09PSAyICYmIGhhc0dhc1ByaWNlKSB7XG4gICAgICAgIC8vICAgIHRocm93IG5ldyBFcnJvcihcImVpcC0xNTU5IHRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGdhc1ByaWNlXCIpO1xuICAgICAgICAvL31cbiAgICAgICAgYXNzZXJ0KCFoYXNGZWUgfHwgKHRoaXMudHlwZSAhPT0gMCAmJiB0aGlzLnR5cGUgIT09IDEpLCBcInRyYW5zYWN0aW9uIHR5cGUgY2Fubm90IGhhdmUgbWF4RmVlUGVyR2FzIG9yIG1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgYXNzZXJ0KHRoaXMudHlwZSAhPT0gMCB8fCAhaGFzQWNjZXNzTGlzdCwgXCJsZWdhY3kgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgYWNjZXNzTGlzdFwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIC8vIEV4cGxpY2l0IHR5cGVcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRob3JpemF0aW9uTGlzdCAmJiB0aGlzLmF1dGhvcml6YXRpb25MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNGZWUpIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzR2FzUHJpY2UpIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzQWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0FjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNCbG9iICYmIHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0eXBlcy5zb3J0KCk7XG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGEgbGVnYWN5IHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMGBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzTGVnYWN5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBiZXJsaW4gaGFyZGZvcm0gdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAxYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNCZXJsaW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGxvbmRvbiBoYXJkZm9ybSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDJgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0xvbmRvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYW4gW1tsaW5rLWVpcC00ODQ0XV0gQkxPQlxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQ2FuY3VuKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgdHJhbnNhY2l0b24uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgSlNPTi1mcmllbmRseSBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBzID0gKHYpID0+IHtcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBnYXNMaW1pdDogcyh0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiBzKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHModGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHModGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgdmFsdWU6IHModGhpcy52YWx1ZSksXG4gICAgICAgICAgICBjaGFpbklkOiBzKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBzaWc6IHRoaXMuc2lnbmF0dXJlID8gdGhpcy5zaWduYXR1cmUudG9KU09OKCkgOiBudWxsLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogdGhpcy5hY2Nlc3NMaXN0XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSAqKlRyYW5zYWN0aW9uKiogZnJvbSBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gb3IgYVxuICAgICAqICBUcmFuc2FjdGlvbi1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eCkge1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGdldEJ5dGVzKHR4KTtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkWzBdID49IDB4N2YpIHsgLy8gQFRPRE86ID4gdnMgPj0gPz9cbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VMZWdhY3kocGF5bG9hZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChwYXlsb2FkWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXAyOTMwKHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDE1NTkocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwNDg0NChwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXA3NzAyKHBheWxvYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZyb21cIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgaWYgKHR4LnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSB0eC50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudG8gPSB0eC50bztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubm9uY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm5vbmNlID0gdHgubm9uY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5nYXNMaW1pdCA9IHR4Lmdhc0xpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gdHgubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4RmVlUGVyR2FzID0gdHgubWF4RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhGZWVQZXJCbG9iR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhGZWVQZXJCbG9iR2FzID0gdHgubWF4RmVlUGVyQmxvYkdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHR4LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHR4LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gdHguY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh0eC5zaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gdHguYWNjZXNzTGlzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYXV0aG9yaXphdGlvbkxpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmF1dGhvcml6YXRpb25MaXN0ID0gdHguYXV0aG9yaXphdGlvbkxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB3aWxsIGdldCBvdmVyd3JpdHRlbiBieSBibG9icywgaWYgcHJlc2VudFxuICAgICAgICBpZiAodHguYmxvYlZlcnNpb25lZEhhc2hlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYmxvYlZlcnNpb25lZEhhc2hlcyA9IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGFzc2lnbiB0aGUga3pnIGJlZm9yZSBhc3NpZ25pbmcgYmxvYnMsIHdoaWNoXG4gICAgICAgIC8vIHJlcXVpcmUgdGhlIGxpYnJhcnkgaW4gdGhlIGV2ZW50IHJhdyBibG9iIGRhdGEgaXMgcHJvdmlkZWQuXG4gICAgICAgIGlmICh0eC5remcgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmt6ZyA9IHR4Lmt6ZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYmxvYnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmJsb2JzID0gdHguYmxvYnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lmhhc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LmlzU2lnbmVkKCksIFwidW5zaWduZWQgdHJhbnNhY3Rpb24gY2Fubm90IGRlZmluZSAnLmhhc2gnXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0Lmhhc2ggPT09IHR4Lmhhc2gsIFwiaGFzaCBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lICcuZnJvbSdcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuZnJvbS50b0xvd2VyQ2FzZSgpID09PSAodHguZnJvbSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLCBcImZyb20gbWlzbWF0Y2hcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCwgY29uY2F0LCBlbmNvZGVSbHAsIHRvQmVBcnJheSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQ29tcHV0ZXMgdGhlIFtbbGluay1laXAtNzcwMl1dIGF1dGhvcml6YXRpb24gZGlnZXN0IHRvIHNpZ24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoQXV0aG9yaXphdGlvbihhdXRoKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChhdXRoLmFkZHJlc3MpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgYWRkcmVzcyBmb3IgaGFzaEF1dGhvcml6YXRpb25cIiwgXCJhdXRoLmFkZHJlc3NcIiwgYXV0aCk7XG4gICAgcmV0dXJuIGtlY2NhazI1Nihjb25jYXQoW1xuICAgICAgICBcIjB4MDVcIiwgZW5jb2RlUmxwKFtcbiAgICAgICAgICAgIChhdXRoLmNoYWluSWQgIT0gbnVsbCkgPyB0b0JlQXJyYXkoYXV0aC5jaGFpbklkKSA6IFwiMHhcIixcbiAgICAgICAgICAgIGdldEFkZHJlc3MoYXV0aC5hZGRyZXNzKSxcbiAgICAgICAgICAgIChhdXRoLm5vbmNlICE9IG51bGwpID8gdG9CZUFycmF5KGF1dGgubm9uY2UpIDogXCIweFwiLFxuICAgICAgICBdKVxuICAgIF0pKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgYWRkcmVzcyBvZiB0aGUgcHJpdmF0ZSBrZXkgdGhhdCBwcm9kdWNlZFxuICogIHRoZSBzaWduYXR1cmUgJSVzaWclJSBkdXJpbmcgc2lnbmluZyBmb3IgJSVtZXNzYWdlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlBdXRob3JpemF0aW9uKGF1dGgsIHNpZykge1xuICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyhoYXNoQXV0aG9yaXphdGlvbihhdXRoKSwgc2lnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhvcml6YXRpb24uanMubWFwIiwiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8qKlxuICogIEEgc2ltcGxlIGhhc2hpbmcgZnVuY3Rpb24gd2hpY2ggb3BlcmF0ZXMgb24gVVRGLTggc3RyaW5ncyB0b1xuICogIGNvbXB1dGUgYW4gMzItYnl0ZSBpZGVudGlmaWVyLlxuICpcbiAqICBUaGlzIHNpbXBseSBjb21wdXRlcyB0aGUgW1VURi04IGJ5dGVzXSh0b1V0ZjhCeXRlcykgYW5kIGNvbXB1dGVzXG4gKiAgdGhlIFtba2VjY2FrMjU2XV0uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgaWQoXCJoZWxsbyB3b3JsZFwiKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gaWQodmFsdWUpIHtcbiAgICByZXR1cm4ga2VjY2FrMjU2KHRvVXRmOEJ5dGVzKHZhbHVlKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZC5qcy5tYXAiLCIvLyBjcmVhdGVkIDIwMjMtMDktMjVUMDE6MDE6NTUuMTQ4WlxuLy8gY29tcHJlc3NlZCBiYXNlNjQtZW5jb2RlZCBibG9iIGZvciBpbmNsdWRlLWVucyBkYXRhXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvYmxvYi9tYWluL3NyYy9tYWtlLmpzXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMjc2VjdXJpdHlcbi8vIFNIQS0yNTY6IDA1NjVlZDA0OWI5Y2YxNjE0YmI5ZTExYmE3ZDhhYzZhNmZiOTZjODkzMjUzZDg5MGY3ZTJiMjg4NGI5ZGVkMzJcbnZhciBDT01QUkVTU0VEJDEgPSAnQUVFVWR3bWdEUzhCeFFLS0FQNEJPZ0RqQVRBQW5nRFVBSU1Bb0FCb0FPQUFhZ0NPQUVRQWhBQk1BSElBT3dBOUFDc0FOZ0FtQUdJQUhnQXVBQ2dBSndBWEFDMEFHZ0FqQUI4QUx3QVVBQ2tBRWdBZUFBa0FHd0FSQUJrQUZnQTVBQ2dBTFFBckFEY0FGUUFwQUJBQUhnQWlBQkFBR2dBZUFCTUFHQVVoQmU4QkZ4UkVOOHNGMndDNUFLNUhBVzhBclFrRHpRQ3VoemMzTnpjQlA2OE5FZk1BQlFkSEJ1dzVCVjhGWUFBOU16a0k5cjRaQmc3UXlRQVdBOUNlT3dMTkNqY0NqcWtDaHVBL2xtK1JBc1hUQW9QNkFTZm5FUUR5dFFGSkFqV1ZDa2VYQU9zQTZnb2RBQi9jd2RBVUUwV2xCQ04vQVFVQ1FSakZEL01SQmpIeERRU0pidzBqQnpVQXN3QnhtZSt0bkljQVl3YWJBeXNHOFFBakFFTU1teGNEcWdQS1F5RFhDTU14QTdrVVF3RDNOWE9yQUttRklBQWZCQzBEM3g0QkpRREJHZFVGQWhFZ1ZEOEpud21RSmlOV1lVenJnMG9BR3dBVUFCMEFGbk5jQUNrQUZnQlA5aDNnUGZzRE9XREtuZVkyQ2hnbFgxVURZRDMwQUJzQUZBQWRBQlp6SUdSQW53REQ4d0FqQUVFTXpSYkRxZ01CMnNBRll3WHFBdENuQXNTNEF3cFVKS1J0RkhzYWRVejlBTU1WYndMcEFCTTFOSkVYMFprQ2dZTUJFeU1BeFJWdkF1a0FFelVCVUZBdG1Vd1NBeTREQlRFUjMzRWZ0UUhmU3dCNU14Si9BamtXS1FMekw4RS9jd0JCNlFIOUxRRFBEdE85QVNOcmlRQzVEUUFOQXdDSzIxRUZJOTF6SHdDb0w5a0JxUWNIQndjSEt6VURvd0J2QVFvaFB2VTNmQVFnSHdDeUFjOENLUU1BNXpNU2V6cjdVTGdGbURwL0x6VlFCZ0VHQWk4RllRVmd0OEFGY1R0bFFocENXRW1mZTV0bVo2SUFFeHNEelE4dCtYOHJCS3RUQWx0YkFuMGpzeThCbDZ1dFBXTURUUjhFaTJrUkFOa0RCck5ITnlzREJ6RUNRV1VBY3dGcEoza0FpeVVoQUowQlViOEFMM0VmQWJmTkF6ODFLVXNGV3dGM1lRWnRBbTBBK1ZFZkF6RUpEUUJSU1FDekFRQmxBSHNBTTcwR0QvdjNJWldIQndBUktRQXhBTHNqVHdIWkFlTVBFem1YZ0lId0FCSUFHUUE4QUVVQVFEdDNnZHZJRUdjUVpBa0dUUkZNZEVJVkV3SzBENjRMN1JFZEROa3EwOVBnQURTeEIvTURXd2Z6QTFzRFd3ZnpCL01EV3dmekExc0RXd05iQTFzY0V2QWkyOGdRWnc5UUJIVUZsZ1dUQk40SWl5WlJFWWtITUFqYVZCVjBKaHhQQTAwQkJDTXRTU1E3bXpNVEpVcE1GRTBMQ0FRMlNteXZmVUFEVHpHelZQMlFxZ1BUTWxjNWRBa0dIbmtTcUFBeUQzc2tOYjFPaG5wUGNhZ0tVMCsydFlkSmFrNXZBc1k2c0VBQUNpa0ptMi9EZDFZR1JSQWZKNmtRK3d3M0Fia0JQdzN4Uzl3RTlRWS9CTTBmZ1JrZEQ5R1ZvQWlwTGVFTThTYm5McVdBWGlQNUtvY0Y4VXY0UE9FTFVWRnNEMTBMYVFubk9tZUJVZ01sQVJFaWp3cmhEVDBJY1JEM0NzMXZEZWtSU1FjOUE5bEpuZ0NwQndVTEZSMDVGYmttRkdLd0N3MDVld2IvR3ZvTGt5YXpFeTE3QUFYWEdpVUdVUUV0R3dNQTB5N3JoYlJhTlZ3Z1QyTUdCd3NwSThzVXJGQWtEU2xBdTNoTUdoOEhHU1d0QXBWRGRFcUxVVG9lbHlINlBFRU5haTRYVVlBSCtUd0pHVk1MaFR5aVJxOUZFaEhXUHBFOVRDSk5UREFFT1lNc015ZVBDZE1QaVF5OWZIWUJYUWtsQ2JVTWRSTTFFUnMzeVFnOUJ4MHhseWduR1FnbFJwbGduZ1Q3b3dQM0U5VUREd1ZEQ1VVSEZ3TzVIREVUTWhVdEJSR0JLTnNDOXpiWkxyY0NrMWFFQVJzRnp3OHBIK01RVkVma0R1MElud0pwQTRjbDd3QXhGU1VBR3lLZkNFZG5BR09QM0ZNSkxzOEl5MnB3STNnRGF4VHJaUkYzQjVVT1d3ZXJIRGNWd3h6bGNNeGVENFlNS0tlekNWOEJlUW1kQVdNRTV3Z05OVitNcENCRloxZUxYQmlmSUdWQlExNEFBalVNYVJXalJNR0hmQUtQRDI4U0h3RTVBWGNIUFEwRkFuc1I4UkZ2RUprSTc0WUlOYmt6L0RvcEJGTWhoeUFWQ2lzRFUyelNDeXNtL1F6OGJRR25FbVlERURSQmQvSm5yMkM2S0JnQkJ4MHl5VUZrSWZVTGxrL1JES0FheFJoR1ZESVo2QWZEQS9jYTl5ZnVRVnNHQXdPbkJ4YzZVVFB5Qk1FTGJRaVBDVU1BVFE2bkd3ZmJHRzRLZFl6VUFUV1BBYnVkQTF1Vmh3Snprd1k3Qnc4QWF3K0xCWDNwQUNFQ3F3aW5BQWtBMHdOYkFEMENzUWVoQUIwQWlVVUJRUU1yTXdFbDZRS1RBNWNJTmM4Qm1UTUI5eTBFSDhjTUdRRDdPMjVPQXNPMUFvQnVacVlGNFZ3Q2tnSk5PUUZSS1FRSlVrdFZBN04xNVFEZkFFOEdGK05MQVJtdlRzOGU1MGNCNDNNdkFNc0Evd0FKT1FjSlJRSFJBZmR4QUxzQll3czFDYWEzdVFGUjdTMEFod0FaYndIYkFvMEE0UUE1QUlQMUFWY0FVUVZkL1FYWEFsTk5BUlUxSEM5YlpRRy9BeU1CTndFUkFIMEd6NUdwelFzakJIRUgxd0lRSHhYbEF1OHlCN2tGQXlMakU5RkN5UUs5NGxrQU1ob0tQQXFyQ3FwZ1gyUTNDalYyUFZRQUVoK3NQc3MvVWdWVk8xYzdYRHRYTzF3N1Z6dGNPMWM3WER0WE8xd0RtOFBtdytZS2NGOUpZZThNcWczWVJNdzZUUlBmWUZWZ05oUE1MYnNVeFJYU0pWb1pRUnJBSndrbDZGVU5Ed2d0MTJZMENEQTBlUmZBQUVNcGJJTkZZNG9lTkFwUEhPdFRsVlQ4TFI4QXRVdW1NN01Oc0JzWlJFUUZTM1h4WWk0V0Vnb21BbVNGQW1KR1gxR3pBVjgzSkFLaCt3Sm9uQUptRFFLZmlEZ2ZEd0ptUHdKbUtnUnlCSU1EZnhjRGZwWTVDamw3R3ptR09pY25BbXdoQWpJNk9BNENiY3NDYmJMempnTTNhMGt2QVdzQTRnRGxBRTRKQjV3TWtRRUNEOFlBRWJrQ2R6TUNkcVpEQW5sUFJ3SjR2aUZnMzBXeVJ2Y0NmRU1DZXN3Q2ZRMENmUFJJQkVpQlp5Z0FMeGxKWEVwZkdSdEswQUxSQlFMUTBFc3JBNGhUQTRmcVJNbVJOZ0x5cFYwSEF3T3lTOUpNTVNrSDAwMVFUYk1DaTBNQ2l0ekZId3NoUjJzSnV3S09Pd0tPWUVTYmhRS08zUUtPWUh4UnVGTTVBUTVTMkZTSkFwUC9BcE1RQU8wQUlGVWlWYk5WMUFvc0h5bVppakxsZUdwRlB6MENsNk1DNzdaWUphd0FYU2tDbHBNQ2xvQ2dBSzFac0ZvTmhWRUFQd0tXdVFLV1VseElYTlVDbWM4Q21XaGN6bDBMSFFLY256bkdPcUVDbkJvQ241OENucnlPQUNFVE5TNFRBcDMxQXA2V0FMbEJZVGhoOHdLZTF3S2djZ0d0QXA2akl3S2VVcWxqekdRcktTOENKN01DSm9JQ29QOENvRkRiQXFZekFxWFNBcWdEQUlFQ3AvWm9nR2kxQUFkTmFpQnExUUtzNXdLc3NnS3Rhd0t0QmdKWElRSlY0QUt4NWRzREgxSnNtd0t5d1JFQ3N1d2JiT1J0WjIxTVl3TWwwUUsyWUQ5RGJwUURLVWtDdUdJQ3VVc1pBcmt1ZTNBNmNPVUN2UjBETGJZRE1oVUN2b3h5QmdNemRRSytIbk1tYzFNQ3c4OEN3d2h6aG5SUE9VbDA1QU04cXdFRFBKNERQY01DeFlBQ3hrc0N4aFNOQXNodFZRTElTQUxKVXdMSk1nSmtvUUxkMW5oOVpYaXllU2xMMUFNWXAyY0dBbUg0R2ZlVktIc1BYcFpldnhVQ3oyOEN6M0F6VDFmVzl4ZWpBTXF4QXM5M0FTM3VBMDRXZms4SkF0d3JBdHVPQXRKVEExSmdBMU5qQVFVRFZaQ0FqVU1FenhyeFpFbDVBNExTZzVFQzJzc0MyZUtFRklSTnAwQURocWtBTXdOa0VvWjFYZjBBV1FMZmFRTGV2SGQ3QXVJejdSZ0I4elFyQWZTZkFmTFdpd0xyOXdMcGRIMERBdXI5QXVyb0FQMUxBYjBDN28wQzY2Q1dycGNIQXU1REE0WGttSDF3NUhHbEF2TUhBRzBEamhxWmx3TDNGd09SY2dPU2l3TDNuQUw1M1FMNGFwb2dtcSsvTzVzaUE1MkhBdjcrQVI4QVBaOGdBWiszQXdXUkE2WnVBNmJkQU5YSkF3WnVvWXlpQ1EwRERFMEJFd0VqQjNFR1piMXJDUUMvQkcvREZZOGV0eEVBRzNrOUFDY0ROeEpSQTQyREFXY3JKUUNNOHdBbEFPYW5DNk9WQ0xzR0k2ZkpCZ0N2QlJuREJ2RWxSVVlGRm9BRmNEOUdTRE5DS1VLOFgza1pYOFFBbHMwRk9nQ1FWQ0did1RzdVlEb1p1dGNPTnhqT0dKSEovZ1ZmQldBRlh3VmdCV3NGWUFWZkJXQUZYd1ZnQlY4RllBVmZCV0JPSFFqZmpXOEtDZ29LYkY3eE13VFJBN2tHTjhQREFNTUVyOE1BNzBneEZyb0ZUajV4UG5oQ1IwSytYMzAvWC9BQVdCa3pzd0NOQnN4enpBU203MGFDUlM0ckRETWVMejQ5Zm5YZmNzSDVHY29zY1FGejEzWTRId1ZuQlhMSnljbkFDTmRSWXdnSUNBcUVYb1dUeGdBN1A0a0FDeGJaQnUyMUt3MEFqTXNUQXdrVkFPVnRKVVVzSjFKQ3VVTEVTVUFyWHk5Z1BpOUFLd25KUlFZS1REOUxQb0EraVQ1NFBua0NrVUxFVVVwRFg5TldWM0pWRWpRQWMxdzNBM0lCRTNZblgrZzdRaU1KYjZNS2Fpc3pSQ1V1UXJOQ3hEUE1DY3dFWDlFV0p6WVJFQkVFQndJSEtuNmwzM0pDTlZJZnliUEp0QWx0eWRQVUNtaEJady90RUtzWkFKT1ZKVTFDTFJ1eGJVSE9RQW83UDBzK2VFSkhIQThTSlZSUGRHTTBOVnJwdkJvS2hmVWxNMEpISEdVUVVoRVdPMXhMU2o4TU8wdWNOQXFKSXpWQ1J4djlFRnNxS3lBNE9RZ05qMm53WmdwNVpORmdFMkExSzNZSFMyQWhRUW9qSm1DN0RncHpHRzFXWUZVWkNRWUhaTzlnSFdDZFlJVmd1MkJUWUpsd0ZoOEd2UmJjWGJHOFlndERIck1Cd3pQVnlRb25IUWdrQ3lZQmdRSjBBamM0blZxSUF3R1NDc0JQSWdEc0szU1dFdElWQmE1TjhnR2pBbytrVndWSVp3RC9BRVVTQ0R3ZVg0SVRyUlFzSjhLM1R3QlhGRHdFQUIwVHZ6VmNBdG9UUzIwUkl3RGdWZ1o5QkJJbVlnQTVBTDRDb2k4TEZuZXpPa0NuSVFGakFZNEtCQVBoOVJjR3NnWlNCc0VBSmN0ZHNXSVJ1MmtUa1FzdFJ3N0RBY01CS2dwUEJHSUdNREF3S0NZbktUUWFMZzRBS1JTVkFGd0NkbCtZVVowSmRpY0ZEM2xQQWR0MUY5WlpLQ0d4dUUzeUJ4a0ZWR2NBL3dCRkVnaUNCd0FPTEhRU2p4T3RRRGcxejdkZUZSTUFaOFFUQUd0S2IxQXBJaVBIQURrQXZnS2lMeTFERnRZQ21CaURBbEREV05CMGVvN2ZwYU1PL2FFVlJSdjBBVEVRWkJJT0R5TUVBYzhKUWhDYkRSZ3pGRDRUQUVNQXU5WUJDZ0NzQU9rQW01STNBQndBWXh2T05uUitNaFhKQXhnS1F5eEwyK2trSmhNYmhRS0RCTWtTc3ZGMEFEOUJOUTZ1UUM3V3FTUUh3eEVBRUVJdTFoa2hBSDJ6NGlRUHd5SlBITldwZHlZQlJTcG5KQUx6b0JBRVZQUHNIMjBNeEEwQ0NFUUtSZ0FGeUF0RkFsTU53d2pFRFVRSlJBckVMdGFwTWc3RERaZ0pJdytUR3VrRUl3dkRGa01BcUF0REVNTU1CaGlvZStRQU8zTU1SQUFDcmduRUJTUFk5UTBGRG5iU0JvTUFCOE1TWXhrU3hBRUpBUElKQUFCOEZXTU9GdE1jL0hjWHd4aERBQzdEQXZPb3d3QWV3d0pkS0RLSEFBSERBQUxyRlVRVnd3QWJ3eXZ6cFdNV3Y4d0EvQUJwQXkrK2JjWURVS1BEMEtoREN3S21KMU1BQW1NQTUrVVp3eEFhZ3dpcEJSTC9lQURmdzZmREdPTUNHc09qazNsNkJ3T3BvNHNBRXNNT0d4TUFBNXNBYmNNT0FBdkRwME1KR2tNRHdnaXBuTklQQXdmSXFVTUdBT0dEQUFQekFCWERBQWNEQUFuREFHbVRBQnJEQUE3RENoakRqbkVXQXdBQll3QU9jd0F1VXlZQUJzTUFGOE1JS1FBTlVnQzZ3eTRBQThNQURxTXE4d0N5WWdBY0l3QUI4d3FwQUFYT0N4MFY0d0FIb3dCQ3d3RUtBR25EQUF1REFCM0RBQWpEQ2FrQUJkSUFicWNaM1FDWkNDa0FCZElBQUFGREFBZmpBQjJqQ0NrQUJxSUFDWU1BR3pNQWJTTUE1c09JQUFoakFBaERBQlREQkFrcEFBYlNBT09UQUFsREM2a096UHRuQUFkREFHNmtRRkFBVHdBS3d3d0FBME1BQ2JVRFB3QUhJd0FaZ3dBQ0U2Y0RBQW9qQUFwREFBb0RwL01Hd3dBSkl3QURFd0FRUXdnQUZFTUFFWE1BRDVNQURmTUFEY01BR1JNT0ZpTUFGVU1BYnFNV3V3SERBTUlBRTBNTEFHa3pFZ0RoVXdBQ1F3QUVXZ0FYZ3dVakFBYllBQmpEQlNZQmd6QmFBRUZOQUxjUUJ4VU1lZ0F3TW5nQnJBMElaZ0owS3hRSEJSRVBkMU4wWnpLUkp3YUlIQVpxTlQ0RHFRcThCd25nQUI0REF3dDJBWDU2VDFvY0tRTlhBaDFHQVRRR0MzdE94WU5hZ2tnQU1RQTVDUUFEQVFFQVd4TGpBSU9ZTkFFekFIN3RGUms2VGdsU0FGOE5BQWxZQVErUzFBQ0FRd1FvclFCaUFONGRBSjF3UHllVEFOVnp1UURYM0FJZUVNcDlleU1nWGlVQUVka0JrSml6S2x0YlZWQWFSTXFSQUFFQWh5US9TREV6NkJtZlZ3QjZBVEVzT0NsS0lSY0RPRjBFLzgzMkFGTnQ1QUJ5QW5rQ1J4R0NPczk0TmpYZEF3SU5HQm9uREJ3UEFMVzJBd0lDQWdBQUFBQUFBQVlEQlFNREFSclVBd0F0QUFBQUFnRUdCZ1lHQmdZRkJRVUZCUVVFQlFZSENBa0VCUVVGQlFRQUFBSUNBQUFBSWdDTkFKQUFsVDBBNmdDN0FOd0FwRVFBd2dDeUFLMEFxQUR1QUtZQTJnQ2pBT2NCQ0FFREFNY0FnUUJpQU5JQTFBRURBTjRBOGdDUUFLa0JNUURxQU44QTNBc0JDUTh5TzlyYTJ0cTh4dUxUMXRSSk9CMEJVZ0ZjTlUwQldnRnBBV2dCV3dGTVVVbExiaE1CVXhzTkVBczZQaE1PQUNjVUt5MHZNajVBUUVORFEwUkZGRVlHSkZkWFYxZFpXVmhaTDFwYlhWeGNJMk5uWjJab1p5cHNibloxZUhoNGVIaDRlbnA2ZW5wNmVucDZlbnA4ZkgxOGUySUFSUElBU1FDYUFIZ0FNZ0JtK0FDT0FGY0FWd0EzQW5idkFJc0FCZmo0QUdRQWsvSUFud0JQQUdJQVpQLy9zQUNGQUlVQWFRQldBTEVBSkFDMkFJTUNRQUpEQVB3QTV3RCtBUDRBNkFEL0FPa0E2UURvQU9ZQUx3SjdBVkVCUUFFK0FWUUJQZ0UrQVQ0Qk9RRTRBVGdCT0FFY0FWZ1hBREVRQ0FFQVV4OFNIZ3NkSGhZQWpnQ1dBS1lBVVFCcUlBSXhBSFlBYndDWEF4VURKeklESVVsR1R6RUFrUUpQQU1jQ1Z3S2tBTUFDbGdLV0FwWUNsZ0tXQXBZQ2l3S1dBcFlDbGdLV0FwWUNsZ0tWQXBVQ21BS2dBcGNDbGdLV0FwUUNsQUtVQXBRQ2tnS1ZBblVCMUFLWEFwOENsZ0tXQXBVZUFJRVRCUUQrRFFPZkFtRUNPaDhCVkJnOUF1SVpFak1iQVU0L0cxV1pBWHVzUkFGcFlRRUZBMEZQQVFZQW1URWVJSmR5QURGb0FIRUFOZ0NSQTV6TWsvQzJqR0lOd2pNV3lnSVpDYVhkZkRJTEJDczVkQUU3WW5RQnVnRGxob2lIaG9pR2lZcUtob3VPaklhTmtJNklqNHFRaXBHR2tvYVRocFNTbFlhV2hwZUttSWFaaHBxR200YWNpNTJRbm9xZmh1SUM0WFRwQXQ5MEFJcDBMSFNvQUlzQWRIUUVRd1JBQkVJRVJRUkRCRWtFUmdSQkJFY0VTUVJJQkVRRVJnUkpBSjV1ZEFDckE0OTBBTHh1QVExMEFORlpkSFFBMTNRQ0ZIUUEvbUowQVA0QklRRCtBUHdBL0FEOUFQd0RoR1owM0FTTUsyM0hBUDRBL0FEOEFQMEEvQ1IwZEFDUlluUUEvZ0NSQVNFQS9nQ1JBdlFBL2dDUkE0Um1kTndFakN0dHh5UjBBUDlpZEFFaEFQNEEvZ0Q4QVB3QS9RRDhBUDhBL0FEOEFQMEEvQU9FWm5UY0JJd3JiY2NrZEhRQWtXSjBBU0VBL2dDUkFQNEFrUUwwQVA0QWtRT0VablRjQkl3cmJjY2tkQUpMQVQ1MEFsSUJRWFFDVThsMGRBSmZkSFFEcGdMMEE2WURwZ09uQTZjRHB3T25BNFJtZE53RWpDdHR4eVIwZEFDUlluUUJJUU9tQUpFRHBnQ1JBdlFEcGdDUkE0Um1kTndFakN0dHh5UjBCRGgwQUpFRU9RQ1JEcFU1ZFNnQ0FEUjAzZ1YyQ3dBcmRBRUZBTTVpQ25SMEFGMWlBQVljT2dwMGRBQ1JDblFBWEFFSXdXWjBDblJtZEhRQWtXWjBDblJtZEVYZ0FGRjAzZ3AwZEVZMHRsVDJ1M1NPQVFUd3Njd2hqWlpLcmhZY0JTZkZwOVhOYktpVkRPRDJiK2NwZTQvWjE3bVFuYnR6emhhZVF0RTJHR2owSUROVGpSVVN5VHh4dy9SUEhXLyt2UzdkMU5mUnQ5ejlRUFpnNFg3UUZmaENua3ZnTlBJSXRPc0MyZVY2aFBhbm5aTkhsWjl4cndaWElNT2x1M2pTb1FTcTc4V0Vqd0xqdzFFTFNsRjFhQnZmendrNVpYN0FVdlF6alBRS2JEdVErc200d05PcDRBNkFkVnVSUzB0MXkvRFpwZzRSNm03Rk5qTTlIZ3ZXN0JpODh6YU1qT282bE04d3RCQmRqOExQNHlsdjN6Q1hQaGViTUtKYzA2Nm85c0Y3MW9GVy84Slh1ODZISmJ3RElENWx6dzVHV0xSL0xoVDBRcW5wMkpReE5aTmZjYkxJelB5K1l5cHFSbS9sQm1HbWV4KzgyK1Bpc3hVdW1TZUprQUxJVDZySmV6eE1IK0NUSm1RdHQ1dXdUVmJMM3B0bWpEVVF6bFNJdldpOFRsN25nMU5wdVJuMU5nNG4xNFFjKzNJaWw3T3drdk5Xb2dMU1BrbjNwaWhJRnl0eUlHbU1oT2UzbjF0V3N1TXk5QmRLeXFGNFozdjJTZ2dnVEw5S1Z2TVhQbkNiUmUrb091RkZQM0hlakJHL3c5Z3ZtZk5Zdmc2SnVXaWEybGNTU04xdUlqQmt0em9JYXpPSFBKWjdrS0hQejhtUldWZFczbEE4V0dGOWRRRjZCbTY3M2Jvb3YzQlVXRFUySk5jYWhSMjNHdGZIS0xPei92aVorclluWkZhSXpuWE82N0NZRUoxZlh1VFJwWmhZWmtLZTU0eGVvYWdrTkdMcytOVFpIRTByWDQ1L1h2UTJSR0FEWDZ2Y0F2ZHhJVUJWMjd3eEdtMnpqWm80WDNJTGdBbHJPRmhldVo2d3RzdmFJajR5TFk3cXFhd2xsaWFJY3J6MkcrYzN2c2NBbkNrQ3VNek1tWnZNZnU5bEx3VHZmWCszY1ZTeVBkTjlad2dEWmhmalJnTkpjTGlKNjdiOXh4OEpIc3dwcmJpRTN2OVVwaG90QVBJZ25YVklONUttTWMwcGlYaGM2Y0NoUG5OK01SaEc5YWR0ZHR0UVRUd1NJcGw4STQvai8vZDNzejEzMjZxVEJUcFBSTS9IZ2gza3pxRVhzOFpBazRFclFoTk84aHpyUTBETGtXTUEvTis5MXRuMk1kT0puV0MyRkNaZWhrUXJ3endiS09qaHZac2JNOTVRb2VMOXNrWXlNZjRzclZQVkpTZ2c3cE9MVXRyL245ZVQ5OW9lOW5MdEZScGpBOW9rVjJLajhoOWs1SGFDMG9pdlJEOFZ5WGtKODF0Y2Q0ZkhOWFBDZmxvSVFhc3hzdU8xOC80NmRSMmpndWwvVUlldDJHMGtSdm55T05NS2hIczZKMjZGRW9xU3FkK3JmWWplRUd3SFdWRHBYMWZoMWpCQmNLR01xUmVwanU5WTAwbURWSEMrWGRpai9qNDRyS2Z2ZmpHaW5OczFqTy8wRjNqQjgzWENESU5OL0hCODRheGxQKzNFL2tsa3RSbyt2bDNVL2FpeU1KYklvZEUxWFNzRG42VUF6SW9NdFVPYlkyK2svNGdZL2wrQWtaSjVTajJ2UXJreUxtM0ZveGpoRFgrMzFVWEJGZjlYckFIMzFmRnFvQm1ERVp2aHZ2cG5aODdOK29aRXU3VTlPL25uaytRV2ozeDh1eW9SYkVuZitPNVVNcjlpMG5IUDM4SUY1QXZ6ckJXOFlXQlVSMG1JQXpJdm5kUXE5TjN2L0p0bzNhUGpQWFVQbDhBU2RQUHlBcDdqRU5mOGJrN1ZNTTlvbDlYR21sQm1lRE11R3F0K1d6dUw2Q1hBeFhqSWhDUE01dkFDY2hnTUovOFhCR0xPL0QxaXNWdkdod3dISHIxRExhSTVtbjJKci9iMXBVRDkwdWNpRGFTOGNYTkR6Q1d2Tm1UL1BoUWU1ZThuVG5ubmt0OERzL1NJamliY3VtL2ZxRGhLb3B4QVk4QWtTclBuK0lHREVLT08rVTNYT1A2ZGpGczJINU45K29yaE9haGlRazVLbkVVV2ErQ3prVnpocDhiTUhSYmc4MXFoampYdUlLYkhqU0xTSUJLV3FvY2tHdEtpblkrejQvUmRCVUY2cGNjM0ptbmx4VmNOZ3JJNFNFektVWlN3Y0QyUUN5eHpLdmUrZ0FtZzZadVNSa3BQRmE2bWZUaHU3TEpOdTNINUs0MnVDcE52UEFzb2Vkb2xLVi9MSGUvZUorQmJhRzVNRzBOYVNHVlBSVW1ORk1GRlNTcFhFY1h3YlZoN1VFVE9aWnRvVk5SR09JYmJraWczTWNFdFI2OGNHMFJaQW9KZXZXWW83RGcvbFoxQ1F6YmxXZVV2VkhtcjhmWTROcWQ5SkppSC96RVgyNG1KdmlINjBmQXlGcjBBM2M0YkMxajN5WlU2MFZnSnhYbjhKZ0pYTFVJc2lCbm1LbU1Zeis3eUJRRkJ2cWIyZVludVc1OWpvWkJmNTYvd1h2V0lSNFI4d1RtVjgwaTFtWnkrUzQrQlVFUytoemprMHVYcEMvLy96L0lscUhaMW1vbnpsWHA4YUNmaEdLTXRpNzNGSTFLYkwxcTZJS080ZnVCdVo1OWdhZ2puNXhVNzltdU1wSFhnNlMrZStnRE0vVTlCS0xIYmw5bDZvOGN6UUtsNFJVa0pKaXFmdFFHMmkzQk1nL1RRbFVZRmtKRFlCT092QXVnWXV6WVNEblpiRERkL2FTZDl4ME9lNkYrYkpjSGZsOStncDZMNS9UZ0ErQmRGRm92YmZDclE0MHM1dk1Qdzg4NjZwTlg4enlGR2VGV2R4SXBQVnA5UmcxVVBPVkZiRlpydmFGcS9ZQXpIUWdxTVdwYWhNWWZxSHBtd1hmSEwxL2twWW1HdUhGd1Q1NW1RdTBkeWxmTnVxMk9xMGhUTUNQd3FmeG51QklQTFhmY2k0WTFBTnkrMUNVaXBReGxkL2l6VmgxNld5RzJRMENRUTlOcXRBbngxSENId0RqN3NZeE9TQjB3b3BaU25PenhRT2NFeG14clZURjJCa090aFZwR2Z1aGFHRUNmQ0pwSktwam5paFkreE9UMlFKeE42MSs5SzZRU3F0djJTaHI4MkkzamdKcnFCZzB3RUxGWlBqdkhwdnpUdGFKbkxLNlZiOTdZbjkzM2tvTy9zYU43ZnNqd05LenA0bDJsSlZ4Mm9yakNHekMvNFpMNHpDdmVyNmFRWXRDNXNkb3ljaHVGRTZ1Zk9pb2crVldpNVVEa2Jtdm10YWgvM2FBckVCSWkzOXM1SUxVbmxGTGdpbGNHdXo5Q1FzaEVZN2Z3Mm91b0lMQVlQVlQvZ3lBSXEzVEZBSXdWc2wra3RrUnovcUdmbkNER3JtNWdzbC9sOVFkdkNXR3NqUHozZFU3WHVxS2ZkVXJyLzZYSWdqcDRyZXk2QUpCbUNtVUpNaklUSFZkRmI1bTFwK2RMTUNMOHQ1NXpENDJjbWZ0bUxFSkMwRGEwNFlpUkNWVUJMTGE4RDA3MS9ONVVCTkJYRGgwTEZzbWhWLzVCNUV4T0I0ajNXVkcvUzNsZks1bytWNkVMSHZ5NlJSOW40YWMrVnNLNFZFNHlwaFB2VitrRzlGZWdUQkg0WlJYTDJIeXRVSENkdUphekIvS3lramZldFl4T1hUTHdzMjY3YUdPZCtJK0poS1AvLytWblhtUzkwT0QvanZMY1Z1MGFzeXFjdVlOMW1TYjZYVGxDa3F2MXZpZ1pQSVl3TkYvenBXY1QxR1IvNmFFSVJqa2gweWhnNExYSmZhR29iWUpUWTRKSTU4S2lBS2dtbWdBS1dkbDVuWUNlTHFhdlJKR1FOdVl1WnRaRkd4K0lrSTR3NE5TMnh3YmV0Tk11bk9qQnUvaG1LQ0kvdzd0ZmlpeVVkLy80cmJUZVd0NGl6Qlk4WXZHSU42dnlLWW1QLzhYOHdIS0NlTitXUmNLTTcwK3RYS05HeWV2VTlIMkRnNUJzbGpuVGY4WWJzSjFUbU1zNzRDZTJYbEhpc2xlZ3VoeWVnNDRyUU9IWnV3LzZIVGtobm51cksyZDYycTZ5UzcyMTBTc0FJYVIralhNUUErc3Zrckxwc1VZK0YzMFV3ODl1T2RHQVI2dm80RklNRTBFZlZWZUhUdTZlS2ljZmhTcU9lWEpoYmZ0Y2QwOHNXRW5OVUwxQzlmbnByVGdkODNJTXV0OG9uVlVGMGh2cXpaZkhkdVBqYmp3RVhJY29ZbXkrUDZ0Y0paSG1lT3Y2VnJ2RWRrSERKZWNqSHVIZVdBTmU3OVZHNjYycVRqQS9IQ3Z1bVZ2M3FMK0xyT2NwcUdwczJaR3dRZEZKN1BVNGl1eVJsQnJ3Zk8reG5QeXI0N3MyY1hWYld6QXl6bkRpQkdqQ00za3N4ampxTTYyR0U5QzhmNVUzOGtCM1ZqdGFiS3AvblJkdk1FU1BHREc5MGJXUkxBdDFRazVEeUx1YXpSUjFZemRDMWMraFpYdkFXVjh4QTcyUzRBOEI2N3ZqVmhiYmEzTU1vcDI5M0ZlRVhwZTd6SXRNV3JKRy9MT0g5QnlPWG1Zbk5KZmptZnVYOUticnBnTE9iYTRuWitmbDhHYmR2L2lodis2d0ZHS0hDWXJWd21oRkMwSjNWMmJuMnRJQjF3Q2MxQ1NUM2QzWDJPeXhoZ3VYY3M0c202NzlVbmd6b2Z1U2VCZXdNRkpib0lRSGJVaC9tMkpoVzJoRzlESXZHMnQ3eVpJektCVHo5d0J0bk5DKzJwQ1JZaFNJdVExajh4c3o1VnZxbnlVSXRodnVveXl1N2ZOSXJnL0tRVVZtR1FhcWtxWmsvVng1YjMzL2dzRXM4eVg3U0MxSitOVjRpY3o2YnZJRTdDNUc2TWNCYUk4clZnNTZxNVFCSld4bi84N1Exc1BLNCtzUWE4ZkxVNWdYbzRwYWFxNGNPY1E0d1IwVkJIUEdqS2grVWxQQ2JBMW5MWHlFVVg0NXFaOEo3L0xuNEZQSkUyVGR6RDBaOE1MU05RaXlrTU1tU3lPQ2lGZnk4NFJxNjBlbVlCMnZEMDlLall3c29JcGVEY0JEVEVsQmJYeE5ENzJ5aGQ5cEMvMUNNaWQvNUhVTXZBTDI3T3RjSUpEek5LcFJQTnFQT3B5dDJhUEd6OVFXSXM5aFE5TGlYNXM4bTloalRVdS9mN015SWF0ampkK3RTZlEzdWZaeFBwbUpoVGFCdFp0S0xVY2ZPQ1VxQUR1TytRb0g4Qjl2NlUrUDBIVjFHTFFtdG9ORlRiM3M3NGl2WmdqRVMwcWZLKzhSZEdnQmJjQ01TeThlQnZoOTgrZXQxS0lGcVNlMUtRUHlYVUxCTVRzSVlueXNJd2laQkpZZEkyMHZzZVYrd3VKa2NxR2VtZWhLamFBYjlMNTd4Wm0zZzJ6WDBiWjJ4ay9mVStiQ283VGxuYlc3SnVGMVlkVVJvLzJHdzdWY2xERzFXN0xPdGFzMkxYNHVwaWZaLzIzcnpwc25ZL0FMZlJncmNXUDVoWW1WOVZ4Vk9RQTFmWnZwOUYyVU5VKzdkN3hSeVZtNXdpTHAzLzBkbFY3dmR3MVBNaVpyYkRBWXpJVnFFalJZMllVMDNzSmhQbmx3SVBjWlVHNWx0TDZTOFhDeFUxZVlTNWNqcjM0dmVCbVhBdnk3eU40WmpBcklHMGRmRC81VXBCTmxYMVpQb3hKT3d5cVJpM3dRV3RPemQ0b05LaDBMa29UbThjd3FnSWZLaHFxR09od283MUkrelhuTWVtVHYyQjJBVXpBQld5Rnp0R2dHVUxqRER6V1l3SlVWQlRqS0NuNUsyUUdNSzFDUVQ3U3p6aU9qbytCaEFtcUJqenVjM3hZeW0yZWVkR2VPSVJKVnlUd0R3MzdpQ01lNGc1VmJuc2I1WkJkeE9Bbk1UN0hVNERIcHhXR3VRN0dlaVkzMENwYnZ6c3M1NSs1S20xWXNiRDVlYTNOSTlRTllJWG9sNWFwZ1N1OWRaOGY4eFM1ZHRIcGlkbzVCY2xEdUxXWTRsaGlrMHRiSmEwN3lKaEgwQk95RXV0L0dSYllUUzZSZmlUWVdHTUNrTnBmU0hpN0h2ZGlUZ2xFVkhLWlhhVmhlekg0a2tYaUl2S29wWUFsUHVzZnRwRTRhNUlad3Z3MXgvZUx2b0RJaC96cG85RmlRSW5zVGIyU0FrS0hWNDJYWUJqcEpEZzQzNzRYaVZiM3dzNHFNMHM5ZVNRNUh6c01VNE9aSkt1b3BGakJNK2RBWkVsOFJVTXg1dVUyTjQ4NktyMTQxdFZzR1FmR2pPUllNQ0pBTXN4RUxlTlQ0Um1XalJjcGRUR0J3Y3g2WE45ZHJXcVBtSnpjckdySDQrRFJjNytuMXcza1Bad3UwQmtOcjZoUXJxZ283SlRCOUE1a2RKL0g3UDRjV0JNd3NtdWl4QXpKQjN5clFwbkdJcTkwbHhBWEx6RENkbjFMUGlic1J0N3JITmpnUUJrbFJnUFo4dlRialhkZ1hyVFdRc0s1TWRyWFhRVlBwMFJpbnEzZnJ6WktKMHFENlFoYzQwVnpBcmFVWGxvYjFndmtoSzN2cG1IZ0k2RlJsUVpOeDZlUnFrcDB6eTRBUWxYODEzZkFQdEwzak1SYWl0R0ZGam8wem1FcmxvQytoK1lZZFZRNms0Ri9lcHhBb0YwQm1xRW9LTlR0Nmo0dlFaTlEyQm9xRjlWajUzVE9Jb05tRGl1OVhwMTVSa0lnUUlHY29McGZvSWJlbnpwR1VBdHFGSnA1VytMTG54MzhqSGVFQ1RKL25hdktZMU5XZk4wc1kxVDgvcEI4a0lIM0RVM0RYK3U2VzNZd3B5cEJNWU9oYlN4R2pxODRSWjg0ZldKb3c4cHlIcW40Uy85SjE1RWNDTXNYcXJmd3lkOW1oaXUzK3JFbzlwUHBvSmtkWnFIanJhNE52ekZ3dVRoTkt5Nmhhby9TbEx3M1pBRFVjVXAzdzNTUlZmVzJyaGw4MHpPZ1RZbktFMEhzMnFwMUo2SDN4cVBxSWt2VURSTUZEWXlSYnNGSTNNOU1FeW92UGs4cmx3Ny8wYTgxY0RWTG1Cc1IyemUycEJ1S2IyM2ZiZVpDMHVYb0l2RHBwZlR3SUR4azFPcTJkR2VzR2Mrb0pYV0pMR2tPaGEzQ1grRFVuemdBcDlIR0g5UnNQWk42M0huNFJNQTVlU1ZoUEhPKzlSY1JiL0lPZ3RXMzFWMVE1SVBHdG94UGpDK01FSmJWbElNWUFEZDlhSFlXVUlRS29wdVBPSG1vcVNrdWJuQUtuemdLSHFnSU9mVzVSZEFnb3RONkJOK08yWllIa3VlbUxudlE4VTlUSFZyUzFSdExtS2JjQzdQZWVEc1l6bnZxemVnNlZDTndtcjBZeXgxd25ManlUODRCWnozRUp5Q3B0RDN5ZXVlQXlEV0lzMEwycXMvVlEzSFV5cWZyamEwVjFMZER6cUFpa2VXdVY0c2M3UkxJQjY5akVJQmpDa3laZWRvVUhxQ3JPdlNoVnp5ZDczT2RySlcwaFBPdVF2MnFPb0hEYzl4VmI2WXU2dXEzWHFwMlphSDQ2QTdsemV2YnhRRW1mcnp2QVlTSnVaNFdEazFIejNRWDFMVmRpVUswRXZsQUdBWWxHM01kMzByN2RjUE42M3lxQkNJajI1cHJwdlpQMG5JNCtFZ1dvRkc5NVY1OTZDdXJYcEtSQkdSalFsSEN2eTVJYi9pVzhuWkpXd3JFVDNtZ2Q2bUVoZlA0S0N1YUxqb3BXczdoK01kWEZkSXY4ZEhRSmdnMXhpMWVZcUIwdURZanh3Vm1yaTBTdjVYS3V0L29ucWFwQytGUWlDMkMxbHZZSjlNVmNvNnlEWXNTM0FBTlVmTXR2dGJZSTJoZndaYXRpU3Nub1VlTVpkMzRHVmprTU1LQStYbmpKcFhnUlcyU0hUWnBsVm93UG1Kc3ZYeTZ3M2NmTzFBSzJkdnRaRUtUa0MvVFk5TEZpS0hDRzBEbnJNUWRHbTJsemxCSE05aUVZeW5IMlVjVk1oVUVqc2Mwb0RCVGdvMlpTUTFnemtBSGVXZUJYWUZqWUx1dWY4eXpUQ3k3L1JGUjgxV0RqWE1icTJCT0g1ZFVSbnhvNm9pdm14TDNjS3pLSW5sWmtEMzFudnBIQjlLazdHZmNmRTF0KzFWNjRiOUx0Z2VKR2xwUkZ4UUNBcVdKNURvWTc3c2tpOGdzT0VPcjJ1eXdaYW9PL05HYTBYMHkxcE5RSEJpM2IyU1VHTnBjWnhEVDdyTGJCZjFGU25ROGd1eEdXM1crMzZCVzBnQmplNERPejZCYTZTVmsweGlLZ3QrcTJKT0Z5cjRTWWZudStJYzFRWllJdXdIQnJnenI2VXZPY1NDelBUT283RDZJQzRJU2VTN3prbDRoKzJWb2VIcG5HL3VXUjMreXNOZ1BjT0lYUWJ2MG40bXIzQndRY2RLSnhnUFNleXVQL3oxSmpnNGU5blV2b1hlZ3FRVklFMzBFSHg1R0h2K0ZBVlVOVG93WURKZ3lGaGY1SXZsWW1FcVJpZjYrV04xTWtFSm1EY1FJVHg5RlgyM2E0bXh5MUFRUnNPSE8vK2VJbVg5bDhFTUpJM29QV3pWWHhTT2VIVTFkVVdZcjJ1QUE3QU1iK3ZBRVpTYlUzcW9iOWliQ3lYZXlwRU1wWjY4NjNvNlFQcWxxR0haa3VXQUJTVFZOZDRjT2g5aHYzcUVwU3gyWnkvREpNUDZjSXRFbWlCSjVQRnFRbkRFSXQzTnJBM0NPbE9TZ3o0M0Q3Z3BORk5KNU1CaDRvRnpoRFBpZ2xDMnlwc05VNElTeXdZMmVya3liMU5DM1FoL0lmV2owZURnWkk0L2xuOFdQZkJzVDNtZVRqcTFVcXQxRTdabC9xZnRxa3g2YU05S3VlTUNla1NuTXJjSGoxQ3FUV1d6RXpQc1pHY0RlM1VlNFdzK1hGWVZ4TmJPRkY4ZXprdlFHUjZaT3RPTFUybFFFbk1CU3R4NDd2RTZQYjdBWU1CUmoyT09mWlhmaXNqSm5wVGZTTmpvNnNaNnFTdk54Wk5tRGVTN0drM3lZeUNrMUh0S04yVW5oTUlqT1hVekFxRHY5MGx4OU8vcS9BVDFaTW5pdDVYUWU5d21ReG5FL1dTSDBDcVo5LzJIeStTZm1wZWc4UndzSEk1WjhrQzhIMjkzbS9MSFZWTS9CQTdIYVRKWWc1RW5rN00veFdwcTAxOTJBQ2ZCYWkyTEEvcXJDakNyNkRoMUJJTXpNWElOQm1YOTZNSjVIbjJueGxuL1JYUEZod0h4VW1TVjBFVjJWMGptODYvZHh4dVlTVTFXN3NWa0ViTjlFemtHMFFGd1BoeUhLeWIzdCtGajVXb1VVVEVyY2F6RS9ONkVXNkx2cDBkLy9TRFBqN0VWOVVkSk4rQW1uZjNXd2szQTBTbEo5WjAweXZYWjduM3o3MEc0N0hmc293OFdxMUpYY2Z3bkErWXhhNW1Gc2dWNDY0S0tQNFQzMXdxSWd6RlBkM2VDZTNqNW9yeTVmQkYyaGdDRnlWRnJMekk5ZWV0Tlh2TTdvUXF5RmdEbzRDVHAvaERWOU5NWDlKREhRL255SFRMdlpMTkxGNmZ0bjJPeGpHbTgrUHFPd2h4blBIV2lwa0UvOHdidHlyaTgwU3I3cE1Oa1FHTWZvNFpZSzlPY0NDNEVTVkZGYkxNSXZseFNvUnFXaWUwd3hxbkxmY0xTWE1TcE1NUUVKWURWT2JZc1hJUU52NFRHTndqcTFrdlQxVU9raWNUckczSWFCWjNYZFNjUzN1OHNnZVpQVnBPTGtiaUY5NDBGamJDZU5SSU5OdkRiZDAxRVBCclRDUHBtMTJtNDN6ZTFiQkI1OUlhNk92aG51ci9OdngzSXh3U1dvbCszSDJxZkNKUjhkZjZhUWY0djZXaU9OeGtLK0lxVDRwS1FyWksvTHBsZ0RJL1BKWmJPZXA4ZHRiVjdvQ3I2Q2dmcFdhOE5jek9rUHg4MWlTSGJzTmhWU0pCT3RyTElNckwzMUxLOVRxSHFBYkFIZTBSTG1tVjgwNmtSTERMTkVoVUVKZm05dTBzeHBrTDkzWmdkNnJ3K3RxQmZUTWk1OXhxWEhMWFNId1NiU0JsMEVLMCtsb0VDT1B0cmwrL25zYUZlMTk3ZGk0eVVnb2U0aktvQUpEWGM2REdEanJRT29GRFdaSjlIWHd0OHhEclFQKzdhUndXS1dJMUdGOHM4TzRLenhXQkJjd25sM3ZubDFPZXozb2g2RWExdmpSNy96N0REVHJGdHFVMlcvS0FFekF1WEROWjdNWTczTUYyMTZkemRTYldtVXA0bGNtN2tlSmZXYU1IZ3V0OXg1QzltajY2WjBsSit5aHNqVnZ5aVdyZmsxbHpQT1RkaEcxNVk3Z1FsWHRhY3ZJN3F2L1hOU3NjRHdxa2d3SFQvZ1VzRDV5QjdMZFJSdkp4UUdZSU5uOWhUcG9kS0ZWU1RQcnRHdnlRdytIbFJGWElrb2RFckFHdTlJeTFZcGZTUGMzamtGaDVDWDNsUHh2N2FxakUvSkFmVElwRWpHYi9IN01PMGUydnNWaVNXMXFhL0xtaTQvbjRERUkzZzdsWXJjYW5zcERmRXBLa2RWMU9qU0xPeTBCQ1VxVm9FQ2FCNTV2czA2clhsNGpxbUxzUHNGTS83dllKMHZyQmhEQ20vMDBBL0g4MWwxdWVrSi82TG1sM0hiOStOS2lMcUFUSm1EcHl6ZllaRkh1bUVqQzY2MkwwQndreGk3RTlVNGNRQTBYTVZEdU1ZQUllTE1QZ1FhTVZPZDhmbXQ1U2ZsRklmdUJvc3plQXc3b3c1Z1hQRTJZL3lCYy83akV4QVJVZi9CeElIUUJGNVNuM2k2MXc0ejV4SmRDeU8xRjFYMyszYXgrSlN2TWVaN1M2UVNLcDFGcC9zall6NlorVmdDWnppYkdlRW91anJ5Zk11bEg3UmFpNWtBZnQ5ZWJjVzUwRHlKcjJ1bzJ6OTdtVFdJdTQ1WXNTbk5TTXJyTlV1RzFYc1lCdEQ5VERZelFmZktCODd2V2JrTTRFYlBBRmdvQlY0R1FTK3Z0RkRVcU9GQW9pMW5UdG1JT3ZnMzhONGhUMlNuOHI4Y2xtQkNYc3BCbE1CWVRucnFGSkdCVDN3Wk96QXlKRHJlOWRISDcreDdxYWFLRE9CNFVRQUxENWVjUzBERTRvYnViUUVpdUpaMEVwQlZwTHVZY2NlOEFhNFBZZC9WNERMREFKQllLUVBDV1RjckVhWjVIWWJKaTExR2Q2aGpHb20xaWkxOFZIWW5HMjhOS3BrejJVS1ZQeGxoWVNwOHVacjM2N2lPbW95N3pzeGVoVzl3emN5MnpHMGE4MFBCTUNSUU1iMzJobmFIZU9SOGZuTkR6WmhhTlloa09kRHNCVVozbG9ETWExWVAwdVMwY2pVUDNiLzZEQmxxbVpPZU5BQkRzTGw1Qkk1UUp1cHM4dXhBdVdKZGtVQi9wTzZaYXg2dHNnN2ZONW1qakRnTUduZ08rRFBjS3FpSElEYkZJR3VkeHRQVEl5RGk5U0ZNS0JEY2ZkR1FSdjQxcTFBcW14Z2tWZkpNblA4dy9CYzdOOS9UUjZDN21HT2JGcUZrSUVvbThzS2kyeFlxSkxUQ0hLN2N4emFadnFPRG8yMmMzd2lzQkNQNEhlQWdjUmJOUEFzQmtOUmhTbUQ0OGRIdXBkQlJ3NG1JdnRTNW9lRjZ6ZVQxS01DeWhNbm1ocGtGQUdXbkdzY29Oa3d2UThaTTVsRS92Z1RIRllMOTlPdU54ZEZCeFRFRGQ1djJxTFI4eTlXa1hzV2dHNmtaTm5kRkcrcE8vVUFrT0NpcHFJaEwzaHE3Y1JTZHJDcTdZaFVzVG9jRWNuYUZhNm5Wa2huU2VSWVVBMVlPMHo1aXRGOVNseTNWbHhZRHcyMzlUSkpINmYzRVVmWU81bGI3YmNGY3o4QnA3T284UW1uc1VIT3ovZmFnVlVCdEtFdzFpVDg4aithS2t2OGNzY0tOa014allyODM0NEQxa0ZvWjcvdGQxVzZMQ05ZTjU5NDMwMXRVR1JtRmpBemVSZzV2eW9NMUY2K2JKWi9RNTRqTi9rOFNGZDNEeFBUWWFBVXNpdnNCZmdUbjdNeDhIMlNwUHQ0R09kWVJuRUpPSDZqSE0ycDZTZ0IwZ3pJUnE2Zkh4R01tU21xYVBDbWxmd3hpdWxvYVZJaXRMR044d2llMkNEV2hrekxvQ0pjT0RoN0tJT0FxYkhFdlhkVXhhUzRUVFRzMDdDbHpqLzZHbVZzOWtpWkRlck14RW5oVUI2UVFQbGNmcWtHOTg4MlJxSG9MaUhHQm9IZlF1WElzQUc4R1RBdGFvMktWd1JudnZhbThqbzFlMzEyR1FBS1dFYTRzVVZFQU1HNEc2Y2tjT05Ed1JjZzFlMkQzK29oWGdZNFVBV0Y4d0hLUU1yU256Q2dmRnBzeGgrYUhYTUd0UFFyb1Fhc1JZNFU2VWRHMHJ6MVZqYmthME1la09HUlpRRXZxUUZseHNlRm9yOHpXRmdIZWszdjI5K1dxTjZnYUs1Z1pPVE9NWnpwUUlDMTIwMUxrTUNYaWxkM3ZXWFNjNVVYOXhjRllmYlJQekdGYTFGRGNQZlBCL2pVRXEvRmVHdDQxOUNJM1ltQmxWb0hzYTRLZGN3UVA1WlN3SEhoRko3L1BoL1JhcC80dm1HOTFlRHdQUDBsRGZDRFJDTHN6VHFmek03MXhwbWlLaTJId1M0V2xxdkdOd3R2d0Y1RHFwbjZLVHE4YXgwMFVNUGt4RGNackVFRXNJdkhpVVhYRXBoZGI0R0I0RnltbFB3Qno0R3BlcnFxNXBXN1RRNi95TlJoVzhWVDVOaHVQMHVkbHhvNGdJTHE1WnhBWms4WkdoM2c0Q3F4SmxQS1k3QVF4dXBmVWNWcFdUNVZJdHAxKzMwVXFveVA0d1dzUm8zb2xSUmdrV1paMlpONlZDM09aRmVYQjhOYm5VclNkaWtOcHREMVFpR3VLa3I4RW1TUi9BSzlSdytGRjNzNXV3dVBidkhHaVBlRk9WaWx0TUs3QVVhT3NxOSt4OWNuZGszaUpFRTVMS1pSbFdKYktPWndlUk96bVBOVlBrakUzSy9UeUE1N1JzNjhUa1ozTVI4YWtLcG03Y0ZqbmpQZC9EZGtXamdZb0tIU3I1V3U1c3NvQllVNGFjUnM1ZzJESHhVbWRxOFZYT1hSYnVuRDhRTjBMaGdrc3NnYWhjZG9Zc052dVhHVUsvS1hELzdvRmIrVkdkaHFJbjAydmV1TTViTHVkSk9jMkt5MEdNYUc0Vy94V0J4SUpjTDd5bGlKT1hPcHgwQWtCcVVnemxEY3ptTFQ0aUlMWER4eHRSUjFvWmEySldGZ2lBYjQzb2JySm5HL1RaQzJLU0syd3FPelJaVFhhdlpaRk1iMWYzYlh2VmFOYUs4Mjh3OVRPNjEwZ2s4Sk5mM2dNZkVUelhYc2JjdlJHQ0c5SldRWjYrY0RQcWM0NDY2WW8yUmNLSCtQSUxlS09xdG5sYkluUjNNbUJlR0czRkgxMHl6a3lidXFFQzJIU1F3cEEwQW43ZDkrNzNCa0RVVG0zMGJabW9QL1JHYmdGTitHckNPZkFEZ3FyMFdiSTFhMW9rcEZtczhpSFl3OWhtMHpVdmxFTWl2QlJ4TW9kcmJKSis5L3AzalVkUVE5QkN0UWR4bk9HclQ1ZHpSVW13MDU5My9tYlJTZEJnMG5SdlJaTTUvRTE2bTdaSG1ERXRXaHd2ZmRaQ1o4SjhNMTJXMHlSTXN6WGFtV2ZRVHdJWjRheVlrdHJuc2NRdVdyOGlkcDNQalQyZUYvam10ZGhJZmNwTW5iK0lmWlkyRmViVzZVWS9BSzNqUDR1M1R1NHpFNHFsblFnTEZiTTE5RUJJc05mN0toamRicVEvRDZ5aURiK05sRWkyU0tEK2l2WFZVSzhpYjBvQm8zNjZnWGtSOFp4R2pwSklEY0VnWlBhOVRjWWUwVEliaVBsL3JQVVFEdTNYQko5WC9HTnEzRkFVc0tzbGw1N0R6YUdNcmpjVCtnY3RwKzlNTFlYQ3Erc3FQODFlVlEwcjlsdCtnY1FmWmJBQ1JiRWp2bE1za3p0Wkc4Z2JDOFFuOXR0MjZRN3k3bkRyYlpxL0xFejdrUjZKYzZwZzNOOXJWWDhZNU1KckdsTUw5cDlsVTRqYlRrS3FDdmVlWlVKakhCMDNtMktSS1IyVHl0b0ZrVFhPTGc3a2VVMXMxbHJQTVFKcG9PS0x1QUFDK3kxSGxKdWNVNnlzQjVoc1hodlNQUExxNUo3SnRucUhLWjR2WWpDNFZ5ODE1M1FZKzY3ODB4RHVHQVJzR2JPczFXcXpIMFFTNzY1cm5TS0ViYktsa084b0kvVkR3VWQwaXMxM3RLcHFJTHUxbURKRk55L2lKQVdjdkRnanh2dXNJVCtQR3ozU1QvSjlyOU10ZmQwanBhR2VpTFlJcVhjN0RpSFNTOFRjakZWa3NpNjZQRWt4VzF6NnVqYkxMVUdOTlluek9XcEg4QlpHSzRiQ0s3aVIrTWJJdjhuY0RBejF1NFN0TjN2VFR6ZXdyOUlRams5d3hGeG4rNk4xZGRLczB2ZmZKaVMwOE4zYTRHMVNWcmxaOTdRL00rOEc5ZmU1QVA2ZDkvUXE0V1JuT1JWaG9mUElLRWRDcjNsbHNwVWZFMG9LSUlZb0J5QlJQaCtiWDFITFMzSldHSlJoSXZFMWFXNE5UZDhlUGk0WitrWGIrWjhzbllmU05jcWlqaEFnVnN4NFJDTTU0Y1hVaVlramVCbW1DNGFqT0hyQ2hvRUxzY0pKQzcrOWpqTWp3NUJhZ1pLbGdSTWlTTll6N2g3dnZaSW9RcWJ0UW1zcGMwY1VrMUcvNzNpWHRTcFJPbDV3dExnUWkwbVcyRXg4aTNXVUxoY2dneDZFMUxNVkhVc2RjOUdISTFQSDNVMktvMFB5R2RuOUtkVk9MbTdGUEJ1aTBpOWEwSHBBNjBNc2V3VkU0ejhDQXQ1ZDQwMUd2NnpYbElUNVliaXQxVklBMEZDczd3dHZZcmVydTFmVXlXM29MQVovK2FUblpyT2NZUk5WQThzcG9SdGxSb1dmbHNSQ2xGY2d6a3FpSE9yZjAvU1Z3K0VwVmFGbEowZzRLeHExTU1PbWlRZHBNTnB0ZThsTU1RcW02Y0lGWGxuR2JmSmxseXNLRGkrMEpKTW90a3FnSXhPU1FnVTlkbi9sV2tlVmY4blVtM2l3WDJObDNXRHc5aTZBVUszdkJBYlpacmNKcERRL042NEFWd2pUMDdKZWYzMEdTU210TnUyV2xXN1lveVcyRmxXZlpGUVV3azg2N0VkTFlLazlWRzZKZ0VuQmlCeGtZN0xNbzRZTFFKSmxBbzlsL29UdkprU0FSREYvWHR5QXpNOE8ydDNlVC9pWGE2d0ROM1dld05tUUhkUGZzeENoVS9LdExHMk1uOGk0WnFLZFNsSWFCWmFkeEptUnpWUy9vNHlBNjVSVFNWaXE2MG9hMzk1THF3MHB6WTRTaXB3RTBTWFhzS1YrR1pyYUdTa3IvUlcwOHdQUnZxdlNVa1lCTUE5bFB4NG0yNGF6K0lIbUNiWEErMGZheFRSRTl3dUdlTzA2RElYYTZRbEtKM3B1SXlpdUFWZlByNzM2dnpvMnBCaXJTK1Z4ZWwzVE1tM0pLaHo5bzJab1J2YUZWcElreWtiMEhjbTRvSEZCTWNOU05qNy80R0p0NDNvZ29uWTJWZzRuc0RRSVd4QWNvcnBYQUN6Z0JxUVBqWXNFL1ZVcFhwd05NYW5FcnU0TndNQ0ZQa1h2TW9xdm9lTE4zcXl1L04xZVdFSHR0TUQ2NXYxOWwvMGtIMm1SMzVpdi9GSSt5am9ISjlnUE16NjdhZjNNcS9Cb1dYcXUzcnBoaVdNWFZrbW5QU0VrcEdwVUkyaDFNVGhpZGVHRkVPSzZZWkhQd1l6TUJ2cE5DNytaSHhQYjdlcGZlZkd5SUI0SnpPOURUTkVZbkRMVlZIZFF5dk9FVmVmcms2VXY1a1RRWVZZV1dkcXJkY0lsN3lsand3SVdkZlEveSsyUUIzZVIvcXhZT2J1WXlCNGdUYm8yaW40UHphclUxc085bkVUa21qOS9Bb3hEQStKTTNHTXFRdEpSNGp0ZHVIdG5vQ0x4ZDFnUVVzY0hSQi9Nb1JZSUVzUDJwRFo5S3ZIZ3RsazFpVGJXV2JIaG9od0ZFWVg3eTUxZlVWMm51VW1ub1VjcW5XSVFBQWdsOUxUVlgrQmMwUUdORWhDaHhIUjRZamZFNTFQVWRHZnNTRkU2Y2s3QkwzL2hUZjlqTHE0RzFJYWZJTnhPTEtlQXRPN3F1dWxZdkg1WU9CYyt6WDdDck1nV25XNDcvamZSc1duSmpZWW9FN3hNZldWMkhOMml5SXFMSSc7XG5jb25zdCBGRU5DRUQgPSBuZXcgTWFwKFtbODIxNyxcImFwb3N0cm9waGVcIl0sWzgyNjAsXCJmcmFjdGlvbiBzbGFzaFwiXSxbMTI1MzksXCJtaWRkbGUgZG90XCJdXSk7XG5jb25zdCBOU01fTUFYID0gNDtcblxuZnVuY3Rpb24gZGVjb2RlX2FyaXRobWV0aWMoYnl0ZXMpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRmdW5jdGlvbiB1MTYoKSB7IHJldHVybiAoYnl0ZXNbcG9zKytdIDw8IDgpIHwgYnl0ZXNbcG9zKytdOyB9XHJcblx0XHJcblx0Ly8gZGVjb2RlIHRoZSBmcmVxdWVuY3kgdGFibGVcclxuXHRsZXQgc3ltYm9sX2NvdW50ID0gdTE2KCk7XHJcblx0bGV0IHRvdGFsID0gMTtcclxuXHRsZXQgYWNjID0gWzAsIDFdOyAvLyBmaXJzdCBzeW1ib2wgaGFzIGZyZXF1ZW5jeSAxXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBzeW1ib2xfY291bnQ7IGkrKykge1xyXG5cdFx0YWNjLnB1c2godG90YWwgKz0gdTE2KCkpO1xyXG5cdH1cclxuXHJcblx0Ly8gc2tpcCB0aGUgc2l6ZWQtcGF5bG9hZCB0aGF0IHRoZSBsYXN0IDMgc3ltYm9scyBpbmRleCBpbnRvXHJcblx0bGV0IHNraXAgPSB1MTYoKTtcclxuXHRsZXQgcG9zX3BheWxvYWQgPSBwb3M7XHJcblx0cG9zICs9IHNraXA7XHJcblxyXG5cdGxldCByZWFkX3dpZHRoID0gMDtcclxuXHRsZXQgcmVhZF9idWZmZXIgPSAwOyBcclxuXHRmdW5jdGlvbiByZWFkX2JpdCgpIHtcclxuXHRcdGlmIChyZWFkX3dpZHRoID09IDApIHtcclxuXHRcdFx0Ly8gdGhpcyB3aWxsIHJlYWQgYmV5b25kIGVuZCBvZiBidWZmZXJcclxuXHRcdFx0Ly8gYnV0ICh1bmRlZmluZWR8MCkgPT4gemVybyBwYWRcclxuXHRcdFx0cmVhZF9idWZmZXIgPSAocmVhZF9idWZmZXIgPDwgOCkgfCBieXRlc1twb3MrK107XHJcblx0XHRcdHJlYWRfd2lkdGggPSA4O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChyZWFkX2J1ZmZlciA+PiAtLXJlYWRfd2lkdGgpICYgMTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IE4gPSAzMTtcclxuXHRjb25zdCBGVUxMID0gMioqTjtcclxuXHRjb25zdCBIQUxGID0gRlVMTCA+Pj4gMTtcclxuXHRjb25zdCBRUlRSID0gSEFMRiA+PiAxO1xyXG5cdGNvbnN0IE1BU0sgPSBGVUxMIC0gMTtcclxuXHJcblx0Ly8gZmlsbCByZWdpc3RlclxyXG5cdGxldCByZWdpc3RlciA9IDA7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpIHwgcmVhZF9iaXQoKTtcclxuXHJcblx0bGV0IHN5bWJvbHMgPSBbXTtcclxuXHRsZXQgbG93ID0gMDtcclxuXHRsZXQgcmFuZ2UgPSBGVUxMOyAvLyB0cmVhdCBsaWtlIGEgZmxvYXRcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHZhbHVlID0gTWF0aC5mbG9vcigoKChyZWdpc3RlciAtIGxvdyArIDEpICogdG90YWwpIC0gMSkgLyByYW5nZSk7XHJcblx0XHRsZXQgc3RhcnQgPSAwO1xyXG5cdFx0bGV0IGVuZCA9IHN5bWJvbF9jb3VudDtcclxuXHRcdHdoaWxlIChlbmQgLSBzdGFydCA+IDEpIHsgLy8gYmluYXJ5IHNlYXJjaFxyXG5cdFx0XHRsZXQgbWlkID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcclxuXHRcdFx0aWYgKHZhbHVlIDwgYWNjW21pZF0pIHtcclxuXHRcdFx0XHRlbmQgPSBtaWQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhcnQgPSBtaWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChzdGFydCA9PSAwKSBicmVhazsgLy8gZmlyc3Qgc3ltYm9sIGlzIGVuZCBtYXJrXHJcblx0XHRzeW1ib2xzLnB1c2goc3RhcnQpO1xyXG5cdFx0bGV0IGEgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0XSAgIC8gdG90YWwpO1xyXG5cdFx0bGV0IGIgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0KzFdIC8gdG90YWwpIC0gMTtcclxuXHRcdHdoaWxlICgoKGEgXiBiKSAmIEhBTEYpID09IDApIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgJiBNQVNLIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpICYgTUFTSztcclxuXHRcdFx0YiA9IChiIDw8IDEpICYgTUFTSyB8IDE7XHJcblx0XHR9XHJcblx0XHR3aGlsZSAoYSAmIH5iICYgUVJUUikge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciAmIEhBTEYpIHwgKChyZWdpc3RlciA8PCAxKSAmIChNQVNLID4+PiAxKSkgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgXiBIQUxGO1xyXG5cdFx0XHRiID0gKChiIF4gSEFMRikgPDwgMSkgfCBIQUxGIHwgMTtcclxuXHRcdH1cclxuXHRcdGxvdyA9IGE7XHJcblx0XHRyYW5nZSA9IDEgKyBiIC0gYTtcclxuXHR9XHJcblx0bGV0IG9mZnNldCA9IHN5bWJvbF9jb3VudCAtIDQ7XHJcblx0cmV0dXJuIHN5bWJvbHMubWFwKHggPT4geyAvLyBpbmRleCBpbnRvIHBheWxvYWRcclxuXHRcdHN3aXRjaCAoeCAtIG9mZnNldCkge1xyXG5cdFx0XHRjYXNlIDM6IHJldHVybiBvZmZzZXQgKyAweDEwMTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCAxNikgfCAoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIG9mZnNldCArIDB4MTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gb2Zmc2V0ICsgYnl0ZXNbcG9zX3BheWxvYWQrK107XHJcblx0XHRcdGRlZmF1bHQ6IHJldHVybiB4IC0gMTtcclxuXHRcdH1cclxuXHR9KTtcclxufVx0XHJcblxyXG4vLyByZXR1cm5zIGFuIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgdGhlIG5leHQgc3ltYm9sXHJcbmZ1bmN0aW9uIHJlYWRfcGF5bG9hZCh2KSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0cmV0dXJuICgpID0+IHZbcG9zKytdO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKHMpIHtcclxuXHRyZXR1cm4gcmVhZF9wYXlsb2FkKGRlY29kZV9hcml0aG1ldGljKHVuc2FmZV9hdG9iKHMpKSk7XHJcbn1cclxuXHJcbi8vIHVuc2FmZSBpbiB0aGUgc2Vuc2U6XHJcbi8vIGV4cGVjdGVkIHdlbGwtZm9ybWVkIEJhc2U2NCB3L28gcGFkZGluZyBcclxuLy8gMjAyMjA5MjI6IGFkZGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2lzc3Vlcy80XHJcbmZ1bmN0aW9uIHVuc2FmZV9hdG9iKHMpIHtcclxuXHRsZXQgbG9va3VwID0gW107XHJcblx0Wy4uLidBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ10uZm9yRWFjaCgoYywgaSkgPT4gbG9va3VwW2MuY2hhckNvZGVBdCgwKV0gPSBpKTtcclxuXHRsZXQgbiA9IHMubGVuZ3RoO1xyXG5cdGxldCByZXQgPSBuZXcgVWludDhBcnJheSgoNiAqIG4pID4+IDMpO1xyXG5cdGZvciAobGV0IGkgPSAwLCBwb3MgPSAwLCB3aWR0aCA9IDAsIGNhcnJ5ID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0Y2FycnkgPSAoY2FycnkgPDwgNikgfCBsb29rdXBbcy5jaGFyQ29kZUF0KGkpXTtcclxuXHRcdHdpZHRoICs9IDY7XHJcblx0XHRpZiAod2lkdGggPj0gOCkge1xyXG5cdFx0XHRyZXRbcG9zKytdID0gKGNhcnJ5ID4+ICh3aWR0aCAtPSA4KSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vIGVnLiBbMCwxLDIsMy4uLl0gPT4gWzAsLTEsMSwtMiwuLi5dXHJcbmZ1bmN0aW9uIHNpZ25lZChpKSB7IFxyXG5cdHJldHVybiAoaSAmIDEpID8gKH5pID4+IDEpIDogKGkgPj4gMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRfZGVsdGFzKG4sIG5leHQpIHtcclxuXHRsZXQgdiA9IEFycmF5KG4pO1xyXG5cdGZvciAobGV0IGkgPSAwLCB4ID0gMDsgaSA8IG47IGkrKykgdltpXSA9IHggKz0gc2lnbmVkKG5leHQoKSk7XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIFsxMjNdWzVdID0+IFswIDNdIFsxIDFdIFswIDBdXHJcbmZ1bmN0aW9uIHJlYWRfc29ydGVkKG5leHQsIHByZXYgPSAwKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQoKTtcclxuXHRcdGxldCBuID0gbmV4dCgpO1xyXG5cdFx0aWYgKCFuKSBicmVhaztcclxuXHRcdHByZXYgKz0geDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdHJldC5wdXNoKHByZXYgKyBpKTtcclxuXHRcdH1cclxuXHRcdHByZXYgKz0gbiArIDE7XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRfc29ydGVkX2FycmF5cyhuZXh0KSB7XHJcblx0cmV0dXJuIHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4geyBcclxuXHRcdGxldCB2ID0gcmVhZF9zb3J0ZWQobmV4dCk7XHJcblx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2O1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm5zIG1hcCBvZiB4ID0+IHlzXHJcbmZ1bmN0aW9uIHJlYWRfbWFwcGVkKG5leHQpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB3ID0gbmV4dCgpO1xyXG5cdFx0aWYgKHcgPT0gMCkgYnJlYWs7XHJcblx0XHRyZXQucHVzaChyZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSk7XHJcblx0fVxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKSAtIDE7XHJcblx0XHRpZiAodyA8IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9yZXBsYWNlbWVudF90YWJsZSh3LCBuZXh0KSk7XHJcblx0fVxyXG5cdHJldHVybiByZXQuZmxhdCgpO1xyXG59XHJcblxyXG4vLyByZWFkIHVudGlsIG5leHQgaXMgZmFsc3lcclxuLy8gcmV0dXJuIGFycmF5IG9mIHJlYWQgdmFsdWVzXHJcbmZ1bmN0aW9uIHJlYWRfYXJyYXlfd2hpbGUobmV4dCkge1xyXG5cdGxldCB2ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB4ID0gbmV4dCh2Lmxlbmd0aCk7XHJcblx0XHRpZiAoIXgpIGJyZWFrO1xyXG5cdFx0di5wdXNoKHgpO1xyXG5cdH1cclxuXHRyZXR1cm4gdjtcclxufVxyXG5cclxuLy8gcmVhZCB3IGNvbHVtbnMgb2YgbGVuZ3RoIG5cclxuLy8gcmV0dXJuIGFzIG4gcm93cyBvZiBsZW5ndGggd1xyXG5mdW5jdGlvbiByZWFkX3RyYW5zcG9zZWQobiwgdywgbmV4dCkge1xyXG5cdGxldCBtID0gQXJyYXkobikuZmlsbCgpLm1hcCgoKSA9PiBbXSk7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB3OyBpKyspIHtcclxuXHRcdHJlYWRfZGVsdGFzKG4sIG5leHQpLmZvckVhY2goKHgsIGopID0+IG1bal0ucHVzaCh4KSk7XHJcblx0fVxyXG5cdHJldHVybiBtO1xyXG59XHJcbiBcclxuLy8gcmV0dXJucyBbW3gsIHlzXSwgW3grZHgsIHlzK2R5XSwgW3grMipkeCwgeXMrMipkeV0sIC4uLl1cclxuLy8gd2hlcmUgZHgvZHkgPSBzdGVwcywgbiA9IHJ1biBzaXplLCB3ID0gbGVuZ3RoIG9mIHlcclxuZnVuY3Rpb24gcmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkge1xyXG5cdGxldCBkeCA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IGR5ID0gbmV4dCgpO1xyXG5cdGxldCB2TiA9IHJlYWRfYXJyYXlfd2hpbGUobmV4dCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQodk4ubGVuZ3RoLCAxK3csIG5leHQpO1xyXG5cdHJldHVybiBtLmZsYXRNYXAoKHYsIGkpID0+IHtcclxuXHRcdGxldCBbeCwgLi4ueXNdID0gdjtcclxuXHRcdHJldHVybiBBcnJheSh2TltpXSkuZmlsbCgpLm1hcCgoXywgaikgPT4ge1xyXG5cdFx0XHRsZXQgal9keSA9IGogKiBkeTtcclxuXHRcdFx0cmV0dXJuIFt4ICsgaiAqIGR4LCB5cy5tYXAoeSA9PiB5ICsgal9keSldO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBbW3gsIHlzLi4uXSwgLi4uXVxyXG4vLyB3aGVyZSB3ID0gbGVuZ3RoIG9mIHlcclxuZnVuY3Rpb24gcmVhZF9yZXBsYWNlbWVudF90YWJsZSh3LCBuZXh0KSB7IFxyXG5cdGxldCBuID0gMSArIG5leHQoKTtcclxuXHRsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZChuLCAxK3csIG5leHQpO1xyXG5cdHJldHVybiBtLm1hcCh2ID0+IFt2WzBdLCB2LnNsaWNlKDEpXSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZWFkX3RyaWUobmV4dCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc29ydGVkID0gcmVhZF9zb3J0ZWQobmV4dCk7IFxyXG5cdGV4cGFuZChkZWNvZGUoW10pLCBbXSk7XHJcblx0cmV0dXJuIHJldDsgLy8gbm90IHNvcnRlZFxyXG5cdGZ1bmN0aW9uIGRlY29kZShRKSB7IC8vIGNoYXJhY3RlcnMgdGhhdCBsZWFkIGludG8gdGhpcyBub2RlXHJcblx0XHRsZXQgUyA9IG5leHQoKTsgLy8gc3RhdGU6IHZhbGlkLCBzYXZlLCBjaGVja1xyXG5cdFx0bGV0IEIgPSByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgLy8gYnVja2V0cyBsZWFkaW5nIHRvIG5ldyBub2Rlc1xyXG5cdFx0XHRsZXQgY3BzID0gcmVhZF9zb3J0ZWQobmV4dCkubWFwKGkgPT4gc29ydGVkW2ldKTtcclxuXHRcdFx0aWYgKGNwcy5sZW5ndGgpIHJldHVybiBkZWNvZGUoY3BzKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHtTLCBCLCBRfTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gZXhwYW5kKHtTLCBCfSwgY3BzLCBzYXZlZCkge1xyXG5cdFx0aWYgKFMgJiA0ICYmIHNhdmVkID09PSBjcHNbY3BzLmxlbmd0aC0xXSkgcmV0dXJuO1xyXG5cdFx0aWYgKFMgJiAyKSBzYXZlZCA9IGNwc1tjcHMubGVuZ3RoLTFdO1xyXG5cdFx0aWYgKFMgJiAxKSByZXQucHVzaChjcHMpOyBcclxuXHRcdGZvciAobGV0IGJyIG9mIEIpIHtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgYnIuUSkge1xyXG5cdFx0XHRcdGV4cGFuZChiciwgWy4uLmNwcywgY3BdLCBzYXZlZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cblxuZnVuY3Rpb24gaGV4X2NwKGNwKSB7XHJcblx0cmV0dXJuIGNwLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1b3RlX2NwKGNwKSB7XHJcblx0cmV0dXJuIGB7JHtoZXhfY3AoY3ApfX1gOyAvLyByYWZmeSBjb252ZW50aW9uOiBsaWtlIFwiXFx1e1h9XCIgdy9vIHRoZSBcIlxcdVwiXHJcbn1cclxuXHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiBleHBsb2RlX2NwKHMpIHtcclxuXHRyZXR1cm4gWy4uLnNdLm1hcChjID0+IGMuY29kZVBvaW50QXQoMCkpO1xyXG59XHJcbiovXHJcbmZ1bmN0aW9uIGV4cGxvZGVfY3AocykgeyAvLyB0aGlzIGlzIGFib3V0IDJ4IGZhc3RlclxyXG5cdGxldCBjcHMgPSBbXTtcclxuXHRmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyApIHtcclxuXHRcdGxldCBjcCA9IHMuY29kZVBvaW50QXQocG9zKTtcclxuXHRcdHBvcyArPSBjcCA8IDB4MTAwMDAgPyAxIDogMjtcclxuXHRcdGNwcy5wdXNoKGNwKTtcclxuXHR9XHJcblx0cmV0dXJuIGNwcztcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyX2Zyb21fY3BzKGNwcykge1xyXG5cdGNvbnN0IGNodW5rID0gNDA5NjtcclxuXHRsZXQgbGVuID0gY3BzLmxlbmd0aDtcclxuXHRpZiAobGVuIDwgY2h1bmspIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jcHMpO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKSB7XHJcblx0XHRidWYucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jcHMuc2xpY2UoaSwgaSArPSBjaHVuaykpKTtcclxuXHR9XHJcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGFyZV9hcnJheXMoYSwgYikge1xyXG5cdGxldCBuID0gYS5sZW5ndGg7XHJcblx0bGV0IGMgPSBuIC0gYi5sZW5ndGg7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGMgPT0gMCAmJiBpIDwgbjsgaSsrKSBjID0gYVtpXSAtIGJbaV07XHJcblx0cmV0dXJuIGM7XHJcbn1cblxuLy8gY3JlYXRlZCAyMDIzLTA5LTI1VDAxOjAxOjU1LjE0OFpcbi8vIGNvbXByZXNzZWQgYmFzZTY0LWVuY29kZWQgYmxvYiBmb3IgaW5jbHVkZS1uZiBkYXRhXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvYmxvYi9tYWluL3NyYy9tYWtlLmpzXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMjc2VjdXJpdHlcbi8vIFNIQS0yNTY6IGE5NzRiNmY4NTQxZmMyOWQ5MTliYzg1MTE4YWYwYTQ0MDE1ODUxZmFiNTM0M2Y4Njc5Y2IzMWJlMmJkYjIwOWVcbnZhciBDT01QUkVTU0VEID0gJ0FFVURUQUhCQ0ZRQVRRRFJBREFBY2dBZ0FEUUFGQUFzQUJRQUh3QU9BQ1FBRFFBUkFBb0FGd0FIQUJJQUNBQVBBQVVBQ3dBRkFBd0FCQUFRQUFNQUJ3QUVBQW9BQlFBSUFBSUFDZ0FCQUFRQUZBQUxBQUlBQ3dBQkFBSUFBUUFIQUFNQUF3QUVBQXNBREFBTUFBd0FDZ0FOQUEwQUF3QUtBQWtBQkFBZEFBWUFad0RTQWRzREpnQzBDa01COHhoWkFxZm9DMTkwVUdjVGhnQnVyd2Y3UFQwOVBiMDlBamdKdW04T2pEbGx4SFlVS1hBUHh6cTZ0QUJBeGdLOHlzVXZXQWdNUFQwOVBUMDlQU3M2TFQySGNnV1hXd0ZMb1NNRUVFbDVSRlZNS3ZPMFhROEV4RGRKTW5JZ3NqMjZQVFF5eThGZkVROEFZOElQQUdjRWJ3UndCSEVFY2dSekJIUUVkUVIyQkhjRWVBUjZCSHNFZkFSK0JJQUVnZm5kQlFvQllnVUxBV0lGREFGaUJOY0UyQVRaQlJBRkVRVXZCZEFMRkFzVkRQY05CdzEzRFljT01BNHhEak1CNEJsbEhJMEIyZ3JiQU1EcEhMa1E3UUhWQVBSTlFRRm5HUlVFZzB5RUIydWFKRjhBSnBJQnBvYjVBRVJTTUFLTm9BWHFhUUxVQk1DekVpQUNud1JaRWtrVnNTN3RBTkFzQkcwUnVBUUxFUEFCdjlISUNUVUJYaWdQWndSQkFwTURPd0FhbWh0YUFCcUVBWThLdkt4M0xRNEFyQUI4VWh3RUJBVlNhZ0Q4QUVGWkFEa0JJYWRWajJVTVVneDVJbDRBTlFDOUF4SUIxQmxiRVBNQXMzMENHeGxYQWh3WktRSUVDQmM2RWJzQ294bmd6djdVelJRQThNMEJhd0w2WndrTjd3QUJBRDMzT1FSY3NnTEpDak1DanFVQ2h0dy9rbStOQXNYUEFvUDJCVDg0UHdVUkFLMFJBdnB0YjZjQXBRUy9PTU1leTVISlM4NFVkeHB4VFBrQ29nVkZJVGFUT3dFUkFLNXBBdmtOQk9WeUE3cTNCS2xPSlNBTEFnVUlCUmNFZEFTcEJYcXpBQlhGU1daT2F3TENPcXcvL0FvbENaZHZ2M2RTQmtFUUd5ZWxFUGNNTXdHMUFUc043VXZZQlBFR093VEpIMzBaR1EvTmxad0lwUzNkRE8wbTR5NmhnRm9qOVNxREJlMUw5RHpkQzAxUmFBOVpDMlVKNHpwamdVNERJUUVOSW9zSzNRMDVDRzBROHdySmF3M2xFVVVIT1FQVlNab0FwUWNCQ3hFZE5SVzFKaEJpckFzSk9YY0creHIyQzQ4bXJ4TXBldndGMHhvaEJrMEJLUnIvQU04dTU0V3dXakZjSEU5ZkJnTUxKU1BIRktoUUlBMGxRTGQ0U0JvYkJ4VWxxUUtSUTNCS2gxRTJIcE1oOWp3OURXWXVFMUY4Qi9VOEJSbFBDNEU4bmthclJRNFIwajZOUFVnaVNVd3NCRFYvTEM4bml3blBENFVNdVh4eUFWa0pJUW14REhFVE1SRVhOOFVJT1FjWkxaY2tKeFVJSVVhVllKb0U5NThEOHhQUkF3c0ZQd2xCQnhNRHRSd3RFeTRWS1FVTmdTVFhBdk0yMVM2ekFvOVdnQUVYQmNzUEpSL2ZFRkJINEE3cENKc0NaUU9ESmVzQUxSVWhBQmNpbXdoRFl3QmZqOWhUQlM3TENNZHFiQ04wQTJjVTUyRVJjd2VSRGxjSHB4d3pGYjhjNFhESVhndUdDQ2lqcndsYkFYVUptUUZmQk9NSUNUVmJqS0FnUVdkVGkxZ1lteUJoUVQ5ZC9BSXhER1VWbjBTOWgzZ0NpdzlyRWhzQk5RRnpCemtOQVFKM0VlMFJheENWQ091R0JEVzFNL2c2SlFSUElZTWdFUW9uQTA5c3pnc25KdmtNK0drQm94SmlBd3cwUFhmdVo2dGd0aVFYL1FjWk1zVkJZQ0h4QzVKUHpReWNHc0VZUWxRdUdlUUh2d1B6R3ZNbjZrRlhCZjhEb3dNVE9rMHo3Z1M5QzJrSWl3ay9BRWtPb3hjSDF4aHFDbkdNMEFFeGl3RzNtUU5Ya1lNQ2I0OEdOd2NMQUdjTGh3VjU1UUFkQXFjSW93QUZBTThEVndBNUFxMEhuUUFaQUlWQkFUMERKeThCSWVVQ2p3T1RDREhMQVpVdkFmTXBCQnZEREJVQTl6ZHVTZ0xEc1FLQWFtYWlCZDFZQW80Q1NUVUJUU1VFQlU1SFVRT3ZjZUVBMndCTEJoUGZSd0VWcTByTEd1TkRBZDl2S3dESEFQc0FCVFVIQlVFQnpRSHpiUUMzQVY4TE1RbWlzN1VCVGVrcEFJTUFGV3NCMXdLSkFOMEFOUUIvOFFGVEFFMEZXZmtGMHdKUFNRRVJNUmdyVjJFQnV3TWZBVE1CRFFCNUJzdU5wY2tISHdSdEI5TUNFQnNWNFFMdkxnZTFBUU1pM3hQTlFzVUN2ZDVWb1dBQ1pJRUNZa0piVGE5Yk55QUNvZmNDYUpnQ1pna0NuNFE0R3dzQ1pqc0NaaVlFYmdSL0EzOFRBMzZTT1FZNWR4YzVnam9qSXdKc0hRSXlOamdLQW0zSEFtMnU3NG96WjBVckFXY0EzZ0RoQUVvRkI1Z01qUUQrQzhJQURiVUNkeThDZHFJL0FubExRd0o0dWgxYzIwV3VSdGNDZkQ4Q2VzZ0NmUWtDZlBBRldRVWdTQUJJZldNa0FvRnRBb0FBQW9BRkFuK3VTVmhLV3hVWFNzd0MwUUVDME14TEp3T0lUd09INWtURmtUSUM4cUZkQXdNRHJrdk9UQzBsQTg5TlRFMnZBb3MvQW9yWXdSc0hIVU5uQmJjQ2pqY0NqbHhBbDRFQ2p0a0NqbHg0VWJSVE5RcFMxRlNGQXBQN0FwTU1BT2tBSEZVZVZhOVYwQVlzR3ltVmhqTGhlR1pGT3prQ2w1OEM3N0pZSWFnQVdTVUNsbzhDbG55Y0FLbFpyRm9KZ1UwQU93S1d0UUtXVGx4RVhORUNtY3NDbVdSY3lsMEhHUUtjbXpuQ09wMENuQllDbjVzQ25yaUtBQjBQTVNvUEFwM3hBcDZTQUxVOVlUUmg3d0tlMHdLZ2JnR3BBcDZmSHdLZVRxVmp5R1FuSlNzQ0o2OENKbjRDb1BzQ29Fd0NvdDBDb2NRQ3BpOENwYzRDcC84QWZRS244bWg4YUxFQUEwbHFIR3JSQXF6akFxeXVBcTFuQXEwQ0FsY2RBbFhjQXJIaDF3TWZUbXlYQXJLOURRS3k2QmRzNEcxamJVaGZBeVhOQXJaY096OXVrQU1wUlFLNFhnSzVSeFVDdVNwM2NEWnc0UUs5R1FLNzJuQ1dBeklSQXI2SWNnSURNM0VDdmhwekluTlBBc1BMQXNNRWM0SjBTelZGZE9BRFBLY0RQSm9EUGI4Q3hYd0N4a2NDeGhDSkFzaHBVUUxJUkFMSlR3TEpMZ0prblFMZDBuaDVZWGl1ZVNWTDBBTVlvMmNDQW1IMEdmT1ZKSHNMWHBKZXV4RUN6MnNDejJ3dlMxUFM4eE9mQU1hdEFzOXpBU25xQTA0U2Zrc0ZBdHduQXR1S0F0SlBBMUpjQTFOZkFRRURWWXlBaVQ4QXl4YnRZRVdDSElMVGdzNkRqUUxheHdMWjNvUVFoRW1uUEFPR3BRQXZBMlFPaG5GWitRQlZBdDlsQXQ2NGMzY0M0aS90RkFIek1DY0I5SnNCOHRLSEF1dnpBdWx3ZVFMcStRTHE1QUQ1UndHNUF1NkpBdXVjbHFxWEF3THVQd09GNEpoNWNPQnhvUUx6QXdCcEE0NFdtWk1DOXhNRGtXNERrb2NDOTVnQytka0MrR2FhSEpxcnV6ZWJIZ09kZ3dMKytnRWJBRG1mSEorekF3V05BNlpxQTZiWkFOSEZBd1pxb1lpaUJRa0RERWtDd0FBL0F3RGhRUmRUQVJIekEyc0hsMmNGQUpNdEs3ZXZ2ZHNCaVprVWZ4RUVPUUg3S1FVaERwMEpud0NTL1NsWHhRTDNBWjBBdHdXNUFHOExiVUV1RkNhTkxnRkRBWUQ4QWJVbUFIVUREZ1J0QUN3Q0ZneWhBQUFLQWowQ2FnUGRBMzRFa1FFZ1JRVWhmQW9BQlFCRUFCTUFOaElDZHdFQUJkVURhKzhLeFFJQTl3cWZKNyt4dCtVQmtTRkJRZ0hwRkg4Uk5NQ0pBQVFBR3dCYUFrVUNoSXNBQmpwVE9wU05iUUM0T284NjBBQ05PTUU2M0FDbEFPZ0F5d0U2Z1RvN09mdzUrVHQyaVRwYk81NkpPbTg1R0FGV0FUTUJiQVV2TlYwMW5qV3ROV1kxZFRXMk5jVTFnaldSTmRJMTRUV2VOYTAxN2pYOU5iSTF3VFlDTmhFMXhqWFZOaFkySnpYZU5lMDJMalk5Tmk0MUxTRTJPalk5Tmp3MnlUY0lCSkE4VnpZNE50MDNJRGNQTnNvZ040azNNQW9Fc0R4bk5pUTNHVGRzT28wM0lVTFVRd2RDNEVNTEhBOFBDWnNvYlNoUlZRWUE2WDhBNmJBQkZDblhBdWtCb3dDOUJiY0Fid056Qkw4TURBTU1BUWdEQUFrS0N3c0xDUW9HQkFWVkJJL0R2d0R6OWIyOWthVUNiMFF0c1JUTkx0NGVHQmNTSEFNWkZoWVpFaFlFQVJBRUJVRWNRUnhCSEVFY1FSeEJIRUVhUVJ4QkhFRkNTVHhCUEVsSVNVaEJOa00yUVRZYk5rbElTVm1CVklnQkZMV1pBdTBCaFFDakJjRUFieWtCdndHSkFhUWNFWjBlUENrbE1BQWhNdkFJTUFMNTRnQzdCbThFZXNjanpRTXBBUlFwS2dEVUFCYXZBajYyNnhRQUpQMEEzZXR6dWY0Tk5SQTdlZnkyWjlOUXJDbkMwT1N5QU56NUJCSWJKNUlGRFI2bWlJYXZZUzZ0cHJqam11S2VieG01Qzc0UTIyNVgxcGthWVlQYjZmMURLNGszeE1FQmI5UzJXTWpFaWJUTldoc1JKSUErdndOVkVpWFRFNWlYcy93ZXpWNjZvRkxmcDlOWkdZVytHazE5SjIrYkNUNlllMnc2TERZZGd6S01VYWJrNTk1ZUxCQ1hBTno5SFVwV2JBVHE5dnFYVng5WERnK1BjOVhwNCtic1MwMDVTVk0vQkpCTTQ2ODdXVXVmK1VqOWRFaThhRE5hUHh0cGJEeGNHMVRIVEltVU1acTRVQ2FhTllwc1ZxcmFOeUtMSlhEWXNGWi81amw3YkxSdE84OHQ3UDN4WmFBeGhiNU9kUE1YcXNTa3AxV0NpZUc4alhtMVU5OStibHZMbFh6UENTK005M1ZuSkNpSyswOUxmYVNhQkFWQm9teURnSnVhOGRmVXpSN2dhMzRJdlIyTnZqK0E5aGVKNmxzbDFLRzROa0kxMDMyQ25mZjFtMXdvZjJCOW9ISks0Ymk2SmtFZFNxZU5laXVvNlFvWlppbmNvYzczL1RIOVNYRjhzQ0U3WHl1WXlXOFdTZ2JHRkNqUFYwaWhMS2hkUHMwOFR4ODJmWUFrTExjNEkyd2RsNGFwWTdHVTVsSFJGelJXSmVwN1d3M3diZUEzcW1kNTkvODZQNHh1TmFxRHB5Z1h0Nk04NWdsU0JIT0NHZ0pEbnQrcE45Yks3SEFwTWd1WDYrMDZSWk5qelZtY1pKK3djVXJKOS8vYnBSTnhOdUtwTmw5dUZkcytTOXRkeDdMYU01WmtJclBqNm5JVTltbmJGdFZiczlzL3VMZ2w4TVZjekF3ZXQraU9FenpCbFlXN1JDTWdFNmd5TkxlcTYrMXRJeDRkcGdabmQwRGtzSlM1ZitKTkRwd3djUE5YYWFWc3BxMWZiUWFqT3JKZ0swb2ZLdEoxTmU5MEw2Vk80TU9sNVM4ODZwN3U2eG83T0xqRzhUR0wrSFUxSlhHSmdwcGc0bk5iTko1bmx6U3B1UFl5MjFKVUVjVUE5NFBvRmlaZmpadWUrUW55UTgwZWtPdVpWa3h4NGcrY3ZoSmZIZ05sNGh5MS9hNitSS2NLbGFyL0oyOXkvL0V6dGxiVlBIVlVlUTF6WDg2ZVFWQWpSL00zZEE5dzRXOExmYVhwNEVnTTg1d09XYXNsaTgzN1B6Vk1PbnNMelIrazNvNzUvbFJQQUpTRTF4QUtRekVpNXYxMGtlK1ZCdlJ0MWN3UVJNZCtVNW1MQ1RHVmQ2WGladGdCRzVjRGkwdzIyR0tjVk52SGl1NUxRYlpFRFZ0ejBvbm43azUraGV1S1hWc1p0U3ppbGtMUkFVbWpNWEVNQjNKOVlDNTBYQnhQaXo1M1NDK0VoblBsOVdzS0N2OTJTTS9PRkZJTUpaWWZsMFdXOHRJTzNVeFljd2RNQWo3RlNtZ3JzWjJhQVpPMDNCT2hQMWJOTlpJdHlYWVFGVHBDM1NHMVZ1UERxSDlHa2lDRG1FK0p3eHlJVlNPNXNpREVyQU9wRVhGZ2p5NlBRdE9WRGorczZlMXI4aGVXVnZtWm5UY2l1ZjRFaU5aekNBZDdTT01oWEVSSU9sc0hJTUczOTlpOWFMVHkzbTJoUkxaakpWRE5MUzUzaUdJSzExZFBxUXQwekJEeWc2cWM3WXFrRG0yTTVWZTZkQ1dDYUNiVFhYMnJUb2FJZ3o2K3poNGxZVWkvKzZucWNGTUFrUUpLSFlMSzB3WWs1TjlzelY2eGloRGJEREZyNDVsTjFLNGFDWEJxL0ZpdFBTdWQ5Z0x0NVpWbitacUdYN2N3bTJ6NUVHTWdmRnBJRnloR0d1RFBtc282VEl0VE13bnkrN3VQbkxDZjRXNmdvRlFGVjBvUVNzYzlWZk1tVkxjTHI2WmV0RFpiYVNGVExxblNPL2JJUGpBMy96QVVvcWdHRkFFUVM0SWh1TXpFcDJJM2pKemJ6a2svSUVteWF4K3JoWlR3ZDZmK0NHdHdQaXh1OEl2ekFDcXVQV1BSRXU5WnZHa1V6cFJ3dlJSdWFOTjZjcjBXMXdXaXRzOUlDZFlKN2x0YmdNaVNMM3NUUGV1ZmdOY1ZxTVZXRmtDUERINGpHMmpBMFhjVmdRajYyQ2IyOXY5Zi96LysyS2JZdkl2L3p6anBRQVBrbGlhVkR6TnJXNTdUWi9aT3laRDBubGZNbUFJQklBR0FJMEQzay9tZE40eHI5djg1WmJaYmJxZkgyakdkNWhVcU5aV3dsNVNQZm9HbWZFbG1helVJZU5MMWovbWtGN1ZOQXpUcTRqTnQ4Sm9RMTFOUU9jbWhwclhveFN4ZlJHSjlMREVPQVErZG14QVFIOTBpdGk5ZTJ1L01vZXVhR2NEVEhvQyt4c21FZVdteEVLZWZRdUl6SGJwdzVUYzVjRW9jYm9BRDA5b2lwV1FodFRPMXdpdmYvTytEUmUycnBsL0U5d2xyekJvcmpKc09lRzFCL1hQVzRFYUpFRmRObEVDRVpnYTVab0dSSFhnWW91R1J1VmttOHRERVNpRXlGTm8rM3M1TTVwdVNkVHlVTDJsbG5JTlZIRXQ5MVhVTlc0ZXdkTWdKNGJvSmZFeXQvaVk1V1hxYkErQTJGa3Q1WjBsdXRpV2hlOW5aSXlJVWp5WERDM1VzYUcxdCtlTng2ejRXL09Zb1RCN0E2eCtkTlNUT2k5QUluY3RiRVNxbTVndk9Md3c3T1dYUHJtSHdWWmFzcmw0ZUQxMTNwbStKdFQ3SlZPdm5DWHFkenpkVFJIZ0owUGlHVEZZVzVHdnQ5UjlMRDZMemZzMHYvVFpaSFNteVZOcTd2aUlIRTZEQks3UXAwN0l6NTVFTThTWXRRdlpmL29iQm5pVFdpNUMyL292SGZ3NFZuZGtFNVhZZGpPaENNUmpEZU9FZlhlTi9Dd2ZHZHVpVUlmc29GZVV4WGVRWGJhN2M3OTcyWE52OHcrZFRqalVNMFFlTkFSZVcrSjAxNGRLQUQvTWNRWVhUN2MwR1FQSWtuM0xsNlI3Z0dqdWlRb1pEMFRFZUVxUXBLb1oxNWcvME9QUUkxN1FpU3Y5QVVST2EvVi9UUU4zZHZMQXJlYzNScnNZbHZCbTFiOExXemx0ZHVnc0M1MGxOS1lMRXAyYStaWllxUGVqVUxSbE9KaDV6ai9MVk15VER2d0toTXh4d3VEa3hKMVFwb05JME9UV0xvbTRaNzFTTnpJOVRWMWlYSnJJdTlXY25kK01DYUF3OG8xalNYZDk0WVUvMWdua3JDOUJVRU90UXZFSVE3ZzBpNmgrS0wySktrOFlkbDdIcnV2Z1dNU0FtTmUrTHNoR2hWNHFuV0hoTzkvUklQUXpZMXRIUmoyVnFPeU5zRHBLMGN3dys1NkFkREM0Z3NXd1kwWHhvdWNJV0lxcy9HY3duV3FsYVQwS1ByOG1iSzVVOTQvMzAxaTFXTHQ0WUlOVFZ2Q0ZCckZaYkliWThleWNPZGVKMnRlRDVJZlBMQ1JnN2pqY0ZUd2xNRk5sOXpkaC9vM0UvaEhQd2o3QldnME1VMDlwUHJCTGJyQ2dtNTRBNkgrSTZ2Mjcrakw1Z2tqV2cvaVlka3M5amJmVlA1eS9uMGRsZ1dFTWxLYXNsN0p2RlpkNTZMZnliVzFlZWFWTzBneFRmWFp3RDhHNFNJMTE2eXg3VUtWUmd1aTZZYTFZcGl4cVhlTkxjOEl4dEF3Q1U1SWh3UWduK05xSG5SYUR2NjFDeEtoT3E0cE9YN002cGtBK1BtcGQ0ajF2bjZBQ1VBTG9MTGM0dnBYY2k4VmlkTHh6bTdxRkJlN3MrcXV1SnM2RVRZbW5wZ1MzTHdTWnhQSWx0Z0JEWHo4TTFrL1cyeVNOdjJmOS9OUGh4TEdLMkQyMWRrSGVTR21lblJUM1lxY2RsMG0vaDNPWXI4VitsWE5ZR2Y4YUNDcGQ0YldqRTRRSVBqN3ZVS040TnJmczdNTDZZMk95UzgzMEpDbm9mZy9rN2xwRnB0NFNxWmM1SEdnMUhDT3JIdk9kQzhiUDZGR0RiRS9WVjBtWDRJYWt6YmRTL29wK0t0M0cyNC84UWJCVjd5ODZzR1NRL3ZaelU4RlhzN3U2akl2d2Noc0VQMkJwSWhXM0c4dVdOd2EzSG1qZkgvWmpoaENXdmx1QWNGK25NZjE0Q2xLZzVoR2d0UExKOTh1ZU5Ba2M1SHMyV1psazJRSHZmcmVDSzFDQ0dPNm5NWlZTYjk5Vk0vYWpyOFdIVHRlOUpTbWtYcS9pL1U5NDNIRWJkelc2UmUvUzg4ZEtnZzhwR09MbEFlTmlxcmNMa1VSMy9hQ2xGcE1YY09VUDNybUVUY1dTZk1YWkUzVFVPaThpK2ZxUm5UWUxmbFZ4L1ZiLzZHSjdlSVJaVUE2azNSWVIzaUZTSzljNGlEZE53SnVaTDJGS3ovSUs1VmltY05XRXFkWGpTb3hTZ21GMFVQbERvVWxOclBjTTdmdG1BOFk5Z0tpcUtFSHVXTitBWlJJd3RWU3h5ZTJLZjhyTTNsaEo1WGNCWFU5bjR2ME95MVJVMk0rNHFNOEFRUFZ3c2U4RXJOU29iNW9GUFd4dXFablZ6bzFxQi9JQnhrTTNFVlVLRlVVbE8zZTUxMjU5R2dOY0piQ21sdnJkanRvVFc3ckNobTF3eUNLenBDVHdvelVVRU9JY1dMbmVSTGdNWGgrU2pHU0ZrQWxsemJHUzVISzdMbGZDTVJOUkRTdmJRUGpjWGFlbk5ZeEN2dTJReXpuejZTdHV4Vmo2NlNnSTBUOEI2L3NmSEFKWVphWjc4dGhqT1NJRnVtTldMUWJlWml4RENDQyt2MFlCdGt4aUJCM2plZkhxWi9kRkhVK2NyYmo2T3ZTMXgvSkREN3ZsbTd6T1ZQd3BVQzAxbmh4WnVZLzYzRTdnJztcblxuLy8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMTUvXHJcbi8vIGZvciByZWZlcmVuY2UgaW1wbGVtZW50YXRpb25cclxuLy8gc2VlOiAvZGVyaXZlL25mLmpzXHJcblxyXG5cclxuLy8gYWxnb3JpdGhtaWMgaGFuZ3VsXHJcbi8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3ZlcnNpb25zL1VuaWNvZGUxNS4wLjAvY2gwMy5wZGYgKHBhZ2UgMTQ0KVxyXG5jb25zdCBTMCA9IDB4QUMwMDtcclxuY29uc3QgTDAgPSAweDExMDA7XHJcbmNvbnN0IFYwID0gMHgxMTYxO1xyXG5jb25zdCBUMCA9IDB4MTFBNztcclxuY29uc3QgTF9DT1VOVCA9IDE5O1xyXG5jb25zdCBWX0NPVU5UID0gMjE7XHJcbmNvbnN0IFRfQ09VTlQgPSAyODtcclxuY29uc3QgTl9DT1VOVCA9IFZfQ09VTlQgKiBUX0NPVU5UO1xyXG5jb25zdCBTX0NPVU5UID0gTF9DT1VOVCAqIE5fQ09VTlQ7XHJcbmNvbnN0IFMxID0gUzAgKyBTX0NPVU5UO1xyXG5jb25zdCBMMSA9IEwwICsgTF9DT1VOVDtcclxuY29uc3QgVjEgPSBWMCArIFZfQ09VTlQ7XHJcbmNvbnN0IFQxID0gVDAgKyBUX0NPVU5UO1xyXG5cclxuZnVuY3Rpb24gdW5wYWNrX2NjKHBhY2tlZCkge1xyXG5cdHJldHVybiAocGFja2VkID4+IDI0KSAmIDB4RkY7XHJcbn1cclxuZnVuY3Rpb24gdW5wYWNrX2NwKHBhY2tlZCkge1xyXG5cdHJldHVybiBwYWNrZWQgJiAweEZGRkZGRjtcclxufVxyXG5cclxubGV0IFNISUZURURfUkFOSywgRVhDTFVTSU9OUywgREVDT01QLCBSRUNPTVA7XHJcblxyXG5mdW5jdGlvbiBpbml0JDEoKSB7XHJcblx0Ly9jb25zb2xlLnRpbWUoJ25mJyk7XHJcblx0bGV0IHIgPSByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChDT01QUkVTU0VEKTtcclxuXHRTSElGVEVEX1JBTksgPSBuZXcgTWFwKHJlYWRfc29ydGVkX2FycmF5cyhyKS5mbGF0TWFwKCh2LCBpKSA9PiB2Lm1hcCh4ID0+IFt4LCAoaSsxKSA8PCAyNF0pKSk7IC8vIHByZS1zaGlmdGVkXHJcblx0RVhDTFVTSU9OUyA9IG5ldyBTZXQocmVhZF9zb3J0ZWQocikpO1xyXG5cdERFQ09NUCA9IG5ldyBNYXAoKTtcclxuXHRSRUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0Zm9yIChsZXQgW2NwLCBjcHNdIG9mIHJlYWRfbWFwcGVkKHIpKSB7XHJcblx0XHRpZiAoIUVYQ0xVU0lPTlMuaGFzKGNwKSAmJiBjcHMubGVuZ3RoID09IDIpIHtcclxuXHRcdFx0bGV0IFthLCBiXSA9IGNwcztcclxuXHRcdFx0bGV0IGJ1Y2tldCA9IFJFQ09NUC5nZXQoYSk7XHJcblx0XHRcdGlmICghYnVja2V0KSB7XHJcblx0XHRcdFx0YnVja2V0ID0gbmV3IE1hcCgpO1xyXG5cdFx0XHRcdFJFQ09NUC5zZXQoYSwgYnVja2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRidWNrZXQuc2V0KGIsIGNwKTtcclxuXHRcdH1cclxuXHRcdERFQ09NUC5zZXQoY3AsIGNwcy5yZXZlcnNlKCkpOyAvLyBzdG9yZWQgcmV2ZXJzZWRcclxuXHR9XHJcblx0Ly9jb25zb2xlLnRpbWVFbmQoJ25mJyk7XHJcblx0Ly8gMjAyMzA5MDU6IDExbXNcclxufVxyXG5cclxuZnVuY3Rpb24gaXNfaGFuZ3VsKGNwKSB7XHJcblx0cmV0dXJuIGNwID49IFMwICYmIGNwIDwgUzE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBvc2VfcGFpcihhLCBiKSB7XHJcblx0aWYgKGEgPj0gTDAgJiYgYSA8IEwxICYmIGIgPj0gVjAgJiYgYiA8IFYxKSB7XHJcblx0XHRyZXR1cm4gUzAgKyAoYSAtIEwwKSAqIE5fQ09VTlQgKyAoYiAtIFYwKSAqIFRfQ09VTlQ7XHJcblx0fSBlbHNlIGlmIChpc19oYW5ndWwoYSkgJiYgYiA+IFQwICYmIGIgPCBUMSAmJiAoYSAtIFMwKSAlIFRfQ09VTlQgPT0gMCkge1xyXG5cdFx0cmV0dXJuIGEgKyAoYiAtIFQwKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0bGV0IHJlY29tcCA9IFJFQ09NUC5nZXQoYSk7XHJcblx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdHJlY29tcCA9IHJlY29tcC5nZXQoYik7XHJcblx0XHRcdGlmIChyZWNvbXApIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVjb21wO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWNvbXBvc2VkKGNwcykge1xyXG5cdGlmICghU0hJRlRFRF9SQU5LKSBpbml0JDEoKTtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGxldCBjaGVja19vcmRlciA9IGZhbHNlO1xyXG5cdGZ1bmN0aW9uIGFkZChjcCkge1xyXG5cdFx0bGV0IGNjID0gU0hJRlRFRF9SQU5LLmdldChjcCk7XHJcblx0XHRpZiAoY2MpIHtcclxuXHRcdFx0Y2hlY2tfb3JkZXIgPSB0cnVlO1xyXG5cdFx0XHRjcCB8PSBjYztcclxuXHRcdH1cclxuXHRcdHJldC5wdXNoKGNwKTtcclxuXHR9XHJcblx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRpZiAoY3AgPCAweDgwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlzX2hhbmd1bChjcCkpIHtcclxuXHRcdFx0XHRsZXQgc19pbmRleCA9IGNwIC0gUzA7XHJcblx0XHRcdFx0bGV0IGxfaW5kZXggPSBzX2luZGV4IC8gTl9DT1VOVCB8IDA7XHJcblx0XHRcdFx0bGV0IHZfaW5kZXggPSAoc19pbmRleCAlIE5fQ09VTlQpIC8gVF9DT1VOVCB8IDA7XHJcblx0XHRcdFx0bGV0IHRfaW5kZXggPSBzX2luZGV4ICUgVF9DT1VOVDtcclxuXHRcdFx0XHRhZGQoTDAgKyBsX2luZGV4KTtcclxuXHRcdFx0XHRhZGQoVjAgKyB2X2luZGV4KTtcclxuXHRcdFx0XHRpZiAodF9pbmRleCA+IDApIGFkZChUMCArIHRfaW5kZXgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBtYXBwZWQgPSBERUNPTVAuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAobWFwcGVkKSB7XHJcblx0XHRcdFx0XHRidWYucHVzaCguLi5tYXBwZWQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRhZGQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWJ1Zi5sZW5ndGgpIGJyZWFrO1xyXG5cdFx0XHRjcCA9IGJ1Zi5wb3AoKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNoZWNrX29yZGVyICYmIHJldC5sZW5ndGggPiAxKSB7XHJcblx0XHRsZXQgcHJldl9jYyA9IHVucGFja19jYyhyZXRbMF0pO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGNjID0gdW5wYWNrX2NjKHJldFtpXSk7XHJcblx0XHRcdGlmIChjYyA9PSAwIHx8IHByZXZfY2MgPD0gY2MpIHtcclxuXHRcdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGogPSBpLTE7XHJcblx0XHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdFx0bGV0IHRtcCA9IHJldFtqKzFdO1xyXG5cdFx0XHRcdHJldFtqKzFdID0gcmV0W2pdO1xyXG5cdFx0XHRcdHJldFtqXSA9IHRtcDtcclxuXHRcdFx0XHRpZiAoIWopIGJyZWFrO1xyXG5cdFx0XHRcdHByZXZfY2MgPSB1bnBhY2tfY2MocmV0Wy0tal0pO1xyXG5cdFx0XHRcdGlmIChwcmV2X2NjIDw9IGNjKSBicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFtpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZCh2KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBzdGFjayA9IFtdO1xyXG5cdGxldCBwcmV2X2NwID0gLTE7XHJcblx0bGV0IHByZXZfY2MgPSAwO1xyXG5cdGZvciAobGV0IHBhY2tlZCBvZiB2KSB7XHJcblx0XHRsZXQgY2MgPSB1bnBhY2tfY2MocGFja2VkKTtcclxuXHRcdGxldCBjcCA9IHVucGFja19jcChwYWNrZWQpO1xyXG5cdFx0aWYgKHByZXZfY3AgPT0gLTEpIHtcclxuXHRcdFx0aWYgKGNjID09IDApIHtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0LnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPiAwICYmIHByZXZfY2MgPj0gY2MpIHtcclxuXHRcdFx0aWYgKGNjID09IDApIHtcclxuXHRcdFx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHJcblx0XHRcdFx0c3RhY2subGVuZ3RoID0gMDtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChjcCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNvbXBvc2VkID0gY29tcG9zZV9wYWlyKHByZXZfY3AsIGNwKTtcclxuXHRcdFx0aWYgKGNvbXBvc2VkID49IDApIHtcclxuXHRcdFx0XHRwcmV2X2NwID0gY29tcG9zZWQ7XHJcblx0XHRcdH0gZWxzZSBpZiAocHJldl9jYyA9PSAwICYmIGNjID09IDApIHtcclxuXHRcdFx0XHRyZXQucHVzaChwcmV2X2NwKTtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChjcCk7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2X2NwID49IDApIHtcclxuXHRcdHJldC5wdXNoKHByZXZfY3AsIC4uLnN0YWNrKTtcdFxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBub3RlOiBjcHMgY2FuIGJlIGl0ZXJhYmxlXHJcbmZ1bmN0aW9uIG5mZChjcHMpIHtcclxuXHRyZXR1cm4gZGVjb21wb3NlZChjcHMpLm1hcCh1bnBhY2tfY3ApO1xyXG59XHJcbmZ1bmN0aW9uIG5mYyhjcHMpIHtcclxuXHRyZXR1cm4gY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkKGRlY29tcG9zZWQoY3BzKSk7XHJcbn1cblxuY29uc3QgSFlQSEVOID0gMHgyRDtcclxuY29uc3QgU1RPUCA9IDB4MkU7XHJcbmNvbnN0IFNUT1BfQ0ggPSAnLic7XHJcbmNvbnN0IEZFMEYgPSAweEZFMEY7XHJcbmNvbnN0IFVOSVFVRV9QSCA9IDE7XHJcblxyXG4vLyAyMDIzMDkxMzogcmVwbGFjZSBbLi4udl0gd2l0aCBBcnJheV9mcm9tKHYpIHRvIGF2b2lkIGxhcmdlIHNwcmVhZHNcclxuY29uc3QgQXJyYXlfZnJvbSA9IHggPT4gQXJyYXkuZnJvbSh4KTsgLy8gQXJyYXkuZnJvbS5iaW5kKEFycmF5KTtcclxuXHJcbmZ1bmN0aW9uIGdyb3VwX2hhc19jcChnLCBjcCkge1xyXG5cdC8vIDIwMjMwOTEzOiBrZWVwIHByaW1hcnkgYW5kIHNlY29uZGFyeSBkaXN0aW5jdCBpbnN0ZWFkIG9mIGNyZWF0aW5nIHZhbGlkIHVuaW9uXHJcblx0cmV0dXJuIGcuUC5oYXMoY3ApIHx8IGcuUS5oYXMoY3ApO1xyXG59XHJcblxyXG5jbGFzcyBFbW9qaSBleHRlbmRzIEFycmF5IHtcclxuXHRnZXQgaXNfZW1vamkoKSB7IHJldHVybiB0cnVlOyB9IC8vIGZyZWUgdGFnZ2luZyBzeXN0ZW1cclxufVxyXG5cclxubGV0IE1BUFBFRCwgSUdOT1JFRCwgQ00sIE5TTSwgRVNDQVBFLCBORkNfQ0hFQ0ssIEdST1VQUywgV0hPTEVfVkFMSUQsIFdIT0xFX01BUCwgVkFMSUQsIEVNT0pJX0xJU1QsIEVNT0pJX1JPT1Q7XHJcblxyXG5mdW5jdGlvbiBpbml0KCkge1xyXG5cdGlmIChNQVBQRUQpIHJldHVybjtcclxuXHRcclxuXHRsZXQgciA9IHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKENPTVBSRVNTRUQkMSk7XHJcblx0Y29uc3QgcmVhZF9zb3J0ZWRfYXJyYXkgPSAoKSA9PiByZWFkX3NvcnRlZChyKTtcclxuXHRjb25zdCByZWFkX3NvcnRlZF9zZXQgPSAoKSA9PiBuZXcgU2V0KHJlYWRfc29ydGVkX2FycmF5KCkpO1xyXG5cdGNvbnN0IHNldF9hZGRfbWFueSA9IChzZXQsIHYpID0+IHYuZm9yRWFjaCh4ID0+IHNldC5hZGQoeCkpO1xyXG5cclxuXHRNQVBQRUQgPSBuZXcgTWFwKHJlYWRfbWFwcGVkKHIpKTsgXHJcblx0SUdOT1JFRCA9IHJlYWRfc29ydGVkX3NldCgpOyAvLyBpZ25vcmVkIGNoYXJhY3RlcnMgYXJlIG5vdCB2YWxpZCwgc28ganVzdCByZWFkIHJhdyBjb2RlcG9pbnRzXHJcblxyXG5cdC8qXHJcblx0Ly8gZGlyZWN0IGluY2x1ZGUgZnJvbSBwYXlsb2FkIGlzIHNtYWxsZXIgdGhhbiB0aGUgZGVjb21wcmVzc2lvbiBjb2RlXHJcblx0Y29uc3QgRkVOQ0VEID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdGxldCBjcCA9IHIoKTtcclxuXHRcdGlmIChjcCkgcmV0dXJuIFtjcCwgcmVhZF9zdHIocigpKV07XHJcblx0fSkpO1xyXG5cdCovXHJcblx0Ly8gMjAyMzAyMTc6IHdlIHN0aWxsIG5lZWQgYWxsIENNIGZvciBwcm9wZXIgZXJyb3IgZm9ybWF0dGluZ1xyXG5cdC8vIGJ1dCBub3JtIG9ubHkgbmVlZHMgTlNNIHN1YnNldCB0aGF0IGFyZSBwb3RlbnRpYWxseS12YWxpZFxyXG5cdENNID0gcmVhZF9zb3J0ZWRfYXJyYXkoKTtcclxuXHROU00gPSBuZXcgU2V0KHJlYWRfc29ydGVkX2FycmF5KCkubWFwKGkgPT4gQ01baV0pKTtcclxuXHRDTSA9IG5ldyBTZXQoQ00pO1xyXG5cdFxyXG5cdEVTQ0FQRSA9IHJlYWRfc29ydGVkX3NldCgpOyAvLyBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIG5vdCBiZSBwcmludGVkXHJcblx0TkZDX0NIRUNLID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIG9ubHkgbmVlZGVkIHRvIGlsbHVzdHJhdGUgZW5zX3Rva2VuaXplKCkgdHJhbnNmb3JtYXRpb25zXHJcblxyXG5cdGxldCBjaHVua3MgPSByZWFkX3NvcnRlZF9hcnJheXMocik7XHJcblx0bGV0IHVucmVzdHJpY3RlZCA9IHIoKTtcclxuXHQvL2NvbnN0IHJlYWRfY2h1bmtlZCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5mbGF0TWFwKGkgPT4gY2h1bmtzW2ldKS5jb25jYXQocmVhZF9zb3J0ZWRfYXJyYXkoKSkpO1xyXG5cdGNvbnN0IHJlYWRfY2h1bmtlZCA9ICgpID0+IHtcclxuXHRcdC8vIDIwMjMwOTIxOiBidWlsZCBzZXQgaW4gcGFydHMsIDJ4IGZhc3RlclxyXG5cdFx0bGV0IHNldCA9IG5ldyBTZXQoKTtcclxuXHRcdHJlYWRfc29ydGVkX2FycmF5KCkuZm9yRWFjaChpID0+IHNldF9hZGRfbWFueShzZXQsIGNodW5rc1tpXSkpO1xyXG5cdFx0c2V0X2FkZF9tYW55KHNldCwgcmVhZF9zb3J0ZWRfYXJyYXkoKSk7XHJcblx0XHRyZXR1cm4gc2V0OyBcclxuXHR9O1xyXG5cdEdST1VQUyA9IHJlYWRfYXJyYXlfd2hpbGUoaSA9PiB7XHJcblx0XHQvLyBtaW5pZmllciBwcm9wZXJ0eSBtYW5nbGluZyBzZWVtcyB1bnNhZmVcclxuXHRcdC8vIHNvIHRoZXNlIGFyZSBtYW51YWxseSByZW5hbWVkIHRvIHNpbmdsZSBjaGFyc1xyXG5cdFx0bGV0IE4gPSByZWFkX2FycmF5X3doaWxlKHIpLm1hcCh4ID0+IHgrMHg2MCk7XHJcblx0XHRpZiAoTi5sZW5ndGgpIHtcclxuXHRcdFx0bGV0IFIgPSBpID49IHVucmVzdHJpY3RlZDsgLy8gdW5yZXN0cmljdGVkIHRoZW4gcmVzdHJpY3RlZFxyXG5cdFx0XHROWzBdIC09IDMyOyAvLyBjYXBpdGFsaXplXHJcblx0XHRcdE4gPSBzdHJfZnJvbV9jcHMoTik7XHJcblx0XHRcdGlmIChSKSBOPWBSZXN0cmljdGVkWyR7Tn1dYDtcclxuXHRcdFx0bGV0IFAgPSByZWFkX2NodW5rZWQoKTsgLy8gcHJpbWFyeVxyXG5cdFx0XHRsZXQgUSA9IHJlYWRfY2h1bmtlZCgpOyAvLyBzZWNvbmRhcnlcclxuXHRcdFx0bGV0IE0gPSAhcigpOyAvLyBub3Qtd2hpdGVsaXN0ZWQsIGNoZWNrIGZvciBOU01cclxuXHRcdFx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdFx0XHQvKlxyXG5cdFx0XHRsZXQgViA9IFsuLi5QLCAuLi5RXS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBkZXJpdmU6IHNvcnRlZCB2YWxpZFxyXG5cdFx0XHRsZXQgTSA9IHIoKS0xOyAvLyBudW1iZXIgb2YgY29tYmluaW5nIG1hcmtcclxuXHRcdFx0aWYgKE0gPCAwKSB7IC8vIHdoaXRlbGlzdGVkXHJcblx0XHRcdFx0TSA9IG5ldyBNYXAocmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRcdFx0XHRsZXQgaSA9IHIoKTtcclxuXHRcdFx0XHRcdGlmIChpKSByZXR1cm4gW1ZbaS0xXSwgcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRcdFx0XHRcdGxldCB2ID0gcmVhZF9hcnJheV93aGlsZShyKTtcclxuXHRcdFx0XHRcdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdi5tYXAoeCA9PiB4LTEpO1xyXG5cdFx0XHRcdFx0fSldO1xyXG5cdFx0XHRcdH0pKTtcclxuXHRcdFx0fSovXHJcblx0XHRcdHJldHVybiB7TiwgUCwgUSwgTSwgUn07XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdC8vIGRlY29kZSBjb21wcmVzc2VkIHdob2xlc1xyXG5cdFdIT0xFX1ZBTElEID0gcmVhZF9zb3J0ZWRfc2V0KCk7XHJcblx0V0hPTEVfTUFQID0gbmV3IE1hcCgpO1xyXG5cdGxldCB3aG9sZXMgPSByZWFkX3NvcnRlZF9hcnJheSgpLmNvbmNhdChBcnJheV9mcm9tKFdIT0xFX1ZBTElEKSkuc29ydCgoYSwgYikgPT4gYS1iKTsgLy8gbXVzdCBiZSBzb3J0ZWRcclxuXHR3aG9sZXMuZm9yRWFjaCgoY3AsIGkpID0+IHtcclxuXHRcdGxldCBkID0gcigpOyBcclxuXHRcdGxldCB3ID0gd2hvbGVzW2ldID0gZCA/IHdob2xlc1tpLWRdIDoge1Y6IFtdLCBNOiBuZXcgTWFwKCl9O1xyXG5cdFx0dy5WLnB1c2goY3ApOyAvLyBhZGQgdG8gbWVtYmVyIHNldFxyXG5cdFx0aWYgKCFXSE9MRV9WQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFdIT0xFX01BUC5zZXQoY3AsIHcpOyAgLy8gcmVnaXN0ZXIgd2l0aCB3aG9sZSBtYXBcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gY29tcHV0ZSBjb25mdXNhYmxlLWV4dGVudCBjb21wbGVtZW50c1xyXG5cdC8vIHVzYWdlOiBXSE9MRV9NQVAuZ2V0KGNwKS5NLmdldChjcCkgPSBjb21wbGVtZW50IHNldFxyXG5cdGZvciAobGV0IHtWLCBNfSBvZiBuZXcgU2V0KFdIT0xFX01BUC52YWx1ZXMoKSkpIHtcclxuXHRcdC8vIGNvbm5lY3QgYWxsIGdyb3VwcyB0aGF0IGhhdmUgZWFjaCB3aG9sZSBjaGFyYWN0ZXJcclxuXHRcdGxldCByZWNzID0gW107XHJcblx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdGxldCBncyA9IEdST1VQUy5maWx0ZXIoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKTtcclxuXHRcdFx0bGV0IHJlYyA9IHJlY3MuZmluZCgoe0d9KSA9PiBncy5zb21lKGcgPT4gRy5oYXMoZykpKTtcclxuXHRcdFx0aWYgKCFyZWMpIHtcclxuXHRcdFx0XHRyZWMgPSB7RzogbmV3IFNldCgpLCBWOiBbXX07XHJcblx0XHRcdFx0cmVjcy5wdXNoKHJlYyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmVjLlYucHVzaChjcCk7XHJcblx0XHRcdHNldF9hZGRfbWFueShyZWMuRywgZ3MpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gcGVyIGNoYXJhY3RlciBjYWNoZSBncm91cHMgd2hpY2ggYXJlIG5vdCBhIG1lbWJlciBvZiB0aGUgZXh0ZW50XHJcblx0XHRsZXQgdW5pb24gPSByZWNzLmZsYXRNYXAoeCA9PiBBcnJheV9mcm9tKHguRykpOyAvLyBhbGwgb2YgdGhlIGdyb3VwcyB1c2VkIGJ5IHRoaXMgd2hvbGVcclxuXHRcdGZvciAobGV0IHtHLCBWfSBvZiByZWNzKSB7XHJcblx0XHRcdGxldCBjb21wbGVtZW50ID0gbmV3IFNldCh1bmlvbi5maWx0ZXIoZyA9PiAhRy5oYXMoZykpKTsgLy8gZ3JvdXBzIG5vdCBjb3ZlcmVkIGJ5IHRoZSBleHRlbnRcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgVikge1xyXG5cdFx0XHRcdE0uc2V0KGNwLCBjb21wbGVtZW50KTsgLy8gdGhpcyBpcyB0aGUgc2FtZSByZWZlcmVuY2VcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gY29tcHV0ZSB2YWxpZCBzZXRcclxuXHQvLyAyMDIzMDkyNDogVkFMSUQgd2FzIHVuaW9uIGJ1dCBjYW4gYmUgcmUtdXNlZFxyXG5cdFZBTElEID0gbmV3IFNldCgpOyAvLyBleGlzdHMgaW4gMSsgZ3JvdXBzXHJcblx0bGV0IG11bHRpID0gbmV3IFNldCgpOyAvLyBleGlzdHMgaW4gMisgZ3JvdXBzXHJcblx0Y29uc3QgYWRkX3RvX3VuaW9uID0gY3AgPT4gVkFMSUQuaGFzKGNwKSA/IG11bHRpLmFkZChjcCkgOiBWQUxJRC5hZGQoY3ApO1xyXG5cdGZvciAobGV0IGcgb2YgR1JPVVBTKSB7XHJcblx0XHRmb3IgKGxldCBjcCBvZiBnLlApIGFkZF90b191bmlvbihjcCk7XHJcblx0XHRmb3IgKGxldCBjcCBvZiBnLlEpIGFkZF90b191bmlvbihjcCk7XHJcblx0fVxyXG5cdC8vIGR1YWwgcHVycG9zZSBXSE9MRV9NQVA6IHJldHVybiBwbGFjZWhvbGRlciBpZiB1bmlxdWUgbm9uLWNvbmZ1c2FibGVcclxuXHRmb3IgKGxldCBjcCBvZiBWQUxJRCkge1xyXG5cdFx0aWYgKCFXSE9MRV9NQVAuaGFzKGNwKSAmJiAhbXVsdGkuaGFzKGNwKSkge1xyXG5cdFx0XHRXSE9MRV9NQVAuc2V0KGNwLCBVTklRVUVfUEgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyBhZGQgYWxsIGRlY29tcG9zZWQgcGFydHNcclxuXHQvLyBzZWUgZGVyaXZlOiBcIlZhbGlkIGlzIENsb3NlZCAodmlhIEJydXRlLWZvcmNlKVwiXHJcblx0c2V0X2FkZF9tYW55KFZBTElELCBuZmQoVkFMSUQpKTtcclxuXHRcclxuXHQvLyBkZWNvZGUgZW1vamlcclxuXHQvLyAyMDIzMDcxOTogZW1vamkgYXJlIG5vdyBmdWxseS1leHBhbmRlZCB0byBhdm9pZCBxdWlyayBsb2dpYyBcclxuXHRFTU9KSV9MSVNUID0gcmVhZF90cmllKHIpLm1hcCh2ID0+IEVtb2ppLmZyb20odikpLnNvcnQoY29tcGFyZV9hcnJheXMpO1xyXG5cdEVNT0pJX1JPT1QgPSBuZXcgTWFwKCk7IC8vIHRoaXMgaGFzIGFwcHJveCA3SyBub2RlcyAoMisgcGVyIGVtb2ppKVxyXG5cdGZvciAobGV0IGNwcyBvZiBFTU9KSV9MSVNUKSB7XHJcblx0XHQvLyAyMDIzMDcxOTogY2hhbmdlIHRvICpzbGlnaHRseSogc3RyaWN0ZXIgYWxnb3JpdGhtIHdoaWNoIGRpc2FsbG93cyBcclxuXHRcdC8vIGluc2VydGlvbiBvZiBtaXNwbGFjZWQgRkUwRiBpbiBlbW9qaSBzZXF1ZW5jZXMgKG1hdGNoaW5nIEVOU0lQLTE1KVxyXG5cdFx0Ly8gZXhhbXBsZTogYmVhdXRpZmllZCBbQSBCXSAoZWcuIGZsYWcgZW1vamkpIFxyXG5cdFx0Ly8gIGJlZm9yZTogYWxsb3c6IFtBIEZFMEYgQl0sIGVycm9yOiBbQSBGRTBGIEZFMEYgQl0gXHJcblx0XHQvLyAgIGFmdGVyOiBlcnJvcjogYm90aFxyXG5cdFx0Ly8gbm90ZTogdGhpcyBjb2RlIG5vdyBtYXRjaGVzIEVOU05vcm1hbGl6ZS57Y3MsamF2YX0gbG9naWNcclxuXHRcdGxldCBwcmV2ID0gW0VNT0pJX1JPT1RdO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRcdGxldCBuZXh0ID0gcHJldi5tYXAobm9kZSA9PiB7XHJcblx0XHRcdFx0bGV0IGNoaWxkID0gbm9kZS5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmICghY2hpbGQpIHtcclxuXHRcdFx0XHRcdC8vIHNob3VsZCB0aGlzIGJlIG9iamVjdD8gXHJcblx0XHRcdFx0XHQvLyAobW9zdCBoYXZlIDEtMiBpdGVtcywgZmV3IGhhdmUgbWFueSlcclxuXHRcdFx0XHRcdC8vIDIwMjMwNzE5OiBubywgdjggZGVmYXVsdCBtYXAgaXMgND9cclxuXHRcdFx0XHRcdGNoaWxkID0gbmV3IE1hcCgpO1xyXG5cdFx0XHRcdFx0bm9kZS5zZXQoY3AsIGNoaWxkKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGNoaWxkO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYgKGNwID09PSBGRTBGKSB7XHJcblx0XHRcdFx0cHJldi5wdXNoKC4uLm5leHQpOyAvLyBsZXNzIHRoYW4gMjAgZWxlbWVudHNcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRwcmV2ID0gbmV4dDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yIChsZXQgeCBvZiBwcmV2KSB7XHJcblx0XHRcdHguViA9IGNwcztcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIGlmIGVzY2FwZWQ6IHtIRVh9XHJcbi8vICAgICAgIGVsc2U6IFwieFwiIHtIRVh9XHJcbmZ1bmN0aW9uIHF1b3RlZF9jcChjcCkge1xyXG5cdHJldHVybiAoc2hvdWxkX2VzY2FwZShjcCkgPyAnJyA6IGAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoW2NwXSkpfSBgKSArIHF1b3RlX2NwKGNwKTtcclxufVxyXG5cclxuLy8gMjAyMzAyMTE6IHNvbWUgbWVzc2FnZXMgY2FuIGJlIG1peGVkLWRpcmVjdGlvbmFsIGFuZCByZXN1bHQgaW4gc3BpbGxvdmVyXHJcbi8vIHVzZSAyMDBFIGFmdGVyIGEgcXVvdGVkIHN0cmluZyB0byBmb3JjZSB0aGUgcmVtYWluZGVyIG9mIGEgc3RyaW5nIGZyb20gXHJcbi8vIGFjcXVyaW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHF1b3RlXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9JbnRlcm5hdGlvbmFsL3F1ZXN0aW9ucy9xYS1iaWRpLXVuaWNvZGUtY29udHJvbHMjZXhjZXB0aW9uc1xyXG5mdW5jdGlvbiBiaWRpX3FxKHMpIHtcclxuXHRyZXR1cm4gYFwiJHtzfVwiXFx1MjAwRWA7IC8vIHN0cm9uZyBMVFJcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tfbGFiZWxfZXh0ZW5zaW9uKGNwcykge1xyXG5cdGlmIChjcHMubGVuZ3RoID49IDQgJiYgY3BzWzJdID09IEhZUEhFTiAmJiBjcHNbM10gPT0gSFlQSEVOKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbGFiZWwgZXh0ZW5zaW9uOiBcIiR7c3RyX2Zyb21fY3BzKGNwcy5zbGljZSgwLCA0KSl9XCJgKTsgLy8gdGhpcyBjYW4gb25seSBiZSBhc2NpaSBzbyBjYW50IGJlIGJpZGlcclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tfbGVhZGluZ191bmRlcnNjb3JlKGNwcykge1xyXG5cdGNvbnN0IFVOREVSU0NPUkUgPSAweDVGO1xyXG5cdGZvciAobGV0IGkgPSBjcHMubGFzdEluZGV4T2YoVU5ERVJTQ09SRSk7IGkgPiAwOyApIHtcclxuXHRcdGlmIChjcHNbLS1pXSAhPT0gVU5ERVJTQ09SRSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3VuZGVyc2NvcmUgYWxsb3dlZCBvbmx5IGF0IHN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbi8vIGNoZWNrIHRoYXQgYSBmZW5jZWQgY3AgaXMgbm90IGxlYWRpbmcsIHRyYWlsaW5nLCBvciB0b3VjaGluZyBhbm90aGVyIGZlbmNlZCBjcFxyXG5mdW5jdGlvbiBjaGVja19mZW5jZWQoY3BzKSB7XHJcblx0bGV0IGNwID0gY3BzWzBdO1xyXG5cdGxldCBwcmV2ID0gRkVOQ0VELmdldChjcCk7XHJcblx0aWYgKHByZXYpIHRocm93IGVycm9yX3BsYWNlbWVudChgbGVhZGluZyAke3ByZXZ9YCk7XHJcblx0bGV0IG4gPSBjcHMubGVuZ3RoO1xyXG5cdGxldCBsYXN0ID0gLTE7IC8vIHByZXZlbnRzIHRyYWlsaW5nIGZyb20gdGhyb3dpbmdcclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykge1xyXG5cdFx0Y3AgPSBjcHNbaV07XHJcblx0XHRsZXQgbWF0Y2ggPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRcdGlmIChtYXRjaCkge1xyXG5cdFx0XHQvLyBzaW5jZSBjcHNbMF0gaXNuJ3QgZmVuY2VkLCBjcHNbMV0gY2Fubm90IHRocm93XHJcblx0XHRcdGlmIChsYXN0ID09IGkpIHRocm93IGVycm9yX3BsYWNlbWVudChgJHtwcmV2fSArICR7bWF0Y2h9YCk7XHJcblx0XHRcdGxhc3QgPSBpICsgMTtcclxuXHRcdFx0cHJldiA9IG1hdGNoO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobGFzdCA9PSBuKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYHRyYWlsaW5nICR7cHJldn1gKTtcclxufVxyXG5cclxuLy8gY3JlYXRlIGEgc2FmZSB0byBwcmludCBzdHJpbmcgXHJcbi8vIGludmlzaWJsZXMgYXJlIGVzY2FwZWRcclxuLy8gbGVhZGluZyBjbSB1c2VzIHBsYWNlaG9sZGVyXHJcbi8vIGlmIGNwcyBleGNlZWQgbWF4LCBtaWRkbGUgdHJ1bmNhdGUgd2l0aCBlbGxpcHNpc1xyXG4vLyBxdW90ZXIoY3ApID0+IHN0cmluZywgZWcuIDMwMDAgPT4gXCJ7MzAwMH1cIlxyXG4vLyBub3RlOiBpbiBodG1sLCB5b3UnZCBjYWxsIHRoaXMgZnVuY3Rpb24gdGhlbiByZXBsYWNlIFs8PiZdIHdpdGggZW50aXRpZXNcclxuZnVuY3Rpb24gc2FmZV9zdHJfZnJvbV9jcHMoY3BzLCBtYXggPSBJbmZpbml0eSwgcXVvdGVyID0gcXVvdGVfY3ApIHtcclxuXHQvL2lmIChOdW1iZXIuaXNJbnRlZ2VyKGNwcykpIGNwcyA9IFtjcHNdO1xyXG5cdC8vaWYgKCFBcnJheS5pc0FycmF5KGNwcykpIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIGNvZGVwb2ludHNgKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0aWYgKGlzX2NvbWJpbmluZ19tYXJrKGNwc1swXSkpIGJ1Zi5wdXNoKCfil4wnKTtcclxuXHRpZiAoY3BzLmxlbmd0aCA+IG1heCkge1xyXG5cdFx0bWF4ID4+PSAxO1xyXG5cdFx0Y3BzID0gWy4uLmNwcy5zbGljZSgwLCBtYXgpLCAweDIwMjYsIC4uLmNwcy5zbGljZSgtbWF4KV07XHJcblx0fVxyXG5cdGxldCBwcmV2ID0gMDtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpXTtcclxuXHRcdGlmIChzaG91bGRfZXNjYXBlKGNwKSkge1xyXG5cdFx0XHRidWYucHVzaChzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKHByZXYsIGkpKSk7XHJcblx0XHRcdGJ1Zi5wdXNoKHF1b3RlcihjcCkpO1xyXG5cdFx0XHRwcmV2ID0gaSArIDE7XHJcblx0XHR9XHJcblx0fVxyXG5cdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgbikpKTtcclxuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG4vLyBub3RlOiBzZXQocykgY2Fubm90IGJlIGV4cG9zZWQgYmVjYXVzZSB0aGV5IGNhbiBiZSBtb2RpZmllZFxyXG4vLyBub3RlOiBPYmplY3QuZnJlZXplKCkgZG9lc24ndCB3b3JrXHJcbmZ1bmN0aW9uIGlzX2NvbWJpbmluZ19tYXJrKGNwKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBDTS5oYXMoY3ApO1xyXG59XHJcbmZ1bmN0aW9uIHNob3VsZF9lc2NhcGUoY3ApIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVTQ0FQRS5oYXMoY3ApO1xyXG59XHJcblxyXG4vLyByZXR1cm4gYWxsIHN1cHBvcnRlZCBlbW9qaSBhcyBmdWxseS1xdWFsaWZpZWQgZW1vamkgXHJcbi8vIG9yZGVyZWQgYnkgbGVuZ3RoIHRoZW4gbGV4aWNvZ3JhcGhpYyBcclxuZnVuY3Rpb24gZW5zX2Vtb2ppKCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRU1PSklfTElTVC5tYXAoeCA9PiB4LnNsaWNlKCkpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemVfZnJhZ21lbnQoZnJhZywgZGVjb21wb3NlKSB7XHJcblx0aW5pdCgpO1xyXG5cdGxldCBuZiA9IGRlY29tcG9zZSA/IG5mZCA6IG5mYztcclxuXHRyZXR1cm4gZnJhZy5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4gc3RyX2Zyb21fY3BzKHRva2Vuc19mcm9tX3N0cihleHBsb2RlX2NwKGxhYmVsKSwgbmYsIGZpbHRlcl9mZTBmKS5mbGF0KCkpKS5qb2luKFNUT1BfQ0gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplKG5hbWUpIHtcclxuXHRyZXR1cm4gZmxhdHRlbihzcGxpdChuYW1lLCBuZmMsIGZpbHRlcl9mZTBmKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19iZWF1dGlmeShuYW1lKSB7XHJcblx0bGV0IGxhYmVscyA9IHNwbGl0KG5hbWUsIG5mYywgeCA9PiB4KTsgLy8gZW1vamkgbm90IGV4cG9zZWRcclxuXHRmb3IgKGxldCB7dHlwZSwgb3V0cHV0LCBlcnJvcn0gb2YgbGFiZWxzKSB7XHJcblx0XHRpZiAoZXJyb3IpIGJyZWFrOyAvLyBmbGF0dGVuIHdpbGwgdGhyb3dcclxuXHJcblx0XHQvLyByZXBsYWNlIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuXHJcblx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgYmVhdXRpZmluZyBhbGwgb3IgbGVhZGluZy90cmFpbGluZyBoeXBoZW4gdG8gdW5pY29kZSB2YXJpYW50XHJcblx0XHQvLyBub3QgZXhhY3RseSB0aGUgc2FtZSBpbiBldmVyeSBmb250LCBidXQgdmVyeSBzaW1pbGFyOiBcIi1cIiB2cyBcIuKAkFwiXHJcblx0XHQvKlxyXG5cdFx0Y29uc3QgVU5JQ09ERV9IWVBIRU4gPSAweDIwMTA7XHJcblx0XHQvLyBtYXliZSB0aGlzIHNob3VsZCByZXBsYWNlIGFsbCBmb3IgdmlzdWFsIGNvbnNpc3RhbmN5P1xyXG5cdFx0Ly8gYG5vZGUgdG9vbHMvcmVnLWNvdW50LmpzIHJlZ2V4IF4tXFx7MixcXH1gID0+IDU5MlxyXG5cdFx0Ly9mb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykgaWYgKG91dHB1dFtpXSA9PSAweDJEKSBvdXRwdXRbaV0gPSAweDIwMTA7XHJcblx0XHRpZiAob3V0cHV0WzBdID09IEhZUEhFTikgb3V0cHV0WzBdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHRsZXQgZW5kID0gb3V0cHV0Lmxlbmd0aC0xO1xyXG5cdFx0aWYgKG91dHB1dFtlbmRdID09IEhZUEhFTikgb3V0cHV0W2VuZF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdCovXHJcblx0XHQvLyAyMDIzMDEyMzogV0hBVFdHIFVSTCB1c2VzIFwiQ2hlY2tIeXBoZW5zXCIgZmFsc2VcclxuXHRcdC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaWRuYVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBldGhlcmV1bSBzeW1ib2xcclxuXHRcdC8vIM6+ID0+IM6eIGlmIG5vdCBncmVla1xyXG5cdFx0aWYgKHR5cGUgIT09ICdHcmVlaycpIGFycmF5X3JlcGxhY2Uob3V0cHV0LCAweDNCRSwgMHgzOUUpO1xyXG5cclxuXHRcdC8vIDIwMjIxMjEzOiBmaXhlcyBiaWRpIHN1YmRvbWFpbiBpc3N1ZSwgYnV0IGJyZWFrcyBpbnZhcmlhbnQgKDIwMEUgaXMgZGlzYWxsb3dlZClcclxuXHRcdC8vIGNvdWxkIGJlIGZpeGVkIHdpdGggc3BlY2lhbCBjYXNlIGZvcjogMkQgKC4pICsgMjAwRSAoTFRSKVxyXG5cdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvYmlkaS1sYWJlbC1vcmRlcmluZy1zcG9vZi8xNTgyNFxyXG5cdFx0Ly9vdXRwdXQuc3BsaWNlKDAsIDAsIDB4MjAwRSk7XHJcblx0fVxyXG5cdHJldHVybiBmbGF0dGVuKGxhYmVscyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFycmF5X3JlcGxhY2UodiwgYSwgYikge1xyXG5cdGxldCBwcmV2ID0gMDtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IG5leHQgPSB2LmluZGV4T2YoYSwgcHJldik7XHJcblx0XHRpZiAobmV4dCA8IDApIGJyZWFrO1xyXG5cdFx0dltuZXh0XSA9IGI7IFxyXG5cdFx0cHJldiA9IG5leHQgKyAxO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX3NwbGl0KG5hbWUsIHByZXNlcnZlX2Vtb2ppKSB7XHJcblx0cmV0dXJuIHNwbGl0KG5hbWUsIG5mYywgcHJlc2VydmVfZW1vamkgPyB4ID0+IHguc2xpY2UoKSA6IGZpbHRlcl9mZTBmKTsgLy8gZW1vamkgYXJlIGV4cG9zZWQgc28gY29weVxyXG59XHJcblxyXG5mdW5jdGlvbiBzcGxpdChuYW1lLCBuZiwgZWYpIHtcclxuXHRpZiAoIW5hbWUpIHJldHVybiBbXTsgLy8gMjAyMzA3MTk6IGVtcHR5IG5hbWUgYWxsb3dhbmNlXHJcblx0aW5pdCgpO1xyXG5cdGxldCBvZmZzZXQgPSAwO1xyXG5cdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdC8vIDQuKSBcIlRoZSBsYWJlbCBtdXN0IG5vdCBjb250YWluIGEgVSswMDJFICggLiApIEZVTEwgU1RPUC5cIlxyXG5cdHJldHVybiBuYW1lLnNwbGl0KFNUT1BfQ0gpLm1hcChsYWJlbCA9PiB7XHJcblx0XHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKGxhYmVsKTtcclxuXHRcdGxldCBpbmZvID0ge1xyXG5cdFx0XHRpbnB1dCxcclxuXHRcdFx0b2Zmc2V0LCAvLyBjb2RlcG9pbnQsIG5vdCBzdWJzdHJpbmchXHJcblx0XHR9O1xyXG5cdFx0b2Zmc2V0ICs9IGlucHV0Lmxlbmd0aCArIDE7IC8vICsgc3RvcFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gMS4pIFwiVGhlIGxhYmVsIG11c3QgYmUgaW4gVW5pY29kZSBOb3JtYWxpemF0aW9uIEZvcm0gTkZDXCJcclxuXHRcdFx0bGV0IHRva2VucyA9IGluZm8udG9rZW5zID0gdG9rZW5zX2Zyb21fc3RyKGlucHV0LCBuZiwgZWYpO1xyXG5cdFx0XHRsZXQgdG9rZW5fY291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG5cdFx0XHRsZXQgdHlwZTtcclxuXHRcdFx0aWYgKCF0b2tlbl9jb3VudCkgeyAvLyB0aGUgbGFiZWwgd2FzIGVmZmVjdGl2ZWx5IGVtcHR5IChjb3VsZCBvZiBoYWQgaWdub3JlZCBjaGFyYWN0ZXJzKVxyXG5cdFx0XHRcdC8vbm9ybSA9IFtdO1xyXG5cdFx0XHRcdC8vdHlwZSA9ICdOb25lJzsgLy8gdXNlIHRoaXMgaW5zdGVhZCBvZiBuZXh0IG1hdGNoLCBcIkFTQ0lJXCJcclxuXHRcdFx0XHQvLyAyMDIzMDEyMDogY2hhbmdlIHRvIHN0cmljdFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZGlzY3Vzcy5lbnMuZG9tYWlucy90L2Vucy1uYW1lLW5vcm1hbGl6YXRpb24tMm5kLzE0NTY0LzU5XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBlbXB0eSBsYWJlbGApO1xyXG5cdFx0XHR9IFxyXG5cdFx0XHRsZXQgbm9ybSA9IGluZm8ub3V0cHV0ID0gdG9rZW5zLmZsYXQoKTtcclxuXHRcdFx0Y2hlY2tfbGVhZGluZ191bmRlcnNjb3JlKG5vcm0pO1xyXG5cdFx0XHRsZXQgZW1vamkgPSBpbmZvLmVtb2ppID0gdG9rZW5fY291bnQgPiAxIHx8IHRva2Vuc1swXS5pc19lbW9qaTsgLy8gc2FtZSBhczogdG9rZW5zLnNvbWUoeCA9PiB4LmlzX2Vtb2ppKTtcclxuXHRcdFx0aWYgKCFlbW9qaSAmJiBub3JtLmV2ZXJ5KGNwID0+IGNwIDwgMHg4MCkpIHsgLy8gc3BlY2lhbCBjYXNlIGZvciBhc2NpaVxyXG5cdFx0XHRcdC8vIDIwMjMwMTIzOiBtYXRjaGVzIG1hdGNoZXMgV0hBVFdHLCBzZWUgbm90ZSAzLjNcclxuXHRcdFx0XHRjaGVja19sYWJlbF9leHRlbnNpb24obm9ybSk7IC8vIG9ubHkgbmVlZGVkIGZvciBhc2NpaVxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSBmZW5jZWRcclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgY21cclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgd2hvbGVzXHJcblx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJGYXN0cGF0aCBBU0NJSVwiXHJcblx0XHRcdFx0dHlwZSA9ICdBU0NJSSc7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNoYXJzID0gdG9rZW5zLmZsYXRNYXAoeCA9PiB4LmlzX2Vtb2ppID8gW10gOiB4KTsgLy8gYWxsIG9mIHRoZSBuZmMgdG9rZW5zIGNvbmNhdCB0b2dldGhlclxyXG5cdFx0XHRcdGlmICghY2hhcnMubGVuZ3RoKSB7IC8vIHRoZXJlcyBubyB0ZXh0LCBqdXN0IGVtb2ppXHJcblx0XHRcdFx0XHR0eXBlID0gJ0Vtb2ppJztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gNS4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGJlZ2luIHdpdGggYSBjb21iaW5pbmcgbWFyaywgdGhhdCBpczogR2VuZXJhbF9DYXRlZ29yeT1NYXJrLlwiXHJcblx0XHRcdFx0XHRpZiAoQ00uaGFzKG5vcm1bMF0pKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoJ2xlYWRpbmcgY29tYmluaW5nIG1hcmsnKTtcclxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgdG9rZW5fY291bnQ7IGkrKykgeyAvLyB3ZSd2ZSBhbHJlYWR5IGNoZWNrZWQgdGhlIGZpcnN0IHRva2VuXHJcblx0XHRcdFx0XHRcdGxldCBjcHMgPSB0b2tlbnNbaV07XHJcblx0XHRcdFx0XHRcdGlmICghY3BzLmlzX2Vtb2ppICYmIENNLmhhcyhjcHNbMF0pKSB7IC8vIGV2ZXJ5IHRleHQgdG9rZW4gaGFzIGVtb2ppIG5laWdoYm9ycywgZWcuIEV0RUVFdEV0Li4uXHJcblx0XHRcdFx0XHRcdFx0Ly8gYmlkaV9xcSgpIG5vdCBuZWVkZWQgc2luY2UgZW1vamkgaXMgTFRSIGFuZCBjcHMgaXMgYSBDTVxyXG5cdFx0XHRcdFx0XHRcdHRocm93IGVycm9yX3BsYWNlbWVudChgZW1vamkgKyBjb21iaW5pbmcgbWFyazogXCIke3N0cl9mcm9tX2Nwcyh0b2tlbnNbaS0xXSl9ICsgJHtzYWZlX3N0cl9mcm9tX2NwcyhbY3BzWzBdXSl9XCJgKTsgXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNoZWNrX2ZlbmNlZChub3JtKTtcclxuXHRcdFx0XHRcdGxldCB1bmlxdWUgPSBBcnJheV9mcm9tKG5ldyBTZXQoY2hhcnMpKTtcclxuXHRcdFx0XHRcdGxldCBbZ10gPSBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKTsgLy8gdGFrZSB0aGUgZmlyc3QgbWF0Y2hcclxuXHRcdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiTWF0Y2hpbmcgR3JvdXBzIGhhdmUgU2FtZSBDTSBTdHlsZVwiXHJcblx0XHRcdFx0XHQvLyBhbHRlcm5hdGl2ZTogY291bGQgZm9ybSBhIGh5YnJpZCB0eXBlOiBMYXRpbi9KYXBhbmVzZS8uLi5cdFxyXG5cdFx0XHRcdFx0Y2hlY2tfZ3JvdXAoZywgY2hhcnMpOyAvLyBuZWVkIHRleHQgaW4gb3JkZXJcclxuXHRcdFx0XHRcdGNoZWNrX3dob2xlKGcsIHVuaXF1ZSk7IC8vIG9ubHkgbmVlZCB1bmlxdWUgdGV4dCAob3JkZXIgd291bGQgYmUgcmVxdWlyZWQgZm9yIG11bHRpcGxlLWNoYXIgY29uZnVzYWJsZXMpXHJcblx0XHRcdFx0XHR0eXBlID0gZy5OO1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGV4cG9zaW5nIHJlc3RyaWN0ZWQgZmxhZ1xyXG5cdFx0XHRcdFx0Ly8gaXQncyBzaW1wbGVyIHRvIGp1c3QgY2hlY2sgZm9yICdSZXN0cmljdGVkJ1xyXG5cdFx0XHRcdFx0Ly8gb3IgZXZlbiBiZXR0ZXI6IHR5cGUuZW5kc1dpdGgoJ10nKVxyXG5cdFx0XHRcdFx0Ly9pZiAoZy5SKSBpbmZvLnJlc3RyaWN0ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpbmZvLnR5cGUgPSB0eXBlO1xyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdGluZm8uZXJyb3IgPSBlcnI7IC8vIHVzZSBmdWxsIGVycm9yIG9iamVjdFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGluZm87XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX3dob2xlKGdyb3VwLCB1bmlxdWUpIHtcclxuXHRsZXQgbWFrZXI7XHJcblx0bGV0IHNoYXJlZCA9IFtdO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0bGV0IHdob2xlID0gV0hPTEVfTUFQLmdldChjcCk7XHJcblx0XHRpZiAod2hvbGUgPT09IFVOSVFVRV9QSCkgcmV0dXJuOyAvLyB1bmlxdWUsIG5vbi1jb25mdXNhYmxlXHJcblx0XHRpZiAod2hvbGUpIHtcclxuXHRcdFx0bGV0IHNldCA9IHdob2xlLk0uZ2V0KGNwKTsgLy8gZ3JvdXBzIHdoaWNoIGhhdmUgYSBjaGFyYWN0ZXIgdGhhdCBsb29rLWxpa2UgdGhpcyBjaGFyYWN0ZXJcclxuXHRcdFx0bWFrZXIgPSBtYWtlciA/IG1ha2VyLmZpbHRlcihnID0+IHNldC5oYXMoZykpIDogQXJyYXlfZnJvbShzZXQpO1xyXG5cdFx0XHRpZiAoIW1ha2VyLmxlbmd0aCkgcmV0dXJuOyAvLyBjb25mdXNhYmxlIGludGVyc2VjdGlvbiBpcyBlbXB0eVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c2hhcmVkLnB1c2goY3ApOyBcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKG1ha2VyKSB7XHJcblx0XHQvLyB3ZSBoYXZlIDErIGNvbmZ1c2FibGVcclxuXHRcdC8vIGNoZWNrIGlmIGFueSBvZiB0aGUgcmVtYWluaW5nIGdyb3Vwc1xyXG5cdFx0Ly8gY29udGFpbiB0aGUgc2hhcmVkIGNoYXJhY3RlcnMgdG9vXHJcblx0XHRmb3IgKGxldCBnIG9mIG1ha2VyKSB7XHJcblx0XHRcdGlmIChzaGFyZWQuZXZlcnkoY3AgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSkpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHdob2xlLXNjcmlwdCBjb25mdXNhYmxlOiAke2dyb3VwLk59LyR7Zy5OfWApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiB1bmlxdWUuc2l6ZSA+IDBcclxuLy8gcmV0dXJucyBsaXN0IG9mIG1hdGNoaW5nIGdyb3Vwc1xyXG5mdW5jdGlvbiBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKSB7XHJcblx0bGV0IGdyb3VwcyA9IEdST1VQUztcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdC8vIG5vdGU6IHdlIG5lZWQgdG8gZG9kZ2UgQ00gdGhhdCBhcmUgd2hpdGVsaXN0ZWRcclxuXHRcdC8vIGJ1dCB0aGF0IGNvZGUgaXNuJ3QgY3VycmVudGx5IG5lY2Vzc2FyeVxyXG5cdFx0bGV0IGdzID0gZ3JvdXBzLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0aWYgKCFncy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKCFHUk9VUFMuc29tZShnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpKSB7IFxyXG5cdFx0XHRcdC8vIHRoZSBjaGFyYWN0ZXIgd2FzIGNvbXBvc2VkIG9mIHZhbGlkIHBhcnRzXHJcblx0XHRcdFx0Ly8gYnV0IGl0J3MgTkZDIGZvcm0gaXMgaW52YWxpZFxyXG5cdFx0XHRcdC8vIDIwMjMwNzE2OiBjaGFuZ2UgdG8gbW9yZSBleGFjdCBzdGF0ZW1lbnQsIHNlZTogRU5TTm9ybWFsaXplLntjcyxqYXZhfVxyXG5cdFx0XHRcdC8vIG5vdGU6IHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlIGEgY29tcG9zaXRpb25cclxuXHRcdFx0XHQvLyAyMDIzMDcyMDogY2hhbmdlIHRvIGZ1bGwgY2hlY2tcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTsgLy8gdGhpcyBzaG91bGQgYmUgcmFyZVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIHRoZXJlIGlzIG5vIGdyb3VwIHRoYXQgY29udGFpbnMgYWxsIHRoZXNlIGNoYXJhY3RlcnNcclxuXHRcdFx0XHQvLyB0aHJvdyB1c2luZyB0aGUgaGlnaGVzdCBwcmlvcml0eSBncm91cCB0aGF0IG1hdGNoZWRcclxuXHRcdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRcdHRocm93IGVycm9yX2dyb3VwX21lbWJlcihncm91cHNbMF0sIGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Z3JvdXBzID0gZ3M7XHJcblx0XHRpZiAoZ3MubGVuZ3RoID09IDEpIGJyZWFrOyAvLyB0aGVyZSBpcyBvbmx5IG9uZSBncm91cCBsZWZ0XHJcblx0fVxyXG5cdC8vIHRoZXJlIGFyZSBhdCBsZWFzdCAxIGdyb3VwKHMpIHdpdGggYWxsIG9mIHRoZXNlIGNoYXJhY3RlcnNcclxuXHRyZXR1cm4gZ3JvdXBzO1xyXG59XHJcblxyXG4vLyB0aHJvdyBvbiBmaXJzdCBlcnJvclxyXG5mdW5jdGlvbiBmbGF0dGVuKHNwbGl0KSB7XHJcblx0cmV0dXJuIHNwbGl0Lm1hcCgoe2lucHV0LCBlcnJvciwgb3V0cHV0fSkgPT4ge1xyXG5cdFx0aWYgKGVycm9yKSB7XHJcblx0XHRcdC8vIGRvbid0IHByaW50IGxhYmVsIGFnYWluIGlmIGp1c3QgYSBzaW5nbGUgbGFiZWxcclxuXHRcdFx0bGV0IG1zZyA9IGVycm9yLm1lc3NhZ2U7XHJcblx0XHRcdC8vIGJpZGlfcXEoKSBvbmx5IG5lY2Vzc2FyeSBpZiBtc2cgaXMgZGlnaXRzXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihzcGxpdC5sZW5ndGggPT0gMSA/IG1zZyA6IGBJbnZhbGlkIGxhYmVsICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhpbnB1dCwgNjMpKX06ICR7bXNnfWApOyBcclxuXHRcdH1cclxuXHRcdHJldHVybiBzdHJfZnJvbV9jcHMob3V0cHV0KTtcclxuXHR9KS5qb2luKFNUT1BfQ0gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlcnJvcl9kaXNhbGxvd2VkKGNwKSB7XHJcblx0Ly8gVE9ETzogYWRkIGNwIHRvIGVycm9yP1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgY2hhcmFjdGVyOiAke3F1b3RlZF9jcChjcCl9YCk7IFxyXG59XHJcbmZ1bmN0aW9uIGVycm9yX2dyb3VwX21lbWJlcihnLCBjcCkge1xyXG5cdGxldCBxdW90ZWQgPSBxdW90ZWRfY3AoY3ApO1xyXG5cdGxldCBnZyA9IEdST1VQUy5maW5kKGcgPT4gZy5QLmhhcyhjcCkpOyAvLyBvbmx5IGNoZWNrIHByaW1hcnlcclxuXHRpZiAoZ2cpIHtcclxuXHRcdHF1b3RlZCA9IGAke2dnLk59ICR7cXVvdGVkfWA7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgbWl4dHVyZTogJHtnLk59ICsgJHtxdW90ZWR9YCk7XHJcbn1cclxuZnVuY3Rpb24gZXJyb3JfcGxhY2VtZW50KHdoZXJlKSB7XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgaWxsZWdhbCBwbGFjZW1lbnQ6ICR7d2hlcmV9YCk7XHJcbn1cclxuXHJcbi8vIGFzc3VtcHRpb246IGNwcy5sZW5ndGggPiAwXHJcbi8vIGFzc3VtcHRpb246IGNwc1swXSBpc24ndCBhIENNXHJcbi8vIGFzc3VtcHRpb246IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXNuJ3QgYW4gZW1vamlcclxuZnVuY3Rpb24gY2hlY2tfZ3JvdXAoZywgY3BzKSB7XHJcblx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRpZiAoIWdyb3VwX2hhc19jcChnLCBjcCkpIHtcclxuXHRcdFx0Ly8gZm9yIHdoaXRlbGlzdGVkIHNjcmlwdHMsIHRoaXMgd2lsbCB0aHJvdyBpbGxlZ2FsIG1peHR1cmUgb24gaW52YWxpZCBjbSwgZWcuIFwiZXszMDB9ezMwMH1cIlxyXG5cdFx0XHQvLyBhdCB0aGUgbW9tZW50LCBpdCdzIHVubmVjZXNzYXJ5IHRvIGludHJvZHVjZSBhbiBleHRyYSBlcnJvciB0eXBlXHJcblx0XHRcdC8vIHVudGlsIHRoZXJlIGV4aXN0cyBhIHdoaXRlbGlzdGVkIG11bHRpLWNoYXJhY3RlclxyXG5cdFx0XHQvLyAgIGVnLiBpZiAoTSA8IDAgJiYgaXNfY29tYmluaW5nX21hcmsoY3ApKSB7IC4uLiB9XHJcblx0XHRcdC8vIHRoZXJlIGFyZSAzIGNhc2VzOlxyXG5cdFx0XHQvLyAgIDEuIGlsbGVnYWwgY20gZm9yIHdyb25nIGdyb3VwID0+IG1peHR1cmUgZXJyb3JcclxuXHRcdFx0Ly8gICAyLiBpbGxlZ2FsIGNtIGZvciBzYW1lIGdyb3VwID0+IGNtIGVycm9yXHJcblx0XHRcdC8vICAgICAgIHJlcXVpcmVzIHNldCBvZiB3aGl0ZWxpc3QgY20gcGVyIGdyb3VwOiBcclxuXHRcdFx0Ly8gICAgICAgIGVnLiBuZXcgU2V0KFsuLi5nLlAsIC4uLmcuUV0uZmxhdE1hcChuZmMpLmZpbHRlcihjcCA9PiBDTS5oYXMoY3ApKSlcclxuXHRcdFx0Ly8gICAzLiB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdHRocm93IGVycm9yX2dyb3VwX21lbWJlcihnLCBjcCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vaWYgKE0gPj0gMCkgeyAvLyB3ZSBoYXZlIGEga25vd24gZml4ZWQgY20gY291bnRcclxuXHRpZiAoZy5NKSB7IC8vIHdlIG5lZWQgdG8gY2hlY2sgZm9yIE5TTVxyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gc2VlOiBhc3N1bXB0aW9uXHJcblx0XHRcdC8vIDIwMjMwMjEwOiBidWdmaXg6IHVzaW5nIGNwcyBpbnN0ZWFkIG9mIGRlY29tcG9zZWQgaC90IENhcmJvbjIyNVxyXG5cdFx0XHQvKlxyXG5cdFx0XHRpZiAoQ00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGRlY29tcG9zZWRbal0pKSBqKys7XHJcblx0XHRcdFx0aWYgKGogLSBpID4gTSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB0b28gbWFueSBjb21iaW5pbmcgbWFya3M6ICR7Zy5OfSAke2JpZGlfcXEoc3RyX2Zyb21fY3BzKGRlY29tcG9zZWQuc2xpY2UoaS0xLCBqKSkpfSAoJHtqLWl9LyR7TX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHRcdCovXHJcblx0XHRcdC8vIDIwMjMwMjE3OiBzd2l0Y2ggdG8gTlNNIGNvdW50aW5nXHJcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jT3B0aW9uYWxfRGV0ZWN0aW9uXHJcblx0XHRcdGlmIChOU00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHRmb3IgKGxldCBjcDsgaiA8IGUgJiYgTlNNLmhhcyhjcCA9IGRlY29tcG9zZWRbal0pOyBqKyspIHtcclxuXHRcdFx0XHRcdC8vIGEuIEZvcmJpZCBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbm9uc3BhY2luZyBtYXJrLlxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgayA9IGk7IGsgPCBqOyBrKyspIHsgLy8gTyhuXjIpIGJ1dCBuIDwgMTAwXHJcblx0XHRcdFx0XHRcdGlmIChkZWNvbXBvc2VkW2tdID09IGNwKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGUgbm9uLXNwYWNpbmcgbWFya3M6ICR7cXVvdGVkX2NwKGNwKX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBwYXJzZSB0byBlbmQgc28gd2UgaGF2ZSBmdWxsIG5zbSBjb3VudFxyXG5cdFx0XHRcdC8vIGIuIEZvcmJpZCBzZXF1ZW5jZXMgb2YgbW9yZSB0aGFuIDQgbm9uc3BhY2luZyBtYXJrcyAoZ2M9TW4gb3IgZ2M9TWUpLlxyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE5TTV9NQVgpIHtcclxuXHRcdFx0XHRcdC8vIG5vdGU6IHRoaXMgc2xpY2Ugc3RhcnRzIHdpdGggYSBiYXNlIGNoYXIgb3Igc3BhY2luZy1tYXJrIGNtXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGV4Y2Vzc2l2ZSBub24tc3BhY2luZyBtYXJrczogJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKGRlY29tcG9zZWQuc2xpY2UoaS0xLCBqKSkpfSAoJHtqLWl9LyR7TlNNX01BWH0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vICoqKiB0aGlzIGNvZGUgY3VycmVudGx5IGlzbid0IG5lZWRlZCAqKipcclxuXHQvKlxyXG5cdGxldCBjbV93aGl0ZWxpc3QgPSBNIGluc3RhbmNlb2YgTWFwO1xyXG5cdGZvciAobGV0IGkgPSAwLCBlID0gY3BzLmxlbmd0aDsgaSA8IGU7ICkge1xyXG5cdFx0bGV0IGNwID0gY3BzW2krK107XHJcblx0XHRsZXQgc2VxcyA9IGNtX3doaXRlbGlzdCAmJiBNLmdldChjcCk7XHJcblx0XHRpZiAoc2VxcykgeyBcclxuXHRcdFx0Ly8gbGlzdCBvZiBjb2RlcG9pbnRzIHRoYXQgY2FuIGZvbGxvd1xyXG5cdFx0XHQvLyBpZiB0aGlzIGV4aXN0cywgdGhpcyB3aWxsIGFsd2F5cyBiZSAxK1xyXG5cdFx0XHRsZXQgaiA9IGk7XHJcblx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoY3BzW2pdKSkgaisrO1xyXG5cdFx0XHRsZXQgY21zID0gY3BzLnNsaWNlKGksIGopO1xyXG5cdFx0XHRsZXQgbWF0Y2ggPSBzZXFzLmZpbmQoc2VxID0+ICFjb21wYXJlX2FycmF5cyhzZXEsIGNtcykpO1xyXG5cdFx0XHRpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgY29tYmluaW5nIG1hcmsgc2VxdWVuY2U6IFwiJHtzYWZlX3N0cl9mcm9tX2NwcyhbY3AsIC4uLmNtc10pfVwiYCk7XHJcblx0XHRcdGkgPSBqO1xyXG5cdFx0fSBlbHNlIGlmICghVi5oYXMoY3ApKSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jbWl4ZWRfc2NyaXB0X2NvbmZ1c2FibGVzXHJcblx0XHRcdGxldCBxdW90ZWQgPSBxdW90ZWRfY3AoY3ApO1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0XHRsZXQgdSA9IFVOSVFVRS5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmICh1ICYmIHUgIT09IGcpIHtcclxuXHRcdFx0XHRcdC8vIGlmIGJvdGggc2NyaXB0cyBhcmUgcmVzdHJpY3RlZCB0aGlzIGVycm9yIGlzIGNvbmZ1c2luZ1xyXG5cdFx0XHRcdFx0Ly8gYmVjYXVzZSB3ZSBkb24ndCBkaWZmZXJlbnRpYXRlIFJlc3RyaWN0ZWRBIGZyb20gUmVzdHJpY3RlZEIgXHJcblx0XHRcdFx0XHRpZiAoIXUuUikgcXVvdGVkID0gYCR7cXVvdGVkfSBpcyAke3UuTn1gO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCAke2cuTn0gY2hhcmFjdGVyOiAke3F1b3RlZH1gKTtcclxuXHRcdFx0Ly90aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgY2hhcmFjdGVyOiAke3F1b3RlZH0gKGV4cGVjdGVkICR7Zy5OfSlgKTtcclxuXHRcdFx0Ly90aHJvdyBuZXcgRXJyb3IoYCR7Zy5OfSBkb2VzIG5vdCBhbGxvdzogJHtxdW90ZWR9YCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmICghY21fd2hpdGVsaXN0KSB7XHJcblx0XHRsZXQgZGVjb21wb3NlZCA9IG5mZChjcHMpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDEsIGUgPSBkZWNvbXBvc2VkLmxlbmd0aDsgaSA8IGU7IGkrKykgeyAvLyB3ZSBrbm93IGl0IGNhbid0IGJlIGNtIGxlYWRpbmdcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiBcIiR7c3RyX2Zyb21fY3BzKGRlY29tcG9zZWQuc2xpY2UoaS0xLCBqKSl9XCIgKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQqL1xyXG59XHJcblxyXG4vLyBnaXZlbiBhIGxpc3Qgb2YgY29kZXBvaW50c1xyXG4vLyByZXR1cm5zIGEgbGlzdCBvZiBsaXN0cywgd2hlcmUgZW1vamkgYXJlIGEgZnVsbHktcXVhbGlmaWVkIChhcyBBcnJheSBzdWJjbGFzcylcclxuLy8gZWcuIGV4cGxvZGVfY3AoXCJhYmPwn5KpZFwiKSA9PiBbWzYxLCA2MiwgNjNdLCBFbW9qaVsxRjRBOSwgRkUwRl0sIFs2NF1dXHJcbi8vIDIwMjMwODE4OiByZW5hbWUgZm9yICdwcm9jZXNzJyBuYW1lIGNvbGxpc2lvbiBoL3QgSmF2YXJvbWVcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9pc3N1ZXMvMjNcclxuZnVuY3Rpb24gdG9rZW5zX2Zyb21fc3RyKGlucHV0LCBuZiwgZWYpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IGNoYXJzID0gW107XHJcblx0aW5wdXQgPSBpbnB1dC5zbGljZSgpLnJldmVyc2UoKTsgLy8gZmxpcCBzbyB3ZSBjYW4gcG9wXHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCk7XHJcblx0XHRpZiAoZW1vamkpIHtcclxuXHRcdFx0aWYgKGNoYXJzLmxlbmd0aCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKG5mKGNoYXJzKSk7XHJcblx0XHRcdFx0Y2hhcnMgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXQucHVzaChlZihlbW9qaSkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNwID0gaW5wdXQucG9wKCk7XHJcblx0XHRcdGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0Y2hhcnMucHVzaChjcCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNwcyA9IE1BUFBFRC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChjcHMpIHtcclxuXHRcdFx0XHRcdGNoYXJzLnB1c2goLi4uY3BzKTsgLy8gbGVzcyB0aGFuIDEwIGVsZW1lbnRzXHJcblx0XHRcdFx0fSBlbHNlIGlmICghSUdOT1JFRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0XHQvLyAyMDIzMDkxMjogdW5pY29kZSAxNS4xIGNoYW5nZWQgdGhlIG9yZGVyIG9mIHByb2Nlc3Npbmcgc3VjaCB0aGF0XHJcblx0XHRcdFx0XHQvLyBkaXNhbGxvd2VkIHBhcnRzIGFyZSBvbmx5IHJlamVjdGVkIGFmdGVyIE5GQ1xyXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYvI1ZhbGlkaXR5X0NyaXRlcmlhXHJcblx0XHRcdFx0XHQvLyB0aGlzIGRvZXNuJ3QgaW1wYWN0IG5vcm1hbGl6YXRpb24gYXMgb2YgdG9kYXlcclxuXHRcdFx0XHRcdC8vIHRlY2huaWNhbGx5LCB0aGlzIGVycm9yIGNhbiBiZSByZW1vdmVkIGFzIHRoZSBncm91cCBsb2dpYyB3aWxsIGFwcGx5IHNpbWlsYXIgbG9naWNcclxuXHRcdFx0XHRcdC8vIGhvd2V2ZXIgdGhlIGVycm9yIHR5cGUgbWlnaHQgYmUgbGVzcyBjbGVhclxyXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3JfZGlzYWxsb3dlZChjcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdHJldC5wdXNoKG5mKGNoYXJzKSk7XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlcl9mZTBmKGNwcykge1xyXG5cdHJldHVybiBjcHMuZmlsdGVyKGNwID0+IGNwICE9IEZFMEYpO1xyXG59XHJcblxyXG4vLyBnaXZlbiBhcnJheSBvZiBjb2RlcG9pbnRzXHJcbi8vIHJldHVybnMgdGhlIGxvbmdlc3QgdmFsaWQgZW1vamkgc2VxdWVuY2UgKG9yIHVuZGVmaW5lZCBpZiBubyBtYXRjaClcclxuLy8gKk1VVEFURVMqIHRoZSBzdXBwbGllZCBhcnJheVxyXG4vLyBkaXNhbGxvd3MgaW50ZXJsZWF2ZWQgaWdub3JlZCBjaGFyYWN0ZXJzXHJcbi8vIGZpbGxzIChvcHRpb25hbCkgZWF0ZW4gYXJyYXkgd2l0aCBtYXRjaGVkIGNvZGVwb2ludHNcclxuZnVuY3Rpb24gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChjcHMsIGVhdGVuKSB7XHJcblx0bGV0IG5vZGUgPSBFTU9KSV9ST09UO1xyXG5cdGxldCBlbW9qaTtcclxuXHRsZXQgcG9zID0gY3BzLmxlbmd0aDtcclxuXHR3aGlsZSAocG9zKSB7XHJcblx0XHRub2RlID0gbm9kZS5nZXQoY3BzWy0tcG9zXSk7XHJcblx0XHRpZiAoIW5vZGUpIGJyZWFrO1xyXG5cdFx0bGV0IHtWfSA9IG5vZGU7XHJcblx0XHRpZiAoVikgeyAvLyB0aGlzIGlzIGEgdmFsaWQgZW1vamkgKHNvIGZhcilcclxuXHRcdFx0ZW1vamkgPSBWO1xyXG5cdFx0XHRpZiAoZWF0ZW4pIGVhdGVuLnB1c2goLi4uY3BzLnNsaWNlKHBvcykucmV2ZXJzZSgpKTsgLy8gKG9wdGlvbmFsKSBjb3B5IGlucHV0LCB1c2VkIGZvciBlbnNfdG9rZW5pemUoKVxyXG5cdFx0XHRjcHMubGVuZ3RoID0gcG9zOyAvLyB0cnVuY2F0ZVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZW1vamk7XHJcbn1cclxuXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyB0b2tlbml6ZXIgXHJcblxyXG5jb25zdCBUWV9WQUxJRCA9ICd2YWxpZCc7XHJcbmNvbnN0IFRZX01BUFBFRCA9ICdtYXBwZWQnO1xyXG5jb25zdCBUWV9JR05PUkVEID0gJ2lnbm9yZWQnO1xyXG5jb25zdCBUWV9ESVNBTExPV0VEID0gJ2Rpc2FsbG93ZWQnO1xyXG5jb25zdCBUWV9FTU9KSSA9ICdlbW9qaSc7XHJcbmNvbnN0IFRZX05GQyA9ICduZmMnO1xyXG5jb25zdCBUWV9TVE9QID0gJ3N0b3AnO1xyXG5cclxuZnVuY3Rpb24gZW5zX3Rva2VuaXplKG5hbWUsIHtcclxuXHRuZiA9IHRydWUsIC8vIGNvbGxhcHNlIHVubm9ybWFsaXplZCBydW5zIGludG8gYSBzaW5nbGUgdG9rZW5cclxufSA9IHt9KSB7XHJcblx0aW5pdCgpO1xyXG5cdGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobmFtZSkucmV2ZXJzZSgpO1xyXG5cdGxldCBlYXRlbiA9IFtdO1xyXG5cdGxldCB0b2tlbnMgPSBbXTtcclxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XHJcblx0XHRsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0LCBlYXRlbik7XHJcblx0XHRpZiAoZW1vamkpIHtcclxuXHRcdFx0dG9rZW5zLnB1c2goe1xyXG5cdFx0XHRcdHR5cGU6IFRZX0VNT0pJLFxyXG5cdFx0XHRcdGVtb2ppOiBlbW9qaS5zbGljZSgpLCAvLyBjb3B5IGVtb2ppXHJcblx0XHRcdFx0aW5wdXQ6IGVhdGVuLFxyXG5cdFx0XHRcdGNwczogZmlsdGVyX2ZlMGYoZW1vamkpXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRlYXRlbiA9IFtdOyAvLyByZXNldCBidWZmZXJcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoY3AgPT0gU1RPUCkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9TVE9QLCBjcH0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKFZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfVkFMSUQsIGNwczogW2NwXX0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKElHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9JR05PUkVELCBjcH0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfTUFQUEVELCBjcCwgY3BzOiBjcHMuc2xpY2UoKX0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfRElTQUxMT1dFRCwgY3B9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKG5mKSB7XHJcblx0XHRmb3IgKGxldCBpID0gMCwgc3RhcnQgPSAtMTsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgdG9rZW4gPSB0b2tlbnNbaV07XHJcblx0XHRcdGlmIChpc192YWxpZF9vcl9tYXBwZWQodG9rZW4udHlwZSkpIHtcclxuXHRcdFx0XHRpZiAocmVxdWlyZXNfY2hlY2sodG9rZW4uY3BzKSkgeyAvLyBub3JtYWxpemF0aW9uIG1pZ2h0IGJlIG5lZWRlZFxyXG5cdFx0XHRcdFx0bGV0IGVuZCA9IGkgKyAxO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgcG9zID0gZW5kOyBwb3MgPCB0b2tlbnMubGVuZ3RoOyBwb3MrKykgeyAvLyBmaW5kIGFkamFjZW50IHRleHRcclxuXHRcdFx0XHRcdFx0bGV0IHt0eXBlLCBjcHN9ID0gdG9rZW5zW3Bvc107XHJcblx0XHRcdFx0XHRcdGlmIChpc192YWxpZF9vcl9tYXBwZWQodHlwZSkpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIXJlcXVpcmVzX2NoZWNrKGNwcykpIGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGVuZCA9IHBvcyArIDE7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyB8fCB0eXBlICE9PSBUWV9ESVNBTExPV0VEKSB7IFxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoc3RhcnQgPCAwKSBzdGFydCA9IGk7XHJcblx0XHRcdFx0XHRsZXQgc2xpY2UgPSB0b2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCk7XHJcblx0XHRcdFx0XHRsZXQgY3BzMCA9IHNsaWNlLmZsYXRNYXAoeCA9PiBpc192YWxpZF9vcl9tYXBwZWQoeC50eXBlKSA/IHguY3BzIDogW10pOyAvLyBzdHJpcCBqdW5rIHRva2Vuc1xyXG5cdFx0XHRcdFx0bGV0IGNwcyA9IG5mYyhjcHMwKTtcclxuXHRcdFx0XHRcdGlmIChjb21wYXJlX2FycmF5cyhjcHMsIGNwczApKSB7IC8vIGJ1bmRsZSBpbnRvIGFuIG5mYyB0b2tlblxyXG5cdFx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCwge1xyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFRZX05GQywgXHJcblx0XHRcdFx0XHRcdFx0aW5wdXQ6IGNwczAsIC8vIHRoZXJlIGFyZSAzIHN0YXRlczogdG9rZW5zMCA9PShwcm9jZXNzKT0+IGlucHV0ID09KG5mYyk9PiB0b2tlbnMvY3BzXHJcblx0XHRcdFx0XHRcdFx0Y3BzLCBcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnMwOiBjb2xsYXBzZV92YWxpZF90b2tlbnMoc2xpY2UpLFxyXG5cdFx0XHRcdFx0XHRcdHRva2VuczogZW5zX3Rva2VuaXplKHN0cl9mcm9tX2NwcyhjcHMpLCB7bmY6IGZhbHNlfSlcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdGkgPSBzdGFydDtcclxuXHRcdFx0XHRcdH0gZWxzZSB7IFxyXG5cdFx0XHRcdFx0XHRpID0gZW5kIC0gMTsgLy8gc2tpcCB0byBlbmQgb2Ygc2xpY2VcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gaTsgLy8gcmVtZW1iZXIgbGFzdFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbi50eXBlICE9PSBUWV9JR05PUkVEKSB7IC8vIDIwMjIxMDI0OiBpcyB0aGlzIGNvcnJlY3Q/XHJcblx0XHRcdFx0c3RhcnQgPSAtMTsgLy8gcmVzZXRcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gY29sbGFwc2VfdmFsaWRfdG9rZW5zKHRva2Vucyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzX3ZhbGlkX29yX21hcHBlZCh0eXBlKSB7XHJcblx0cmV0dXJuIHR5cGUgPT0gVFlfVkFMSUQgfHwgdHlwZSA9PSBUWV9NQVBQRUQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcXVpcmVzX2NoZWNrKGNwcykge1xyXG5cdHJldHVybiBjcHMuc29tZShjcCA9PiBORkNfQ0hFQ0suaGFzKGNwKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpIHtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKHRva2Vuc1tpXS50eXBlID09IFRZX1ZBTElEKSB7XHJcblx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdHdoaWxlIChqIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbal0udHlwZSA9PSBUWV9WQUxJRCkgaisrO1xyXG5cdFx0XHR0b2tlbnMuc3BsaWNlKGksIGogLSBpLCB7dHlwZTogVFlfVkFMSUQsIGNwczogdG9rZW5zLnNsaWNlKGksIGopLmZsYXRNYXAoeCA9PiB4LmNwcyl9KTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHRva2VucztcclxufVxuXG5leHBvcnQgeyBlbnNfYmVhdXRpZnksIGVuc19lbW9qaSwgZW5zX25vcm1hbGl6ZSwgZW5zX25vcm1hbGl6ZV9mcmFnbWVudCwgZW5zX3NwbGl0LCBlbnNfdG9rZW5pemUsIGlzX2NvbWJpbmluZ19tYXJrLCBuZmMsIG5mZCwgc2FmZV9zdHJfZnJvbV9jcHMsIHNob3VsZF9lc2NhcGUgfTtcbiIsImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgaGV4bGlmeSwgYXNzZXJ0QXJndW1lbnQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBlbnNfbm9ybWFsaXplIH0gZnJvbSBcIkBhZHJhZmZ5L2Vucy1ub3JtYWxpemVcIjtcbmNvbnN0IFplcm9zID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuWmVyb3MuZmlsbCgwKTtcbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50KGNvbXApIHtcbiAgICBhc3NlcnRBcmd1bWVudChjb21wLmxlbmd0aCAhPT0gMCwgXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIiwgXCJjb21wXCIsIGNvbXApO1xuICAgIHJldHVybiBjb21wO1xufVxuZnVuY3Rpb24gZW5zTmFtZVNwbGl0KG5hbWUpIHtcbiAgICBjb25zdCBieXRlcyA9IHRvVXRmOEJ5dGVzKGVuc05vcm1hbGl6ZShuYW1lKSk7XG4gICAgY29uc3QgY29tcHMgPSBbXTtcbiAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBzO1xuICAgIH1cbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkID0gYnl0ZXNbaV07XG4gICAgICAgIC8vIEEgc2VwYXJhdG9yIChpLmUuIFwiLlwiKTsgY29weSB0aGlzIGNvbXBvbmVudFxuICAgICAgICBpZiAoZCA9PT0gMHgyZSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0LCBpKSkpO1xuICAgICAgICAgICAgbGFzdCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZXJlIHdhcyBhIHN0cmF5IHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lXG4gICAgYXNzZXJ0QXJndW1lbnQobGFzdCA8IGJ5dGVzLmxlbmd0aCwgXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCkpKTtcbiAgICByZXR1cm4gY29tcHM7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBFTlMgJSVuYW1lJSUgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc05vcm1hbGl6ZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBsYWJlbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5zX25vcm1hbGl6ZShuYW1lKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBFTlMgbmFtZSAoJHtlcnJvci5tZXNzYWdlfSlgLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJW5hbWUlJSBpcyBhIHZhbGlkIEVOUyBuYW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZE5hbWUobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoZW5zTmFtZVNwbGl0KG5hbWUpLmxlbmd0aCAhPT0gMCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgW1tsaW5rLW5hbWVoYXNoXV0gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBFTlMgbmFtZTsgbm90IGEgc3RyaW5nXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBhc3NlcnRBcmd1bWVudChuYW1lLmxlbmd0aCwgYGludmFsaWQgRU5TIG5hbWUgKGVtcHR5IGxhYmVsKWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgY29uc3QgY29tcHMgPSBlbnNOYW1lU3BsaXQobmFtZSk7XG4gICAgd2hpbGUgKGNvbXBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBrZWNjYWsyNTYoY29uY2F0KFtyZXN1bHQsIGtlY2NhazI1NigoY29tcHMucG9wKCkpKV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIEROUyBlbmNvZGVkICUlbmFtZSUlLlxuICpcbiAqICBUaGlzIGlzIHVzZWQgZm9yIHZhcmlvdXMgcGFydHMgb2YgRU5TIG5hbWUgcmVzb2x1dGlvbiwgc3VjaFxuICogIGFzIHRoZSB3aWxkY2FyZCByZXNvbHV0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG5zRW5jb2RlKG5hbWUsIF9tYXhMZW5ndGgpIHtcbiAgICBjb25zdCBsZW5ndGggPSAoX21heExlbmd0aCAhPSBudWxsKSA/IF9tYXhMZW5ndGggOiA2MztcbiAgICBhc3NlcnRBcmd1bWVudChsZW5ndGggPD0gMjU1LCBcIkROUyBlbmNvZGVkIGxhYmVsIGNhbm5vdCBleGNlZWQgMjU1XCIsIFwibGVuZ3RoXCIsIGxlbmd0aCk7XG4gICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KGVuc05hbWVTcGxpdChuYW1lKS5tYXAoKGNvbXApID0+IHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoY29tcC5sZW5ndGggPD0gbGVuZ3RoLCBgbGFiZWwgJHtKU09OLnN0cmluZ2lmeShuYW1lKX0gZXhjZWVkcyAke2xlbmd0aH0gYnl0ZXNgLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY29tcC5sZW5ndGggKyAxKTtcbiAgICAgICAgYnl0ZXMuc2V0KGNvbXAsIDEpO1xuICAgICAgICBieXRlc1swXSA9IGJ5dGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9KSkpICsgXCIwMFwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZWhhc2guanMubWFwIiwiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgTWVzc2FnZVByZWZpeCB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBDb21wdXRlcyB0aGUgW1tsaW5rLWVpcC0xOTFdXSBwZXJzb25hbC1zaWduIG1lc3NhZ2UgZGlnZXN0IHRvIHNpZ24uXG4gKlxuICogIFRoaXMgcHJlZml4ZXMgdGhlIG1lc3NhZ2Ugd2l0aCBbW01lc3NhZ2VQcmVmaXhdXSBhbmQgdGhlIGRlY2ltYWwgbGVuZ3RoXG4gKiAgb2YgJSVtZXNzYWdlJSUgYW5kIGNvbXB1dGVzIHRoZSBbW2tlY2NhazI1Nl1dIGRpZ2VzdC5cbiAqXG4gKiAgSWYgJSVtZXNzYWdlJSUgaXMgYSBzdHJpbmcsIGl0IGlzIGNvbnZlcnRlZCB0byBpdHMgVVRGLTggYnl0ZXNcbiAqICBmaXJzdC4gVG8gY29tcHV0ZSB0aGUgZGlnZXN0IG9mIGEgW1tEYXRhSGV4U3RyaW5nXV0sIGl0IG11c3QgYmUgY29udmVydGVkXG4gKiAgdG8gW2J5dGVzXShnZXRCeXRlcykuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgaGFzaE1lc3NhZ2UoXCJIZWxsbyBXb3JsZFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEhhc2hlcyB0aGUgU0lYICg2KSBzdHJpbmcgY2hhcmFjdGVycywgaS5lLlxuICogICAgLy8gWyBcIjBcIiwgXCJ4XCIsIFwiNFwiLCBcIjJcIiwgXCI0XCIsIFwiM1wiIF1cbiAqICAgIGhhc2hNZXNzYWdlKFwiMHg0MjQzXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSGFzaGVzIHRoZSBUV08gKDIpIGJ5dGVzIFsgMHg0MiwgMHg0MyBdLi4uXG4gKiAgICBoYXNoTWVzc2FnZShnZXRCeXRlcyhcIjB4NDI0M1wiKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyAuLi53aGljaCBpcyBlcXVhbCB0byB1c2luZyBkYXRhXG4gKiAgICBoYXNoTWVzc2FnZShuZXcgVWludDhBcnJheShbIDB4NDIsIDB4NDMgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0b1V0ZjhCeXRlcyhtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIGtlY2NhazI1Nihjb25jYXQoW1xuICAgICAgICB0b1V0ZjhCeXRlcyhNZXNzYWdlUHJlZml4KSxcbiAgICAgICAgdG9VdGY4Qnl0ZXMoU3RyaW5nKG1lc3NhZ2UubGVuZ3RoKSksXG4gICAgICAgIG1lc3NhZ2VcbiAgICBdKSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIGFkZHJlc3Mgb2YgdGhlIHByaXZhdGUga2V5IHRoYXQgcHJvZHVjZWRcbiAqICB0aGUgc2lnbmF0dXJlICUlc2lnJSUgZHVyaW5nIHNpZ25pbmcgZm9yICUlbWVzc2FnZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZShtZXNzYWdlLCBzaWcpIHtcbiAgICBjb25zdCBkaWdlc3QgPSBoYXNoTWVzc2FnZShtZXNzYWdlKTtcbiAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZS5qcy5tYXAiLCIvL2ltcG9ydCB7IFR5cGVkRGF0YURvbWFpbiwgVHlwZWREYXRhRmllbGQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJhYnN0cmFjdC1zaWduZXJcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXRCeXRlcywgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIG1hc2ssIHRvQmVIZXgsIHRvUXVhbnRpdHksIHRvVHdvcywgemVyb1BhZFZhbHVlLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi9pZC5qc1wiO1xuY29uc3QgcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbnBhZGRpbmcuZmlsbCgwKTtcbmNvbnN0IEJOX18xID0gQmlnSW50KC0xKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fTUFYX1VJTlQyNTYgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG47XG47XG5mdW5jdGlvbiBoZXhQYWRSaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUpO1xuICAgIGNvbnN0IHBhZE9mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIDMyO1xuICAgIGlmIChwYWRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbYnl0ZXMsIHBhZGRpbmcuc2xpY2UocGFkT2Zmc2V0KV0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG59XG5jb25zdCBoZXhUcnVlID0gdG9CZUhleChCTl8xLCAzMik7XG5jb25zdCBoZXhGYWxzZSA9IHRvQmVIZXgoQk5fMCwgMzIpO1xuY29uc3QgZG9tYWluRmllbGRUeXBlcyA9IHtcbiAgICBuYW1lOiBcInN0cmluZ1wiLFxuICAgIHZlcnNpb246IFwic3RyaW5nXCIsXG4gICAgY2hhaW5JZDogXCJ1aW50MjU2XCIsXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IFwiYWRkcmVzc1wiLFxuICAgIHNhbHQ6IFwiYnl0ZXMzMlwiXG59O1xuY29uc3QgZG9tYWluRmllbGROYW1lcyA9IFtcbiAgICBcIm5hbWVcIiwgXCJ2ZXJzaW9uXCIsIFwiY2hhaW5JZFwiLCBcInZlcmlmeWluZ0NvbnRyYWN0XCIsIFwic2FsdFwiXG5dO1xuZnVuY3Rpb24gY2hlY2tTdHJpbmcoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciAke0pTT04uc3RyaW5naWZ5KGtleSl9YCwgYGRvbWFpbi4ke2tleX1gLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuY29uc3QgZG9tYWluQ2hlY2tzID0ge1xuICAgIG5hbWU6IGNoZWNrU3RyaW5nKFwibmFtZVwiKSxcbiAgICB2ZXJzaW9uOiBjaGVja1N0cmluZyhcInZlcnNpb25cIiksXG4gICAgY2hhaW5JZDogZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwiZG9tYWluLmNoYWluSWRcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IDAsIFwiaW52YWxpZCBjaGFpbiBJRFwiLCBcImRvbWFpbi5jaGFpbklkXCIsIF92YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1F1YW50aXR5KHZhbHVlKTtcbiAgICB9LFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBkb21haW4gdmFsdWUgXCJ2ZXJpZnlpbmdDb250cmFjdFwiYCwgXCJkb21haW4udmVyaWZ5aW5nQ29udHJhY3RcIiwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2FsdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUsIFwiZG9tYWluLnNhbHRcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gMzIsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInNhbHRcImAsIFwiZG9tYWluLnNhbHRcIiwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGdldEJhc2VFbmNvZGVyKHR5cGUpIHtcbiAgICAvLyBpbnRYWCBhbmQgdWludFhYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14odT8paW50KFxcZCspJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJcIik7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHdpZHRoICUgOCA9PT0gMCAmJiB3aWR0aCAhPT0gMCAmJiB3aWR0aCA8PSAyNTYgJiYgbWF0Y2hbMl0gPT09IFN0cmluZyh3aWR0aCksIFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc1VwcGVyID0gbWFzayhCTl9NQVhfVUlOVDI1Niwgc2lnbmVkID8gKHdpZHRoIC0gMSkgOiB3aWR0aCk7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNMb3dlciA9IHNpZ25lZCA/ICgoYm91bmRzVXBwZXIgKyBCTl8xKSAqIEJOX18xKSA6IEJOXzA7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSBib3VuZHNMb3dlciAmJiB2YWx1ZSA8PSBib3VuZHNVcHBlciwgYHZhbHVlIG91dC1vZi1ib3VuZHMgZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9CZUhleChzaWduZWQgPyB0b1R3b3ModmFsdWUsIDI1NikgOiB2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBieXRlc1hYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL15ieXRlcyhcXGQrKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHdpZHRoICE9PSAwICYmIHdpZHRoIDw9IDMyICYmIG1hdGNoWzFdID09PSBTdHJpbmcod2lkdGgpLCBcImludmFsaWQgYnl0ZXMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gd2lkdGgsIGBpbnZhbGlkIGxlbmd0aCBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhQYWRSaWdodCh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZFZhbHVlKGdldEFkZHJlc3ModmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbmNvZGVUeXBlKG5hbWUsIGZpZWxkcykge1xuICAgIHJldHVybiBgJHtuYW1lfSgke2ZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiAodHlwZSArIFwiIFwiICsgbmFtZSkpLmpvaW4oXCIsXCIpfSlgO1xufVxuLy8gZm9vW11bM10gPT4geyBiYXNlOiBcImZvb1wiLCBpbmRleDogXCJbXVszXVwiLCBhcnJheToge1xuLy8gICAgIGJhc2U6IFwiZm9vXCIsIHByZWZpeDogXCJmb29bXVwiLCBjb3VudDogMyB9IH1cbmZ1bmN0aW9uIHNwbGl0QXJyYXkodHlwZSkge1xuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXihbXlxceDViXSopKChcXHg1YlxcZCpcXHg1ZCkqKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhc2U6IG1hdGNoWzFdLFxuICAgICAgICAgICAgaW5kZXg6IChtYXRjaFsyXSArIG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGFycmF5OiB7XG4gICAgICAgICAgICAgICAgYmFzZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgcHJlZml4OiAobWF0Y2hbMV0gKyBtYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgY291bnQ6IChtYXRjaFs1XSA/IHBhcnNlSW50KG1hdGNoWzVdKSA6IC0xKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgYmFzZTogdHlwZSB9O1xufVxuLyoqXG4gKiAgQSAqKlR5cGVkRGF0YUVuY29kZSoqIHByZXBhcmVzIGFuZCBlbmNvZGVzIFtbbGluay1laXAtNzEyXV0gcGF5bG9hZHNcbiAqICBmb3Igc2lnbmVkIHR5cGVkIGRhdGEuXG4gKlxuICogIFRoaXMgaXMgdXNlZnVsIGZvciB0aG9zZSB0aGF0IHdpc2ggdG8gY29tcHV0ZSB2YXJpb3VzIGNvbXBvbmVudHMgb2YgYVxuICogIHR5cGVkIGRhdGEgaGFzaCwgcHJpbWFyeSB0eXBlcywgb3Igc3ViLWNvbXBvbmVudHMsIGJ1dCBnZW5lcmFsbHkgdGhlXG4gKiAgaGlnaGVyIGxldmVsIFtbU2lnbmVyLXNpZ25UeXBlZERhdGFdXSBpcyBtb3JlIHVzZWZ1bC5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVkRGF0YUVuY29kZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJpbWFyeSB0eXBlIGZvciB0aGUgc3RydWN0dXJlZCBbW3R5cGVzXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBkZXJpdmVkIGF1dG9tYXRpY2FsbHkgZnJvbSB0aGUgW1t0eXBlc11dLCBzaW5jZSBub1xuICAgICAqICByZWN1cnNpb24gaXMgcG9zc2libGUsIG9uY2UgdGhlIERBRyBmb3IgdGhlIHR5cGVzIGlzIGNvbnN0dXJjdGVkXG4gICAgICogIGludGVybmFsbHksIHRoZSBwcmltYXJ5IHR5cGUgbXVzdCBiZSB0aGUgb25seSByZW1haW5pbmcgdHlwZSB3aXRoXG4gICAgICogIG5vIHBhcmVudCBub2Rlcy5cbiAgICAgKi9cbiAgICBwcmltYXJ5VHlwZTtcbiAgICAjdHlwZXM7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlcy5cbiAgICAgKi9cbiAgICBnZXQgdHlwZXMoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuI3R5cGVzKTtcbiAgICB9XG4gICAgI2Z1bGxUeXBlcztcbiAgICAjZW5jb2RlckNhY2hlO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipUeXBlZERhdGFFbmNvZGVyKiogZm9yICUldHlwZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHBlcmZvcm1zIGFsbCBuZWNlc3NhcnkgY2hlY2tpbmcgdGhhdCB0eXBlcyBhcmUgdmFsaWQgYW5kXG4gICAgICogIGRvIG5vdCB2aW9sYXRlIHRoZSBbW2xpbmstZWlwLTcxMl1dIHN0cnVjdHVyYWwgY29uc3RyYWludHMgYXNcbiAgICAgKiAgd2VsbCBhcyBjb21wdXRlcyB0aGUgW1twcmltYXJ5VHlwZV1dLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF90eXBlcykge1xuICAgICAgICB0aGlzLiNmdWxsVHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2VuY29kZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3QgdHlwZXMgdG8gdGhlaXIgZGlyZWN0IGNoaWxkIHN0cnVjdHNcbiAgICAgICAgY29uc3QgbGlua3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgc3RydWN0cyB0byBzdHJ1Y3RzIHdoaWNoIGNvbnRhaW4gdGhlbSBhcyBhIGNoaWxkXG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgYWxsIHN1YnR5cGVzIHdpdGhpbiBhIGdpdmVuIHN0cnVjdFxuICAgICAgICBjb25zdCBzdWJ0eXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoX3R5cGVzKS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICB0eXBlc1t0eXBlXSA9IF90eXBlc1t0eXBlXS5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBiYXNlIHR5cGUgKHVubGVzcyBuYW1lIGNvbmZsaWN0KVxuICAgICAgICAgICAgICAgIGxldCB7IGJhc2UsIGluZGV4IH0gPSBzcGxpdEFycmF5KHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlID09PSBcImludFwiICYmICFfdHlwZXNbXCJpbnRcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IFwiaW50MjU2XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYXNlID09PSBcInVpbnRcIiAmJiAhX3R5cGVzW1widWludFwiXSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gXCJ1aW50MjU2XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG5hbWUsIHR5cGU6IChiYXNlICsgKGluZGV4IHx8IFwiXCIpKSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsaW5rcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgICAgIHBhcmVudHMuc2V0KHR5cGUsIFtdKTtcbiAgICAgICAgICAgIHN1YnR5cGVzLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jdHlwZXMgPSBKU09OLnN0cmluZ2lmeSh0eXBlcyk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0eXBlcykge1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBmaWVsZCBoYXMgYSB1bmlxdWUgbmFtZVxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCF1bmlxdWVOYW1lcy5oYXMoZmllbGQubmFtZSksIGBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZSAke0pTT04uc3RyaW5naWZ5KGZpZWxkLm5hbWUpfSBpbiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBiYXNlIHR5cGUgKGRyb3AgYW55IGFycmF5IHNwZWNpZmllcnMpXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBzcGxpdEFycmF5KGZpZWxkLnR5cGUpLmJhc2U7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYmFzZVR5cGUgIT09IG5hbWUsIGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBhIGJhc2UgZW5jb2RpbmcgdHlwZT9cbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIoYmFzZVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChwYXJlbnRzLmhhcyhiYXNlVHlwZSksIGB1bmtub3duIHR5cGUgJHtKU09OLnN0cmluZ2lmeShiYXNlVHlwZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBsaW5rYWdlXG4gICAgICAgICAgICAgICAgcGFyZW50cy5nZXQoYmFzZVR5cGUpLnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgbGlua3MuZ2V0KG5hbWUpLmFkZChiYXNlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVkdWNlIHRoZSBwcmltYXJ5IHR5cGVcbiAgICAgICAgY29uc3QgcHJpbWFyeVR5cGVzID0gQXJyYXkuZnJvbShwYXJlbnRzLmtleXMoKSkuZmlsdGVyKChuKSA9PiAocGFyZW50cy5nZXQobikubGVuZ3RoID09PSAwKSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggIT09IDAsIFwibWlzc2luZyBwcmltYXJ5IHR5cGVcIiwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwcmltYXJ5VHlwZXMubGVuZ3RoID09PSAxLCBgYW1iaWd1b3VzIHByaW1hcnkgdHlwZXMgb3IgdW51c2VkIHR5cGVzOiAke3ByaW1hcnlUeXBlcy5tYXAoKHQpID0+IChKU09OLnN0cmluZ2lmeSh0KSkpLmpvaW4oXCIsIFwiKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwcmltYXJ5VHlwZTogcHJpbWFyeVR5cGVzWzBdIH0pO1xuICAgICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2VzXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQ2lyY3VsYXIodHlwZSwgZm91bmQpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFmb3VuZC5oYXModHlwZSksIGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KHR5cGUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgIGZvdW5kLmFkZCh0eXBlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgbGlua3MuZ2V0KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNoZWNrIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY2hlY2tDaXJjdWxhcihjaGlsZCwgZm91bmQpO1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgYWxsIGFuY2VzdG9ycyBhcyBoYXZpbmcgdGhpcyBkZWNlbmRhbnRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YnR5cGUgb2YgZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZXMuZ2V0KHN1YnR5cGUpLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ2lyY3VsYXIodGhpcy5wcmltYXJ5VHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgLy8gQ29tcHV0ZSBlYWNoIGZ1bGx5IGRlc2NyaWJlIHR5cGVcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgc2V0XSBvZiBzdWJ0eXBlcykge1xuICAgICAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5mcm9tKHNldCk7XG4gICAgICAgICAgICBzdC5zb3J0KCk7XG4gICAgICAgICAgICB0aGlzLiNmdWxsVHlwZXMuc2V0KG5hbWUsIGVuY29kZVR5cGUobmFtZSwgdHlwZXNbbmFtZV0pICsgc3QubWFwKCh0KSA9PiBlbmNvZGVUeXBlKHQsIHR5cGVzW3RdKSkuam9pbihcIlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnRoZSBlbmNvZGVyIGZvciB0aGUgc3BlY2lmaWMgJSV0eXBlJSUuXG4gICAgICovXG4gICAgZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIGxldCBlbmNvZGVyID0gdGhpcy4jZW5jb2RlckNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFlbmNvZGVyKSB7XG4gICAgICAgICAgICBlbmNvZGVyID0gdGhpcy4jZ2V0RW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuI2VuY29kZXJDYWNoZS5zZXQodHlwZSwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgfVxuICAgICNnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgYXJyYXkgPSBzcGxpdEFycmF5KHR5cGUpLmFycmF5O1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnR5cGUgPSBhcnJheS5wcmVmaXg7XG4gICAgICAgICAgICBjb25zdCBzdWJFbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFycmF5LmNvdW50ID09PSAtMSB8fCBhcnJheS5jb3VudCA9PT0gdmFsdWUubGVuZ3RoLCBgYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHthcnJheS5jb3VudH1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWUubWFwKHN1YkVuY29kZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNmdWxsVHlwZXMuaGFzKHN1YnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoa2VjY2FrMjU2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nihjb25jYXQocmVzdWx0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVHlwZSA9IGlkKHRoaXMuI2Z1bGxUeXBlcy5nZXQodHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNmdWxsVHlwZXMuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMudW5zaGlmdChlbmNvZGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbCB0eXBlIGZvciAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVsbFR5cGVzLmdldChuYW1lKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LCBgdW5rbm93biB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSAlJXR5cGUlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVEYXRhKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgaGFzaCBvZiAlJXZhbHVlJSUgZm9yIHRoZSB0eXBlIG9mICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLmVuY29kZURhdGEobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbGVkIGVuY29kZWQgJSV2YWx1ZSUlIGZvciB0aGUgW1t0eXBlc11dLlxuICAgICAqL1xuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVEYXRhKHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaCBvZiB0aGUgZnVsbHkgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXG4gICAgICovXG4gICAgaGFzaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoU3RydWN0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF92aXNpdCh0eXBlLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBhcnJheSA9IHNwbGl0QXJyYXkodHlwZSkuYXJyYXk7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYXJyYXkuY291bnQgPT09IC0xIHx8IGFycmF5LmNvdW50ID09PSB2YWx1ZS5sZW5ndGgsIGBhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAke2FycmF5LmNvdW50fWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy5fdmlzaXQoYXJyYXkucHJlZml4LCB2LCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRzLnJlZHVjZSgoYWNjdW0sIHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB0aGlzLl92aXNpdCh0eXBlLCB2YWx1ZVtuYW1lXSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbGwgJSVjYWxiYWNrJSUgZm9yIGVhY2ggdmFsdWUgaW4gJSV2YWx1ZSUlLCBwYXNzaW5nIHRoZSB0eXBlIGFuZFxuICAgICAqICBjb21wb25lbnQgd2l0aGluICUldmFsdWUlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgcmVwbGFjaW5nIGFkZHJlc3NlcyBvciBvdGhlciB0cmFuc2Zvcm1hdGlvbiB0aGF0XG4gICAgICogIG1heSBiZSBkZXNpcmVkIG9uIGVhY2ggY29tcG9uZW50LCBiYXNlZCBvbiBpdHMgdHlwZS5cbiAgICAgKi9cbiAgICB2aXNpdCh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipUeXBlZERhdGFFbmNvZGVyKiogZm9yICUldHlwZXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eXBlcykge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkRGF0YUVuY29kZXIodHlwZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBwcmltYXJ5IHR5cGUgZm9yICUldHlwZXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UHJpbWFyeVR5cGUodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykucHJpbWFyeVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGhhc2hlZCBzdHJ1Y3QgZm9yICUldmFsdWUlJSB1c2luZyAlJXR5cGVzJSUgYW5kICUlbmFtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoU3RydWN0KG5hbWUsIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoU3RydWN0KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZG9tYWluIGhhc2ggZm9yICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hEb21haW4oZG9tYWluKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbkZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZG9tYWluKSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBkb21haW5GaWVsZFR5cGVzW25hbWVdO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZSwgYGludmFsaWQgdHlwZWQtZGF0YSBkb21haW4ga2V5OiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwiZG9tYWluXCIsIGRvbWFpbik7XG4gICAgICAgICAgICBkb21haW5GaWVsZHMucHVzaCh7IG5hbWUsIHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tYWluRmllbGRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYS5uYW1lKSAtIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihiLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuaGFzaFN0cnVjdChcIkVJUDcxMkRvbWFpblwiLCB7IEVJUDcxMkRvbWFpbjogZG9tYWluRmllbGRzIH0sIGRvbWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bGx5IGVuY29kZWQgW1tsaW5rLWVpcC03MTJdXSAlJXZhbHVlJSUgZm9yICUldHlwZXMlJSB3aXRoICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIFwiMHgxOTAxXCIsXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKSxcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaCh2YWx1ZSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGhhc2ggb2YgdGhlIGZ1bGx5IGVuY29kZWQgW1tsaW5rLWVpcC03MTJdXSAlJXZhbHVlJSUgZm9yICUldHlwZXMlJSB3aXRoICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1NihUeXBlZERhdGFFbmNvZGVyLmVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBSZXBsYWNlcyBhbGwgYWRkcmVzcyB0eXBlcyB3aXRoIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGxvb2tlZCB1cCBhZGRyZXNzXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdG8gdGhlIHZhbHVlIGZyb20gcmVzb2x2aW5nIGFsbCBhZGRyZXNzZXMgaW4gJSV2YWx1ZSUlIGZvclxuICAgICAqICUldHlwZXMlJSBhbmQgdGhlICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgcmVzb2x2ZU5hbWUpIHtcbiAgICAgICAgLy8gTWFrZSBhIGNvcHkgdG8gaXNvbGF0ZSBpdCBmcm9tIHRoZSBvYmplY3QgcGFzc2VkIGluXG4gICAgICAgIGRvbWFpbiA9IE9iamVjdC5hc3NpZ24oe30sIGRvbWFpbik7XG4gICAgICAgIC8vIEFsbG93IHBhc3NpbmcgbnVsbCB0byBpZ25vcmUgdmFsdWVcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZG9tYWluKSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkb21haW5ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIHVwIGFsbCBFTlMgbmFtZXNcbiAgICAgICAgY29uc3QgZW5zQ2FjaGUgPSB7fTtcbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBsb29rIHVwIHRoZSBkb21haW4ncyB2ZXJpZnlpbmdDb250cmFjdD9cbiAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiAhaXNIZXhTdHJpbmcoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0LCAyMCkpIHtcbiAgICAgICAgICAgIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0gPSBcIjB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIHVzZSB0aGUgZW5jb2RlciB0byB2aXNpdCBhbGwgdGhlIGJhc2UgdmFsdWVzXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xuICAgICAgICAvLyBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgYWRkcmVzc2VzXG4gICAgICAgIGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiICYmICFpc0hleFN0cmluZyh2YWx1ZSwgMjApKSB7XG4gICAgICAgICAgICAgICAgZW5zQ2FjaGVbdmFsdWVdID0gXCIweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTG9va3VwIGVhY2ggbmFtZVxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZW5zQ2FjaGUpIHtcbiAgICAgICAgICAgIGVuc0NhY2hlW25hbWVdID0gYXdhaXQgcmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgZG9tYWluIHZlcmlmeWluZ0NvbnRyYWN0IGlmIG5lZWRlZFxuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0pIHtcbiAgICAgICAgICAgIGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCA9IGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgRU5TIG5hbWVzIHdpdGggdGhlaXIgYWRkcmVzc1xuICAgICAgICB2YWx1ZSA9IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiICYmIGVuc0NhY2hlW3ZhbHVlXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnNDYWNoZVt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBkb21haW4sIHZhbHVlIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBKU09OLWVuY29kZWQgcGF5bG9hZCBleHBlY3RlZCBieSBub2RlcyB3aGljaCBpbXBsZW1lbnRcbiAgICAgKiAgdGhlIEpTT04tUlBDIFtbbGluay1laXAtNzEyXV0gbWV0aG9kLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQYXlsb2FkKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkb21haW4gZmllbGRzXG4gICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pO1xuICAgICAgICAvLyBEZXJpdmUgdGhlIEVJUDcxMkRvbWFpbiBTdHJ1Y3QgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgY29uc3QgZG9tYWluVmFsdWVzID0ge307XG4gICAgICAgIGNvbnN0IGRvbWFpblR5cGVzID0gW107XG4gICAgICAgIGRvbWFpbkZpZWxkTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb21haW5bbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbWFpblZhbHVlc1tuYW1lXSA9IGRvbWFpbkNoZWNrc1tuYW1lXSh2YWx1ZSk7XG4gICAgICAgICAgICBkb21haW5UeXBlcy5wdXNoKHsgbmFtZSwgdHlwZTogZG9tYWluRmllbGRUeXBlc1tuYW1lXSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xuICAgICAgICAvLyBHZXQgdGhlIG5vcm1hbGl6ZWQgdHlwZXNcbiAgICAgICAgdHlwZXMgPSBlbmNvZGVyLnR5cGVzO1xuICAgICAgICBjb25zdCB0eXBlc1dpdGhEb21haW4gPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlcyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPT0gbnVsbCwgXCJ0eXBlcyBtdXN0IG5vdCBjb250YWluIEVJUDcxMkRvbWFpbiB0eXBlXCIsIFwidHlwZXMuRUlQNzEyRG9tYWluXCIsIHR5cGVzKTtcbiAgICAgICAgdHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9IGRvbWFpblR5cGVzO1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCB0eXBlc1xuICAgICAgICBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlczogdHlwZXNXaXRoRG9tYWluLFxuICAgICAgICAgICAgZG9tYWluOiBkb21haW5WYWx1ZXMsXG4gICAgICAgICAgICBwcmltYXJ5VHlwZTogZW5jb2Rlci5wcmltYXJ5VHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL15ieXRlcyhcXGQqKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGdldEJ5dGVzKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgb3IgaW50XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqICBDb21wdXRlIHRoZSBhZGRyZXNzIHVzZWQgdG8gc2lnbiB0aGUgdHlwZWQgZGF0YSBmb3IgdGhlICUlc2lnbmF0dXJlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlUeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUsIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyhUeXBlZERhdGFFbmNvZGVyLmhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpLCBzaWduYXR1cmUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWQtZGF0YS5qcy5tYXAiLCIvKipcbiAqICBBIGZyYWdtZW50IGlzIGEgc2luZ2xlIGl0ZW0gZnJvbSBhbiBBQkksIHdoaWNoIG1heSByZXByZXNlbnQgYW55IG9mOlxuICpcbiAqICAtIFtGdW5jdGlvbnNdKEZ1bmN0aW9uRnJhZ21lbnQpXG4gKiAgLSBbRXZlbnRzXShFdmVudEZyYWdtZW50KVxuICogIC0gW0NvbnN0cnVjdG9yc10oQ29uc3RydWN0b3JGcmFnbWVudClcbiAqICAtIEN1c3RvbSBbRXJyb3JzXShFcnJvckZyYWdtZW50KVxuICogIC0gW0ZhbGxiYWNrIG9yIFJlY2VpdmVdKEZhbGxiYWNrRnJhZ21lbnQpIGZ1bmN0aW9uc1xuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL2FiaS9hYmktY29kZXI6RnJhZ21lbnRzICBbYWJvdXQtZnJhZ21lbnRzXVxuICovXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgYXNzZXJ0LCBhc3NlcnRQcml2YXRlLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuO1xuLy8gWyBcImFcIiwgXCJiXCIgXSA9PiB7IFwiYVwiOiAxLCBcImJcIjogMSB9XG5mdW5jdGlvbiBzZXRpZnkoaXRlbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgaXRlbXMuZm9yRWFjaCgoaykgPT4gcmVzdWx0LmFkZChrKSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzdWx0KTtcbn1cbmNvbnN0IF9rd1Zpc2liRGVwbG95ID0gXCJleHRlcm5hbCBwdWJsaWMgcGF5YWJsZSBvdmVycmlkZVwiO1xuY29uc3QgS3dWaXNpYkRlcGxveSA9IHNldGlmeShfa3dWaXNpYkRlcGxveS5zcGxpdChcIiBcIikpO1xuLy8gVmlzaWJpbGl0eSBLZXl3b3Jkc1xuY29uc3QgX2t3VmlzaWIgPSBcImNvbnN0YW50IGV4dGVybmFsIGludGVybmFsIHBheWFibGUgcHJpdmF0ZSBwdWJsaWMgcHVyZSB2aWV3IG92ZXJyaWRlXCI7XG5jb25zdCBLd1Zpc2liID0gc2V0aWZ5KF9rd1Zpc2liLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dUeXBlcyA9IFwiY29uc3RydWN0b3IgZXJyb3IgZXZlbnQgZmFsbGJhY2sgZnVuY3Rpb24gcmVjZWl2ZSBzdHJ1Y3RcIjtcbmNvbnN0IEt3VHlwZXMgPSBzZXRpZnkoX2t3VHlwZXMuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd01vZGlmaWVycyA9IFwiY2FsbGRhdGEgbWVtb3J5IHN0b3JhZ2UgcGF5YWJsZSBpbmRleGVkXCI7XG5jb25zdCBLd01vZGlmaWVycyA9IHNldGlmeShfa3dNb2RpZmllcnMuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd090aGVyID0gXCJ0dXBsZSByZXR1cm5zXCI7XG4vLyBBbGwgS2V5d29yZHNcbmNvbnN0IF9rZXl3b3JkcyA9IFtfa3dUeXBlcywgX2t3TW9kaWZpZXJzLCBfa3dPdGhlciwgX2t3VmlzaWJdLmpvaW4oXCIgXCIpO1xuY29uc3QgS2V5d29yZHMgPSBzZXRpZnkoX2tleXdvcmRzLnNwbGl0KFwiIFwiKSk7XG4vLyBTaW5nbGUgY2hhcmFjdGVyIHRva2Vuc1xuY29uc3QgU2ltcGxlVG9rZW5zID0ge1xuICAgIFwiKFwiOiBcIk9QRU5fUEFSRU5cIiwgXCIpXCI6IFwiQ0xPU0VfUEFSRU5cIixcbiAgICBcIltcIjogXCJPUEVOX0JSQUNLRVRcIiwgXCJdXCI6IFwiQ0xPU0VfQlJBQ0tFVFwiLFxuICAgIFwiLFwiOiBcIkNPTU1BXCIsIFwiQFwiOiBcIkFUXCJcbn07XG4vLyBQYXJzZXIgcmVnZXhlcyB0byBjb25zdW1lIHRoZSBuZXh0IHRva2VuXG5jb25zdCByZWdleFdoaXRlc3BhY2VQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihcXFxccyopXCIpO1xuY29uc3QgcmVnZXhOdW1iZXJQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihbMC05XSspXCIpO1xuY29uc3QgcmVnZXhJZFByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFthLXpBLVokX11bYS16QS1aMC05JF9dKilcIik7XG4vLyBQYXJzZXIgcmVnZXhzIHRvIGNoZWNrIHZhbGlkaXR5XG5jb25zdCByZWdleElkID0gbmV3IFJlZ0V4cChcIl4oW2EtekEtWiRfXVthLXpBLVowLTkkX10qKSRcIik7XG5jb25zdCByZWdleFR5cGUgPSBuZXcgUmVnRXhwKFwiXihhZGRyZXNzfGJvb2x8Ynl0ZXMoWzAtOV0qKXxzdHJpbmd8dT9pbnQoWzAtOV0qKSkkXCIpO1xuY2xhc3MgVG9rZW5TdHJpbmcge1xuICAgICNvZmZzZXQ7XG4gICAgI3Rva2VucztcbiAgICBnZXQgb2Zmc2V0KCkgeyByZXR1cm4gdGhpcy4jb2Zmc2V0OyB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3Rva2Vucy5sZW5ndGggLSB0aGlzLiNvZmZzZXQ7IH1cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMpIHtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy4jdG9rZW5zID0gdG9rZW5zLnNsaWNlKCk7XG4gICAgfVxuICAgIGNsb25lKCkgeyByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRoaXMuI3Rva2Vucyk7IH1cbiAgICByZXNldCgpIHsgdGhpcy4jb2Zmc2V0ID0gMDsgfVxuICAgICNzdWJUb2tlblN0cmluZyhmcm9tID0gMCwgdG8gPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zLnNsaWNlKGZyb20sIHRvKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sIHQsIHtcbiAgICAgICAgICAgICAgICBtYXRjaDogKHQubWF0Y2ggLSBmcm9tKSxcbiAgICAgICAgICAgICAgICBsaW5rQmFjazogKHQubGlua0JhY2sgLSBmcm9tKSxcbiAgICAgICAgICAgICAgICBsaW5rTmV4dDogKHQubGlua05leHQgLSBmcm9tKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiwgaWYgaXQgaXMgYSBrZXl3b3JkIGluIGFsbG93ZWQ7IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiS0VZV09SRFwiIHx8ICFhbGxvd2VkLmhhcyh0b3AudGV4dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQga2V5d29yZCAke3RvcC50ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpLnRleHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuIGlmIGl0IGlzIGB0eXBlYDsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3BUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke3R5cGV9OyBnb3QgJHt0b3AudHlwZX0gJHtKU09OLnN0cmluZ2lmeSh0b3AudGV4dCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wKCkudGV4dDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyBhIFwiKFwiIFRPS0VOUyBcIilcIlxuICAgIHBvcFBhcmVuKCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHN0YXJ0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI3N1YlRva2VuU3RyaW5nKHRoaXMuI29mZnNldCArIDEsIHRvcC5tYXRjaCArIDEpO1xuICAgICAgICB0aGlzLiNvZmZzZXQgPSB0b3AubWF0Y2ggKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSBpdGVtcyB3aXRoaW4gXCIoXCIgSVRFTTEgXCIsXCIgSVRFTTIgXCIsXCIgLi4uIFwiKVwiXG4gICAgcG9wUGFyYW1zKCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHN0YXJ0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy4jb2Zmc2V0IDwgdG9wLm1hdGNoIC0gMSkge1xuICAgICAgICAgICAgY29uc3QgbGluayA9IHRoaXMucGVlaygpLmxpbmtOZXh0O1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgbGluaykpO1xuICAgICAgICAgICAgdGhpcy4jb2Zmc2V0ID0gbGluaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNvZmZzZXQgPSB0b3AubWF0Y2ggKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB0b3AgVG9rZW4sIHRocm93aW5nIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy4jb2Zmc2V0ID49IHRoaXMuI3Rva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm91dC1vZi1ib3VuZHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3Rva2Vuc1t0aGlzLiNvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBuZXh0IHZhbHVlLCBpZiBpdCBpcyBhIGtleXdvcmQgaW4gYGFsbG93ZWRgXG4gICAgcGVla0tleXdvcmQoYWxsb3dlZCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWtUeXBlKFwiS0VZV09SRFwiKTtcbiAgICAgICAgcmV0dXJuICh0b3AgIT0gbnVsbCAmJiBhbGxvd2VkLmhhcyh0b3ApKSA/IHRvcCA6IG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuIGlmIGl0IGlzIGB0eXBlYFxuICAgIHBlZWtUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgcmV0dXJuICh0b3AudHlwZSA9PT0gdHlwZSkgPyB0b3AudGV4dCA6IG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdG9rZW47IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuI29mZnNldDsgaSA8IHRoaXMuI3Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLiN0b2tlbnNbaV07XG4gICAgICAgICAgICB0b2tlbnMucHVzaChgJHt0b2tlbi50eXBlfToke3Rva2VuLnRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGA8VG9rZW5TdHJpbmcgJHt0b2tlbnMuam9pbihcIiBcIil9PmA7XG4gICAgfVxufVxuZnVuY3Rpb24gbGV4KHRleHQpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBjb25zdCB0aHJvd0Vycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpID8gSlNPTi5zdHJpbmdpZnkodGV4dFtvZmZzZXRdKSA6IFwiJEVPSVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdG9rZW4gJHt0b2tlbn0gYXQgJHtvZmZzZXR9OiAke21lc3NhZ2V9YCk7XG4gICAgfTtcbiAgICBsZXQgYnJhY2tldHMgPSBbXTtcbiAgICBsZXQgY29tbWFzID0gW107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIC8vIFN0cmlwIG9mZiBhbnkgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgIGxldCBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhXaGl0ZXNwYWNlUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgY3VyID0gdGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbiA9IHsgZGVwdGg6IGJyYWNrZXRzLmxlbmd0aCwgbGlua0JhY2s6IC0xLCBsaW5rTmV4dDogLTEsIG1hdGNoOiAtMSwgdHlwZTogXCJcIiwgdGV4dDogXCJcIiwgb2Zmc2V0LCB2YWx1ZTogLTEgfTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBsZXQgdHlwZSA9IChTaW1wbGVUb2tlbnNbY3VyWzBdXSB8fCBcIlwiKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IGN1clswXTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIkNMT1NFX1BBUkVOXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJubyBtYXRjaGluZyBvcGVuIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuLm1hdGNoID0gYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5tYXRjaF0pLm1hdGNoID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdG9rZW4uZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB0b2tlbi5saW5rQmFjayA9IGNvbW1hcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLmxpbmtCYWNrXSkubGlua05leHQgPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ09NTUFcIikge1xuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNvbW1hcy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiT1BFTl9CUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJCUkFDS0VUXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIkNMT1NFX0JSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgQ0xPU0VfQlJBQ0tFVFxuICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDAgJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlID09PSBcIk5VTUJFUlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHZhbHVlICsgc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkudmFsdWUgPSBnZXROdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgIT09IFwiQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3BlbmluZyBicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkudGV4dCArPSBzdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IGN1ci5tYXRjaChyZWdleElkUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBvZmZzZXQgKz0gdG9rZW4udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoS2V5d29yZHMuaGFzKHRva2VuLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiS0VZV09SRFwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnRleHQubWF0Y2gocmVnZXhUeXBlKSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIlRZUEVcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIklEXCI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IGN1ci5tYXRjaChyZWdleE51bWJlclByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiTlVNQkVSXCI7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdG9rZW4udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW4gJHtKU09OLnN0cmluZ2lmeShjdXJbMF0pfSBhdCBwb3NpdGlvbiAke29mZnNldH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0b2tlbnMubWFwKCh0KSA9PiBPYmplY3QuZnJlZXplKHQpKSk7XG59XG4vLyBDaGVjayBvbmx5IG9uZSBvZiBgYWxsb3dlZGAgaXMgaW4gYHNldGBcbmZ1bmN0aW9uIGFsbG93U2luZ2xlKHNldCwgYWxsb3dlZCkge1xuICAgIGxldCBpbmNsdWRlZCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGFsbG93ZWQua2V5cygpKSB7XG4gICAgICAgIGlmIChzZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGluY2x1ZGVkLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5jbHVkZWQubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbmZsaWN0aW5nIHR5cGVzOiAke2luY2x1ZGVkLmpvaW4oXCIsIFwiKX1gKTtcbiAgICB9XG59XG4vLyBGdW5jdGlvbnMgdG8gcHJvY2VzcyBhIFNvbGlkaXR5IFNpZ25hdHVyZSBUb2tlblN0cmluZyBmcm9tIGxlZnQtdG8tcmlnaHQgZm9yLi4uXG4vLyAuLi50aGUgbmFtZSB3aXRoIGFuIG9wdGlvbmFsIHR5cGUsIHJldHVybmluZyB0aGUgbmFtZVxuZnVuY3Rpb24gY29uc3VtZU5hbWUodHlwZSwgdG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5wZWVrS2V5d29yZChLd1R5cGVzKSkge1xuICAgICAgICBjb25zdCBrZXl3b3JkID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgIGlmIChrZXl3b3JkICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX0sIGdvdCAke2tleXdvcmR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucy5wb3BUeXBlKFwiSURcIik7XG59XG4vLyAuLi5hbGwga2V5d29yZHMgbWF0Y2hpbmcgYWxsb3dlZCwgcmV0dXJuaW5nIHRoZSBrZXl3b3Jkc1xuZnVuY3Rpb24gY29uc3VtZUtleXdvcmRzKHRva2VucywgYWxsb3dlZCkge1xuICAgIGNvbnN0IGtleXdvcmRzID0gbmV3IFNldCgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xuICAgICAgICBpZiAoa2V5d29yZCA9PSBudWxsIHx8IChhbGxvd2VkICYmICFhbGxvd2VkLmhhcyhrZXl3b3JkKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKGtleXdvcmRzLmhhcyhrZXl3b3JkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGUga2V5d29yZHM6ICR7SlNPTi5zdHJpbmdpZnkoa2V5d29yZCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAga2V5d29yZHMuYWRkKGtleXdvcmQpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShrZXl3b3Jkcyk7XG59XG4vLyAuLi5hbGwgdmlzaWJpbGl0eSBrZXl3b3JkcywgcmV0dXJuaW5nIHRoZSBjb2FsZXNjZWQgbXV0YWJpbGl0eVxuZnVuY3Rpb24gY29uc3VtZU11dGFiaWxpdHkodG9rZW5zKSB7XG4gICAgbGV0IG1vZGlmaWVycyA9IGNvbnN1bWVLZXl3b3Jkcyh0b2tlbnMsIEt3VmlzaWIpO1xuICAgIC8vIERldGVjdCBjb25mbGljdGluZyBtb2RpZmllcnNcbiAgICBhbGxvd1NpbmdsZShtb2RpZmllcnMsIHNldGlmeShcImNvbnN0YW50IHBheWFibGUgbm9ucGF5YWJsZVwiLnNwbGl0KFwiIFwiKSkpO1xuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwicHVyZSB2aWV3IHBheWFibGUgbm9ucGF5YWJsZVwiLnNwbGl0KFwiIFwiKSkpO1xuICAgIC8vIFByb2Nlc3MgbXV0YWJpbGl0eSBzdGF0ZXNcbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInZpZXdcIikpIHtcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInB1cmVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwicHVyZVwiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInBheWFibGVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwicGF5YWJsZVwiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcIm5vbnBheWFibGVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwibm9ucGF5YWJsZVwiO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGxlZ2FjeSBgY29uc3RhbnRgIGxhc3RcbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcImNvbnN0YW50XCIpKSB7XG4gICAgICAgIHJldHVybiBcInZpZXdcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwibm9ucGF5YWJsZVwiO1xufVxuLy8gLi4uYSBwYXJhbWV0ZXIgbGlzdCwgcmV0dXJuaW5nIHRoZSBQYXJhbVR5cGUgbGlzdFxuZnVuY3Rpb24gY29uc3VtZVBhcmFtcyh0b2tlbnMsIGFsbG93SW5kZXhlZCkge1xuICAgIHJldHVybiB0b2tlbnMucG9wUGFyYW1zKCkubWFwKCh0KSA9PiBQYXJhbVR5cGUuZnJvbSh0LCBhbGxvd0luZGV4ZWQpKTtcbn1cbi8vIC4uLmEgZ2FzIGxpbWl0LCByZXR1cm5pbmcgYSBCaWdOdW1iZXIgb3IgbnVsbCBpZiBub25lXG5mdW5jdGlvbiBjb25zdW1lR2FzKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMucGVla1R5cGUoXCJBVFwiKSkge1xuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIGlmICh0b2tlbnMucGVla1R5cGUoXCJOVU1CRVJcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCaWdJbnQodG9rZW5zLnBvcCgpLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZ2FzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnN1bWVFb2kodG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHRva2VucyBhdCBvZmZzZXQgJHt0b2tlbnMub2Zmc2V0fTogJHt0b2tlbnMudG9TdHJpbmcoKX1gKTtcbiAgICB9XG59XG5jb25zdCByZWdleEFycmF5VHlwZSA9IG5ldyBSZWdFeHAoL14oLiopXFxbKFswLTldKilcXF0kLyk7XG5mdW5jdGlvbiB2ZXJpZnlCYXNpY1R5cGUodHlwZSkge1xuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChyZWdleFR5cGUpO1xuICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoLCBcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwidWludFwiKSB7XG4gICAgICAgIHJldHVybiBcInVpbnQyNTZcIjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiaW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiaW50MjU2XCI7XG4gICAgfVxuICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAvLyBieXRlc1hYXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSAzMiwgXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgIC8vIGludFhYIG9yIHVpbnRYWFxuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG59XG4vLyBNYWtlIHRoZSBGcmFnbWVudCBjb25zdHJ1Y3RvcnMgZWZmZWN0aXZlbHkgcHJpdmF0ZVxuY29uc3QgX2d1YXJkID0ge307XG5jb25zdCBpbnRlcm5hbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX2ludGVybmFsXCIpO1xuY29uc3QgUGFyYW1UeXBlSW50ZXJuYWwgPSBcIl9QYXJhbVR5cGVJbnRlcm5hbFwiO1xuY29uc3QgRXJyb3JGcmFnbWVudEludGVybmFsID0gXCJfRXJyb3JJbnRlcm5hbFwiO1xuY29uc3QgRXZlbnRGcmFnbWVudEludGVybmFsID0gXCJfRXZlbnRJbnRlcm5hbFwiO1xuY29uc3QgQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsID0gXCJfQ29uc3RydWN0b3JJbnRlcm5hbFwiO1xuY29uc3QgRmFsbGJhY2tGcmFnbWVudEludGVybmFsID0gXCJfRmFsbGJhY2tJbnRlcm5hbFwiO1xuY29uc3QgRnVuY3Rpb25GcmFnbWVudEludGVybmFsID0gXCJfRnVuY3Rpb25JbnRlcm5hbFwiO1xuY29uc3QgU3RydWN0RnJhZ21lbnRJbnRlcm5hbCA9IFwiX1N0cnVjdEludGVybmFsXCI7XG4vKipcbiAqICBFYWNoIGlucHV0IGFuZCBvdXRwdXQgb2YgYSBbW0ZyYWdtZW50XV0gaXMgYW4gQXJyYXkgb2YgKipQYXJhbVR5cGUqKi5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcmFtVHlwZSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2NhbCBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgKG9yIGBgXCJcImBgIGlmIHVuYm91bmQpXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlKGFkZHJlc3MpXCJgYCxcbiAgICAgKiAgYGBcInVpbnQyNTZbM11bXVwiYGApXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJhc2UgdHlwZSAoZS5nLiBgYFwiYWRkcmVzc1wiYGAsIGBgXCJ0dXBsZVwiYGAsIGBgXCJhcnJheVwiYGApXG4gICAgICovXG4gICAgYmFzZVR5cGU7XG4gICAgLyoqXG4gICAgICogIFRydWUgaWYgdGhlIHBhcmFtZXRlcnMgaXMgaW5kZXhlZC5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWluZGV4YWJsZSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGluZGV4ZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wb25lbnRzIGZvciB0aGUgdHVwbGUuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi10dXBsZSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGNvbXBvbmVudHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcnJheSBsZW5ndGgsIG9yIGBgLTFgYCBmb3IgZHluYW1pYy1sZW5ndGhlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1hcnJheSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFycmF5TGVuZ3RoO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSBvZiBlYWNoIGNoaWxkIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgYXJyYXlDaGlsZHJlbjtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJQYXJhbVR5cGVcIik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogUGFyYW1UeXBlSW50ZXJuYWwgfSk7XG4gICAgICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzID0gT2JqZWN0LmZyZWV6ZShjb21wb25lbnRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlMZW5ndGggPT0gbnVsbCB8fCBhcnJheUNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJyYXlMZW5ndGggIT0gbnVsbCB8fCBhcnJheUNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wb25lbnRzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHR5cGUuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsXG4gICAgICpcbiAgICAgKiAgYGBzaWdoYXNoXCIgPT4gXCIodWludDI1NixhZGRyZXNzKVwiYGBcbiAgICAgKlxuICAgICAqICBgYFwibWluaW1hbFwiID0+IFwidHVwbGUodWludDI1NixhZGRyZXNzKSBpbmRleGVkXCJgYFxuICAgICAqXG4gICAgICogIGBgXCJmdWxsXCIgPT4gXCJ0dXBsZSh1aW50MjU2IGZvbywgYWRkcmVzcyBiYXIpIGluZGV4ZWQgYmF6XCJgYFxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZSB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSh0aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIHJlc3VsdC50eXBlICs9IGBbJHsodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKX1dYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAoKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLmluZGV4ZWQpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pbmRleGVkID0gdGhpcy5pbmRleGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubWFwKChjKSA9PiBKU09OLnBhcnNlKGMuZm9ybWF0KGZvcm1hdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICAvLyBBcnJheVxuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICByZXN1bHQgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiKFwiICsgdGhpcy5jb21wb25lbnRzLm1hcCgoY29tcCkgPT4gY29tcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBcImZ1bGxcIikgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgaW5kZXhlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJmdWxsXCIgJiYgdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYW4gQXJyYXkgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbYXJyYXlDaGlsZHJlbl1dXG4gICAgICogIGFuZCBbW2FycmF5TGVuZ3RoXV0gYXJlIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhIFR1cGxlIHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2NvbXBvbmVudHNdXVxuICAgICAqICBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc1R1cGxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYW4gSW5kZXhhYmxlIHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2luZGV4ZWRdXVxuICAgICAqICBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0luZGV4YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4ZWQgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXYWxrcyB0aGUgKipQYXJhbVR5cGUqKiB3aXRoICUldmFsdWUlJSwgY2FsbGluZyAlJXByb2Nlc3MlJVxuICAgICAqICBvbiBlYWNoIHR5cGUsIGRlc3RydWN0aW5nIHRoZSAlJXZhbHVlJSUgcmVjdXJzaXZlbHkuXG4gICAgICovXG4gICAgd2Fsayh2YWx1ZSwgcHJvY2Vzcykge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFycmF5IHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXlMZW5ndGggIT09IC0xICYmIHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5hcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IChfdGhpcy5hcnJheUNoaWxkcmVuLndhbGsodiwgcHJvY2VzcykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYsIGkpID0+IChfdGhpcy5jb21wb25lbnRzW2ldLndhbGsodiwgcHJvY2VzcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvY2Vzcyh0aGlzLnR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsIHNldFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheUxlbmd0aCAhPT0gLTEgJiYgdmFsdWUubGVuZ3RoICE9PSB0aGlzLmFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gdGhpcy5hcnJheUNoaWxkcmVuO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZFR5cGUuI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgb2JqZWN0IGludG8gYW4gYXJyYXlcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mICh2YWx1ZSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29tcG9uZW50cy5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW0ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBvYmplY3QgdmFsdWUgd2l0aCB1bm5hbWVkIGNvbXBvbmVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW0ubmFtZSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgY29tcG9uZW50ICR7cGFyYW0ubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbcGFyYW0ubmFtZV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2luZGV4XS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xuICAgICAgICBpZiAocmVzdWx0LnRoZW4pIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgc2V0VmFsdWUoYXdhaXQgcmVzdWx0KTsgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXYWxrcyB0aGUgKipQYXJhbVR5cGUqKiB3aXRoICUldmFsdWUlJSwgYXN5bmNocm9ub3VzbHkgY2FsbGluZ1xuICAgICAqICAlJXByb2Nlc3MlJSBvbiBlYWNoIHR5cGUsIGRlc3RydWN0aW5nIHRoZSAlJXZhbHVlJSUgcmVjdXJzaXZlbHkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gYmUgdXNlZCB0byByZXNvbHZlIEVOUyBuYW1lcyBieSB3YWxraW5nIGFuZCByZXNvbHZpbmcgZWFjaFxuICAgICAqICBgYFwiYWRkcmVzc1wiYGAgdHlwZS5cbiAgICAgKi9cbiAgICBhc3luYyB3YWxrQXN5bmModmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW3ZhbHVlXTtcbiAgICAgICAgdGhpcy4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlBhcmFtVHlwZSoqIGZvciAlJW9iaiUlLlxuICAgICAqXG4gICAgICogIElmICUlYWxsb3dJbmRleGVkJSUgdGhlbiB0aGUgYGBpbmRleGVkYGAga2V5d29yZCBpcyBwZXJtaXR0ZWQsXG4gICAgICogIG90aGVyd2lzZSB0aGUgYGBpbmRleGVkYGAga2V5d29yZCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaiwgYWxsb3dJbmRleGVkKSB7XG4gICAgICAgIGlmIChQYXJhbVR5cGUuaXNQYXJhbVR5cGUob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbShsZXgob2JqKSwgYWxsb3dJbmRleGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgcGFyYW0gdHlwZVwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IFwiXCIsIGJhc2VUeXBlID0gXCJcIjtcbiAgICAgICAgICAgIGxldCBjb21wcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInR1cGxlXCJdKSkuaGFzKFwidHVwbGVcIikgfHwgb2JqLnBlZWtUeXBlKFwiT1BFTl9QQVJFTlwiKSkge1xuICAgICAgICAgICAgICAgIC8vIFR1cGxlXG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcInR1cGxlXCI7XG4gICAgICAgICAgICAgICAgY29tcHMgPSBvYmoucG9wUGFyYW1zKCkubWFwKCh0KSA9PiBQYXJhbVR5cGUuZnJvbSh0KSk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGB0dXBsZSgke2NvbXBzLm1hcCgoYykgPT4gYy5mb3JtYXQoKSkuam9pbihcIixcIil9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxcbiAgICAgICAgICAgICAgICB0eXBlID0gdmVyaWZ5QmFzaWNUeXBlKG9iai5wb3BUeXBlKFwiVFlQRVwiKSk7XG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEFycmF5XG4gICAgICAgICAgICBsZXQgYXJyYXlDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJyYXlMZW5ndGggPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKG9iai5sZW5ndGggJiYgb2JqLnBlZWtUeXBlKFwiQlJBQ0tFVFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyYWNrZXQgPSBvYmoucG9wKCk7IC8vYXJyYXlzW2ldO1xuICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW4gPSBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgXCJcIiwgdHlwZSwgYmFzZVR5cGUsIG51bGwsIGNvbXBzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgYXJyYXlMZW5ndGggPSBicmFja2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHR5cGUgKz0gYnJhY2tldC50ZXh0O1xuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gXCJhcnJheVwiO1xuICAgICAgICAgICAgICAgIGNvbXBzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbmRleGVkID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmRzID0gY29uc3VtZUtleXdvcmRzKG9iaiwgS3dNb2RpZmllcnMpO1xuICAgICAgICAgICAgaWYgKGtleXdvcmRzLmhhcyhcImluZGV4ZWRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IChvYmoucGVla1R5cGUoXCJJRFwiKSA/IG9iai5wb3AoKS50ZXh0IDogXCJcIik7XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxlZnRvdmVyIHRva2Vuc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IG9iai5uYW1lO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCghbmFtZSB8fCAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lLm1hdGNoKHJlZ2V4SWQpKSwgXCJpbnZhbGlkIG5hbWVcIiwgXCJvYmoubmFtZVwiLCBuYW1lKTtcbiAgICAgICAgbGV0IGluZGV4ZWQgPSBvYmouaW5kZXhlZDtcbiAgICAgICAgaWYgKGluZGV4ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWxsb3dJbmRleGVkLCBcInBhcmFtZXRlciBjYW5ub3QgYmUgaW5kZXhlZFwiLCBcIm9iai5pbmRleGVkXCIsIG9iai5pbmRleGVkKTtcbiAgICAgICAgICAgIGluZGV4ZWQgPSAhIWluZGV4ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSBvYmoudHlwZTtcbiAgICAgICAgbGV0IGFycmF5TWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4QXJyYXlUeXBlKTtcbiAgICAgICAgaWYgKGFycmF5TWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gcGFyc2VJbnQoYXJyYXlNYXRjaFsyXSB8fCBcIi0xXCIpO1xuICAgICAgICAgICAgY29uc3QgYXJyYXlDaGlsZHJlbiA9IFBhcmFtVHlwZS5mcm9tKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcnJheU1hdGNoWzFdLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IG9iai5jb21wb25lbnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCBcImFycmF5XCIsIGluZGV4ZWQsIG51bGwsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHR5cGUuc3RhcnRzV2l0aChcInR1cGxlKFwiIC8qIGZpeDogKSAqLykgfHwgdHlwZS5zdGFydHNXaXRoKFwiKFwiIC8qIGZpeDogKSAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG9iai5jb21wb25lbnRzICE9IG51bGwpID8gb2JqLmNvbXBvbmVudHMubWFwKChjKSA9PiBQYXJhbVR5cGUuZnJvbShjKSkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgdHVwbGUgPSBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCBcInR1cGxlXCIsIGluZGV4ZWQsIGNvbXBzLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB1c2UgbGV4ZXIgdG8gdmFsaWRhdGUgYW5kIG5vcm1hbGl6ZSB0eXBlXG4gICAgICAgICAgICByZXR1cm4gdHVwbGU7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IHZlcmlmeUJhc2ljVHlwZShvYmoudHlwZSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCB0eXBlLCBpbmRleGVkLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSAqKlBhcmFtVHlwZSoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1BhcmFtVHlwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gUGFyYW1UeXBlSW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuIGFic3RyYWN0IGNsYXNzIHRvIHJlcHJlc2VudCBBbiBpbmRpdmlkdWFsIGZyYWdtZW50IGZyb20gYSBwYXJzZSBBQkkuXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlIG9mIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5wdXRzIGZvciB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgaW5wdXRzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBpbnB1dHMpIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIkZyYWdtZW50XCIpO1xuICAgICAgICBpbnB1dHMgPSBPYmplY3QuZnJlZXplKGlucHV0cy5zbGljZSgpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHR5cGUsIGlucHV0cyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGcmFnbWVudCoqIGZvciAlJW9iaiUlLCB3aWNoIGNhbiBiZSBhbnkgc3VwcG9ydGVkXG4gICAgICogIEFCSSBmcmdhbWVudCB0eXBlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBUcnkgcGFyc2luZyBKU09OLi4uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEZyYWdtZW50LmZyb20oSlNPTi5wYXJzZShvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIC8vIC4uLm90aGVyd2lzZSwgdXNlIHRoZSBodW1hbi1yZWFkYWJsZSBsZXhlclxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgLy8gSHVtYW4tcmVhZGFibGUgQUJJIChhbHJlYWR5IGxleGVkKVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9iai5wZWVrS2V5d29yZChLd1R5cGVzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOiByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHJldHVybiBFcnJvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjogcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjogcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjogcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9iaikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIEpTT04gQUJJXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6IHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjogcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5zdXBwb3J0ZWQgdHlwZTogJHtvYmoudHlwZX1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIkZyYWdtZW50LmZyb21cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgZnJnYW1lbnQgb2JqZWN0XCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tDb25zdHJ1Y3RvckZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzQ29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIFtbRXJyb3JGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBbW0V2ZW50RnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFdmVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW0Z1bmN0aW9uRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW1N0cnVjdEZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzU3RydWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJ1Y3RGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiBhYnN0cmFjdCBjbGFzcyB0byByZXByZXNlbnQgQW4gaW5kaXZpZHVhbCBmcmFnbWVudFxuICogIHdoaWNoIGhhcyBhIG5hbWUgZnJvbSBhIHBhcnNlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5hbWVkRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIgJiYgbmFtZS5tYXRjaChyZWdleElkKSwgXCJpbnZhbGlkIGlkZW50aWZpZXJcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICBpbnB1dHMgPSBPYmplY3QuZnJlZXplKGlucHV0cy5zbGljZSgpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gam9pblBhcmFtcyhmb3JtYXQsIHBhcmFtcykge1xuICAgIHJldHVybiBcIihcIiArIHBhcmFtcy5tYXAoKHApID0+IHAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gXCJmdWxsXCIpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSAvL0N1c3RvbSBFcnJvci8vLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZXJyb3JcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBFcnJvckZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQ3VzdG9tIEVycm9yIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSkuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmcmFnbWVudCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkVycm9yRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJlcnJvclwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvckZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYW5cbiAgICAgKiAgKipFcnJvckZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEVycm9yRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGFuIEV2ZW50LlxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoaXMgZXZlbnQgaXMgYW5vbnltb3VzLlxuICAgICAqL1xuICAgIGFub255bW91cztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZXZlbnRcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBFdmVudEZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhbm9ueW1vdXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRXZlbnQgdG9waWMgaGFzaC5cbiAgICAgKi9cbiAgICBnZXQgdG9waWNIYXNoKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBldmVudCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgICAgICAgICAgICAgYW5vbnltb3VzOiB0aGlzLmFub255bW91cyxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZXZlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiICYmIHRoaXMuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImFub255bW91c1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSB0b3BpYyBoYXNoIGZvciBhbiBldmVudCB3aXRoICUlbmFtZSUlIGFuZCAlJXBhcmFtcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRUb3BpY0hhc2gobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCkpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgcGFyYW1zLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRXZlbnRGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRXZlbnRGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZXZlbnQgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZXZlbnRcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGFub255bW91cyA9ICEhY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcImFub255bW91c1wiXSkpLmhhcyhcImFub255bW91c1wiKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cywgYW5vbnltb3VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwLCB0cnVlKSkgOiBbXSwgISFvYmouYW5vbnltb3VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYW5cbiAgICAgKiAgKipFdmVudEZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25zdHJ1Y3RvckZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoZSBjb25zdHJ1Y3RvciBjYW4gcmVjZWl2ZSBhbiBlbmRvd21lbnQuXG4gICAgICovXG4gICAgcGF5YWJsZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY29tbWVuZGVkIGdhcyBsaW1pdCBmb3IgZGVwbG95bWVudCBvciBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cywgcGF5YWJsZSwgZ2FzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCB0eXBlLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBheWFibGUsIGdhcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb25zdHJ1Y3RvciBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgYXNzZXJ0KGZvcm1hdCAhPSBudWxsICYmIGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIsIFwiY2Fubm90IGZvcm1hdCBhIGNvbnN0cnVjdG9yIGZvciBzaWdoYXNoXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZvcm1hdChzaWdoYXNoKVwiIH0pO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAodGhpcy5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcInVuZGVmaW5lZFwiKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAoKHRoaXMuZ2FzICE9IG51bGwpID8gdGhpcy5nYXMgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW2Bjb25zdHJ1Y3RvciR7am9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKX1gXTtcbiAgICAgICAgaWYgKHRoaXMucGF5YWJsZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJwYXlhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChgQCR7dGhpcy5nYXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkNvbnN0cnVjdG9yRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGNvbnN0dWN0b3IgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcImNvbnN0cnVjdG9yXCJdKSk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdCBwYXlhYmxlID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBLd1Zpc2liRGVwbG95KS5oYXMoXCJwYXlhYmxlXCIpO1xuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9ndWFyZCwgXCJjb25zdHJ1Y3RvclwiLCBpbnB1dHMsIHBheWFibGUsIGdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9ndWFyZCwgXCJjb25zdHJ1Y3RvclwiLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sICEhb2JqLnBheWFibGUsIChvYmouZ2FzICE9IG51bGwpID8gb2JqLmdhcyA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqQ29uc3RydWN0b3JGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZhbGxiYWNrRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBjYW4gYmUgc2VudCB2YWx1ZSBkdXJpbmcgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBpbnB1dHMsIHBheWFibGUpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZmFsbGJhY2tcIiwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwYXlhYmxlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZhbGxiYWNrIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBjb25zdCB0eXBlID0gKCh0aGlzLmlucHV0cy5sZW5ndGggPT09IDApID8gXCJyZWNlaXZlXCIgOiBcImZhbGxiYWNrXCIpO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVNdXRhYmlsaXR5ID0gKHRoaXMucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJub25wYXlhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHsgdHlwZSwgc3RhdGVNdXRhYmlsaXR5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0eXBlfSgpJHt0aGlzLnBheWFibGUgPyBcIiBwYXlhYmxlXCIgOiBcIlwifWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRmFsbGJhY2tGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRmFsbGJhY2tGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZmFsbGJhY2sgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JPYmogPSBvYmoudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcElzVmFsaWQgPSBvYmoucGVla0tleXdvcmQoc2V0aWZ5KFtcImZhbGxiYWNrXCIsIFwicmVjZWl2ZVwiXSkpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodG9wSXNWYWxpZCwgXCJ0eXBlIG11c3QgYmUgZmFsbGJhY2sgb3IgcmVjZWl2ZVwiLCBcIm9ialwiLCBlcnJvck9iaik7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBvcEtleXdvcmQoc2V0aWZ5KFtcImZhbGxiYWNrXCIsIFwicmVjZWl2ZVwiXSkpO1xuICAgICAgICAgICAgLy8gcmVjZWl2ZSgpXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyZWNlaXZlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5wdXRzLmxlbmd0aCA9PT0gMCwgYHJlY2VpdmUgY2Fubm90IGhhdmUgYXJndW1lbnRzYCwgXCJvYmouaW5wdXRzXCIsIGlucHV0cyk7XG4gICAgICAgICAgICAgICAgY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInBheWFibGVcIl0pKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgW10sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbGJhY2soKSBbcGF5YWJsZV1cbiAgICAgICAgICAgIC8vIGZhbGxiYWNrKGJ5dGVzKSBbcGF5YWJsZV0gcmV0dXJucyAoYnl0ZXMpXG4gICAgICAgICAgICBsZXQgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbnB1dHMubGVuZ3RoID09PSAxICYmIGlucHV0c1swXS50eXBlID09PSBcImJ5dGVzXCIsIFwiaW52YWxpZCBmYWxsYmFjayBpbnB1dHNcIiwgXCJvYmouaW5wdXRzXCIsIGlucHV0cy5tYXAoKGkpID0+IGkuZm9ybWF0KFwibWluaW1hbFwiKSkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0cyA9IFtQYXJhbVR5cGUuZnJvbShcImJ5dGVzXCIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQobXV0YWJpbGl0eSA9PT0gXCJub25wYXlhYmxlXCIgfHwgbXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIsIFwiZmFsbGJhY2sgY2Fubm90IGJlIGNvbnN0YW50c1wiLCBcIm9iai5zdGF0ZU11dGFiaWxpdHlcIiwgbXV0YWJpbGl0eSk7XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInJldHVybnNcIl0pKS5oYXMoXCJyZXR1cm5zXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChvdXRwdXRzLmxlbmd0aCA9PT0gMSAmJiBvdXRwdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIG91dHB1dHNcIiwgXCJvYmoub3V0cHV0c1wiLCBvdXRwdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgaW5wdXRzLCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai50eXBlID09PSBcInJlY2VpdmVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgW10sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJmYWxsYmFja1wiKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBbUGFyYW1UeXBlLmZyb20oXCJieXRlc1wiKV07XG4gICAgICAgICAgICBjb25zdCBwYXlhYmxlID0gKG9iai5zdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIGlucHV0cywgcGF5YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBkZXNjcmlwdGlvblwiLCBcIm9ialwiLCBvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqRmFsbGJhY2tGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uRnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGlzIGNvbnN0YW50IChlLmcuIGBgcHVyZWBgIG9yIGBgdmlld2BgIGZ1bmN0aW9ucykuXG4gICAgICovXG4gICAgY29uc3RhbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSByZXR1cm5lZCB0eXBlcyBmb3IgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgb3V0cHV0cztcbiAgICAvKipcbiAgICAgKiAgVGhlIHN0YXRlIG11dGFiaWxpdHkgKGUuZy4gYGBwYXlhYmxlYGAsIGBgbm9ucGF5YWJsZWBgLCBgYHZpZXdgYFxuICAgICAqICBvciBgYHB1cmVgYClcbiAgICAgKi9cbiAgICBzdGF0ZU11dGFiaWxpdHk7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBjYW4gYmUgc2VudCB2YWx1ZSBkdXJpbmcgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcmVjb21tZW5kZWQgZ2FzIGxpbWl0IHRvIHNlbmQgd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZ2FzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBzdGF0ZU11dGFiaWxpdHksIGlucHV0cywgb3V0cHV0cywgZ2FzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImZ1bmN0aW9uXCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRnVuY3Rpb25GcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBvdXRwdXRzID0gT2JqZWN0LmZyZWV6ZShvdXRwdXRzLnNsaWNlKCkpO1xuICAgICAgICBjb25zdCBjb25zdGFudCA9IChzdGF0ZU11dGFiaWxpdHkgPT09IFwidmlld1wiIHx8IHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwdXJlXCIpO1xuICAgICAgICBjb25zdCBwYXlhYmxlID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgY29uc3RhbnQsIGdhcywgb3V0cHV0cywgcGF5YWJsZSwgc3RhdGVNdXRhYmlsaXR5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEZ1bmN0aW9uIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSkuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbnN0YW50OiB0aGlzLmNvbnN0YW50LFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKCh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpID8gdGhpcy5zdGF0ZU11dGFiaWxpdHkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICgodGhpcy5nYXMgIT0gbnVsbCkgPyB0aGlzLmdhcyA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cy5tYXAoKG8pID0+IEpTT04ucGFyc2Uoby5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc3RhdGVNdXRhYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dHMgJiYgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwicmV0dXJuc1wiKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5vdXRwdXRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHNlbGVjdG9yIGZvciBhIGZ1bmN0aW9uIHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFNlbGVjdG9yKG5hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHApKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG5hbWUsIFwidmlld1wiLCBwYXJhbXMsIFtdLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LnNlbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkZ1bmN0aW9uRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEZ1bmN0aW9uRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZ1bmN0aW9uIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImZ1bmN0aW9uXCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdCBtdXRhYmlsaXR5ID0gY29uc3VtZU11dGFiaWxpdHkob2JqKTtcbiAgICAgICAgICAgIGxldCBvdXRwdXRzID0gW107XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInJldHVybnNcIl0pKS5oYXMoXCJyZXR1cm5zXCIpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdhcyA9IGNvbnN1bWVHYXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG5hbWUsIG11dGFiaWxpdHksIGlucHV0cywgb3V0cHV0cywgZ2FzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGVNdXRhYmlsaXR5ID0gb2JqLnN0YXRlTXV0YWJpbGl0eTtcbiAgICAgICAgLy8gVXNlIGxlZ2FjeSBTb2xpZGl0eSBBQkkgbG9naWMgaWYgc3RhdGVNdXRhYmlsaXR5IGlzIG1pc3NpbmdcbiAgICAgICAgaWYgKHN0YXRlTXV0YWJpbGl0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG9iai5jb25zdGFudCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJ2aWV3XCI7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmouY29uc3RhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJwYXlhYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG9iai5wYXlhYmxlKSA9PT0gXCJib29sZWFuXCIgJiYgIW9iai5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob2JqLnBheWFibGUpID09PSBcImJvb2xlYW5cIiAmJiAhb2JqLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogdmVyaWZ5U3RhdGUgZm9yIHN0YXRlTXV0YWJpbGl0eSAoZS5nLiB0aHJvdyBpZlxuICAgICAgICAvLyAgICAgICAgcGF5YWJsZTogZmFsc2UgYnV0IHN0YXRlTXV0YWJpbGl0eSBpcyBcIm5vbnBheWFibGVcIilcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCBvYmoub3V0cHV0cyA/IG9iai5vdXRwdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgKG9iai5nYXMgIT0gbnVsbCkgPyBvYmouZ2FzIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipGdW5jdGlvbkZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgc3RydWN0dXJlLlxuICovXG5leHBvcnQgY2xhc3MgU3RydWN0RnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcInN0cnVjdFwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc3RydWN0IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipTdHJ1Y3RGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgc3RydWN0IGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcInN0cnVjdFwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10pO1xuICAgIH1cbiAgICAvLyBAVE9ETzogZml4IHRoaXMgcmV0dXJuIHR5cGVcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqU3RydWN0RnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gU3RydWN0RnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhZ21lbnRzLmpzLm1hcCIsIi8qKlxuICogIFdoZW4gc2VuZGluZyB2YWx1ZXMgdG8gb3IgcmVjZWl2aW5nIHZhbHVlcyBmcm9tIGEgW1tDb250cmFjdF1dLCB0aGVcbiAqICBkYXRhIGlzIGdlbmVyYWxseSBlbmNvZGVkIHVzaW5nIHRoZSBbQUJJIHN0YW5kYXJkXShsaW5rLXNvbGMtYWJpKS5cbiAqXG4gKiAgVGhlIEFiaUNvZGVyIHByb3ZpZGVzIGEgdXRpbGl0eSB0byBlbmNvZGUgdmFsdWVzIHRvIEFCSSBkYXRhIGFuZFxuICogIGRlY29kZSB2YWx1ZXMgZnJvbSBBQkkgZGF0YS5cbiAqXG4gKiAgTW9zdCBvZiB0aGUgdGltZSwgZGV2ZWxvcGVycyBzaG91bGQgZmF2b3VyIHRoZSBbW0NvbnRyYWN0XV0gY2xhc3MsXG4gKiAgd2hpY2ggZnVydGhlciBhYnN0cmFjdHMgYSBsb3Qgb2YgdGhlIGZpbmVyIGRldGFpbHMgb2YgQUJJIGRhdGEuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpBQkkgRW5jb2RpbmdcbiAqL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnRDb3VudCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFJlYWRlciwgV3JpdGVyIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBZGRyZXNzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWRkcmVzcy5qc1wiO1xuaW1wb3J0IHsgQXJyYXlDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hcnJheS5qc1wiO1xuaW1wb3J0IHsgQm9vbGVhbkNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2Jvb2xlYW4uanNcIjtcbmltcG9ydCB7IEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYnl0ZXMuanNcIjtcbmltcG9ydCB7IEZpeGVkQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9maXhlZC1ieXRlcy5qc1wiO1xuaW1wb3J0IHsgTnVsbENvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bGwuanNcIjtcbmltcG9ydCB7IE51bWJlckNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bWJlci5qc1wiO1xuaW1wb3J0IHsgU3RyaW5nQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvc3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBUdXBsZUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3R1cGxlLmpzXCI7XG5pbXBvcnQgeyBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnksIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbFxuY29uc3QgUGFuaWNSZWFzb25zID0gbmV3IE1hcCgpO1xuUGFuaWNSZWFzb25zLnNldCgweDAwLCBcIkdFTkVSSUNfUEFOSUNcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDEsIFwiQVNTRVJUX0ZBTFNFXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDExLCBcIk9WRVJGTE9XXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDEyLCBcIkRJVklERV9CWV9aRVJPXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDIxLCBcIkVOVU1fUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjIsIFwiQkFEX1NUT1JBR0VfREFUQVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMSwgXCJTVEFDS19VTkRFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MzIsIFwiQVJSQVlfUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4NDEsIFwiT1VUX09GX01FTU9SWVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg1MSwgXCJVTklOSVRJQUxJWkVEX0ZVTkNUSU9OX0NBTExcIik7XG5jb25zdCBwYXJhbVR5cGVCeXRlcyA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO1xuY29uc3QgcGFyYW1UeXBlTnVtYmVyID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKTtcbmxldCBkZWZhdWx0Q29kZXIgPSBudWxsO1xubGV0IGRlZmF1bHRNYXhJbmZsYXRpb24gPSAxMDI0O1xuZnVuY3Rpb24gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgYWJpQ29kZXIpIHtcbiAgICBsZXQgbWVzc2FnZSA9IFwibWlzc2luZyByZXZlcnQgZGF0YVwiO1xuICAgIGxldCByZWFzb24gPSBudWxsO1xuICAgIGNvbnN0IGludm9jYXRpb24gPSBudWxsO1xuICAgIGxldCByZXZlcnQgPSBudWxsO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcImV4ZWN1dGlvbiByZXZlcnRlZFwiO1xuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAobm8gZGF0YSBwcmVzZW50OyBsaWtlbHkgcmVxdWlyZShmYWxzZSkgb2NjdXJyZWRcIjtcbiAgICAgICAgICAgIHJlYXNvbiA9IFwicmVxdWlyZShmYWxzZSlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggJSAzMiAhPT0gNCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSByZWFzb247IGludmFsaWQgZGF0YSBsZW5ndGgpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHgwOGMzNzlhMFwiKSB7XG4gICAgICAgICAgICAvLyBFcnJvcihzdHJpbmcpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGFiaUNvZGVyLmRlY29kZShbXCJzdHJpbmdcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXTtcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlYXNvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtKU09OLnN0cmluZ2lmeShyZWFzb24pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBzdHJpbmcgZGF0YSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDRlNDg3YjcxXCIpIHtcbiAgICAgICAgICAgIC8vIFBhbmljKHVpbnQyNTYpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIoYWJpQ29kZXIuZGVjb2RlKFtcInVpbnQyNTZcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbY29kZV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGBQYW5pYyBkdWUgdG8gJHtQYW5pY1JlYXNvbnMuZ2V0KGNvZGUpIHx8IFwiVU5LTk9XTlwifSgke2NvZGV9KWA7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke3JlYXNvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSBwYW5pYyBjb2RlKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIHRvOiAodHgudG8gPyBnZXRBZGRyZXNzKHR4LnRvKSA6IG51bGwpLFxuICAgICAgICBkYXRhOiAodHguZGF0YSB8fCBcIjB4XCIpXG4gICAgfTtcbiAgICBpZiAodHguZnJvbSkge1xuICAgICAgICB0cmFuc2FjdGlvbi5mcm9tID0gZ2V0QWRkcmVzcyh0eC5mcm9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VFcnJvcihtZXNzYWdlLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgYWN0aW9uLCBkYXRhLCByZWFzb24sIHRyYW5zYWN0aW9uLCBpbnZvY2F0aW9uLCByZXZlcnRcbiAgICB9KTtcbn1cbi8qKlxuICogIFRoZSAqKkFiaUNvZGVyKiogaXMgYSBsb3ctbGV2ZWwgY2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY29kaW5nIEphdmFTY3JpcHRcbiAqICB2YWx1ZXMgaW50byBiaW5hcnkgZGF0YSBhbmQgZGVjb2RpbmcgYmluYXJ5IGRhdGEgaW50byBKYXZhU2NyaXB0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFiaUNvZGVyIHtcbiAgICAjZ2V0Q29kZXIocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvZGVyKHRoaXMuI2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLCBwYXJhbS5hcnJheUxlbmd0aCwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZUNvZGVyKHBhcmFtLmNvbXBvbmVudHMubWFwKChjKSA9PiB0aGlzLiNnZXRDb2RlcihjKSksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGFyYW0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkNvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdWxsQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdT9pbnRbMC05XSpcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBcIiArIG1hdGNoWzFdICsgXCIgYml0IGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5dGVzWzAtOV0rXG4gICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHBhcmFtLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlIGdpdmVuICUldHlwZXMlJS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSBgYHVpbnRgYCBpcyBieSBkZWZhdWx0IGBgMGBgIGFuZCBgYGJvb2xgYFxuICAgICAqICBpcyBieSBkZWZhdWx0IGBgZmFsc2VgYC5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0VmFsdWUodHlwZXMpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGUgdGhlICUldmFsdWVzJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIEFCSSBkYXRhLlxuICAgICAqXG4gICAgICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAgICAgKi9cbiAgICBlbmNvZGUodHlwZXMsIHZhbHVlcykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlcy5sZW5ndGgsIHR5cGVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIpO1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gKG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgICAgICBjb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgdGhlIEFCSSAlJWRhdGElJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlbG9vc2UlJSBkZWNvZGluZyBpcyBlbmFibGVkLCB0aGVuIHN0cmljdCBwYWRkaW5nIGlzXG4gICAgICogIG5vdCBlbmZvcmNlZC4gU29tZSBvbGRlciB2ZXJzaW9ucyBvZiBTb2xpZGl0eSBpbmNvcnJlY3RseVxuICAgICAqICBwYWRkZWQgZXZlbnQgZGF0YSBlbWl0dGVkIGZyb20gYGBleHRlcm5hbGBgIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBkZWNvZGUodHlwZXMsIGRhdGEsIGxvb3NlKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlY29kZShuZXcgUmVhZGVyKGRhdGEsIGxvb3NlLCBkZWZhdWx0TWF4SW5mbGF0aW9uKSk7XG4gICAgfVxuICAgIHN0YXRpYyBfc2V0RGVmYXVsdE1heEluZmxhdGlvbih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSwgXCJpbnZhbGlkIGRlZmF1bHRNYXhJbmZsYXRpb24gZmFjdG9yXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICBkZWZhdWx0TWF4SW5mbGF0aW9uID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzaGFyZWQgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgZGVmYXVsdCBbW0FiaUNvZGVyXV0uXG4gICAgICpcbiAgICAgKiAgT24gdGhlIGZpcnN0IGNhbGwsIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkIGludGVybmFsbHkuXG4gICAgICovXG4gICAgc3RhdGljIGRlZmF1bHRBYmlDb2RlcigpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDb2RlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q29kZXIgPSBuZXcgQWJpQ29kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdENvZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtY29tcGF0aWJsZSBbW0NhbGxFeGNlcHRpb25FcnJvcl1dIEVycm9yIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgcmVzdWx0ICUlZGF0YSUlIGZvciB0aGUgW1tDYWxsRXhjZXB0aW9uQWN0aW9uXV0gJSVhY3Rpb24lJSBhZ2FpbnN0XG4gICAgICogIHRoZSBUcmFuc2FjdGlvbiAlJXR4JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEsIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmktY29kZXIuanMubWFwIiwiLyoqXG4gKiAgVGhlIEludGVyZmFjZSBjbGFzcyBpcyBhIGxvdy1sZXZlbCBjbGFzcyB0aGF0IGFjY2VwdHMgYW5cbiAqICBBQkkgYW5kIHByb3ZpZGVzIGFsbCB0aGUgbmVjZXNzYXJ5IGZ1bmN0aW9uYWxpdHkgdG8gZW5jb2RlXG4gKiAgYW5kIGRlY29kZSBwYXJhbWF0ZXJzIHRvIGFuZCByZXN1bHRzIGZyb20gbWV0aG9kcywgZXZlbnRzXG4gKiAgYW5kIGVycm9ycy5cbiAqXG4gKiAgSXQgYWxzbyBwcm92aWRlcyBzZXZlcmFsIGNvbnZlbmllbmNlIG1ldGhvZHMgdG8gYXV0b21hdGljYWxseVxuICogIHNlYXJjaCBhbmQgZmluZCBtYXRjaGluZyB0cmFuc2FjdGlvbnMgYW5kIGV2ZW50cyB0byBwYXJzZSB0aGVtLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL2FiaTpJbnRlcmZhY2VzICBbaW50ZXJmYWNlc11cbiAqL1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhU2xpY2UsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSwgemVyb1BhZEJ5dGVzLCB6ZXJvUGFkVmFsdWUsIGlzSGV4U3RyaW5nLCBkZWZpbmVQcm9wZXJ0aWVzLCBhc3NlcnRBcmd1bWVudCwgdG9CZUhleCwgYXNzZXJ0IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBBYmlDb2RlciB9IGZyb20gXCIuL2FiaS1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgY2hlY2tSZXN1bHRFcnJvcnMsIFJlc3VsdCB9IGZyb20gXCIuL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgQ29uc3RydWN0b3JGcmFnbWVudCwgRXJyb3JGcmFnbWVudCwgRXZlbnRGcmFnbWVudCwgRnJhZ21lbnQsIEZ1bmN0aW9uRnJhZ21lbnQsIFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50cy5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi90eXBlZC5qc1wiO1xuZXhwb3J0IHsgY2hlY2tSZXN1bHRFcnJvcnMsIFJlc3VsdCB9O1xuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VMb2ddXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIGEgTG9nIHRvIGl0cyBldmVudFxuICogIGZvciBwYXJzaW5nLCBhICoqTG9nRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZ0Rlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZvciB0aGUgYGB0b3BpYzBgYC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEV2ZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3BpYyBoYXNoIGZvciB0aGUgRXZlbnQuXG4gICAgICovXG4gICAgdG9waWM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIEV2ZW50IHdpdGggYGBlbWl0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHRvcGljLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgc2lnbmF0dXJlLCB0b3BpYywgYXJnc1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZVRyYW5zYWN0aW9uXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaFxuICogIGEgdHJhbnNhY3Rpb24gZGF0YSB0byBpdHMgZnVuY3Rpb24gZm9yIHBhcnNpbmcsXG4gKiAgYSAqKlRyYW5zYWN0aW9uRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRnVuY3Rpb24gc2lnbmF0dXJlIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbGVjdG9yIGZvciB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgc2VsZWN0b3I7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHZhbHVlYGAgKGluIHdlaSkgZnJvbSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCBzZWxlY3RvciwgYXJncywgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBhcmdzLCBzaWduYXR1cmUsIHNlbGVjdG9yLCB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZUVycm9yXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaCBhblxuICogIGVycm9yIGZvciBhIGNhbGwgcmVzdWx0IGZvciBwYXJzaW5nLCBhbiAqKkVycm9yRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgRXJyb3Igd2l0aCBgYHJldmVydGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEVycm9yIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEVycm9yLlxuICAgICAqL1xuICAgIHNlbGVjdG9yO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBhcmdzLCBzaWduYXR1cmUsIHNlbGVjdG9yXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqSW5kZXhlZCoqIGlzIHVzZWQgYXMgYSB2YWx1ZSB3aGVuIGEgdmFsdWUgdGhhdCBkb2VzIG5vdFxuICogIGZpdCB3aXRoaW4gYSB0b3BpYyAoaS5lLiBub3QgYSBmaXhlZC1sZW5ndGgsIDMyLWJ5dGUgdHlwZSkuIEl0XG4gKiAgaXMgdGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlLCBhbmQgdXNlZCBmb3IgdHlwZXMgc3VjaCBhc1xuICogIGFycmF5cywgdHVwbGVzLCBieXRlcyBhbmQgc3RyaW5ncy5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZGV4ZWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgYGBrZWNjYWsyNTZgYCBvZiB0aGUgdmFsdWUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF9pc0luZGV4ZWQ7XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSV2YWx1ZSUlIGlzIGFuICoqSW5kZXhlZCoqLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIGZvciBwcm9wZXJ0eSBhY2Nlc3MuXG4gICAgICovXG4gICAgc3RhdGljIGlzSW5kZXhlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzSW5kZXhlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihoYXNoKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBoYXNoLCBfaXNJbmRleGVkOiB0cnVlIH0pO1xuICAgIH1cbn1cbi8vIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTMvY29udHJvbC1zdHJ1Y3R1cmVzLmh0bWw/aGlnaGxpZ2h0PXBhbmljI3BhbmljLXZpYS1hc3NlcnQtYW5kLWVycm9yLXZpYS1yZXF1aXJlXG5jb25zdCBQYW5pY1JlYXNvbnMgPSB7XG4gICAgXCIwXCI6IFwiZ2VuZXJpYyBwYW5pY1wiLFxuICAgIFwiMVwiOiBcImFzc2VydChmYWxzZSlcIixcbiAgICBcIjE3XCI6IFwiYXJpdGhtZXRpYyBvdmVyZmxvd1wiLFxuICAgIFwiMThcIjogXCJkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiLFxuICAgIFwiMzNcIjogXCJlbnVtIG92ZXJmbG93XCIsXG4gICAgXCIzNFwiOiBcImludmFsaWQgZW5jb2RlZCBzdG9yYWdlIGJ5dGUgYXJyYXkgYWNjZXNzZWRcIixcbiAgICBcIjQ5XCI6IFwib3V0LW9mLWJvdW5kcyBhcnJheSBhY2Nlc3M7IHBvcHBpbmcgb24gYW4gZW1wdHkgYXJyYXlcIixcbiAgICBcIjUwXCI6IFwib3V0LW9mLWJvdW5kcyBhY2Nlc3Mgb2YgYW4gYXJyYXkgb3IgYnl0ZXNOXCIsXG4gICAgXCI2NVwiOiBcIm91dCBvZiBtZW1vcnlcIixcbiAgICBcIjgxXCI6IFwidW5pbml0aWFsaXplZCBmdW5jdGlvblwiLFxufTtcbmNvbnN0IEJ1aWx0aW5FcnJvcnMgPSB7XG4gICAgXCIweDA4YzM3OWEwXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIixcbiAgICAgICAgbmFtZTogXCJFcnJvclwiLFxuICAgICAgICBpbnB1dHM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgcmVhc29uOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGByZXZlcnRlZCB3aXRoIHJlYXNvbiBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlKX1gO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcIjB4NGU0ODdiNzFcIjoge1xuICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICBpbnB1dHM6IFtcInVpbnQyNTZcIl0sXG4gICAgICAgIHJlYXNvbjogKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZWFzb24gPSBcInVua25vd24gcGFuaWMgY29kZVwiO1xuICAgICAgICAgICAgaWYgKGNvZGUgPj0gMCAmJiBjb2RlIDw9IDB4ZmYgJiYgUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV0pIHtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBQYW5pY1JlYXNvbnNbY29kZS50b1N0cmluZygpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCBwYW5pYyBjb2RlIDB4JHtjb2RlLnRvU3RyaW5nKDE2KX0gKCR7cmVhc29ufSlgO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogIEFuIEludGVyZmFjZSBhYnN0cmFjdHMgbWFueSBvZiB0aGUgbG93LWxldmVsIGRldGFpbHMgZm9yXG4gKiAgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHRoZSBkYXRhIG9uIHRoZSBibG9ja2NoYWluLlxuICpcbiAqICBBbiBBQkkgcHJvdmlkZXMgaW5mb3JtYXRpb24gb24gaG93IHRvIGVuY29kZSBkYXRhIHRvIHNlbmQgdG9cbiAqICBhIENvbnRyYWN0LCBob3cgdG8gZGVjb2RlIHRoZSByZXN1bHRzIGFuZCBldmVudHMgYW5kIGhvdyB0b1xuICogIGludGVycHJldCByZXZlcnQgZXJyb3JzLlxuICpcbiAqICBUaGUgQUJJIGNhbiBiZSBzcGVjaWZpZWQgYnkgW2FueSBzdXBwb3J0ZWQgZm9ybWF0XShJbnRlcmZhY2VBYmkpLlxuICovXG5leHBvcnQgY2xhc3MgSW50ZXJmYWNlIHtcbiAgICAvKipcbiAgICAgKiAgQWxsIHRoZSBDb250cmFjdCBBQkkgbWVtYmVycyAoaS5lLiBtZXRob2RzLCBldmVudHMsIGVycm9ycywgZXRjKS5cbiAgICAgKi9cbiAgICBmcmFnbWVudHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBkZXBsb3k7XG4gICAgLyoqXG4gICAgICogIFRoZSBGYWxsYmFjayBtZXRob2QsIGlmIGFueS5cbiAgICAgKi9cbiAgICBmYWxsYmFjaztcbiAgICAvKipcbiAgICAgKiAgSWYgcmVjZWl2aW5nIGV0aGVyIGlzIHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICByZWNlaXZlO1xuICAgICNlcnJvcnM7XG4gICAgI2V2ZW50cztcbiAgICAjZnVuY3Rpb25zO1xuICAgIC8vICAgICNzdHJ1Y3RzOiBNYXA8c3RyaW5nLCBTdHJ1Y3RGcmFnbWVudD47XG4gICAgI2FiaUNvZGVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgSW50ZXJmYWNlIGZvciB0aGUgJSVmcmFnbWVudHMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGFiaSA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudHMpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhYmkgPSBKU09OLnBhcnNlKGZyYWdtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhYmkgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZnVuY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNlcnJvcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2V2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gICAgICAgIHRoaXMuI3N0cnVjdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGZyYWdzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBhYmkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnJhZ3MucHVzaChGcmFnbWVudC5mcm9tKGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbV2FybmluZ10gSW52YWxpZCBGcmFnbWVudCAke0pTT04uc3RyaW5naWZ5KGEpfTpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50czogT2JqZWN0LmZyZWV6ZShmcmFncylcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGxldCByZWNlaXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2FiaUNvZGVyID0gdGhpcy5nZXRBYmlDb2RlcigpO1xuICAgICAgICAvLyBBZGQgYWxsIGZyYWdtZW50cyBieSB0aGVpciBzaWduYXR1cmVcbiAgICAgICAgdGhpcy5mcmFnbWVudHMuZm9yRWFjaCgoZnJhZ21lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgYnVja2V0O1xuICAgICAgICAgICAgc3dpdGNoIChmcmFnbWVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZGVwbG95OiBmcmFnbWVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghZmFsbGJhY2sgfHwgZnJhZ21lbnQucGF5YWJsZSAhPT0gZmFsbGJhY2sucGF5YWJsZSwgXCJjb25mbGljdGluZyBmYWxsYmFjayBmcmFnbWVudHNcIiwgYGZyYWdtZW50c1ske2luZGV4fV1gLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjayA9IGZyYWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZSA9IGZhbGxiYWNrLnBheWFibGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcIm91dHB1dFwiLCAoPEZ1bmN0aW9uRnJhZ21lbnQ+ZnJhZ21lbnQpLm91dHB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNmdW5jdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUd28gaWRlbnRpY2FsIGVudHJpZXM7IGlnbm9yZSBpdFxuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgICAgICBpZiAoYnVja2V0LmhhcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVja2V0LnNldChzaWduYXR1cmUsIGZyYWdtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlIGEgY29uc3RydWN0b3IgYWRkIGEgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuZGVwbG95KSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBkZXBsb3k6IENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShcImNvbnN0cnVjdG9yKClcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmYWxsYmFjaywgcmVjZWl2ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGVudGlyZSBIdW1hbi1SZWFkYWJsZSBBQkksIGFzIGFuIGFycmF5IG9mXG4gICAgICogIHNpZ25hdHVyZXMsIG9wdGlvbmFsbHkgYXMgJSVtaW5pbWFsJSUgc3RyaW5ncywgd2hpY2hcbiAgICAgKiAgcmVtb3ZlcyBwYXJhbWV0ZXIgbmFtZXMgYW5kIHVubmVjZWVzYXJ5IHNwYWNlcy5cbiAgICAgKi9cbiAgICBmb3JtYXQobWluaW1hbCkge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSAobWluaW1hbCA/IFwibWluaW1hbFwiIDogXCJmdWxsXCIpO1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KGZvcm1hdCkpO1xuICAgICAgICByZXR1cm4gYWJpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBKU09OLWVuY29kZWQgQUJJLiBUaGlzIGlzIHRoZSBmb3JtYXQgU29saWRpeVxuICAgICAqICByZXR1cm5zLlxuICAgICAqL1xuICAgIGZvcm1hdEpzb24oKSB7XG4gICAgICAgIGNvbnN0IGFiaSA9IHRoaXMuZnJhZ21lbnRzLm1hcCgoZikgPT4gZi5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZS1idW5kbGUgdGhlIEpTT04gZnJhZ21lbnRzIGEgYml0XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhYmkubWFwKChqKSA9PiBKU09OLnBhcnNlKGopKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQUJJIGNvZGVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGVuY29kZSBhbmQgZGVjb2RlIGJpbmFyeVxuICAgICAqICBkYXRhLlxuICAgICAqL1xuICAgIGdldEFiaUNvZGVyKCkge1xuICAgICAgICByZXR1cm4gQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCk7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEZ1bmN0aW9uKGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBTZWxlY3RvclxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZnVuY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9ICh2YWx1ZXMubGVuZ3RoID4gMCkgPyB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBhbGxvd09wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChUeXBlZC5pc1R5cGVkKGxhc3RWYWx1ZSkgJiYgbGFzdFZhbHVlLnR5cGUgPT09IFwib3ZlcnJpZGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPcHRpb25zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlTGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wYXRpYmxlIGxlbmd0aC4gVGhlIGFyZ3NcbiAgICAgICAgICAgICAgICAvLyBtYXkgY29udGFpbiBhbiBvdmVycmlkZXMsIHNvIHRoZSBtYXRjaCBtYXkgaGF2ZSBuIG9yIG4gLSAxIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cyAhPT0gdmFsdWVMZW5ndGggJiYgKCFhbGxvd09wdGlvbnMgfHwgaW5wdXRzICE9PSB2YWx1ZUxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIFR5cGVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB0eXBlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFUeXBlZC5pc1R5cGVkKHZhbHVlc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBwYXN0IHRoZSBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID49IGlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgPT09IFwib3ZlcnJpZGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmFsdWUgdHlwZSBtYXRjaGVzIHRoZSBpbnB1dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgIT09IGlucHV0c1tqXS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgc2luZ2xlIG1hdGNoaW5nIHNpZ25hdHVyZSB3aXRoIGFuIG92ZXJyaWRlcywgYnV0IHRoZVxuICAgICAgICAgICAgLy8gbGFzdCB2YWx1ZSBpcyBzb21ldGhpbmcgdGhhdCBjYW5ub3QgcG9zc2libHkgYmUgYW4gb3B0aW9uc1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCAhPT0gbWF0Y2hpbmdbMF0uaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RBcmcgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0QXJnID09IG51bGwgfHwgQXJyYXkuaXNBcnJheShsYXN0QXJnKSB8fCB0eXBlb2YgKGxhc3RBcmcpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZSgwLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGZ1bmN0aW9uIGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdW5jdGlvbnMuZ2V0KEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZnVuY3Rpb24gbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb24gc2VsZWN0b3IsXG4gICAgICogIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uTmFtZShrZXkpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLiNnZXRGdW5jdGlvbihrZXksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnVuY3Rpb25cIiwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50Lm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVrZXklJSAoYSBmdW5jdGlvbiBzZWxlY3RvciwgZnVuY3Rpb24gbmFtZSBvclxuICAgICAqICBmdW5jdGlvbiBzaWduYXR1cmUpIGlzIHByZXNlbnQgaW4gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJbiB0aGUgY2FzZSBvZiBhIGZ1bmN0aW9uIG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tGdW5jdGlvbkZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNGdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSBmdW5jdGlvblxuICAgICAqICBzZWxlY3RvciwgZnVuY3Rpb24gbmFtZSBvciBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGZ1bmN0aW9ucyBtYXRjaCBieSBuYW1lLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZnVuY3Rpb24gaW5cbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRGdW5jdGlvbihrZXksIHZhbHVlcyB8fCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZnVuY3Rpb25zLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG4gICAgZm9yRWFjaEZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNmdW5jdGlvbnMua2V5cygpKTtcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2Z1bmN0aW9ucy5nZXQobmFtZSkpLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGaW5kIGFuIGV2ZW50IGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcbiAgICAjZ2V0RXZlbnQoa2V5LCB2YWx1ZXMsIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgIC8vIEV2ZW50VG9waWNcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VG9waWMgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXZlbnRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VG9waWMgPT09IGZyYWdtZW50LnRvcGljSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wYXRpYmxlIGxlbmd0aC5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIFR5cGVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB0eXBlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFUeXBlZC5pc1R5cGVkKHZhbHVlc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmFsdWUgdHlwZSBtYXRjaGVzIHRoZSBpbnB1dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2pdLnR5cGUgIT09IGlucHV0c1tqXS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPiAxICYmIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZXZlbnQgZGVzY3JpcHRpb24gKGkuZS4gbWF0Y2hlcyAke21hdGNoU3RyfSlgLCBcImtleVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2V2ZW50cy5nZXQoRXZlbnRGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBldmVudCBuYW1lIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRFdmVudE5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGFuIGV2ZW50IHRvcGljIGhhc2gsIGV2ZW50IG5hbWUgb3JcbiAgICAgKiAgZXZlbnQgc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYW4gZXZlbnQgbmFtZSwgdGhlIG5hbWUgbWF5IGJlIGFtYmlndW91cywgc29cbiAgICAgKiAgYWNjZXNzaW5nIHRoZSBbW0V2ZW50RnJhZ21lbnRdXSBtYXkgcmVxdWlyZSByZWZpbmVtZW50LlxuICAgICAqL1xuICAgIGhhc0V2ZW50KGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNnZXRFdmVudChrZXksIG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgW1tFdmVudEZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIHRvcGljIGhhc2gsXG4gICAgICogIGV2ZW50IG5hbWUgb3IgZXZlbnQgc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBldmVudHMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGV2ZW50IGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFdmVudChrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RXZlbnQoa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGV2ZW50cywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFdmVudChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXZlbnRzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNldmVudHMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgW1tFcnJvckZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhbiBlcnJvclxuICAgICAqICBzZWxlY3RvciwgZXJyb3IgbmFtZSBvciBlcnJvciBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGVycm9ycyBtYXRjaCBieSBuYW1lLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZXJyb3IgaW5cbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldEVycm9yKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKEJ1aWx0aW5FcnJvcnNbc2VsZWN0b3JdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShCdWlsdGluRXJyb3JzW3NlbGVjdG9yXS5zaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiB0aGlzLiNlcnJvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IGZyYWdtZW50LnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNlcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBFcnJvcihzdHJpbmcpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIFBhbmljKHVpbnQyNTYpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBlcnJvciBkZXNjcmlwdGlvbiAoaS5lLiAke21hdGNoU3RyfSlgLCBcIm5hbWVcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBrZXkgPSBFcnJvckZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJFcnJvcihzdHJpbmcpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBFcnJvcihzdHJpbmcpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IFwiUGFuaWModWludDI1NilcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIFBhbmljKHVpbnQyNTYpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Vycm9ycy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZXJyb3JzLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG4gICAgZm9yRWFjaEVycm9yKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNlcnJvcnMua2V5cygpKTtcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2Vycm9ycy5nZXQobmFtZSkpLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHZXQgdGhlIDQtYnl0ZSBzZWxlY3RvciB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGEgZnVuY3Rpb25cbiAgICAvKlxuZ2V0U2VsZWN0b3IoZnJhZ21lbnQ6IEVycm9yRnJhZ21lbnQgfCBGdW5jdGlvbkZyYWdtZW50KTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBtYXRjaGVzOiBBcnJheTxGcmFnbWVudD4gPSBbIF07XG5cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpKTsgfSBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB0cnkgeyBtYXRjaGVzLnB1c2godGhpcy5nZXRFcnJvcig8c3RyaW5nPmZyYWdtZW50KSk7IH0gY2F0Y2ggKF8pIHsgfVxuXG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVua25vd24gZnJhZ21lbnRcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFtYmlndW91cyBmcmFnbWVudCBtYXRjaGVzIGZ1bmN0aW9uIGFuZCBlcnJvclwiLCBcImtleVwiLCBmcmFnbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCA9IG1hdGNoZXNbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFTbGljZShpZChmcmFnbWVudC5mb3JtYXQoKSksIDAsIDQpO1xufVxuICAgICovXG4gICAgLy8gR2V0IHRoZSAzMi1ieXRlIHRvcGljIGhhc2ggdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhbiBldmVudFxuICAgIC8qXG4gICAgZ2V0RXZlbnRUb3BpYyhmcmFnbWVudDogRXZlbnRGcmFnbWVudCk6IHN0cmluZyB7XG4gICAgICAgIC8vaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHsgZnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpOyB9XG4gICAgICAgIHJldHVybiBpZChmcmFnbWVudC5mb3JtYXQoKSk7XG4gICAgfVxuICAgICovXG4gICAgX2RlY29kZVBhcmFtcyhwYXJhbXMsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmRlY29kZShwYXJhbXMsIGRhdGEpO1xuICAgIH1cbiAgICBfZW5jb2RlUGFyYW1zKHBhcmFtcywgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5lbmNvZGUocGFyYW1zLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyBhIGBgdHguZGF0YWBgIG9iamVjdCBmb3IgZGVwbG95aW5nIHRoZSBDb250cmFjdCB3aXRoXG4gICAgICogIHRoZSAlJXZhbHVlcyUlIGFzIHRoZSBjb25zdHJ1Y3RvciBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZW5jb2RlRGVwbG95KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMuZGVwbG95LmlucHV0cywgdmFsdWVzIHx8IFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZXJyb3IgKHNlZSBbW2dldEVycm9yXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGVycm9yXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFTbGljZShkYXRhLCAwLCA0KSA9PT0gZnJhZ21lbnQuc2VsZWN0b3IsIGBkYXRhIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBlcnJvciAke2ZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShkYXRhLCA0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIHRoZSB0cmFuc2FjdGlvbiByZXZlcnQgZGF0YSBmb3IgYSBjYWxsIHJlc3VsdCB0aGF0XG4gICAgICogIHJldmVydGVkIGZyb20gdGhlIHRoZSBDb250cmFjdCB3aXRoIHRoZSBzZXBjaWZpZWQgJSVlcnJvciUlXG4gICAgICogIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aCB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRXJyb3JSZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlICUlZGF0YSUlIGZyb20gYSB0cmFuc2FjdGlvbiBgYHR4LmRhdGFgYCBmb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIHNwZWNpZmllZCAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlVHJhbnNhY3Rpb25dXSBtZXRob2RcbiAgICAgKiAgaW5zdGVhZCwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZGVjb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFTbGljZShkYXRhLCAwLCA0KSA9PT0gZnJhZ21lbnQuc2VsZWN0b3IsIGBkYXRhIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBmdW5jdGlvbiAke2ZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShkYXRhLCA0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIHRoZSBgYHR4LmRhdGFgYCBmb3IgYSB0cmFuc2FjdGlvbiB0aGF0IGNhbGxzIHRoZSBmdW5jdGlvblxuICAgICAqICBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3IgJSVmcmFnbWVudCUlKSB3aXRoXG4gICAgICogIHRoZSAlJXZhbHVlcyUlLlxuICAgICAqL1xuICAgIGVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgZnJhZ21lbnQuc2VsZWN0b3IsXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCB2YWx1ZXMgfHwgW10pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlcyB0aGUgcmVzdWx0ICUlZGF0YSUlIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzIGZvclxuICAgICAqICAlJWtleSUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZUNhbGxSZXN1bHRdXSBtZXRob2QgaW5zdGVhZCxcbiAgICAgKiAgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCBhIGBgQ0FMTF9FWENFUFRJT05gYCBhbmQgdGhyb3cgdGhlXG4gICAgICogIGNvcnJlc3BvbmRpbmcgZXJyb3IuXG4gICAgICovXG4gICAgZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcImludmFsaWQgbGVuZ3RoIGZvciByZXN1bHQgZGF0YVwiO1xuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzQ29weShkYXRhKTtcbiAgICAgICAgaWYgKChieXRlcy5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5vdXRwdXRzLCBieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJjb3VsZCBub3QgZGVjb2RlIHJlc3VsdCBkYXRhXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCByZXR1cm5lZCBkYXRhIHdpdGggbm8gZXJyb3IsIGJ1dCB0aGUgZGF0YSBpcyBqdW5rXG4gICAgICAgIGFzc2VydChmYWxzZSwgbWVzc2FnZSwgXCJCQURfREFUQVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogaGV4bGlmeShieXRlcyksXG4gICAgICAgICAgICBpbmZvOiB7IG1ldGhvZDogZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYWtlRXJyb3IoX2RhdGEsIHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgICAgICBjb25zdCBlcnJvciA9IEFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKFwiY2FsbFwiLCB0eCwgZGF0YSk7XG4gICAgICAgIC8vIE5vdCBhIGJ1aWx0LWluIGVycm9yOyB0cnkgZmluZGluZyBhIGN1c3RvbSBlcnJvclxuICAgICAgICBjb25zdCBjdXN0b21QcmVmaXggPSBcImV4ZWN1dGlvbiByZXZlcnRlZCAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoY3VzdG9tUHJlZml4KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBoZXhsaWZ5KGRhdGEuc2xpY2UoMCwgNCkpO1xuICAgICAgICAgICAgY29uc3QgZWYgPSB0aGlzLmdldEVycm9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChlZikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZWYuaW5wdXRzLCBkYXRhLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWYubmFtZSwgc2lnbmF0dXJlOiBlZi5mb3JtYXQoKSwgYXJnc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5yZWFzb24gPSBlcnJvci5yZXZlcnQuc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYGV4ZWN1dGlvbiByZXZlcnRlZDogJHtlcnJvci5yZWFzb259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQgKGNvdWx0IG5vdCBkZWNvZGUgY3VzdG9tIGVycm9yKWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgaW52b2NhdGlvbiwgaWYgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIGVycm9yLmludm9jYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwYXJzZWQubmFtZSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHBhcnNlZC5zaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgYXJnczogcGFyc2VkLmFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgcmVzdWx0IGRhdGEgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGZ1bmN0aW9uIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXNcbiAgICAgKiAgZm9yICUlZnJhZ21lbnQlJSkgd2l0aCAlJXZhbHVlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VkIGJ5IG1vc3QgZGV2ZWxvcGVycywgdW5sZXNzIHRyeWluZyB0byBtb2NrXG4gICAgICogIGEgcmVzdWx0IGZyb20gYSBDb250cmFjdC5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHRoaXMuI2FiaUNvZGVyLmVuY29kZShmcmFnbWVudC5vdXRwdXRzLCB2YWx1ZXMgfHwgW10pKTtcbiAgICB9XG4gICAgLypcbiAgICAgICAgc3BlbHVuayhpbnB1dHM6IEFycmF5PFBhcmFtVHlwZT4sIHZhbHVlczogUmVhZG9ubHlBcnJheTxhbnk+LCBwcm9jZXNzZnVuYzogKHR5cGU6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gUHJvbWlzZTxhbnk+KTogUHJvbWlzZTxBcnJheTxhbnk+PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlczogQXJyYXk8UHJvbWlzZTw+PiA9IFsgXTtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3MgPSBmdW5jdGlvbih0eXBlOiBQYXJhbVR5cGUsIHZhbHVlOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NlbmQodHlwZS5jaGlsZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZS4gPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IGRlc2NlbmQgPSBmdW5jdGlvbiAoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55Pikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7IHRocm93IG5ldyBFcnJvcihcImxlbmd0aCBtaXNtYXRjaFwiKTsgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8YW55PiA9IFsgXTtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHZhbHVlLm1hcCgodmFsdWUpID0+IGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICovXG4gICAgLy8gQ3JlYXRlIHRoZSBmaWx0ZXIgZm9yIHRoZSBldmVudCB3aXRoIHNlYXJjaCBjcml0ZXJpYSAoZS5nLiBmb3IgZXRoX2ZpbHRlckxvZylcbiAgICBlbmNvZGVGaWx0ZXJUb3BpY3MoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh2YWx1ZXMubGVuZ3RoIDw9IGZyYWdtZW50LmlucHV0cy5sZW5ndGgsIGB0b28gbWFueSBhcmd1bWVudHMgZm9yICR7ZnJhZ21lbnQuZm9ybWF0KCl9YCwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHsgY291bnQ6IHZhbHVlcy5sZW5ndGgsIGV4cGVjdGVkQ291bnQ6IGZyYWdtZW50LmlucHV0cy5sZW5ndGggfSk7XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogVXNlIHRoZSBjb2RlcnMgZm9yIHRoaXM7IHRvIHByb3Blcmx5IHN1cHBvcnQgdHVwbGVzLCBldGMuXG4gICAgICAgIGNvbnN0IGVuY29kZVRvcGljID0gKHBhcmFtLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihoZXhsaWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJib29sXCIgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgPyBcIjB4MDFcIiA6IFwiMHgwMFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0JlSGV4KHZhbHVlKTsgLy8gQFRPRE86IFNob3VsZCB0aGlzIHRvVHdvcz8/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9eYnl0ZXMvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gemVyb1BhZEJ5dGVzKHZhbHVlLCAzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGFkZHJlc3NlcyBhcmUgdmFsaWRcbiAgICAgICAgICAgICAgICB0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW1wiYWRkcmVzc1wiXSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZFZhbHVlKGhleGxpZnkodmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gZnJhZ21lbnQuaW5wdXRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghcGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID09IG51bGwsIFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyaW0gb2ZmIHRyYWlsaW5nIG51bGxzXG4gICAgICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRvcGljcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9waWNzO1xuICAgIH1cbiAgICBlbmNvZGVFdmVudExvZyhmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGV2ZW50XCIsIFwiZXZlbnRGcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9waWNzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVmFsdWVzID0gW107XG4gICAgICAgIGlmICghZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICB0b3BpY3MucHVzaChmcmFnbWVudC50b3BpY0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlcy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGgsIFwiZXZlbnQgYXJndW1lbnRzL3ZhbHVlcyBtaXNtYXRjaFwiLCBcInZhbHVlc1wiLCB2YWx1ZXMpO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGlkKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChrZWNjYWsyNTYodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuI2FiaUNvZGVyLmVuY29kZShbcGFyYW0udHlwZV0sIFt2YWx1ZV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZGF0YVZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZGF0YVR5cGVzLCBkYXRhVmFsdWVzKSxcbiAgICAgICAgICAgIHRvcGljczogdG9waWNzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIERlY29kZSBhIGZpbHRlciBmb3IgdGhlIGV2ZW50IGFuZCB0aGUgc2VhcmNoIGNyaXRlcmlhXG4gICAgZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGRhdGEsIHRvcGljcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3BpY3MgIT0gbnVsbCAmJiAhZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodG9waWNzWzBdLCAzMikgJiYgdG9waWNzWzBdLnRvTG93ZXJDYXNlKCkgPT09IGV2ZW50VG9waWMsIFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIiwgXCJ0b3BpY3NbMF1cIiwgdG9waWNzWzBdKTtcbiAgICAgICAgICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IG5vbkluZGV4ZWQgPSBbXTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IFtdO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiIHx8IHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKFBhcmFtVHlwZS5mcm9tKHsgdHlwZTogXCJieXRlczMyXCIsIG5hbWU6IHBhcmFtLm5hbWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vbkluZGV4ZWQucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdEluZGV4ZWQgPSAodG9waWNzICE9IG51bGwpID8gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGluZGV4ZWQsIGNvbmNhdCh0b3BpY3MpKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdE5vbkluZGV4ZWQgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUobm9uSW5kZXhlZCwgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIC8vY29uc3QgcmVzdWx0OiAoQXJyYXk8YW55PiAmIHsgWyBrZXk6IHN0cmluZyBdOiBhbnkgfSkgPSBbIF07XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIGxldCBub25JbmRleGVkSW5kZXggPSAwLCBpbmRleGVkSW5kZXggPSAwO1xuICAgICAgICBmcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0SW5kZXhlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEluZGV4ZWQobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEluZGV4ZWQocmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHROb25JbmRleGVkW25vbkluZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAga2V5cy5wdXNoKHBhcmFtLm5hbWUgfHwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGFyc2VzIGEgdHJhbnNhY3Rpb24sIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGFuZCBleHRyYWN0c1xuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBmdW5jdGlvbiBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBjYW5ub3QgYmUgZm91bmQsIHJldHVybiBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKHR4LmRhdGEsIFwidHguZGF0YVwiKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoKHR4LnZhbHVlICE9IG51bGwpID8gdHgudmFsdWUgOiAwLCBcInR4LnZhbHVlXCIpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oaGV4bGlmeShkYXRhLnNsaWNlKDAsIDQpKSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhLnNsaWNlKDQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC5zZWxlY3RvciwgYXJncywgdmFsdWUpO1xuICAgIH1cbiAgICBwYXJzZUNhbGxSZXN1bHQoZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHJlY2VpcHQgbG9nLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBldmVudCBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZXZlbnQgZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZXZlbnQgY2Fubm90IGJlIGZvdW5kLCByZXR1cm5zIG51bGwuXG4gICAgICovXG4gICAgcGFyc2VMb2cobG9nKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCB8fCBmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBJZiBhbm9ueW1vdXMsIGFuZCB0aGUgb25seSBtZXRob2QsIGFuZCB0aGUgaW5wdXQgY291bnQgbWF0Y2hlcywgc2hvdWxkIHdlIHBhcnNlP1xuICAgICAgICAvLyAgICAgICAgUHJvYmFibHkgbm90LCBiZWNhdXNlIGp1c3QgYmVjYXVzZSBpdCBpcyB0aGUgb25seSBldmVudCBpbiB0aGUgQUJJIGRvZXNcbiAgICAgICAgLy8gICAgICAgIG5vdCBtZWFuIHdlIGhhdmUgdGhlIGZ1bGwgQUJJOyBtYXliZSBqdXN0IGEgZnJhZ21lbnQ/XG4gICAgICAgIHJldHVybiBuZXcgTG9nRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnRvcGljSGFzaCwgdGhpcy5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHJldmVydCBkYXRhLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBlcnJvciBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZXJyb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZXJyb3IgY2Fubm90IGJlIGZvdW5kLCByZXR1cm5zIG51bGwuXG4gICAgICovXG4gICAgcGFyc2VFcnJvcihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhleERhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXJyb3IoZGF0YVNsaWNlKGhleERhdGEsIDAsIDQpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIGRhdGFTbGljZShoZXhEYXRhLCA0KSk7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JEZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ludGVyZmFjZV1dIGZyb20gdGhlIEFCSSAlJXZhbHVlJSUuXG4gICAgICpcbiAgICAgKiAgVGhlICUldmFsdWUlJSBtYXkgYmUgcHJvdmlkZWQgYXMgYW4gZXhpc3RpbmcgW1tJbnRlcmZhY2VdXSBvYmplY3QsXG4gICAgICogIGEgSlNPTi1lbmNvZGVkIEFCSSBvciBhbnkgSHVtYW4tUmVhZGFibGUgQUJJIGZvcm1hdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICAvLyBBbHJlYWR5IGFuIEludGVyZmFjZSwgd2hpY2ggaXMgaW1tdXRhYmxlXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVyZmFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEpTT05cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQW4gSW50ZXJmYWNlOyBwb3NzaWJseSBmcm9tIGFub3RoZXIgdjYgaW5zdGFuY2VcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUuZm9ybWF0SnNvbikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUuZm9ybWF0SnNvbigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIGxlZ2FjeSBJbnRlcmZhY2U7IGZyb20gYW4gb2xkZXIgdmVyc2lvblxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZS5mb3JtYXQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIGZyYWdtZW50c1xuICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsIi8vaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGlzQnl0ZXNMaWtlLCByZXNvbHZlUHJvcGVydGllcywgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNFcnJvciwgbWFrZUVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRvSnNvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn1cbi8vIEBUT0RPPyA8VCBleHRlbmRzIEZlZURhdGEgPSB7IH0+IGltcGxlbWVudHMgUmVxdWlyZWQ8VD5cbi8qKlxuICogIEEgKipGZWVEYXRhKiogd3JhcHMgYWxsIHRoZSBmZWUtcmVsYXRlZCB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoXG4gKiAgdGhlIG5ldHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVEYXRhIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBmb3IgbGVnYWN5IG5ldHdvcmtzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgdG8gcGF5IHBlciBnYXMuXG4gICAgICpcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgaXMgZGVmaW5lZCBieSB0aGUgbmV0d29yayBhbmQgYmFzZWQgb25cbiAgICAgKiAgY29uZ2VzdGlvbiwgaW5jcmVhc2luZyB0aGUgY29zdCBkdXJpbmcgdGltZXMgb2YgaGVhdnkgbG9hZFxuICAgICAqICBhbmQgbG93ZXJpbmcgd2hlbiBsZXNzIGJ1c3kuXG4gICAgICpcbiAgICAgKiAgVGhlIGFjdHVhbCBmZWUgcGVyIGdhcyB3aWxsIGJlIHRoZSBiYXNlIGZlZSBmb3IgdGhlIGJsb2NrXG4gICAgICogIGFuZCB0aGUgcHJpb3JpdHkgZmVlLCB1cCB0byB0aGUgbWF4IGZlZSBwZXIgZ2FzLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBiZSBgYG51bGxgYCBvbiBsZWdhY3kgbmV0d29ya3MgKGkuZS4gW3ByZS1FSVAtMTU1OV0obGluay1laXAtMTU1OSkpXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkaXRpb25hbCBhbW91dCB0byBwYXkgcGVyIGdhcyB0byBlbmNvdXJhZ2UgYSB2YWxpZGF0b3JcbiAgICAgKiAgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhlIHB1cnBvc2Ugb2YgdGhpcyBpcyB0byBjb21wZW5zYXRlIHRoZSB2YWxpZGF0b3IgZm9yIHRoZVxuICAgICAqICBhZGp1c3RlZCByaXNrIGZvciBpbmNsdWRpbmcgYSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYmUgYGBudWxsYGAgb24gbGVnYWN5IG5ldHdvcmtzIChpLmUuIFtwcmUtRUlQLTE1NTldKGxpbmstZWlwLTE1NTkpKVxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEZlZURhdGEgZm9yICUlZ2FzUHJpY2UlJSwgJSVtYXhGZWVQZXJHYXMlJSBhbmRcbiAgICAgKiAgJSVtYXhQcmlvcml0eUZlZVBlckdhcyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZ2FzUHJpY2U6IGdldFZhbHVlKGdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2V0VmFsdWUobWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBnZXRWYWx1ZShtYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJGZWVEYXRhXCIsXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKGdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKG1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdG9Kc29uKG1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG47XG4vKipcbiAqICBSZXR1cm5zIGEgY29weSBvZiAlJXJlcSUlIHdpdGggYWxsIHByb3BlcnRpZXMgY29lcmNlZCB0byB0aGVpciBzdHJpY3RcbiAqICB0eXBlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlSZXF1ZXN0KHJlcSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIC8vIFRoZXNlIGNvdWxkIGJlIGFkZHJlc3NlcywgRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlc1xuICAgIGlmIChyZXEudG8pIHtcbiAgICAgICAgcmVzdWx0LnRvID0gcmVxLnRvO1xuICAgIH1cbiAgICBpZiAocmVxLmZyb20pIHtcbiAgICAgICAgcmVzdWx0LmZyb20gPSByZXEuZnJvbTtcbiAgICB9XG4gICAgaWYgKHJlcS5kYXRhKSB7XG4gICAgICAgIHJlc3VsdC5kYXRhID0gaGV4bGlmeShyZXEuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGJpZ0ludEtleXMgPSBcImNoYWluSWQsZ2FzTGltaXQsZ2FzUHJpY2UsbWF4RmVlUGVyQmxvYkdhcyxtYXhGZWVQZXJHYXMsbWF4UHJpb3JpdHlGZWVQZXJHYXMsdmFsdWVcIi5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGJpZ0ludEtleXMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXRCaWdJbnQocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xuICAgIH1cbiAgICBjb25zdCBudW1iZXJLZXlzID0gXCJ0eXBlLG5vbmNlXCIuc3BsaXQoLywvKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBudW1iZXJLZXlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiByZXEpIHx8IHJlcVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gZ2V0TnVtYmVyKHJlcVtrZXldLCBgcmVxdWVzdC4ke2tleX1gKTtcbiAgICB9XG4gICAgaWYgKHJlcS5hY2Nlc3NMaXN0KSB7XG4gICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeShyZXEuYWNjZXNzTGlzdCk7XG4gICAgfVxuICAgIGlmIChyZXEuYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGhvcml6YXRpb25MaXN0ID0gcmVxLmF1dGhvcml6YXRpb25MaXN0LnNsaWNlKCk7XG4gICAgfVxuICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja1RhZyA9IHJlcS5ibG9ja1RhZztcbiAgICB9XG4gICAgaWYgKFwiZW5hYmxlQ2NpcFJlYWRcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmVuYWJsZUNjaXBSZWFkID0gISFyZXEuZW5hYmxlQ2NpcFJlYWQ7XG4gICAgfVxuICAgIGlmIChcImN1c3RvbURhdGFcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmN1c3RvbURhdGEgPSByZXEuY3VzdG9tRGF0YTtcbiAgICB9XG4gICAgaWYgKFwiYmxvYlZlcnNpb25lZEhhc2hlc1wiIGluIHJlcSAmJiByZXEuYmxvYlZlcnNpb25lZEhhc2hlcykge1xuICAgICAgICByZXN1bHQuYmxvYlZlcnNpb25lZEhhc2hlcyA9IHJlcS5ibG9iVmVyc2lvbmVkSGFzaGVzLnNsaWNlKCk7XG4gICAgfVxuICAgIGlmIChcImt6Z1wiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQua3pnID0gcmVxLmt6ZztcbiAgICB9XG4gICAgaWYgKFwiYmxvYnNcIiBpbiByZXEgJiYgcmVxLmJsb2JzKSB7XG4gICAgICAgIHJlc3VsdC5ibG9icyA9IHJlcS5ibG9icy5tYXAoKGIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0J5dGVzTGlrZShiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIEEgKipCbG9jayoqIHJlcHJlc2VudHMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgZnVsbCBibG9jayBvblxuICogIEV0aGVyZXVtLlxuICovXG5leHBvcnQgY2xhc3MgQmxvY2sge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBibG9jayB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIsIHNvbWV0aW1lcyBjYWxsZWQgdGhlIGJsb2NrIGhlaWdodC4gVGhpcyBpcyBhXG4gICAgICogIHNlcXVlbnRpYWwgbnVtYmVyIHRoYXQgaXMgb25lIGhpZ2hlciB0aGFuIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgbnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaC5cbiAgICAgKlxuICAgICAqICBUaGlzIGhhc2ggaW5jbHVkZXMgYWxsIHByb3BlcnRpZXMsIHNvIGNhbiBiZSBzYWZlbHkgdXNlZCB0byBpZGVudGlmeVxuICAgICAqICBhbiBleGFjdCBzZXQgb2YgYmxvY2sgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgdGltZXN0YW1wIGZvciB0aGlzIGJsb2NrLCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcbiAgICAgKiAgZXBvY2ggdGhhdCB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZC5cbiAgICAgKi9cbiAgICB0aW1lc3RhbXA7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgcGFyZW50SGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGhhc2ggdHJlZSByb290IG9mIHRoZSBwYXJlbnQgYmVhY29uIGJsb2NrIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgZXhlY3V0aW9uIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00Nzg4XV0uXG4gICAgICovXG4gICAgcGFyZW50QmVhY29uQmxvY2tSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSByYW5kb20gbnVtYmVyIGluc2VydGVkIHdoaWNoXG4gICAgICogIHBlcm1pdHRlZCB0aGUgZGlmZmljdWx0eSB0YXJnZXQgdG8gYmUgcmVhY2hlZC5cbiAgICAgKi9cbiAgICBub25jZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRpZmZpY3VsdHkgdGFyZ2V0LlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpcyBpcyB0aGUgcHJvb2Ytb2Ytd29yayB0YXJnZXQgcmVxdWlyZWRcbiAgICAgKiAgZm9yIGEgYmxvY2sgdG8gbWVldCB0aGUgcHJvdG9jb2wgcnVsZXMgdG8gYmUgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgT24gbW9kZXJuIG5ldHdvcmtzLCB0aGlzIGlzIGEgcmFuZG9tIG51bWJlciBhcnJpdmVkIGF0IHVzaW5nXG4gICAgICogIHJhbmRhby4gIEBUT0RPOiBGaW5kIGxpbmtzP1xuICAgICAqL1xuICAgIGRpZmZpY3VsdHk7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgbGltaXQgZm9yIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgdXNlZCBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSByb290IGhhc2ggZm9yIHRoZSBnbG9iYWwgc3RhdGUgYWZ0ZXIgYXBwbHlpbmcgY2hhbmdlc1xuICAgICAqICBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIHN0YXRlUm9vdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRzIHRyaWUuXG4gICAgICovXG4gICAgcmVjZWlwdHNSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgYW1vdW50IG9mIGJsb2IgZ2FzIGNvbnN1bWVkIGJ5IHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgKiAgd2l0aGluIHRoZSBibG9jay4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgcnVubmluZyB0b3RhbCBvZiBibG9iIGdhcyBjb25zdW1lZCBpbiBleGNlc3Mgb2YgdGhlXG4gICAgICogIHRhcmdldCwgcHJpb3IgdG8gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXG4gICAgICovXG4gICAgZXhjZXNzQmxvYkdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1pbmVyIGNvaW5iYXNlIGFkZHJlc3MsIHdpaGNoIHJlY2VpdmVzIGFueSBzdWJzaWRpZXMgZm9yXG4gICAgICogIGluY2x1ZGluZyB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIG1pbmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgbGF0ZXN0IFJBTkRBTyBtaXggb2YgdGhlIHBvc3QgYmVhY29uIHN0YXRlIG9mXG4gICAgICogIHRoZSBwcmV2aW91cyBibG9jay5cbiAgICAgKi9cbiAgICBwcmV2UmFuZGFvO1xuICAgIC8qKlxuICAgICAqICBBbnkgZXh0cmEgZGF0YSB0aGUgdmFsaWRhdG9yIHdpc2hlZCB0byBpbmNsdWRlLlxuICAgICAqL1xuICAgIGV4dHJhRGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgdGhhdCBhbGwgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2sgd2VyZVxuICAgICAqICBjaGFyZ2VkLlxuICAgICAqXG4gICAgICogIFRoaXMgYWRqdXN0cyBhZnRlciBlYWNoIGJsb2NrLCBkZXBlbmRpbmcgb24gaG93IGNvbmdlc3RlZCB0aGUgbmV0d29ya1xuICAgICAqICBpcy5cbiAgICAgKi9cbiAgICBiYXNlRmVlUGVyR2FzO1xuICAgICN0cmFuc2FjdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkJsb2NrKiogb2JqZWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgbmVjZXNzYXJ5IGFzIHRoZSB1bmxlc3MgaW1wbGVtZW50aW5nIGFcbiAgICAgKiAgbG93LWxldmVsIGxpYnJhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmxvY2ssIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3RyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICBoYXNoOiBnZXRWYWx1ZShibG9jay5oYXNoKSxcbiAgICAgICAgICAgIG51bWJlcjogYmxvY2subnVtYmVyLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBibG9jay50aW1lc3RhbXAsXG4gICAgICAgICAgICBwYXJlbnRIYXNoOiBibG9jay5wYXJlbnRIYXNoLFxuICAgICAgICAgICAgcGFyZW50QmVhY29uQmxvY2tSb290OiBibG9jay5wYXJlbnRCZWFjb25CbG9ja1Jvb3QsXG4gICAgICAgICAgICBub25jZTogYmxvY2subm9uY2UsXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiBibG9jay5kaWZmaWN1bHR5LFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJsb2NrLmdhc0xpbWl0LFxuICAgICAgICAgICAgZ2FzVXNlZDogYmxvY2suZ2FzVXNlZCxcbiAgICAgICAgICAgIGJsb2JHYXNVc2VkOiBibG9jay5ibG9iR2FzVXNlZCxcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IGJsb2NrLmV4Y2Vzc0Jsb2JHYXMsXG4gICAgICAgICAgICBtaW5lcjogYmxvY2subWluZXIsXG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBnZXRWYWx1ZShibG9jay5wcmV2UmFuZGFvKSxcbiAgICAgICAgICAgIGV4dHJhRGF0YTogYmxvY2suZXh0cmFEYXRhLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogZ2V0VmFsdWUoYmxvY2suYmFzZUZlZVBlckdhcyksXG4gICAgICAgICAgICBzdGF0ZVJvb3Q6IGJsb2NrLnN0YXRlUm9vdCxcbiAgICAgICAgICAgIHJlY2VpcHRzUm9vdDogYmxvY2sucmVjZWlwdHNSb290LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb24gaGFzaGVzLCBpbiB0aGUgb3JkZXJcbiAgICAgKiAgdGhleSB3ZXJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgYmxvY2suXG4gICAgICovXG4gICAgZ2V0IHRyYW5zYWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHguaGFzaDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBjb21wbGV0ZSB0cmFuc2FjdGlvbnMsIGluIHRoZSBvcmRlciB0aGV5XG4gICAgICogIHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBibG9ja3Mgd2hpY2ggcHJlZmV0Y2hlZFxuICAgICAqICB0cmFuc2FjdGlvbnMsIGJ5IHBhc3NpbmcgYGB0cnVlYGAgdG8gJSVwcmVmZXRjaFR4cyUlXG4gICAgICogIGludG8gW1tQcm92aWRlci1nZXRCbG9ja11dLlxuICAgICAqL1xuICAgIGdldCBwcmVmZXRjaGVkVHJhbnNhY3Rpb25zKCkge1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLiN0cmFuc2FjdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgLy8gRG9lc24ndCBtYXR0ZXIuLi5cbiAgICAgICAgaWYgKHR4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcHJlZmV0Y2hlZCB0aGUgdHJhbnNhY3Rpb25zXG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHR4c1swXSkgPT09IFwib2JqZWN0XCIsIFwidHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQgd2l0aCBibG9jayByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0cmFuc2FjdGlvblJlc3BvbnNlcygpXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYmFzZUZlZVBlckdhcywgZGlmZmljdWx0eSwgZXh0cmFEYXRhLCBnYXNMaW1pdCwgZ2FzVXNlZCwgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsIHRpbWVzdGFtcCwgdHJhbnNhY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiQmxvY2tcIixcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IHRvSnNvbihiYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHRvSnNvbihkaWZmaWN1bHR5KSxcbiAgICAgICAgICAgIGV4dHJhRGF0YSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24oZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzVXNlZDogdG9Kc29uKGdhc1VzZWQpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IHRvSnNvbih0aGlzLmV4Y2Vzc0Jsb2JHYXMpLFxuICAgICAgICAgICAgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLnRyYW5zYWN0aW9ucztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4c1tpbmRleCsrXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWpzLWRhdGVdXSB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZCBhdC5cbiAgICAgKi9cbiAgICBnZXQgZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXN0YW1wID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRpbWVzdGFtcCAqIDEwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSB0cmFuc2FjdGlvbiBhdCAlJWluZGV4ZSUlIHdpdGhpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGludGVybmFsIHZhbHVlIGJ5IGl0cyBpbmRleCBvciBoYXNoXG4gICAgICAgIGxldCB0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0eCA9IHRoaXMuI3RyYW5zYWN0aW9uc1tpbmRleE9ySGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLiN0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHggPSB2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdWNoIHR4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHR4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGEgKipCbG9jayoqIHdhcyBmZXRjaGVkIHdpdGggYSByZXF1ZXN0IHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uc1xuICAgICAqICB0aGlzIHdpbGwgYWxsb3cgc3luY2hyb25vdXMgYWNjZXNzIHRvIHRob3NlIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgdHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQsIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRQcmVmZXRjaGVkVHJhbnNhY3Rpb24oaW5kZXhPckhhc2gpIHtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy5wcmVmZXRjaGVkVHJhbnNhY3Rpb25zO1xuICAgICAgICBpZiAodHlwZW9mIChpbmRleE9ySGFzaCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eHNbaW5kZXhPckhhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4T3JIYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yIChjb25zdCB0eCBvZiB0eHMpIHtcbiAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSBpbmRleE9ySGFzaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJubyBtYXRjaGluZyB0cmFuc2FjdGlvblwiLCBcImluZGV4T3JIYXNoXCIsIGluZGV4T3JIYXNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGJsb2NrIGJlZW4gbWluZWQuIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGd1YXJkXG4gICAgICogIGZvciBhbGwgcHJvcGVydGllcyBvbiBhIFtbTWluZWRCbG9ja11dLlxuICAgICAqL1xuICAgIGlzTWluZWQoKSB7IHJldHVybiAhIXRoaXMuaGFzaDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBpcyBhbiBbW2xpbmstZWlwLTI5MzBdXSBibG9jay5cbiAgICAgKi9cbiAgICBpc0xvbmRvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5iYXNlRmVlUGVyR2FzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgb3JwaGFuZWRFdmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTWluZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyKHRoaXMpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIExvZ1xuLyoqXG4gKiAgQSAqKkxvZyoqIGluIEV0aGVyZXVtIHJlcHJlc2VudHMgYW4gZXZlbnQgdGhhdCBoYXMgYmVlbiBpbmNsdWRlZCBpbiBhXG4gKiAgdHJhbnNhY3Rpb24gdXNpbmcgdGhlIGBgTE9HKmBgIG9wY29kZXMsIHdoaWNoIGFyZSBtb3N0IGNvbW1vbmx5IHVzZWQgYnlcbiAqICBTb2xpZGl0eSdzIGVtaXQgZm9yIGFubm91bmNpbmcgZXZlbnRzLlxuICovXG5leHBvcnQgY2xhc3MgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXG4gICAgICogIFtbTG9nLWdldFRyYW5zYWN0aW9uXV0gdG8gZ2V0IHRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbkhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxuICAgICAqICBbW0xvZy1nZXRCbG9ja11dIHRvIGdldCB0aGUgW1tCbG9ja11dLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIEl0IGlzIHByZWZlcnJlZFxuICAgICAqICB0byB1c2UgdGhlIFtbQmxvY2staGFzaF1dIHdoZW4gZmV0Y2hpbmcgdGhlIHJlbGF0ZWQgW1tCbG9ja11dLFxuICAgICAqICBzaW5jZSBpbiB0aGUgY2FzZSBvZiBhbiBvcnBoYW5lZCBibG9jaywgdGhlIGJsb2NrIGF0IHRoYXQgaGVpZ2h0IG1heVxuICAgICAqICBoYXZlIGNoYW5nZWQuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSAqKkxvZyoqIHJlcHJlc2VudHMgYSBibG9jayB0aGF0IHdhcyByZW1vdmVkIGR1ZSB0byBhbiBvcnBoYW5lZFxuICAgICAqICBibG9jaywgdGhpcyB3aWxsIGJlIHRydWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBoYXBwZW4gd2l0aGluIGFuIG9ycGhhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICByZW1vdmVkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgdGhhdCBlbWl0dGVkIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICovXG4gICAgZGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4ZWQgdG9waWNzIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiAgQWxsIHRvcGljcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGJsb29tIGZpbHRlcnMsIHNvIHRoZXkgY2FuIGJlXG4gICAgICogIGVmZmljaWVudGx5IGZpbHRlcmVkIHVzaW5nIHRoZSBbW1Byb3ZpZGVyLWdldExvZ3NdXSBtZXRob2QuXG4gICAgICovXG4gICAgdG9waWNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBhdC4gVGhpcyBpcyBnZW5lcmFsbHlcbiAgICAgKiAgbm90IHVzZWZ1bCB0byBkZXZlbG9wZXJzLCBidXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgdmFyaW91cyByb290c1xuICAgICAqICB0byBwcm9vZiBpbmNsdXNpb24gd2l0aGluIGEgYmxvY2suXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIG9mIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uSW5kZXg7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBsb2cuYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGxvZy5ibG9ja051bWJlcixcbiAgICAgICAgICAgIHJlbW92ZWQ6IGxvZy5yZW1vdmVkLFxuICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIHRvcGljcyxcbiAgICAgICAgICAgIGluZGV4OiBsb2cuaW5kZXgsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBsb2cudHJhbnNhY3Rpb25JbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsIHJlbW92ZWQsIHRvcGljcywgdHJhbnNhY3Rpb25IYXNoLCB0cmFuc2FjdGlvbkluZGV4IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwibG9nXCIsXG4gICAgICAgICAgICBhZGRyZXNzLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBkYXRhLCBpbmRleCxcbiAgICAgICAgICAgIHJlbW92ZWQsIHRvcGljcywgdHJhbnNhY3Rpb25IYXNoLCB0cmFuc2FjdGlvbkluZGV4XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBibG9jayB0aGF0IHRoaXMgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sodGhpcy5ibG9ja0hhc2gpO1xuICAgICAgICBhc3NlcnQoISFibG9jaywgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHRoaXMgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odGhpcy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBhc3NlcnQoISF0eCwgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvdCB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzXG4gICAgICogIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGFzc2VydCghIXJlY2VpcHQsIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb24gcmVjZWlwdFwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIodGhpcyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVHJhbnNhY3Rpb24gUmVjZWlwdFxuLypcbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWN5VHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IGZhbHNlO1xuICAgIHN0YXR1czogbnVsbDtcbiAgICByb290OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnl6YW50aXVtVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IHRydWU7XG4gICAgc3RhdHVzOiBudW1iZXI7XG4gICAgcm9vdDogbnVsbDtcbn1cbiovXG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCBhXG4gKiAgdHJhbnNhY3Rpb24gdGhhdCBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciBpdCBoYXMgYmVlbiBtaW5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIHRoZSB0cmFuc2FjdGlvbiB3YXMgc2VudCB0by5cbiAgICAgKi9cbiAgICB0bztcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRlciBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgZGlyZWN0bHlcbiAgICAgKiAgcmVzcG9uc2libGUgZm9yIGRlcGxveWluZyBvbmUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub24tbnVsbCAqKm9ubHkqKiBpZiB0aGUgYGB0b2BgIGlzIGVtcHR5IGFuZCB0aGUgYGBkYXRhYGBcbiAgICAgKiAgd2FzIHN1Y2Nlc3NmdWxseSBleGVjdXRlZCBhcyBpbml0Y29kZS5cbiAgICAgKi9cbiAgICBjb250cmFjdEFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCBvZiB0aGlzIHRyYW5zYWN0aW9uIHdpdGhpbiB0aGUgYmxvY2sgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvb20gZmlsdGVyIGJ5dGVzIHRoYXQgcmVwcmVzZW50IGFsbCBsb2dzIHRoYXQgb2NjdXJyZWQgd2l0aGluXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIG1vc3QgZGV2ZWxvcGVycyxcbiAgICAgKiAgYnV0IGNhbiBiZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBpbmNsdWRlZCBsb2dzLlxuICAgICAqL1xuICAgIGxvZ3NCbG9vbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCBhbW91bnQgb2YgZ2FzIHVzZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBXaGVuIGNyZWF0aW5nIGEgdHJhbnNhY3Rpb24sIHRoZSBhbW91bnQgb2YgZ2FzIHRoYXQgd2lsbCBiZSB1c2VkIGNhblxuICAgICAqICBvbmx5IGJlIGFwcHJveGltYXRlZCwgYnV0IHRoZSBzZW5kZXIgbXVzdCBwYXkgdGhlIGdhcyBmZWUgZm9yIHRoZVxuICAgICAqICBlbnRpcmUgZ2FzIGxpbWl0LiBBZnRlciB0aGUgdHJhbnNhY3Rpb24sIHRoZSBkaWZmZXJlbmNlIGlzIHJlZnVuZGVkLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgdXNlZCBmb3IgQkxPYnMuIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBibG9iR2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFtb3VudCBvZiBnYXMgdXNlZCBieSBhbGwgdHJhbnNhY3Rpb25zIHdpdGhpbiB0aGUgYmxvY2sgZm9yIHRoaXNcbiAgICAgKiAgYW5kIGFsbCB0cmFuc2FjdGlvbnMgd2l0aCBhIGxvd2VyIGBgaW5kZXhgYC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIGZvciBkZXZlbG9wZXJzIGJ1dCBjYW4gYmUgdXNlZCB0b1xuICAgICAqICB2YWxpZGF0ZSBjZXJ0YWluIGFzcGVjdHMgb2YgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGN1bXVsYXRpdmVHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIGdhcyBwcmljZSB1c2VkIGR1cmluZyBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiAgRHVlIHRvIHRoZSBjb21wbGV4aXR5IG9mIFtbbGluay1laXAtMTU1OV1dIHRoaXMgdmFsdWUgY2FuIG9ubHlcbiAgICAgKiAgYmUgY2FsdWNsYXRlZCBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQsIHNuY2UgdGhlIGJhc2VcbiAgICAgKiAgZmVlIGlzIHByb3RvY29sLWVuZm9yY2VkLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJpY2UgcGFpZCBwZXIgQkxPQiBpbiBnYXMuIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBibG9iR2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLy9yZWFkb25seSBieXphbnRpdW0hOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdHVzIG9mIHRoaXMgdHJhbnNhY3Rpb24sIGluZGljYXRpbmcgc3VjY2VzcyAoaS5lLiBgYDFgYCkgb3JcbiAgICAgKiAgYSByZXZlcnQgKGkuZS4gYGAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYXZhaWxhYmxlIGluIHBvc3QtYnl6YW50aXVtIGJsb2NrcywgYnV0IHNvbWUgYmFja2VuZHMgbWF5XG4gICAgICogIGJhY2tmaWxsIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgc3RhdHVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgcm9vdCBoYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBubyBwcmVzZW50IGFuZCB3YXMgb25seSBpbmNsdWRlZCBpbiBwcmUtYnl6YW50aXVtIGJsb2NrcywgYnV0XG4gICAgICogIGNvdWxkIGJlIHVzZWQgdG8gdmFsaWRhdGUgY2VydGFpbiBwYXJ0cyBvZiB0aGUgcmVjZWlwdC5cbiAgICAgKi9cbiAgICByb290O1xuICAgICNsb2dzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jbG9ncyA9IE9iamVjdC5mcmVlemUodHgubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IGdhc1ByaWNlID0gQk5fMDtcbiAgICAgICAgaWYgKHR4LmVmZmVjdGl2ZUdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdhc1ByaWNlID0gdHguZWZmZWN0aXZlR2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHguY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgIGluZGV4OiB0eC5pbmRleCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogdHguYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgbG9nc0Jsb29tOiB0eC5sb2dzQmxvb20sXG4gICAgICAgICAgICBnYXNVc2VkOiB0eC5nYXNVc2VkLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHR4LmJsb2JHYXNVc2VkLFxuICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICBibG9iR2FzUHJpY2U6IHR4LmJsb2JHYXNQcmljZSxcbiAgICAgICAgICAgIHR5cGU6IHR4LnR5cGUsXG4gICAgICAgICAgICAvL2J5emFudGl1bTogdHguYnl6YW50aXVtLFxuICAgICAgICAgICAgc3RhdHVzOiB0eC5zdGF0dXMsXG4gICAgICAgICAgICByb290OiB0eC5yb290XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZ3MgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7IHJldHVybiB0aGlzLiNsb2dzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IHRvLCBmcm9tLCBjb250cmFjdEFkZHJlc3MsIGhhc2gsIGluZGV4LCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBsb2dzQmxvb20sIGxvZ3MsIC8vYnl6YW50aXVtLCBcbiAgICAgICAgc3RhdHVzLCByb290IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgLy9ieXphbnRpdW0sIFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHRvSnNvbih0aGlzLmN1bXVsYXRpdmVHYXNVc2VkKSxcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGJsb2JHYXNQcmljZTogdG9Kc29uKHRoaXMuYmxvYkdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxuICAgICAgICAgICAgaGFzaCwgaW5kZXgsIGxvZ3MsIGxvZ3NCbG9vbSwgcm9vdCwgc3RhdHVzLCB0b1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMubG9ncy5sZW5ndGg7IH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5sb2dzW2luZGV4KytdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLCBpbiB3ZWkuXG4gICAgICovXG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzVXNlZCAqIHRoaXMuZ2FzUHJpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXG4gICAgICogIHdpdGggdGhlIGBgZGVidWdfYGAgb3IgYGB0cmFjZV9gYCBBUEkgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdCh0aGlzLmhhc2gpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSkgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgIGFzc2VydCghb3RoZXIgfHwgb3RoZXIuaXNNaW5lZCgpLCBcInVubWluZWQgJ290aGVyJyB0cmFuc2N0aW9uIGNhbm5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW9yZGVyZWRFdmVudChvdGhlcilcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cbiAqICB0aGF0IHdhcyBzZW50IHRvIHRoZSBuZXR3b3JrLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBpbmNsdWRlZCBpbiBhXG4gKiAgYmxvY2suXG4gKlxuICogIFRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2UtaXNNaW5lZF1dIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZVxuICogIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFzIHdlbGwgYXMgdHlwZSBndWFyZCB0aGF0IHRoZSBvdGhlcndpc2VcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciB0aGlzIGlzIGNvbm5lY3RlZCB0bywgd2hpY2ggd2lsbCBpbmZsdWVuY2UgaG93IGl0c1xuICAgICAqICBtZXRob2RzIHdpbGwgcmVzb2x2ZSBpdHMgYXN5bmMgaW5zcGVjdGlvbiBtZXRob2RzLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2tIYXNoIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHJlc2lkZXMgYXQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0eXBlLiBUaGlzIGlzXG4gICAgICogIGBgMGBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zIHR5cGVzLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNlaXZlciBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIElmIGBgbnVsbGBgLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBpbml0Y29kZSB0cmFuc2FjdGlvbi5cbiAgICAgKiAgVGhpcyBtZWFucyB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyB0aGUgW1tkYXRhXV0gd2lsbCBiZSBkZXBsb3llZFxuICAgICAqICBhcyBhIG5ldyBjb250cmFjdCBvbiBjaGFpbiAoYXNzdW1pbmcgaXQgZG9lcyBub3QgcmV2ZXJ0KSBhbmQgdGhlXG4gICAgICogIGFkZHJlc3MgbWF5IGJlIGNvbXB1dGVkIHVzaW5nIFtbZ2V0Q3JlYXRlQWRkcmVzc11dLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uIEl0IGlzIGltcGxpY2l0bHkgY29tcHV0ZWRcbiAgICAgKiAgZnJvbSB0aGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlIGhhc2ggKGFzIHRoZSBkaWdlc3QpIGFuZCB0aGVcbiAgICAgKiAgW1tzaWduYXR1cmVdXSB1c2luZyBlY3JlY292ZXIuXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5vbmNlLCB3aGljaCBpcyB1c2VkIHRvIHByZXZlbnQgcmVwbGF5IGF0dGFja3MgYW5kIG9mZmVyXG4gICAgICogIGEgbWV0aG9kIHRvIGVuc3VyZSB0cmFuc2FjdGlvbnMgZnJvbSBhIGdpdmVuIHNlbmRlciBhcmUgZXhwbGljaXRseVxuICAgICAqICBvcmRlcmVkLlxuICAgICAqXG4gICAgICogIFdoZW4gc2VuZGluZyBhIHRyYW5zYWN0aW9uLCB0aGlzIG11c3QgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAqICB0cmFuc2FjdGlvbnMgZXZlciBzZW50IGJ5IFtbZnJvbV1dLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB1bml0cyBvZiBnYXMgdGhpcyB0cmFuc2FjdGlvbiBjYW4gY29uc3VtZS4gSWYgZXhlY3V0aW9uXG4gICAgICogIGV4Y2VlZHMgdGhpcywgdGhlIGVudHJpZXMgdHJhbnNhY3Rpb24gaXMgcmV2ZXJ0ZWQgYW5kIHRoZSBzZW5kZXJcbiAgICAgKiAgaXMgY2hhcmdlZCBmb3IgdGhlIGZ1bGwgYW1vdW50LCBkZXNwaXRlIG5vdCBzdGF0ZSBjaGFuZ2VzIGJlaW5nIG1hZGUuXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgY2FuIGhhdmUgdmFyaW91cyB2YWx1ZXMsIGRlcGVuZGluZyBvbiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqICBJbiBtb2Rlcm4gbmV0d29ya3MsIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgaW5jbHVkZWQgdGhpcyBpc1xuICAgICAqICB0aGUgLy9lZmZlY3RpdmUgZ2FzIHByaWNlLy8gKHRoZSBmZWUgcGVyIGdhcyB0aGF0IHdhcyBhY3R1YWxseVxuICAgICAqICBjaGFyZ2VkKSwgd2hpbGUgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGhhdmUgbm90IGJlZW4gaW5jbHVkZWQgeWV0XG4gICAgICogIGlzIHRoZSBbW21heEZlZVBlckdhc11dLlxuICAgICAqXG4gICAgICogIEZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLCBvciB0cmFuc2FjdGlvbnMgb24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzXG4gICAgICogIGlzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIGNoYXJnZWQgcGVyIHVuaXQgb2YgZ2FzIHRoZSB0cmFuc2FjdGlvblxuICAgICAqICBjb25zdW1lcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IGFcbiAgICAgKiAgdmFsaWRhdG9yIHRvIGNoYXJnZSB0aGUgc2VuZGVyLiBUaGlzIGlzIGluY2x1c2l2ZSBvZiB0aGVcbiAgICAgKiAgW1ttYXhGZWVGZWVQZXJHYXNdXS5cbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiAgdG8gY2hhcmdlIHRoZSBzZW5kZXIuXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC00ODQ0XV0gbWF4IGZlZSBwZXIgQkxPYiBnYXMuXG4gICAgICovXG4gICAgbWF4RmVlUGVyQmxvYkdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEuXG4gICAgICovXG4gICAgZGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlLCBpbiB3ZWkuIFVzZSBbW2Zvcm1hdEV0aGVyXV0gdG8gZm9ybWF0IHRoaXMgdmFsdWVcbiAgICAgKiAgYXMgZXRoZXIuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBjaGFpbklkO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0IGZvciB0cmFuc2FjdGlvbiB0eXBlcyB0aGF0XG4gICAgICogIHN1cHBvcnQgaXQsIG90aGVyd2lzZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhY2Nlc3NMaXN0O1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC00ODQ0XV0gQkxPYiB2ZXJzaW9uZWQgaGFzaGVzLlxuICAgICAqL1xuICAgIGJsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTc3MDJdXSBhdXRob3JpemF0aW9ucyAoaWYgYW55KS5cbiAgICAgKi9cbiAgICBhdXRob3JpemF0aW9uTGlzdDtcbiAgICAjc3RhcnRCbG9jaztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5ibG9ja051bWJlciA9ICh0eC5ibG9ja051bWJlciAhPSBudWxsKSA/IHR4LmJsb2NrTnVtYmVyIDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9ja0hhc2ggPSAodHguYmxvY2tIYXNoICE9IG51bGwpID8gdHguYmxvY2tIYXNoIDogbnVsbDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHguaGFzaDtcbiAgICAgICAgdGhpcy5pbmRleCA9IHR4LmluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eC50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSB0eC5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gdHgudG8gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5nYXNMaW1pdCA9IHR4Lmdhc0xpbWl0O1xuICAgICAgICB0aGlzLm5vbmNlID0gdHgubm9uY2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IHR4LmRhdGE7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgdGhpcy5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzID0gKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckdhcyA9ICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckJsb2JHYXMgPSAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckJsb2JHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSB0eC5jaGFpbklkO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IHR4LnNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5hY2Nlc3NMaXN0ID0gKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkgPyB0eC5hY2Nlc3NMaXN0IDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9iVmVyc2lvbmVkSGFzaGVzID0gKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT0gbnVsbCkgPyB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzIDogbnVsbDtcbiAgICAgICAgdGhpcy5hdXRob3JpemF0aW9uTGlzdCA9ICh0eC5hdXRob3JpemF0aW9uTGlzdCAhPSBudWxsKSA/IHR4LmF1dGhvcml6YXRpb25MaXN0IDogbnVsbDtcbiAgICAgICAgdGhpcy4jc3RhcnRCbG9jayA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tIYXNoLCBpbmRleCwgaGFzaCwgdHlwZSwgdG8sIGZyb20sIG5vbmNlLCBkYXRhLCBzaWduYXR1cmUsIGFjY2Vzc0xpc3QsIGJsb2JWZXJzaW9uZWRIYXNoZXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJUcmFuc2FjdGlvblJlc3BvbnNlXCIsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0LCBibG9ja051bWJlciwgYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IHRvSnNvbih0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgZGF0YSwgZnJvbSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24odGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJCbG9iR2FzKSxcbiAgICAgICAgICAgIG5vbmNlLCBzaWduYXR1cmUsIHRvLCBpbmRleCwgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB0b0pzb24odGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgQmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBpbmNsdWRlZCB5ZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGxldCBibG9ja051bWJlciA9IHRoaXMuYmxvY2tOdW1iZXI7XG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlcik7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoaXMgdHJhbnNhY3Rpb24gYmVpbmcgcmUtcmVxdWVzdGVkIGZyb20gdGhlXG4gICAgICogIHByb3ZpZGVyLiBUaGlzIGNhbiBiZSB1c2VkIGlmIHlvdSBoYXZlIGFuIHVubWluZWQgdHJhbnNhY3Rpb25cbiAgICAgKiAgYW5kIHdpc2ggdG8gZ2V0IGFuIHVwLXRvLWRhdGUgcG9wdWxhdGVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWF0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tOdW1iZXIgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0eDogdGhpcy5nZXRUcmFuc2FjdGlvbigpLFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm90IG1pbmVkIHlldC4uLlxuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwgfHwgdHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChfY29uZmlybXMsIF90aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyA9PSBudWxsKSA/IDEgOiBfY29uZmlybXM7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoX3RpbWVvdXQgPT0gbnVsbCkgPyAwIDogX3RpbWVvdXQ7XG4gICAgICAgIGxldCBzdGFydEJsb2NrID0gdGhpcy4jc3RhcnRCbG9jaztcbiAgICAgICAgbGV0IG5leHRTY2FuID0gLTE7XG4gICAgICAgIGxldCBzdG9wU2Nhbm5pbmcgPSAoc3RhcnRCbG9jayA9PT0gLTEpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGVja1JlcGxhY2VtZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGlzIHNlbmRlclxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgbm9uY2UgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5mcm9tKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBObyB0cmFuc2FjdGlvbiBvciBvdXIgbm9uY2UgaGFzIG5vdCBiZWVuIG1pbmVkIHlldDsgYnV0IHdlXG4gICAgICAgICAgICAvLyBjYW4gc3RhcnQgc2Nhbm5pbmcgbGF0ZXIgd2hlbiB3ZSBkbyBzdGFydFxuICAgICAgICAgICAgaWYgKG5vbmNlIDwgdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3ZXJlIG1pbmVkOyBubyByZXBsYWNlbWVudFxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWluZWQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQ7IHN0YXJ0IHNjYW5uaW5nIGZvciB0aGF0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBTdGFydGluZyB0byBzY2FuOyBsb29rIGJhY2sgYSBmZXcgZXh0cmEgYmxvY2tzIGZvciBzYWZldHlcbiAgICAgICAgICAgIGlmIChuZXh0U2NhbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHN0YXJ0QmxvY2sgLSAzO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2NhbiA8IHRoaXMuI3N0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNjYW4gPSB0aGlzLiNzdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChuZXh0U2NhbiA8PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBibG9jayB0byBzY2FuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKG5leHRTY2FuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoID09PSB0aGlzLmhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHJlcGxhY2VkIHVzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGJsb2NrLmdldFRyYW5zYWN0aW9uKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHguZnJvbSA9PT0gdGhpcy5mcm9tICYmIHR4Lm5vbmNlID09PSB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eC5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgcmV0cnkgdGhpcyBvbiB0aGUgbmV4dCBibG9jayAodGhpcyBjYXNlIGNvdWxkIGJlIG9wdGltaXplZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSkgPCBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhID09PSB0aGlzLmRhdGEgJiYgdHgudG8gPT09IHRoaXMudG8gJiYgdHgudmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5kYXRhID09PSBcIjB4XCIgJiYgdHguZnJvbSA9PT0gdHgudG8gJiYgdHgudmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZFwiLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTY2FuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoZWNrUmVjZWlwdCA9IChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsIHx8IHJlY2VpcHQuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidHJhbnNhY3Rpb24gZXhlY3V0aW9uIHJldmVydGVkXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLCByZWFzb246IG51bGwsIGludm9jYXRpb246IG51bGwsIHJldmVydDogbnVsbCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0bzogcmVjZWlwdC50byxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcmVjZWlwdC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBcIlwiIC8vIEBUT0RPOiBpbiB2Nywgc3BsaXQgb3V0IHNlbmRUcmFuc2FjdGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfSwgcmVjZWlwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmhhc2gpO1xuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICAgIGlmIChjb25maXJtcyA9PT0gMSB8fCAoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aHJvd3MgaWYgYSByZXBsYWNlbWVudCB3YXMgZm91bmRcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgIC8vIEFsbG93IG51bGwgb25seSB3aGVuIHRoZSBjb25maXJtcyBpcyAwXG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWl0ZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBMaXN0IG9mIHRoaW5ncyB0byBjYW5jZWwgd2hlbiB3ZSBoYXZlIGEgcmVzdWx0IChvbmUgd2F5IG9yIHRoZSBvdGhlcilcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHsgY2FuY2VsbGVycy5mb3JFYWNoKChjKSA9PiBjKCkpOyB9O1xuICAgICAgICAgICAgLy8gT24gY2FuY2VsLCBzdG9wIHNjYW5uaW5nIGZvciByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHN0b3BTY2FubmluZyA9IHRydWU7IH0pO1xuICAgICAgICAgICAgLy8gU2V0IHVwIGFueSB0aW1lb3V0IHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJ3YWl0IGZvciB0cmFuc2FjdGlvbiB0aW1lb3V0XCIsIFwiVElNRU9VVFwiKSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eExpc3RlbmVyID0gYXN5bmMgKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb25lOyByZXR1cm4gaXQhXG4gICAgICAgICAgICAgICAgaWYgKChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNoZWNrUmVjZWlwdChyZWNlaXB0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7IH0pO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbih0aGlzLmhhc2gsIHR4TGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gV2Ugc3VwcG9ydCByZXBsYWNlbWVudCBkZXRlY3Rpb247IHN0YXJ0IGNoZWNraW5nXG4gICAgICAgICAgICBpZiAoc3RhcnRCbG9jayA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUxpc3RlbmVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRoaXMgdGhyb3dzIG9ubHkgaWYgb25lIGlzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGVja1JlcGxhY2VtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHJlcGxhY2VkICh3aXRoIGVub3VnaCBjb25maXJtcyk7IHJlLXRocm93IHRoZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNjaGV1ZGxlIGEgY2hlY2sgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB3YWl0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBlZmZlY3RpdmUgb25seSBhcyBvZiB0aGUgdGltZSB0aGUgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgICAqICB3YXMgaW5zdGFudGlhdGVkLiBUbyBnZXQgdXAtdG8tZGF0ZSBpbmZvcm1hdGlvbiwgdXNlXG4gICAgICogIFtbZ2V0VHJhbnNhY3Rpb25dXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIG5vbi1udWxsIHByb3BlcnR5IHZhbHVlcyBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBudWxsIGZvclxuICAgICAqICB1bm1pbmVkIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmxvY2tIYXNoICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSAoaS5lLiBgYHR5cGUgPT0gMGBgKVxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBCZXJsaW4gKGkuZS4gYGB0eXBlID09IDFgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTIwNzBdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNCZXJsaW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBMb25kb24gKGkuZS4gYGB0eXBlID09IDJgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTE1NTldXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBodGUgdHJhbnNhY3Rpb24gaXMgYSBDYW5jdW4gKGkuZS4gYGB0eXBlID09IDNgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBpc0NhbmN1bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZpbHRlciB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG9ycGhhbiBldmVudHNcbiAgICAgKiAgdGhhdCBldmljdCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZpbHRlciB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG9ycGhhbiBldmVudHNcbiAgICAgKiAgdGhhdCByZS1vcmRlciB0aGlzIGV2ZW50IGFnYWluc3QgJSVvdGhlciUlLlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmlzTWluZWQoKSwgXCJ1bm1pbmVkIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgYXNzZXJ0KCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSBpbnN0YW5jZSB3aGljaCBoYXMgdGhlIGFiaWxpdHkgdG9cbiAgICAgKiAgZGV0ZWN0IChhbmQgdGhyb3cgYW4gZXJyb3IpIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyByZXBsYWNlZCwgd2hpY2hcbiAgICAgKiAgd2lsbCBiZWdpbiBzY2FubmluZyBhdCAlJXN0YXJ0QmxvY2slJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQgYnkgZGV2ZWxvcGVycyBhbmQgaXMgaW50ZW5kZWRcbiAgICAgKiAgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIFNldHRpbmcgYW4gaW5jb3JyZWN0ICUlc3RhcnRCbG9jayUlIGNhblxuICAgICAqICBoYXZlIGRldmFzdGF0aW5nIHBlcmZvcm1hbmNlIGNvbnNlcXVlbmNlcyBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAqL1xuICAgIHJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jaykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YXJ0QmxvY2spICYmIHN0YXJ0QmxvY2sgPj0gMCwgXCJpbnZhbGlkIHN0YXJ0QmxvY2tcIiwgXCJzdGFydEJsb2NrXCIsIHN0YXJ0QmxvY2spO1xuICAgICAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKHRoaXMsIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICB0eC4jc3RhcnRCbG9jayA9IHN0YXJ0QmxvY2s7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyKGJsb2NrKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtYmxvY2tcIiwgaGFzaDogYmxvY2suaGFzaCwgbnVtYmVyOiBibG9jay5udW1iZXIgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHR4LCBvdGhlcikge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJyZW9yZGVyLXRyYW5zYWN0aW9uXCIsIHR4LCBvdGhlciB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHR4KSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtdHJhbnNhY3Rpb25cIiwgdHggfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIobG9nKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtbG9nXCIsIGxvZzoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBsb2cuYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGxvZy5ibG9ja051bWJlcixcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICB0b3BpY3M6IE9iamVjdC5mcmVlemUobG9nLnRvcGljcy5zbGljZSgpKSxcbiAgICAgICAgICAgIGluZGV4OiBsb2cuaW5kZXhcbiAgICAgICAgfSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXIuanMubWFwIiwiLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuaW1wb3J0IHsgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi4vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBFdmVudFBheWxvYWQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8qKlxuICogIEFuICoqRXZlbnRMb2cqKiBjb250YWlucyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgcGFyc2VkIGZyb20gdGhlIFtbTG9nXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudExvZyBleHRlbmRzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZXZlbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZXZlbnQgYnkgYGBlbWl0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIGlmYWNlLCBmcmFnbWVudCkge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBpZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXJncywgZnJhZ21lbnQsIGludGVyZmFjZTogaWZhY2UgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TmFtZSgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnQubmFtZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpOyB9XG59XG4vKipcbiAqICBBbiAqKkV2ZW50TG9nKiogY29udGFpbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHBhcnNlZCBmcm9tIHRoZSBbW0xvZ11dLlxuICovXG5leHBvcnQgY2xhc3MgVW5kZWNvZGVkRXZlbnRMb2cgZXh0ZW5kcyBMb2cge1xuICAgIC8qKlxuICAgICAqICBUaGUgZXJyb3IgZW5jb3VudGVkIHdoZW4gdHJ5aW5nIHRvIGRlY29kZSB0aGUgbG9nLlxuICAgICAqL1xuICAgIGVycm9yO1xuICAgIC8qKlxuICAgICAqIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgZXJyb3IpIHtcbiAgICAgICAgc3VwZXIobG9nLCBsb2cucHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZXJyb3IgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgdGhlIHBhcnNlZCBsb2dzIGZyb20gYVxuICogIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCBleHRlbmRzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgI2lmYWNlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSwgcHJvdmlkZXIsIHR4KSB7XG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcGFyc2VkIGxvZ3MgZm9yIGFueSBbW0xvZ11dIHdoaWNoIGhhcyBhIG1hdGNoaW5nIGV2ZW50IGluIHRoZVxuICAgICAqICBDb250cmFjdCBBQkkuXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGxvZy50b3BpY3MubGVuZ3RoID8gdGhpcy4jaWZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuI2lmYWNlLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2c7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UqKiB3aWxsIHJldHVybiBhXG4gKiAgW1tDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdF1dIHdoZW4gd2FpdGVkIG9uLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIGV4dGVuZHMgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgI2lmYWNlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSwgcHJvdmlkZXIsIHR4KSB7XG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYW5kIGhhc1xuICAgICAqICAlJWNvbmZpcm1zJSUgYmxvY2tzIGluY2x1ZGluZyBpdCAoZGVmYXVsdDogYGAxYGApIHdpdGggYW5cbiAgICAgKiAgb3B0aW9uYWwgJSV0aW1lb3V0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gcmVzb2x2ZSB0byBgYG51bGxgYCBvbmx5IGlmICUlY29uZmlybXMlJSBpcyBgYDBgYFxuICAgICAqICBhbmQgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgb3RoZXJ3aXNlIHRoaXMgd2lsbFxuICAgICAqICB3YWl0IHVudGlsIGVub3VnaCBjb25maXJtYXRpb25zIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoY29uZmlybXMsIHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHN1cGVyLndhaXQoY29uZmlybXMsIHRpbWVvdXQpO1xuICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuI2lmYWNlLCB0aGlzLnByb3ZpZGVyLCByZWNlaXB0KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkKiogaXMgaW5jbHVkZWQgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGRvZXMgbm90IG1hdGNoIGFueSBldmVudHMgaW4gdGhlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCBleHRlbmRzIEV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2cgd2l0aCBubyBtYXRjaGluZyBldmVudHMuXG4gICAgICovXG4gICAgbG9nO1xuICAgIC8qKlxuICAgICAqICBAX2V2ZW50OlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBsb2cpIHtcbiAgICAgICAgc3VwZXIoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbG9nIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0QmxvY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RFdmVudFBheWxvYWQqKiBpcyBpbmNsdWRlZCBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG9cbiAqICBDb250cmFjdCBFdmVudHMgd2hlbiB0aGUgZXZlbnQgaXMga25vd24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdEV2ZW50UGF5bG9hZCBleHRlbmRzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBmcmFnbWVudCwgX2xvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgbmV3IEV2ZW50TG9nKF9sb2csIGNvbnRyYWN0LmludGVyZmFjZSwgZnJhZ21lbnQpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgdGhpcy5sb2cuZGF0YSwgdGhpcy5sb2cudG9waWNzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFyZ3MsIGZyYWdtZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IG5hbWUuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50U2lnbmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cmFwcGVycy5qcy5tYXAiLCJpbXBvcnQgeyBJbnRlcmZhY2UsIFR5cGVkIH0gZnJvbSBcIi4uL2FiaS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaXNBZGRyZXNzYWJsZSwgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuaW1wb3J0IHsgY29weVJlcXVlc3QsIExvZyB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaXNDYWxsRXhjZXB0aW9uLCBpc0hleFN0cmluZywgcmVzb2x2ZVByb3BlcnRpZXMsIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3RFdmVudFBheWxvYWQsIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlLCBFdmVudExvZywgVW5kZWNvZGVkRXZlbnRMb2cgfSBmcm9tIFwiLi93cmFwcGVycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmZ1bmN0aW9uIGNhbkNhbGwodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuY2FsbCkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5Fc3RpbWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5lc3RpbWF0ZUdhcykgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5SZXNvbHZlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnJlc29sdmVOYW1lKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhblNlbmQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuc2VuZFRyYW5zYWN0aW9uKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGNhblJlc29sdmUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIFByZXBhcmVkVG9waWNGaWx0ZXIge1xuICAgICNmaWx0ZXI7XG4gICAgZnJhZ21lbnQ7XG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmcmFnbWVudCB9KTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBjYW5SZXNvbHZlKHJ1bm5lcikgPyBydW5uZXIgOiBudWxsO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgUHJvbWlzZS5hbGwoZnJhZ21lbnQuaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsdWUubWFwKCh2KSA9PiByZXNvbHZlQWRkcmVzcyh2LCByZXNvbHZlcikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyh2YWx1ZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXRUb3BpY0ZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZpbHRlcjtcbiAgICB9XG59XG4vLyBBID0gQXJndW1lbnRzIHBhc3NlZCBpbiBhcyBhIHR1cGxlXG4vLyBSID0gVGhlIHJlc3VsdCB0eXBlIG9mIHRoZSBjYWxsIChpLmUuIGlmIG9ubHkgb25lIHJldHVybiB0eXBlLFxuLy8gICAgIHRoZSBxdWFsaWZpZWQgdHlwZSwgb3RoZXJ3aXNlIFJlc3VsdClcbi8vIEQgPSBUaGUgdHlwZSB0aGUgZGVmYXVsdCBjYWxsIHdpbGwgcmV0dXJuIChpLmUuIFIgZm9yIHZpZXcvcHVyZSxcbi8vICAgICBUcmFuc2FjdGlvblJlc3BvbnNlIG90aGVyd2lzZSlcbi8vZXhwb3J0IGludGVyZmFjZSBDb250cmFjdE1ldGhvZDxBIGV4dGVuZHMgQXJyYXk8YW55PiA9IEFycmF5PGFueT4sIFIgPSBhbnksIEQgZXh0ZW5kcyBSIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlPiB7XG5mdW5jdGlvbiBnZXRSdW5uZXIodmFsdWUsIGZlYXR1cmUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWVbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUucHJvdmlkZXIgJiYgdHlwZW9mICh2YWx1ZS5wcm92aWRlcltmZWF0dXJlXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UHJvdmlkZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyIHx8IG51bGw7XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvcHlPdmVycmlkZXMoYXJnLCBhbGxvd2VkKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBvdmVycmlkZXMgcGFzc2VkIGluIGFyZSBhIHZhbGlkIG92ZXJyaWRlcyBvYmplY3RcbiAgICBjb25zdCBfb3ZlcnJpZGVzID0gVHlwZWQuZGVyZWZlcmVuY2UoYXJnLCBcIm92ZXJyaWRlc1wiKTtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKF9vdmVycmlkZXMpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgb3ZlcnJpZGVzIHBhcmFtZXRlclwiLCBcIm92ZXJyaWRlc1wiLCBhcmcpO1xuICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY29weSAod2UnbGwgZGVlcC1pZnkgYW55dGhpbmcgbmVlZGVkIGR1cmluZyBub3JtYWxpemluZylcbiAgICBjb25zdCBvdmVycmlkZXMgPSBjb3B5UmVxdWVzdChfb3ZlcnJpZGVzKTtcbiAgICBhc3NlcnRBcmd1bWVudChvdmVycmlkZXMudG8gPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcInRvXCIpID49IDAsIFwiY2Fubm90IG92ZXJyaWRlIHRvXCIsIFwib3ZlcnJpZGVzLnRvXCIsIG92ZXJyaWRlcy50byk7XG4gICAgYXNzZXJ0QXJndW1lbnQob3ZlcnJpZGVzLmRhdGEgPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcImRhdGFcIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgZGF0YVwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIG92ZXJyaWRlcy5kYXRhKTtcbiAgICAvLyBSZXNvbHZlIGFueSBmcm9tXG4gICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgIG92ZXJyaWRlcy5mcm9tID0gb3ZlcnJpZGVzLmZyb207XG4gICAgfVxuICAgIHJldHVybiBvdmVycmlkZXM7XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVBcmdzKF9ydW5uZXIsIGlucHV0cywgYXJncykge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcbiAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoX3J1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKGlucHV0cy5tYXAoKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKHZhbHVlLCByZXNvbHZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZEZhbGxiYWNrKGNvbnRyYWN0KSB7XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgLy8gSWYgYW4gb3ZlcnJpZGVzIHdhcyBwYXNzZWQgaW4sIGNvcHkgaXQgYW5kIG5vcm1hbGl6ZSB0aGUgdmFsdWVzXG4gICAgICAgIGNvbnN0IHR4ID0gKGF3YWl0IGNvcHlPdmVycmlkZXMob3ZlcnJpZGVzLCBbXCJkYXRhXCJdKSk7XG4gICAgICAgIHR4LnRvID0gYXdhaXQgY29udHJhY3QuZ2V0QWRkcmVzcygpO1xuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgdHguZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIGdldFJlc29sdmVyKGNvbnRyYWN0LnJ1bm5lcikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmYWNlID0gY29udHJhY3QuaW50ZXJmYWNlO1xuICAgICAgICBjb25zdCBub1ZhbHVlID0gKGdldEJpZ0ludCgodHgudmFsdWUgfHwgQk5fMCksIFwib3ZlcnJpZGVzLnZhbHVlXCIpID09PSBCTl8wKTtcbiAgICAgICAgY29uc3Qgbm9EYXRhID0gKCh0eC5kYXRhIHx8IFwiMHhcIikgPT09IFwiMHhcIik7XG4gICAgICAgIGlmIChpZmFjZS5mYWxsYmFjayAmJiAhaWZhY2UuZmFsbGJhY2sucGF5YWJsZSAmJiBpZmFjZS5yZWNlaXZlICYmICFub0RhdGEgJiYgIW5vVmFsdWUpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZSBvciBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZhbGxiYWNrXCIsIFwib3ZlcnJpZGVzXCIsIG92ZXJyaWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgcGF5YWJsZSBjb250cmFjdHMgdG8gc2V0IG5vbi16ZXJvIHZhbHVlXG4gICAgICAgIGNvbnN0IHBheWFibGUgPSBpZmFjZS5yZWNlaXZlIHx8IChpZmFjZS5mYWxsYmFjayAmJiBpZmFjZS5mYWxsYmFjay5wYXlhYmxlKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocGF5YWJsZSB8fCBub1ZhbHVlLCBcImNhbm5vdCBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZhbGxiYWNrXCIsIFwib3ZlcnJpZGVzLnZhbHVlXCIsIHR4LnZhbHVlKTtcbiAgICAgICAgLy8gT25seSBhbGxvdyBmYWxsYmFjayBjb250cmFjdHMgdG8gc2V0IG5vbi1lbXB0eSBkYXRhXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgIGFzc2VydChjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250cmFjdC5pbnRlcmZhY2UubWFrZUVycm9yKGVycm9yLmRhdGEsIHR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZW5kID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBjb250cmFjdC5ydW5uZXI7XG4gICAgICAgIGFzc2VydChjYW5TZW5kKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XG4gICAgfTtcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJlc3RpbWF0ZUdhc1wiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKG92ZXJyaWRlcykgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZChvdmVycmlkZXMpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIHNlbmQsIHN0YXRpY0NhbGxcbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkTWV0aG9kKGNvbnRyYWN0LCBrZXkpIHtcbiAgICBjb25zdCBnZXRGcmFnbWVudCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uKGtleSwgYXJncyk7XG4gICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgIGluZm86IHsga2V5LCBhcmdzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IHBvcHVsYXRlVHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICAvLyBJZiBhbiBvdmVycmlkZXMgd2FzIHBhc3NlZCBpbiwgY29weSBpdCBhbmQgbm9ybWFsaXplIHRoZSB2YWx1ZXNcbiAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgPT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdmVycmlkZXMgPSBhd2FpdCBjb3B5T3ZlcnJpZGVzKGFyZ3MucG9wKCkpO1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhvdmVycmlkZXMuZnJvbSwgZ2V0UmVzb2x2ZXIoY29udHJhY3QucnVubmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbCBlcnJvcjogZnJhZ21lbnQgaW5wdXRzIGRvZXNuJ3QgbWF0Y2ggYXJndW1lbnRzOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCByZXNvbHZlQXJncyhjb250cmFjdC5ydW5uZXIsIGZyYWdtZW50LmlucHV0cywgYXJncyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHRvOiBjb250cmFjdC5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICBkYXRhOiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGF0aWNDYWxsUmVzdWx0KC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgYXNzZXJ0KGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncykpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XG4gICAgfTtcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgIGFzc2VydChjYW5Fc3RpbWF0ZShydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGdhcyBlc3RpbWF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImVzdGltYXRlR2FzXCIgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuZXN0aW1hdGVHYXMoYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsUmVzdWx0ID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJjYWxsXCIpO1xuICAgICAgICBhc3NlcnQoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJhY3QuaW50ZXJmYWNlLm1ha2VFcnJvcihlcnJvci5kYXRhLCB0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc3RhdGljQ2FsbCguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZCguLi5hcmdzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbk5hbWUoa2V5KSxcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxuICAgICAgICBnZXRGcmFnbWVudCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIHNlbmQsIHN0YXRpY0NhbGwsIHN0YXRpY0NhbGxSZXN1bHQsXG4gICAgfSk7XG4gICAgLy8gT25seSB3b3JrcyBvbiBub24tYW1iaWd1b3VzIGtleXMgKHJlZmluZWQgZnJhZ21lbnQgaXMgYWx3YXlzIG5vbi1hbWJpZ3VvdXMpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGhvZCwgXCJmcmFnbWVudFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb24oa2V5KTtcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRXZlbnQoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5LCBhcmdzKTtcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVwYXJlZFRvcGljRmlsdGVyKGNvbnRyYWN0LCBnZXRGcmFnbWVudCguLi5hcmdzKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBuYW1lOiBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnROYW1lKGtleSksXG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsIF9rZXk6IGtleSxcbiAgICAgICAgZ2V0RnJhZ21lbnRcbiAgICB9KTtcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChrZXkpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG4vLyBUaGUgY29tYmluYXRpb24gb2YgVHlwZVNjcnlwZSwgUHJpdmF0ZSBGaWVsZHMgYW5kIFByb3hpZXMgbWFrZXNcbi8vIHRoZSB3b3JsZCBnbyBib29tOyBzbyB3ZSBoaWRlIHZhcmlhYmxlcyB3aXRoIHNvbWUgdHJpY2tlcnkga2VlcGluZ1xuLy8gYSBzeW1ib2wgYXR0YWNoZWQgdG8gZWFjaCBCYXNlQ29udHJhY3Qgd2hpY2ggaXRzIHN1Yi1jbGFzcyAoZXZlblxuLy8gdmlhIGEgUHJveHkpIGNhbiByZWFjaCBhbmQgdXNlIHRvIGxvb2sgdXAgaXRzIGludGVybmFsIHZhbHVlcy5cbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNJbnRlcm5hbF9jb250cmFjdFwiKTtcbmNvbnN0IGludGVybmFsVmFsdWVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHNldEludGVybmFsKGNvbnRyYWN0LCB2YWx1ZXMpIHtcbiAgICBpbnRlcm5hbFZhbHVlcy5zZXQoY29udHJhY3RbaW50ZXJuYWxdLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWwoY29udHJhY3QpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxWYWx1ZXMuZ2V0KGNvbnRyYWN0W2ludGVybmFsXSk7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiAoXCJnZXRUb3BpY0ZpbHRlclwiIGluIHZhbHVlKSAmJlxuICAgICAgICAodHlwZW9mICh2YWx1ZS5nZXRUb3BpY0ZpbHRlcikgPT09IFwiZnVuY3Rpb25cIikgJiYgdmFsdWUuZnJhZ21lbnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpIHtcbiAgICBsZXQgdG9waWNzO1xuICAgIGxldCBmcmFnbWVudCA9IG51bGw7XG4gICAgLy8gQ29udmVydCBuYW1lZCBldmVudHMgdG8gdG9waWNIYXNoIGFuZCBnZXQgdGhlIGZyYWdtZW50IGZvclxuICAgIC8vIGV2ZW50cyB3aGljaCBuZWVkIGRlY29uc3RydWN0aW5nLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBjb25zdCB0b3BpY0hhc2hpZnkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWUsIDMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobmFtZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJ1bmtub3duIGZyYWdtZW50XCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFycmF5IG9mIFRvcGljcyBhbmQgTmFtZXM7IGUuZy4gYFsgXCIweDEyMzQuLi44OWFiXCIsIFwiVHJhbnNmZXIoYWRkcmVzcylcIiBdYFxuICAgICAgICB0b3BpY3MgPSBldmVudC5tYXAoKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUubWFwKHRvcGljSGFzaGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9waWNIYXNoaWZ5KGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQgPT09IFwiKlwiKSB7XG4gICAgICAgIHRvcGljcyA9IFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChldmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGV2ZW50LCAzMikpIHtcbiAgICAgICAgICAgIC8vIFRvcGljIEhhc2hcbiAgICAgICAgICAgIHRvcGljcyA9IFtldmVudF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOYW1lIG9yIFNpZ25hdHVyZTsgZS5nLiBgXCJUcmFuc2ZlclwiLCBgXCJUcmFuc2ZlcihhZGRyZXNzKVwiYFxuICAgICAgICAgICAgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcImV2ZW50XCIsIGV2ZW50KTtcbiAgICAgICAgICAgIHRvcGljcyA9IFtmcmFnbWVudC50b3BpY0hhc2hdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVmZXJyZWQoZXZlbnQpKSB7XG4gICAgICAgIC8vIERlZmVycmVkIFRvcGljIEZpbHRlcjsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyKGZyb20pYFxuICAgICAgICB0b3BpY3MgPSBhd2FpdCBldmVudC5nZXRUb3BpY0ZpbHRlcigpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcImZyYWdtZW50XCIgaW4gZXZlbnQpIHtcbiAgICAgICAgLy8gQ29udHJhY3RFdmVudDsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyYFxuICAgICAgICBmcmFnbWVudCA9IGV2ZW50LmZyYWdtZW50O1xuICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gZXZlbnQgbmFtZVwiLCBcImV2ZW50XCIsIGV2ZW50KTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljcyBhbmQgc29ydCBUb3BpY1NldHNcbiAgICB0b3BpY3MgPSB0b3BpY3MubWFwKCh0KSA9PiB7XG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20obmV3IFNldCh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSkudmFsdWVzKCkpO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1zLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHRhZyA9IHRvcGljcy5tYXAoKHQpID0+IHtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9KS5qb2luKFwiJlwiKTtcbiAgICByZXR1cm4geyBmcmFnbWVudCwgdGFnLCB0b3BpY3MgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhc1N1Yihjb250cmFjdCwgZXZlbnQpIHtcbiAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKGNvbnRyYWN0KTtcbiAgICByZXR1cm4gc3Vicy5nZXQoKGF3YWl0IGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KSkudGFnKSB8fCBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViKGNvbnRyYWN0LCBvcGVyYXRpb24sIGV2ZW50KSB7XG4gICAgLy8gTWFrZSBzdXJlIG91ciBydW5uZXIgY2FuIGFjdHVhbGx5IHN1YnNjcmliZSB0byBldmVudHNcbiAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHN1YnNjcmliaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCk7XG4gICAgY29uc3QgeyBhZGRyLCBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XG4gICAgbGV0IHN1YiA9IHN1YnMuZ2V0KHRhZyk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IGNvbnRyYWN0KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MgfTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBmcmFnbWVudCBpcyBudWxsLCB3ZSBkbyBub3QgZGVjb25zdHJ1Y3QgdGhlIGFyZ3MgdG8gZW1pdFxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZm91bmRGcmFnbWVudCA9IGZvdW5kRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGZyYWdtZW50ID8gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcykgOiBbXTtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RFdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgX2ZvdW5kRnJhZ21lbnQsIGxvZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgW10sIChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBsb2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRpbmcucHVzaChwcm92aWRlci5vbihmaWx0ZXIsIGxpc3RlbmVyKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRlZCA9IHN0YXJ0aW5nO1xuICAgICAgICAgICAgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHN0YXJ0ZWQpO1xuICAgICAgICAgICAgcHJvdmlkZXIub2ZmKGZpbHRlciwgbGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgICAgICBzdWIgPSB7IHRhZywgbGlzdGVuZXJzOiBbXSwgc3RhcnQsIHN0b3AgfTtcbiAgICAgICAgc3Vicy5zZXQodGFnLCBzdWIpO1xuICAgIH1cbiAgICByZXR1cm4gc3ViO1xufVxuLy8gV2UgdXNlIHRoaXMgdG8gZW5zdXJlIG9uZSBlbWl0IHJlc29sdmVzIGJlZm9yZSBmaXJpbmcgdGhlIG5leHQgdG9cbi8vIGVuc3VyZSBjb3JyZWN0IG9yZGVyaW5nIChub3RlIHRoaXMgY2Fubm90IHRocm93IGFuZCBqdXN0IGFkZHMgdGhlXG4vLyBub3RpY2UgdG8gdGhlIGV2ZW50IHF1ZXUgdXNpbmcgc2V0VGltZW91dCkuXG5sZXQgbGFzdEVtaXQgPSBQcm9taXNlLnJlc29sdmUoKTtcbmFzeW5jIGZ1bmN0aW9uIF9lbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcbiAgICBhd2FpdCBsYXN0RW1pdDtcbiAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIoY29udHJhY3QsIGV2ZW50KTtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcbiAgICAgICAgY29uc3QgcGFzc0FyZ3MgPSBBcnJheS5mcm9tKGFyZ3MpO1xuICAgICAgICBpZiAocGF5bG9hZEZ1bmMpIHtcbiAgICAgICAgICAgIHBhc3NBcmdzLnB1c2gocGF5bG9hZEZ1bmMob25jZSA/IG51bGwgOiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKGNvbnRyYWN0LCAuLi5wYXNzQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgIH0pO1xuICAgIGlmIChzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICBnZXRJbnRlcm5hbChjb250cmFjdCkuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgfVxuICAgIHJldHVybiAoY291bnQgPiAwKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYykge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGxhc3RFbWl0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIGNvbnN0IHJlc3VsdFByb21pc2UgPSBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKTtcbiAgICBsYXN0RW1pdCA9IHJlc3VsdFByb21pc2U7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3VsdFByb21pc2U7XG59XG5jb25zdCBwYXNzUHJvcGVydGllcyA9IFtcInRoZW5cIl07XG5leHBvcnQgY2xhc3MgQmFzZUNvbnRyYWN0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRhcmdldCB0byBjb25uZWN0IHRvLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIGFuIGFkZHJlc3MsIEVOUyBuYW1lIG9yIGFueSBbW0FkZHJlc3NhYmxlXV0sIHN1Y2ggYXNcbiAgICAgKiAgYW5vdGhlciBjb250cmFjdC4gVG8gZ2V0IHRoZSByZXNvdmxlZCBhZGRyZXNzLCB1c2UgdGhlIGBgZ2V0QWRkcmVzc2BgXG4gICAgICogIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHJ1bm5lci4gVGhpcyBpcyBnZW5lcmFsbHkgYSBbW1Byb3ZpZGVyXV0gb3IgYVxuICAgICAqICBbW1NpZ25lcl1dLCB3aGljaCBkaWN0YXRlcyB3aGF0IG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSAqKkNvbnRyYWN0KiogY29ubmVjdGVkIHRvIGEgW1tQcm92aWRlcl1dIG1heVxuICAgICAqICBvbmx5IGV4ZWN1dGUgcmVhZC1vbmx5IG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgcnVubmVyO1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIEV2ZW50cyBhdmFpbGFibGUgb24gdGhpcyBjb250cmFjdC5cbiAgICAgKi9cbiAgICBmaWx0ZXJzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBbaW50ZXJuYWxdO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmFsbGJhY2sgb3IgcmVjZWl2ZSBmdW5jdGlvbiBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgY29udHJhY3QgY29ubmVjdGVkIHRvICUldGFyZ2V0JSUgd2l0aCB0aGUgJSVhYmklJSBhbmRcbiAgICAgKiAgb3B0aW9uYWxseSBjb25uZWN0ZWQgdG8gYSAlJXJ1bm5lciUlIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBiZWhhbGZcbiAgICAgKiAgb2YuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBhYmksIHJ1bm5lciwgX2RlcGxveVR4KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIiB8fCBpc0FkZHJlc3NhYmxlKHRhcmdldCksIFwiaW52YWxpZCB2YWx1ZSBmb3IgQ29udHJhY3QgdGFyZ2V0XCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZmFjZSA9IEludGVyZmFjZS5mcm9tKGFiaSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyB0YXJnZXQsIHJ1bm5lciwgaW50ZXJmYWNlOiBpZmFjZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiB7fSB9KTtcbiAgICAgICAgbGV0IGFkZHJQcm9taXNlO1xuICAgICAgICBsZXQgYWRkciA9IG51bGw7XG4gICAgICAgIGxldCBkZXBsb3lUeCA9IG51bGw7XG4gICAgICAgIGlmIChfZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIocnVubmVyKTtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgICAgIGRlcGxveVR4ID0gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLmludGVyZmFjZSwgcHJvdmlkZXIsIF9kZXBsb3lUeCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHRhcmdldCBhcyB0aGUgYWRkcmVzc1xuICAgICAgICBpZiAodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGFkZHIgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZ2V0UnVubmVyKHJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhblJlc29sdmUocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcihcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IG5hbWUgcmVzb2x1dGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKFwiYW4gRU5TIG5hbWUgdXNlZCBmb3IgYSBjb250cmFjdCB0YXJnZXQgbXVzdCBiZSBjb3JyZWN0bHkgY29uZmlndXJlZFwiLCBcIlVOQ09ORklHVVJFRF9OQU1FXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHRhcmdldC5nZXRBZGRyZXNzKCkudGhlbigoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3VyIHByaXZhdGUgdmFsdWVzXG4gICAgICAgIHNldEludGVybmFsKHRoaXMsIHsgYWRkclByb21pc2UsIGFkZHIsIGRlcGxveVR4LCBzdWJzIH0pO1xuICAgICAgICAvLyBBZGQgdGhlIGV2ZW50IGZpbHRlcnNcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFdmVudChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAocGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSB8fCB0aGlzLmludGVyZmFjZS5oYXNFdmVudChTdHJpbmcocHJvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZpbHRlcnMgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZmFsbGJhY2s6ICgoaWZhY2UucmVjZWl2ZSB8fCBpZmFjZS5mYWxsYmFjaykgPyAoYnVpbGRXcmFwcGVkRmFsbGJhY2sodGhpcykpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiBhIFByb3h5IHRoYXQgd2lsbCByZXNwb25kIHRvIGZ1bmN0aW9uc1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbmRlZmluZWQgcHJvcGVydGllcyBzaG91bGQgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0RnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuaW50ZXJmYWNlLmhhc0Z1bmN0aW9uKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBDb250cmFjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHRhcmdldCBhbmQgQUJJLCBidXRcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSVydW5uZXIlJS5cbiAgICAgKi9cbiAgICBjb25uZWN0KHJ1bm5lcikge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0aGlzLnRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHJ1bm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBBQkkgYW5kIHJ1bm5lciwgYnV0XG4gICAgICogIGEgZGlmZmVyZW50ICUldGFyZ2V0JSUuXG4gICAgICovXG4gICAgYXR0YWNoKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnJ1bm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHJlc29sdmVkIGFkZHJlc3Mgb2YgdGhpcyBDb250cmFjdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gYXdhaXQgZ2V0SW50ZXJuYWwodGhpcykuYWRkclByb21pc2U7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBkZXBsb3llZCBieXRlY29kZSBvciBudWxsIGlmIG5vIGJ5dGVjb2RlIGlzIGZvdW5kLlxuICAgICAqL1xuICAgIGFzeW5jIGdldERlcGxveWVkQ29kZSgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRDb2RlXCIgfSk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBwcm92aWRlci5nZXRDb2RlKGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoaXMgQ29udHJhY3Qgb25jZSB0aGUgYnl0ZWNvZGUgaGFzIGJlZW4gZGVwbG95ZWQsIG9yXG4gICAgICogIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgYWxyZWFkeSBkZXBsb3llZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yRGVwbG95bWVudCgpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZGVwbG95ZW1lbnQgdHJhbnNhY3Rpb247IGp1c3QgdXNlIHRoYXQgKHRocm93cyBpZiBkZXBsb3llbWVudCBmYWlscylcbiAgICAgICAgY29uc3QgZGVwbG95VHggPSB0aGlzLmRlcGxveW1lbnRUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAoZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGF3YWl0IGRlcGxveVR4LndhaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIHN1YnNjcmliZSB0byBhIHByb3ZpZGVyIGV2ZW50XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIgIT0gbnVsbCwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwid2FpdEZvckRlcGxveW1lbnRcIiB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrQ29kZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5nZXREZXBsb3llZENvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub25jZShcImJsb2NrXCIsIGNoZWNrQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja0NvZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRyYW5zYWN0aW9uIHVzZWQgdG8gZGVwbG95IHRoaXMgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpZiB0aGlzIGluc3RhbmNlIHdhcyByZXR1cm5lZCBmcm9tIGFcbiAgICAgKiAgW1tDb250cmFjdEZhY3RvcnldXS5cbiAgICAgKi9cbiAgICBkZXBsb3ltZW50VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbCh0aGlzKS5kZXBsb3lUeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIG1ldGhvZCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuYyA9IGJ1aWxkV3JhcHBlZE1ldGhvZCh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZXZlbnQgZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIGV2ZW50IG5hbWUgY29uZmxpY3RzIHdpdGggYSBKYXZhU2NyaXB0IG5hbWUgc3VjaCBhcyBgYHByb3RvdHlwZWBgIG9yXG4gICAgICogIHdoZW4gdXNpbmcgYSBDb250cmFjdCBwcm9ncmFtYXRpY2FsbHkuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGtleSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5mb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRXcmFwcGVkRXZlbnQodGhpcywga2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLypcbiAgICAvLyBAVE9ETzogdGhpcyBpcyBhIG5vbi1iYWNrd2FyZHMgY29tcGF0aWJsZSBjaGFuZ2UsIGJ1dCB3aWxsIGJlIGFkZGVkXG4gICAgLy8gICAgICAgIGluIHY3IGFuZCBpbiBhIHBvdGVudGlhbCBTbWFydENvbnRyYWN0IGNsYXNzIGluIGFuIHVwY29taW5nXG4gICAgLy8gICAgICAgIHY2IHJlbGVhc2VcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaDogc3RyaW5nKTogUHJvbWlzZTxudWxsIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3QgaGF2ZSBhIHByb3ZpZGVyXCIsXG4gICAgICAgICAgICBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeVRyYW5zYWN0aW9uXCIgfSk7XG5cbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCByZWNlaXB0KTtcbiAgICB9XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZSBoaXN0b3JpYyBhY2Nlc3MgdG8gZXZlbnQgZGF0YSBmb3IgJSVldmVudCUlIGluIHRoZSByYW5nZVxuICAgICAqICAlJWZyb21CbG9jayUlIChkZWZhdWx0OiBgYDBgYCkgdG8gJSV0b0Jsb2NrJSUgKGRlZmF1bHQ6IGBgXCJsYXRlc3RcImBgKVxuICAgICAqICBpbmNsdXNpdmUuXG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlGaWx0ZXIoZXZlbnQsIGZyb21CbG9jaywgdG9CbG9jaykge1xuICAgICAgICBpZiAoZnJvbUJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIGZyb21CbG9jayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9CbG9jayA9IFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhZGRyLCBhZGRyUHJvbWlzZSB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoYWRkciA/IGFkZHIgOiAoYXdhaXQgYWRkclByb21pc2UpKTtcbiAgICAgICAgY29uc3QgeyBmcmFnbWVudCwgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MsIGZyb21CbG9jaywgdG9CbG9jayB9O1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBoYXZlIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlGaWx0ZXJcIiB9KTtcbiAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlci5nZXRMb2dzKGZpbHRlcikpLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuaW50ZXJmYWNlLCBmb3VuZEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJS5cbiAgICAgKi9cbiAgICBhc3luYyBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgZ2V0U3ViKHRoaXMsIFwib25cIiwgZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogZmFsc2UgfSk7XG4gICAgICAgIHN1Yi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFkZCBhbiBldmVudCAlJWxpc3RlbmVyJSUgZm9yIHRoZSAlJWV2ZW50JSUsIGJ1dCByZW1vdmUgdGhlIGxpc3RlbmVyXG4gICAgICogIGFmdGVyIGl0IGlzIGZpcmVkIG9uY2UuXG4gICAgICovXG4gICAgYXN5bmMgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgZ2V0U3ViKHRoaXMsIFwib25jZVwiLCBldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBzdWIuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbWl0IGFuICUlZXZlbnQlJSBjYWxsaW5nIGFsbCBsaXN0ZW5lcnMgd2l0aCAlJWFyZ3MlJS5cbiAgICAgKlxuICAgICAqICBSZXNvbHZlcyB0byBgYHRydWVgYCBpZiBhbnkgbGlzdGVuZXJzIHdlcmUgY2FsbGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVtaXQodGhpcywgZXZlbnQsIGFyZ3MsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgb2YgJSVldmVudCUlIG9yIHRoZSB0b3RhbCBudW1iZXJcbiAgICAgKiAgb2YgbGlzdGVuZXJzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbGlzdGVuZXJzIHN1YnNjcmliZWQgdG8gJSVldmVudCUlIG9yIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVtb3ZlIHRoZSAlJWxpc3RlbmVyJSUgZnJvbSB0aGUgbGlzdGVuZXJzIGZvciAlJWV2ZW50JSUgb3IgcmVtb3ZlXG4gICAgICogIGFsbCBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmUgYWxsIGxpc3RlbmVycyBpZlxuICAgICAqICB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFnLCBzdG9wIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICBzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxpYXMgZm9yIFtvbl0uXG4gICAgICovXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGlhcyBmb3IgW29mZl0uXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IENsYXNzIGZvciB0aGUgJSVhYmklJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRDbGFzcyhhYmkpIHtcbiAgICAgICAgY2xhc3MgQ3VzdG9tQ29udHJhY3QgZXh0ZW5kcyBCYXNlQ29udHJhY3Qge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoYWRkcmVzcywgcnVubmVyID0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKGFkZHJlc3MsIGFiaSwgcnVubmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ3VzdG9tQ29udHJhY3Q7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEJhc2VDb250cmFjdCB3aXRoIGEgc3BlY2lmaWVkIEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0YXJnZXQsIGFiaSwgcnVubmVyKSB7XG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyB0aGlzKHRhcmdldCwgYWJpLCBydW5uZXIpO1xuICAgICAgICByZXR1cm4gY29udHJhY3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gX0NvbnRyYWN0QmFzZSgpIHtcbiAgICByZXR1cm4gQmFzZUNvbnRyYWN0O1xufVxuLyoqXG4gKiAgQSBbW0Jhc2VDb250cmFjdF1dIHdpdGggbm8gdHlwZSBndWFyZHMgb24gaXRzIG1ldGhvZHMgb3IgZXZlbnRzLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBfQ29udHJhY3RCYXNlKCkge1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QuanMubWFwIiwiLyoqXG4gKiAgRU5TIGlzIGEgc2VydmljZSB3aGljaCBhbGxvd3MgZWFzeS10by1yZW1lbWJlciBuYW1lcyB0byBtYXAgdG9cbiAqICBuZXR3b3JrIGFkZHJlc3Nlcy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Vucy1yZXNvbHZlcjpFTlMgUmVzb2x2ZXIgIFthYm91dC1lbnMtcnNvbHZlcl1cbiAqL1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBaZXJvQWRkcmVzcyB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkbnNFbmNvZGUsIG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGhleGxpZnksIGlzSGV4U3RyaW5nLCB0b0JlSGV4LCBkZWZpbmVQcm9wZXJ0aWVzLCBlbmNvZGVCYXNlNTgsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzRXJyb3IsIEZldGNoUmVxdWVzdCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gQFRPRE86IFRoaXMgc2hvdWxkIHVzZSB0aGUgZmV0Y2gtZGF0YTppcGZzIGdhdGV3YXlcbi8vIFRyaW0gb2ZmIHRoZSBpcGZzOi8vIHByZWZpeCBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0IGdhdGV3YXkgVVJMXG5mdW5jdGlvbiBnZXRJcGZzTGluayhsaW5rKSB7XG4gICAgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcL2lwZnNcXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDEyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZyg3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIElQRlMgZm9ybWF0XCIsIFwibGlua1wiLCBsaW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIGBodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvJHtsaW5rfWA7XG59XG47XG47XG4vKipcbiAqICBBIHByb3ZpZGVyIHBsdWdpbiBzdXBlci1jbGFzcyBmb3IgcHJvY2Vzc2luZyBtdWx0aWNvaW4gYWRkcmVzcyB0eXBlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk11bHRpY29pblByb3ZpZGVyUGx1aW5nKiogZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvaXZkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlY29pblR5cGUlJSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBwbHVnaW4uXG4gICAgICovXG4gICAgc3VwcG9ydHNDb2luVHlwZShjb2luVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZW5jb2RlZCAlJWFkZHJlc3MlJSBmb3IgJSVjb2luVHlwZSUlLlxuICAgICAqL1xuICAgIGFzeW5jIGVuY29kZUFkZHJlc3MoY29pblR5cGUsIGFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY29pblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBkZWNvZGVkICUlZGF0YSUlIGZvciAlJWNvaW5UeXBlJSUuXG4gICAgICovXG4gICAgYXN5bmMgZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xuICAgIH1cbn1cbmNvbnN0IEJhc2ljTXVsdGljb2luUGx1Z2luSWQgPSBcIm9yZy5ldGhlcnMucGx1Z2lucy5wcm92aWRlci5CYXNpY011bHRpY29pblwiO1xuLyoqXG4gKiAgQSAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKiBwcm92aWRlcyBzZXJ2aWNlIGZvciBjb21tb25cbiAqICBjb2luIHR5cGVzLCB3aGljaCBkbyBub3QgcmVxdWlyZSBhZGRpdGlvbmFsIGxpYnJhcmllcyB0byBlbmNvZGUgb3JcbiAqICBkZWNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luIGV4dGVuZHMgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihCYXNpY011bHRpY29pblBsdWdpbklkKTtcbiAgICB9XG59XG5jb25zdCBtYXRjaGVySXBmcyA9IG5ldyBSZWdFeHAoXCJeKGlwZnMpOi9cXC8oLiopJFwiLCBcImlcIik7XG5jb25zdCBtYXRjaGVycyA9IFtcbiAgICBuZXcgUmVnRXhwKFwiXihodHRwcyk6L1xcLyguKikkXCIsIFwiaVwiKSxcbiAgICBuZXcgUmVnRXhwKFwiXihkYXRhKTooLiopJFwiLCBcImlcIiksXG4gICAgbWF0Y2hlcklwZnMsXG4gICAgbmV3IFJlZ0V4cChcIl5laXAxNTU6WzAtOV0rLyhlcmNbMC05XSspOiguKikkXCIsIFwiaVwiKSxcbl07XG4vKipcbiAqICBBIGNvbm5lY3RlZCBvYmplY3QgdG8gYSByZXNvbHZlZCBFTlMgbmFtZSByZXNvbHZlciwgd2hpY2ggY2FuIGJlXG4gKiAgdXNlZCB0byBxdWVyeSBhZGRpdGlvbmFsIGRldGFpbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnNSZXNvbHZlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSByZXNvbHZlci5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSB0aGlzIHJlc29sdmVyIHdhcyByZXNvbHZlZCBhZ2FpbnN0LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLy8gRm9yIEVJUC0yNTQ0IG5hbWVzLCB0aGUgYW5jZXN0b3IgdGhhdCBwcm92aWRlZCB0aGUgcmVzb2x2ZXJcbiAgICAjc3VwcG9ydHMyNTQ0O1xuICAgICNyZXNvbHZlcjtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcywgbmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUgfSk7XG4gICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3Jlc29sdmVyID0gbmV3IENvbnRyYWN0KGFkZHJlc3MsIFtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gc3VwcG9ydHNJbnRlcmZhY2UoYnl0ZXM0KSB2aWV3IHJldHVybnMgKGJvb2wpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmUoYnl0ZXMsIGJ5dGVzKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBhZGRyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyLCB1aW50KSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiB0ZXh0KGJ5dGVzMzIsIHN0cmluZykgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGNvbnRlbnRoYXNoKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXG4gICAgICAgIF0sIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRydWUgaWYgdGhlIHJlc29sdmVyIHN1cHBvcnRzIHdpbGRjYXJkIHJlc29sdXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgc3VwcG9ydHNXaWxkY2FyZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3N1cHBvcnRzMjU0NCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNyZXNvbHZlci5zdXBwb3J0c0ludGVyZmFjZShcIjB4OTA2MWI5MjNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaWxkY2FyZCByZXNvbHZlcnMgbXVzdCB1bmRlcnN0YW5kIHN1cHBvcnRzSW50ZXJmYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBMZXQgZnV0dXJlIGF0dGVtcHRzIHRyeSBhZ2Fpbi4uLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNzdXBwb3J0czI1NDQ7XG4gICAgfVxuICAgIGFzeW5jICNmZXRjaChmdW5jTmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gdGhpcy4jcmVzb2x2ZXIuaW50ZXJmYWNlO1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFyYW1ldGVycyBpcyBhbHdheXMgdGhlIG5vZGVoYXNoXG4gICAgICAgIHBhcmFtcy51bnNoaWZ0KG5hbWVoYXNoKHRoaXMubmFtZSkpO1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5zdXBwb3J0c1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gaWZhY2UuZ2V0RnVuY3Rpb24oZnVuY05hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm1pc3NpbmcgZnJhZ21lbnRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHtcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGZ1bmNOYW1lIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zID0gW1xuICAgICAgICAgICAgICAgIGRuc0VuY29kZSh0aGlzLm5hbWUsIDI1NSksXG4gICAgICAgICAgICAgICAgaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCBwYXJhbXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZnVuY05hbWUgPSBcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLnB1c2goe1xuICAgICAgICAgICAgZW5hYmxlQ2NpcFJlYWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNyZXNvbHZlcltmdW5jTmFtZV0oLi4ucGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWNvaW5UeXBlJSUgb3IgbnVsbCBpZiB0aGVcbiAgICAgKiAgcHJvdmlkZWQgJSVjb2luVHlwZSUlIGhhcyBub3QgYmVlbiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoY29pblR5cGUpIHtcbiAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvaW5UeXBlID0gNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5UeXBlID09PSA2MCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMilcIik7XG4gICAgICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IFplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSBkZWNvZGluZyBpdHMgRVZNIGNhbm9uaWNhbCBjaGFpbiBhcyBhbiBFVk0gY2hhaW4gYWRkcmVzcyBmaXJzdFxuICAgICAgICBpZiAoY29pblR5cGUgPj0gMCAmJiBjb2luVHlwZSA8IDB4ODAwMDAwMDApIHtcbiAgICAgICAgICAgIGxldCBldGhDb2luVHlwZSA9IGNvaW5UeXBlICsgMHg4MDAwMDAwMDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMix1aW50KVwiLCBbZXRoQ29pblR5cGVdKTtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCAyMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29pblBsdWdpbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucHJvdmlkZXIucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKCEocGx1Z2luIGluc3RhbmNlb2YgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGx1Z2luLnN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29pblBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pblBsdWdpbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIsdWludDI1NlwiKVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2NvaW5UeXBlXSk7XG4gICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGFkZHJlc3NcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IGNvaW5QbHVnaW4uZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSk7XG4gICAgICAgIGlmIChhZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgY29pbiBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgLFxuICAgICAgICAgICAgaW5mbzogeyBjb2luVHlwZSwgZGF0YSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIEVJUC02MzQgdGV4dCByZWNvcmQgZm9yICUla2V5JSUsIG9yIGBgbnVsbGBgXG4gICAgICogIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUZXh0KGtleSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJ0ZXh0KGJ5dGVzMzIsc3RyaW5nKVwiLCBba2V5XSk7XG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJzb2x2ZXMgdG8gdGhlIGNvbnRlbnQtaGFzaCBvciBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29udGVudEhhc2goKSB7XG4gICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiY29udGVudGhhc2goYnl0ZXMzMilcIik7XG4gICAgICAgIC8vIE5vIGNvbnRlbnRoYXNoXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJUEZTIChDSUQ6IDEsIFR5cGU6IDcwPURBRy1QQiwgNzI9bGlicDJwLWtleSlcbiAgICAgICAgY29uc3QgaXBmcyA9IGRhdGEubWF0Y2goL14weChlMzAxMDE3MHxlNTAxMDE3MikoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuICAgICAgICBpZiAoaXBmcykge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gKGlwZnNbMV0gPT09IFwiZTMwMTAxNzBcIikgPyBcImlwZnNcIiA6IFwiaXBuc1wiO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoaXBmc1s0XSwgMTYpO1xuICAgICAgICAgICAgaWYgKGlwZnNbNV0ubGVuZ3RoID09PSBsZW5ndGggKiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NjaGVtZX06L1xcLyR7ZW5jb2RlQmFzZTU4KFwiMHhcIiArIGlwZnNbMl0pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3dhcm0gKENJRDogMSwgVHlwZTogc3dhcm0tbWFuaWZlc3Q7IGhhc2gvbGVuZ3RoIGhhcmQtY29kZWQgdG8ga2VjY2FrMjU2LzMyKVxuICAgICAgICBjb25zdCBzd2FybSA9IGRhdGEubWF0Y2goL14weGU0MDEwMWZhMDExYjIwKFswLTlhLWZdKikkLyk7XG4gICAgICAgIGlmIChzd2FybSAmJiBzd2FybVsxXS5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICByZXR1cm4gYGJ6ejovXFwvJHtzd2FybVsxXX1gO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0Q29udGVudEhhc2goKVwiLFxuICAgICAgICAgICAgaW5mbzogeyBkYXRhIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYXZhdGFyIHVybCBvciBgYG51bGxgYCBpZiB0aGUgYXZhdGFyIGlzIGVpdGhlclxuICAgICAqICB1bmNvbmZpZ3VyZWQgb3IgaW5jb3JyZWN0bHkgY29uZmlndXJlZCAoZS5nLiByZWZlcmVuY2VzIGFuIE5GVFxuICAgICAqICBub3Qgb3duZWQgYnkgdGhlIGFkZHJlc3MpLlxuICAgICAqXG4gICAgICogIElmIGRpYWdub3NpbmcgaXNzdWVzIHdpdGggY29uZmlndXJhdGlvbnMsIHRoZSBbW19nZXRBdmF0YXJdXVxuICAgICAqICBtZXRob2QgbWF5IGJlIHVzZWZ1bC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdmF0YXIoKSB7XG4gICAgICAgIGNvbnN0IGF2YXRhciA9IGF3YWl0IHRoaXMuX2dldEF2YXRhcigpO1xuICAgICAgICByZXR1cm4gYXZhdGFyLnVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdoZW4gcmVzb2x2aW5nIGFuIGF2YXRhciwgdGhlcmUgYXJlIG1hbnkgc3RlcHMgaW52b2x2ZWQsIHN1Y2hcbiAgICAgKiAgZmV0Y2hpbmcgbWV0YWRhdGEgYW5kIHBvc3NpYmx5IHZhbGlkYXRpbmcgb3duZXJzaGlwIG9mIGFuXG4gICAgICogIE5GVC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBleGFtaW5lIGVhY2ggc3RlcCBhbmQgdGhlIHZhbHVlIGl0XG4gICAgICogIHdhcyB3b3JraW5nIGZyb20uXG4gICAgICovXG4gICAgYXN5bmMgX2dldEF2YXRhcigpIHtcbiAgICAgICAgY29uc3QgbGlua2FnZSA9IFt7IHR5cGU6IFwibmFtZVwiLCB2YWx1ZTogdGhpcy5uYW1lIH1dO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gdGVzdCBkYXRhIGZvciByaWNtb28uZXRoXG4gICAgICAgICAgICAvL2NvbnN0IGF2YXRhciA9IFwiZWlwMTU1OjEvZXJjNzIxOjB4MjY1Mzg1YzdmNDEzMjIyOEEwZDU0RUIxQTllNzQ2MGI5MWMwY0M2OC8yOTIzM1wiO1xuICAgICAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5nZXRUZXh0KFwiYXZhdGFyXCIpO1xuICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhYXZhdGFyXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJhdmF0YXJcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGF2YXRhci5tYXRjaChtYXRjaGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlwZnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZ2V0SXBmc0xpbmsoYXZhdGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaXBmc1wiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IHVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmM3MjFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzExNTVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBFUkMgdHlwZSwgdXNlIHRva2VuVVJJKHVpbnQyNTYpIG9yIHVybCh1aW50MjU2KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoc2NoZW1lID09PSBcImVyYzcyMVwiKSA/IFwidG9rZW5VUkkodWludDI1NilcIiA6IFwidXJpKHVpbnQyNTYpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBzY2hlbWUsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3duZXIgb2YgdGhpcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvd25lciA9IGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG1hdGNoWzJdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBgISR7c2NoZW1lfWNhaXBgLCB2YWx1ZTogKG1hdGNoWzJdIHx8IFwiXCIpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IGNvbXBzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoY29tcHNbMF0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtNzIxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiB0b2tlblVSSSh1aW50KSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIG93bmVyT2YodWludCkgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy0xMTU1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiB1cmkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBiYWxhbmNlT2YoYWRkcmVzcywgdWludDI1NikgdmlldyByZXR1cm5zICh1aW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhpcyBhY2NvdW50IG93bnMgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzcyMVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Pd25lciA9IGF3YWl0IGNvbnRyYWN0Lm93bmVyT2YodG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyICE9PSB0b2tlbk93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW93bmVyXCIsIHZhbHVlOiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY29udHJhY3QuYmFsYW5jZU9mKG93bmVyLCB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhYmFsYW5jZVwiLCB2YWx1ZTogXCIwXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImJhbGFuY2VcIiwgdmFsdWU6IGJhbGFuY2UudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIHRva2VuIGNvbnRyYWN0IGZvciB0aGUgbWV0YWRhdGEgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGFVcmwgPSBhd2FpdCBjb250cmFjdFtzZWxlY3Rvcl0odG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwgPT0gbnVsbCB8fCBtZXRhZGF0YVVybCA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGEtdXJsXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtYmFzZVwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NSBhbGxvd3MgYSBnZW5lcmljIHtpZH0gaW4gdGhlIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IG1ldGFkYXRhVXJsLnJlcGxhY2UoXCJ7aWR9XCIsIHRvQmVIZXgodG9rZW5JZCwgMzIpLnN1YnN0cmluZygyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtZXhwYW5kZWRcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbWV0YWRhdGEgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybC5tYXRjaCgvXmlwZnM6L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBnZXRJcGZzTGluayhtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybFwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRva2VuIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKG5ldyBGZXRjaFJlcXVlc3QobWV0YWRhdGFVcmwpKS5zZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHJlc3BvbnNlLmJvZHlKc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IHJlc3BvbnNlLmJvZHlUZXh0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiBoZXhsaWZ5KGJ5dGVzKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIHZhbHVlOiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdWxsIHRoZSBpbWFnZSBVUkwgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VVcmwgPSBtZXRhZGF0YS5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGltYWdlVXJsKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWltYWdlVXJsXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlVXJsLm1hdGNoKC9eKGh0dHBzOlxcL1xcL3xkYXRhOikvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbGluayB0byBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXBmcyA9IGltYWdlVXJsLm1hdGNoKG1hdGNoZXJJcGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWltYWdlVXJsLWlwZnNcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpbWFnZVVybC1pcGZzXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGdldElwZnNMaW5rKGltYWdlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogaW1hZ2VVcmwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IG51bGwgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGdldEVuc0FkZHJlc3MocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgY29uc3QgZW5zUGx1Z2luID0gbmV0d29yay5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5FbnNcIik7XG4gICAgICAgIC8vIE5vIEVOUy4uLlxuICAgICAgICBhc3NlcnQoZW5zUGx1Z2luLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEVuc0FkZHJlc3NcIiwgaW5mbzogeyBuZXR3b3JrIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbnNQbHVnaW4uYWRkcmVzcztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jICNnZXRSZXNvbHZlcihwcm92aWRlciwgbmFtZSkge1xuICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyhwcm92aWRlcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBDb250cmFjdChlbnNBZGRyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcbiAgICAgICAgICAgIF0sIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSBhd2FpdCBjb250cmFjdC5yZXNvbHZlcihuYW1laGFzaChuYW1lKSwge1xuICAgICAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhZGRyID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBFTlMgcmVnaXN0cnkgY2Fubm90IHRocm93IGVycm9ycyBvbiByZXNvbHZlcihieXRlczMyKSxcbiAgICAgICAgICAgIC8vIHNvIHByb2JhYmx5IGEgbGluayBlcnJvclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoZSBFTlMgcmVzb2x2ZXIgZm9yICUlbmFtZSUlIHVzaW5nICUlcHJvdmlkZXIlJSBvclxuICAgICAqICBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21OYW1lKHByb3ZpZGVyLCBuYW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50TmFtZSA9IG5hbWU7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgPT09IFwiXCIgfHwgY3VycmVudE5hbWUgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gc2luY2UgdGhlIGV0aCBub2RlIGNhbm5vdCBjaGFuZ2UgYW5kIGRvZXNcbiAgICAgICAgICAgIC8vIG5vdCBoYXZlIGEgd2lsZGNhcmQgcmVzb2x2ZXJcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcImV0aFwiICYmIGN1cnJlbnROYW1lID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgY3VycmVudCBub2RlIGZvciBhIHJlc29sdmVyXG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuI2dldFJlc29sdmVyKHByb3ZpZGVyLCBjdXJyZW50TmFtZSk7XG4gICAgICAgICAgICAvLyBGb3VuZCBhIHJlc29sdmVyIVxuICAgICAgICAgICAgaWYgKGFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gbmV3IEVuc1Jlc29sdmVyKHByb3ZpZGVyLCBhZGRyLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgcmVzb2x2ZXIgZm91bmQsIHVzaW5nIEVJUC0yNTQ0IHNvIGl0IGlzbid0IHNhZmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lICE9PSBuYW1lICYmICEoYXdhaXQgcmVzb2x2ZXIuc3VwcG9ydHNXaWxkY2FyZCgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgY3VycmVudE5hbWUgPSBjdXJyZW50TmFtZS5zcGxpdChcIi5cIikuc2xpY2UoMSkuam9pbihcIi5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnMtcmVzb2x2ZXIuanMubWFwIiwiLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q3JlYXRlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmV4cG9ydCBmdW5jdGlvbiBhbGxvd051bGwoZm9ybWF0LCBudWxsVmFsdWUpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheU9mKGZvcm1hdCwgYWxsb3dOdWxsKSB7XG4gICAgcmV0dXJuICgoYXJyYXkpID0+IHtcbiAgICAgICAgaWYgKGFsbG93TnVsbCAmJiBhcnJheSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoaSkgPT4gZm9ybWF0KGkpKTtcbiAgICB9KTtcbn1cbi8vIFJlcXVpcmVzIGFuIG9iamVjdCB3aGljaCBtYXRjaGVzIGEgZmxlZXQgb2Ygb3RoZXIgZm9ybWF0dGVyc1xuLy8gQW55IEZvcm1hdEZ1bmMgbWF5IHJldHVybiBgdW5kZWZpbmVkYCB0byBoYXZlIHRoZSB2YWx1ZSBvbWl0dGVkXG4vLyBmcm9tIHRoZSByZXN1bHQgb2JqZWN0LiBDYWxscyBwcmVzZXJ2ZSBgdGhpc2AuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0KGZvcm1hdCwgYWx0TmFtZXMpIHtcbiAgICByZXR1cm4gKCh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZm9ybWF0KSB7XG4gICAgICAgICAgICBsZXQgc3JjS2V5ID0ga2V5O1xuICAgICAgICAgICAgaWYgKGFsdE5hbWVzICYmIGtleSBpbiBhbHROYW1lcyAmJiAhKHNyY0tleSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsdEtleSBvZiBhbHROYW1lc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHRLZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY0tleSA9IGFsdEtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBudiA9IGZvcm1hdFtrZXldKHZhbHVlW3NyY0tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChudiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gbnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSA/IGVycm9yLm1lc3NhZ2UgOiBcIm5vdC1hbi1lcnJvclwiO1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgdmFsdWUgZm9yIHZhbHVlLiR7a2V5fSAoJHttZXNzYWdlfSlgLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCb29sZWFuKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBib29sZWFuOyAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRhKHZhbHVlKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpLCBcImludmFsaWQgZGF0YVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0SGFzaCh2YWx1ZSkge1xuICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlLCAzMiksIFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVaW50MjU2KHZhbHVlKSB7XG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xuICAgIH1cbiAgICByZXR1cm4gemVyb1BhZFZhbHVlKHZhbHVlLCAzMik7XG59XG5jb25zdCBfZm9ybWF0TG9nID0gb2JqZWN0KHtcbiAgICBhZGRyZXNzOiBnZXRBZGRyZXNzLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxuICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICByZW1vdmVkOiBhbGxvd051bGwoZm9ybWF0Qm9vbGVhbiwgZmFsc2UpLFxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgdHJhbnNhY3Rpb25JbmRleDogZ2V0TnVtYmVyLFxufSwge1xuICAgIGluZGV4OiBbXCJsb2dJbmRleFwiXVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TG9nKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRMb2codmFsdWUpO1xufVxuY29uc3QgX2Zvcm1hdEJsb2NrID0gb2JqZWN0KHtcbiAgICBoYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCksXG4gICAgcGFyZW50SGFzaDogZm9ybWF0SGFzaCxcbiAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICBudW1iZXI6IGdldE51bWJlcixcbiAgICB0aW1lc3RhbXA6IGdldE51bWJlcixcbiAgICBub25jZTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxuICAgIGRpZmZpY3VsdHk6IGdldEJpZ0ludCxcbiAgICBnYXNMaW1pdDogZ2V0QmlnSW50LFxuICAgIGdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBzdGF0ZVJvb3Q6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICByZWNlaXB0c1Jvb3Q6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICBibG9iR2FzVXNlZDogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXG4gICAgZXhjZXNzQmxvYkdhczogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXG4gICAgbWluZXI6IGFsbG93TnVsbChnZXRBZGRyZXNzKSxcbiAgICBwcmV2UmFuZGFvOiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgZXh0cmFEYXRhOiBmb3JtYXREYXRhLFxuICAgIGJhc2VGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpXG59LCB7XG4gICAgcHJldlJhbmRhbzogW1wibWl4SGFzaFwiXVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QmxvY2sodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBfZm9ybWF0QmxvY2sodmFsdWUpO1xuICAgIHJlc3VsdC50cmFuc2FjdGlvbnMgPSB2YWx1ZS50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh0eCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IF9mb3JtYXRSZWNlaXB0TG9nID0gb2JqZWN0KHtcbiAgICB0cmFuc2FjdGlvbkluZGV4OiBnZXROdW1iZXIsXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgYWRkcmVzczogZ2V0QWRkcmVzcyxcbiAgICB0b3BpY3M6IGFycmF5T2YoZm9ybWF0SGFzaCksXG4gICAgZGF0YTogZm9ybWF0RGF0YSxcbiAgICBpbmRleDogZ2V0TnVtYmVyLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbn0sIHtcbiAgICBpbmRleDogW1wibG9nSW5kZXhcIl1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJlY2VpcHRMb2codmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdFJlY2VpcHRMb2codmFsdWUpO1xufVxuY29uc3QgX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCA9IG9iamVjdCh7XG4gICAgdG86IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICBmcm9tOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgY29udHJhY3RBZGRyZXNzOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgLy8gc2hvdWxkIGJlIGFsbG93TnVsbChoYXNoKSwgYnV0IGJyb2tlbi1FSVAtNjU4IHN1cHBvcnQgaXMgaGFuZGxlZCBpbiByZWNlaXB0XG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICByb290OiBhbGxvd051bGwoaGV4bGlmeSksXG4gICAgZ2FzVXNlZDogZ2V0QmlnSW50LFxuICAgIGJsb2JHYXNVc2VkOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICBsb2dzQmxvb206IGFsbG93TnVsbChmb3JtYXREYXRhKSxcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG4gICAgaGFzaDogZm9ybWF0SGFzaCxcbiAgICBsb2dzOiBhcnJheU9mKGZvcm1hdFJlY2VpcHRMb2cpLFxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXG4gICAgLy9jb25maXJtYXRpb25zOiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcbiAgICBjdW11bGF0aXZlR2FzVXNlZDogZ2V0QmlnSW50LFxuICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcbiAgICBibG9iR2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgIHN0YXR1czogYWxsb3dOdWxsKGdldE51bWJlciksXG4gICAgdHlwZTogYWxsb3dOdWxsKGdldE51bWJlciwgMClcbn0sIHtcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogW1wiZ2FzUHJpY2VcIl0sXG4gICAgaGFzaDogW1widHJhbnNhY3Rpb25IYXNoXCJdLFxuICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdLFxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodmFsdWUpIHtcbiAgICAvLyBTb21lIGNsaWVudHMgKFRlc3RSUEMpIGRvIHN0cmFuZ2UgdGhpbmdzIGxpa2UgcmV0dXJuIDB4MCBmb3IgdGhlXG4gICAgLy8gMCBhZGRyZXNzOyBjb3JyZWN0IHRoaXMgdG8gYmUgYSByZWFsIGFkZHJlc3NcbiAgICBpZiAodmFsdWUudG8gJiYgZ2V0QmlnSW50KHZhbHVlLnRvKSA9PT0gQk5fMCkge1xuICAgICAgICB2YWx1ZS50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG9iamVjdCh7XG4gICAgICAgIGhhc2g6IGZvcm1hdEhhc2gsXG4gICAgICAgIC8vIFNvbWUgbm9kZXMgZG8gbm90IHJldHVybiB0aGlzLCB1c3VhbGx5IHRlc3Qgbm9kZXMgKGxpa2UgR2FuYWNoZSlcbiAgICAgICAgaW5kZXg6IGFsbG93TnVsbChnZXROdW1iZXIsIHVuZGVmaW5lZCksXG4gICAgICAgIHR5cGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4XCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGFsbG93TnVsbChhY2Nlc3NMaXN0aWZ5LCBudWxsKSxcbiAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlczogYWxsb3dOdWxsKGFycmF5T2YoZm9ybWF0SGFzaCwgdHJ1ZSksIG51bGwpLFxuICAgICAgICBhdXRob3JpemF0aW9uTGlzdDogYWxsb3dOdWxsKGFycmF5T2YoKHYpID0+IHtcbiAgICAgICAgICAgIGxldCBzaWc7XG4gICAgICAgICAgICBpZiAodi5zaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBzaWcgPSB2LnNpZ25hdHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB5UGFyaXR5ID0gdi55UGFyaXR5O1xuICAgICAgICAgICAgICAgIGlmICh5UGFyaXR5ID09PSBcIjB4MWJcIikge1xuICAgICAgICAgICAgICAgICAgICB5UGFyaXR5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeVBhcml0eSA9PT0gXCIweDFjXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpZyA9IE9iamVjdC5hc3NpZ24oe30sIHYsIHsgeVBhcml0eSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyh2LmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGdldEJpZ0ludCh2LmNoYWluSWQpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBnZXRCaWdJbnQodi5ub25jZSksXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbShzaWcpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBmYWxzZSksIG51bGwpLFxuICAgICAgICBibG9ja0hhc2g6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICAgICAgYmxvY2tOdW1iZXI6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcbiAgICAgICAgZnJvbTogZ2V0QWRkcmVzcyxcbiAgICAgICAgLy8gZWl0aGVyIChnYXNQcmljZSkgb3IgKG1heFByaW9yaXR5RmVlUGVyR2FzICsgbWF4RmVlUGVyR2FzKSBtdXN0IGJlIHNldFxuICAgICAgICBnYXNQcmljZTogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4RmVlUGVyQmxvYkdhczogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXG4gICAgICAgIGdhc0xpbWl0OiBnZXRCaWdJbnQsXG4gICAgICAgIHRvOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgICAgIHZhbHVlOiBnZXRCaWdJbnQsXG4gICAgICAgIG5vbmNlOiBnZXROdW1iZXIsXG4gICAgICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgICAgIGNyZWF0ZXM6IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICAgICAgY2hhaW5JZDogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbClcbiAgICB9LCB7XG4gICAgICAgIGRhdGE6IFtcImlucHV0XCJdLFxuICAgICAgICBnYXNMaW1pdDogW1wiZ2FzXCJdLFxuICAgICAgICBpbmRleDogW1widHJhbnNhY3Rpb25JbmRleFwiXVxuICAgIH0pKHZhbHVlKTtcbiAgICAvLyBJZiB0byBhbmQgY3JlYXRlcyBhcmUgZW1wdHksIHBvcHVsYXRlIHRoZSBjcmVhdGVzIGZyb20gdGhlIHZhbHVlXG4gICAgaWYgKHJlc3VsdC50byA9PSBudWxsICYmIHJlc3VsdC5jcmVhdGVzID09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmNyZWF0ZXMgPSBnZXRDcmVhdGVBZGRyZXNzKHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayBmZWUgZGF0YVxuICAgIC8vIEFkZCBhbiBhY2Nlc3MgbGlzdCB0byBzdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZXNcbiAgICBpZiAoKHZhbHVlLnR5cGUgPT09IDEgfHwgdmFsdWUudHlwZSA9PT0gMikgJiYgdmFsdWUuYWNjZXNzTGlzdCA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gW107XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdGhlIHNpZ25hdHVyZVxuICAgIGlmICh2YWx1ZS5zaWduYXR1cmUpIHtcbiAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHZhbHVlLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICAvLyBTb21lIGJhY2tlbmRzIG9taXQgQ2hhaW5JZCBvbiBsZWdhY3kgdHJhbnNhY3Rpb25zLCBidXQgd2UgY2FuIGNvbXB1dGUgaXRcbiAgICBpZiAocmVzdWx0LmNoYWluSWQgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjaGFpbklkID0gcmVzdWx0LnNpZ25hdHVyZS5sZWdhY3lDaGFpbklkO1xuICAgICAgICBpZiAoY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQFRPRE86IGNoZWNrIGNoYWluSURcbiAgICAvKlxuICAgIGlmICh2YWx1ZS5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGNoYWluSWQgPSB2YWx1ZS5jaGFpbklkO1xuXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY2hhaW5JZCA9IHZhbHVlLm5ldHdvcmtJZDtcblxuICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcbiAgICAgICAgaWYgKGNoYWluSWQgPT0gbnVsbCAmJiByZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gdmFsdWUuY2hhaW5JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGNoYWluSWQpICE9PSBcIm51bWJlclwiICYmIHJlc3VsdC52ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSAocmVzdWx0LnYgLSAzNSkgLyAyO1xuICAgICAgICAgICAgaWYgKGNoYWluSWQgPCAwKSB7IGNoYWluSWQgPSAwOyB9XG4gICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7IGNoYWluSWQgPSAwOyB9XG5cbiAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgIH1cbiAgICAqL1xuICAgIC8vIDB4MDAwMC4uLiBzaG91bGQgYWN0dWFsbHkgYmUgbnVsbFxuICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoICYmIGdldEJpZ0ludChyZXN1bHQuYmxvY2tIYXNoKSA9PT0gQk5fMCkge1xuICAgICAgICByZXN1bHQuYmxvY2tIYXNoID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBFbnNBZGRyZXNzID0gXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIjtcbi8qKlxuICogIEEgKipOZXR3b3JrUGx1Z2luKiogcHJvdmlkZXMgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IG9uIGEgW1tOZXR3b3JrXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqICBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgcmV2ZXJzZS1kb21haW4tbm90YXRpb24sIHdoaWNoIHBlcm1pdHNcbiAgICAgKiAgdW5pcXVlIG5hbWVzIHdpdGggYSBrbm93biBhdXRob3JpdHkgYXMgd2VsbCBhcyBoaWVyYXJjaGFsIGVudHJpZXMuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmtQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBwbHVnaW4uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmV0d29ya1BsdWdpbih0aGlzLm5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipHYXNDb3N0UGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFsdGVybmF0aXZlIHZhbHVlcyB3aGVuXG4gKiAgY29tcHV0aW5nIHRoZSBpbnRyaW5zaWMgZ2FzIHJlcXVpcmVkIGZvciBhIHRyYW5zYWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgR2FzQ29zdFBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIHRvIHRyZWF0IHRoZXNlIHZhbHVlcyBhcyB2YWxpZCBmcm9tLlxuICAgICAqXG4gICAgICogIFRoaXMgYWxsb3dzIGEgaGFyZGZvcmsgdG8gaGF2ZSB1cGRhdGVkIHZhbHVlcyBpbmNsdWRlZCBhcyB3ZWxsIGFzXG4gICAgICogIG11bHV0aXBsZSBoYXJkZm9ya3MgdG8gYmUgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIGVmZmVjdGl2ZUJsb2NrO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb25zIGJhc2UgZmVlLlxuICAgICAqL1xuICAgIHR4QmFzZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBmb3IgY3JlYXRpbmcgYSBuZXcgYWNjb3VudC5cbiAgICAgKi9cbiAgICB0eENyZWF0ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgemVyby1ieXRlIGluIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHR4RGF0YVplcm87XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIG5vbi16ZXJvLWJ5dGUgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgdHhEYXRhTm9uemVybztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgc3RvcmFnZSBrZXkgaW4gdGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0LlxuICAgICAqL1xuICAgIHR4QWNjZXNzTGlzdFN0b3JhZ2VLZXk7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIGFkZHJlc3MgaW4gdGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0LlxuICAgICAqL1xuICAgIHR4QWNjZXNzTGlzdEFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgR2FzQ29zdFBsdWdpbiBmcm9tICUlZWZmZWN0aXZlQmxvY2slJSB1bnRpbCB0aGVcbiAgICAgKiAgbGF0ZXN0IGJsb2NrIG9yIGFub3RoZXIgR2FzQ29zdFBsdWdpbiBzdXBlcmNlZGVzIHRoYXQgYmxvY2sgbnVtYmVyLFxuICAgICAqICB3aXRoIHRoZSBhc3NvY2lhdGVkICUlY29zdHMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlZmZlY3RpdmVCbG9jaywgY29zdHMpIHtcbiAgICAgICAgaWYgKGVmZmVjdGl2ZUJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIGVmZmVjdGl2ZUJsb2NrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihgb3JnLmV0aGVycy5uZXR3b3JrLnBsdWdpbnMuR2FzQ29zdCMkeyhlZmZlY3RpdmVCbG9jayB8fCAwKX1gKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7IGVmZmVjdGl2ZUJsb2NrIH07XG4gICAgICAgIGZ1bmN0aW9uIHNldChuYW1lLCBudWxsaXNoKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoY29zdHMgfHwge30pW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGxpc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiwgYGludmFsdWQgdmFsdWUgZm9yICR7bmFtZX1gLCBcImNvc3RzXCIsIGNvc3RzKTtcbiAgICAgICAgICAgIHByb3BzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KFwidHhCYXNlXCIsIDIxMDAwKTtcbiAgICAgICAgc2V0KFwidHhDcmVhdGVcIiwgMzIwMDApO1xuICAgICAgICBzZXQoXCJ0eERhdGFaZXJvXCIsIDQpO1xuICAgICAgICBzZXQoXCJ0eERhdGFOb256ZXJvXCIsIDE2KTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0U3RvcmFnZUtleVwiLCAxOTAwKTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0QWRkcmVzc1wiLCAyNDAwKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCBwcm9wcyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdhc0Nvc3RQbHVnaW4odGhpcy5lZmZlY3RpdmVCbG9jaywgdGhpcyk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gKipFbnNQbHVnaW4qKiBhbGxvd3MgYSBbW05ldHdvcmtdXSB0byBzcGVjaWZ5IHRoZSBFTlMgUmVnaXN0cnlcbiAqICBDb250cmFjdCBhZGRyZXNzIGFuZCB0aGUgdGFyZ2V0IG5ldHdvcmsgdG8gdXNlIHdoZW4gdXNpbmcgdGhhdFxuICogIGNvbnRyYWN0LlxuICpcbiAqICBWYXJpb3VzIHRlc3RuZXRzIGhhdmUgdGhlaXIgb3duIGluc3RhbmNlIG9mIHRoZSBjb250cmFjdCB0byB1c2UsIGJ1dFxuICogIGluIGdlbmVyYWwsIHRoZSBtYWlubmV0IGluc3RhbmNlIHN1cHBvcnRzIG11bHRpLWNoYWluIGFkZHJlc3NlcyBhbmRcbiAqICBzaG91bGQgYmUgdXNlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuc1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgRU5TIFJlZ2lzdHJ0eSBDb250cmFjdCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCB0aGF0IHRoZSBFTlMgY29udHJhY3QgbGl2ZXMgb24uXG4gICAgICovXG4gICAgdGFyZ2V0TmV0d29yaztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkVuc1BsdWdpbioqIGNvbm5lY3RlZCB0byAlJWFkZHJlc3MlJSBvbiB0aGVcbiAgICAgKiAgJSV0YXJnZXROZXR3b3JrJSUuIFRoZSBkZWZhdWx0IEVOUyBhZGRyZXNzIGFuZCBtYWlubmV0IGlzIHVzZWRcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgdGFyZ2V0TmV0d29yaykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBhZGRyZXNzOiAoYWRkcmVzcyB8fCBFbnNBZGRyZXNzKSxcbiAgICAgICAgICAgIHRhcmdldE5ldHdvcms6ICgodGFyZ2V0TmV0d29yayA9PSBudWxsKSA/IDEgOiB0YXJnZXROZXR3b3JrKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW5zUGx1Z2luKHRoaXMuYWRkcmVzcywgdGhpcy50YXJnZXROZXR3b3JrKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqRmVlRGF0YU5ldHdvcmtQbHVnaW4qKiBhbGxvd3MgYSBuZXR3b3JrIHRvIHByb3ZpZGUgYW5kIGFsdGVybmF0ZVxuICogIG1lYW5zIHRvIHNwZWNpZnkgaXRzIGZlZSBkYXRhLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgYSBuZXR3b3JrIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgW1tsaW5rLWVpcC0xNTU5XV0gbWF5XG4gKiAgY2hvb3NlIHRvIHVzZSBhIEdhcyBTdGF0aW9uIHNpdGUgdG8gYXBwcm94aW1hdGUgdGhlIGdhcyBwcmljZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgI2ZlZURhdGFGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIGRhdGEgZnVuY3Rpb24gcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGdldCBmZWVEYXRhRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZlZURhdGFGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZlZURhdGFOZXR3b3JrUGx1Z2luKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZmVlRGF0YUZ1bmMpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZWVEYXRhXCIpO1xuICAgICAgICB0aGlzLiNmZWVEYXRhRnVuYyA9IGZlZURhdGFGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGZlZSBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEZlZURhdGEocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZlZURhdGFGdW5jKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmVlRGF0YU5ldHdvcmtQbHVnaW4odGhpcy4jZmVlRGF0YUZ1bmMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgI3VybDtcbiAgICAjcHJvY2Vzc0Z1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBVUkwgdG8gaW5pdGlhbGl6ZSB0aGUgRmV0Y2hSZXF1ZXN0IHdpdGggaW4gJSVwcm9jZXNzRnVuYyUlLlxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNhbGxiYWNrIHRvIHVzZSB3aGVuIGNvbXB1dGluZyB0aGUgRmVlRGF0YS5cbiAgICAgKi9cbiAgICBnZXQgcHJvY2Vzc0Z1bmMoKSB7IHJldHVybiB0aGlzLiNwcm9jZXNzRnVuYzsgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbioqIHdoaWNoIHdpbGxcbiAgICAgKiAgYmUgdXNlZCB3aGVuIGNvbXB1dGluZyB0aGUgZmVlIGRhdGEgZm9yIHRoZSBuZXR3b3JrLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZXRjaFVybEZlZURhdGFQbHVnaW5cIik7XG4gICAgICAgIHRoaXMuI3VybCA9IHVybDtcbiAgICAgICAgdGhpcy4jcHJvY2Vzc0Z1bmMgPSBwcm9jZXNzRnVuYztcbiAgICB9XG4gICAgLy8gV2UgYXJlIGltbXV0YWJsZSwgc28gd2UgY2FuIHNlcnZlIGFzIG91ciBvd24gY2xvbmVcbiAgICBjbG9uZSgpIHsgcmV0dXJuIHRoaXM7IH1cbn1cbi8qXG5leHBvcnQgY2xhc3MgQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgcmVhZG9ubHkgI2Jsb2NrRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pID0+IEJsb2NrPHN0cmluZz47XG4gICAgcmVhZG9ubHkgI2Jsb2NrV2l0aFR4c0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPikgPT4gQmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT47XG5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KSA9PiBCbG9jazxzdHJpbmc+LCBibG9ja1dpdGhUeHNGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pID0+IEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+KSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5uZXR3b3JrLXBsdWdpbnMuY3VzdG9tLWJsb2NrXCIpO1xuICAgICAgICB0aGlzLiNibG9ja0Z1bmMgPSBibG9ja0Z1bmM7XG4gICAgICAgIHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMgPSBibG9ja1dpdGhUeHNGdW5jO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEJsb2NrKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pOiBQcm9taXNlPEJsb2NrPHN0cmluZz4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jsb2NrRnVuYyhwcm92aWRlciwgYmxvY2spO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEJsb2NraW9ucyhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPik6IFByb21pc2U8QmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4ge1xuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbih0aGlzLiNibG9ja0Z1bmMsIHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMpO1xuICAgIH1cbn1cbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW5zLW5ldHdvcmsuanMubWFwIiwiLyoqXG4gKiAgQSAqKk5ldHdvcmsqKiBlbmNhcHN1bGF0ZXMgdGhlIHZhcmlvdXMgcHJvcGVydGllcyByZXF1aXJlZCB0b1xuICogIGludGVyYWN0IHdpdGggYSBzcGVjaWZpYyBjaGFpbi5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzOk5ldHdvcmtzICBbbmV0d29ya3NdXG4gKi9cbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJpZ0ludCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRW5zUGx1Z2luLCBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luLCBHYXNDb3N0UGx1Z2luIH0gZnJvbSBcIi4vcGx1Z2lucy1uZXR3b3JrLmpzXCI7XG4vKiAqICogKlxuLy8gTmV0d29ya3Mgd2hpY2ggb3BlcmF0aW9uIGFnYWluc3QgYW4gTDIgY2FuIHVzZSB0aGlzIHBsdWdpbiB0b1xuLy8gc3BlY2lmeSBob3cgdG8gYWNjZXNzIEwxLCBmb3IgdGhlIHB1cnBvc2Ugb2YgcmVzb2x2aW5nIEVOUyxcbi8vIGZvciBleGFtcGxlLlxuZXhwb3J0IGNsYXNzIExheWVyT25lQ29ubmVjdGlvblBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIHJlYWRvbmx5IHByb3ZpZGVyITogUHJvdmlkZXI7XG4vLyBAVE9ETzogUmVuYW1lIHRvIENoYWluQWNjZXNzIGFuZCBhbGxvdyBmb3IgY29ubmVjdGluZyB0byBhbnkgY2hhaW5cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcjogUHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubGF5ZXItb25lLWNvbm5lY3Rpb25cIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXM8TGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luPih0aGlzLCB7IHByb3ZpZGVyIH0pO1xuICAgIH1cblxuICAgIGNsb25lKCk6IExheWVyT25lQ29ubmVjdGlvblBsdWdpbiB7XG4gICAgICAgIHJldHVybiBuZXcgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luKHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbn1cbiovXG5jb25zdCBOZXR3b3JrcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogIEEgKipOZXR3b3JrKiogcHJvdmlkZXMgYWNjZXNzIHRvIGEgY2hhaW4ncyBwcm9wZXJ0aWVzIGFuZCBhbGxvd3NcbiAqICBmb3IgcGx1Zy1pbnMgdG8gZXh0ZW5kIGZ1bmN0aW9uYWxpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXR3b3JrIHtcbiAgICAjbmFtZTtcbiAgICAjY2hhaW5JZDtcbiAgICAjcGx1Z2lucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmsqKiBmb3IgJSVuYW1lJSUgYW5kICUlY2hhaW5JZCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNoYWluSWQpIHtcbiAgICAgICAgdGhpcy4jbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQoY2hhaW5JZCk7XG4gICAgICAgIHRoaXMuI3BsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgTmV0d29yay5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IHRoaXMubmFtZSwgY2hhaW5JZDogU3RyaW5nKHRoaXMuY2hhaW5JZCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuZXR3b3JrIGNvbW1vbiBuYW1lLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdGhlIGNhbm9uaWNhbCBuYW1lLCBhcyBuZXR3b3JrcyBtaWdoIGhhdmUgbXVsdGlwbGVcbiAgICAgKiAgbmFtZXMuXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLiNuYW1lOyB9XG4gICAgc2V0IG5hbWUodmFsdWUpIHsgdGhpcy4jbmFtZSA9IHZhbHVlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuZXR3b3JrIGNoYWluIElELlxuICAgICAqL1xuICAgIGdldCBjaGFpbklkKCkgeyByZXR1cm4gdGhpcy4jY2hhaW5JZDsgfVxuICAgIHNldCBjaGFpbklkKHZhbHVlKSB7IHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQodmFsdWUsIFwiY2hhaW5JZFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIG1hdGNoZXMgdGhpcyBuZXR3b3JrLiBBbnkgY2hhaW4gSURcbiAgICAgKiAgbXVzdCBtYXRjaCwgYW5kIGlmIG5vIGNoYWluIElEIGlzIHByZXNlbnQsIHRoZSBuYW1lIG11c3QgbWF0Y2guXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgZG9lcyBub3QgY3VycmVudGx5IGNoZWNrIGZvciBhZGRpdGlvbmFsIHByb3BlcnRpZXMsXG4gICAgICogIHN1Y2ggYXMgRU5TIGFkZHJlc3Mgb3IgcGx1Zy1pbiBjb21wYXRpYmlsaXR5LlxuICAgICAqL1xuICAgIG1hdGNoZXMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lID09PSBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAob3RoZXIpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAob3RoZXIuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlci5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lID09PSBvdGhlci5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsaXN0IG9mIHBsdWdpbnMgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoaXMgTmV0d29yay5cbiAgICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jcGx1Z2lucy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBdHRhY2ggYSBuZXcgJSVwbHVnaW4lJSB0byB0aGlzIE5ldHdvcmsuIFRoZSBuZXR3b3JrIG5hbWVcbiAgICAgKiAgbXVzdCBiZSB1bmlxdWUsIGV4Y2x1ZGluZyBhbnkgZnJhZ21lbnQuXG4gICAgICovXG4gICAgYXR0YWNoUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBpZiAodGhpcy4jcGx1Z2lucy5nZXQocGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZXBsYWNlIGV4aXN0aW5nIHBsdWdpbjogJHtwbHVnaW4ubmFtZX0gYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGx1Z2lucy5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbi5jbG9uZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHBsdWdpbiwgaWYgYW55LCBtYXRjaGluZyAlJW5hbWUlJSBleGFjdGx5LiBQbHVnaW5zXG4gICAgICogIHdpdGggZnJhZ21lbnRzIHdpbGwgbm90IGJlIHJldHVybmVkIHVubGVzcyAlJW5hbWUlJSBpbmNsdWRlc1xuICAgICAqICBhIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXRzIGEgbGlzdCBvZiBhbGwgcGx1Z2lucyB0aGF0IG1hdGNoICUlbmFtZSUlLCB3aXRoIG90ciB3aXRob3V0XG4gICAgICogIGEgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZ2V0UGx1Z2lucyhiYXNlbmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMucGx1Z2lucy5maWx0ZXIoKHApID0+IChwLm5hbWUuc3BsaXQoXCIjXCIpWzBdID09PSBiYXNlbmFtZSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBOZXR3b3JrLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBOZXR3b3JrKHRoaXMubmFtZSwgdGhpcy5jaGFpbklkKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgY2xvbmUuYXR0YWNoUGx1Z2luKHBsdWdpbi5jbG9uZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGludHJpbnNpYyBnYXMgcmVxdWlyZWQgZm9yIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgQSBHYXNDb3N0UGx1Z2luIGNhbiBiZSBhdHRhY2hlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdFxuICAgICAqICB2YWx1ZXMuXG4gICAgICovXG4gICAgY29tcHV0ZUludHJpbnNpY0dhcyh0eCkge1xuICAgICAgICBjb25zdCBjb3N0cyA9IHRoaXMuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuR2FzQ29zdFwiKSB8fCAobmV3IEdhc0Nvc3RQbHVnaW4oKSk7XG4gICAgICAgIGxldCBnYXMgPSBjb3N0cy50eEJhc2U7XG4gICAgICAgIGlmICh0eC50byA9PSBudWxsKSB7XG4gICAgICAgICAgICBnYXMgKz0gY29zdHMudHhDcmVhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdHguZGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhLnN1YnN0cmluZyhpLCBpICsgMikgPT09IFwiMDBcIikge1xuICAgICAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhEYXRhWmVybztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFOb256ZXJvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzTGlzdCA9IGFjY2Vzc0xpc3RpZnkodHguYWNjZXNzTGlzdCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHIgaW4gYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eEFjY2Vzc0xpc3RBZGRyZXNzICsgY29zdHMudHhBY2Nlc3NMaXN0U3RvcmFnZUtleSAqIGFjY2Vzc0xpc3RbYWRkcl0uc3RvcmFnZUtleXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IE5ldHdvcmsgZm9yIHRoZSAlJW5ldHdvcmslJSBuYW1lIG9yIGNoYWluSWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20obmV0d29yaykge1xuICAgICAgICBpbmplY3RDb21tb25OZXR3b3JrcygpO1xuICAgICAgICAvLyBEZWZhdWx0IG5ldHdvcmtcbiAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5ldHdvcmsuZnJvbShcIm1haW5uZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2Fub25pY2FsIG5hbWUgb3IgY2hhaW4gSURcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5ldHdvcmsgPSBCaWdJbnQobmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgY29uc3QgbmV0d29ya0Z1bmMgPSBOZXR3b3Jrcy5nZXQobmV0d29yayk7XG4gICAgICAgICAgICBpZiAobmV0d29ya0Z1bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29ya0Z1bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrKFwidW5rbm93blwiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvbmFibGUgd2l0aCBuZXR3b3JrLWxpa2UgYWJpbGl0aWVzXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmsuY2xvbmUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gbmV0d29yay5jbG9uZSgpO1xuICAgICAgICAgICAgLy9pZiAodHlwZW9mKG5ldHdvcmsubmFtZSkgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mKG5ldHdvcmsuY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5ldHdvcmtpc2hcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmV0d29yay5uYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgKG5ldHdvcmsuY2hhaW5JZCkgPT09IFwibnVtYmVyXCIsIFwiaW52YWxpZCBuZXR3b3JrIG9iamVjdCBuYW1lIG9yIGNoYWluSWRcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tID0gbmV3IE5ldHdvcmsoKG5ldHdvcmsubmFtZSksIChuZXR3b3JrLmNoYWluSWQpKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrLmVuc0FkZHJlc3MgfHwgbmV0d29yay5lbnNOZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBFbnNQbHVnaW4obmV0d29yay5lbnNBZGRyZXNzLCBuZXR3b3JrLmVuc05ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgLy8gICAgY3VzdG9tLmF0dGFjaFBsdWdpbihuZXcgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikpO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZWdpc3RlciAlJW5hbWVPckNoYWluSWQlJSB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJuc1xuICAgICAqICBhbiBpbnN0YW5jZSBvZiBhIE5ldHdvcmsgcmVwcmVzZW50aW5nIHRoYXQgY2hhaW4uXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyKG5hbWVPckNoYWluSWQsIG5ldHdvcmtGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG5hbWVPckNoYWluSWQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBuYW1lT3JDaGFpbklkID0gQmlnSW50KG5hbWVPckNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gTmV0d29ya3MuZ2V0KG5hbWVPckNoYWluSWQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgY29uZmxpY3RpbmcgbmV0d29yayBmb3IgJHtKU09OLnN0cmluZ2lmeShleGlzdGluZy5uYW1lKX1gLCBcIm5hbWVPckNoYWluSWRcIiwgbmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgTmV0d29ya3Muc2V0KG5hbWVPckNoYWluSWQsIG5ldHdvcmtGdW5jKTtcbiAgICB9XG59XG4vLyBXZSBkb24ndCB3YW50IHRvIGJyaW5nIGluIGZvcm1hdFVuaXRzIGJlY2F1c2UgaXQgaXMgYmFja2VkIGJ5XG4vLyBGaXhlZE51bWJlciBhbmQgd2Ugd2FudCB0byBrZWVwIE5ldHdvcmtzIHRpbnkuIFRoZSB2YWx1ZXNcbi8vIGluY2x1ZGVkIGJ5IHRoZSBHYXMgU3RhdGlvbnMgYXJlIGFsc28gSUVFRSA3NTQgd2l0aCBsb3RzIG9mXG4vLyByb3VuZGluZyBpc3N1ZXMgYW5kIGV4Y2VlZCB0aGUgc3RyaWN0IGNoZWNrcyBmb3JtYXRVbml0cyBoYXMuXG5mdW5jdGlvbiBwYXJzZVVuaXRzKF92YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IFN0cmluZyhfdmFsdWUpO1xuICAgIGlmICghdmFsdWUubWF0Y2goL15bMC05Ll0rJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gQnJlYWsgaW50byBbIHdob2xlLCBmcmFjdGlvbiBdXG4gICAgY29uc3QgY29tcHMgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb21wcy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICAvLyBNb3JlIHRoYW4gMSBkZWNpbWFsIHBvaW50IG9yIHRvbyBtYW55IGZyYWN0aW9uYWwgcG9zaXRpb25zXG4gICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZ3dlaSB2YWx1ZTogJHtfdmFsdWV9YCk7XG4gICAgfVxuICAgIC8vIFBhZCB0aGUgZnJhY3Rpb24gdG8gOSBkZWNpbWFscGxhY2VzXG4gICAgd2hpbGUgKGNvbXBzWzFdLmxlbmd0aCA8IGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbXBzWzFdICs9IFwiMFwiO1xuICAgIH1cbiAgICAvLyBUb28gbWFueSBkZWNpbWFscyBhbmQgc29tZSBub24temVybyBlbmRpbmcsIHRha2UgdGhlIGNlaWxpbmdcbiAgICBpZiAoY29tcHNbMV0ubGVuZ3RoID4gOSkge1xuICAgICAgICBsZXQgZnJhYyA9IEJpZ0ludChjb21wc1sxXS5zdWJzdHJpbmcoMCwgOSkpO1xuICAgICAgICBpZiAoIWNvbXBzWzFdLnN1YnN0cmluZyg5KS5tYXRjaCgvXjArJC8pKSB7XG4gICAgICAgICAgICBmcmFjKys7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHNbMV0gPSBmcmFjLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoY29tcHNbMF0gKyBjb21wc1sxXSk7XG59XG4vLyBVc2VkIGJ5IFBvbHlnb24gdG8gdXNlIGEgZ2FzIHN0YXRpb24gZm9yIGZlZSBkYXRhXG5mdW5jdGlvbiBnZXRHYXNTdGF0aW9uUGx1Z2luKHVybCkge1xuICAgIHJldHVybiBuZXcgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbih1cmwsIGFzeW5jIChmZXRjaEZlZURhdGEsIHByb3ZpZGVyLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgIC8vIFByZXZlbnQgQ2xvdWRmbGFyZSBmcm9tIGJsb2NraW5nIG91ciByZXF1ZXN0IGluIG5vZGUuanNcbiAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJVc2VyLUFnZW50XCIsIFwiZXRoZXJzXCIpO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbX3Jlc3BvbnNlLCBfZmVlRGF0YV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCksIGZldGNoRmVlRGF0YSgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX3Jlc3BvbnNlO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHJlc3BvbnNlLmJvZHlKc29uLnN0YW5kYXJkO1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogX2ZlZURhdGEuZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBwYXJzZVVuaXRzKHBheWxvYWQubWF4RmVlLCA5KSxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcGFyc2VVbml0cyhwYXlsb2FkLm1heFByaW9yaXR5RmVlLCA5KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZmVlRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYGVycm9yIGVuY291bnRlcmVkIHdpdGggcG9seWdvbiBnYXMgc3RhdGlvbiAoJHtKU09OLnN0cmluZ2lmeShyZXF1ZXN0LnVybCl9KWAsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBTZWU6IGh0dHBzOi8vY2hhaW5saXN0Lm9yZ1xubGV0IGluamVjdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbmplY3RDb21tb25OZXR3b3JrcygpIHtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgLy8vIFJlZ2lzdGVyIHBvcHVsYXIgRXRoZXJldW0gbmV0d29ya3NcbiAgICBmdW5jdGlvbiByZWdpc3RlckV0aChuYW1lLCBjaGFpbklkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV3IE5ldHdvcmsobmFtZSwgY2hhaW5JZCk7XG4gICAgICAgICAgICAvLyBXZSB1c2UgMCB0byBkaXNhYmxlIEVOU1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5zTmV0d29yayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4obmV3IEVuc1BsdWdpbihudWxsLCBvcHRpb25zLmVuc05ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKG5ldyBHYXNDb3N0UGx1Z2luKCkpO1xuICAgICAgICAgICAgKG9wdGlvbnMucGx1Z2lucyB8fCBbXSkuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXR3b3JrIGJ5IG5hbWUgYW5kIGNoYWluIElEXG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIoY2hhaW5JZCwgZnVuYyk7XG4gICAgICAgIGlmIChvcHRpb25zLmFsdE5hbWVzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFsdE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKG5hbWUsIGZ1bmMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJFdGgoXCJtYWlubmV0XCIsIDEsIHsgZW5zTmV0d29yazogMSwgYWx0TmFtZXM6IFtcImhvbWVzdGVhZFwiXSB9KTtcbiAgICByZWdpc3RlckV0aChcInJvcHN0ZW5cIiwgMywgeyBlbnNOZXR3b3JrOiAzIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwicmlua2VieVwiLCA0LCB7IGVuc05ldHdvcms6IDQgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJnb2VybGlcIiwgNSwgeyBlbnNOZXR3b3JrOiA1IH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwia292YW5cIiwgNDIsIHsgZW5zTmV0d29yazogNDIgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJzZXBvbGlhXCIsIDExMTU1MTExLCB7IGVuc05ldHdvcms6IDExMTU1MTExIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiaG9sZXNreVwiLCAxNzAwMCwgeyBlbnNOZXR3b3JrOiAxNzAwMCB9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNcIiwgNjEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNLb3R0aVwiLCA2LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bVwiLCA0MjE2MSwge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tZ29lcmxpXCIsIDQyMTYxMywge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tc2Vwb2xpYVwiLCA0MjE2MTQsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImJhc2VcIiwgODQ1MywgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1nb2VybGlcIiwgODQ1MzEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImJhc2Utc2Vwb2xpYVwiLCA4NDUzMiwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYm5iXCIsIDU2LCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJibmJ0XCIsIDk3LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYVwiLCA1OTE0NCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwibGluZWEtZ29lcmxpXCIsIDU5MTQwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1zZXBvbGlhXCIsIDU5MTQxLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpY1wiLCAxMzcsIHtcbiAgICAgICAgZW5zTmV0d29yazogMSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLnBvbHlnb24udGVjaG5vbG9neS92MlwiKVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpYy1hbW95XCIsIDgwMDAyLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpYy1tdW1iYWlcIiwgODAwMDEsIHtcbiAgICAgICAgYWx0TmFtZXM6IFtcIm1hdGljTXVtYmFpXCIsIFwibWF0aWNtdW1cIl0sXG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIGdldEdhc1N0YXRpb25QbHVnaW4oXCJodHRwczovXFwvZ2Fzc3RhdGlvbi10ZXN0bmV0LnBvbHlnb24udGVjaG5vbG9neS92MlwiKVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbVwiLCAxMCwge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgICAgICBwbHVnaW5zOiBbXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tZ29lcmxpXCIsIDQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tc2Vwb2xpYVwiLCAxMTE1NTQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwieGRhaVwiLCAxMDAsIHsgZW5zTmV0d29yazogMSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmsuanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0LCBpc0hleFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgcG9sbGluZyBzdWJzY3JpYmVyIGZvciBjb21tb24gZXZlbnRzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9sbGluZ1N1YnNjcmliZXIocHJvdmlkZXIsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKGV2ZW50LCAzMikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHByb3ZpZGVyLCBldmVudCk7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBwb2xsaW5nIGV2ZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcImdldFBvbGxpbmdTdWJzY3JpYmVyXCIsIGluZm86IHsgZXZlbnQgfVxuICAgIH0pO1xufVxuLy8gQFRPRE86IHJlZmFjdG9yIHRoaXNcbi8qKlxuICogIEEgKipQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKiogcG9sbHMgYXQgYSByZWd1bGFyIGludGVydmFsIGZvciBhIGNoYW5nZVxuICogIGluIHRoZSBibG9jayBudW1iZXIuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGxlcjtcbiAgICAjaW50ZXJ2YWw7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICNibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNpbnRlcnZhbCA9IDQwMDA7XG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKi9cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jaW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7IHRoaXMuI2ludGVydmFsID0gdmFsdWU7IH1cbiAgICBhc3luYyAjcG9sbCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgICAgIC8vIEJvb3RzdHJhcCBwb2xsIHRvIHNldHVwIG91ciBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQFRPRE86IFB1dCBhIGNhcCBvbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHBlciBsb29wP1xuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyICE9PSB0aGlzLiNibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgPSB0aGlzLiNibG9ja051bWJlciArIDE7IGIgPD0gYmxvY2tOdW1iZXI7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNwcm92aWRlci5lbWl0KFwiYmxvY2tcIiwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogTWlub3IgYnVtcCwgYWRkIGFuIFwiZXJyb3JcIiBldmVudCB0byBsZXQgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIC8vICAgICAgICBrbm93IHRoaW5ncyB3ZW50IGF3cnkuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICAgICAgdGhpcy4jcG9sbCgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3BvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLl9jbGVhclRpbWVvdXQodGhpcy4jcG9sbGVyKTtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gbnVsbDtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqT25CbG9ja1N1YnNjcmliZXIqKiBjYW4gYmUgc3ViLWNsYXNzZWQsIHdpdGggYSBbW19wb2xsXV1cbiAqICBpbXBsbWVudGF0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIG9uIGV2ZXJ5IG5ldyBibG9jay5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGw7XG4gICAgI3J1bm5pbmc7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKk9uQmxvY2tTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcG9sbCA9IChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcG9sbChibG9ja051bWJlciwgdGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbGVkIG9uIGV2ZXJ5IG5ldyBibG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViLWNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcG9sbCgtMik7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB0aGlzLnN0b3AoKTsgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG5leHBvcnQgY2xhc3MgUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjdGFnO1xuICAgICNsYXN0QmxvY2s7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIHRhZykge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI3RhZyA9IHRhZztcbiAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gLTI7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXVzZShkcm9wV2hpbGVQYXVzZWQpO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCBwcm92aWRlci5nZXRCbG9jayh0aGlzLiN0YWcpO1xuICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2sgPT09IC0yKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSBibG9jay5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2subnVtYmVyID4gdGhpcy4jbGFzdEJsb2NrKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI3RhZywgYmxvY2subnVtYmVyKTtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IGJsb2NrLm51bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlOlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ09ycGhhblN1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI2ZpbHRlcjtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gY29weShmaWx0ZXIpO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuI2ZpbHRlcik7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiB3aWxsIHBvbGwgZm9yIGEgZ2l2ZW4gdHJhbnNhY3Rpb25cbiAqICBoYXNoIGZvciBpdHMgcmVjZWlwdC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI2hhc2g7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUsIGxpc3RlbmluZyBmb3IgJSVoYXNoJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGhhc2gpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNoYXNoID0gaGFzaDtcbiAgICB9XG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuI2hhc2gpO1xuICAgICAgICBpZiAodHgpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jaGFzaCwgdHgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlBvbGxpbmdFdmVudFN1YnNjcmliZXIqKiB3aWxsIHBvbGwgZm9yIGEgZ2l2ZW4gZmlsdGVyIGZvciBpdHMgbG9ncy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdFdmVudFN1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjZmlsdGVyO1xuICAgICNwb2xsZXI7XG4gICAgI3J1bm5pbmc7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICNibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJSwgbGlzdGVuaW5nIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gY29weShmaWx0ZXIpO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICB9XG4gICAgYXN5bmMgI3BvbGwoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgLy8gVGhlIGluaXRpYWwgYmxvY2sgaGFzbid0IGJlZW4gZGV0ZXJtaW5lZCB5ZXRcbiAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGNvcHkodGhpcy4jZmlsdGVyKTtcbiAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IHRoaXMuI2Jsb2NrTnVtYmVyICsgMTtcbiAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgY29uc3QgbG9ncyA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldExvZ3MoZmlsdGVyKTtcbiAgICAgICAgLy8gTm8gbG9ncyBjb3VsZCBqdXN0IG1lYW4gdGhlIG5vZGUgaGFzIG5vdCBpbmRleGVkIHRoZW0geWV0LFxuICAgICAgICAvLyBzbyB3ZSBrZWVwIGEgc2xpZGluZyB3aW5kb3cgb2YgNjAgYmxvY2tzIHRvIGtlZXAgc2Nhbm5pbmdcbiAgICAgICAgaWYgKGxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPCBibG9ja051bWJlciAtIDYwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLmVtaXQodGhpcy4jZmlsdGVyLCBsb2cpO1xuICAgICAgICAgICAgLy8gT25seSBhZHZhbmNlIHRoZSBibG9jayBudW1iZXIgd2hlbiBsb2dzIHdlcmUgZm91bmQgdG9cbiAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIG5ldHdvcmtzIChsaWtlIEJOQiBhbmQgUG9seWdvbikgd2hpY2ggbWF5XG4gICAgICAgICAgICAvLyBzYWNyaWZpY2UgZXZlbnQgY29uc2lzdGVuY3kgZm9yIGJsb2NrIGV2ZW50IHNwZWVkXG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5vbihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZXItcG9sbGluZy5qcy5tYXAiLCIvKipcbiAqICBUaGUgYXZhaWxhYmxlIHByb3ZpZGVycyBzaG91bGQgc3VmZmljZSBmb3IgbW9zdCBkZXZlbG9wZXJzIHB1cnBvc2VzLFxuICogIGJ1dCB0aGUgW1tBYnN0cmFjdFByb3ZpZGVyXV0gY2xhc3MgaGFzIG1hbnkgZmVhdHVyZXMgd2hpY2ggZW5hYmxlXG4gKiAgc3ViLWNsYXNzaW5nIGl0IGZvciBzcGVjaWZpYyBwdXJwb3Nlcy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyOiBTdWJjbGFzc2luZyBQcm92aWRlciAgW2Fic3RyYWN0LXByb3ZpZGVyXVxuICovXG4vLyBAVE9ET1xuLy8gRXZlbnQgY29hbGVzY2VuY2Vcbi8vICAgV2hlbiB3ZSByZWdpc3RlciBhbiBldmVudCB3aXRoIGFuIGFzeW5jIHZhbHVlIChlLmcuIGFkZHJlc3MgaXMgYSBTaWduZXJcbi8vICAgb3IgRU5TIG5hbWUpLCB3ZSBuZWVkIHRvIGFkZCBpdCBpbW1laWRhdGVseSBmb3IgdGhlIEV2ZW50IEFQSSwgYnV0IGFsc29cbi8vICAgbmVlZCB0aW1lIHRvIHJlc29sdmUgdGhlIGFkZHJlc3MuIFVwb24gcmVzb2x2aW5nIHRoZSBhZGRyZXNzLCB3ZSBuZWVkIHRvXG4vLyAgIG1pZ3JhdGUgdGhlIGxpc3RlbmVyIHRvIHRoZSBzdGF0aWMgZXZlbnQuIFdlIGFsc28gbmVlZCB0byBtYWludGFpbiBhIG1hcFxuLy8gICBvZiBTaWduZXIvRU5TIG5hbWUgdG8gYWRkcmVzcyBzbyB3ZSBjYW4gc3luYyByZXNwb25kIHRvIGxpc3RlbmVyQ291bnQuXG5pbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBaZXJvQWRkcmVzcyB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBuYW1laGFzaCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBkYXRhU2xpY2UsIGhleGxpZnksIGlzSGV4U3RyaW5nLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXROdW1iZXIsIGlzQ2FsbEV4Y2VwdGlvbiwgaXNFcnJvciwgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBGZXRjaFJlcXVlc3QsIHRvQmVBcnJheSwgdG9RdWFudGl0eSwgZGVmaW5lUHJvcGVydGllcywgRXZlbnRQYXlsb2FkLCByZXNvbHZlUHJvcGVydGllcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBFbnNSZXNvbHZlciB9IGZyb20gXCIuL2Vucy1yZXNvbHZlci5qc1wiO1xuaW1wb3J0IHsgZm9ybWF0QmxvY2ssIGZvcm1hdExvZywgZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0LCBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcIi4vZm9ybWF0LmpzXCI7XG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xuaW1wb3J0IHsgY29weVJlcXVlc3QsIEJsb2NrLCBGZWVEYXRhLCBMb2csIFRyYW5zYWN0aW9uUmVjZWlwdCwgVHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyLCBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyLCBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyLCBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciwgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiO1xuLy8gQ29uc3RhbnRzXG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgTUFYX0NDSVBfUkVESVJFQ1RTID0gMTA7XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBnZXRUYWcocHJlZml4LCB2YWx1ZSkge1xuICAgIHJldHVybiBwcmVmaXggKyBcIjpcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlLCAoaywgdikgPT4ge1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBgYmlnaW50OiR7di50b1N0cmluZygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydCBvYmplY3Qga2V5c1xuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHYpO1xuICAgICAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKGFjY3VtLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtrZXldID0gdltrZXldO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9KTtcbn1cbi8qKlxuICogIEFuICoqVW5tYW5hZ2VkU3Vic2NyaWJlcioqIGlzIHVzZWZ1bCBmb3IgZXZlbnRzIHdoaWNoIGRvIG5vdCByZXF1aXJlXG4gKiAgYW55IGFkZGl0aW9uYWwgbWFuYWdlbWVudCwgc3VjaCBhcyBgYFwiZGVidWdcImBgIHdoaWNoIG9ubHkgcmVxdWlyZXNcbiAqICBlbWl0IGluIHN5bmNocm9ub3VzIGV2ZW50IGxvb3AgdHJpZ2dlcmVkIGNhbGxzLlxuICovXG5leHBvcnQgY2xhc3MgVW5tYW5hZ2VkU3Vic2NyaWJlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIGZvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IFVubWFuYWdlZFN1YnNjcmliZXIgd2l0aCAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7IGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pOyB9XG4gICAgc3RhcnQoKSB7IH1cbiAgICBzdG9wKCkgeyB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7IH1cbiAgICByZXN1bWUoKSB7IH1cbn1cbmZ1bmN0aW9uIGNvcHkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gY29uY2lzaWZ5KGl0ZW1zKSB7XG4gICAgaXRlbXMgPSBBcnJheS5mcm9tKChuZXcgU2V0KGl0ZW1zKSkudmFsdWVzKCkpO1xuICAgIGl0ZW1zLnNvcnQoKTtcbiAgICByZXR1cm4gaXRlbXM7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWJzY3JpcHRpb24oX2V2ZW50LCBwcm92aWRlcikge1xuICAgIGlmIChfZXZlbnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGV2ZW50XCIpO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgdG9waWMgYXJyYXkgaW5mbyBhbiBFdmVudEZpbHRlclxuICAgIGlmIChBcnJheS5pc0FycmF5KF9ldmVudCkpIHtcbiAgICAgICAgX2V2ZW50ID0geyB0b3BpY3M6IF9ldmVudCB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChfZXZlbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN3aXRjaCAoX2V2ZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICBjYXNlIFwibmV0d29ya1wiOlxuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBfZXZlbnQsIHRhZzogX2V2ZW50IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKF9ldmVudCwgMzIpKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBfZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0cmFuc2FjdGlvblwiLCB0YWc6IGdldFRhZyhcInR4XCIsIHsgaGFzaCB9KSwgaGFzaCB9O1xuICAgIH1cbiAgICBpZiAoX2V2ZW50Lm9ycGhhbikge1xuICAgICAgICBjb25zdCBldmVudCA9IF9ldmVudDtcbiAgICAgICAgLy8gQFRPRE86IFNob3VsZCBsb3dlcmNhc2UgYW5kIHdoYXRub3QgdGhpbmdzIGhlcmUgaW5zdGVhZCBvZiBjb3B5Li4uXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwib3JwaGFuXCIsIHRhZzogZ2V0VGFnKFwib3JwaGFuXCIsIGV2ZW50KSwgZmlsdGVyOiBjb3B5KGV2ZW50KSB9O1xuICAgIH1cbiAgICBpZiAoKF9ldmVudC5hZGRyZXNzIHx8IF9ldmVudC50b3BpY3MpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICB0b3BpY3M6ICgoZXZlbnQudG9waWNzIHx8IFtdKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uY2lzaWZ5KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXZlbnQuYWRkcmVzcykge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYWRkQWRkcmVzcyA9IChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGFkZHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYXdhaXQgcmVzb2x2ZUFkZHJlc3MoYWRkciwgcHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50LmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuYWRkcmVzcy5mb3JFYWNoKGFkZEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQWRkcmVzcyhldmVudC5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGNvbmNpc2lmeShhZGRyZXNzZXMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaWx0ZXIsIHRhZzogZ2V0VGFnKFwiZXZlbnRcIiwgZmlsdGVyKSwgdHlwZTogXCJldmVudFwiIH07XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gUHJvdmlkZXJFdmVudFwiLCBcImV2ZW50XCIsIF9ldmVudCk7XG59XG5mdW5jdGlvbiBnZXRUaW1lKCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgfVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgY2FjaGVUaW1lb3V0OiAyNTAsXG4gICAgcG9sbGluZ0ludGVydmFsOiA0MDAwXG59O1xuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFByb3ZpZGVyKiogcHJvdmlkZXMgYSBiYXNlIGNsYXNzIGZvciBvdGhlciBzdWItY2xhc3NlcyB0b1xuICogIGltcGxlbWVudCB0aGUgW1tQcm92aWRlcl1dIEFQSSBieSBub3JtYWxpemluZyBpbnB1dCBhcmd1bWVudHMgYW5kXG4gKiAgZm9ybWF0dGluZyBvdXRwdXQgcmVzdWx0cyBhcyB3ZWxsIGFzIHRyYWNraW5nIGV2ZW50cyBmb3IgY29uc2lzdGVudFxuICogIGJlaGF2aW91ciBvbiBhbiBldmVudHVhbGx5LWNvbnNpc3RlbnQgbmV0d29yay5cbiAqL1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0UHJvdmlkZXIge1xuICAgICNzdWJzO1xuICAgICNwbHVnaW5zO1xuICAgIC8vIG51bGw9dW5wYXVzZWQsIHRydWU9cGF1c2VkK2Ryb3BXaGlsZVBhdXNlZCwgZmFsc2U9cGF1c2VkXG4gICAgI3BhdXNlZFN0YXRlO1xuICAgICNkZXN0cm95ZWQ7XG4gICAgI25ldHdvcmtQcm9taXNlO1xuICAgICNhbnlOZXR3b3JrO1xuICAgICNwZXJmb3JtQ2FjaGU7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIG51bWJlciBpZiBydW5uaW5nIGFuIGV2ZW50IG9yIC0xIGlmIG5vIFwiYmxvY2tcIiBldmVudFxuICAgICNsYXN0QmxvY2tOdW1iZXI7XG4gICAgI25leHRUaW1lcjtcbiAgICAjdGltZXJzO1xuICAgICNkaXNhYmxlQ2NpcFJlYWQ7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkFic3RyYWN0UHJvdmlkZXIqKiBjb25uZWN0ZWQgdG8gJSVuZXR3b3JrJSUsIG9yXG4gICAgICogIHVzZSB0aGUgdmFyaW91cyBuZXR3b3JrIGRldGVjdGlvbiBjYXBhYmlsaXRpZXMgdG8gZGlzY292ZXIgdGhlXG4gICAgICogIFtbTmV0d29ya11dIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICBpZiAoX25ldHdvcmsgPT09IFwiYW55XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9uZXR3b3JrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG5ldHdvcmspO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7IH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xuICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3N1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI25leHRUaW1lciA9IDE7XG4gICAgICAgIHRoaXMuI3RpbWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZGlzYWJsZUNjaXBSZWFkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNvcHRpb25zLnBvbGxpbmdJbnRlcnZhbDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdGhpc2BgLCB0byBhbGxvdyBhbiAqKkFic3RyYWN0UHJvdmlkZXIqKiB0byBpbXBsZW1lbnRcbiAgICAgKiAgdGhlIFtbQ29udHJhY3RSdW5uZXJdXSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZ2V0IHByb3ZpZGVyKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFsbCB0aGUgcmVnaXN0ZXJlZCBwbHVnLWlucy5cbiAgICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jcGx1Z2lucy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBdHRhY2ggYSBuZXcgcGx1Zy1pbi5cbiAgICAgKi9cbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNvbm5lY3QodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCBhIHBsdWdpbiBieSBuYW1lLlxuICAgICAqL1xuICAgIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcmV2ZW50IGFueSBDQ0lQLXJlYWQgb3BlcmF0aW9uLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgcmVxdWVzdGVkXG4gICAgICogIGluIGEgW1tjYWxsXV0gdXNpbmcgYGBlbmFibGVDY2lwUmVhZGBgLlxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlQ2NpcFJlYWQoKSB7IHJldHVybiB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQ7IH1cbiAgICBzZXQgZGlzYWJsZUNjaXBSZWFkKHZhbHVlKSB7IHRoaXMuI2Rpc2FibGVDY2lwUmVhZCA9ICEhdmFsdWU7IH1cbiAgICAvLyBTaGFyZXMgbXVsdGlwbGUgaWRlbnRpY2FsIHJlcXVlc3RzIG1hZGUgZHVyaW5nIHRoZSBzYW1lIDI1MG1zXG4gICAgYXN5bmMgI3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLiNvcHRpb25zLmNhY2hlVGltZW91dDtcbiAgICAgICAgLy8gQ2FjaGluZyBkaXNhYmxlZFxuICAgICAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgdGFnXG4gICAgICAgIGNvbnN0IHRhZyA9IGdldFRhZyhyZXEubWV0aG9kLCByZXEpO1xuICAgICAgICBsZXQgcGVyZm9ybSA9IHRoaXMuI3BlcmZvcm1DYWNoZS5nZXQodGFnKTtcbiAgICAgICAgaWYgKCFwZXJmb3JtKSB7XG4gICAgICAgICAgICBwZXJmb3JtID0gdGhpcy5fcGVyZm9ybShyZXEpO1xuICAgICAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlLnNldCh0YWcsIHBlcmZvcm0pO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BlcmZvcm1DYWNoZS5nZXQodGFnKSA9PT0gcGVyZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZGF0YSBmb3IgZXhlY3V0aW5nIHRoZSBDQ0lQLXJlYWQgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBjY2lwUmVhZEZldGNoKHR4LCBjYWxsZGF0YSwgdXJscykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ2NpcFJlYWQgfHwgdXJscy5sZW5ndGggPT09IDAgfHwgdHgudG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGVyID0gdHgudG8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNhbGxkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxzW2ldO1xuICAgICAgICAgICAgLy8gVVJMIGV4cGFuc2lvblxuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHVybC5yZXBsYWNlKFwie3NlbmRlcn1cIiwgc2VuZGVyKS5yZXBsYWNlKFwie2RhdGF9XCIsIGRhdGEpO1xuICAgICAgICAgICAgLy8gSWYgbm8ge2RhdGF9IGlzIHByZXNlbnQsIHVzZSBQT1NUOyBvdGhlcndpc2UgR0VUXG4gICAgICAgICAgICAvL2NvbnN0IGpzb246IHN0cmluZyB8IG51bGwgPSAodXJsLmluZGV4T2YoXCJ7ZGF0YX1cIikgPj0gMCkgPyBudWxsOiBKU09OLnN0cmluZ2lmeSh7IGRhdGEsIHNlbmRlciB9KTtcbiAgICAgICAgICAgIC8vY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2hKc29uKHsgdXJsOiBocmVmLCBlcnJvclBhc3NUaHJvdWdoOiB0cnVlIH0sIGpzb24sICh2YWx1ZSwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIC8vICAgIHZhbHVlLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgICAvLyAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvL30pO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoaHJlZik7XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoXCJ7ZGF0YX1cIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0geyBkYXRhLCBzZW5kZXIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRDY2lwUmVhZEZldGNoUmVxdWVzdFwiLCByZXF1ZXN0LCBpbmRleDogaSwgdXJscyB9KTtcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcInVua25vd24gZXJyb3JcIjtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSByZXNvdXJjZS4uLlxuICAgICAgICAgICAgbGV0IHJlc3A7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3AgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIC4uLmxvdy1sZXZlbCBmZXRjaCBlcnJvciAobWlzc2luZyBob3N0LCBiYWQgU1NMLCBldGMuKSxcbiAgICAgICAgICAgICAgICAvLyBzbyB0cnkgbmV4dCBVUkxcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hFcnJvclwiLCByZXF1ZXN0LCByZXN1bHQ6IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcC5ib2R5SnNvbjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hSZXN1bHRcIiwgcmVxdWVzdCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSByZXN1bHQubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hFcnJvclwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gNHh4IGluZGljYXRlcyB0aGUgcmVzdWx0IGlzIG5vdCBwcmVzZW50OyBzdG9wXG4gICAgICAgICAgICBhc3NlcnQocmVzcC5zdGF0dXNDb2RlIDwgNDAwIHx8IHJlc3Auc3RhdHVzQ29kZSA+PSA1MDAsIGByZXNwb25zZSBub3QgZm91bmQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlfWAsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwgeyByZWFzb246IFwiNDA0X01JU1NJTkdfUkVTT1VSQ0VcIiwgdHJhbnNhY3Rpb246IHR4LCBpbmZvOiB7IHVybCwgZXJyb3JNZXNzYWdlIH0gfSk7XG4gICAgICAgICAgICAvLyA1eHggaW5kaWNhdGVzIHNlcnZlciBpc3N1ZTsgdHJ5IHRoZSBuZXh0IHVybFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlcy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0pKS5qb2luKFwiLCBcIil9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiNTAwX1NFUlZFUl9FUlJPUlwiLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LCBpbmZvOiB7IHVybHMsIGVycm9yTWVzc2FnZXMgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGJsb2NrIGJlZm9yZVxuICAgICAqICByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW4gYWx0ZXJuYXRlXG4gICAgICogIHN1Yi1jbGFzcyBvZiBbW0Jsb2NrXV0uXG4gICAgICovXG4gICAgX3dyYXBCbG9jayh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrKGZvcm1hdEJsb2NrKHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSBsb2cgYmVmb3JlXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbTG9nXV0uXG4gICAgICovXG4gICAgX3dyYXBMb2codmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2coZm9ybWF0TG9nKHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSB0cmFuc2FjdGlvblxuICAgICAqICByZWNlaXB0IGJlZm9yZSByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW5cbiAgICAgKiAgYWx0ZXJuYXRlIHN1Yi1jbGFzcyBvZiBbW1RyYW5zYWN0aW9uUmVjZWlwdF1dLlxuICAgICAqL1xuICAgIF93cmFwVHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZWNlaXB0KGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgdHJhbnNhY3Rpb25cbiAgICAgKiAgcmVzcG9uc2UgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxuICAgICAqICBhbHRlcm5hdGUgc3ViLWNsYXNzIG9mIFtbVHJhbnNhY3Rpb25SZXNwb25zZV1dLlxuICAgICAqL1xuICAgIF93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UoZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh0eCksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIE5ldHdvcmssIGZvcmNpbmcgYSBuZXR3b3JrIGRldGVjdGlvbiB1c2luZyB3aGF0ZXZlclxuICAgICAqICB0ZWNobmlxdWUgdGhlIHN1Yi1jbGFzcyByZXF1aXJlcy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzLlxuICAgICAqL1xuICAgIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwic3ViLWNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgdGhpc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiX2RldGVjdE5ldHdvcmtcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIHNob3VsZCB1c2UgdGhpcyB0byBwZXJmb3JtIGFsbCBidWlsdC1pbiBvcGVyYXRpb25zLiBBbGxcbiAgICAgKiAgbWV0aG9kcyBzYW5pdGl6ZXMgYW5kIG5vcm1hbGl6ZXMgdGhlIHZhbHVlcyBwYXNzZWQgaW50byB0aGlzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXG4gICAgICovXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgYHVuc3VwcG9ydGVkIG1ldGhvZDogJHtyZXEubWV0aG9kfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogcmVxLm1ldGhvZCxcbiAgICAgICAgICAgIGluZm86IHJlcVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gU3RhdGVcbiAgICBhc3luYyBnZXRCbG9ja051bWJlcigpIHtcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBnZXROdW1iZXIoYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRCbG9ja051bWJlclwiIH0pLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWFkZHJlc3MlJSwgcmVzb2x2aW5nIEVOU1xuICAgICAqICBuYW1lcyBhbmQgW1tBZGRyZXNzYWJsZV1dIG9iamVjdHMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGFuXG4gICAgICogIGFkZHJlc3MuXG4gICAgICovXG4gICAgX2dldEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3MoYWRkcmVzcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgdmFsaWQgYmxvY2sgdGFnIGZvciAlJWJsb2NrVGFnJSUsIHJlc29sdmluZ1xuICAgICAqICBuZWdhdGl2ZSB2YWx1ZXMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWQgYmxvY2sgdGFnLlxuICAgICAqL1xuICAgIF9nZXRCbG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChibG9ja1RhZykge1xuICAgICAgICAgICAgY2FzZSBcImVhcmxpZXN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICBjYXNlIFwibGF0ZXN0XCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrVGFnLCAzMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eShibG9ja1RhZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IGdldE51bWJlcihibG9ja1RhZywgXCJibG9ja1RhZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChibG9ja1RhZyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkoYmxvY2tUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkodGhpcy4jbGFzdEJsb2NrTnVtYmVyICsgYmxvY2tUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChiKSA9PiB0b1F1YW50aXR5KGIgKyBibG9ja1RhZykpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgYmxvY2tUYWdcIiwgXCJibG9ja1RhZ1wiLCBibG9ja1RhZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgZmlsdGVyIGZvciAlJWZpbHRlciUlLCByZXNvbHZpbmcgYW55IEVOU1xuICAgICAqICBuYW1lcyBvciBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0IGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkXG4gICAgICogIGZpbHRlci5cbiAgICAgKi9cbiAgICBfZ2V0RmlsdGVyKGZpbHRlcikge1xuICAgICAgICAvLyBDcmVhdGUgYSBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRvcGljc1xuICAgICAgICBjb25zdCB0b3BpY3MgPSAoZmlsdGVyLnRvcGljcyB8fCBbXSkubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jaXNpZnkodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJsb2NrSGFzaCA9IChcImJsb2NrSGFzaFwiIGluIGZpbHRlcikgPyBmaWx0ZXIuYmxvY2tIYXNoIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCByZXNvbHZlID0gKF9hZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgc3dpdGNoIChfYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBfYWRkcmVzcy5zb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUJsb2NrICE9IG51bGwgfHwgdG9CbG9jayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmlsdGVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9waWNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IGZyb21CbG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSB0b0Jsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgIGZpbHRlci5ibG9ja0hhc2ggPSBibG9ja0hhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBZGRyZXNzZXMgY291bGQgYmUgYXN5bmMgKEVOUyBuYW1lcyBvciBBZGRyZXNzYWJsZXMpXG4gICAgICAgIGxldCBhZGRyZXNzID0gW107XG4gICAgICAgIGlmIChmaWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIG9mIGZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGFkZHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLnB1c2godGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBmcm9tQmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChcImZyb21CbG9ja1wiIGluIGZpbHRlcikge1xuICAgICAgICAgICAgZnJvbUJsb2NrID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyLmZyb21CbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvQmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChcInRvQmxvY2tcIiBpbiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHRvQmxvY2sgPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXIudG9CbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3MuZmlsdGVyKChhKSA9PiAodHlwZW9mIChhKSAhPT0gXCJzdHJpbmdcIikpLmxlbmd0aCB8fFxuICAgICAgICAgICAgKGZyb21CbG9jayAhPSBudWxsICYmIHR5cGVvZiAoZnJvbUJsb2NrKSAhPT0gXCJzdHJpbmdcIikgfHxcbiAgICAgICAgICAgICh0b0Jsb2NrICE9IG51bGwgJiYgdHlwZW9mICh0b0Jsb2NrKSAhPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbUHJvbWlzZS5hbGwoYWRkcmVzcyksIGZyb21CbG9jaywgdG9CbG9ja10pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoYWRkcmVzcywgZnJvbUJsb2NrLCB0b0Jsb2NrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSB0cmFuc2FjdGlvbiBmb3IgJSVyZXF1ZXN0JSUsIHJlc29sdmluZ1xuICAgICAqICBhbnkgRU5TIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZFxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBfZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF9yZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjb3B5UmVxdWVzdChfcmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIFtcInRvXCIsIFwiZnJvbVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSByZXNvbHZlQWRkcmVzcyhyZXF1ZXN0W2tleV0sIHRoaXMpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShhZGRyKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgcmVxdWVzdFtrZXldID0gYXdhaXQgYWRkcjsgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0W2tleV0gPSBhZGRyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlcXVlc3QuYmxvY2tUYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhyZXF1ZXN0LmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyByZXF1ZXN0LmJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7IH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ibG9ja1RhZyA9IGJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGFzeW5jIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IG5ldHdvcmsgd2FzIHNldCBhbmQgdGhpcyBpcyBvdXIgZmlyc3QgdGltZVxuICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRGV0ZWN0IHRoZSBjdXJyZW50IG5ldHdvcmsgKHNoYXJlZCB3aXRoIGFsbCBjYWxscylcbiAgICAgICAgICAgIGNvbnN0IGRldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLl9kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09PSBkZXRlY3ROZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gZGV0ZWN0TmV0d29yaztcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgZGV0ZWN0TmV0d29yaykuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrUHJvbWlzZSA9IHRoaXMuI25ldHdvcmtQcm9taXNlO1xuICAgICAgICBjb25zdCBbZXhwZWN0ZWQsIGFjdHVhbF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBuZXR3b3JrUHJvbWlzZSxcbiAgICAgICAgICAgIHRoaXMuX2RldGVjdE5ldHdvcmsoKSAvLyBUaGUgYWN0dWFsIGNvbm5lY3RlZCBuZXR3b3JrXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoZXhwZWN0ZWQuY2hhaW5JZCAhPT0gYWN0dWFsLmNoYWluSWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIFwiYW55XCIgbmV0d29yayBjYW4gY2hhbmdlLCBzbyBub3RpZnkgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBhY3R1YWwsIGV4cGVjdGVkKTtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG5ldHdvcmsgaWYgc29tZXRoaW5nIGVsc2UgaGFzbid0IGFscmVhZHkgY2hhbmdlZCBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PT0gbmV0d29ya1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYWN0dWFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGRvIG5vdCBhbGxvdyBjaGFuZ2VzIHRvIHRoZSB1bmRlcmx5aW5nIG5ldHdvcmtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGBuZXR3b3JrIGNoYW5nZWQ6ICR7ZXhwZWN0ZWQuY2hhaW5JZH0gPT4gJHthY3R1YWwuY2hhaW5JZH0gYCwgXCJORVRXT1JLX0VSUk9SXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiY2hhbmdlZFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkLmNsb25lKCk7XG4gICAgfVxuICAgIGFzeW5jIGdldEZlZURhdGEoKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgY29uc3QgZ2V0RmVlRGF0YUZ1bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IF9ibG9jaywgZ2FzUHJpY2UsIHByaW9yaXR5RmVlIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgX2Jsb2NrOiB0aGlzLiNnZXRCbG9jayhcImxhdGVzdFwiLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6ICgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldEdhc1ByaWNlXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpKSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eUZlZTogKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0UHJpb3JpdHlGZWVcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUsIFwiJXJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pKCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBtYXhGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG1heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgcmVjb21tZW5kZWQgRUlQLTE1NTkgaGV1cmlzdGljcyBmb3IgZmVlIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5fd3JhcEJsb2NrKF9ibG9jaywgbmV0d29yayk7XG4gICAgICAgICAgICBpZiAoYmxvY2sgJiYgYmxvY2suYmFzZUZlZVBlckdhcykge1xuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gKHByaW9yaXR5RmVlICE9IG51bGwpID8gcHJpb3JpdHlGZWUgOiBCaWdJbnQoXCIxMDAwMDAwMDAwXCIpO1xuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IChibG9jay5iYXNlRmVlUGVyR2FzICogQk5fMikgKyBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRmVlRGF0YShnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENoZWNrIGZvciBhIEZlZURhdGFOZXRXb3JrUGx1Z2luXG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xuICAgICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KHBsdWdpbi51cmwpO1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHBsdWdpbi5wcm9jZXNzRnVuYyhnZXRGZWVEYXRhRnVuYywgdGhpcywgcmVxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmVlRGF0YShmZWVEYXRhLmdhc1ByaWNlLCBmZWVEYXRhLm1heEZlZVBlckdhcywgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldEZlZURhdGFGdW5jKCk7XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlR2FzKF90eCkge1xuICAgICAgICBsZXQgdHggPSB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSh0eCkpIHtcbiAgICAgICAgICAgIHR4ID0gYXdhaXQgdHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEJpZ0ludChhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJlc3RpbWF0ZUdhc1wiLCB0cmFuc2FjdGlvbjogdHhcbiAgICAgICAgfSksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyAjY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQpIHtcbiAgICAgICAgYXNzZXJ0KGF0dGVtcHQgPCBNQVhfQ0NJUF9SRURJUkVDVFMsIFwiQ0NJUCByZWFkIGV4Y2VlZGVkIG1heGltdW0gcmVkaXJlY3Rpb25zXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcIlRPT19NQU5ZX1JFRElSRUNUU1wiLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4LCB7IGJsb2NrVGFnLCBlbmFibGVDY2lwUmVhZDogdHJ1ZSB9KVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhpcyBjYW1lIGluIGFzIGEgUGVyZm9ybUFjdGlvblRyYW5zYWN0aW9uLCBzbyB0by9mcm9tIGFyZSBzYWZlOyB3ZSBjYW4gY2FzdFxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNvcHlSZXF1ZXN0KHR4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuX3BlcmZvcm0oeyBtZXRob2Q6IFwiY2FsbFwiLCB0cmFuc2FjdGlvbiwgYmxvY2tUYWcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ0NJUCBSZWFkIE9mZmNoYWluTG9va3VwXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZUNjaXBSZWFkICYmIGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSAmJiBhdHRlbXB0ID49IDAgJiYgYmxvY2tUYWcgPT09IFwibGF0ZXN0XCIgJiYgdHJhbnNhY3Rpb24udG8gIT0gbnVsbCAmJiBkYXRhU2xpY2UoZXJyb3IuZGF0YSwgMCwgNCkgPT09IFwiMHg1NTZmMTgzMFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGVycm9yLmRhdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhTZW5kZXIgPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0cmFuc2FjdGlvbi50bywgdGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIENDSVAgUmVhZCBBcmd1bWVudHNcbiAgICAgICAgICAgICAgICBsZXQgY2NpcEFyZ3M7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2NpcEFyZ3MgPSBwYXJzZU9mZmNoYWluTG9va3VwKGRhdGFTbGljZShlcnJvci5kYXRhLCA0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkJBRF9EQVRBXCIsIHRyYW5zYWN0aW9uLCBpbmZvOiB7IGRhdGEgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHNlbmRlciBvZiB0aGUgT2ZmY2hhaW5Mb29rdXAgbWF0Y2hlcyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICBhc3NlcnQoY2NpcEFyZ3Muc2VuZGVyLnRvTG93ZXJDYXNlKCkgPT09IHR4U2VuZGVyLnRvTG93ZXJDYXNlKCksIFwiQ0NJUCBSZWFkIHNlbmRlciBtaXNtYXRjaFwiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBjY2lwQXJncy5lcnJvckFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNjaXBSZXN1bHQgPSBhd2FpdCB0aGlzLmNjaXBSZWFkRmV0Y2godHJhbnNhY3Rpb24sIGNjaXBBcmdzLmNhbGxkYXRhLCBjY2lwQXJncy51cmxzKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoY2NpcFJlc3VsdCAhPSBudWxsLCBcIkNDSVAgUmVhZCBmYWlsZWQgdG8gZmV0Y2ggZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkZFVENIX0ZBSUxFRFwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhOiBlcnJvci5kYXRhLCBlcnJvckFyZ3M6IGNjaXBBcmdzLmVycm9yQXJncyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiB0eFNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY29uY2F0KFtjY2lwQXJncy5zZWxlY3RvciwgZW5jb2RlQnl0ZXMoW2NjaXBSZXN1bHQsIGNjaXBBcmdzLmV4dHJhRGF0YV0pXSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRDY2lwUmVhZENhbGxcIiwgdHJhbnNhY3Rpb246IHR4IH0pO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZENhbGxSZXN1bHRcIiwgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4KSwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkQ2FsbEVycm9yXCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjY2hlY2tOZXR3b3JrKHByb21pc2UpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICB2YWx1ZTogcHJvbWlzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBhc3luYyBjYWxsKF90eCkge1xuICAgICAgICBjb25zdCB7IHR4LCBibG9ja1RhZyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdHg6IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfdHgpLFxuICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKF90eC5ibG9ja1RhZylcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jY2FsbCh0eCwgYmxvY2tUYWcsIF90eC5lbmFibGVDY2lwUmVhZCA/IDAgOiAtMSkpO1xuICAgIH1cbiAgICAvLyBBY2NvdW50XG4gICAgYXN5bmMgI2dldEFjY291bnRWYWx1ZShyZXF1ZXN0LCBfYWRkcmVzcywgX2Jsb2NrVGFnKSB7XG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhfYWRkcmVzcyk7XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKF9ibG9ja1RhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBbYWRkcmVzcywgYmxvY2tUYWddID0gYXdhaXQgUHJvbWlzZS5hbGwoW2FkZHJlc3MsIGJsb2NrVGFnXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NoZWNrTmV0d29yayh0aGlzLiNwZXJmb3JtKE9iamVjdC5hc3NpZ24ocmVxdWVzdCwgeyBhZGRyZXNzLCBibG9ja1RhZyB9KSkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRCYWxhbmNlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBnZXRCaWdJbnQoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldEJhbGFuY2VcIiB9LCBhZGRyZXNzLCBibG9ja1RhZyksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBnZXROdW1iZXIoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uQ291bnRcIiB9LCBhZGRyZXNzLCBibG9ja1RhZyksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRDb2RlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRDb2RlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U3RvcmFnZShhZGRyZXNzLCBfcG9zaXRpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0QmlnSW50KF9wb3NpdGlvbiwgXCJwb3NpdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFN0b3JhZ2VcIiwgcG9zaXRpb24gfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcbiAgICB9XG4gICAgLy8gV3JpdGVcbiAgICBhc3luYyBicm9hZGNhc3RUcmFuc2FjdGlvbihzaWduZWRUeCkge1xuICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBoYXNoLCBuZXR3b3JrIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgaGFzaDogdGhpcy5fcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgc2lnbmVkVHJhbnNhY3Rpb246IHNpZ25lZFR4XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eCA9IFRyYW5zYWN0aW9uLmZyb20oc2lnbmVkVHgpO1xuICAgICAgICBpZiAodHguaGFzaCAhPT0gaGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE86IHRoZSByZXR1cm5lZCBoYXNoIGRpZCBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKS5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKTtcbiAgICB9XG4gICAgYXN5bmMgI2dldEJsb2NrKGJsb2NrLCBpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgQ3VzdG9tQmxvY2tQbHVnaW4gY2hlY2tcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrLCAzMikpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0QmxvY2tcIiwgYmxvY2tIYXNoOiBibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2spO1xuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlcmZvcm0oe1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrVGFnLCBpbmNsdWRlVHJhbnNhY3Rpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBRdWVyaWVzXG4gICAgYXN5bmMgZ2V0QmxvY2soYmxvY2ssIHByZWZldGNoVHhzKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jZ2V0QmxvY2soYmxvY2ssICEhcHJlZmV0Y2hUeHMpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwQmxvY2socGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25cIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UocGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgYmFja2VuZHMgZGlkIG5vdCBiYWNrZmlsbCB0aGUgZWZmZWN0aXZlR2FzUHJpY2UgaW50byBvbGQgdHJhbnNhY3Rpb25zXG4gICAgICAgIC8vIGluIHRoZSByZWNlaXB0LCBzbyB3ZSBsb29rIGl0IHVwIG1hbnVhbGx5IGFuZCBpbmplY3QgaXQuXG4gICAgICAgIGlmIChwYXJhbXMuZ2FzUHJpY2UgPT0gbnVsbCAmJiBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uXCIsIGhhc2ggfSk7XG4gICAgICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcG9ydCB0aGlzOyBjb3VsZCBub3QgZmluZCB0eCBvciBlZmZlY3RpdmVHYXNQcmljZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtcy5lZmZlY3RpdmVHYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZWNlaXB0KHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVzdWx0KGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcmVzdWx0OiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uUmVzdWx0XCIsIGhhc2ggfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQmxvb20tZmlsdGVyIFF1ZXJpZXNcbiAgICBhc3luYyBnZXRMb2dzKF9maWx0ZXIpIHtcbiAgICAgICAgbGV0IGZpbHRlciA9IHRoaXMuX2dldEZpbHRlcihfZmlsdGVyKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShmaWx0ZXIpKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBhd2FpdCBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldExvZ3NcIiwgZmlsdGVyIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1zLm1hcCgocCkgPT4gdGhpcy5fd3JhcExvZyhwLCBuZXR3b3JrKSk7XG4gICAgfVxuICAgIC8vIEVOU1xuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJwcm92aWRlciBjYW5ub3QgY29ubmVjdCB0byB0YXJnZXQgbmV0d29ya1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiX2dldFByb3ZpZGVyKClcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVzb2x2ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgRW5zUmVzb2x2ZXIuZnJvbU5hbWUodGhpcywgbmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEF2YXRhcihuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZXIuZ2V0QXZhdGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVOYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlci5nZXRBZGRyZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGxvb2t1cEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGVuc0NvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGVuc0FkZHIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IGVuc0NvbnRyYWN0LnJlc29sdmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyID09IG51bGwgfHwgcmVzb2x2ZXIgPT09IFplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlckNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KHJlc29sdmVyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBuYW1lKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiXG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCByZXNvbHZlckNvbnRyYWN0Lm5hbWUobm9kZSk7XG4gICAgICAgICAgICAvLyBGYWlsZWQgZm9yd2FyZCByZXNvbHV0aW9uXG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IGF3YWl0IHRoaXMucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTm8gZGF0YSB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgcmVzb2x2ZXJcbiAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJBRF9EQVRBXCIpICYmIGVycm9yLnZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyByZWVydGVkXG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbihoYXNoLCBfY29uZmlybXMsIHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgY29uZmlybXMgPSAoX2NvbmZpcm1zICE9IG51bGwpID8gX2NvbmZpcm1zIDogMTtcbiAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChhc3luYyAoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMub2ZmKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFRUVcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJ0aW1lb3V0XCIsIFwiVElNRU9VVFwiLCB7IHJlYXNvbjogXCJ0aW1lb3V0XCIgfSkpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXIoYXdhaXQgdGhpcy5nZXRCbG9ja051bWJlcigpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JCbG9jayhibG9ja1RhZykge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwibm90IGltcGxlbWVudGVkIHlldFwiLCBcIk5PVF9JTVBMRU1FTlRFRFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwid2FpdEZvckJsb2NrXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDbGVhciBhIHRpbWVyIGNyZWF0ZWQgdXNpbmcgdGhlIFtbX3NldFRpbWVvdXRdXSBtZXRob2QuXG4gICAgICovXG4gICAgX2NsZWFyVGltZW91dCh0aW1lcklkKSB7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gdGhpcy4jdGltZXJzLmdldCh0aW1lcklkKTtcbiAgICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lci50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyLnRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiN0aW1lcnMuZGVsZXRlKHRpbWVySWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgdGltZXIgdGhhdCB3aWxsIGV4ZWN1dGUgJSVmdW5jJSUgYWZ0ZXIgYXQgbGVhc3QgJSV0aW1lb3V0JSVcbiAgICAgKiAgKGluIG1zKS4gSWYgJSV0aW1lb3V0JSUgaXMgdW5zcGVjaWZpZWQsIHRoZW4gJSVmdW5jJSUgd2lsbCBleGVjdXRlXG4gICAgICogIGluIHRoZSBuZXh0IGV2ZW50IGxvb3AuXG4gICAgICpcbiAgICAgKiAgW1BhdXNpbmddKEFic3RyYWN0UHJvdmlkZXItcGF1c2VkKSB0aGUgcHJvdmlkZXIgd2lsbCBwYXVzZSBhbnlcbiAgICAgKiAgYXNzb2NpYXRlZCB0aW1lcnMuXG4gICAgICovXG4gICAgX3NldFRpbWVvdXQoX2Z1bmMsIHRpbWVvdXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZXJJZCA9IHRoaXMuI25leHRUaW1lcisrO1xuICAgICAgICBjb25zdCBmdW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcbiAgICAgICAgICAgIF9mdW5jKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLnNldCh0aW1lcklkLCB7IHRpbWVyOiBudWxsLCBmdW5jLCB0aW1lOiB0aW1lb3V0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmMsIHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLnNldCh0aW1lcklkLCB7IHRpbWVyLCBmdW5jLCB0aW1lOiBnZXRUaW1lKCkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWVySWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQZXJmb3JtICUlZnVuYyUlIG9uIGVhY2ggc3Vic2NyaWJlci5cbiAgICAgKi9cbiAgICBfZm9yRWFjaFN1YnNjcmliZXIoZnVuYykge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmdW5jKHN1Yi5zdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gY3VzdG9taXplIHN1YnNjcmlwdGlvblxuICAgICAqICBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICovXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIHN3aXRjaCAoc3ViLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICBjYXNlIFwibmV0d29ya1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlcihzdWIudHlwZSk7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSBuZXcgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMucG9sbGluZ0ludGVydmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdCbG9ja1RhZ1N1YnNjcmliZXIodGhpcywgc3ViLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgY2FzZSBcInRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHRoaXMsIHN1Yi5oYXNoKTtcbiAgICAgICAgICAgIGNhc2UgXCJvcnBoYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXZlbnQ6ICR7c3ViLnR5cGV9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBhIFtbU3Vic2NyaWJlcl1dIGZhaWxzIGFuZCBuZWVkcyB0byByZXBsYWNlIGl0c2VsZiwgdGhpc1xuICAgICAqICBtZXRob2QgbWF5IGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIHRoaXMgaXMgdXNlZCBmb3IgcHJvdmlkZXJzIHdoZW4gdXNpbmcgdGhlXG4gICAgICogIGBgZXRoX2dldEZpbHRlckNoYW5nZXNgYCBtZXRob2QsIHdoaWNoIGNhbiByZXR1cm4gbnVsbCBpZiBzdGF0ZVxuICAgICAqICBmaWx0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBiYWNrZW5kLCBhbGxvd2luZyB0aGUgU3Vic2NyaWJlclxuICAgICAqICB0byBzd2FwIGluIGEgW1tQb2xsaW5nRXZlbnRTdWJzY3JpYmVyXV0uXG4gICAgICovXG4gICAgX3JlY292ZXJTdWJzY3JpYmVyKG9sZFN1YiwgbmV3U3ViKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3Vic2NyaWJlciA9PT0gb2xkU3ViKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIgPSBuZXdTdWI7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1Yi5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjaGFzU3ViKGV2ZW50LCBlbWl0QXJncykge1xuICAgICAgICBsZXQgc3ViID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKGV2ZW50LCB0aGlzKTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxvZyB0aGF0IGlzIHJlbW92aW5nIGFuIGV4aXN0aW5nIGxvZzsgd2UgYWN0dWFsbHkgd2FudFxuICAgICAgICAvLyB0byBlbWl0IGFuIG9ycGhhbiBldmVudCBmb3IgdGhlIHJlbW92ZWQgbG9nXG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJldmVudFwiICYmIGVtaXRBcmdzICYmIGVtaXRBcmdzLmxlbmd0aCA+IDAgJiYgZW1pdEFyZ3NbMF0ucmVtb3ZlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3ViID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKHsgb3JwaGFuOiBcImRyb3AtbG9nXCIsIGxvZzogZW1pdEFyZ3NbMF0gfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3N1YnMuZ2V0KHN1Yi50YWcpIHx8IG51bGw7XG4gICAgfVxuICAgIGFzeW5jICNnZXRTdWIoZXZlbnQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKGV2ZW50LCB0aGlzKTtcbiAgICAgICAgLy8gUHJldmVudCB0YW1wZXJpbmcgd2l0aCBvdXIgdGFnIGluIGFueSBzdWJjbGFzcycgX2dldFN1YnNjcmliZXJcbiAgICAgICAgY29uc3QgdGFnID0gc3Vic2NyaXB0aW9uLnRhZztcbiAgICAgICAgbGV0IHN1YiA9IHRoaXMuI3N1YnMuZ2V0KHRhZyk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gdGhpcy5fZ2V0U3Vic2NyaWJlcihzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2FibGVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgY29uc3QgbmFtZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHN1YiA9IHsgc3Vic2NyaWJlciwgdGFnLCBhZGRyZXNzYWJsZU1hcCwgbmFtZU1hcCwgc3RhcnRlZDogZmFsc2UsIGxpc3RlbmVyczogW10gfTtcbiAgICAgICAgICAgIHRoaXMuI3N1YnMuc2V0KHRhZywgc3ViKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICBhc3luYyBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IGZhbHNlIH0pO1xuICAgICAgICBpZiAoIXN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdGFydCgpO1xuICAgICAgICAgICAgc3ViLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBpZiAoIXN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdGFydCgpO1xuICAgICAgICAgICAgc3ViLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50LCBhcmdzKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IHN1YnNjcmlwdGlvbiBvciBpZiBhIHJlY2VudCBlbWl0IHJlbW92ZWRcbiAgICAgICAgLy8gdGhlIGxhc3Qgb2YgdGhlbSAod2hpY2ggYWxzbyBkZWxldGVkIHRoZSBzdWIpIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCFzdWIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMgPSBzdWIubGlzdGVuZXJzLmZpbHRlcigoeyBsaXN0ZW5lciwgb25jZSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gbmV3IEV2ZW50UGF5bG9hZCh0aGlzLCAob25jZSA/IG51bGwgOiBsaXN0ZW5lciksIGV2ZW50KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCAuLi5hcmdzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gIW9uY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY291bnQgPiAwKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaXN0ZW5lciB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGFnLCBzdGFydGVkLCBzdWJzY3JpYmVyIH0gPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt0YWcsIHsgc3RhcnRlZCwgc3Vic2NyaWJlciB9XSBvZiB0aGlzLiNzdWJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcbiAgICBhc3luYyBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLy8gQWxpYXMgZm9yIFwib2ZmXCJcbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0aGlzIHByb3ZpZGVyIGhhcyBiZWVuIGRlc3Ryb3llZCB1c2luZyB0aGUgW1tkZXN0cm95XV0gbWV0aG9kLlxuICAgICAqXG4gICAgICogIE9uY2UgZGVzdHJveWVkLCBhbGwgcmVzb3VyY2VzIGFyZSByZWNsYWltZWQsIGludGVybmFsIGV2ZW50IGxvb3BzXG4gICAgICogIGFuZCB0aW1lcnMgYXJlIGNsZWFuZWQgdXAgYW5kIG5vIGZ1cnRoZXIgcmVxdWVzdHMgbWF5IGJlIHNlbnQgdG9cbiAgICAgKiAgdGhlIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkZXN0cm95ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgdXNlIHRoaXMgdG8gc2h1dGRvd24gYW55IHNvY2tldHMgb3IgcmVsZWFzZSB0aGVpclxuICAgICAqICByZXNvdXJjZXMgYW5kIHJlamVjdCBhbnkgcGVuZGluZyByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBjYWxsIGBgc3VwZXIuZGVzdHJveSgpYGAuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gU3RvcCBhbGwgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIC8vIFNodXQgZG93biBhbGwgdGllbXJzXG4gICAgICAgIGZvciAoY29uc3QgdGltZXJJZCBvZiB0aGlzLiN0aW1lcnMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhlIHByb3ZpZGVyIGlzIGN1cnJlbnRseSBwYXVzZWQuXG4gICAgICpcbiAgICAgKiAgQSBwYXVzZWQgcHJvdmlkZXIgd2lsbCBub3QgZW1pdCBhbnkgZXZlbnRzLCBhbmQgZ2VuZXJhbGx5IHNob3VsZFxuICAgICAqICBub3QgbWFrZSBhbnkgcmVxdWVzdHMgdG8gdGhlIG5ldHdvcmssIGJ1dCB0aGF0IGlzIHVwIHRvIHN1Yi1jbGFzc2VzXG4gICAgICogIHRvIG1hbmFnZS5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIGBgcGF1c2VkID0gdHJ1ZWBgIGlzIGlkZW50aWNhbCB0byBjYWxsaW5nIGBgLnBhdXNlKGZhbHNlKWBgLFxuICAgICAqICB3aGljaCB3aWxsIGJ1ZmZlciBhbnkgZXZlbnRzIHRoYXQgb2NjdXIgd2hpbGUgcGF1c2VkIHVudGlsIHRoZVxuICAgICAqICBwcm92aWRlciBpcyB1bnBhdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgcGF1c2VkKCkgeyByZXR1cm4gKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpOyB9XG4gICAgc2V0IHBhdXNlZChwYXVzZSkge1xuICAgICAgICBpZiAoISFwYXVzZSA9PT0gdGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGF1c2UgdGhlIHByb3ZpZGVyLiBJZiAlJWRyb3BXaGlsZVBhdXNlZCUlLCBhbnkgZXZlbnRzIHRoYXQgb2NjdXJcbiAgICAgKiAgd2hpbGUgcGF1c2VkIGFyZSBkcm9wcGVkLCBvdGhlcndpc2UgYWxsIGV2ZW50cyB3aWxsIGJlIGVtaXR0ZWQgb25jZVxuICAgICAqICB0aGUgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlID09ICEhZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBjaGFuZ2UgcGF1c2UgdHlwZTsgcmVzdW1lIGZpcnN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicGF1c2VcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHMpID0+IHMucGF1c2UoZHJvcFdoaWxlUGF1c2VkKSk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gISFkcm9wV2hpbGVQYXVzZWQ7XG4gICAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy4jdGltZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgdGltZXJcbiAgICAgICAgICAgIGlmICh0aW1lci50aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSBuZWVkZWQgZm9yIHdoZW4gd2UgYmVjb21lIHVucGF1c2VkXG4gICAgICAgICAgICB0aW1lci50aW1lID0gZ2V0VGltZSgpIC0gdGltZXIudGltZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzdW1lIHRoZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHMpID0+IHMucmVzdW1lKCkpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy4jdGltZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSB3aGVuIHdlIHdlcmUgcGF1c2VkXG4gICAgICAgICAgICBsZXQgdGltZW91dCA9IHRpbWVyLnRpbWU7XG4gICAgICAgICAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IHRpbWUgKGluIGNhdXNlIHBhdXNlZCwgc28gd2UgY29uIGNvbXB1dGUgcmVtYWluaW5mIHRpbWUpXG4gICAgICAgICAgICB0aW1lci50aW1lID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVyLmZ1bmMsIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCwgc3RhcnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBieXRlcyA9IF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpO1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBnZXROdW1iZXIoZGF0YVNsaWNlKHJlc3VsdCwgc3RhcnQsIHN0YXJ0ICsgMzIpKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TnVtYmVyKGRhdGFTbGljZShyZXN1bHQsIG9mZnNldCwgb2Zmc2V0ICsgMzIpKTtcbiAgICAgICAgcmV0dXJuIGRhdGFTbGljZShyZXN1bHQsIG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIGxlbmd0aCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBudW1QYWQodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcGFkZGVkLnNldChyZXN1bHQsIDMyIC0gcmVzdWx0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHBhZGRlZDtcbn1cbmZ1bmN0aW9uIGJ5dGVzUGFkKHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZS5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwodmFsdWUubGVuZ3RoIC8gMzIpICogMzIpO1xuICAgIHJlc3VsdC5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBlbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8vIEFCSSBFbmNvZGVzIGEgc2VyaWVzIG9mIChieXRlcywgYnl0ZXMsIC4uLilcbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKGRhdGFzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgLy8gQWRkIHBsYWNlLWhvbGRlcnMgZm9yIHBvaW50ZXJzIGFzIHdlIGFkZCBpdGVtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZW1wdHkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKGRhdGFzW2ldKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBieXRlcyBvZmZzZXRcbiAgICAgICAgcmVzdWx0W2ldID0gbnVtUGFkKGJ5dGVDb3VudCk7XG4gICAgICAgIC8vIFRoZSBsZW5ndGggYW5kIHBhZGRlZCB2YWx1ZSBvZiBkYXRhXG4gICAgICAgIHJlc3VsdC5wdXNoKG51bVBhZChkYXRhLmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQucHVzaChieXRlc1BhZChkYXRhKSk7XG4gICAgICAgIGJ5dGVDb3VudCArPSAzMiArIE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDMyKSAqIDMyO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KHJlc3VsdCk7XG59XG5jb25zdCB6ZXJvcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5mdW5jdGlvbiBwYXJzZU9mZmNoYWluTG9va3VwKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNlbmRlcjogXCJcIiwgdXJsczogW10sIGNhbGxkYXRhOiBcIlwiLCBzZWxlY3RvcjogXCJcIiwgZXh0cmFEYXRhOiBcIlwiLCBlcnJvckFyZ3M6IFtdXG4gICAgfTtcbiAgICBhc3NlcnQoZGF0YUxlbmd0aChkYXRhKSA+PSA1ICogMzIsIFwiaW5zdWZmaWNpZW50IE9mZmNoYWluTG9va3VwIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJpbnN1ZmZpY2llbnQgT2ZmY2hhaW5Mb29rdXAgZGF0YVwiXG4gICAgfSk7XG4gICAgY29uc3Qgc2VuZGVyID0gZGF0YVNsaWNlKGRhdGEsIDAsIDMyKTtcbiAgICBhc3NlcnQoZGF0YVNsaWNlKHNlbmRlciwgMCwgMTIpID09PSBkYXRhU2xpY2UoemVyb3MsIDAsIDEyKSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgc2VuZGVyXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VuZGVyID0gZGF0YVNsaWNlKHNlbmRlciwgMTIpO1xuICAgIC8vIFJlYWQgdGhlIFVSTHMgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmxzID0gW107XG4gICAgICAgIGNvbnN0IHVybHNPZmZzZXQgPSBnZXROdW1iZXIoZGF0YVNsaWNlKGRhdGEsIDMyLCA2NCkpO1xuICAgICAgICBjb25zdCB1cmxzTGVuZ3RoID0gZ2V0TnVtYmVyKGRhdGFTbGljZShkYXRhLCB1cmxzT2Zmc2V0LCB1cmxzT2Zmc2V0ICsgMzIpKTtcbiAgICAgICAgY29uc3QgdXJsc0RhdGEgPSBkYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCArIDMyKTtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1cmxzTGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IF9wYXJzZVN0cmluZyh1cmxzRGF0YSwgdSAqIDMyKTtcbiAgICAgICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJscy5wdXNoKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVybHMgPSB1cmxzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgdXJsc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBDQ0lQIGNhbGxkYXRhIHRvIGZvcndhcmRcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWxsZGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDY0KTtcbiAgICAgICAgaWYgKGNhbGxkYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5jYWxsZGF0YSA9IGNhbGxkYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsZGF0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGNhbGxiYWNrU2VsZWN0b3IgKGJ5dGVzNClcbiAgICBhc3NlcnQoZGF0YVNsaWNlKGRhdGEsIDEwMCwgMTI4KSA9PT0gZGF0YVNsaWNlKHplcm9zLCAwLCAyOCksIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsYmFhY2tTZWxlY3RvclwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIlxuICAgIH0pO1xuICAgIHJlc3VsdC5zZWxlY3RvciA9IGRhdGFTbGljZShkYXRhLCA5NiwgMTAwKTtcbiAgICAvLyBHZXQgdGhlIGV4dHJhIGRhdGEgdG8gc2VuZCBiYWNrIHRvIHRoZSBjb250cmFjdCBhcyBjb250ZXh0XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0cmFEYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgMTI4KTtcbiAgICAgICAgaWYgKGV4dHJhRGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuZXh0cmFEYXRhID0gZXh0cmFEYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VsdC5lcnJvckFyZ3MgPSBcInNlbmRlcix1cmxzLGNhbGxkYXRhLHNlbGVjdG9yLGV4dHJhRGF0YVwiLnNwbGl0KC8sLykubWFwKChrKSA9PiByZXN1bHRba10pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1wcm92aWRlci5qcy5tYXAiLCIvKipcbiAqICBHZW5lcmFsbHkgdGhlIFtbV2FsbGV0XV0gYW5kIFtbSnNvblJwY1NpZ25lcl1dIGFuZCB0aGVpciBzdWItY2xhc3Nlc1xuICogIGFyZSBzdWZmaWNlbnQgZm9yIG1vc3QgZGV2ZWxvcGVycywgYnV0IHRoaXMgaXMgcHJvdmlkZWQgdG9cbiAqICBmYXNjaWxpdGF0ZSBtb3JlIGNvbXBsZXggU2lnbmVycy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lcjogU3ViY2xhc3NpbmcgU2lnbmVyIFthYnN0cmFjdC1zaWduZXJdXG4gKi9cbmltcG9ydCB7IHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb3B5UmVxdWVzdCB9IGZyb20gXCIuL3Byb3ZpZGVyLmpzXCI7XG5mdW5jdGlvbiBjaGVja1Byb3ZpZGVyKHNpZ25lciwgb3BlcmF0aW9uKSB7XG4gICAgaWYgKHNpZ25lci5wcm92aWRlcikge1xuICAgICAgICByZXR1cm4gc2lnbmVyLnByb3ZpZGVyO1xuICAgIH1cbiAgICBhc3NlcnQoZmFsc2UsIFwibWlzc2luZyBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbiB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBvcHVsYXRlKHNpZ25lciwgdHgpIHtcbiAgICBsZXQgcG9wID0gY29weVJlcXVlc3QodHgpO1xuICAgIGlmIChwb3AudG8gIT0gbnVsbCkge1xuICAgICAgICBwb3AudG8gPSByZXNvbHZlQWRkcmVzcyhwb3AudG8sIHNpZ25lcik7XG4gICAgfVxuICAgIGlmIChwb3AuZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBwb3AuZnJvbTtcbiAgICAgICAgcG9wLmZyb20gPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBzaWduZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgcmVzb2x2ZUFkZHJlc3MoZnJvbSwgc2lnbmVyKVxuICAgICAgICBdKS50aGVuKChbYWRkcmVzcywgZnJvbV0pID0+IHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gZnJvbS50b0xvd2VyQ2FzZSgpLCBcInRyYW5zYWN0aW9uIGZyb20gbWlzbWF0Y2hcIiwgXCJ0eC5mcm9tXCIsIGZyb20pO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9wLmZyb20gPSBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMocG9wKTtcbn1cbi8qKlxuICogIEFuICoqQWJzdHJhY3RTaWduZXIqKiBpbmNsdWRlcyBtb3N0IG9mIHRlaCBmdW5jdGlvbmFsaXR5IHJlcXVpcmVkXG4gKiAgdG8gZ2V0IGEgW1tTaWduZXJdXSB3b3JraW5nIGFzIGV4cGVjdGVkLCBidXQgcmVxdWlyZXMgYSBmZXdcbiAqICBTaWduZXItc3BlY2lmaWMgbWV0aG9kcyBiZSBvdmVycmlkZGVuLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgc2lnbmVyIGlzIGNvbm5lY3RlZCB0by5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBTaWduZXIgY29ubmVjdGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJvdmlkZXI6IChwcm92aWRlciB8fCBudWxsKSB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIpLmdldFRyYW5zYWN0aW9uQ291bnQoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKTtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVDYWxsKHR4KSB7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcbiAgICAgICAgcmV0dXJuIHBvcDtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCBwb3B1bGF0ZSh0aGlzLCB0eCk7XG4gICAgICAgIGlmIChwb3Aubm9uY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9wLm5vbmNlID0gYXdhaXQgdGhpcy5nZXROb25jZShcInBlbmRpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcC5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3AuZ2FzTGltaXQgPSBhd2FpdCB0aGlzLmVzdGltYXRlR2FzKHBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGNoYWluIElEXG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCAodGhpcy5wcm92aWRlcikuZ2V0TmV0d29yaygpO1xuICAgICAgICBpZiAocG9wLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IGdldEJpZ0ludChwb3AuY2hhaW5JZCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChjaGFpbklkID09PSBuZXR3b3JrLmNoYWluSWQsIFwidHJhbnNhY3Rpb24gY2hhaW5JZCBtaXNtYXRjaFwiLCBcInR4LmNoYWluSWRcIiwgdHguY2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3AuY2hhaW5JZCA9IG5ldHdvcmsuY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgYWxsb3cgbWl4aW5nIHByZS1laXAtMTU1OSBhbmQgZWlwLTE1NTkgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBoYXNFaXAxNTU5ID0gKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgIT0gbnVsbCAmJiAocG9wLnR5cGUgPT09IDIgfHwgaGFzRWlwMTU1OSkpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IGdhc1ByaWNlXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwb3AudHlwZSA9PT0gMCB8fCBwb3AudHlwZSA9PT0gMSkgJiYgaGFzRWlwMTU1OSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwicHJlLWVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IG1heEZlZVBlckdhcy9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHBvcC50eXBlID09PSAyIHx8IHBvcC50eXBlID09IG51bGwpICYmIChwb3AubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpKSB7XG4gICAgICAgICAgICAvLyBGdWxseS1mb3JtZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gKHNraXAgZ2V0RmVlRGF0YSlcbiAgICAgICAgICAgIHBvcC50eXBlID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3AudHlwZSA9PT0gMCB8fCBwb3AudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXQgTGVnYWN5IG9yIEVJUC0yOTMwIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgYXNzZXJ0KGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRHYXNQcmljZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZ2FzUHJpY2VcbiAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBvcC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgaWYgKHBvcC50eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGF1dG8tZGV0ZWN0IHRoZSBpbnRlbmRlZCB0eXBlIG9mIHRoaXMgdHJhbnNhY3Rpb24uLi5cbiAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldHdvcmsgc3VwcG9ydHMgRUlQLTE1NTkhXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZ3JhZGUgdHJhbnNhY3Rpb24gZnJvbSBudWxsIHRvIGVpcC0xNTU5XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuYXV0aG9yaXphdGlvbkxpc3QgJiYgcG9wLmF1dGhvcml6YXRpb25MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLnR5cGUgPSA0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgbGVnYWN5IGdhc1ByaWNlIHByb3BlcnR5IG9uIGFuIGVpcC0xNTU5IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB1c2UgZ2FzUHJpY2UgYXMgYm90aCBmZWUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSBwb3AuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcG9wLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9wLm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IHN1cHBvcnQgRUlQLTE1NTkuLi5cbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IHRoZXkgYXJlIHRyeWluZyB0byB1c2UgRUlQLTE1NTkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoIWhhc0VpcDE1NTksIFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVJUC0xNTU5XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AuZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHVudHlwZWQgdHJhbnNhY3Rpb24gdG8gbGVnYWN5XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBNYXliZSB0aGlzIHNob2xkIGFsbG93IHR5cGUgMT9cbiAgICAgICAgICAgICAgICAgICAgcG9wLnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RmVlRGF0YSBoYXMgZmFpbGVkIHVzLlxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiZmFpbGVkIHRvIGdldCBjb25zaXN0ZW50IGZlZSBkYXRhXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuZ2V0RmVlRGF0YVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBvcC50eXBlID09PSAyIHx8IHBvcC50eXBlID09PSAzIHx8IHBvcC50eXBlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2luZyBFSVAtMTU1OSBvciBFSVAtNDg0NFxuICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vQFRPT0Q6IERvbid0IGF3YWl0IGFsbCBvdmVyIHRoZSBwbGFjZTsgc2F2ZSB0aGVtIHVwIGZvclxuICAgICAgICAvLyB0aGUgZW5kIGZvciBiZXR0ZXIgYmF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHBvcCk7XG4gICAgfVxuICAgIGFzeW5jIHBvcHVsYXRlQXV0aG9yaXphdGlvbihfYXV0aCkge1xuICAgICAgICBjb25zdCBhdXRoID0gT2JqZWN0LmFzc2lnbih7fSwgX2F1dGgpO1xuICAgICAgICAvLyBBZGQgYSBjaGFpbiBJRCBpZiBub3QgZXhwbGljaXRseSBzZXQgdG8gMFxuICAgICAgICBpZiAoYXV0aC5jaGFpbklkID09IG51bGwpIHtcbiAgICAgICAgICAgIGF1dGguY2hhaW5JZCA9IChhd2FpdCBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZ2V0TmV0d29ya1wiKS5nZXROZXR3b3JrKCkpLmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IFRha2UgY2hhaW4gSUQgaW50byBhY2NvdW50IHdoZW4gcG9wdWxhdGluZyBub2NlP1xuICAgICAgICBpZiAoYXV0aC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhdXRoLm5vbmNlID0gYXdhaXQgdGhpcy5nZXROb25jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRoO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZUdhcyh0eCkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImVzdGltYXRlR2FzXCIpLmVzdGltYXRlR2FzKGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KSk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGwodHgpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJjYWxsXCIpLmNhbGwoYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwic2VuZFRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBkZWxldGUgcG9wLmZyb207XG4gICAgICAgIGNvbnN0IHR4T2JqID0gVHJhbnNhY3Rpb24uZnJvbShwb3ApO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuYnJvYWRjYXN0VHJhbnNhY3Rpb24oYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHhPYmopKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IGluIHY3IG1vdmUgdGhpcyB0byBiZSBhYnN0cmFjdFxuICAgIGF1dGhvcml6ZShhdXRob3JpemF0aW9uKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJhdXRob3JpemF0aW9uIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBzaWduZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiYXV0aG9yaXplXCIgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlZvaWRTaWduZXIqKiBpcyBhIGNsYXNzIGRlaXNnbmVkIHRvIGFsbG93IGFuIGFkZHJlc3MgdG8gYmUgdXNlZFxuICogIGluIGFueSBBUEkgd2hpY2ggYWNjZXB0cyBhIFNpZ25lciwgYnV0IGZvciB3aGljaCB0aGVyZSBhcmUgbm9cbiAqICBjcmVkZW50aWFscyBhdmFpbGFibGUgdG8gcGVyZm9ybSBhbnkgYWN0dWFsIHNpZ25pbmcuXG4gKlxuICogIFRoaXMgZm9yIGV4YW1wbGUgYWxsb3cgaW1wZXJzb25hdGluZyBhbiBhY2NvdW50IGZvciB0aGUgcHVycG9zZSBvZlxuICogIHN0YXRpYyBjYWxscyBvciBlc3RpbWF0aW5nIGdhcywgYnV0IGRvZXMgbm90IGFsbG93IHNlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICovXG5leHBvcnQgY2xhc3MgVm9pZFNpZ25lciBleHRlbmRzIEFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNpZ25lciBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipWb2lkU2lnbmVyKiogd2l0aCAlJWFkZHJlc3MlJSBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIHRoaXMuYWRkcmVzczsgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWb2lkU2lnbmVyKHRoaXMuYWRkcmVzcywgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAjdGhyb3dVbnN1cHBvcnRlZChzdWZmaXgsIG9wZXJhdGlvbikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIGBWb2lkU2lnbmVyIGNhbm5vdCBzaWduICR7c3VmZml4fWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgdGhpcy4jdGhyb3dVbnN1cHBvcnRlZChcInRyYW5zYWN0aW9uc1wiLCBcInNpZ25UcmFuc2FjdGlvblwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwibWVzc2FnZXNcIiwgXCJzaWduTWVzc2FnZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHlwZWQtZGF0YVwiLCBcInNpZ25UeXBlZERhdGFcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3Qtc2lnbmVyLmpzLm1hcCIsImltcG9ydCB7IGlzRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vKipcbiAqICBTb21lIGJhY2tlbmRzIHN1cHBvcnQgc3Vic2NyaWJpbmcgdG8gZXZlbnRzIHVzaW5nIGEgRmlsdGVyIElELlxuICpcbiAqICBXaGVuIHN1YnNjcmliaW5nIHdpdGggdGhpcyB0ZWNobmlxdWUsIHRoZSBub2RlIGlzc3VlcyBhIHVuaXF1ZVxuICogIC8vRmlsdGVyIElELy8uIEF0IHRoaXMgcG9pbnQgdGhlIG5vZGUgZGVkaWNhdGVzIHJlc291cmNlcyB0b1xuICogIHRoZSBmaWx0ZXIsIHNvIHRoYXQgcGVyaW9kaWMgY2FsbHMgdG8gZm9sbG93IHVwIG9uIHRoZSAvL0ZpbHRlciBJRC8vXG4gKiAgd2lsbCByZWNlaXZlIGFueSBldmVudHMgc2luY2UgdGhlIGxhc3QgY2FsbC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXJJZFByb21pc2U7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAjbmV0d29yaztcbiAgICAjaGF1bHQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiB3aGljaCB3aWxsIHVzZWQgW1tfc3Vic2NyaWJlXV1cbiAgICAgKiAgYW5kIFtbX2VtaXRSZXN1bHRzXV0gdG8gc2V0dXAgdGhlIHN1YnNjcmlwdGlvbiBhbmQgcHJvdmlkZSB0aGUgZXZlbnRcbiAgICAgKiAgdG8gdGhlICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIHRvIGJlZ2luIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHRoZSBldmVudHMuXG4gICAgICovXG4gICAgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIGhhbmRsZSByZWNvdmVyeSBvbiBlcnJvcnMuXG4gICAgICovXG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAodGhpcy4jZmlsdGVySWRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSB0aGlzLl9zdWJzY3JpYmUodGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBGaWx0ZXIgSURcbiAgICAgICAgICAgIGxldCBmaWx0ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZpbHRlcklkID0gYXdhaXQgdGhpcy4jZmlsdGVySWRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiKSB8fCBlcnJvci5vcGVyYXRpb24gIT09IFwiZXRoX25ld0ZpbHRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgRmlsdGVyIElEOyBkb3duZ3JhZGUgdG9cbiAgICAgICAgICAgIC8vIHBvbGxpbmdcbiAgICAgICAgICAgIGlmIChmaWx0ZXJJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5fcmVjb3ZlclN1YnNjcmliZXIodGhpcywgdGhpcy5fcmVjb3Zlcih0aGlzLiNwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI25ldHdvcmspIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrLmNoYWluSWQgIT09IG5ldHdvcmsuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYWlkIGNoYW5nZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIiwgW2ZpbHRlcklkXSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9lbWl0UmVzdWx0cyh0aGlzLiNwcm92aWRlciwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQFRPRE9cIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICAjdGVhcmRvd24oKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcklkUHJvbWlzZSA9IHRoaXMuI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAgICAgaWYgKGZpbHRlcklkUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIGZpbHRlcklkUHJvbWlzZS50aGVuKChmaWx0ZXJJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwcm92aWRlci5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwb2xsKC0yKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNoYXVsdCA9IHRydWU7XG4gICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiN0ZWFyZG93bigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG4vKipcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBjb250cmFjdCBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciBleHRlbmRzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgI2V2ZW50O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmlsdGVySWRFdmVudFN1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSVcbiAgICAgKiAgbGlzdGVuaW5nIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNldmVudCA9IGNvcHkoZmlsdGVyKTtcbiAgICB9XG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHByb3ZpZGVyLCB0aGlzLiNldmVudCk7XG4gICAgfVxuICAgIGFzeW5jIF9zdWJzY3JpYmUocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgZmlsdGVySWQgPSBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld0ZpbHRlclwiLCBbdGhpcy4jZXZlbnRdKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgIH1cbiAgICBhc3luYyBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiNldmVudCwgcHJvdmlkZXIuX3dyYXBMb2cocmVzdWx0LCBwcm92aWRlci5fbmV0d29yaykpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkZpbHRlcklkU3Vic2NyaWJlcioqIGZvciByZWNlaXZpbmcgcGVuZGluZyB0cmFuc2FjdGlvbnMgZXZlbnRzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciBleHRlbmRzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIiwgW10pO1xuICAgIH1cbiAgICBhc3luYyBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdChcInBlbmRpbmdcIiwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZXItZmlsdGVyaWQuanMubWFwIiwiLyoqXG4gKiAgT25lIG9mIHRoZSBtb3N0IGNvbW1vbiB3YXlzIHRvIGludGVyYWN0IHdpdGggdGhlIGJsb2NrY2hhaW4gaXNcbiAqICBieSBhIG5vZGUgcnVubmluZyBhIEpTT04tUlBDIGludGVyZmFjZSB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHRvLFxuICogIGJhc2VkIG9uIHRoZSB0cmFuc3BvcnQsIHVzaW5nOlxuICpcbiAqICAtIEhUVFAgb3IgSFRUUFMgLSBbW0pzb25ScGNQcm92aWRlcl1dXG4gKiAgLSBXZWJTb2NrZXQgLSBbW1dlYlNvY2tldFByb3ZpZGVyXV1cbiAqICAtIElQQyAtIFtbSXBjU29ja2V0UHJvdmlkZXJdXVxuICpcbiAqIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9qc29ucnBjOkpTT04tUlBDIFByb3ZpZGVyICBbYWJvdXQtanNvbnJwY1Byb3ZpZGVyXVxuICovXG4vLyBAVE9ETzpcbi8vIC0gQWRkIHRoZSBiYXRjaGluZyBBUElcbi8vIGh0dHBzOi8vcGxheWdyb3VuZC5vcGVuLXJwYy5vcmcvP3NjaGVtYVVybD1odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZXRoZXJldW0vZXRoMS4wLWFwaXMvYXNzZW1ibGVkLXNwZWMvb3BlbnJwYy5qc29uJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6c3BsaXRWaWV3JTVEPXRydWUmdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTppbnB1dCU1RD1mYWxzZSZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOmV4YW1wbGVzRHJvcGRvd24lNUQ9ZmFsc2VcbmltcG9ydCB7IEFiaUNvZGVyIH0gZnJvbSBcIi4uL2FiaS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWREYXRhRW5jb2RlciB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5LCBhdXRob3JpemF0aW9uaWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGhleGxpZnksIGlzSGV4U3RyaW5nLCB0b1F1YW50aXR5LCB0b1V0ZjhCeXRlcywgaXNFcnJvciwgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBGZXRjaFJlcXVlc3QsIHJlc29sdmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBBYnN0cmFjdFByb3ZpZGVyLCBVbm1hbmFnZWRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IEFic3RyYWN0U2lnbmVyIH0gZnJvbSBcIi4vYWJzdHJhY3Qtc2lnbmVyLmpzXCI7XG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xuaW1wb3J0IHsgRmlsdGVySWRFdmVudFN1YnNjcmliZXIsIEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLWZpbHRlcmlkLmpzXCI7XG5pbXBvcnQgeyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XG5jb25zdCBQcmltaXRpdmUgPSBcImJpZ2ludCxib29sZWFuLGZ1bmN0aW9uLG51bWJlcixzdHJpbmcsc3ltYm9sXCIuc3BsaXQoLywvZyk7XG4vL2NvbnN0IE1ldGhvZHMgPSBcImdldEFkZHJlc3MsdGhlblwiLnNwbGl0KC8sL2cpO1xuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBQcmltaXRpdmUuaW5kZXhPZih0eXBlb2YgKHZhbHVlKSkgPj0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8vIEtlZXAgYW55IEFkZHJlc3NhYmxlXG4gICAgaWYgKHR5cGVvZiAodmFsdWUuZ2V0QWRkcmVzcykgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlLm1hcChkZWVwQ29weSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoKGFjY3VtLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGFjY3VtW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgc2hvdWxkIG5vdCBoYXBwZW46ICR7dmFsdWV9ICgke3R5cGVvZiAodmFsdWUpfSlgKTtcbn1cbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pOyB9KTtcbn1cbmZ1bmN0aW9uIGdldExvd2VyQ2FzZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaXNQb2xsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5wb2xsaW5nSW50ZXJ2YWwpID09PSBcIm51bWJlclwiKTtcbn1cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHBvbGxpbmc6IGZhbHNlLFxuICAgIHN0YXRpY05ldHdvcms6IG51bGwsXG4gICAgYmF0Y2hTdGFsbFRpbWU6IDEwLFxuICAgIGJhdGNoTWF4U2l6ZTogKDEgPDwgMjApLFxuICAgIGJhdGNoTWF4Q291bnQ6IDEwMCxcbiAgICBjYWNoZVRpbWVvdXQ6IDI1MCxcbiAgICBwb2xsaW5nSW50ZXJ2YWw6IDQwMDBcbn07XG4vLyBAVE9ETzogVW5jaGVja2VkIFNpZ25lcnNcbmV4cG9ydCBjbGFzcyBKc29uUnBjU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIGFkZHJlc3M7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFkZHJlc3MgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCByZWNvbm5lY3QgSnNvblJwY1NpZ25lclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmNvbm5lY3RcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzcztcbiAgICB9XG4gICAgLy8gSlNPTi1SUEMgd2lsbCBhdXRvbWF0aWFsbHkgZmlsbCBpbiBub25jZSwgZXRjLiBzbyB3ZSBqdXN0IGNoZWNrIGZyb21cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMganVzdCB0aGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gYWZ0ZXIgc2VudCwgd2hpY2ggaXMgd2hhdFxuICAgIC8vIHRoZSBiYXJlIEpTT04tUlBDIEFQSSBkb2VzO1xuICAgIGFzeW5jIHNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbihfdHgpIHtcbiAgICAgICAgY29uc3QgdHggPSBkZWVwQ29weShfdHgpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZyb20gbWF0Y2hlcyB0aGUgc2VuZGVyXG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBfZnJvbSA9IHR4LmZyb207XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKF9mcm9tLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcm9tICE9IG51bGwgJiYgZnJvbS50b0xvd2VyQ2FzZSgpID09PSB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCBfdHgpO1xuICAgICAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5hZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBKU09OLVJQQyBmb3IgZXRoX3NlbmRUcmFuc2FjdGlvbiB1c2VzIDkwMDAwIGdhczsgaWYgdGhlIHVzZXJcbiAgICAgICAgLy8gd2lzaGVzIHRvIHVzZSB0aGlzLCBpdCBpcyBlYXN5IHRvIHNwZWNpZnkgZXhwbGljaXRseSwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlIGxvb2sgaXQgdXAgZm9yIHRoZW0uXG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHguZ2FzTGltaXQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHsgLi4udHgsIGZyb206IHRoaXMuYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBhZGRyZXNzIG1heSBiZSBhbiBFTlMgbmFtZSBvciBBZGRyZXNzYWJsZVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgX3RvID0gdHgudG87XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHgudG8gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhfdG8sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2FpdCB1bnRpbCBhbGwgb2Ygb3VyIHByb3BlcnRpZXMgYXJlIGZpbGxlZCBpblxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmdldFJwY1RyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgW2hleFR4XSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICAvLyBUaGlzIGNhbm5vdCBiZSBtaW5lZCBhbnkgZWFybGllciB0aGFuIGFueSByZWNlbnQgYmxvY2tcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgIC8vIFNlbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIEpTT04tUlBDIG9ubHkgcHJvdmlkZXMgYW5kIG9wYXF1ZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICAgIC8vIGZvciBhIHJlc3BvbnNlLCBhbmQgd2UgbmVlZCB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uLCBzbyB3ZSBwb2xsXG4gICAgICAgIC8vIGZvciBpdDsgaXQgc2hvdWxkIHNob3cgdXAgdmVyeSBxdWlja2x5XG4gICAgICAgIHJldHVybiBhd2FpdCAobmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dHMgPSBbMTAwMCwgMTAwXTtcbiAgICAgICAgICAgIGxldCBpbnZhbGlkcyA9IDA7XG4gICAgICAgICAgICBjb25zdCBjaGVja1R4ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHR4LnJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oYmxvY2tOdW1iZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBjYW5jZWxsZWQ6IHN0b3AgcG9sbGluZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRhdGEgaXMgYmFkOiB0aGUgbm9kZSByZXR1cm5zIGJhZCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5ldHdvcmsgY2hhbmdlZDogY2FsbGluZyBhZ2FpbiB3aWxsIGFsc28gZmFpbFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB1bnN1cHBvcnRlZDogbGlrZWx5IGRlc3Ryb3llZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQU5DRUxMRURcIikgfHwgaXNFcnJvcihlcnJvciwgXCJCQURfREFUQVwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFcnJvcihlcnJvciwgXCJORVRXT1JLX0VSUk9SXCIpIHx8IGlzRXJyb3IoZXJyb3IsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuaW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuaW5mbyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuaW5mby5zZW5kVHJhbnNhY3Rpb25IYXNoID0gaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcC1nYXAgZm9yIG1pc2JlaGF2aW5nIGJhY2tlbmRzOyBzZWUgIzQ1MTNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZHMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5pbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvLnNlbmRUcmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludmFsaWRzID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RpZnkgYW55b25lIHRoYXQgY2FyZXM7IGJ1dCB3ZSB3aWxsIHRyeSBhZ2Fpbiwgc2luY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgbGlrZWx5IGFuIGludGVybWl0dGVudCBzZXJ2aWNlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuZW1pdChcImVycm9yXCIsIG1ha2VFcnJvcihcImZhaWxlZCB0byBmZXRjaCB0cmFuc2F0aW9uIGFmdGVyIHNlbmRpbmcgKHdpbGwgdHJ5IGFnYWluKVwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBlcnJvciB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdhaXQgYW5vdGhlciA0IHNlY29uZHNcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLl9zZXRUaW1lb3V0KCgpID0+IHsgY2hlY2tUeCgpOyB9LCB0aW1lb3V0cy5wb3AoKSB8fCA0MDAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja1R4KCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKF90eCkge1xuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0eC5mcm9tLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICB0eC5mcm9tID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmdldFJwY1RyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHJhbnNhY3Rpb25cIiwgW2hleFR4XSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKF9tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoKHR5cGVvZiAoX21lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IHRvVXRmOEJ5dGVzKF9tZXNzYWdlKSA6IF9tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3NpZ25cIiwgW1xuICAgICAgICAgICAgaGV4bGlmeShtZXNzYWdlKSwgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKClcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGVlcENvcHkoX3ZhbHVlKTtcbiAgICAgICAgLy8gUG9wdWxhdGUgYW55IEVOUyBuYW1lcyAoaW4tcGxhY2UpXG4gICAgICAgIGNvbnN0IHBvcHVsYXRlZCA9IGF3YWl0IFR5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzICE9IG51bGwsIFwiVHlwZWREYXRhIGRvZXMgbm90IHN1cHBvcnQgbnVsbCBhZGRyZXNzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShUeXBlZERhdGFFbmNvZGVyLmdldFBheWxvYWQocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyB1bmxvY2socGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3VubG9ja0FjY291bnRcIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0pTT04tUlBDI2V0aF9zaWduXG4gICAgYXN5bmMgX2xlZ2FjeVNpZ25NZXNzYWdlKF9tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoKHR5cGVvZiAoX21lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IHRvVXRmOEJ5dGVzKF9tZXNzYWdlKSA6IF9tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBoZXhsaWZ5KG1lc3NhZ2UpXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbi8qKlxuICogIFRoZSBKc29uUnBjQXBpUHJvdmlkZXIgaXMgYW4gYWJzdHJhY3QgY2xhc3MgYW5kICoqTVVTVCoqIGJlXG4gKiAgc3ViLWNsYXNzZWQuXG4gKlxuICogIEl0IHByb3ZpZGVzIHRoZSBiYXNlIGZvciBhbGwgSlNPTi1SUEMtYmFzZWQgUHJvdmlkZXIgaW50ZXJhY3Rpb24uXG4gKlxuICogIFN1Yi1jbGFzc2luZyBOb3RlczpcbiAqICAtIGEgc3ViLWNsYXNzIE1VU1Qgb3ZlcnJpZGUgX3NlbmRcbiAqICAtIGEgc3ViLWNsYXNzIE1VU1QgY2FsbCB0aGUgYF9zdGFydCgpYCBtZXRob2Qgb25jZSBjb25uZWN0ZWRcbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNBcGlQcm92aWRlciBleHRlbmRzIEFic3RyYWN0UHJvdmlkZXIge1xuICAgICNvcHRpb25zO1xuICAgIC8vIFRoZSBuZXh0IElEIHRvIHVzZSBmb3IgdGhlIEpTT04tUlBDIElEIGZpZWxkXG4gICAgI25leHRJZDtcbiAgICAvLyBQYXlsb2FkcyBhcmUgcXVldWVkIGFuZCB0cmlnZ2VyZWQgaW4gYmF0Y2hlcyB1c2luZyB0aGUgZHJhaW5UaW1lclxuICAgICNwYXlsb2FkcztcbiAgICAjZHJhaW5UaW1lcjtcbiAgICAjbm90UmVhZHk7XG4gICAgI25ldHdvcms7XG4gICAgI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgICNzY2hlZHVsZURyYWluKCkge1xuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCB1c2luZyBiYXRjaGluZywgbm8gaGFybSBpbiBzZW5kaW5nIGl0IGltbWVkaWF0ZWx5XG4gICAgICAgIGNvbnN0IHN0YWxsVGltZSA9ICh0aGlzLl9nZXRPcHRpb24oXCJiYXRjaE1heENvdW50XCIpID09PSAxKSA/IDAgOiB0aGlzLl9nZXRPcHRpb24oXCJiYXRjaFN0YWxsVGltZVwiKTtcbiAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHRoaXMuI3BheWxvYWRzO1xuICAgICAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChwYXlsb2Fkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgcGF5bG9hZCBiYXRjaGVzIHRoYXQgc2F0aXNmeSBvdXIgYmF0Y2ggY29uc3RyYWludHNcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IFsocGF5bG9hZHMuc2hpZnQoKSldO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXlsb2Fkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA9PT0gdGhpcy4jb3B0aW9ucy5iYXRjaE1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiYXRjaC5wdXNoKChwYXlsb2Fkcy5zaGlmdCgpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gSlNPTi5zdHJpbmdpZnkoYmF0Y2gubWFwKChwKSA9PiBwLnBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHRoaXMuI29wdGlvbnMuYmF0Y2hNYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2Fkcy51bnNoaWZ0KChiYXRjaC5wb3AoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgcmVzdWx0IHRvIGVhY2ggcGF5bG9hZFxuICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSAoKGJhdGNoLmxlbmd0aCA9PT0gMSkgPyBiYXRjaFswXS5wYXlsb2FkIDogYmF0Y2gubWFwKChwKSA9PiBwLnBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJwY1BheWxvYWRcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3NlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjUmVzdWx0XCIsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgcmVzdWx0cyBpbiBiYXRjaCBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlc29sdmUsIHJlamVjdCwgcGF5bG9hZCB9IG9mIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtYXRjaGluZyByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gcmVzdWx0LmZpbHRlcigocikgPT4gKHIuaWQgPT09IHBheWxvYWQuaWQpKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyByZXN1bHQ7IHRoZSBub2RlIGZhaWxlZCB1cyBpbiB1bmV4cGVjdGVkIHdheXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbWFrZUVycm9yKFwibWlzc2luZyByZXNwb25zZSBmb3IgcmVxdWVzdFwiLCBcIkJBRF9EQVRBXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQsIGluZm86IHsgcGF5bG9hZCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVzcG9uc2UgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIHJlc3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgcmVzcCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGdvb2Q7IHNlbmQgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlamVjdCB9IG9mIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IGF1Z21lbnQgdGhlIGVycm9yIHdpdGggdGhlIHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RhbGxUaW1lKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy4jbmV4dElkID0gMTtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcbiAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuI25ldHdvcmsgPSBudWxsO1xuICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gX3Jlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuI25vdFJlYWR5ID0geyBwcm9taXNlLCByZXNvbHZlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGljTmV0d29yayA9IHRoaXMuX2dldE9wdGlvbihcInN0YXRpY05ldHdvcmtcIik7XG4gICAgICAgIGlmICh0eXBlb2YgKHN0YXRpY05ldHdvcmspID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXN0YXRpY05ldHdvcmsgfHwgbmV0d29yayAhPT0gXCJhbnlcIiwgXCJzdGF0aWNOZXR3b3JrIGNhbm5vdCBiZSB1c2VkIG9uIHNwZWNpYWwgbmV0d29yayAnYW55J1wiLCBcIm9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3RhdGljTmV0d29yayAmJiBuZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gTmV0d29yay5mcm9tKG5ldHdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRpY05ldHdvcmspIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbnkgc3RhdGljIG5ldHdvcmsgaXMgY29tcGF0YmlsZSB3aXRoIHRoZSBwcm92aWRlZCBuZXR3cm9rXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChuZXR3b3JrID09IG51bGwgfHwgc3RhdGljTmV0d29yay5tYXRjaGVzKG5ldHdvcmspLCBcInN0YXRpY05ldHdvcmsgTVVTVCBtYXRjaCBuZXR3b3JrIG9iamVjdFwiLCBcIm9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gc3RhdGljTmV0d29yaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBvcHRpb24gJSVrZXklJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBjYW4gdXNlIHRoaXMgdG8gaW5xdWlyZSBhYm91dCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgX2dldE9wdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnNba2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldHMgdGhlIFtbTmV0d29ya11dIHRoaXMgcHJvdmlkZXIgaGFzIGNvbW1pdHRlZCB0by4gT24gZWFjaCBjYWxsLCB0aGUgbmV0d29ya1xuICAgICAqICBpcyBkZXRlY3RlZCwgYW5kIGlmIGl0IGhhcyBjaGFuZ2VkLCB0aGUgY2FsbCB3aWxsIHJlamVjdC5cbiAgICAgKi9cbiAgICBnZXQgX25ldHdvcmsoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLiNuZXR3b3JrLCBcIm5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZSB5ZXRcIiwgXCJORVRXT1JLX0VSUk9SXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBub24tbm9ybWFsaXplZCB2YWx1ZSBieSBwZXJmb3JtaW5nICUlcmVxJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IGJlaGF2aW9yIG9mIGFjdGlvbnMsXG4gICAgICogIGFuZCBzaG91bGQgZ2VuZXJhbGx5IGNhbGwgYGBzdXBlci5fcGVyZm9ybWBgIGFzIGEgZmFsbGJhY2suXG4gICAgICovXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIC8vIExlZ2FjeSBuZXR3b3JrcyBkbyBub3QgbGlrZSB0aGUgdHlwZSBmaWVsZCBiZWluZyBwYXNzZWQgYWxvbmcgKHdoaWNoXG4gICAgICAgIC8vIGlzIGZhaXIpLCBzbyB3ZSBkZWxldGUgdHlwZSBpZiBpdCBpcyAwIGFuZCBhIG5vbi1FSVAtMTU1OSBuZXR3b3JrXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImNhbGxcIiB8fCByZXEubWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgIGxldCB0eCA9IHJlcS50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGlmICh0eCAmJiB0eC50eXBlICE9IG51bGwgJiYgZ2V0QmlnSW50KHR4LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIEVJUC0xNTU5IG9yIG5ld2VyIHByb3BlcnRpZXMsIGl0IG1pZ2h0IGJlIHByZS1FSVAtMTU1OVxuICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCB0aGlzLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzID09IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qga25vdyBhYm91dCBFSVAtMTU1OSAoYW5kIGhlbmNlIHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBPYmplY3QuYXNzaWduKHt9LCByZXEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgsIHsgdHlwZTogdW5kZWZpbmVkIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5nZXRScGNSZXF1ZXN0KHJlcSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9wZXJmb3JtKHJlcSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpczsgaXQgZGV0ZWN0cyB0aGUgKmFjdHVhbCogbmV0d29yayB0aGF0XG4gICAgICogIHdlIGFyZSAqKmN1cnJlbnRseSoqIGNvbm5lY3RlZCB0by5cbiAgICAgKlxuICAgICAqICBLZWVwIGluIG1pbmQgdGhhdCBbW3NlbmRdXSBtYXkgb25seSBiZSB1c2VkIG9uY2UgW1tyZWFkeV1dLCBvdGhlcndpc2UgdGhlXG4gICAgICogIF9zZW5kIHByaW1pdGl2ZSBtdXN0IGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBfZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IHRoaXMuX2dldE9wdGlvbihcInN0YXRpY05ldHdvcmtcIik7XG4gICAgICAgIGlmIChuZXR3b3JrKSB7XG4gICAgICAgICAgICBpZiAobmV0d29yayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZSByZWFkeSwgdXNlIGBgc2VuZGBgLCB3aGljaCBlbmFibGVkIHJlcXVlc3RzIHRvIGJlIGJhdGNoZWRcbiAgICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBOZXR3b3JrLmZyb20oZ2V0QmlnSW50KGF3YWl0IHRoaXMuc2VuZChcImV0aF9jaGFpbklkXCIsIFtdKSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYXJlIG5vdCByZWFkeSB5ZXQ7IHVzZSB0aGUgcHJpbWl0aXZlIF9zZW5kXG4gICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuI25leHRJZCsrLCBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIiwgcGFyYW1zOiBbXSwganNvbnJwYzogXCIyLjBcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRScGNQYXlsb2FkXCIsIHBheWxvYWQgfSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAoYXdhaXQgdGhpcy5fc2VuZChwYXlsb2FkKSlbMF07XG4gICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgaWYgKFwicmVzdWx0XCIgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5ldHdvcmsuZnJvbShnZXRCaWdJbnQocmVzdWx0LnJlc3VsdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCByZXN1bHQpO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKk1VU1QqKiBjYWxsIHRoaXMuIFVudGlsIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjYWxsc1xuICAgICAqICB3aWxsIGJlIHBhc3NlZCB0byBbW19zZW5kXV0gZnJvbSBbW3NlbmRdXS4gSWYgaXQgaXMgb3ZlcnJpZGRlbiwgdGhlblxuICAgICAqICBgYHN1cGVyLl9zdGFydCgpYGAgKipNVVNUKiogYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogIENhbGxpbmcgaXQgbXVsdGlwbGUgdGltZXMgaXMgc2FmZSBhbmQgaGFzIG5vIGVmZmVjdC5cbiAgICAgKi9cbiAgICBfc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNub3RSZWFkeSA9PSBudWxsIHx8IHRoaXMuI25vdFJlYWR5LnJlc29sdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI25vdFJlYWR5LnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy4jbm90UmVhZHkgPSBudWxsO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQm9vdHN0cmFwIHRoZSBuZXR3b3JrXG4gICAgICAgICAgICB3aGlsZSAodGhpcy4jbmV0d29yayA9PSBudWxsICYmICF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBhd2FpdCB0aGlzLl9kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSnNvblJwY1Byb3ZpZGVyIGZhaWxlZCB0byBkZXRlY3QgbmV0d29yayBhbmQgY2Fubm90IHN0YXJ0IHVwOyByZXRyeSBpbiAxcyAocGVyaGFwcyB0aGUgVVJMIGlzIHdyb25nIG9yIHRoZSBub2RlIGlzIG5vdCBzdGFydGVkKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbWFrZUVycm9yKFwiZmFpbGVkIHRvIGJvb3RzdHJhcCBuZXR3b3JrIGRldGVjdGlvblwiLCBcIk5FVFdPUktfRVJST1JcIiwgeyBldmVudDogXCJpbml0aWFsLW5ldHdvcmstZGlzY292ZXJ5XCIsIGluZm86IHsgZXJyb3IgfSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGRpc3BhdGNoaW5nIHJlcXVlc3RzXG4gICAgICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoZSBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZC4gVGhpcyBjYW4gYmUgdXNlZCBpblxuICAgICAqICBzdWItY2xhc3NlcyB0byBkZWZlciBzZW5kaW5nIGRhdGEgdW50aWwgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW5cbiAgICAgKiAgZXN0YWJsaXNoZWQuXG4gICAgICovXG4gICAgYXN5bmMgX3dhaXRVbnRpbFJlYWR5KCkge1xuICAgICAgICBpZiAodGhpcy4jbm90UmVhZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNub3RSZWFkeS5wcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgU3Vic2NyaWJlciB0aGF0IHdpbGwgbWFuYWdlIHRoZSAlJXN1YiUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIG1vZGlmeSB0aGUgYmVoYXZpb3Igb2ZcbiAgICAgKiAgc3Vic2NyaXB0aW9uIG1hbmFnZW1lbnQuXG4gICAgICovXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIC8vIFBlbmRpbmcgRmlsdGVycyBhcmVuJ3QgYXZhaWxibGUgdmlhIHBvbGxpbmdcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJldmVudFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0T3B0aW9uKFwicG9sbGluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0V2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlsdGVySWRFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3JwaGFuZWQgTG9ncyBhcmUgaGFuZGxlZCBhdXRvbWF0aWNhbGx5LCBieSB0aGUgZmlsdGVyLCBzaW5jZVxuICAgICAgICAvLyBsb2dzIHdpdGggcmVtb3ZlZCBhcmUgZW1pdHRlZCBieSBpdFxuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwib3JwaGFuXCIgJiYgc3ViLmZpbHRlci5vcnBoYW4gPT09IFwiZHJvcC1sb2dcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyKFwib3JwaGFuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0U3Vic2NyaWJlcihzdWIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLlxuICAgICAqL1xuICAgIGdldCByZWFkeSgpIHsgcmV0dXJuIHRoaXMuI25vdFJlYWR5ID09IG51bGw7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyAlJXR4JSUgYXMgYSBub3JtYWxpemVkIEpTT04tUlBDIHRyYW5zYWN0aW9uIHJlcXVlc3QsXG4gICAgICogIHdoaWNoIGhhcyBhbGwgdmFsdWVzIGhleGxpZmllZCBhbmQgYW55IG51bWVyaWMgdmFsdWVzIGNvbnZlcnRlZFxuICAgICAqICB0byBRdWFudGl0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0UnBjVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIEpTT04tUlBDIG5vdyByZXF1aXJlcyBudW1lcmljIHZhbHVlcyB0byBiZSBcInF1YW50aXR5XCIgdmFsdWVzXG4gICAgICAgIFtcImNoYWluSWRcIiwgXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwidHlwZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZHN0S2V5ID0ga2V5O1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJnYXNMaW1pdFwiKSB7XG4gICAgICAgICAgICAgICAgZHN0S2V5ID0gXCJnYXNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtkc3RLZXldID0gdG9RdWFudGl0eShnZXRCaWdJbnQodHhba2V5XSwgYHR4LiR7a2V5fWApKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhZGRyZXNzZXMgYW5kIGRhdGEgYXJlIGxvd2VyY2FzZVxuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIiwgXCJkYXRhXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gaGV4bGlmeSh0eFtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgYWNjZXNzIGxpc3Qgb2JqZWN0XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICByZXN1bHRbXCJhY2Nlc3NMaXN0XCJdID0gYWNjZXNzTGlzdGlmeSh0eC5hY2Nlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYmxvYlZlcnNpb25lZEhhc2hlcykge1xuICAgICAgICAgICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIDxhbnk+IGNhc2Ugb25jZSBFSVAtNDg0NCBhZGRlZCB0byBwcmVwYXJlZCB0eFxuICAgICAgICAgICAgcmVzdWx0W1wiYmxvYlZlcnNpb25lZEhhc2hlc1wiXSA9IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMubWFwKGggPT4gaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtcImF1dGhvcml6YXRpb25MaXN0XCJdID0gdHguYXV0aG9yaXphdGlvbkxpc3QubWFwKChfYSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBhdXRob3JpemF0aW9uaWZ5KF9hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlOiB0b1F1YW50aXR5KGEubm9uY2UpLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0b1F1YW50aXR5KGEuY2hhaW5JZCksXG4gICAgICAgICAgICAgICAgICAgIHlQYXJpdHk6IHRvUXVhbnRpdHkoYS5zaWduYXR1cmUueVBhcml0eSksXG4gICAgICAgICAgICAgICAgICAgIHI6IHRvUXVhbnRpdHkoYS5zaWduYXR1cmUuciksXG4gICAgICAgICAgICAgICAgICAgIHM6IHRvUXVhbnRpdHkoYS5zaWduYXR1cmUucyksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBibG9icyBzaG91bGQgcHJvYmFibHkgYWxzbyBiZSBjb3BpZWQgb3Zlciwgb3B0aW9uYWxseVxuICAgICAgICAvLyBhY2NvdW50aW5nIGZvciB0aGUga3pnIHByb3BlcnR5IHRvIGJhY2tmaWxsIGJsb2JWZXJzaW9uZWRIYXNoZXNcbiAgICAgICAgLy8gdXNpbmcgdGhlIGNvbW1pdG1lbnQuIE9yIHNob3VsZCB0aGF0IGJlIGxlZnQgYXMgYW4gZXhlcmNpc2UgdG9cbiAgICAgICAgLy8gdGhlIGNhbGxlcj9cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHJlcXVlc3QgbWV0aG9kIGFuZCBhcmd1bWVudHMgcmVxdWlyZWQgdG8gcGVyZm9ybVxuICAgICAqICAlJXJlcSUlLlxuICAgICAqL1xuICAgIGdldFJwY1JlcXVlc3QocmVxKSB7XG4gICAgICAgIHN3aXRjaCAocmVxLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcImNoYWluSWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfYmxvY2tOdW1iZXJcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfZ2FzUHJpY2VcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRQcmlvcml0eUZlZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRTdG9yYWdlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIjB4XCIgKyByZXEucG9zaXRpb24udG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuc2lnbmVkVHJhbnNhY3Rpb25dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuYmxvY2tUYWcsICEhcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiYmxvY2tIYXNoXCIgaW4gcmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJsb2NrQnlIYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmJsb2NrSGFzaCwgISFyZXEuaW5jbHVkZVRyYW5zYWN0aW9uc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuaGFzaF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuaGFzaF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2NhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3RoaXMuZ2V0UnBjVHJhbnNhY3Rpb24ocmVxLnRyYW5zYWN0aW9uKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZXN0aW1hdGVHYXNcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3RoaXMuZ2V0UnBjVHJhbnNhY3Rpb24ocmVxLnRyYW5zYWN0aW9uKV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVxLmZpbHRlciAmJiByZXEuZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEuZmlsdGVyLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuZmlsdGVyLmFkZHJlc3MgPSByZXEuZmlsdGVyLmFkZHJlc3MubWFwKGdldExvd2VyQ2FzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuZmlsdGVyLmFkZHJlc3MgPSBnZXRMb3dlckNhc2UocmVxLmZpbHRlci5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2dldExvZ3NcIiwgYXJnczogW3JlcS5maWx0ZXJdIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFuIGV0aGVycy1zdHlsZSBFcnJvciBmb3IgdGhlIGdpdmVuIEpTT04tUlBDIGVycm9yXG4gICAgICogICUlcGF5bG9hZCUlLCBjb2FsZXNjaW5nIHRoZSB2YXJpb3VzIHN0cmluZ3MgYW5kIGVycm9yIHNoYXBlc1xuICAgICAqICB0aGF0IGRpZmZlcmVudCBub2RlcyByZXR1cm4sIGNvZXJjaW5nIHRoZW0gaW50byBhIG1hY2hpbmUtcmVhZGFibGVcbiAgICAgKiAgc3RhbmRhcmRpemVkIGVycm9yLlxuICAgICAqL1xuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIF9lcnJvcikge1xuICAgICAgICBjb25zdCB7IG1ldGhvZCB9ID0gcGF5bG9hZDtcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gX2Vycm9yO1xuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9lc3RpbWF0ZUdhc1wiICYmIGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIW1zZy5tYXRjaCgvcmV2ZXJ0L2kpICYmIG1zZy5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImluc3VmZmljaWVudCBmdW5kc1wiLCBcIklOU1VGRklDSUVOVF9GVU5EU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAocGF5bG9hZC5wYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1zZy5tYXRjaCgvbm9uY2UvaSkgJiYgbXNnLm1hdGNoKC90b28gbG93L2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBcIk5PTkNFX0VYUElSRURcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogKHBheWxvYWQucGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfY2FsbFwiIHx8IG1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVua0RhdGEoZXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgZSA9IEFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKChtZXRob2QgPT09IFwiZXRoX2NhbGxcIikgPyBcImNhbGxcIiA6IFwiZXN0aW1hdGVHYXNcIiwgKHBheWxvYWQucGFyYW1zWzBdKSwgKHJlc3VsdCA/IHJlc3VsdC5kYXRhIDogbnVsbCkpO1xuICAgICAgICAgICAgZS5pbmZvID0geyBlcnJvciwgcGF5bG9hZCB9O1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBlc3RpbWF0ZUdhcyBhbmQgY2FsbCBjYW4gcmV0dXJuIGFyYml0cmFyeSBjb250cmFjdC1kZWZpbmVkIHRleHQsIHNvIG5vdyB3ZVxuICAgICAgICAvLyB3ZSBjYW4gcHJvY2VzcyB0ZXh0IHNhZmVseS5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHNwZWx1bmtNZXNzYWdlKGVycm9yKSk7XG4gICAgICAgIGlmICh0eXBlb2YgKGVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkfGV0aGVycy11c2VyLWRlbmllZC9pKSkge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uTWFwID0ge1xuICAgICAgICAgICAgICAgIGV0aF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgcGVyc29uYWxfc2lnbjogXCJzaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3Y0OiBcInNpZ25UeXBlZERhdGFcIixcbiAgICAgICAgICAgICAgICBldGhfc2lnblRyYW5zYWN0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGV0aF9zZW5kVHJhbnNhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXRoX3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgd2FsbGV0X3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihgdXNlciByZWplY3RlZCBhY3Rpb25gLCBcIkFDVElPTl9SRUpFQ1RFRFwiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoYWN0aW9uTWFwW21ldGhvZF0gfHwgXCJ1bmtub3duXCIpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogXCJyZWplY3RlZFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIgfHwgbWV0aG9kID09PSBcImV0aF9zZW5kVHJhbnNhY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAocGF5bG9hZC5wYXJhbXNbMF0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kc3xiYXNlIGZlZSBleGNlZWRzIGdhcyBsaW1pdC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL25vbmNlL2kpICYmIG1lc3NhZ2UubWF0Y2goL3RvbyBsb3cvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIFwiTk9OQ0VfRVhQSVJFRFwiLCB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9yZXBsYWNlbWVudCB0cmFuc2FjdGlvbi9pKSAmJiBtZXNzYWdlLm1hdGNoKC91bmRlcnByaWNlZC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9vbmx5IHJlcGxheS1wcm90ZWN0ZWQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibGVnYWN5IHByZS1laXAtMTU1IHRyYW5zYWN0aW9ucyBub3Qgc3VwcG9ydGVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBtZXRob2QsIGluZm86IHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVuc3VwcG9ydGVkID0gISFtZXNzYWdlLm1hdGNoKC90aGUgbWV0aG9kIC4qIGRvZXMgbm90IGV4aXN0L2kpO1xuICAgICAgICBpZiAoIXVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuZGV0YWlscyAmJiBlcnJvci5kZXRhaWxzLnN0YXJ0c1dpdGgoXCJVbmF1dGhvcml6ZWQgbWV0aG9kOlwiKSkge1xuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJ1bnN1cHBvcnRlZCBvcGVyYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QsIGluZm86IHsgZXJyb3IsIHBheWxvYWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImNvdWxkIG5vdCBjb2FsZXNjZSBlcnJvclwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBlcnJvciwgcGF5bG9hZCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlcXVlc3RzIHRoZSAlJW1ldGhvZCUlIHdpdGggJSVwYXJhbXMlJSB2aWEgdGhlIEpTT04tUlBDIHByb3RvY29sXG4gICAgICogIG92ZXIgdGhlIHVuZGVybHlpbmcgY2hhbm5lbC4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYWxsIG1ldGhvZHNcbiAgICAgKiAgb24gdGhlIGJhY2tlbmQgdGhhdCBkbyBub3QgaGF2ZSBhIGhpZ2gtbGV2ZWwgQVBJIHdpdGhpbiB0aGUgUHJvdmlkZXJcbiAgICAgKiAgQVBJLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIHF1ZXVlcyByZXF1ZXN0cyBhY2NvcmRpbmcgdG8gdGhlIGJhdGNoIGNvbnN0cmFpbnRzXG4gICAgICogIGluIHRoZSBvcHRpb25zLCBhc3NpZ25zIHRoZSByZXF1ZXN0IGEgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogICoqRG8gTk9UIG92ZXJyaWRlKiogdGhpcyBtZXRob2QgaW4gc3ViLWNsYXNzZXM7IGluc3RlYWRcbiAgICAgKiAgb3ZlcnJpZGUgW1tfc2VuZF1dIG9yIGZvcmNlIHRoZSBvcHRpb25zIHZhbHVlcyBpbiB0aGVcbiAgICAgKiAgY2FsbCB0byB0aGUgY29uc3RydWN0b3IgdG8gbW9kaWZ5IHRoaXMgbWV0aG9kJ3MgYmVoYXZpb3IuXG4gICAgICovXG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICAvLyBAVE9ETzogY2FjaGUgY2hhaW5JZD8/IHB1cmdlIG9uIHN3aXRjaF9uZXR3b3Jrc1xuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gZGVzdHJveWVkOyBubyBvcGVyYXRpb25zIGFyZSBzdXBwb3J0ZWQgYW55bW9yZVxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChtYWtlRXJyb3IoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy4jbmV4dElkKys7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNwYXlsb2Fkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZXNvbHZlLCByZWplY3QsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogeyBtZXRob2QsIHBhcmFtcywgaWQsIGpzb25ycGM6IFwiMi4wXCIgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3QgYSBwZW5kaW5nIGRyYWluVGltZXIsIHNldCBvbmVcbiAgICAgICAgdGhpcy4jc2NoZWR1bGVEcmFpbigpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBbW1NpZ25lcl1dIGFjY291bnQgZm9yICAlJWFkZHJlc3MlJSBtYW5hZ2VkIGJ5XG4gICAgICogIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUlYWRkcmVzcyUlIGlzIGEgbnVtYmVyLCBpdCBpcyB1c2VkIGFzIGFuIGluZGV4IGluIHRoZVxuICAgICAqICB0aGUgYWNjb3VudHMgZnJvbSBbW2xpc3RBY2NvdW50c11dLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCBvbiBjbGllbnRzIHdoaWNoIG1hbmFnZSBhY2NvdW50cyAoc3VjaCBhc1xuICAgICAqICBHZXRoIHdpdGggaW1wb3J0ZWQgYWNjb3VudCBvciBNZXRhTWFzaykuXG4gICAgICpcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSBhY2NvdW50IGRvZXNuJ3QgZXhpc3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2lnbmVyKGFkZHJlc3MpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNjb3VudHNQcm9taXNlID0gdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKTtcbiAgICAgICAgLy8gQWNjb3VudCBpbmRleFxuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSAoYXdhaXQgYWNjb3VudHNQcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzID49IGFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHN1Y2ggYWNjb3VudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhY2NvdW50c1thZGRyZXNzXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhY2NvdW50cyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBhY2NvdW50czogYWNjb3VudHNQcm9taXNlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBY2NvdW50IGFkZHJlc3NcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiBhY2NvdW50cykge1xuICAgICAgICAgICAgaWYgKGdldEFkZHJlc3MoYWNjb3VudCkgPT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhY2NvdW50XCIpO1xuICAgIH1cbiAgICBhc3luYyBsaXN0QWNjb3VudHMoKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRzLm1hcCgoYSkgPT4gbmV3IEpzb25ScGNTaWduZXIodGhpcywgYSkpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBTdG9wIHByb2Nlc3NpbmcgcmVxdWVzdHNcbiAgICAgICAgaWYgKHRoaXMuI2RyYWluVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNkcmFpblRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyByZXF1ZXN0c1xuICAgICAgICBmb3IgKGNvbnN0IHsgcGF5bG9hZCwgcmVqZWN0IH0gb2YgdGhpcy4jcGF5bG9hZHMpIHtcbiAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcbiAgICAgICAgLy8gUGFyZW50IGNsZWFuLXVwXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vLyBAVE9ETzogcmVtb3ZlIHRoaXMgaW4gdjcsIGl0IGlzIG5vdCBleHBvcnRlZCBiZWNhdXNlIHRoaXMgZnVuY3Rpb25hbGl0eVxuLy8gaXMgZXhwb3NlZCBpbiB0aGUgSnNvblJwY0FwaVByb3ZpZGVyIGJ5IHNldHRpbmcgcG9sbGluZyB0byB0cnVlLiBJdCBzaG91bGRcbi8vIGJlIHNhZmUgdG8gcmVtb3ZlIHJlZ2FyZGxlc3MsIGJlY2F1c2UgaXQgaXNuJ3QgcmVhY2hhYmxlLCBidXQganVzdCBpbiBjYXNlLlxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVByb3ZpZGVyIHtcbiAgICAjcG9sbGluZ0ludGVydmFsO1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIGxldCBwb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLl9nZXRPcHRpb24oXCJwb2xsaW5nSW50ZXJ2YWxcIik7XG4gICAgICAgIGlmIChwb2xsaW5nSW50ZXJ2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9sbGluZ0ludGVydmFsID0gZGVmYXVsdE9wdGlvbnMucG9sbGluZ0ludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxpbmdJbnRlcnZhbCA9IHBvbGxpbmdJbnRlcnZhbDtcbiAgICB9XG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSBzdXBlci5fZ2V0U3Vic2NyaWJlcihzdWIpO1xuICAgICAgICBpZiAoaXNQb2xsYWJsZShzdWJzY3JpYmVyKSkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcG9sbGluZyBpbnRlcnZhbCAoZGVmYXVsdDogNDAwMCBtcylcbiAgICAgKi9cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jcG9sbGluZ0ludGVydmFsOyB9XG4gICAgc2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnRlcnZhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsaW5nSW50ZXJ2YWwgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHN1YikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUG9sbGFibGUoc3ViKSkge1xuICAgICAgICAgICAgICAgIHN1Yi5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIFRoZSBKc29uUnBjUHJvdmlkZXIgaXMgb25lIG9mIHRoZSBtb3N0IGNvbW1vbiBQcm92aWRlcnMsXG4gKiAgd2hpY2ggcGVyZm9ybXMgYWxsIG9wZXJhdGlvbnMgb3ZlciBIVFRQIChvciBIVFRQUykgcmVxdWVzdHMuXG4gKlxuICogIEV2ZW50cyBhcmUgcHJvY2Vzc2VkIGJ5IHBvbGxpbmcgdGhlIGJhY2tlbmQgZm9yIHRoZSBjdXJyZW50IGJsb2NrXG4gKiAgbnVtYmVyOyB3aGVuIGl0IGFkdmFuY2VzLCBhbGwgYmxvY2stYmFzZSBldmVudHMgYXJlIHRoZW4gY2hlY2tlZFxuICogIGZvciB1cGRhdGVzLlxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB7XG4gICAgI2Nvbm5lY3Q7XG4gICAgY29uc3RydWN0b3IodXJsLCBuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdXJsID0gXCJodHRwOi9cXC9sb2NhbGhvc3Q6ODU0NVwiO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICBpZiAodHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gbmV3IEZldGNoUmVxdWVzdCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IHVybC5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY29ubmVjdC5jbG9uZSgpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEFsbCByZXF1ZXN0cyBhcmUgb3ZlciBIVFRQLCBzbyB3ZSBjYW4ganVzdCBzdGFydCBoYW5kbGluZyByZXF1ZXN0c1xuICAgICAgICAvLyBXZSBkbyB0aGlzIGhlcmUgcmF0aGVyIHRoYW4gdGhlIGNvbnN0cnVjdG9yIHNvIHRoYXQgd2UgZG9uJ3Qgc2VuZCBhbnlcbiAgICAgICAgLy8gcmVxdWVzdHMgdG8gdGhlIG5ldHdvcmsgKGkuZS4gZXRoX2NoYWluSWQpIHVudGlsIHdlIGFic29sdXRlbHkgaGF2ZSB0by5cbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBhIFBPU1QgY29ubmVjdGlvbiBmb3IgdGhlIHJlcXVlc3RlZCBtZXRob2RcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX2dldENvbm5lY3Rpb24oKTtcbiAgICAgICAgcmVxdWVzdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgcmVzcG9uc2UuYXNzZXJ0T2soKTtcbiAgICAgICAgbGV0IHJlc3AgPSByZXNwb25zZS5ib2R5SnNvbjtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3ApKSB7XG4gICAgICAgICAgICByZXNwID0gW3Jlc3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNwZWx1bmtEYXRhKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFRoZXNlICphcmUqIHRoZSBkcm9pZHMgd2UncmUgbG9va2luZyBmb3IuXG4gICAgaWYgKHR5cGVvZiAodmFsdWUubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubWVzc2FnZS5tYXRjaCgvcmV2ZXJ0L2kpICYmIGlzSGV4U3RyaW5nKHZhbHVlLmRhdGEpKSB7XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsIGRhdGE6IHZhbHVlLmRhdGEgfTtcbiAgICB9XG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rRGF0YSh2YWx1ZVtrZXldKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzcGVsdW5rRGF0YShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfc3BlbHVua01lc3NhZ2UodmFsdWUsIHJlc3VsdCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBfc3BlbHVua01lc3NhZ2UodmFsdWVba2V5XSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfc3BlbHVua01lc3NhZ2UoSlNPTi5wYXJzZSh2YWx1ZSksIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG59XG5mdW5jdGlvbiBzcGVsdW5rTWVzc2FnZSh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItanNvbnJwYy5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBoYXNoQXV0aG9yaXphdGlvbiwgaGFzaE1lc3NhZ2UsIFR5cGVkRGF0YUVuY29kZXIgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RTaWduZXIsIGNvcHlSZXF1ZXN0IH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29tcHV0ZUFkZHJlc3MsIFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBUaGUgKipCYXNlV2FsbGV0KiogaXMgYSBzdHJlYW0tbGluZWQgaW1wbGVtZW50YXRpb24gb2YgYVxuICogIFtbU2lnbmVyXV0gdGhhdCBvcGVyYXRlcyB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFtbV2FsbGV0XV0gY2xhc3MsIGFzIGl0IG9mZmVyc1xuICogIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSBhbmQgc2ltcGxpZmllcyBsb2FkaW5nIGEgdmFyaWV0eVxuICogIG9mIEpTT04gZm9ybWF0cywgTW5lbW9uaWMgUGhyYXNlcywgZXRjLlxuICpcbiAqICBUaGlzIGNsYXNzIG1heSBiZSBvZiB1c2UgZm9yIHRob3NlIGF0dGVtcHRpbmcgdG8gaW1wbGVtZW50XG4gKiAgYSBtaW5pbWFsIFNpZ25lci5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VXYWxsZXQgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSB3YWxsZXQgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgICNzaWduaW5nS2V5O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEJhc2VXYWxsZXQgZm9yICUlcHJpdmF0ZUtleSUlLCBvcHRpb25hbGx5XG4gICAgICogIGNvbm5lY3RlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwcm92aWRlciUlIGlzIG5vdCBzcGVjaWZpZWQsIG9ubHkgb2ZmbGluZSBtZXRob2RzIGNhblxuICAgICAqICBiZSB1c2VkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXksIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHJpdmF0ZUtleSAmJiB0eXBlb2YgKHByaXZhdGVLZXkuc2lnbikgPT09IFwiZnVuY3Rpb25cIiwgXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgdGhpcy4jc2lnbmluZ0tleSA9IHByaXZhdGVLZXk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcyh0aGlzLnNpZ25pbmdLZXkucHVibGljS2V5KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFkZHJlc3MgfSk7XG4gICAgfVxuICAgIC8vIFN0b3JlIHByaXZhdGUgdmFsdWVzIGJlaGluZCBnZXR0ZXJzIHRvIHJlZHVjZSB2aXNpYmlsaXR5XG4gICAgLy8gaW4gY29uc29sZS5sb2dcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbU2lnbmluZ0tleV1dIHVzZWQgZm9yIHNpZ25pbmcgcGF5bG9hZHMuXG4gICAgICovXG4gICAgZ2V0IHNpZ25pbmdLZXkoKSB7IHJldHVybiB0aGlzLiNzaWduaW5nS2V5OyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcml2YXRlIGtleSBmb3IgdGhpcyB3YWxsZXQuXG4gICAgICovXG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7IHJldHVybiB0aGlzLnNpZ25pbmdLZXkucHJpdmF0ZUtleTsgfVxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiB0aGlzLmFkZHJlc3M7IH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZVdhbGxldCh0aGlzLiNzaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgICAgICB0eCA9IGNvcHlSZXF1ZXN0KHR4KTtcbiAgICAgICAgLy8gUmVwbGFjZSBhbnkgQWRkcmVzc2FibGUgb3IgRU5TIG5hbWUgd2l0aCBhbiBhZGRyZXNzXG4gICAgICAgIGNvbnN0IHsgdG8sIGZyb20gfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHRvOiAodHgudG8gPyByZXNvbHZlQWRkcmVzcyh0eC50bywgdGhpcykgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgZnJvbTogKHR4LmZyb20gPyByZXNvbHZlQWRkcmVzcyh0eC5mcm9tLCB0aGlzKSA6IHVuZGVmaW5lZClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0byAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC50byA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGdldEFkZHJlc3MoKHR4LmZyb20pKSA9PT0gdGhpcy5hZGRyZXNzLCBcInRyYW5zYWN0aW9uIGZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInR4LmZyb21cIiwgdHguZnJvbSk7XG4gICAgICAgICAgICBkZWxldGUgdHguZnJvbTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgYnR4ID0gVHJhbnNhY3Rpb24uZnJvbSh0eCk7XG4gICAgICAgIGJ0eC5zaWduYXR1cmUgPSB0aGlzLnNpZ25pbmdLZXkuc2lnbihidHgudW5zaWduZWRIYXNoKTtcbiAgICAgICAgcmV0dXJuIGJ0eC5zZXJpYWxpemVkO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25NZXNzYWdlU3luYyhtZXNzYWdlKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IEFkZCBhIHNlY2lhbGl6ZWQgc2lnblR4IGFuZCBzaWduVHlwZWQgc3luYyB0aGF0IGVuZm9yY2VzXG4gICAgLy8gYWxsIHBhcmFtZXRlcnMgYXJlIGtub3duP1xuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzaWduYXR1cmUgZm9yICUlbWVzc2FnZSUlIHNpZ25lZCB3aXRoIHRoaXMgd2FsbGV0LlxuICAgICAqL1xuICAgIHNpZ25NZXNzYWdlU3luYyhtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25pbmdLZXkuc2lnbihoYXNoTWVzc2FnZShtZXNzYWdlKSkuc2VyaWFsaXplZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIEF1dGhvcml6YXRpb24gZm9yICUlYXV0aCUlLlxuICAgICAqL1xuICAgIGF1dGhvcml6ZVN5bmMoYXV0aCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKGF1dGguYWRkcmVzcykgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBhZGRyZXNzIGZvciBhdXRob3JpemVTeW5jXCIsIFwiYXV0aC5hZGRyZXNzXCIsIGF1dGgpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLnNpZ25pbmdLZXkuc2lnbihoYXNoQXV0aG9yaXphdGlvbihhdXRoKSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGF1dGguYWRkcmVzcyksXG4gICAgICAgICAgICBub25jZTogZ2V0QmlnSW50KGF1dGgubm9uY2UgfHwgMCksXG4gICAgICAgICAgICBjaGFpbklkOiBnZXRCaWdJbnQoYXV0aC5jaGFpbklkIHx8IDApLFxuICAgICAgICB9LCB7IHNpZ25hdHVyZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBBdXRob3JpemF0aW9uIGZvciAlJWF1dGglJS5cbiAgICAgKi9cbiAgICBhc3luYyBhdXRob3JpemUoYXV0aCkge1xuICAgICAgICBhdXRoID0gT2JqZWN0LmFzc2lnbih7fSwgYXV0aCwge1xuICAgICAgICAgICAgYWRkcmVzczogYXdhaXQgcmVzb2x2ZUFkZHJlc3MoYXV0aC5hZGRyZXNzLCB0aGlzKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aG9yaXplU3luYyhhd2FpdCB0aGlzLnBvcHVsYXRlQXV0aG9yaXphdGlvbihhdXRoKSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgLy8gUG9wdWxhdGUgYW55IEVOUyBuYW1lc1xuICAgICAgICBjb25zdCBwb3B1bGF0ZWQgPSBhd2FpdCBUeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgYXN5bmMgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0aGlzIHNob3VsZCB1c2UgcmVzb2x2ZU5hbWU7IGFkZHJlc3NlcyBkb24ndFxuICAgICAgICAgICAgLy8gICAgICAgIG5lZWQgYSBwcm92aWRlclxuICAgICAgICAgICAgYXNzZXJ0KHRoaXMucHJvdmlkZXIgIT0gbnVsbCwgXCJjYW5ub3QgcmVzb2x2ZSBFTlMgbmFtZXMgd2l0aG91dCBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IG5hbWUgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIGFzc2VydChhZGRyZXNzICE9IG51bGwsIFwidW5jb25maWd1cmVkIEVOUyBuYW1lXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmluZ0tleS5zaWduKFR5cGVkRGF0YUVuY29kZXIuaGFzaChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSkuc2VyaWFsaXplZDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLXdhbGxldC5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3Qgc3Vic0NocnMgPSBcIiAhIyQlJicoKSorLC0uLzw9Pj9AW11eX2B7fH1+XCI7XG5jb25zdCBXb3JkID0gL15bYS16XSokL2k7XG5mdW5jdGlvbiB1bmZvbGQod29yZHMsIHNlcCkge1xuICAgIGxldCBpbml0aWFsID0gOTc7XG4gICAgcmV0dXJuIHdvcmRzLnJlZHVjZSgoYWNjdW0sIHdvcmQpID0+IHtcbiAgICAgICAgaWYgKHdvcmQgPT09IHNlcCkge1xuICAgICAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdvcmQubWF0Y2goV29yZCkpIHtcbiAgICAgICAgICAgIGFjY3VtLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpbml0aWFsKSArIHdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5pdGlhbCA9IDk3O1xuICAgICAgICAgICAgYWNjdW0ucHVzaCh3b3JkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwgW10pO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBzdWJzKSB7XG4gICAgLy8gUmVwbGFjZSBhbGwgdGhlIHN1YnN0aXR1dGlvbnMgd2l0aCB0aGVpciBleHBhbmRlZCBmb3JtXG4gICAgZm9yIChsZXQgaSA9IHN1YnNDaHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KHN1YnNDaHJzW2ldKS5qb2luKHN1YnMuc3Vic3RyaW5nKDIgKiBpLCAyICogaSArIDIpKTtcbiAgICB9XG4gICAgLy8gR2V0IGFsbCB0bGUgY2x1bXBzOyBlYWNoIHN1ZmZpeCwgZmlyc3QtaW5jcmVtZW50IGFuZCBzZWNvbmQtaW5jcmVtZW50XG4gICAgY29uc3QgY2x1bXBzID0gW107XG4gICAgY29uc3QgbGVmdG92ZXIgPSBkYXRhLnJlcGxhY2UoLyg6fChbMC05XSl8KFtBLVpdW2Etel0qKSkvZywgKGFsbCwgaXRlbSwgc2VtaSwgd29yZCkgPT4ge1xuICAgICAgICBpZiAoc2VtaSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlSW50KHNlbWkpOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGNsdW1wcy5wdXNoKFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsdW1wcy5wdXNoKGl0ZW0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSk7XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGxlZnRvdmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbGVmdG92ZXJzOiAke0pTT04uc3RyaW5naWZ5KGxlZnRvdmVyKX1gKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICByZXR1cm4gdW5mb2xkKHVuZm9sZChjbHVtcHMsIFwiO1wiKSwgXCI6XCIpO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU93bChkYXRhKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoZGF0YVswXSA9PT0gXCIwXCIsIFwidW5zdXBwb3J0ZWQgYXV3bCBkYXRhXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlKGRhdGEuc3Vic3RyaW5nKDEgKyAyICogc3Vic0NocnMubGVuZ3RoKSwgZGF0YS5zdWJzdHJpbmcoMSwgMSArIDIgKiBzdWJzQ2hycy5sZW5ndGgpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZS1vd2wuanMubWFwIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQSBXb3JkbGlzdCByZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBsYW5ndWFnZS1zcGVjaWZpY1xuICogIHdvcmRzIHVzZWQgdG8gZW5jb2RlIGFuZCBkZXZvY2UgW1tsaW5rLWJpcC0zOV1dIGVuY29kZWQgZGF0YVxuICogIGJ5IG1hcHBpbmcgd29yZHMgdG8gMTEtYml0IHZhbHVlcyBhbmQgdmljZSB2ZXJzYS5cbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmRsaXN0IHtcbiAgICBsb2NhbGU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgV29yZGxpc3QgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgTVVTVCBjYWxsIHRoaXMgaWYgdGhleSBwcm92aWRlIHRoZWlyIG93biBjb25zdHJ1Y3RvcixcbiAgICAgKiAgcGFzc2luZyBpbiB0aGUgbG9jYWxlIHN0cmluZyBvZiB0aGUgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiAgR2VuZXJhbGx5IHRoZXJlIGlzIG5vIG5lZWQgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBhIFdvcmRsaXN0LFxuICAgICAqICBzaW5jZSBlYWNoIGxhbmd1YWdlLXNwZWNpZmljIFdvcmRsaXN0IGNyZWF0ZXMgYW4gaW5zdGFuY2UgYW5kXG4gICAgICogIHRoZXJlIGlzIG5vIHN0YXRlIGtlcHQgaW50ZXJuYWxseSwgc28gdGhleSBhcmUgc2FmZSB0byBzaGFyZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGxvY2FsZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIHByb3ZpZGUgYSBsYW5ndWFnZS1zcGVjaWZpY1xuICAgICAqICBtZXRob2QgZm9yIHNwbGl0aW5nICUlcGhyYXNlJSUgaW50byBpbmRpdmlkdWFsIHdvcmRzLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQsICUlcGhyYXNlJSUgaXMgc3BsaXQgdXNpbmcgYW55IHNlcXVlbmNlcyBvZlxuICAgICAqICB3aGl0ZS1zcGFjZSBhcyBkZWZpbmVkIGJ5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgKGkuZS4gYGAvXFxzKy9gYCkuXG4gICAgICovXG4gICAgc3BsaXQocGhyYXNlKSB7XG4gICAgICAgIHJldHVybiBwaHJhc2UudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy9nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIHByb3ZpZGVyIGEgbGFuZ3VhZ2Utc3BlY2lmaWNcbiAgICAgKiAgbWV0aG9kIGZvciBqb2luaW5nICUld29yZHMlJSBpbnRvIGEgcGhyYXNlLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQsICUld29yZHMlJSBhcmUgam9pbmVkIGJ5IGEgc2luZ2xlIHNwYWNlLlxuICAgICAqL1xuICAgIGpvaW4od29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHdvcmRzLmpvaW4oXCIgXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmRsaXN0LmpzLm1hcCIsIi8vIFVzZSB0aGUgZW5jb2RlLWxhdGluLmpzIHNjcmlwdCB0byBjcmVhdGUgdGhlIG5lY2Vzc2FyeVxuLy8gZGF0YSBmaWxlcyB0byBiZSBjb25zdW1lZCBieSB0aGlzIGNsYXNzXG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlT3dsIH0gZnJvbSBcIi4vZGVjb2RlLW93bC5qc1wiO1xuaW1wb3J0IHsgV29yZGxpc3QgfSBmcm9tIFwiLi93b3JkbGlzdC5qc1wiO1xuLyoqXG4gKiAgQW4gT1dMIGZvcm1hdCBXb3JkbGlzdCBpcyBhbiBlbmNvZGluZyBtZXRob2QgdGhhdCBleHBsb2l0c1xuICogIHRoZSBnZW5lcmFsIGxvY2FsaXR5IG9mIGFscGhhYmV0aWNhbGx5IHNvcnRlZCB3b3JkcyB0b1xuICogIGFjaGlldmUgYSBzaW1wbGUgYnV0IGVmZmVjdGl2ZSBtZWFucyBvZiBjb21wcmVzc2lvbi5cbiAqXG4gKiAgVGhpcyBjbGFzcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCB0byBtb3N0IGRldmVsb3BlcnMgYXNcbiAqICBpdCBpcyB1c2VkIG1haW5seSBpbnRlcm5hbGx5IHRvIGtlZXAgV29yZGxpc3RzIGZvciBsYW5ndWFnZXNcbiAqICBiYXNlZCBvbiBBU0NJSS03IHNtYWxsLlxuICpcbiAqICBJZiBuZWNlc3NhcnksIHRoZXJlIGFyZSB0b29scyB3aXRoaW4gdGhlIGBgZ2VuZXJhdGlvbi9gYCBmb2xkZXJcbiAqICB0byBjcmVhdGUgdGhlIG5lY2Vzc2FyeSBkYXRhLlxuICovXG5leHBvcnQgY2xhc3MgV29yZGxpc3RPd2wgZXh0ZW5kcyBXb3JkbGlzdCB7XG4gICAgI2RhdGE7XG4gICAgI2NoZWNrc3VtO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFdvcmRsaXN0IGZvciAlJWxvY2FsZSUlIHVzaW5nIHRoZSBPV0wgJSVkYXRhJSVcbiAgICAgKiAgYW5kIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSAlJWNoZWNrc3VtJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWxlLCBkYXRhLCBjaGVja3N1bSkge1xuICAgICAgICBzdXBlcihsb2NhbGUpO1xuICAgICAgICB0aGlzLiNkYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy4jY2hlY2tzdW0gPSBjaGVja3N1bTtcbiAgICAgICAgdGhpcy4jd29yZHMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIE9XTC1lbmNvZGVkIGRhdGEuXG4gICAgICovXG4gICAgZ2V0IF9kYXRhKCkgeyByZXR1cm4gdGhpcy4jZGF0YTsgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgYWxsIHRoZSB3b3JkcyBmb3IgdGhlIHdvcmRsaXN0LlxuICAgICAqL1xuICAgIF9kZWNvZGVXb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZU93bCh0aGlzLiNkYXRhKTtcbiAgICB9XG4gICAgI3dvcmRzO1xuICAgICNsb2FkV29yZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLiN3b3JkcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IHRoaXMuX2RlY29kZVdvcmRzKCk7XG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGNvbXB1dGVkIGxpc3QgbWF0Y2hlcyB0aGUgb2ZmaWNpYWwgbGlzdFxuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBpZCh3b3Jkcy5qb2luKFwiXFxuXCIpICsgXCJcXG5cIik7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChjaGVja3N1bSAhPT0gdGhpcy4jY2hlY2tzdW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJJUDM5IFdvcmRsaXN0IGZvciAke3RoaXMubG9jYWxlfSBGQUlMRURgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB0aGlzLiN3b3JkcyA9IHdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiN3b3JkcztcbiAgICB9XG4gICAgZ2V0V29yZChpbmRleCkge1xuICAgICAgICBjb25zdCB3b3JkcyA9IHRoaXMuI2xvYWRXb3JkcygpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwICYmIGluZGV4IDwgd29yZHMubGVuZ3RoLCBgaW52YWxpZCB3b3JkIGluZGV4OiAke2luZGV4fWAsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gd29yZHNbaW5kZXhdO1xuICAgIH1cbiAgICBnZXRXb3JkSW5kZXgod29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbG9hZFdvcmRzKCkuaW5kZXhPZih3b3JkKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdC1vd2wuanMubWFwIiwiaW1wb3J0IHsgV29yZGxpc3RPd2wgfSBmcm9tIFwiLi93b3JkbGlzdC1vd2wuanNcIjtcbmNvbnN0IHdvcmRzID0gXCIwZXJsZW9uYWxvcmVuc2VpbmNlcmVnZXN0aWNpdFN0YW52ZXRlYXJjdHNzaSNjaDJBdGhjayZ0bmVMbDBBbmQjSWwueUxlT3V0Tz1TfFMlYi9yYUBTdXJkVScwQ2VbQ2lkfENvdW50Q3UnSGllPUlkT3UsLVF1aSpSb1tUVF1UJVQqW1R1JDBBcHRERC10RCpbSnUsTS5VbHRWPClWaSkwUm9iLTBGYWlyRiVkUmFpZDBBKEVFbnRSZWUwRWFkME1SUnAldFMhX3JtQnVtQ29ob2xFcnRJJkxMZXlMb3dNbyxPfVBoYVJlYWR5U29UIFdheXMwQT51ckF6KGdPbmdPdW50VSdkMEFseSxDaCVDaXxHIEchR3J5SW0kSyFOb3VuKU51JE9gIFN3IFQmbmFUaXF1ZVhpZXR5WTFBcnRPbG9neVBlP1AhUHJvPVJpbDFDaEN0LUVhRW5hR3VlTU1lZE0lTXlPdW5kUjwrUmUsUmk9Um93VFRlZmFAVGksVHclazBLUGVAU2F1bHRTZXRTaSxTdW1lVGhtYTBIIT5PbVRhe1QmZFQudWRlVHJhQDBDdF1ELkd1LE50VGglVG9UdW1uMEVyYStPY2Fkb09pZDBBa2VBKkF5RXNvbWVGdWxLdz9kMElzOkJ5Q2hlbCVDI0QrR0w8KUxjI3l+TWJvb048YU5uIFJSZWx5UmdhKFIqbFNlUy1Ta2V0VHQhM0FeQW5BdXR5Q2F1J0NvbWVFZkYlZUcoSGE9SChkTGllPUxvd0x0Tl5OZWYuL1RyYXlUdCBUd2UmWSNkM0N5YyFES2VOZE9sb2d5UmRSYFR0IF97QWRlQW1lQW5rZXRBLEVha0VbSW5kT29kT1tvbU91J1VlVXJVc2hfcmRBdER5SWxNYk5lTnVzT2tPLFJkIFIoZ1Jyb3dTc1R0b21VbilYWV97ZXRBKEFuZEFbQT1FYWRFZXplSXtJZCtJZWZJZ2h0SW5nSXNrT2Njb2xpT2smT256ZU9vbU9gIE93blVzaDJCYiFEZHlEK3RGZiRvSWxkTGJMa0whdE5kIU5rIFJkJlJnIFIsU1MoZVtTeVR0IFkgWno6QmJhK0IoQiFDdHVzR2VLZX5MbU0gYU1wTk4kTilsTmR5Tm4jTm9lTnZhc055I1BhYiFQLiRQdGEoUlJiI1JkUmdvUnBldFJyeVJ0U2VTaFMoby8hU3UkVFQkb2dUXlRlZyV5VHQhVWdodFUnVXRdVmUzSWwoZ0wgeU18TnN1c050dXJ5UmUkUnRhKF9pckFsa0FtcF1BbitBb3NBcHQgQXIrQSdBdEVhcEV7RWUnRWZFcnJ5RSxJeyZJZWZJbGRJbX15T2kpT28nUiMtVXshVW5rVXJuMEc/Tm5hbSNSYyFUaXomVHlWaWxfaW1BcEFyaWZ5QXdBeUU8RXJrRXYgSXtJfElmZkltYkluLUlwT3tPZ08nT2BPdWRPd25VYlVtcFUsIFV0Xl9eQSxDI3V0RGVGZmVlSWxJbkwhQEwlTHVtbk1iKGVNZU1mJXRNLU1tI01wPHlOYyB0TmR1QE5maXJtTmcqW059QE5zaWQgTnRyb2xOdigpT2tPbFBwIFB5UiRSZVJuUipAL1R0I1VeVW50cnlVcCFVcidVcyhWIFlvPl97QWQhQWZ0QW1BfUFzaEF0IEF3bEF6eUVhbUVkLkVla0V3SXtldEltZUlzcEl0LU9wT1tPdV5Pd2RVY2kkVWVsVWknVW1iIVVuXlVzaFlZLCQyQmVMdHUqUFBibz9kUmlvdXNScnxSdGEoUj1TaF0vb21UZTNDITpETWErTXBOKU5nIFIoZ1NoVWdodCBXblkzQWxCYT5CcmlzQ2FkZUNlbWIgQ2lkZUNsKGVDJWE+QyphJ0VyRiYnRihlRnlHKmVMYXlMaXYgTTxkTWknTmkkTnRpLE55UD90UCZkUG9zLlBgUHV0eVJpPVNjcmliZVMgdFNpZ25Ta1NwYWlyL3JveVRhaWxUZUBWZWxvcFZpKVZvPjNBZ3JhbUFsQW0jZEFyeUNlRSdsRXRGZiBHLiRHbi55TGVtbWFObiBOb3NhdXJSZUBSdFNhZyplU2NvdiBTZWEnU2hTbWlbUyVkIFNwbGF5LzwpViB0VmlkZVYlKVp6eTVDdCVDdW18R35McGgoTWEoTmE+TmtleU4lT3JTZVViIVZlX2Z0QWcjQW1hQSwtQXdFYW1FW0lmdElsbElua0lwST1PcFVtWTJDa01iTmVSKGcvVF5UeTFBcmYxTmFtLTpHIEchUmx5Um5SYFNpbHkvU3kxSG9PbG9neU9ub215MEdlSXRVY2E+MUYldDBHMUdodFRoIDJCb3dEIEVAci1FZzx0RW18RXBoPHRFdmF0JUk+U2UwQj9rQm9keUJyYSlFcitPdF1QbG95UG93IFB0eTBBYiFBQEREIVtEJSdFbXlFcmd5RiUpR2ErRyhlSDwpSm95TGksT3VnaFItaFJvbGxTdSpUIFRpKlRyeVZlbG9wZTFJc29kZTBVJFVpcDBBQSdPZGVPc11SJVVwdDBDYXBlU2F5UyYpVGE+MEVybiRILXMxSWQmKUlsT2tlT2w9MUFAQW1wIUNlW0NoPCtDLmVDbHVkZUN1J0VjdT5FcmNpJ0hhdSxIaWIuSSFJLEl0T3QtUDxkUGVAUGkqUGxhKFBvJ1AqW1QmZFRyYTBFRWJyb3c6QnItQ2VDdWx0eURlSW50SWB+TCdNZU1pbHlNb3VzTk5jeU50YXN5Um1TaF1UVCRUaCBUaWd1ZVVsdFYlLmUzQXR1KkJydT95RCAkRUVkRWxNYSFOKS9pdiRUXlYgVzNCIEN0XUVsZEd1KkxlTG1MdCBOJE5kTmVOZyBOaXNoUmVSbVIsU2MkU2hUVH1bWF9nQW1lQXNoQXRBdiVFZUlnaHRJcE9hdE97TyVPdyBVaWRVc2hZX21DdXNHSWxMZH5vd09kT3RSKVJlLFIrdFJrUnR1fVJ1bVJ3P2RTc2lsLyBVbmRYX2dpIUFtZUVxdXxFc2hJJmRJbitPZ09udE8sT3duT3omVS4yRWxOTm55Um5hKVJ5VHUqOkQrdEluTGF4eX4geU1lUFJhK1JiYStSZCZSbC1SbXxTU3BUZVRoIFUrWmUzTiAkTml1c04qTnQhTnUoZS91KjJPLDBBbnRGdEdnIU5nIFJhZmZlUmxWZV9kQW4pQSpBW0lkZUltcCdPYmVPb21PcnlPPU93VWVfdERkZVtMZE9kTydSaWxsYVNwZWxTc2lwViBuV25fYkEpQShBbnRBcGVBW0F2LnlFYXRFJklkSWVmSXRPYyB5T3VwT3dVbnRfcmRFW0lkZUlsdEl0P04zTTpCLklyTGZNbSBNLCBOZFBweVJiJVJkUnNoUj0sVFZlV2taP2QzQWRBbGBBcnRBdnlEK2hvZ0lnaHR+b0xtZXRMcE5SbzNEZCZHaH5OdFBSZS8leTVCYnlDa2V5TGRMZUxpZGF5fm93TWVOZXlPZFBlUm5SciVSJ1NwLiQvVGVsVXJWIDVCR2VNPE1iIU0lTmQqZE5ncnlOdFJkIVJyeVJ0U2I8ZDNCcmlkOjFFT24wRWFFbnRpZnlMZTJOJWU0TExlZyRMfVswQStJdGE+TSYnTXV9UGFAUG8nUHJvPVB1bCcwQ2hDbHVkZUNvbWVDKmEnRGV4RC1hPkRvJUR1LHJ5Rjx0RmwtdEYlbUhhIUggLkl0aSRKZUBKdXJ5TWE+TiBOb2N8UHV0UXVpcnlTPGVTZUBTaWRlU3BpKi8kbFRhQFQgZSxUb1ZlLFYuZVZvbD0zT24wTDxkT2xhPlN1ZTBFbTFPcnk6Q2tldEd1P1JaejNBbG91c0Fuc355V2VsOUJJbktlVXJ9eVk1RCtJKU1wTmchTmklTmsvOk5nP29vM0VuRXBUXnVwWTNDa0REfXlOZE5nZG9tU3NUVF4mVGVUdCZXaTRFZUlmZU97T3c6QkJlbEIlRGQgRHlLZU1wTmd1YStQdG9wUitUIFQoVWdoVW5kcnlWYVdXbldzdS5ZIFp5M0FkIEFmQXJuQT1DdHUqRnRHRyRHJmRJc3UqTSNOZE5nYE5zT3A/ZFNzI1R0IFZlbDNBckIgdHlCcj95QyYnRmVGdEdodEtlTWJNLk5rT25RdWlkL1R0IVZlWj9kNUFkQW5CLCBDJENrRy1OZWx5TmdPcFR0IHlVZFVuK1ZlWSQ1Q2t5R2dhK01iIE4/Tl5YdXJ5M1ItczpDaChlREctR310SWRJbEluSiVLZU1tJE5OYStOZGE+TmdvTnNdTnUkUCFSYiFSXlJnKFIoZVJrZXRScmlhK1NrU3MvIFReVCBpJFRoVHJpeFR0IFhpbXVtWmUzQWRvd0FuQXN1KkF0Q2g8LUQkRGlhTG9keUx0TWIgTSV5TnRdTnVSY3lSK1IuUnJ5U2hTc2ErVCRUaG9kM0RkIURuaWdodExrfl1NLU5kTmltdW1OJU51PlJhYyFSciVTIHlTcy9ha2VYWGVkWHR1KjVCaSFEZWxEaWZ5TU18Ti4lTmtleU4sIE5gT25SJFJlUm4oZ1NxdS5vVGggVF1UJVVudGEoVSdWZVZpZTVDaEZmKExlTHRpcGx5U2MhU2V1bVNocm9vbVMtL1R1JDNTZWxmLyB5VGg6ST1NZVBrKFJyb3cveVRdVHUqM0FyQ2tFZEdhdGk9RyFASWAgUGhld1I9L1RUdyVrVXRyJFYgV3NYdDNDZUdodDVCIUknTShlZU9kIVJtJFJgU2VUYWIhVGVUaChnVGkpVmVsVzVDIT9NYiBSJ1Q6SzBFeUplQExpK1NjdSpTID1UYShWaW91czBDdXJFPFRvYiAwT3IxRkYgRmkpVCYyTDFBeTBEST1ZbXAtMEl0MENlRUkjTChlTHkxRW5FcmFJbl1QbydUXTFBbitCLkNoP2REIEQoP3lHPEl8SWcoJFBoPDBUci1oMEggMFRkbyVUIFRwdXRUc2lkZTBBbEVuRXIwTk4gMFlnJjAvIDBPfTpDdERkIUdlSXJMYSlMbU5kYU5lbE4tTmAgUCBSYWRlUnxSa1Jyb3RSdHlTc1ReVGhUaXxUcm9sVHQgblUnVmVZbXwzQSlBbnV0QXJBczx0TC08Tk4kdHlOY2lsT3AhUHAgUmZlQFJtLlJzI1QyT31PdG9SYSdZcy0kMEFub0NuLUN0dSpFKUdHZSN+TG90TmtPfSBQZS9vbFReWnphXylBfXRBLC1BPkF5RWEnRWQrVXtVZ1VuKzJFbUV0SW50TD9MZUxpKU5kTnlPbFB1bD9SdF1TLl1Tc2liIS9UYXRvVHQgeVYgdHlXZCBXIF9AaSlBaSdFZC10RWYgRXBhKkVzfEV0dHlFdnxJKUlkZUltP3lJbnRJJS55SXMjSXZhPkl6ZU9iIW1PKVtPZHUpT2YuT2dyYW1PamVAT21vPk9vZk9wIHR5T3NwIE8+QE91ZE92aWRlMkJsLURkKGd+THBMJ01wayhOXlBpbFBweVJeYSdSLnlScG8nUidTaFRaeiEzUmFtaWQ6OTlBbC55QW50dW1BcnQgRSxdSXtJdEl6Tz46QmIuQ2NvI0NlQ2tEP0Rpb0lsSW5JJ355TXBOXk5kb21OK1BpZFJlVGVUaCBWJldaJTNBZHlBbEFzI0JlbEJ1aWxkQyRsQ2VpPUNpcGVDJWRDeWMhRHUpRiFARiVtRnUnR11HKnRHdWw/SmVATGF4TGVhJ0xpZWZMeU1hKE1lbWIgTShkTW89TmQgTmV3TnRPcCZQYWlyUGVhdFBsYSlQJXRRdWkqU2N1ZVNlbWIhU2ksU291cilTcCMnU3VsdFRpKlQqYXRUdXJuVW5dVmUkVmlld1c/ZDJZYG0wQkJiI0NlQ2hEZUQrRiFHaHRHaWROZ090UHAhU2tUdSRWJFYgNUFkQSxCb3RCdSxDa2V0TTwpT2ZPa2llT21TZVRhPlVnaFVuZFU+WSQ1QmIgRGVHTGVOTndheVIkOkREZCFEfVtGZUlsTGFkTG0jTCNMdEx1Pk1lTXAhTmRUaXNmeVRvc2hpVSlVc2ErVmVZMUEhQW5BKkF0dCBFfUhlbWVIb29sSSYpSVslc09ycF1PdXRSYXBSZSZSaXB0UnViMUFBcl5BcyNBdEMjZEMqdEN0XUN1ci55RWRFa0dtfExlQH5NKD9OaSVOJ050JilSaWVzUnZpKVNzXVR0IVR1cFYmX2Rvd0FmdEFsbG93QSpFZEVsbEVyaWZmSWVsZElmdEl9SXBJdiBPe09lT290T3BPcnRPdWxkIE89UmltcFJ1Z1VmZiFZMEJsKGdDa0RlRStHaHRHbkx8TGt+eUx2IE1pbD9NcCFOKU5nUiYvIFR1YT5YWmUxQT5FdF5JSWxsSW5JcnRVbGwwQWJBbUVlcEVuZCBJKUlkZUlnaHRJbU9nPE90T3dVc2gwQWxsQXJ0SSFPa2VPb2AwQXtBa2VBcElmZk93MEFwQ2MgQ2kkQ2tEYUZ0TD9MZGkgTGlkTHV0XUw9TWUjZU5nT25ScnlSdFVsVW5kVXBVcilVYDBBKUEqQXRpJEF3bkVha0VjaSRFZWRFbGxFbmRIIGVJKUlkIElrZUluSXIuTC5PaWxPbnMlTyNPcnRPdFJheVJlYWRSKGdZMFVhKlVlZXplVWlyKmxfYiFBZGl1bUFmZkErQWlyc0FtcEFuZEFydEE+QXlFYWtFZWxFbUVwRSpvSXtJbGxJbmdPe09tYV5PfU9vbE9yeU89UmE+Z3lSZWV0UmlrZVIjZ1J1Z2chVWR8VWZmVW1iIVkhMEJqZUBCbS5Cd2F5QylbQ2hEZCZGZiBHP0crLEl0TW0gTk5ueU4ndFAgUHBseVAqbWVSZVJmYSlSK1JwcmknUnJvdW5kUj15U3BlQC9hKDFBbGxvd0FtcEFwQXJtRT9FZXRJZnRJbUluZ0l0Xk9yZDFNYm9sTXB0b21SdXAvZW06QiFDayFHSWxMfExrTmtQZVIrdFNrL2VUdG9vWGkzQV5BbX5OTjx0Tm5pc050Um0vWHRfbmtBdEVtZUVuRSV5RSpFeUluZ0lzT3VnaHRSZWVSaT1Sb3dVbWJVbmQgMENrZXREZUcgTHRNYiBNZU55UFJlZFNzdWVUITVBLEJhY2NvRGF5RGRsIEVHZWAgSSF0SyZNYXRvTSVyb3dOZU5ndWVOaWdodE9sT2BQUC1QcCFSXlJuYWRvUnRvaSdTc1QkVXJpLFc/ZFcgV25ZX3tBZGVBZmYtQWctQShBbnNmIEFwQXNoQT1sQXlFYXRFZUVuZEkkSWJlSXtJZ2cgSW1JcE9waHlPdWIhVXtVZVVseVVtcGV0VSxVYFkyQmVJdF1NYiFOYU59bFJrZXlSblJ0ITFFbD1FbnR5SSlJbkksTzFQZVAtJDo1THk1QipsbGEwQWIhQXdhKkMhQ292IEQgRG9GYWlyRm9sZEhhcHB5SWYlbUlxdWVJdEl2ICdLbm93bkxve1RpbFVzdSRWZWlsMURhPkdyYWRlSG9sZE9uUCBTZXQxQjxHZTBBK0VFZEVmdWxFIVtVJDBJbC55OkM8dEN1dW1HdWVMaWRMIXlMPU5OaXNoUCVSaW91cy9VbHQzSC0hTD10TmQlTnR1Kk51ZVJiUmlmeVJzXVJ5UydsVCA8M0FiIUJyPHRDaW91c0N0JXlEZW9Fd35hK050YStPbChSdHUkUnVzU2FTLlN1JFQkVmlkNUMkSSlJZExjPG9MdW1lVGVZYSs6R2VHI0l0TGt+TG51dE50UmZhKlJtUnJpJVNoU3AvZVQgVmVZM0FsYEFwI0FyQSdsQWAgQkRkKGdFayZkSXJkTGNvbWUvVF8hQXRFYXRFZWxFbkUqSXBJc3AgMERlRGBGZUxkfk5OZG93TmVOZ05rTm4gTnQgUmVTZG9tU2VTaFR9WzVMZk08TmQgT2RPbFJkUmtSbGRScnlSYF9wRXtFLCFJLEk+T25nOjpSZDNBcn5vdzlVVW5nVWA6M0JyYVJvOU5lT1wiO1xuY29uc3QgY2hlY2tzdW0gPSBcIjB4M2M4YWNjMWU3YjA4ZDhlNzZmOWZkYTAxNWVmNDhkYzhjNzEwYTczY2I3ZTBmNzdiMmMxOGE5YjVhN2FkZGU2MFwiO1xubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzktZW5dXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuZXhwb3J0IGNsYXNzIExhbmdFbiBleHRlbmRzIFdvcmRsaXN0T3dsIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgRW5nbGlzaCBsYW5ndWFnZSBXb3JkbGlzdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSBtb3N0IG9mIHRoZSB0aW1lIGFzIHRoZSBleHBvcnRlZFxuICAgICAqICBbW2xhbmdFbl1dIHNob3VsZCBzdWZmaWNlLlxuICAgICAqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcImVuXCIsIHdvcmRzLCBjaGVja3N1bSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGBgTGFuZ0VuYGAsIGNyZWF0aW5nIGl0XG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB3b3JkbGlzdCgpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbmV3IExhbmdFbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWVuLmpzLm1hcCIsImltcG9ydCB7IHBia2RmMiwgc2hhMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0Qnl0ZXMsIGhleGxpZnksIGFzc2VydE5vcm1hbGl6ZSwgYXNzZXJ0UHJpdmF0ZSwgYXNzZXJ0QXJndW1lbnQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBMYW5nRW4gfSBmcm9tIFwiLi4vd29yZGxpc3RzL2xhbmctZW4uanNcIjtcbi8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIE1TQiBiaXRzIHNldFxuZnVuY3Rpb24gZ2V0VXBwZXJNYXNrKGJpdHMpIHtcbiAgICByZXR1cm4gKCgxIDw8IGJpdHMpIC0gMSkgPDwgKDggLSBiaXRzKSAmIDB4ZmY7XG59XG4vLyBSZXR1cm5zIGEgYnl0ZSB3aXRoIHRoZSBMU0IgYml0cyBzZXRcbmZ1bmN0aW9uIGdldExvd2VyTWFzayhiaXRzKSB7XG4gICAgcmV0dXJuICgoMSA8PCBiaXRzKSAtIDEpICYgMHhmZjtcbn1cbmZ1bmN0aW9uIG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLCB3b3JkbGlzdCkge1xuICAgIGFzc2VydE5vcm1hbGl6ZShcIk5GS0RcIik7XG4gICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgd29yZGxpc3QgPSBMYW5nRW4ud29yZGxpc3QoKTtcbiAgICB9XG4gICAgY29uc3Qgd29yZHMgPSB3b3JkbGlzdC5zcGxpdChtbmVtb25pYyk7XG4gICAgYXNzZXJ0QXJndW1lbnQoKHdvcmRzLmxlbmd0aCAlIDMpID09PSAwICYmIHdvcmRzLmxlbmd0aCA+PSAxMiAmJiB3b3Jkcy5sZW5ndGggPD0gMjQsIFwiaW52YWxpZCBtbmVtb25pYyBsZW5ndGhcIiwgXCJtbmVtb25pY1wiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICBjb25zdCBlbnRyb3B5ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKDExICogd29yZHMubGVuZ3RoIC8gOCkpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGluZGV4ID0gd29yZGxpc3QuZ2V0V29yZEluZGV4KHdvcmRzW2ldLm5vcm1hbGl6ZShcIk5GS0RcIikpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBgaW52YWxpZCBtbmVtb25pYyB3b3JkIGF0IGluZGV4ICR7aX1gLCBcIm1uZW1vbmljXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICBmb3IgKGxldCBiaXQgPSAwOyBiaXQgPCAxMTsgYml0KyspIHtcbiAgICAgICAgICAgIGlmIChpbmRleCAmICgxIDw8ICgxMCAtIGJpdCkpKSB7XG4gICAgICAgICAgICAgICAgZW50cm9weVtvZmZzZXQgPj4gM10gfD0gKDEgPDwgKDcgLSAob2Zmc2V0ICUgOCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVudHJvcHlCaXRzID0gMzIgKiB3b3Jkcy5sZW5ndGggLyAzO1xuICAgIGNvbnN0IGNoZWNrc3VtQml0cyA9IHdvcmRzLmxlbmd0aCAvIDM7XG4gICAgY29uc3QgY2hlY2tzdW1NYXNrID0gZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBnZXRCeXRlcyhzaGEyNTYoZW50cm9weS5zbGljZSgwLCBlbnRyb3B5Qml0cyAvIDgpKSlbMF0gJiBjaGVja3N1bU1hc2s7XG4gICAgYXNzZXJ0QXJndW1lbnQoY2hlY2tzdW0gPT09IChlbnRyb3B5W2VudHJvcHkubGVuZ3RoIC0gMV0gJiBjaGVja3N1bU1hc2spLCBcImludmFsaWQgbW5lbW9uaWMgY2hlY2tzdW1cIiwgXCJtbmVtb25pY1wiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpO1xufVxuZnVuY3Rpb24gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpIHtcbiAgICBhc3NlcnRBcmd1bWVudCgoZW50cm9weS5sZW5ndGggJSA0KSA9PT0gMCAmJiBlbnRyb3B5Lmxlbmd0aCA+PSAxNiAmJiBlbnRyb3B5Lmxlbmd0aCA8PSAzMiwgXCJpbnZhbGlkIGVudHJvcHkgc2l6ZVwiLCBcImVudHJvcHlcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgd29yZGxpc3QgPSBMYW5nRW4ud29yZGxpc3QoKTtcbiAgICB9XG4gICAgY29uc3QgaW5kaWNlcyA9IFswXTtcbiAgICBsZXQgcmVtYWluaW5nQml0cyA9IDExO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDb25zdW1lIHRoZSB3aG9sZSBieXRlICh3aXRoIHN0aWxsIG1vcmUgdG8gZ28pXG4gICAgICAgIGlmIChyZW1haW5pbmdCaXRzID4gOCkge1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSA4O1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IGVudHJvcHlbaV07XG4gICAgICAgICAgICByZW1haW5pbmdCaXRzIC09IDg7XG4gICAgICAgICAgICAvLyBUaGlzIGJ5dGUgd2lsbCBjb21wbGV0ZSBhbiAxMS1iaXQgaW5kZXhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gcmVtYWluaW5nQml0cztcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSBlbnRyb3B5W2ldID4+ICg4IC0gcmVtYWluaW5nQml0cyk7XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCB3b3JkXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goZW50cm9weVtpXSAmIGdldExvd2VyTWFzayg4IC0gcmVtYWluaW5nQml0cykpO1xuICAgICAgICAgICAgcmVtYWluaW5nQml0cyArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdGhlIGNoZWNrc3VtIGJpdHNcbiAgICBjb25zdCBjaGVja3N1bUJpdHMgPSBlbnRyb3B5Lmxlbmd0aCAvIDQ7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBwYXJzZUludChzaGEyNTYoZW50cm9weSkuc3Vic3RyaW5nKDIsIDQpLCAxNikgJiBnZXRVcHBlck1hc2soY2hlY2tzdW1CaXRzKTtcbiAgICAvLyBTaGlmdCB0aGUgY2hlY2tzdW0gaW50byB0aGUgd29yZCBpbmRpY2VzXG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSBjaGVja3N1bUJpdHM7XG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IChjaGVja3N1bSA+PiAoOCAtIGNoZWNrc3VtQml0cykpO1xuICAgIHJldHVybiB3b3JkbGlzdC5qb2luKGluZGljZXMubWFwKChpbmRleCkgPT4gd29yZGxpc3QuZ2V0V29yZChpbmRleCkpKTtcbn1cbmNvbnN0IF9ndWFyZCA9IHt9O1xuLyoqXG4gKiAgQSAqKk1uZW1vbmljKiogd3JhcHMgYWxsIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gY29tcHV0ZSBbW2xpbmstYmlwLTM5XV1cbiAqICBzZWVkcyBhbmQgY29udmVydCBiZXR3ZWVuIHBocmFzZXMgYW5kIGVudHJvcHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBNbmVtb25pYyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtbmVtb25pYyBwaHJhc2Ugb2YgMTIsIDE1LCAxOCwgMjEgb3IgMjQgd29yZHMuXG4gICAgICpcbiAgICAgKiAgVXNlIHRoZSBbW3dvcmRsaXN0XV0gYGBzcGxpdGBgIG1ldGhvZCB0byBnZXQgdGhlIGluZGl2aWR1YWwgd29yZHMuXG4gICAgICovXG4gICAgcGhyYXNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFzc3dvcmQgdXNlZCBmb3IgdGhpcyBtbmVtb25pYy4gSWYgbm8gcGFzc3dvcmQgaXMgdXNlZCB0aGlzXG4gICAgICogIGlzIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYGBcIlwiYGApIGFzIHBlciB0aGUgc3BlY2lmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBwYXNzd29yZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHdvcmRsaXN0IGZvciB0aGlzIG1uZW1vbmljLlxuICAgICAqL1xuICAgIHdvcmRsaXN0O1xuICAgIC8qKlxuICAgICAqICBUaGUgdW5kZXJseWluZyBlbnRyb3B5IHdoaWNoIHRoZSBtbmVtb25pYyBlbmNvZGVzLlxuICAgICAqL1xuICAgIGVudHJvcHk7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGVudHJvcHksIHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gTGFuZ0VuLndvcmRsaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIk1uZW1vbmljXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QsIGVudHJvcHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzZWVkIGZvciB0aGUgbW5lbW9uaWMuXG4gICAgICovXG4gICAgY29tcHV0ZVNlZWQoKSB7XG4gICAgICAgIGNvbnN0IHNhbHQgPSB0b1V0ZjhCeXRlcyhcIm1uZW1vbmljXCIgKyB0aGlzLnBhc3N3b3JkLCBcIk5GS0RcIik7XG4gICAgICAgIHJldHVybiBwYmtkZjIodG9VdGY4Qnl0ZXModGhpcy5waHJhc2UsIFwiTkZLRFwiKSwgc2FsdCwgMjA0OCwgNjQsIFwic2hhNTEyXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBNbmVtb25pYyBmb3IgdGhlICUlcGhyYXNlJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgJSVwYXNzd29yZCUlIGlzIHRoZSBlbXB0eSBzdHJpbmcgYW5kIHRoZSBkZWZhdWx0XG4gICAgICogIHdvcmRsaXN0IGlzIHRoZSBbRW5nbGlzaCB3b3JkbGlzdHNdKExhbmdFbikuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBjYXNlIGFuZCBzcGFjZTsgdGhyb3dzIGlmIGludmFsaWRcbiAgICAgICAgY29uc3QgZW50cm9weSA9IG1uZW1vbmljVG9FbnRyb3B5KHBocmFzZSwgd29yZGxpc3QpO1xuICAgICAgICBwaHJhc2UgPSBlbnRyb3B5VG9NbmVtb25pYyhnZXRCeXRlcyhlbnRyb3B5KSwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gbmV3IE1uZW1vbmljKF9ndWFyZCwgZW50cm9weSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqTW5lbW9uaWMqKiBmcm9tIHRoZSAlJWVudHJvcHklJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVmYXVsdCAlJXBhc3N3b3JkJSUgaXMgdGhlIGVtcHR5IHN0cmluZyBhbmQgdGhlIGRlZmF1bHRcbiAgICAgKiAgd29yZGxpc3QgaXMgdGhlIFtFbmdsaXNoIHdvcmRsaXN0c10oTGFuZ0VuKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUVudHJvcHkoX2VudHJvcHksIHBhc3N3b3JkLCB3b3JkbGlzdCkge1xuICAgICAgICBjb25zdCBlbnRyb3B5ID0gZ2V0Qnl0ZXMoX2VudHJvcHksIFwiZW50cm9weVwiKTtcbiAgICAgICAgY29uc3QgcGhyYXNlID0gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gbmV3IE1uZW1vbmljKF9ndWFyZCwgaGV4bGlmeShlbnRyb3B5KSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcGhyYXNlIGZvciAlJW1uZW1vbmljJSUuXG4gICAgICovXG4gICAgc3RhdGljIGVudHJvcHlUb1BocmFzZShfZW50cm9weSwgd29yZGxpc3QpIHtcbiAgICAgICAgY29uc3QgZW50cm9weSA9IGdldEJ5dGVzKF9lbnRyb3B5LCBcImVudHJvcHlcIik7XG4gICAgICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRyb3B5IGZvciAlJXBocmFzZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBwaHJhc2VUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCkge1xuICAgICAgICByZXR1cm4gbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVwaHJhc2UlJSBpcyBhIHZhbGlkIFtbbGluay1iaXAtMzldXSBwaHJhc2UuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjaGVja3MgYWxsIHRoZSBwcm92aWRlZCB3b3JkcyBiZWxvbmcgdG8gdGhlICUld29yZGxpc3QlJSxcbiAgICAgKiAgdGhhdCB0aGUgbGVuZ3RoIGlzIHZhbGlkIGFuZCB0aGUgY2hlY2tzdW0gaXMgY29ycmVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZE1uZW1vbmljKHBocmFzZSwgd29yZGxpc3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1uZW1vbmljVG9FbnRyb3B5KHBocmFzZSwgd29yZGxpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1uZW1vbmljLmpzLm1hcCIsIi8qISBNSVQgTGljZW5zZS4gQ29weXJpZ2h0IDIwMTUtMjAyMiBSaWNoYXJkIE1vb3JlIDxtZUByaWNtb28uY29tPi4gU2VlIExJQ0VOU0UudHh0LiAqL1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9BRVNfa2V5LCBfQUVTX0tkLCBfQUVTX0tlO1xuLy8gTnVtYmVyIG9mIHJvdW5kcyBieSBrZXlzaXplXG5jb25zdCBudW1iZXJPZlJvdW5kcyA9IHsgMTY6IDEwLCAyNDogMTIsIDMyOiAxNCB9O1xuLy8gUm91bmQgY29uc3RhbnQgd29yZHNcbmNvbnN0IHJjb24gPSBbMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNiwgMHg2YywgMHhkOCwgMHhhYiwgMHg0ZCwgMHg5YSwgMHgyZiwgMHg1ZSwgMHhiYywgMHg2MywgMHhjNiwgMHg5NywgMHgzNSwgMHg2YSwgMHhkNCwgMHhiMywgMHg3ZCwgMHhmYSwgMHhlZiwgMHhjNSwgMHg5MV07XG4vLyBTLWJveCBhbmQgSW52ZXJzZSBTLWJveCAoUyBpcyBmb3IgU3Vic3RpdHV0aW9uKVxuY29uc3QgUyA9IFsweDYzLCAweDdjLCAweDc3LCAweDdiLCAweGYyLCAweDZiLCAweDZmLCAweGM1LCAweDMwLCAweDAxLCAweDY3LCAweDJiLCAweGZlLCAweGQ3LCAweGFiLCAweDc2LCAweGNhLCAweDgyLCAweGM5LCAweDdkLCAweGZhLCAweDU5LCAweDQ3LCAweGYwLCAweGFkLCAweGQ0LCAweGEyLCAweGFmLCAweDljLCAweGE0LCAweDcyLCAweGMwLCAweGI3LCAweGZkLCAweDkzLCAweDI2LCAweDM2LCAweDNmLCAweGY3LCAweGNjLCAweDM0LCAweGE1LCAweGU1LCAweGYxLCAweDcxLCAweGQ4LCAweDMxLCAweDE1LCAweDA0LCAweGM3LCAweDIzLCAweGMzLCAweDE4LCAweDk2LCAweDA1LCAweDlhLCAweDA3LCAweDEyLCAweDgwLCAweGUyLCAweGViLCAweDI3LCAweGIyLCAweDc1LCAweDA5LCAweDgzLCAweDJjLCAweDFhLCAweDFiLCAweDZlLCAweDVhLCAweGEwLCAweDUyLCAweDNiLCAweGQ2LCAweGIzLCAweDI5LCAweGUzLCAweDJmLCAweDg0LCAweDUzLCAweGQxLCAweDAwLCAweGVkLCAweDIwLCAweGZjLCAweGIxLCAweDViLCAweDZhLCAweGNiLCAweGJlLCAweDM5LCAweDRhLCAweDRjLCAweDU4LCAweGNmLCAweGQwLCAweGVmLCAweGFhLCAweGZiLCAweDQzLCAweDRkLCAweDMzLCAweDg1LCAweDQ1LCAweGY5LCAweDAyLCAweDdmLCAweDUwLCAweDNjLCAweDlmLCAweGE4LCAweDUxLCAweGEzLCAweDQwLCAweDhmLCAweDkyLCAweDlkLCAweDM4LCAweGY1LCAweGJjLCAweGI2LCAweGRhLCAweDIxLCAweDEwLCAweGZmLCAweGYzLCAweGQyLCAweGNkLCAweDBjLCAweDEzLCAweGVjLCAweDVmLCAweDk3LCAweDQ0LCAweDE3LCAweGM0LCAweGE3LCAweDdlLCAweDNkLCAweDY0LCAweDVkLCAweDE5LCAweDczLCAweDYwLCAweDgxLCAweDRmLCAweGRjLCAweDIyLCAweDJhLCAweDkwLCAweDg4LCAweDQ2LCAweGVlLCAweGI4LCAweDE0LCAweGRlLCAweDVlLCAweDBiLCAweGRiLCAweGUwLCAweDMyLCAweDNhLCAweDBhLCAweDQ5LCAweDA2LCAweDI0LCAweDVjLCAweGMyLCAweGQzLCAweGFjLCAweDYyLCAweDkxLCAweDk1LCAweGU0LCAweDc5LCAweGU3LCAweGM4LCAweDM3LCAweDZkLCAweDhkLCAweGQ1LCAweDRlLCAweGE5LCAweDZjLCAweDU2LCAweGY0LCAweGVhLCAweDY1LCAweDdhLCAweGFlLCAweDA4LCAweGJhLCAweDc4LCAweDI1LCAweDJlLCAweDFjLCAweGE2LCAweGI0LCAweGM2LCAweGU4LCAweGRkLCAweDc0LCAweDFmLCAweDRiLCAweGJkLCAweDhiLCAweDhhLCAweDcwLCAweDNlLCAweGI1LCAweDY2LCAweDQ4LCAweDAzLCAweGY2LCAweDBlLCAweDYxLCAweDM1LCAweDU3LCAweGI5LCAweDg2LCAweGMxLCAweDFkLCAweDllLCAweGUxLCAweGY4LCAweDk4LCAweDExLCAweDY5LCAweGQ5LCAweDhlLCAweDk0LCAweDliLCAweDFlLCAweDg3LCAweGU5LCAweGNlLCAweDU1LCAweDI4LCAweGRmLCAweDhjLCAweGExLCAweDg5LCAweDBkLCAweGJmLCAweGU2LCAweDQyLCAweDY4LCAweDQxLCAweDk5LCAweDJkLCAweDBmLCAweGIwLCAweDU0LCAweGJiLCAweDE2XTtcbmNvbnN0IFNpID0gWzB4NTIsIDB4MDksIDB4NmEsIDB4ZDUsIDB4MzAsIDB4MzYsIDB4YTUsIDB4MzgsIDB4YmYsIDB4NDAsIDB4YTMsIDB4OWUsIDB4ODEsIDB4ZjMsIDB4ZDcsIDB4ZmIsIDB4N2MsIDB4ZTMsIDB4MzksIDB4ODIsIDB4OWIsIDB4MmYsIDB4ZmYsIDB4ODcsIDB4MzQsIDB4OGUsIDB4NDMsIDB4NDQsIDB4YzQsIDB4ZGUsIDB4ZTksIDB4Y2IsIDB4NTQsIDB4N2IsIDB4OTQsIDB4MzIsIDB4YTYsIDB4YzIsIDB4MjMsIDB4M2QsIDB4ZWUsIDB4NGMsIDB4OTUsIDB4MGIsIDB4NDIsIDB4ZmEsIDB4YzMsIDB4NGUsIDB4MDgsIDB4MmUsIDB4YTEsIDB4NjYsIDB4MjgsIDB4ZDksIDB4MjQsIDB4YjIsIDB4NzYsIDB4NWIsIDB4YTIsIDB4NDksIDB4NmQsIDB4OGIsIDB4ZDEsIDB4MjUsIDB4NzIsIDB4ZjgsIDB4ZjYsIDB4NjQsIDB4ODYsIDB4NjgsIDB4OTgsIDB4MTYsIDB4ZDQsIDB4YTQsIDB4NWMsIDB4Y2MsIDB4NWQsIDB4NjUsIDB4YjYsIDB4OTIsIDB4NmMsIDB4NzAsIDB4NDgsIDB4NTAsIDB4ZmQsIDB4ZWQsIDB4YjksIDB4ZGEsIDB4NWUsIDB4MTUsIDB4NDYsIDB4NTcsIDB4YTcsIDB4OGQsIDB4OWQsIDB4ODQsIDB4OTAsIDB4ZDgsIDB4YWIsIDB4MDAsIDB4OGMsIDB4YmMsIDB4ZDMsIDB4MGEsIDB4ZjcsIDB4ZTQsIDB4NTgsIDB4MDUsIDB4YjgsIDB4YjMsIDB4NDUsIDB4MDYsIDB4ZDAsIDB4MmMsIDB4MWUsIDB4OGYsIDB4Y2EsIDB4M2YsIDB4MGYsIDB4MDIsIDB4YzEsIDB4YWYsIDB4YmQsIDB4MDMsIDB4MDEsIDB4MTMsIDB4OGEsIDB4NmIsIDB4M2EsIDB4OTEsIDB4MTEsIDB4NDEsIDB4NGYsIDB4NjcsIDB4ZGMsIDB4ZWEsIDB4OTcsIDB4ZjIsIDB4Y2YsIDB4Y2UsIDB4ZjAsIDB4YjQsIDB4ZTYsIDB4NzMsIDB4OTYsIDB4YWMsIDB4NzQsIDB4MjIsIDB4ZTcsIDB4YWQsIDB4MzUsIDB4ODUsIDB4ZTIsIDB4ZjksIDB4MzcsIDB4ZTgsIDB4MWMsIDB4NzUsIDB4ZGYsIDB4NmUsIDB4NDcsIDB4ZjEsIDB4MWEsIDB4NzEsIDB4MWQsIDB4MjksIDB4YzUsIDB4ODksIDB4NmYsIDB4YjcsIDB4NjIsIDB4MGUsIDB4YWEsIDB4MTgsIDB4YmUsIDB4MWIsIDB4ZmMsIDB4NTYsIDB4M2UsIDB4NGIsIDB4YzYsIDB4ZDIsIDB4NzksIDB4MjAsIDB4OWEsIDB4ZGIsIDB4YzAsIDB4ZmUsIDB4NzgsIDB4Y2QsIDB4NWEsIDB4ZjQsIDB4MWYsIDB4ZGQsIDB4YTgsIDB4MzMsIDB4ODgsIDB4MDcsIDB4YzcsIDB4MzEsIDB4YjEsIDB4MTIsIDB4MTAsIDB4NTksIDB4MjcsIDB4ODAsIDB4ZWMsIDB4NWYsIDB4NjAsIDB4NTEsIDB4N2YsIDB4YTksIDB4MTksIDB4YjUsIDB4NGEsIDB4MGQsIDB4MmQsIDB4ZTUsIDB4N2EsIDB4OWYsIDB4OTMsIDB4YzksIDB4OWMsIDB4ZWYsIDB4YTAsIDB4ZTAsIDB4M2IsIDB4NGQsIDB4YWUsIDB4MmEsIDB4ZjUsIDB4YjAsIDB4YzgsIDB4ZWIsIDB4YmIsIDB4M2MsIDB4ODMsIDB4NTMsIDB4OTksIDB4NjEsIDB4MTcsIDB4MmIsIDB4MDQsIDB4N2UsIDB4YmEsIDB4NzcsIDB4ZDYsIDB4MjYsIDB4ZTEsIDB4NjksIDB4MTQsIDB4NjMsIDB4NTUsIDB4MjEsIDB4MGMsIDB4N2RdO1xuLy8gVHJhbnNmb3JtYXRpb25zIGZvciBlbmNyeXB0aW9uXG5jb25zdCBUMSA9IFsweGM2NjM2M2E1LCAweGY4N2M3Yzg0LCAweGVlNzc3Nzk5LCAweGY2N2I3YjhkLCAweGZmZjJmMjBkLCAweGQ2NmI2YmJkLCAweGRlNmY2ZmIxLCAweDkxYzVjNTU0LCAweDYwMzAzMDUwLCAweDAyMDEwMTAzLCAweGNlNjc2N2E5LCAweDU2MmIyYjdkLCAweGU3ZmVmZTE5LCAweGI1ZDdkNzYyLCAweDRkYWJhYmU2LCAweGVjNzY3NjlhLCAweDhmY2FjYTQ1LCAweDFmODI4MjlkLCAweDg5YzljOTQwLCAweGZhN2Q3ZDg3LCAweGVmZmFmYTE1LCAweGIyNTk1OWViLCAweDhlNDc0N2M5LCAweGZiZjBmMDBiLCAweDQxYWRhZGVjLCAweGIzZDRkNDY3LCAweDVmYTJhMmZkLCAweDQ1YWZhZmVhLCAweDIzOWM5Y2JmLCAweDUzYTRhNGY3LCAweGU0NzI3Mjk2LCAweDliYzBjMDViLCAweDc1YjdiN2MyLCAweGUxZmRmZDFjLCAweDNkOTM5M2FlLCAweDRjMjYyNjZhLCAweDZjMzYzNjVhLCAweDdlM2YzZjQxLCAweGY1ZjdmNzAyLCAweDgzY2NjYzRmLCAweDY4MzQzNDVjLCAweDUxYTVhNWY0LCAweGQxZTVlNTM0LCAweGY5ZjFmMTA4LCAweGUyNzE3MTkzLCAweGFiZDhkODczLCAweDYyMzEzMTUzLCAweDJhMTUxNTNmLCAweDA4MDQwNDBjLCAweDk1YzdjNzUyLCAweDQ2MjMyMzY1LCAweDlkYzNjMzVlLCAweDMwMTgxODI4LCAweDM3OTY5NmExLCAweDBhMDUwNTBmLCAweDJmOWE5YWI1LCAweDBlMDcwNzA5LCAweDI0MTIxMjM2LCAweDFiODA4MDliLCAweGRmZTJlMjNkLCAweGNkZWJlYjI2LCAweDRlMjcyNzY5LCAweDdmYjJiMmNkLCAweGVhNzU3NTlmLCAweDEyMDkwOTFiLCAweDFkODM4MzllLCAweDU4MmMyYzc0LCAweDM0MWExYTJlLCAweDM2MWIxYjJkLCAweGRjNmU2ZWIyLCAweGI0NWE1YWVlLCAweDViYTBhMGZiLCAweGE0NTI1MmY2LCAweDc2M2IzYjRkLCAweGI3ZDZkNjYxLCAweDdkYjNiM2NlLCAweDUyMjkyOTdiLCAweGRkZTNlMzNlLCAweDVlMmYyZjcxLCAweDEzODQ4NDk3LCAweGE2NTM1M2Y1LCAweGI5ZDFkMTY4LCAweDAwMDAwMDAwLCAweGMxZWRlZDJjLCAweDQwMjAyMDYwLCAweGUzZmNmYzFmLCAweDc5YjFiMWM4LCAweGI2NWI1YmVkLCAweGQ0NmE2YWJlLCAweDhkY2JjYjQ2LCAweDY3YmViZWQ5LCAweDcyMzkzOTRiLCAweDk0NGE0YWRlLCAweDk4NGM0Y2Q0LCAweGIwNTg1OGU4LCAweDg1Y2ZjZjRhLCAweGJiZDBkMDZiLCAweGM1ZWZlZjJhLCAweDRmYWFhYWU1LCAweGVkZmJmYjE2LCAweDg2NDM0M2M1LCAweDlhNGQ0ZGQ3LCAweDY2MzMzMzU1LCAweDExODU4NTk0LCAweDhhNDU0NWNmLCAweGU5ZjlmOTEwLCAweDA0MDIwMjA2LCAweGZlN2Y3ZjgxLCAweGEwNTA1MGYwLCAweDc4M2MzYzQ0LCAweDI1OWY5ZmJhLCAweDRiYThhOGUzLCAweGEyNTE1MWYzLCAweDVkYTNhM2ZlLCAweDgwNDA0MGMwLCAweDA1OGY4ZjhhLCAweDNmOTI5MmFkLCAweDIxOWQ5ZGJjLCAweDcwMzgzODQ4LCAweGYxZjVmNTA0LCAweDYzYmNiY2RmLCAweDc3YjZiNmMxLCAweGFmZGFkYTc1LCAweDQyMjEyMTYzLCAweDIwMTAxMDMwLCAweGU1ZmZmZjFhLCAweGZkZjNmMzBlLCAweGJmZDJkMjZkLCAweDgxY2RjZDRjLCAweDE4MGMwYzE0LCAweDI2MTMxMzM1LCAweGMzZWNlYzJmLCAweGJlNWY1ZmUxLCAweDM1OTc5N2EyLCAweDg4NDQ0NGNjLCAweDJlMTcxNzM5LCAweDkzYzRjNDU3LCAweDU1YTdhN2YyLCAweGZjN2U3ZTgyLCAweDdhM2QzZDQ3LCAweGM4NjQ2NGFjLCAweGJhNWQ1ZGU3LCAweDMyMTkxOTJiLCAweGU2NzM3Mzk1LCAweGMwNjA2MGEwLCAweDE5ODE4MTk4LCAweDllNGY0ZmQxLCAweGEzZGNkYzdmLCAweDQ0MjIyMjY2LCAweDU0MmEyYTdlLCAweDNiOTA5MGFiLCAweDBiODg4ODgzLCAweDhjNDY0NmNhLCAweGM3ZWVlZTI5LCAweDZiYjhiOGQzLCAweDI4MTQxNDNjLCAweGE3ZGVkZTc5LCAweGJjNWU1ZWUyLCAweDE2MGIwYjFkLCAweGFkZGJkYjc2LCAweGRiZTBlMDNiLCAweDY0MzIzMjU2LCAweDc0M2EzYTRlLCAweDE0MGEwYTFlLCAweDkyNDk0OWRiLCAweDBjMDYwNjBhLCAweDQ4MjQyNDZjLCAweGI4NWM1Y2U0LCAweDlmYzJjMjVkLCAweGJkZDNkMzZlLCAweDQzYWNhY2VmLCAweGM0NjI2MmE2LCAweDM5OTE5MWE4LCAweDMxOTU5NWE0LCAweGQzZTRlNDM3LCAweGYyNzk3OThiLCAweGQ1ZTdlNzMyLCAweDhiYzhjODQzLCAweDZlMzczNzU5LCAweGRhNmQ2ZGI3LCAweDAxOGQ4ZDhjLCAweGIxZDVkNTY0LCAweDljNGU0ZWQyLCAweDQ5YTlhOWUwLCAweGQ4NmM2Y2I0LCAweGFjNTY1NmZhLCAweGYzZjRmNDA3LCAweGNmZWFlYTI1LCAweGNhNjU2NWFmLCAweGY0N2E3YThlLCAweDQ3YWVhZWU5LCAweDEwMDgwODE4LCAweDZmYmFiYWQ1LCAweGYwNzg3ODg4LCAweDRhMjUyNTZmLCAweDVjMmUyZTcyLCAweDM4MWMxYzI0LCAweDU3YTZhNmYxLCAweDczYjRiNGM3LCAweDk3YzZjNjUxLCAweGNiZThlODIzLCAweGExZGRkZDdjLCAweGU4NzQ3NDljLCAweDNlMWYxZjIxLCAweDk2NGI0YmRkLCAweDYxYmRiZGRjLCAweDBkOGI4Yjg2LCAweDBmOGE4YTg1LCAweGUwNzA3MDkwLCAweDdjM2UzZTQyLCAweDcxYjViNWM0LCAweGNjNjY2NmFhLCAweDkwNDg0OGQ4LCAweDA2MDMwMzA1LCAweGY3ZjZmNjAxLCAweDFjMGUwZTEyLCAweGMyNjE2MWEzLCAweDZhMzUzNTVmLCAweGFlNTc1N2Y5LCAweDY5YjliOWQwLCAweDE3ODY4NjkxLCAweDk5YzFjMTU4LCAweDNhMWQxZDI3LCAweDI3OWU5ZWI5LCAweGQ5ZTFlMTM4LCAweGViZjhmODEzLCAweDJiOTg5OGIzLCAweDIyMTExMTMzLCAweGQyNjk2OWJiLCAweGE5ZDlkOTcwLCAweDA3OGU4ZTg5LCAweDMzOTQ5NGE3LCAweDJkOWI5YmI2LCAweDNjMWUxZTIyLCAweDE1ODc4NzkyLCAweGM5ZTllOTIwLCAweDg3Y2VjZTQ5LCAweGFhNTU1NWZmLCAweDUwMjgyODc4LCAweGE1ZGZkZjdhLCAweDAzOGM4YzhmLCAweDU5YTFhMWY4LCAweDA5ODk4OTgwLCAweDFhMGQwZDE3LCAweDY1YmZiZmRhLCAweGQ3ZTZlNjMxLCAweDg0NDI0MmM2LCAweGQwNjg2OGI4LCAweDgyNDE0MWMzLCAweDI5OTk5OWIwLCAweDVhMmQyZDc3LCAweDFlMGYwZjExLCAweDdiYjBiMGNiLCAweGE4NTQ1NGZjLCAweDZkYmJiYmQ2LCAweDJjMTYxNjNhXTtcbmNvbnN0IFQyID0gWzB4YTVjNjYzNjMsIDB4ODRmODdjN2MsIDB4OTllZTc3NzcsIDB4OGRmNjdiN2IsIDB4MGRmZmYyZjIsIDB4YmRkNjZiNmIsIDB4YjFkZTZmNmYsIDB4NTQ5MWM1YzUsIDB4NTA2MDMwMzAsIDB4MDMwMjAxMDEsIDB4YTljZTY3NjcsIDB4N2Q1NjJiMmIsIDB4MTllN2ZlZmUsIDB4NjJiNWQ3ZDcsIDB4ZTY0ZGFiYWIsIDB4OWFlYzc2NzYsIDB4NDU4ZmNhY2EsIDB4OWQxZjgyODIsIDB4NDA4OWM5YzksIDB4ODdmYTdkN2QsIDB4MTVlZmZhZmEsIDB4ZWJiMjU5NTksIDB4Yzk4ZTQ3NDcsIDB4MGJmYmYwZjAsIDB4ZWM0MWFkYWQsIDB4NjdiM2Q0ZDQsIDB4ZmQ1ZmEyYTIsIDB4ZWE0NWFmYWYsIDB4YmYyMzljOWMsIDB4Zjc1M2E0YTQsIDB4OTZlNDcyNzIsIDB4NWI5YmMwYzAsIDB4YzI3NWI3YjcsIDB4MWNlMWZkZmQsIDB4YWUzZDkzOTMsIDB4NmE0YzI2MjYsIDB4NWE2YzM2MzYsIDB4NDE3ZTNmM2YsIDB4MDJmNWY3ZjcsIDB4NGY4M2NjY2MsIDB4NWM2ODM0MzQsIDB4ZjQ1MWE1YTUsIDB4MzRkMWU1ZTUsIDB4MDhmOWYxZjEsIDB4OTNlMjcxNzEsIDB4NzNhYmQ4ZDgsIDB4NTM2MjMxMzEsIDB4M2YyYTE1MTUsIDB4MGMwODA0MDQsIDB4NTI5NWM3YzcsIDB4NjU0NjIzMjMsIDB4NWU5ZGMzYzMsIDB4MjgzMDE4MTgsIDB4YTEzNzk2OTYsIDB4MGYwYTA1MDUsIDB4YjUyZjlhOWEsIDB4MDkwZTA3MDcsIDB4MzYyNDEyMTIsIDB4OWIxYjgwODAsIDB4M2RkZmUyZTIsIDB4MjZjZGViZWIsIDB4Njk0ZTI3MjcsIDB4Y2Q3ZmIyYjIsIDB4OWZlYTc1NzUsIDB4MWIxMjA5MDksIDB4OWUxZDgzODMsIDB4NzQ1ODJjMmMsIDB4MmUzNDFhMWEsIDB4MmQzNjFiMWIsIDB4YjJkYzZlNmUsIDB4ZWViNDVhNWEsIDB4ZmI1YmEwYTAsIDB4ZjZhNDUyNTIsIDB4NGQ3NjNiM2IsIDB4NjFiN2Q2ZDYsIDB4Y2U3ZGIzYjMsIDB4N2I1MjI5MjksIDB4M2VkZGUzZTMsIDB4NzE1ZTJmMmYsIDB4OTcxMzg0ODQsIDB4ZjVhNjUzNTMsIDB4NjhiOWQxZDEsIDB4MDAwMDAwMDAsIDB4MmNjMWVkZWQsIDB4NjA0MDIwMjAsIDB4MWZlM2ZjZmMsIDB4Yzg3OWIxYjEsIDB4ZWRiNjViNWIsIDB4YmVkNDZhNmEsIDB4NDY4ZGNiY2IsIDB4ZDk2N2JlYmUsIDB4NGI3MjM5MzksIDB4ZGU5NDRhNGEsIDB4ZDQ5ODRjNGMsIDB4ZThiMDU4NTgsIDB4NGE4NWNmY2YsIDB4NmJiYmQwZDAsIDB4MmFjNWVmZWYsIDB4ZTU0ZmFhYWEsIDB4MTZlZGZiZmIsIDB4YzU4NjQzNDMsIDB4ZDc5YTRkNGQsIDB4NTU2NjMzMzMsIDB4OTQxMTg1ODUsIDB4Y2Y4YTQ1NDUsIDB4MTBlOWY5ZjksIDB4MDYwNDAyMDIsIDB4ODFmZTdmN2YsIDB4ZjBhMDUwNTAsIDB4NDQ3ODNjM2MsIDB4YmEyNTlmOWYsIDB4ZTM0YmE4YTgsIDB4ZjNhMjUxNTEsIDB4ZmU1ZGEzYTMsIDB4YzA4MDQwNDAsIDB4OGEwNThmOGYsIDB4YWQzZjkyOTIsIDB4YmMyMTlkOWQsIDB4NDg3MDM4MzgsIDB4MDRmMWY1ZjUsIDB4ZGY2M2JjYmMsIDB4YzE3N2I2YjYsIDB4NzVhZmRhZGEsIDB4NjM0MjIxMjEsIDB4MzAyMDEwMTAsIDB4MWFlNWZmZmYsIDB4MGVmZGYzZjMsIDB4NmRiZmQyZDIsIDB4NGM4MWNkY2QsIDB4MTQxODBjMGMsIDB4MzUyNjEzMTMsIDB4MmZjM2VjZWMsIDB4ZTFiZTVmNWYsIDB4YTIzNTk3OTcsIDB4Y2M4ODQ0NDQsIDB4MzkyZTE3MTcsIDB4NTc5M2M0YzQsIDB4ZjI1NWE3YTcsIDB4ODJmYzdlN2UsIDB4NDc3YTNkM2QsIDB4YWNjODY0NjQsIDB4ZTdiYTVkNWQsIDB4MmIzMjE5MTksIDB4OTVlNjczNzMsIDB4YTBjMDYwNjAsIDB4OTgxOTgxODEsIDB4ZDE5ZTRmNGYsIDB4N2ZhM2RjZGMsIDB4NjY0NDIyMjIsIDB4N2U1NDJhMmEsIDB4YWIzYjkwOTAsIDB4ODMwYjg4ODgsIDB4Y2E4YzQ2NDYsIDB4MjljN2VlZWUsIDB4ZDM2YmI4YjgsIDB4M2MyODE0MTQsIDB4NzlhN2RlZGUsIDB4ZTJiYzVlNWUsIDB4MWQxNjBiMGIsIDB4NzZhZGRiZGIsIDB4M2JkYmUwZTAsIDB4NTY2NDMyMzIsIDB4NGU3NDNhM2EsIDB4MWUxNDBhMGEsIDB4ZGI5MjQ5NDksIDB4MGEwYzA2MDYsIDB4NmM0ODI0MjQsIDB4ZTRiODVjNWMsIDB4NWQ5ZmMyYzIsIDB4NmViZGQzZDMsIDB4ZWY0M2FjYWMsIDB4YTZjNDYyNjIsIDB4YTgzOTkxOTEsIDB4YTQzMTk1OTUsIDB4MzdkM2U0ZTQsIDB4OGJmMjc5NzksIDB4MzJkNWU3ZTcsIDB4NDM4YmM4YzgsIDB4NTk2ZTM3MzcsIDB4YjdkYTZkNmQsIDB4OGMwMThkOGQsIDB4NjRiMWQ1ZDUsIDB4ZDI5YzRlNGUsIDB4ZTA0OWE5YTksIDB4YjRkODZjNmMsIDB4ZmFhYzU2NTYsIDB4MDdmM2Y0ZjQsIDB4MjVjZmVhZWEsIDB4YWZjYTY1NjUsIDB4OGVmNDdhN2EsIDB4ZTk0N2FlYWUsIDB4MTgxMDA4MDgsIDB4ZDU2ZmJhYmEsIDB4ODhmMDc4NzgsIDB4NmY0YTI1MjUsIDB4NzI1YzJlMmUsIDB4MjQzODFjMWMsIDB4ZjE1N2E2YTYsIDB4Yzc3M2I0YjQsIDB4NTE5N2M2YzYsIDB4MjNjYmU4ZTgsIDB4N2NhMWRkZGQsIDB4OWNlODc0NzQsIDB4MjEzZTFmMWYsIDB4ZGQ5NjRiNGIsIDB4ZGM2MWJkYmQsIDB4ODYwZDhiOGIsIDB4ODUwZjhhOGEsIDB4OTBlMDcwNzAsIDB4NDI3YzNlM2UsIDB4YzQ3MWI1YjUsIDB4YWFjYzY2NjYsIDB4ZDg5MDQ4NDgsIDB4MDUwNjAzMDMsIDB4MDFmN2Y2ZjYsIDB4MTIxYzBlMGUsIDB4YTNjMjYxNjEsIDB4NWY2YTM1MzUsIDB4ZjlhZTU3NTcsIDB4ZDA2OWI5YjksIDB4OTExNzg2ODYsIDB4NTg5OWMxYzEsIDB4MjczYTFkMWQsIDB4YjkyNzllOWUsIDB4MzhkOWUxZTEsIDB4MTNlYmY4ZjgsIDB4YjMyYjk4OTgsIDB4MzMyMjExMTEsIDB4YmJkMjY5NjksIDB4NzBhOWQ5ZDksIDB4ODkwNzhlOGUsIDB4YTczMzk0OTQsIDB4YjYyZDliOWIsIDB4MjIzYzFlMWUsIDB4OTIxNTg3ODcsIDB4MjBjOWU5ZTksIDB4NDk4N2NlY2UsIDB4ZmZhYTU1NTUsIDB4Nzg1MDI4MjgsIDB4N2FhNWRmZGYsIDB4OGYwMzhjOGMsIDB4Zjg1OWExYTEsIDB4ODAwOTg5ODksIDB4MTcxYTBkMGQsIDB4ZGE2NWJmYmYsIDB4MzFkN2U2ZTYsIDB4YzY4NDQyNDIsIDB4YjhkMDY4NjgsIDB4YzM4MjQxNDEsIDB4YjAyOTk5OTksIDB4Nzc1YTJkMmQsIDB4MTExZTBmMGYsIDB4Y2I3YmIwYjAsIDB4ZmNhODU0NTQsIDB4ZDY2ZGJiYmIsIDB4M2EyYzE2MTZdO1xuY29uc3QgVDMgPSBbMHg2M2E1YzY2MywgMHg3Yzg0Zjg3YywgMHg3Nzk5ZWU3NywgMHg3YjhkZjY3YiwgMHhmMjBkZmZmMiwgMHg2YmJkZDY2YiwgMHg2ZmIxZGU2ZiwgMHhjNTU0OTFjNSwgMHgzMDUwNjAzMCwgMHgwMTAzMDIwMSwgMHg2N2E5Y2U2NywgMHgyYjdkNTYyYiwgMHhmZTE5ZTdmZSwgMHhkNzYyYjVkNywgMHhhYmU2NGRhYiwgMHg3NjlhZWM3NiwgMHhjYTQ1OGZjYSwgMHg4MjlkMWY4MiwgMHhjOTQwODljOSwgMHg3ZDg3ZmE3ZCwgMHhmYTE1ZWZmYSwgMHg1OWViYjI1OSwgMHg0N2M5OGU0NywgMHhmMDBiZmJmMCwgMHhhZGVjNDFhZCwgMHhkNDY3YjNkNCwgMHhhMmZkNWZhMiwgMHhhZmVhNDVhZiwgMHg5Y2JmMjM5YywgMHhhNGY3NTNhNCwgMHg3Mjk2ZTQ3MiwgMHhjMDViOWJjMCwgMHhiN2MyNzViNywgMHhmZDFjZTFmZCwgMHg5M2FlM2Q5MywgMHgyNjZhNGMyNiwgMHgzNjVhNmMzNiwgMHgzZjQxN2UzZiwgMHhmNzAyZjVmNywgMHhjYzRmODNjYywgMHgzNDVjNjgzNCwgMHhhNWY0NTFhNSwgMHhlNTM0ZDFlNSwgMHhmMTA4ZjlmMSwgMHg3MTkzZTI3MSwgMHhkODczYWJkOCwgMHgzMTUzNjIzMSwgMHgxNTNmMmExNSwgMHgwNDBjMDgwNCwgMHhjNzUyOTVjNywgMHgyMzY1NDYyMywgMHhjMzVlOWRjMywgMHgxODI4MzAxOCwgMHg5NmExMzc5NiwgMHgwNTBmMGEwNSwgMHg5YWI1MmY5YSwgMHgwNzA5MGUwNywgMHgxMjM2MjQxMiwgMHg4MDliMWI4MCwgMHhlMjNkZGZlMiwgMHhlYjI2Y2RlYiwgMHgyNzY5NGUyNywgMHhiMmNkN2ZiMiwgMHg3NTlmZWE3NSwgMHgwOTFiMTIwOSwgMHg4MzllMWQ4MywgMHgyYzc0NTgyYywgMHgxYTJlMzQxYSwgMHgxYjJkMzYxYiwgMHg2ZWIyZGM2ZSwgMHg1YWVlYjQ1YSwgMHhhMGZiNWJhMCwgMHg1MmY2YTQ1MiwgMHgzYjRkNzYzYiwgMHhkNjYxYjdkNiwgMHhiM2NlN2RiMywgMHgyOTdiNTIyOSwgMHhlMzNlZGRlMywgMHgyZjcxNWUyZiwgMHg4NDk3MTM4NCwgMHg1M2Y1YTY1MywgMHhkMTY4YjlkMSwgMHgwMDAwMDAwMCwgMHhlZDJjYzFlZCwgMHgyMDYwNDAyMCwgMHhmYzFmZTNmYywgMHhiMWM4NzliMSwgMHg1YmVkYjY1YiwgMHg2YWJlZDQ2YSwgMHhjYjQ2OGRjYiwgMHhiZWQ5NjdiZSwgMHgzOTRiNzIzOSwgMHg0YWRlOTQ0YSwgMHg0Y2Q0OTg0YywgMHg1OGU4YjA1OCwgMHhjZjRhODVjZiwgMHhkMDZiYmJkMCwgMHhlZjJhYzVlZiwgMHhhYWU1NGZhYSwgMHhmYjE2ZWRmYiwgMHg0M2M1ODY0MywgMHg0ZGQ3OWE0ZCwgMHgzMzU1NjYzMywgMHg4NTk0MTE4NSwgMHg0NWNmOGE0NSwgMHhmOTEwZTlmOSwgMHgwMjA2MDQwMiwgMHg3ZjgxZmU3ZiwgMHg1MGYwYTA1MCwgMHgzYzQ0NzgzYywgMHg5ZmJhMjU5ZiwgMHhhOGUzNGJhOCwgMHg1MWYzYTI1MSwgMHhhM2ZlNWRhMywgMHg0MGMwODA0MCwgMHg4ZjhhMDU4ZiwgMHg5MmFkM2Y5MiwgMHg5ZGJjMjE5ZCwgMHgzODQ4NzAzOCwgMHhmNTA0ZjFmNSwgMHhiY2RmNjNiYywgMHhiNmMxNzdiNiwgMHhkYTc1YWZkYSwgMHgyMTYzNDIyMSwgMHgxMDMwMjAxMCwgMHhmZjFhZTVmZiwgMHhmMzBlZmRmMywgMHhkMjZkYmZkMiwgMHhjZDRjODFjZCwgMHgwYzE0MTgwYywgMHgxMzM1MjYxMywgMHhlYzJmYzNlYywgMHg1ZmUxYmU1ZiwgMHg5N2EyMzU5NywgMHg0NGNjODg0NCwgMHgxNzM5MmUxNywgMHhjNDU3OTNjNCwgMHhhN2YyNTVhNywgMHg3ZTgyZmM3ZSwgMHgzZDQ3N2EzZCwgMHg2NGFjYzg2NCwgMHg1ZGU3YmE1ZCwgMHgxOTJiMzIxOSwgMHg3Mzk1ZTY3MywgMHg2MGEwYzA2MCwgMHg4MTk4MTk4MSwgMHg0ZmQxOWU0ZiwgMHhkYzdmYTNkYywgMHgyMjY2NDQyMiwgMHgyYTdlNTQyYSwgMHg5MGFiM2I5MCwgMHg4ODgzMGI4OCwgMHg0NmNhOGM0NiwgMHhlZTI5YzdlZSwgMHhiOGQzNmJiOCwgMHgxNDNjMjgxNCwgMHhkZTc5YTdkZSwgMHg1ZWUyYmM1ZSwgMHgwYjFkMTYwYiwgMHhkYjc2YWRkYiwgMHhlMDNiZGJlMCwgMHgzMjU2NjQzMiwgMHgzYTRlNzQzYSwgMHgwYTFlMTQwYSwgMHg0OWRiOTI0OSwgMHgwNjBhMGMwNiwgMHgyNDZjNDgyNCwgMHg1Y2U0Yjg1YywgMHhjMjVkOWZjMiwgMHhkMzZlYmRkMywgMHhhY2VmNDNhYywgMHg2MmE2YzQ2MiwgMHg5MWE4Mzk5MSwgMHg5NWE0MzE5NSwgMHhlNDM3ZDNlNCwgMHg3OThiZjI3OSwgMHhlNzMyZDVlNywgMHhjODQzOGJjOCwgMHgzNzU5NmUzNywgMHg2ZGI3ZGE2ZCwgMHg4ZDhjMDE4ZCwgMHhkNTY0YjFkNSwgMHg0ZWQyOWM0ZSwgMHhhOWUwNDlhOSwgMHg2Y2I0ZDg2YywgMHg1NmZhYWM1NiwgMHhmNDA3ZjNmNCwgMHhlYTI1Y2ZlYSwgMHg2NWFmY2E2NSwgMHg3YThlZjQ3YSwgMHhhZWU5NDdhZSwgMHgwODE4MTAwOCwgMHhiYWQ1NmZiYSwgMHg3ODg4ZjA3OCwgMHgyNTZmNGEyNSwgMHgyZTcyNWMyZSwgMHgxYzI0MzgxYywgMHhhNmYxNTdhNiwgMHhiNGM3NzNiNCwgMHhjNjUxOTdjNiwgMHhlODIzY2JlOCwgMHhkZDdjYTFkZCwgMHg3NDljZTg3NCwgMHgxZjIxM2UxZiwgMHg0YmRkOTY0YiwgMHhiZGRjNjFiZCwgMHg4Yjg2MGQ4YiwgMHg4YTg1MGY4YSwgMHg3MDkwZTA3MCwgMHgzZTQyN2MzZSwgMHhiNWM0NzFiNSwgMHg2NmFhY2M2NiwgMHg0OGQ4OTA0OCwgMHgwMzA1MDYwMywgMHhmNjAxZjdmNiwgMHgwZTEyMWMwZSwgMHg2MWEzYzI2MSwgMHgzNTVmNmEzNSwgMHg1N2Y5YWU1NywgMHhiOWQwNjliOSwgMHg4NjkxMTc4NiwgMHhjMTU4OTljMSwgMHgxZDI3M2ExZCwgMHg5ZWI5Mjc5ZSwgMHhlMTM4ZDllMSwgMHhmODEzZWJmOCwgMHg5OGIzMmI5OCwgMHgxMTMzMjIxMSwgMHg2OWJiZDI2OSwgMHhkOTcwYTlkOSwgMHg4ZTg5MDc4ZSwgMHg5NGE3MzM5NCwgMHg5YmI2MmQ5YiwgMHgxZTIyM2MxZSwgMHg4NzkyMTU4NywgMHhlOTIwYzllOSwgMHhjZTQ5ODdjZSwgMHg1NWZmYWE1NSwgMHgyODc4NTAyOCwgMHhkZjdhYTVkZiwgMHg4YzhmMDM4YywgMHhhMWY4NTlhMSwgMHg4OTgwMDk4OSwgMHgwZDE3MWEwZCwgMHhiZmRhNjViZiwgMHhlNjMxZDdlNiwgMHg0MmM2ODQ0MiwgMHg2OGI4ZDA2OCwgMHg0MWMzODI0MSwgMHg5OWIwMjk5OSwgMHgyZDc3NWEyZCwgMHgwZjExMWUwZiwgMHhiMGNiN2JiMCwgMHg1NGZjYTg1NCwgMHhiYmQ2NmRiYiwgMHgxNjNhMmMxNl07XG5jb25zdCBUNCA9IFsweDYzNjNhNWM2LCAweDdjN2M4NGY4LCAweDc3Nzc5OWVlLCAweDdiN2I4ZGY2LCAweGYyZjIwZGZmLCAweDZiNmJiZGQ2LCAweDZmNmZiMWRlLCAweGM1YzU1NDkxLCAweDMwMzA1MDYwLCAweDAxMDEwMzAyLCAweDY3NjdhOWNlLCAweDJiMmI3ZDU2LCAweGZlZmUxOWU3LCAweGQ3ZDc2MmI1LCAweGFiYWJlNjRkLCAweDc2NzY5YWVjLCAweGNhY2E0NThmLCAweDgyODI5ZDFmLCAweGM5Yzk0MDg5LCAweDdkN2Q4N2ZhLCAweGZhZmExNWVmLCAweDU5NTllYmIyLCAweDQ3NDdjOThlLCAweGYwZjAwYmZiLCAweGFkYWRlYzQxLCAweGQ0ZDQ2N2IzLCAweGEyYTJmZDVmLCAweGFmYWZlYTQ1LCAweDljOWNiZjIzLCAweGE0YTRmNzUzLCAweDcyNzI5NmU0LCAweGMwYzA1YjliLCAweGI3YjdjMjc1LCAweGZkZmQxY2UxLCAweDkzOTNhZTNkLCAweDI2MjY2YTRjLCAweDM2MzY1YTZjLCAweDNmM2Y0MTdlLCAweGY3ZjcwMmY1LCAweGNjY2M0ZjgzLCAweDM0MzQ1YzY4LCAweGE1YTVmNDUxLCAweGU1ZTUzNGQxLCAweGYxZjEwOGY5LCAweDcxNzE5M2UyLCAweGQ4ZDg3M2FiLCAweDMxMzE1MzYyLCAweDE1MTUzZjJhLCAweDA0MDQwYzA4LCAweGM3Yzc1Mjk1LCAweDIzMjM2NTQ2LCAweGMzYzM1ZTlkLCAweDE4MTgyODMwLCAweDk2OTZhMTM3LCAweDA1MDUwZjBhLCAweDlhOWFiNTJmLCAweDA3MDcwOTBlLCAweDEyMTIzNjI0LCAweDgwODA5YjFiLCAweGUyZTIzZGRmLCAweGViZWIyNmNkLCAweDI3Mjc2OTRlLCAweGIyYjJjZDdmLCAweDc1NzU5ZmVhLCAweDA5MDkxYjEyLCAweDgzODM5ZTFkLCAweDJjMmM3NDU4LCAweDFhMWEyZTM0LCAweDFiMWIyZDM2LCAweDZlNmViMmRjLCAweDVhNWFlZWI0LCAweGEwYTBmYjViLCAweDUyNTJmNmE0LCAweDNiM2I0ZDc2LCAweGQ2ZDY2MWI3LCAweGIzYjNjZTdkLCAweDI5Mjk3YjUyLCAweGUzZTMzZWRkLCAweDJmMmY3MTVlLCAweDg0ODQ5NzEzLCAweDUzNTNmNWE2LCAweGQxZDE2OGI5LCAweDAwMDAwMDAwLCAweGVkZWQyY2MxLCAweDIwMjA2MDQwLCAweGZjZmMxZmUzLCAweGIxYjFjODc5LCAweDViNWJlZGI2LCAweDZhNmFiZWQ0LCAweGNiY2I0NjhkLCAweGJlYmVkOTY3LCAweDM5Mzk0YjcyLCAweDRhNGFkZTk0LCAweDRjNGNkNDk4LCAweDU4NThlOGIwLCAweGNmY2Y0YTg1LCAweGQwZDA2YmJiLCAweGVmZWYyYWM1LCAweGFhYWFlNTRmLCAweGZiZmIxNmVkLCAweDQzNDNjNTg2LCAweDRkNGRkNzlhLCAweDMzMzM1NTY2LCAweDg1ODU5NDExLCAweDQ1NDVjZjhhLCAweGY5ZjkxMGU5LCAweDAyMDIwNjA0LCAweDdmN2Y4MWZlLCAweDUwNTBmMGEwLCAweDNjM2M0NDc4LCAweDlmOWZiYTI1LCAweGE4YThlMzRiLCAweDUxNTFmM2EyLCAweGEzYTNmZTVkLCAweDQwNDBjMDgwLCAweDhmOGY4YTA1LCAweDkyOTJhZDNmLCAweDlkOWRiYzIxLCAweDM4Mzg0ODcwLCAweGY1ZjUwNGYxLCAweGJjYmNkZjYzLCAweGI2YjZjMTc3LCAweGRhZGE3NWFmLCAweDIxMjE2MzQyLCAweDEwMTAzMDIwLCAweGZmZmYxYWU1LCAweGYzZjMwZWZkLCAweGQyZDI2ZGJmLCAweGNkY2Q0YzgxLCAweDBjMGMxNDE4LCAweDEzMTMzNTI2LCAweGVjZWMyZmMzLCAweDVmNWZlMWJlLCAweDk3OTdhMjM1LCAweDQ0NDRjYzg4LCAweDE3MTczOTJlLCAweGM0YzQ1NzkzLCAweGE3YTdmMjU1LCAweDdlN2U4MmZjLCAweDNkM2Q0NzdhLCAweDY0NjRhY2M4LCAweDVkNWRlN2JhLCAweDE5MTkyYjMyLCAweDczNzM5NWU2LCAweDYwNjBhMGMwLCAweDgxODE5ODE5LCAweDRmNGZkMTllLCAweGRjZGM3ZmEzLCAweDIyMjI2NjQ0LCAweDJhMmE3ZTU0LCAweDkwOTBhYjNiLCAweDg4ODg4MzBiLCAweDQ2NDZjYThjLCAweGVlZWUyOWM3LCAweGI4YjhkMzZiLCAweDE0MTQzYzI4LCAweGRlZGU3OWE3LCAweDVlNWVlMmJjLCAweDBiMGIxZDE2LCAweGRiZGI3NmFkLCAweGUwZTAzYmRiLCAweDMyMzI1NjY0LCAweDNhM2E0ZTc0LCAweDBhMGExZTE0LCAweDQ5NDlkYjkyLCAweDA2MDYwYTBjLCAweDI0MjQ2YzQ4LCAweDVjNWNlNGI4LCAweGMyYzI1ZDlmLCAweGQzZDM2ZWJkLCAweGFjYWNlZjQzLCAweDYyNjJhNmM0LCAweDkxOTFhODM5LCAweDk1OTVhNDMxLCAweGU0ZTQzN2QzLCAweDc5Nzk4YmYyLCAweGU3ZTczMmQ1LCAweGM4Yzg0MzhiLCAweDM3Mzc1OTZlLCAweDZkNmRiN2RhLCAweDhkOGQ4YzAxLCAweGQ1ZDU2NGIxLCAweDRlNGVkMjljLCAweGE5YTllMDQ5LCAweDZjNmNiNGQ4LCAweDU2NTZmYWFjLCAweGY0ZjQwN2YzLCAweGVhZWEyNWNmLCAweDY1NjVhZmNhLCAweDdhN2E4ZWY0LCAweGFlYWVlOTQ3LCAweDA4MDgxODEwLCAweGJhYmFkNTZmLCAweDc4Nzg4OGYwLCAweDI1MjU2ZjRhLCAweDJlMmU3MjVjLCAweDFjMWMyNDM4LCAweGE2YTZmMTU3LCAweGI0YjRjNzczLCAweGM2YzY1MTk3LCAweGU4ZTgyM2NiLCAweGRkZGQ3Y2ExLCAweDc0NzQ5Y2U4LCAweDFmMWYyMTNlLCAweDRiNGJkZDk2LCAweGJkYmRkYzYxLCAweDhiOGI4NjBkLCAweDhhOGE4NTBmLCAweDcwNzA5MGUwLCAweDNlM2U0MjdjLCAweGI1YjVjNDcxLCAweDY2NjZhYWNjLCAweDQ4NDhkODkwLCAweDAzMDMwNTA2LCAweGY2ZjYwMWY3LCAweDBlMGUxMjFjLCAweDYxNjFhM2MyLCAweDM1MzU1ZjZhLCAweDU3NTdmOWFlLCAweGI5YjlkMDY5LCAweDg2ODY5MTE3LCAweGMxYzE1ODk5LCAweDFkMWQyNzNhLCAweDllOWViOTI3LCAweGUxZTEzOGQ5LCAweGY4ZjgxM2ViLCAweDk4OThiMzJiLCAweDExMTEzMzIyLCAweDY5NjliYmQyLCAweGQ5ZDk3MGE5LCAweDhlOGU4OTA3LCAweDk0OTRhNzMzLCAweDliOWJiNjJkLCAweDFlMWUyMjNjLCAweDg3ODc5MjE1LCAweGU5ZTkyMGM5LCAweGNlY2U0OTg3LCAweDU1NTVmZmFhLCAweDI4Mjg3ODUwLCAweGRmZGY3YWE1LCAweDhjOGM4ZjAzLCAweGExYTFmODU5LCAweDg5ODk4MDA5LCAweDBkMGQxNzFhLCAweGJmYmZkYTY1LCAweGU2ZTYzMWQ3LCAweDQyNDJjNjg0LCAweDY4NjhiOGQwLCAweDQxNDFjMzgyLCAweDk5OTliMDI5LCAweDJkMmQ3NzVhLCAweDBmMGYxMTFlLCAweGIwYjBjYjdiLCAweDU0NTRmY2E4LCAweGJiYmJkNjZkLCAweDE2MTYzYTJjXTtcbi8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjcnlwdGlvblxuY29uc3QgVDUgPSBbMHg1MWY0YTc1MCwgMHg3ZTQxNjU1MywgMHgxYTE3YTRjMywgMHgzYTI3NWU5NiwgMHgzYmFiNmJjYiwgMHgxZjlkNDVmMSwgMHhhY2ZhNThhYiwgMHg0YmUzMDM5MywgMHgyMDMwZmE1NSwgMHhhZDc2NmRmNiwgMHg4OGNjNzY5MSwgMHhmNTAyNGMyNSwgMHg0ZmU1ZDdmYywgMHhjNTJhY2JkNywgMHgyNjM1NDQ4MCwgMHhiNTYyYTM4ZiwgMHhkZWIxNWE0OSwgMHgyNWJhMWI2NywgMHg0NWVhMGU5OCwgMHg1ZGZlYzBlMSwgMHhjMzJmNzUwMiwgMHg4MTRjZjAxMiwgMHg4ZDQ2OTdhMywgMHg2YmQzZjljNiwgMHgwMzhmNWZlNywgMHgxNTkyOWM5NSwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHhkNGJlODMyZCwgMHg1ODc0MjFkMywgMHg0OWUwNjkyOSwgMHg4ZWM5Yzg0NCwgMHg3NWMyODk2YSwgMHhmNDhlNzk3OCwgMHg5OTU4M2U2YiwgMHgyN2I5NzFkZCwgMHhiZWUxNGZiNiwgMHhmMDg4YWQxNywgMHhjOTIwYWM2NiwgMHg3ZGNlM2FiNCwgMHg2M2RmNGExOCwgMHhlNTFhMzE4MiwgMHg5NzUxMzM2MCwgMHg2MjUzN2Y0NSwgMHhiMTY0NzdlMCwgMHhiYjZiYWU4NCwgMHhmZTgxYTAxYywgMHhmOTA4MmI5NCwgMHg3MDQ4Njg1OCwgMHg4ZjQ1ZmQxOSwgMHg5NGRlNmM4NywgMHg1MjdiZjhiNywgMHhhYjczZDMyMywgMHg3MjRiMDJlMiwgMHhlMzFmOGY1NywgMHg2NjU1YWIyYSwgMHhiMmViMjgwNywgMHgyZmI1YzIwMywgMHg4NmM1N2I5YSwgMHhkMzM3MDhhNSwgMHgzMDI4ODdmMiwgMHgyM2JmYTViMiwgMHgwMjAzNmFiYSwgMHhlZDE2ODI1YywgMHg4YWNmMWMyYiwgMHhhNzc5YjQ5MiwgMHhmMzA3ZjJmMCwgMHg0ZTY5ZTJhMSwgMHg2NWRhZjRjZCwgMHgwNjA1YmVkNSwgMHhkMTM0NjIxZiwgMHhjNGE2ZmU4YSwgMHgzNDJlNTM5ZCwgMHhhMmYzNTVhMCwgMHgwNThhZTEzMiwgMHhhNGY2ZWI3NSwgMHgwYjgzZWMzOSwgMHg0MDYwZWZhYSwgMHg1ZTcxOWYwNiwgMHhiZDZlMTA1MSwgMHgzZTIxOGFmOSwgMHg5NmRkMDYzZCwgMHhkZDNlMDVhZSwgMHg0ZGU2YmQ0NiwgMHg5MTU0OGRiNSwgMHg3MWM0NWQwNSwgMHgwNDA2ZDQ2ZiwgMHg2MDUwMTVmZiwgMHgxOTk4ZmIyNCwgMHhkNmJkZTk5NywgMHg4OTQwNDNjYywgMHg2N2Q5OWU3NywgMHhiMGU4NDJiZCwgMHgwNzg5OGI4OCwgMHhlNzE5NWIzOCwgMHg3OWM4ZWVkYiwgMHhhMTdjMGE0NywgMHg3YzQyMGZlOSwgMHhmODg0MWVjOSwgMHgwMDAwMDAwMCwgMHgwOTgwODY4MywgMHgzMjJiZWQ0OCwgMHgxZTExNzBhYywgMHg2YzVhNzI0ZSwgMHhmZDBlZmZmYiwgMHgwZjg1Mzg1NiwgMHgzZGFlZDUxZSwgMHgzNjJkMzkyNywgMHgwYTBmZDk2NCwgMHg2ODVjYTYyMSwgMHg5YjViNTRkMSwgMHgyNDM2MmUzYSwgMHgwYzBhNjdiMSwgMHg5MzU3ZTcwZiwgMHhiNGVlOTZkMiwgMHgxYjliOTE5ZSwgMHg4MGMwYzU0ZiwgMHg2MWRjMjBhMiwgMHg1YTc3NGI2OSwgMHgxYzEyMWExNiwgMHhlMjkzYmEwYSwgMHhjMGEwMmFlNSwgMHgzYzIyZTA0MywgMHgxMjFiMTcxZCwgMHgwZTA5MGQwYiwgMHhmMjhiYzdhZCwgMHgyZGI2YThiOSwgMHgxNDFlYTljOCwgMHg1N2YxMTk4NSwgMHhhZjc1MDc0YywgMHhlZTk5ZGRiYiwgMHhhMzdmNjBmZCwgMHhmNzAxMjY5ZiwgMHg1YzcyZjViYywgMHg0NDY2M2JjNSwgMHg1YmZiN2UzNCwgMHg4YjQzMjk3NiwgMHhjYjIzYzZkYywgMHhiNmVkZmM2OCwgMHhiOGU0ZjE2MywgMHhkNzMxZGNjYSwgMHg0MjYzODUxMCwgMHgxMzk3MjI0MCwgMHg4NGM2MTEyMCwgMHg4NTRhMjQ3ZCwgMHhkMmJiM2RmOCwgMHhhZWY5MzIxMSwgMHhjNzI5YTE2ZCwgMHgxZDllMmY0YiwgMHhkY2IyMzBmMywgMHgwZDg2NTJlYywgMHg3N2MxZTNkMCwgMHgyYmIzMTY2YywgMHhhOTcwYjk5OSwgMHgxMTk0NDhmYSwgMHg0N2U5NjQyMiwgMHhhOGZjOGNjNCwgMHhhMGYwM2YxYSwgMHg1NjdkMmNkOCwgMHgyMjMzOTBlZiwgMHg4NzQ5NGVjNywgMHhkOTM4ZDFjMSwgMHg4Y2NhYTJmZSwgMHg5OGQ0MGIzNiwgMHhhNmY1ODFjZiwgMHhhNTdhZGUyOCwgMHhkYWI3OGUyNiwgMHgzZmFkYmZhNCwgMHgyYzNhOWRlNCwgMHg1MDc4OTIwZCwgMHg2YTVmY2M5YiwgMHg1NDdlNDY2MiwgMHhmNjhkMTNjMiwgMHg5MGQ4YjhlOCwgMHgyZTM5Zjc1ZSwgMHg4MmMzYWZmNSwgMHg5ZjVkODBiZSwgMHg2OWQwOTM3YywgMHg2ZmQ1MmRhOSwgMHhjZjI1MTJiMywgMHhjOGFjOTkzYiwgMHgxMDE4N2RhNywgMHhlODljNjM2ZSwgMHhkYjNiYmI3YiwgMHhjZDI2NzgwOSwgMHg2ZTU5MThmNCwgMHhlYzlhYjcwMSwgMHg4MzRmOWFhOCwgMHhlNjk1NmU2NSwgMHhhYWZmZTY3ZSwgMHgyMWJjY2YwOCwgMHhlZjE1ZThlNiwgMHhiYWU3OWJkOSwgMHg0YTZmMzZjZSwgMHhlYTlmMDlkNCwgMHgyOWIwN2NkNiwgMHgzMWE0YjJhZiwgMHgyYTNmMjMzMSwgMHhjNmE1OTQzMCwgMHgzNWEyNjZjMCwgMHg3NDRlYmMzNywgMHhmYzgyY2FhNiwgMHhlMDkwZDBiMCwgMHgzM2E3ZDgxNSwgMHhmMTA0OTg0YSwgMHg0MWVjZGFmNywgMHg3ZmNkNTAwZSwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg0M2VmYjA0ZCwgMHhjY2FhNGQ1NCwgMHhlNDk2MDRkZiwgMHg5ZWQxYjVlMywgMHg0YzZhODgxYiwgMHhjMTJjMWZiOCwgMHg0NjY1NTE3ZiwgMHg5ZDVlZWEwNCwgMHgwMThjMzU1ZCwgMHhmYTg3NzQ3MywgMHhmYjBiNDEyZSwgMHhiMzY3MWQ1YSwgMHg5MmRiZDI1MiwgMHhlOTEwNTYzMywgMHg2ZGQ2NDcxMywgMHg5YWQ3NjE4YywgMHgzN2ExMGM3YSwgMHg1OWY4MTQ4ZSwgMHhlYjEzM2M4OSwgMHhjZWE5MjdlZSwgMHhiNzYxYzkzNSwgMHhlMTFjZTVlZCwgMHg3YTQ3YjEzYywgMHg5Y2QyZGY1OSwgMHg1NWYyNzMzZiwgMHgxODE0Y2U3OSwgMHg3M2M3MzdiZiwgMHg1M2Y3Y2RlYSwgMHg1ZmZkYWE1YiwgMHhkZjNkNmYxNCwgMHg3ODQ0ZGI4NiwgMHhjYWFmZjM4MSwgMHhiOTY4YzQzZSwgMHgzODI0MzQyYywgMHhjMmEzNDA1ZiwgMHgxNjFkYzM3MiwgMHhiY2UyMjUwYywgMHgyODNjNDk4YiwgMHhmZjBkOTU0MSwgMHgzOWE4MDE3MSwgMHgwODBjYjNkZSwgMHhkOGI0ZTQ5YywgMHg2NDU2YzE5MCwgMHg3YmNiODQ2MSwgMHhkNTMyYjY3MCwgMHg0ODZjNWM3NCwgMHhkMGI4NTc0Ml07XG5jb25zdCBUNiA9IFsweDUwNTFmNGE3LCAweDUzN2U0MTY1LCAweGMzMWExN2E0LCAweDk2M2EyNzVlLCAweGNiM2JhYjZiLCAweGYxMWY5ZDQ1LCAweGFiYWNmYTU4LCAweDkzNGJlMzAzLCAweDU1MjAzMGZhLCAweGY2YWQ3NjZkLCAweDkxODhjYzc2LCAweDI1ZjUwMjRjLCAweGZjNGZlNWQ3LCAweGQ3YzUyYWNiLCAweDgwMjYzNTQ0LCAweDhmYjU2MmEzLCAweDQ5ZGViMTVhLCAweDY3MjViYTFiLCAweDk4NDVlYTBlLCAweGUxNWRmZWMwLCAweDAyYzMyZjc1LCAweDEyODE0Y2YwLCAweGEzOGQ0Njk3LCAweGM2NmJkM2Y5LCAweGU3MDM4ZjVmLCAweDk1MTU5MjljLCAweGViYmY2ZDdhLCAweGRhOTU1MjU5LCAweDJkZDRiZTgzLCAweGQzNTg3NDIxLCAweDI5NDllMDY5LCAweDQ0OGVjOWM4LCAweDZhNzVjMjg5LCAweDc4ZjQ4ZTc5LCAweDZiOTk1ODNlLCAweGRkMjdiOTcxLCAweGI2YmVlMTRmLCAweDE3ZjA4OGFkLCAweDY2YzkyMGFjLCAweGI0N2RjZTNhLCAweDE4NjNkZjRhLCAweDgyZTUxYTMxLCAweDYwOTc1MTMzLCAweDQ1NjI1MzdmLCAweGUwYjE2NDc3LCAweDg0YmI2YmFlLCAweDFjZmU4MWEwLCAweDk0ZjkwODJiLCAweDU4NzA0ODY4LCAweDE5OGY0NWZkLCAweDg3OTRkZTZjLCAweGI3NTI3YmY4LCAweDIzYWI3M2QzLCAweGUyNzI0YjAyLCAweDU3ZTMxZjhmLCAweDJhNjY1NWFiLCAweDA3YjJlYjI4LCAweDAzMmZiNWMyLCAweDlhODZjNTdiLCAweGE1ZDMzNzA4LCAweGYyMzAyODg3LCAweGIyMjNiZmE1LCAweGJhMDIwMzZhLCAweDVjZWQxNjgyLCAweDJiOGFjZjFjLCAweDkyYTc3OWI0LCAweGYwZjMwN2YyLCAweGExNGU2OWUyLCAweGNkNjVkYWY0LCAweGQ1MDYwNWJlLCAweDFmZDEzNDYyLCAweDhhYzRhNmZlLCAweDlkMzQyZTUzLCAweGEwYTJmMzU1LCAweDMyMDU4YWUxLCAweDc1YTRmNmViLCAweDM5MGI4M2VjLCAweGFhNDA2MGVmLCAweDA2NWU3MTlmLCAweDUxYmQ2ZTEwLCAweGY5M2UyMThhLCAweDNkOTZkZDA2LCAweGFlZGQzZTA1LCAweDQ2NGRlNmJkLCAweGI1OTE1NDhkLCAweDA1NzFjNDVkLCAweDZmMDQwNmQ0LCAweGZmNjA1MDE1LCAweDI0MTk5OGZiLCAweDk3ZDZiZGU5LCAweGNjODk0MDQzLCAweDc3NjdkOTllLCAweGJkYjBlODQyLCAweDg4MDc4OThiLCAweDM4ZTcxOTViLCAweGRiNzljOGVlLCAweDQ3YTE3YzBhLCAweGU5N2M0MjBmLCAweGM5Zjg4NDFlLCAweDAwMDAwMDAwLCAweDgzMDk4MDg2LCAweDQ4MzIyYmVkLCAweGFjMWUxMTcwLCAweDRlNmM1YTcyLCAweGZiZmQwZWZmLCAweDU2MGY4NTM4LCAweDFlM2RhZWQ1LCAweDI3MzYyZDM5LCAweDY0MGEwZmQ5LCAweDIxNjg1Y2E2LCAweGQxOWI1YjU0LCAweDNhMjQzNjJlLCAweGIxMGMwYTY3LCAweDBmOTM1N2U3LCAweGQyYjRlZTk2LCAweDllMWI5YjkxLCAweDRmODBjMGM1LCAweGEyNjFkYzIwLCAweDY5NWE3NzRiLCAweDE2MWMxMjFhLCAweDBhZTI5M2JhLCAweGU1YzBhMDJhLCAweDQzM2MyMmUwLCAweDFkMTIxYjE3LCAweDBiMGUwOTBkLCAweGFkZjI4YmM3LCAweGI5MmRiNmE4LCAweGM4MTQxZWE5LCAweDg1NTdmMTE5LCAweDRjYWY3NTA3LCAweGJiZWU5OWRkLCAweGZkYTM3ZjYwLCAweDlmZjcwMTI2LCAweGJjNWM3MmY1LCAweGM1NDQ2NjNiLCAweDM0NWJmYjdlLCAweDc2OGI0MzI5LCAweGRjY2IyM2M2LCAweDY4YjZlZGZjLCAweDYzYjhlNGYxLCAweGNhZDczMWRjLCAweDEwNDI2Mzg1LCAweDQwMTM5NzIyLCAweDIwODRjNjExLCAweDdkODU0YTI0LCAweGY4ZDJiYjNkLCAweDExYWVmOTMyLCAweDZkYzcyOWExLCAweDRiMWQ5ZTJmLCAweGYzZGNiMjMwLCAweGVjMGQ4NjUyLCAweGQwNzdjMWUzLCAweDZjMmJiMzE2LCAweDk5YTk3MGI5LCAweGZhMTE5NDQ4LCAweDIyNDdlOTY0LCAweGM0YThmYzhjLCAweDFhYTBmMDNmLCAweGQ4NTY3ZDJjLCAweGVmMjIzMzkwLCAweGM3ODc0OTRlLCAweGMxZDkzOGQxLCAweGZlOGNjYWEyLCAweDM2OThkNDBiLCAweGNmYTZmNTgxLCAweDI4YTU3YWRlLCAweDI2ZGFiNzhlLCAweGE0M2ZhZGJmLCAweGU0MmMzYTlkLCAweDBkNTA3ODkyLCAweDliNmE1ZmNjLCAweDYyNTQ3ZTQ2LCAweGMyZjY4ZDEzLCAweGU4OTBkOGI4LCAweDVlMmUzOWY3LCAweGY1ODJjM2FmLCAweGJlOWY1ZDgwLCAweDdjNjlkMDkzLCAweGE5NmZkNTJkLCAweGIzY2YyNTEyLCAweDNiYzhhYzk5LCAweGE3MTAxODdkLCAweDZlZTg5YzYzLCAweDdiZGIzYmJiLCAweDA5Y2QyNjc4LCAweGY0NmU1OTE4LCAweDAxZWM5YWI3LCAweGE4ODM0ZjlhLCAweDY1ZTY5NTZlLCAweDdlYWFmZmU2LCAweDA4MjFiY2NmLCAweGU2ZWYxNWU4LCAweGQ5YmFlNzliLCAweGNlNGE2ZjM2LCAweGQ0ZWE5ZjA5LCAweGQ2MjliMDdjLCAweGFmMzFhNGIyLCAweDMxMmEzZjIzLCAweDMwYzZhNTk0LCAweGMwMzVhMjY2LCAweDM3NzQ0ZWJjLCAweGE2ZmM4MmNhLCAweGIwZTA5MGQwLCAweDE1MzNhN2Q4LCAweDRhZjEwNDk4LCAweGY3NDFlY2RhLCAweDBlN2ZjZDUwLCAweDJmMTc5MWY2LCAweDhkNzY0ZGQ2LCAweDRkNDNlZmIwLCAweDU0Y2NhYTRkLCAweGRmZTQ5NjA0LCAweGUzOWVkMWI1LCAweDFiNGM2YTg4LCAweGI4YzEyYzFmLCAweDdmNDY2NTUxLCAweDA0OWQ1ZWVhLCAweDVkMDE4YzM1LCAweDczZmE4Nzc0LCAweDJlZmIwYjQxLCAweDVhYjM2NzFkLCAweDUyOTJkYmQyLCAweDMzZTkxMDU2LCAweDEzNmRkNjQ3LCAweDhjOWFkNzYxLCAweDdhMzdhMTBjLCAweDhlNTlmODE0LCAweDg5ZWIxMzNjLCAweGVlY2VhOTI3LCAweDM1Yjc2MWM5LCAweGVkZTExY2U1LCAweDNjN2E0N2IxLCAweDU5OWNkMmRmLCAweDNmNTVmMjczLCAweDc5MTgxNGNlLCAweGJmNzNjNzM3LCAweGVhNTNmN2NkLCAweDViNWZmZGFhLCAweDE0ZGYzZDZmLCAweDg2Nzg0NGRiLCAweDgxY2FhZmYzLCAweDNlYjk2OGM0LCAweDJjMzgyNDM0LCAweDVmYzJhMzQwLCAweDcyMTYxZGMzLCAweDBjYmNlMjI1LCAweDhiMjgzYzQ5LCAweDQxZmYwZDk1LCAweDcxMzlhODAxLCAweGRlMDgwY2IzLCAweDljZDhiNGU0LCAweDkwNjQ1NmMxLCAweDYxN2JjYjg0LCAweDcwZDUzMmI2LCAweDc0NDg2YzVjLCAweDQyZDBiODU3XTtcbmNvbnN0IFQ3ID0gWzB4YTc1MDUxZjQsIDB4NjU1MzdlNDEsIDB4YTRjMzFhMTcsIDB4NWU5NjNhMjcsIDB4NmJjYjNiYWIsIDB4NDVmMTFmOWQsIDB4NThhYmFjZmEsIDB4MDM5MzRiZTMsIDB4ZmE1NTIwMzAsIDB4NmRmNmFkNzYsIDB4NzY5MTg4Y2MsIDB4NGMyNWY1MDIsIDB4ZDdmYzRmZTUsIDB4Y2JkN2M1MmEsIDB4NDQ4MDI2MzUsIDB4YTM4ZmI1NjIsIDB4NWE0OWRlYjEsIDB4MWI2NzI1YmEsIDB4MGU5ODQ1ZWEsIDB4YzBlMTVkZmUsIDB4NzUwMmMzMmYsIDB4ZjAxMjgxNGMsIDB4OTdhMzhkNDYsIDB4ZjljNjZiZDMsIDB4NWZlNzAzOGYsIDB4OWM5NTE1OTIsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4ODMyZGQ0YmUsIDB4MjFkMzU4NzQsIDB4NjkyOTQ5ZTAsIDB4Yzg0NDhlYzksIDB4ODk2YTc1YzIsIDB4Nzk3OGY0OGUsIDB4M2U2Yjk5NTgsIDB4NzFkZDI3YjksIDB4NGZiNmJlZTEsIDB4YWQxN2YwODgsIDB4YWM2NmM5MjAsIDB4M2FiNDdkY2UsIDB4NGExODYzZGYsIDB4MzE4MmU1MWEsIDB4MzM2MDk3NTEsIDB4N2Y0NTYyNTMsIDB4NzdlMGIxNjQsIDB4YWU4NGJiNmIsIDB4YTAxY2ZlODEsIDB4MmI5NGY5MDgsIDB4Njg1ODcwNDgsIDB4ZmQxOThmNDUsIDB4NmM4Nzk0ZGUsIDB4ZjhiNzUyN2IsIDB4ZDMyM2FiNzMsIDB4MDJlMjcyNGIsIDB4OGY1N2UzMWYsIDB4YWIyYTY2NTUsIDB4MjgwN2IyZWIsIDB4YzIwMzJmYjUsIDB4N2I5YTg2YzUsIDB4MDhhNWQzMzcsIDB4ODdmMjMwMjgsIDB4YTViMjIzYmYsIDB4NmFiYTAyMDMsIDB4ODI1Y2VkMTYsIDB4MWMyYjhhY2YsIDB4YjQ5MmE3NzksIDB4ZjJmMGYzMDcsIDB4ZTJhMTRlNjksIDB4ZjRjZDY1ZGEsIDB4YmVkNTA2MDUsIDB4NjIxZmQxMzQsIDB4ZmU4YWM0YTYsIDB4NTM5ZDM0MmUsIDB4NTVhMGEyZjMsIDB4ZTEzMjA1OGEsIDB4ZWI3NWE0ZjYsIDB4ZWMzOTBiODMsIDB4ZWZhYTQwNjAsIDB4OWYwNjVlNzEsIDB4MTA1MWJkNmUsIDB4OGFmOTNlMjEsIDB4MDYzZDk2ZGQsIDB4MDVhZWRkM2UsIDB4YmQ0NjRkZTYsIDB4OGRiNTkxNTQsIDB4NWQwNTcxYzQsIDB4ZDQ2ZjA0MDYsIDB4MTVmZjYwNTAsIDB4ZmIyNDE5OTgsIDB4ZTk5N2Q2YmQsIDB4NDNjYzg5NDAsIDB4OWU3NzY3ZDksIDB4NDJiZGIwZTgsIDB4OGI4ODA3ODksIDB4NWIzOGU3MTksIDB4ZWVkYjc5YzgsIDB4MGE0N2ExN2MsIDB4MGZlOTdjNDIsIDB4MWVjOWY4ODQsIDB4MDAwMDAwMDAsIDB4ODY4MzA5ODAsIDB4ZWQ0ODMyMmIsIDB4NzBhYzFlMTEsIDB4NzI0ZTZjNWEsIDB4ZmZmYmZkMGUsIDB4Mzg1NjBmODUsIDB4ZDUxZTNkYWUsIDB4MzkyNzM2MmQsIDB4ZDk2NDBhMGYsIDB4YTYyMTY4NWMsIDB4NTRkMTliNWIsIDB4MmUzYTI0MzYsIDB4NjdiMTBjMGEsIDB4ZTcwZjkzNTcsIDB4OTZkMmI0ZWUsIDB4OTE5ZTFiOWIsIDB4YzU0ZjgwYzAsIDB4MjBhMjYxZGMsIDB4NGI2OTVhNzcsIDB4MWExNjFjMTIsIDB4YmEwYWUyOTMsIDB4MmFlNWMwYTAsIDB4ZTA0MzNjMjIsIDB4MTcxZDEyMWIsIDB4MGQwYjBlMDksIDB4YzdhZGYyOGIsIDB4YThiOTJkYjYsIDB4YTljODE0MWUsIDB4MTk4NTU3ZjEsIDB4MDc0Y2FmNzUsIDB4ZGRiYmVlOTksIDB4NjBmZGEzN2YsIDB4MjY5ZmY3MDEsIDB4ZjViYzVjNzIsIDB4M2JjNTQ0NjYsIDB4N2UzNDViZmIsIDB4Mjk3NjhiNDMsIDB4YzZkY2NiMjMsIDB4ZmM2OGI2ZWQsIDB4ZjE2M2I4ZTQsIDB4ZGNjYWQ3MzEsIDB4ODUxMDQyNjMsIDB4MjI0MDEzOTcsIDB4MTEyMDg0YzYsIDB4MjQ3ZDg1NGEsIDB4M2RmOGQyYmIsIDB4MzIxMWFlZjksIDB4YTE2ZGM3MjksIDB4MmY0YjFkOWUsIDB4MzBmM2RjYjIsIDB4NTJlYzBkODYsIDB4ZTNkMDc3YzEsIDB4MTY2YzJiYjMsIDB4Yjk5OWE5NzAsIDB4NDhmYTExOTQsIDB4NjQyMjQ3ZTksIDB4OGNjNGE4ZmMsIDB4M2YxYWEwZjAsIDB4MmNkODU2N2QsIDB4OTBlZjIyMzMsIDB4NGVjNzg3NDksIDB4ZDFjMWQ5MzgsIDB4YTJmZThjY2EsIDB4MGIzNjk4ZDQsIDB4ODFjZmE2ZjUsIDB4ZGUyOGE1N2EsIDB4OGUyNmRhYjcsIDB4YmZhNDNmYWQsIDB4OWRlNDJjM2EsIDB4OTIwZDUwNzgsIDB4Y2M5YjZhNWYsIDB4NDY2MjU0N2UsIDB4MTNjMmY2OGQsIDB4YjhlODkwZDgsIDB4Zjc1ZTJlMzksIDB4YWZmNTgyYzMsIDB4ODBiZTlmNWQsIDB4OTM3YzY5ZDAsIDB4MmRhOTZmZDUsIDB4MTJiM2NmMjUsIDB4OTkzYmM4YWMsIDB4N2RhNzEwMTgsIDB4NjM2ZWU4OWMsIDB4YmI3YmRiM2IsIDB4NzgwOWNkMjYsIDB4MThmNDZlNTksIDB4YjcwMWVjOWEsIDB4OWFhODgzNGYsIDB4NmU2NWU2OTUsIDB4ZTY3ZWFhZmYsIDB4Y2YwODIxYmMsIDB4ZThlNmVmMTUsIDB4OWJkOWJhZTcsIDB4MzZjZTRhNmYsIDB4MDlkNGVhOWYsIDB4N2NkNjI5YjAsIDB4YjJhZjMxYTQsIDB4MjMzMTJhM2YsIDB4OTQzMGM2YTUsIDB4NjZjMDM1YTIsIDB4YmMzNzc0NGUsIDB4Y2FhNmZjODIsIDB4ZDBiMGUwOTAsIDB4ZDgxNTMzYTcsIDB4OTg0YWYxMDQsIDB4ZGFmNzQxZWMsIDB4NTAwZTdmY2QsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4YjA0ZDQzZWYsIDB4NGQ1NGNjYWEsIDB4MDRkZmU0OTYsIDB4YjVlMzllZDEsIDB4ODgxYjRjNmEsIDB4MWZiOGMxMmMsIDB4NTE3ZjQ2NjUsIDB4ZWEwNDlkNWUsIDB4MzU1ZDAxOGMsIDB4NzQ3M2ZhODcsIDB4NDEyZWZiMGIsIDB4MWQ1YWIzNjcsIDB4ZDI1MjkyZGIsIDB4NTYzM2U5MTAsIDB4NDcxMzZkZDYsIDB4NjE4YzlhZDcsIDB4MGM3YTM3YTEsIDB4MTQ4ZTU5ZjgsIDB4M2M4OWViMTMsIDB4MjdlZWNlYTksIDB4YzkzNWI3NjEsIDB4ZTVlZGUxMWMsIDB4YjEzYzdhNDcsIDB4ZGY1OTljZDIsIDB4NzMzZjU1ZjIsIDB4Y2U3OTE4MTQsIDB4MzdiZjczYzcsIDB4Y2RlYTUzZjcsIDB4YWE1YjVmZmQsIDB4NmYxNGRmM2QsIDB4ZGI4Njc4NDQsIDB4ZjM4MWNhYWYsIDB4YzQzZWI5NjgsIDB4MzQyYzM4MjQsIDB4NDA1ZmMyYTMsIDB4YzM3MjE2MWQsIDB4MjUwY2JjZTIsIDB4NDk4YjI4M2MsIDB4OTU0MWZmMGQsIDB4MDE3MTM5YTgsIDB4YjNkZTA4MGMsIDB4ZTQ5Y2Q4YjQsIDB4YzE5MDY0NTYsIDB4ODQ2MTdiY2IsIDB4YjY3MGQ1MzIsIDB4NWM3NDQ4NmMsIDB4NTc0MmQwYjhdO1xuY29uc3QgVDggPSBbMHhmNGE3NTA1MSwgMHg0MTY1NTM3ZSwgMHgxN2E0YzMxYSwgMHgyNzVlOTYzYSwgMHhhYjZiY2IzYiwgMHg5ZDQ1ZjExZiwgMHhmYTU4YWJhYywgMHhlMzAzOTM0YiwgMHgzMGZhNTUyMCwgMHg3NjZkZjZhZCwgMHhjYzc2OTE4OCwgMHgwMjRjMjVmNSwgMHhlNWQ3ZmM0ZiwgMHgyYWNiZDdjNSwgMHgzNTQ0ODAyNiwgMHg2MmEzOGZiNSwgMHhiMTVhNDlkZSwgMHhiYTFiNjcyNSwgMHhlYTBlOTg0NSwgMHhmZWMwZTE1ZCwgMHgyZjc1MDJjMywgMHg0Y2YwMTI4MSwgMHg0Njk3YTM4ZCwgMHhkM2Y5YzY2YiwgMHg4ZjVmZTcwMywgMHg5MjljOTUxNSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHhiZTgzMmRkNCwgMHg3NDIxZDM1OCwgMHhlMDY5Mjk0OSwgMHhjOWM4NDQ4ZSwgMHhjMjg5NmE3NSwgMHg4ZTc5NzhmNCwgMHg1ODNlNmI5OSwgMHhiOTcxZGQyNywgMHhlMTRmYjZiZSwgMHg4OGFkMTdmMCwgMHgyMGFjNjZjOSwgMHhjZTNhYjQ3ZCwgMHhkZjRhMTg2MywgMHgxYTMxODJlNSwgMHg1MTMzNjA5NywgMHg1MzdmNDU2MiwgMHg2NDc3ZTBiMSwgMHg2YmFlODRiYiwgMHg4MWEwMWNmZSwgMHgwODJiOTRmOSwgMHg0ODY4NTg3MCwgMHg0NWZkMTk4ZiwgMHhkZTZjODc5NCwgMHg3YmY4Yjc1MiwgMHg3M2QzMjNhYiwgMHg0YjAyZTI3MiwgMHgxZjhmNTdlMywgMHg1NWFiMmE2NiwgMHhlYjI4MDdiMiwgMHhiNWMyMDMyZiwgMHhjNTdiOWE4NiwgMHgzNzA4YTVkMywgMHgyODg3ZjIzMCwgMHhiZmE1YjIyMywgMHgwMzZhYmEwMiwgMHgxNjgyNWNlZCwgMHhjZjFjMmI4YSwgMHg3OWI0OTJhNywgMHgwN2YyZjBmMywgMHg2OWUyYTE0ZSwgMHhkYWY0Y2Q2NSwgMHgwNWJlZDUwNiwgMHgzNDYyMWZkMSwgMHhhNmZlOGFjNCwgMHgyZTUzOWQzNCwgMHhmMzU1YTBhMiwgMHg4YWUxMzIwNSwgMHhmNmViNzVhNCwgMHg4M2VjMzkwYiwgMHg2MGVmYWE0MCwgMHg3MTlmMDY1ZSwgMHg2ZTEwNTFiZCwgMHgyMThhZjkzZSwgMHhkZDA2M2Q5NiwgMHgzZTA1YWVkZCwgMHhlNmJkNDY0ZCwgMHg1NDhkYjU5MSwgMHhjNDVkMDU3MSwgMHgwNmQ0NmYwNCwgMHg1MDE1ZmY2MCwgMHg5OGZiMjQxOSwgMHhiZGU5OTdkNiwgMHg0MDQzY2M4OSwgMHhkOTllNzc2NywgMHhlODQyYmRiMCwgMHg4OThiODgwNywgMHgxOTViMzhlNywgMHhjOGVlZGI3OSwgMHg3YzBhNDdhMSwgMHg0MjBmZTk3YywgMHg4NDFlYzlmOCwgMHgwMDAwMDAwMCwgMHg4MDg2ODMwOSwgMHgyYmVkNDgzMiwgMHgxMTcwYWMxZSwgMHg1YTcyNGU2YywgMHgwZWZmZmJmZCwgMHg4NTM4NTYwZiwgMHhhZWQ1MWUzZCwgMHgyZDM5MjczNiwgMHgwZmQ5NjQwYSwgMHg1Y2E2MjE2OCwgMHg1YjU0ZDE5YiwgMHgzNjJlM2EyNCwgMHgwYTY3YjEwYywgMHg1N2U3MGY5MywgMHhlZTk2ZDJiNCwgMHg5YjkxOWUxYiwgMHhjMGM1NGY4MCwgMHhkYzIwYTI2MSwgMHg3NzRiNjk1YSwgMHgxMjFhMTYxYywgMHg5M2JhMGFlMiwgMHhhMDJhZTVjMCwgMHgyMmUwNDMzYywgMHgxYjE3MWQxMiwgMHgwOTBkMGIwZSwgMHg4YmM3YWRmMiwgMHhiNmE4YjkyZCwgMHgxZWE5YzgxNCwgMHhmMTE5ODU1NywgMHg3NTA3NGNhZiwgMHg5OWRkYmJlZSwgMHg3ZjYwZmRhMywgMHgwMTI2OWZmNywgMHg3MmY1YmM1YywgMHg2NjNiYzU0NCwgMHhmYjdlMzQ1YiwgMHg0MzI5NzY4YiwgMHgyM2M2ZGNjYiwgMHhlZGZjNjhiNiwgMHhlNGYxNjNiOCwgMHgzMWRjY2FkNywgMHg2Mzg1MTA0MiwgMHg5NzIyNDAxMywgMHhjNjExMjA4NCwgMHg0YTI0N2Q4NSwgMHhiYjNkZjhkMiwgMHhmOTMyMTFhZSwgMHgyOWExNmRjNywgMHg5ZTJmNGIxZCwgMHhiMjMwZjNkYywgMHg4NjUyZWMwZCwgMHhjMWUzZDA3NywgMHhiMzE2NmMyYiwgMHg3MGI5OTlhOSwgMHg5NDQ4ZmExMSwgMHhlOTY0MjI0NywgMHhmYzhjYzRhOCwgMHhmMDNmMWFhMCwgMHg3ZDJjZDg1NiwgMHgzMzkwZWYyMiwgMHg0OTRlYzc4NywgMHgzOGQxYzFkOSwgMHhjYWEyZmU4YywgMHhkNDBiMzY5OCwgMHhmNTgxY2ZhNiwgMHg3YWRlMjhhNSwgMHhiNzhlMjZkYSwgMHhhZGJmYTQzZiwgMHgzYTlkZTQyYywgMHg3ODkyMGQ1MCwgMHg1ZmNjOWI2YSwgMHg3ZTQ2NjI1NCwgMHg4ZDEzYzJmNiwgMHhkOGI4ZTg5MCwgMHgzOWY3NWUyZSwgMHhjM2FmZjU4MiwgMHg1ZDgwYmU5ZiwgMHhkMDkzN2M2OSwgMHhkNTJkYTk2ZiwgMHgyNTEyYjNjZiwgMHhhYzk5M2JjOCwgMHgxODdkYTcxMCwgMHg5YzYzNmVlOCwgMHgzYmJiN2JkYiwgMHgyNjc4MDljZCwgMHg1OTE4ZjQ2ZSwgMHg5YWI3MDFlYywgMHg0ZjlhYTg4MywgMHg5NTZlNjVlNiwgMHhmZmU2N2VhYSwgMHhiY2NmMDgyMSwgMHgxNWU4ZTZlZiwgMHhlNzliZDliYSwgMHg2ZjM2Y2U0YSwgMHg5ZjA5ZDRlYSwgMHhiMDdjZDYyOSwgMHhhNGIyYWYzMSwgMHgzZjIzMzEyYSwgMHhhNTk0MzBjNiwgMHhhMjY2YzAzNSwgMHg0ZWJjMzc3NCwgMHg4MmNhYTZmYywgMHg5MGQwYjBlMCwgMHhhN2Q4MTUzMywgMHgwNDk4NGFmMSwgMHhlY2RhZjc0MSwgMHhjZDUwMGU3ZiwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHhlZmIwNGQ0MywgMHhhYTRkNTRjYywgMHg5NjA0ZGZlNCwgMHhkMWI1ZTM5ZSwgMHg2YTg4MWI0YywgMHgyYzFmYjhjMSwgMHg2NTUxN2Y0NiwgMHg1ZWVhMDQ5ZCwgMHg4YzM1NWQwMSwgMHg4Nzc0NzNmYSwgMHgwYjQxMmVmYiwgMHg2NzFkNWFiMywgMHhkYmQyNTI5MiwgMHgxMDU2MzNlOSwgMHhkNjQ3MTM2ZCwgMHhkNzYxOGM5YSwgMHhhMTBjN2EzNywgMHhmODE0OGU1OSwgMHgxMzNjODllYiwgMHhhOTI3ZWVjZSwgMHg2MWM5MzViNywgMHgxY2U1ZWRlMSwgMHg0N2IxM2M3YSwgMHhkMmRmNTk5YywgMHhmMjczM2Y1NSwgMHgxNGNlNzkxOCwgMHhjNzM3YmY3MywgMHhmN2NkZWE1MywgMHhmZGFhNWI1ZiwgMHgzZDZmMTRkZiwgMHg0NGRiODY3OCwgMHhhZmYzODFjYSwgMHg2OGM0M2ViOSwgMHgyNDM0MmMzOCwgMHhhMzQwNWZjMiwgMHgxZGMzNzIxNiwgMHhlMjI1MGNiYywgMHgzYzQ5OGIyOCwgMHgwZDk1NDFmZiwgMHhhODAxNzEzOSwgMHgwY2IzZGUwOCwgMHhiNGU0OWNkOCwgMHg1NmMxOTA2NCwgMHhjYjg0NjE3YiwgMHgzMmI2NzBkNSwgMHg2YzVjNzQ0OCwgMHhiODU3NDJkMF07XG4vLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb24ga2V5IGV4cGFuc2lvblxuY29uc3QgVTEgPSBbMHgwMDAwMDAwMCwgMHgwZTA5MGQwYiwgMHgxYzEyMWExNiwgMHgxMjFiMTcxZCwgMHgzODI0MzQyYywgMHgzNjJkMzkyNywgMHgyNDM2MmUzYSwgMHgyYTNmMjMzMSwgMHg3MDQ4Njg1OCwgMHg3ZTQxNjU1MywgMHg2YzVhNzI0ZSwgMHg2MjUzN2Y0NSwgMHg0ODZjNWM3NCwgMHg0NjY1NTE3ZiwgMHg1NDdlNDY2MiwgMHg1YTc3NGI2OSwgMHhlMDkwZDBiMCwgMHhlZTk5ZGRiYiwgMHhmYzgyY2FhNiwgMHhmMjhiYzdhZCwgMHhkOGI0ZTQ5YywgMHhkNmJkZTk5NywgMHhjNGE2ZmU4YSwgMHhjYWFmZjM4MSwgMHg5MGQ4YjhlOCwgMHg5ZWQxYjVlMywgMHg4Y2NhYTJmZSwgMHg4MmMzYWZmNSwgMHhhOGZjOGNjNCwgMHhhNmY1ODFjZiwgMHhiNGVlOTZkMiwgMHhiYWU3OWJkOSwgMHhkYjNiYmI3YiwgMHhkNTMyYjY3MCwgMHhjNzI5YTE2ZCwgMHhjOTIwYWM2NiwgMHhlMzFmOGY1NywgMHhlZDE2ODI1YywgMHhmZjBkOTU0MSwgMHhmMTA0OTg0YSwgMHhhYjczZDMyMywgMHhhNTdhZGUyOCwgMHhiNzYxYzkzNSwgMHhiOTY4YzQzZSwgMHg5MzU3ZTcwZiwgMHg5ZDVlZWEwNCwgMHg4ZjQ1ZmQxOSwgMHg4MTRjZjAxMiwgMHgzYmFiNmJjYiwgMHgzNWEyNjZjMCwgMHgyN2I5NzFkZCwgMHgyOWIwN2NkNiwgMHgwMzhmNWZlNywgMHgwZDg2NTJlYywgMHgxZjlkNDVmMSwgMHgxMTk0NDhmYSwgMHg0YmUzMDM5MywgMHg0NWVhMGU5OCwgMHg1N2YxMTk4NSwgMHg1OWY4MTQ4ZSwgMHg3M2M3MzdiZiwgMHg3ZGNlM2FiNCwgMHg2ZmQ1MmRhOSwgMHg2MWRjMjBhMiwgMHhhZDc2NmRmNiwgMHhhMzdmNjBmZCwgMHhiMTY0NzdlMCwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHg5YjViNTRkMSwgMHg4OTQwNDNjYywgMHg4NzQ5NGVjNywgMHhkZDNlMDVhZSwgMHhkMzM3MDhhNSwgMHhjMTJjMWZiOCwgMHhjZjI1MTJiMywgMHhlNTFhMzE4MiwgMHhlYjEzM2M4OSwgMHhmOTA4MmI5NCwgMHhmNzAxMjY5ZiwgMHg0ZGU2YmQ0NiwgMHg0M2VmYjA0ZCwgMHg1MWY0YTc1MCwgMHg1ZmZkYWE1YiwgMHg3NWMyODk2YSwgMHg3YmNiODQ2MSwgMHg2OWQwOTM3YywgMHg2N2Q5OWU3NywgMHgzZGFlZDUxZSwgMHgzM2E3ZDgxNSwgMHgyMWJjY2YwOCwgMHgyZmI1YzIwMywgMHgwNThhZTEzMiwgMHgwYjgzZWMzOSwgMHgxOTk4ZmIyNCwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg3ODQ0ZGI4NiwgMHg2YTVmY2M5YiwgMHg2NDU2YzE5MCwgMHg0ZTY5ZTJhMSwgMHg0MDYwZWZhYSwgMHg1MjdiZjhiNywgMHg1YzcyZjViYywgMHgwNjA1YmVkNSwgMHgwODBjYjNkZSwgMHgxYTE3YTRjMywgMHgxNDFlYTljOCwgMHgzZTIxOGFmOSwgMHgzMDI4ODdmMiwgMHgyMjMzOTBlZiwgMHgyYzNhOWRlNCwgMHg5NmRkMDYzZCwgMHg5OGQ0MGIzNiwgMHg4YWNmMWMyYiwgMHg4NGM2MTEyMCwgMHhhZWY5MzIxMSwgMHhhMGYwM2YxYSwgMHhiMmViMjgwNywgMHhiY2UyMjUwYywgMHhlNjk1NmU2NSwgMHhlODljNjM2ZSwgMHhmYTg3NzQ3MywgMHhmNDhlNzk3OCwgMHhkZWIxNWE0OSwgMHhkMGI4NTc0MiwgMHhjMmEzNDA1ZiwgMHhjY2FhNGQ1NCwgMHg0MWVjZGFmNywgMHg0ZmU1ZDdmYywgMHg1ZGZlYzBlMSwgMHg1M2Y3Y2RlYSwgMHg3OWM4ZWVkYiwgMHg3N2MxZTNkMCwgMHg2NWRhZjRjZCwgMHg2YmQzZjljNiwgMHgzMWE0YjJhZiwgMHgzZmFkYmZhNCwgMHgyZGI2YThiOSwgMHgyM2JmYTViMiwgMHgwOTgwODY4MywgMHgwNzg5OGI4OCwgMHgxNTkyOWM5NSwgMHgxYjliOTE5ZSwgMHhhMTdjMGE0NywgMHhhZjc1MDc0YywgMHhiZDZlMTA1MSwgMHhiMzY3MWQ1YSwgMHg5OTU4M2U2YiwgMHg5NzUxMzM2MCwgMHg4NTRhMjQ3ZCwgMHg4YjQzMjk3NiwgMHhkMTM0NjIxZiwgMHhkZjNkNmYxNCwgMHhjZDI2NzgwOSwgMHhjMzJmNzUwMiwgMHhlOTEwNTYzMywgMHhlNzE5NWIzOCwgMHhmNTAyNGMyNSwgMHhmYjBiNDEyZSwgMHg5YWQ3NjE4YywgMHg5NGRlNmM4NywgMHg4NmM1N2I5YSwgMHg4OGNjNzY5MSwgMHhhMmYzNTVhMCwgMHhhY2ZhNThhYiwgMHhiZWUxNGZiNiwgMHhiMGU4NDJiZCwgMHhlYTlmMDlkNCwgMHhlNDk2MDRkZiwgMHhmNjhkMTNjMiwgMHhmODg0MWVjOSwgMHhkMmJiM2RmOCwgMHhkY2IyMzBmMywgMHhjZWE5MjdlZSwgMHhjMGEwMmFlNSwgMHg3YTQ3YjEzYywgMHg3NDRlYmMzNywgMHg2NjU1YWIyYSwgMHg2ODVjYTYyMSwgMHg0MjYzODUxMCwgMHg0YzZhODgxYiwgMHg1ZTcxOWYwNiwgMHg1MDc4OTIwZCwgMHgwYTBmZDk2NCwgMHgwNDA2ZDQ2ZiwgMHgxNjFkYzM3MiwgMHgxODE0Y2U3OSwgMHgzMjJiZWQ0OCwgMHgzYzIyZTA0MywgMHgyZTM5Zjc1ZSwgMHgyMDMwZmE1NSwgMHhlYzlhYjcwMSwgMHhlMjkzYmEwYSwgMHhmMDg4YWQxNywgMHhmZTgxYTAxYywgMHhkNGJlODMyZCwgMHhkYWI3OGUyNiwgMHhjOGFjOTkzYiwgMHhjNmE1OTQzMCwgMHg5Y2QyZGY1OSwgMHg5MmRiZDI1MiwgMHg4MGMwYzU0ZiwgMHg4ZWM5Yzg0NCwgMHhhNGY2ZWI3NSwgMHhhYWZmZTY3ZSwgMHhiOGU0ZjE2MywgMHhiNmVkZmM2OCwgMHgwYzBhNjdiMSwgMHgwMjAzNmFiYSwgMHgxMDE4N2RhNywgMHgxZTExNzBhYywgMHgzNDJlNTM5ZCwgMHgzYTI3NWU5NiwgMHgyODNjNDk4YiwgMHgyNjM1NDQ4MCwgMHg3YzQyMGZlOSwgMHg3MjRiMDJlMiwgMHg2MDUwMTVmZiwgMHg2ZTU5MThmNCwgMHg0NDY2M2JjNSwgMHg0YTZmMzZjZSwgMHg1ODc0MjFkMywgMHg1NjdkMmNkOCwgMHgzN2ExMGM3YSwgMHgzOWE4MDE3MSwgMHgyYmIzMTY2YywgMHgyNWJhMWI2NywgMHgwZjg1Mzg1NiwgMHgwMThjMzU1ZCwgMHgxMzk3MjI0MCwgMHgxZDllMmY0YiwgMHg0N2U5NjQyMiwgMHg0OWUwNjkyOSwgMHg1YmZiN2UzNCwgMHg1NWYyNzMzZiwgMHg3ZmNkNTAwZSwgMHg3MWM0NWQwNSwgMHg2M2RmNGExOCwgMHg2ZGQ2NDcxMywgMHhkNzMxZGNjYSwgMHhkOTM4ZDFjMSwgMHhjYjIzYzZkYywgMHhjNTJhY2JkNywgMHhlZjE1ZThlNiwgMHhlMTFjZTVlZCwgMHhmMzA3ZjJmMCwgMHhmZDBlZmZmYiwgMHhhNzc5YjQ5MiwgMHhhOTcwYjk5OSwgMHhiYjZiYWU4NCwgMHhiNTYyYTM4ZiwgMHg5ZjVkODBiZSwgMHg5MTU0OGRiNSwgMHg4MzRmOWFhOCwgMHg4ZDQ2OTdhM107XG5jb25zdCBVMiA9IFsweDAwMDAwMDAwLCAweDBiMGUwOTBkLCAweDE2MWMxMjFhLCAweDFkMTIxYjE3LCAweDJjMzgyNDM0LCAweDI3MzYyZDM5LCAweDNhMjQzNjJlLCAweDMxMmEzZjIzLCAweDU4NzA0ODY4LCAweDUzN2U0MTY1LCAweDRlNmM1YTcyLCAweDQ1NjI1MzdmLCAweDc0NDg2YzVjLCAweDdmNDY2NTUxLCAweDYyNTQ3ZTQ2LCAweDY5NWE3NzRiLCAweGIwZTA5MGQwLCAweGJiZWU5OWRkLCAweGE2ZmM4MmNhLCAweGFkZjI4YmM3LCAweDljZDhiNGU0LCAweDk3ZDZiZGU5LCAweDhhYzRhNmZlLCAweDgxY2FhZmYzLCAweGU4OTBkOGI4LCAweGUzOWVkMWI1LCAweGZlOGNjYWEyLCAweGY1ODJjM2FmLCAweGM0YThmYzhjLCAweGNmYTZmNTgxLCAweGQyYjRlZTk2LCAweGQ5YmFlNzliLCAweDdiZGIzYmJiLCAweDcwZDUzMmI2LCAweDZkYzcyOWExLCAweDY2YzkyMGFjLCAweDU3ZTMxZjhmLCAweDVjZWQxNjgyLCAweDQxZmYwZDk1LCAweDRhZjEwNDk4LCAweDIzYWI3M2QzLCAweDI4YTU3YWRlLCAweDM1Yjc2MWM5LCAweDNlYjk2OGM0LCAweDBmOTM1N2U3LCAweDA0OWQ1ZWVhLCAweDE5OGY0NWZkLCAweDEyODE0Y2YwLCAweGNiM2JhYjZiLCAweGMwMzVhMjY2LCAweGRkMjdiOTcxLCAweGQ2MjliMDdjLCAweGU3MDM4ZjVmLCAweGVjMGQ4NjUyLCAweGYxMWY5ZDQ1LCAweGZhMTE5NDQ4LCAweDkzNGJlMzAzLCAweDk4NDVlYTBlLCAweDg1NTdmMTE5LCAweDhlNTlmODE0LCAweGJmNzNjNzM3LCAweGI0N2RjZTNhLCAweGE5NmZkNTJkLCAweGEyNjFkYzIwLCAweGY2YWQ3NjZkLCAweGZkYTM3ZjYwLCAweGUwYjE2NDc3LCAweGViYmY2ZDdhLCAweGRhOTU1MjU5LCAweGQxOWI1YjU0LCAweGNjODk0MDQzLCAweGM3ODc0OTRlLCAweGFlZGQzZTA1LCAweGE1ZDMzNzA4LCAweGI4YzEyYzFmLCAweGIzY2YyNTEyLCAweDgyZTUxYTMxLCAweDg5ZWIxMzNjLCAweDk0ZjkwODJiLCAweDlmZjcwMTI2LCAweDQ2NGRlNmJkLCAweDRkNDNlZmIwLCAweDUwNTFmNGE3LCAweDViNWZmZGFhLCAweDZhNzVjMjg5LCAweDYxN2JjYjg0LCAweDdjNjlkMDkzLCAweDc3NjdkOTllLCAweDFlM2RhZWQ1LCAweDE1MzNhN2Q4LCAweDA4MjFiY2NmLCAweDAzMmZiNWMyLCAweDMyMDU4YWUxLCAweDM5MGI4M2VjLCAweDI0MTk5OGZiLCAweDJmMTc5MWY2LCAweDhkNzY0ZGQ2LCAweDg2Nzg0NGRiLCAweDliNmE1ZmNjLCAweDkwNjQ1NmMxLCAweGExNGU2OWUyLCAweGFhNDA2MGVmLCAweGI3NTI3YmY4LCAweGJjNWM3MmY1LCAweGQ1MDYwNWJlLCAweGRlMDgwY2IzLCAweGMzMWExN2E0LCAweGM4MTQxZWE5LCAweGY5M2UyMThhLCAweGYyMzAyODg3LCAweGVmMjIzMzkwLCAweGU0MmMzYTlkLCAweDNkOTZkZDA2LCAweDM2OThkNDBiLCAweDJiOGFjZjFjLCAweDIwODRjNjExLCAweDExYWVmOTMyLCAweDFhYTBmMDNmLCAweDA3YjJlYjI4LCAweDBjYmNlMjI1LCAweDY1ZTY5NTZlLCAweDZlZTg5YzYzLCAweDczZmE4Nzc0LCAweDc4ZjQ4ZTc5LCAweDQ5ZGViMTVhLCAweDQyZDBiODU3LCAweDVmYzJhMzQwLCAweDU0Y2NhYTRkLCAweGY3NDFlY2RhLCAweGZjNGZlNWQ3LCAweGUxNWRmZWMwLCAweGVhNTNmN2NkLCAweGRiNzljOGVlLCAweGQwNzdjMWUzLCAweGNkNjVkYWY0LCAweGM2NmJkM2Y5LCAweGFmMzFhNGIyLCAweGE0M2ZhZGJmLCAweGI5MmRiNmE4LCAweGIyMjNiZmE1LCAweDgzMDk4MDg2LCAweDg4MDc4OThiLCAweDk1MTU5MjljLCAweDllMWI5YjkxLCAweDQ3YTE3YzBhLCAweDRjYWY3NTA3LCAweDUxYmQ2ZTEwLCAweDVhYjM2NzFkLCAweDZiOTk1ODNlLCAweDYwOTc1MTMzLCAweDdkODU0YTI0LCAweDc2OGI0MzI5LCAweDFmZDEzNDYyLCAweDE0ZGYzZDZmLCAweDA5Y2QyNjc4LCAweDAyYzMyZjc1LCAweDMzZTkxMDU2LCAweDM4ZTcxOTViLCAweDI1ZjUwMjRjLCAweDJlZmIwYjQxLCAweDhjOWFkNzYxLCAweDg3OTRkZTZjLCAweDlhODZjNTdiLCAweDkxODhjYzc2LCAweGEwYTJmMzU1LCAweGFiYWNmYTU4LCAweGI2YmVlMTRmLCAweGJkYjBlODQyLCAweGQ0ZWE5ZjA5LCAweGRmZTQ5NjA0LCAweGMyZjY4ZDEzLCAweGM5Zjg4NDFlLCAweGY4ZDJiYjNkLCAweGYzZGNiMjMwLCAweGVlY2VhOTI3LCAweGU1YzBhMDJhLCAweDNjN2E0N2IxLCAweDM3NzQ0ZWJjLCAweDJhNjY1NWFiLCAweDIxNjg1Y2E2LCAweDEwNDI2Mzg1LCAweDFiNGM2YTg4LCAweDA2NWU3MTlmLCAweDBkNTA3ODkyLCAweDY0MGEwZmQ5LCAweDZmMDQwNmQ0LCAweDcyMTYxZGMzLCAweDc5MTgxNGNlLCAweDQ4MzIyYmVkLCAweDQzM2MyMmUwLCAweDVlMmUzOWY3LCAweDU1MjAzMGZhLCAweDAxZWM5YWI3LCAweDBhZTI5M2JhLCAweDE3ZjA4OGFkLCAweDFjZmU4MWEwLCAweDJkZDRiZTgzLCAweDI2ZGFiNzhlLCAweDNiYzhhYzk5LCAweDMwYzZhNTk0LCAweDU5OWNkMmRmLCAweDUyOTJkYmQyLCAweDRmODBjMGM1LCAweDQ0OGVjOWM4LCAweDc1YTRmNmViLCAweDdlYWFmZmU2LCAweDYzYjhlNGYxLCAweDY4YjZlZGZjLCAweGIxMGMwYTY3LCAweGJhMDIwMzZhLCAweGE3MTAxODdkLCAweGFjMWUxMTcwLCAweDlkMzQyZTUzLCAweDk2M2EyNzVlLCAweDhiMjgzYzQ5LCAweDgwMjYzNTQ0LCAweGU5N2M0MjBmLCAweGUyNzI0YjAyLCAweGZmNjA1MDE1LCAweGY0NmU1OTE4LCAweGM1NDQ2NjNiLCAweGNlNGE2ZjM2LCAweGQzNTg3NDIxLCAweGQ4NTY3ZDJjLCAweDdhMzdhMTBjLCAweDcxMzlhODAxLCAweDZjMmJiMzE2LCAweDY3MjViYTFiLCAweDU2MGY4NTM4LCAweDVkMDE4YzM1LCAweDQwMTM5NzIyLCAweDRiMWQ5ZTJmLCAweDIyNDdlOTY0LCAweDI5NDllMDY5LCAweDM0NWJmYjdlLCAweDNmNTVmMjczLCAweDBlN2ZjZDUwLCAweDA1NzFjNDVkLCAweDE4NjNkZjRhLCAweDEzNmRkNjQ3LCAweGNhZDczMWRjLCAweGMxZDkzOGQxLCAweGRjY2IyM2M2LCAweGQ3YzUyYWNiLCAweGU2ZWYxNWU4LCAweGVkZTExY2U1LCAweGYwZjMwN2YyLCAweGZiZmQwZWZmLCAweDkyYTc3OWI0LCAweDk5YTk3MGI5LCAweDg0YmI2YmFlLCAweDhmYjU2MmEzLCAweGJlOWY1ZDgwLCAweGI1OTE1NDhkLCAweGE4ODM0ZjlhLCAweGEzOGQ0Njk3XTtcbmNvbnN0IFUzID0gWzB4MDAwMDAwMDAsIDB4MGQwYjBlMDksIDB4MWExNjFjMTIsIDB4MTcxZDEyMWIsIDB4MzQyYzM4MjQsIDB4MzkyNzM2MmQsIDB4MmUzYTI0MzYsIDB4MjMzMTJhM2YsIDB4Njg1ODcwNDgsIDB4NjU1MzdlNDEsIDB4NzI0ZTZjNWEsIDB4N2Y0NTYyNTMsIDB4NWM3NDQ4NmMsIDB4NTE3ZjQ2NjUsIDB4NDY2MjU0N2UsIDB4NGI2OTVhNzcsIDB4ZDBiMGUwOTAsIDB4ZGRiYmVlOTksIDB4Y2FhNmZjODIsIDB4YzdhZGYyOGIsIDB4ZTQ5Y2Q4YjQsIDB4ZTk5N2Q2YmQsIDB4ZmU4YWM0YTYsIDB4ZjM4MWNhYWYsIDB4YjhlODkwZDgsIDB4YjVlMzllZDEsIDB4YTJmZThjY2EsIDB4YWZmNTgyYzMsIDB4OGNjNGE4ZmMsIDB4ODFjZmE2ZjUsIDB4OTZkMmI0ZWUsIDB4OWJkOWJhZTcsIDB4YmI3YmRiM2IsIDB4YjY3MGQ1MzIsIDB4YTE2ZGM3MjksIDB4YWM2NmM5MjAsIDB4OGY1N2UzMWYsIDB4ODI1Y2VkMTYsIDB4OTU0MWZmMGQsIDB4OTg0YWYxMDQsIDB4ZDMyM2FiNzMsIDB4ZGUyOGE1N2EsIDB4YzkzNWI3NjEsIDB4YzQzZWI5NjgsIDB4ZTcwZjkzNTcsIDB4ZWEwNDlkNWUsIDB4ZmQxOThmNDUsIDB4ZjAxMjgxNGMsIDB4NmJjYjNiYWIsIDB4NjZjMDM1YTIsIDB4NzFkZDI3YjksIDB4N2NkNjI5YjAsIDB4NWZlNzAzOGYsIDB4NTJlYzBkODYsIDB4NDVmMTFmOWQsIDB4NDhmYTExOTQsIDB4MDM5MzRiZTMsIDB4MGU5ODQ1ZWEsIDB4MTk4NTU3ZjEsIDB4MTQ4ZTU5ZjgsIDB4MzdiZjczYzcsIDB4M2FiNDdkY2UsIDB4MmRhOTZmZDUsIDB4MjBhMjYxZGMsIDB4NmRmNmFkNzYsIDB4NjBmZGEzN2YsIDB4NzdlMGIxNjQsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4NTRkMTliNWIsIDB4NDNjYzg5NDAsIDB4NGVjNzg3NDksIDB4MDVhZWRkM2UsIDB4MDhhNWQzMzcsIDB4MWZiOGMxMmMsIDB4MTJiM2NmMjUsIDB4MzE4MmU1MWEsIDB4M2M4OWViMTMsIDB4MmI5NGY5MDgsIDB4MjY5ZmY3MDEsIDB4YmQ0NjRkZTYsIDB4YjA0ZDQzZWYsIDB4YTc1MDUxZjQsIDB4YWE1YjVmZmQsIDB4ODk2YTc1YzIsIDB4ODQ2MTdiY2IsIDB4OTM3YzY5ZDAsIDB4OWU3NzY3ZDksIDB4ZDUxZTNkYWUsIDB4ZDgxNTMzYTcsIDB4Y2YwODIxYmMsIDB4YzIwMzJmYjUsIDB4ZTEzMjA1OGEsIDB4ZWMzOTBiODMsIDB4ZmIyNDE5OTgsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4ZGI4Njc4NDQsIDB4Y2M5YjZhNWYsIDB4YzE5MDY0NTYsIDB4ZTJhMTRlNjksIDB4ZWZhYTQwNjAsIDB4ZjhiNzUyN2IsIDB4ZjViYzVjNzIsIDB4YmVkNTA2MDUsIDB4YjNkZTA4MGMsIDB4YTRjMzFhMTcsIDB4YTljODE0MWUsIDB4OGFmOTNlMjEsIDB4ODdmMjMwMjgsIDB4OTBlZjIyMzMsIDB4OWRlNDJjM2EsIDB4MDYzZDk2ZGQsIDB4MGIzNjk4ZDQsIDB4MWMyYjhhY2YsIDB4MTEyMDg0YzYsIDB4MzIxMWFlZjksIDB4M2YxYWEwZjAsIDB4MjgwN2IyZWIsIDB4MjUwY2JjZTIsIDB4NmU2NWU2OTUsIDB4NjM2ZWU4OWMsIDB4NzQ3M2ZhODcsIDB4Nzk3OGY0OGUsIDB4NWE0OWRlYjEsIDB4NTc0MmQwYjgsIDB4NDA1ZmMyYTMsIDB4NGQ1NGNjYWEsIDB4ZGFmNzQxZWMsIDB4ZDdmYzRmZTUsIDB4YzBlMTVkZmUsIDB4Y2RlYTUzZjcsIDB4ZWVkYjc5YzgsIDB4ZTNkMDc3YzEsIDB4ZjRjZDY1ZGEsIDB4ZjljNjZiZDMsIDB4YjJhZjMxYTQsIDB4YmZhNDNmYWQsIDB4YThiOTJkYjYsIDB4YTViMjIzYmYsIDB4ODY4MzA5ODAsIDB4OGI4ODA3ODksIDB4OWM5NTE1OTIsIDB4OTE5ZTFiOWIsIDB4MGE0N2ExN2MsIDB4MDc0Y2FmNzUsIDB4MTA1MWJkNmUsIDB4MWQ1YWIzNjcsIDB4M2U2Yjk5NTgsIDB4MzM2MDk3NTEsIDB4MjQ3ZDg1NGEsIDB4Mjk3NjhiNDMsIDB4NjIxZmQxMzQsIDB4NmYxNGRmM2QsIDB4NzgwOWNkMjYsIDB4NzUwMmMzMmYsIDB4NTYzM2U5MTAsIDB4NWIzOGU3MTksIDB4NGMyNWY1MDIsIDB4NDEyZWZiMGIsIDB4NjE4YzlhZDcsIDB4NmM4Nzk0ZGUsIDB4N2I5YTg2YzUsIDB4NzY5MTg4Y2MsIDB4NTVhMGEyZjMsIDB4NThhYmFjZmEsIDB4NGZiNmJlZTEsIDB4NDJiZGIwZTgsIDB4MDlkNGVhOWYsIDB4MDRkZmU0OTYsIDB4MTNjMmY2OGQsIDB4MWVjOWY4ODQsIDB4M2RmOGQyYmIsIDB4MzBmM2RjYjIsIDB4MjdlZWNlYTksIDB4MmFlNWMwYTAsIDB4YjEzYzdhNDcsIDB4YmMzNzc0NGUsIDB4YWIyYTY2NTUsIDB4YTYyMTY4NWMsIDB4ODUxMDQyNjMsIDB4ODgxYjRjNmEsIDB4OWYwNjVlNzEsIDB4OTIwZDUwNzgsIDB4ZDk2NDBhMGYsIDB4ZDQ2ZjA0MDYsIDB4YzM3MjE2MWQsIDB4Y2U3OTE4MTQsIDB4ZWQ0ODMyMmIsIDB4ZTA0MzNjMjIsIDB4Zjc1ZTJlMzksIDB4ZmE1NTIwMzAsIDB4YjcwMWVjOWEsIDB4YmEwYWUyOTMsIDB4YWQxN2YwODgsIDB4YTAxY2ZlODEsIDB4ODMyZGQ0YmUsIDB4OGUyNmRhYjcsIDB4OTkzYmM4YWMsIDB4OTQzMGM2YTUsIDB4ZGY1OTljZDIsIDB4ZDI1MjkyZGIsIDB4YzU0ZjgwYzAsIDB4Yzg0NDhlYzksIDB4ZWI3NWE0ZjYsIDB4ZTY3ZWFhZmYsIDB4ZjE2M2I4ZTQsIDB4ZmM2OGI2ZWQsIDB4NjdiMTBjMGEsIDB4NmFiYTAyMDMsIDB4N2RhNzEwMTgsIDB4NzBhYzFlMTEsIDB4NTM5ZDM0MmUsIDB4NWU5NjNhMjcsIDB4NDk4YjI4M2MsIDB4NDQ4MDI2MzUsIDB4MGZlOTdjNDIsIDB4MDJlMjcyNGIsIDB4MTVmZjYwNTAsIDB4MThmNDZlNTksIDB4M2JjNTQ0NjYsIDB4MzZjZTRhNmYsIDB4MjFkMzU4NzQsIDB4MmNkODU2N2QsIDB4MGM3YTM3YTEsIDB4MDE3MTM5YTgsIDB4MTY2YzJiYjMsIDB4MWI2NzI1YmEsIDB4Mzg1NjBmODUsIDB4MzU1ZDAxOGMsIDB4MjI0MDEzOTcsIDB4MmY0YjFkOWUsIDB4NjQyMjQ3ZTksIDB4NjkyOTQ5ZTAsIDB4N2UzNDViZmIsIDB4NzMzZjU1ZjIsIDB4NTAwZTdmY2QsIDB4NWQwNTcxYzQsIDB4NGExODYzZGYsIDB4NDcxMzZkZDYsIDB4ZGNjYWQ3MzEsIDB4ZDFjMWQ5MzgsIDB4YzZkY2NiMjMsIDB4Y2JkN2M1MmEsIDB4ZThlNmVmMTUsIDB4ZTVlZGUxMWMsIDB4ZjJmMGYzMDcsIDB4ZmZmYmZkMGUsIDB4YjQ5MmE3NzksIDB4Yjk5OWE5NzAsIDB4YWU4NGJiNmIsIDB4YTM4ZmI1NjIsIDB4ODBiZTlmNWQsIDB4OGRiNTkxNTQsIDB4OWFhODgzNGYsIDB4OTdhMzhkNDZdO1xuY29uc3QgVTQgPSBbMHgwMDAwMDAwMCwgMHgwOTBkMGIwZSwgMHgxMjFhMTYxYywgMHgxYjE3MWQxMiwgMHgyNDM0MmMzOCwgMHgyZDM5MjczNiwgMHgzNjJlM2EyNCwgMHgzZjIzMzEyYSwgMHg0ODY4NTg3MCwgMHg0MTY1NTM3ZSwgMHg1YTcyNGU2YywgMHg1MzdmNDU2MiwgMHg2YzVjNzQ0OCwgMHg2NTUxN2Y0NiwgMHg3ZTQ2NjI1NCwgMHg3NzRiNjk1YSwgMHg5MGQwYjBlMCwgMHg5OWRkYmJlZSwgMHg4MmNhYTZmYywgMHg4YmM3YWRmMiwgMHhiNGU0OWNkOCwgMHhiZGU5OTdkNiwgMHhhNmZlOGFjNCwgMHhhZmYzODFjYSwgMHhkOGI4ZTg5MCwgMHhkMWI1ZTM5ZSwgMHhjYWEyZmU4YywgMHhjM2FmZjU4MiwgMHhmYzhjYzRhOCwgMHhmNTgxY2ZhNiwgMHhlZTk2ZDJiNCwgMHhlNzliZDliYSwgMHgzYmJiN2JkYiwgMHgzMmI2NzBkNSwgMHgyOWExNmRjNywgMHgyMGFjNjZjOSwgMHgxZjhmNTdlMywgMHgxNjgyNWNlZCwgMHgwZDk1NDFmZiwgMHgwNDk4NGFmMSwgMHg3M2QzMjNhYiwgMHg3YWRlMjhhNSwgMHg2MWM5MzViNywgMHg2OGM0M2ViOSwgMHg1N2U3MGY5MywgMHg1ZWVhMDQ5ZCwgMHg0NWZkMTk4ZiwgMHg0Y2YwMTI4MSwgMHhhYjZiY2IzYiwgMHhhMjY2YzAzNSwgMHhiOTcxZGQyNywgMHhiMDdjZDYyOSwgMHg4ZjVmZTcwMywgMHg4NjUyZWMwZCwgMHg5ZDQ1ZjExZiwgMHg5NDQ4ZmExMSwgMHhlMzAzOTM0YiwgMHhlYTBlOTg0NSwgMHhmMTE5ODU1NywgMHhmODE0OGU1OSwgMHhjNzM3YmY3MywgMHhjZTNhYjQ3ZCwgMHhkNTJkYTk2ZiwgMHhkYzIwYTI2MSwgMHg3NjZkZjZhZCwgMHg3ZjYwZmRhMywgMHg2NDc3ZTBiMSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHg1YjU0ZDE5YiwgMHg0MDQzY2M4OSwgMHg0OTRlYzc4NywgMHgzZTA1YWVkZCwgMHgzNzA4YTVkMywgMHgyYzFmYjhjMSwgMHgyNTEyYjNjZiwgMHgxYTMxODJlNSwgMHgxMzNjODllYiwgMHgwODJiOTRmOSwgMHgwMTI2OWZmNywgMHhlNmJkNDY0ZCwgMHhlZmIwNGQ0MywgMHhmNGE3NTA1MSwgMHhmZGFhNWI1ZiwgMHhjMjg5NmE3NSwgMHhjYjg0NjE3YiwgMHhkMDkzN2M2OSwgMHhkOTllNzc2NywgMHhhZWQ1MWUzZCwgMHhhN2Q4MTUzMywgMHhiY2NmMDgyMSwgMHhiNWMyMDMyZiwgMHg4YWUxMzIwNSwgMHg4M2VjMzkwYiwgMHg5OGZiMjQxOSwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHg0NGRiODY3OCwgMHg1ZmNjOWI2YSwgMHg1NmMxOTA2NCwgMHg2OWUyYTE0ZSwgMHg2MGVmYWE0MCwgMHg3YmY4Yjc1MiwgMHg3MmY1YmM1YywgMHgwNWJlZDUwNiwgMHgwY2IzZGUwOCwgMHgxN2E0YzMxYSwgMHgxZWE5YzgxNCwgMHgyMThhZjkzZSwgMHgyODg3ZjIzMCwgMHgzMzkwZWYyMiwgMHgzYTlkZTQyYywgMHhkZDA2M2Q5NiwgMHhkNDBiMzY5OCwgMHhjZjFjMmI4YSwgMHhjNjExMjA4NCwgMHhmOTMyMTFhZSwgMHhmMDNmMWFhMCwgMHhlYjI4MDdiMiwgMHhlMjI1MGNiYywgMHg5NTZlNjVlNiwgMHg5YzYzNmVlOCwgMHg4Nzc0NzNmYSwgMHg4ZTc5NzhmNCwgMHhiMTVhNDlkZSwgMHhiODU3NDJkMCwgMHhhMzQwNWZjMiwgMHhhYTRkNTRjYywgMHhlY2RhZjc0MSwgMHhlNWQ3ZmM0ZiwgMHhmZWMwZTE1ZCwgMHhmN2NkZWE1MywgMHhjOGVlZGI3OSwgMHhjMWUzZDA3NywgMHhkYWY0Y2Q2NSwgMHhkM2Y5YzY2YiwgMHhhNGIyYWYzMSwgMHhhZGJmYTQzZiwgMHhiNmE4YjkyZCwgMHhiZmE1YjIyMywgMHg4MDg2ODMwOSwgMHg4OThiODgwNywgMHg5MjljOTUxNSwgMHg5YjkxOWUxYiwgMHg3YzBhNDdhMSwgMHg3NTA3NGNhZiwgMHg2ZTEwNTFiZCwgMHg2NzFkNWFiMywgMHg1ODNlNmI5OSwgMHg1MTMzNjA5NywgMHg0YTI0N2Q4NSwgMHg0MzI5NzY4YiwgMHgzNDYyMWZkMSwgMHgzZDZmMTRkZiwgMHgyNjc4MDljZCwgMHgyZjc1MDJjMywgMHgxMDU2MzNlOSwgMHgxOTViMzhlNywgMHgwMjRjMjVmNSwgMHgwYjQxMmVmYiwgMHhkNzYxOGM5YSwgMHhkZTZjODc5NCwgMHhjNTdiOWE4NiwgMHhjYzc2OTE4OCwgMHhmMzU1YTBhMiwgMHhmYTU4YWJhYywgMHhlMTRmYjZiZSwgMHhlODQyYmRiMCwgMHg5ZjA5ZDRlYSwgMHg5NjA0ZGZlNCwgMHg4ZDEzYzJmNiwgMHg4NDFlYzlmOCwgMHhiYjNkZjhkMiwgMHhiMjMwZjNkYywgMHhhOTI3ZWVjZSwgMHhhMDJhZTVjMCwgMHg0N2IxM2M3YSwgMHg0ZWJjMzc3NCwgMHg1NWFiMmE2NiwgMHg1Y2E2MjE2OCwgMHg2Mzg1MTA0MiwgMHg2YTg4MWI0YywgMHg3MTlmMDY1ZSwgMHg3ODkyMGQ1MCwgMHgwZmQ5NjQwYSwgMHgwNmQ0NmYwNCwgMHgxZGMzNzIxNiwgMHgxNGNlNzkxOCwgMHgyYmVkNDgzMiwgMHgyMmUwNDMzYywgMHgzOWY3NWUyZSwgMHgzMGZhNTUyMCwgMHg5YWI3MDFlYywgMHg5M2JhMGFlMiwgMHg4OGFkMTdmMCwgMHg4MWEwMWNmZSwgMHhiZTgzMmRkNCwgMHhiNzhlMjZkYSwgMHhhYzk5M2JjOCwgMHhhNTk0MzBjNiwgMHhkMmRmNTk5YywgMHhkYmQyNTI5MiwgMHhjMGM1NGY4MCwgMHhjOWM4NDQ4ZSwgMHhmNmViNzVhNCwgMHhmZmU2N2VhYSwgMHhlNGYxNjNiOCwgMHhlZGZjNjhiNiwgMHgwYTY3YjEwYywgMHgwMzZhYmEwMiwgMHgxODdkYTcxMCwgMHgxMTcwYWMxZSwgMHgyZTUzOWQzNCwgMHgyNzVlOTYzYSwgMHgzYzQ5OGIyOCwgMHgzNTQ0ODAyNiwgMHg0MjBmZTk3YywgMHg0YjAyZTI3MiwgMHg1MDE1ZmY2MCwgMHg1OTE4ZjQ2ZSwgMHg2NjNiYzU0NCwgMHg2ZjM2Y2U0YSwgMHg3NDIxZDM1OCwgMHg3ZDJjZDg1NiwgMHhhMTBjN2EzNywgMHhhODAxNzEzOSwgMHhiMzE2NmMyYiwgMHhiYTFiNjcyNSwgMHg4NTM4NTYwZiwgMHg4YzM1NWQwMSwgMHg5NzIyNDAxMywgMHg5ZTJmNGIxZCwgMHhlOTY0MjI0NywgMHhlMDY5Mjk0OSwgMHhmYjdlMzQ1YiwgMHhmMjczM2Y1NSwgMHhjZDUwMGU3ZiwgMHhjNDVkMDU3MSwgMHhkZjRhMTg2MywgMHhkNjQ3MTM2ZCwgMHgzMWRjY2FkNywgMHgzOGQxYzFkOSwgMHgyM2M2ZGNjYiwgMHgyYWNiZDdjNSwgMHgxNWU4ZTZlZiwgMHgxY2U1ZWRlMSwgMHgwN2YyZjBmMywgMHgwZWZmZmJmZCwgMHg3OWI0OTJhNywgMHg3MGI5OTlhOSwgMHg2YmFlODRiYiwgMHg2MmEzOGZiNSwgMHg1ZDgwYmU5ZiwgMHg1NDhkYjU5MSwgMHg0ZjlhYTg4MywgMHg0Njk3YTM4ZF07XG5mdW5jdGlvbiBjb252ZXJ0VG9JbnQzMihieXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goKGJ5dGVzW2ldIDw8IDI0KSB8IChieXRlc1tpICsgMV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAyXSA8PCA4KSB8IGJ5dGVzW2kgKyAzXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY2xhc3MgQUVTIHtcbiAgICBnZXQga2V5KCkgeyByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX2tleSwgXCJmXCIpLnNsaWNlKCk7IH1cbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgX0FFU19rZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Quc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Uuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBRVMpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BRVNfa2V5LCBuZXcgVWludDhBcnJheShrZXkpLCBcImZcIik7XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IG51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07XG4gICAgICAgIGlmIChyb3VuZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgc2l6ZSAobXVzdCBiZSAxNiwgMjQgb3IgMzIgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5jcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZSwgW10sIFwiZlwiKTtcbiAgICAgICAgLy8gZGVjcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZCwgW10sIFwiZlwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcm91bmRzOyBpKyspIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3VuZEtleUNvdW50ID0gKHJvdW5kcyArIDEpICogNDtcbiAgICAgICAgY29uc3QgS0MgPSB0aGlzLmtleS5sZW5ndGggLyA0O1xuICAgICAgICAvLyBjb252ZXJ0IHRoZSBrZXkgaW50byBpbnRzXG4gICAgICAgIGNvbnN0IHRrID0gY29udmVydFRvSW50MzIodGhpcy5rZXkpO1xuICAgICAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHJvdW5kIGtleSBhcnJheXNcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgIGluZGV4ID0gaSA+PiAyO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtleSBleHBhbnNpb24gKGZpcHMtMTk3IHNlY3Rpb24gNS4yKVxuICAgICAgICBsZXQgcmNvbnBvaW50ZXIgPSAwO1xuICAgICAgICBsZXQgdCA9IEtDLCB0dDtcbiAgICAgICAgd2hpbGUgKHQgPCByb3VuZEtleUNvdW50KSB7XG4gICAgICAgICAgICB0dCA9IHRrW0tDIC0gMV07XG4gICAgICAgICAgICB0a1swXSBePSAoKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDI0KSBeXG4gICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAoU1t0dCAmIDB4RkZdIDw8IDgpIF5cbiAgICAgICAgICAgICAgICBTWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgKHJjb25bcmNvbnBvaW50ZXJdIDw8IDI0KSk7XG4gICAgICAgICAgICByY29ucG9pbnRlciArPSAxO1xuICAgICAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiAoZm9yIG5vbi0yNTYgYml0KVxuICAgICAgICAgICAgaWYgKEtDICE9IDgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIGZvciAyNTYtYml0IGtleXMgaXMgXCJzbGlnaHRseSBkaWZmZXJlbnRcIiAoZmlwcy0xOTcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IChLQyAvIDIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0dCA9IHRrWyhLQyAvIDIpIC0gMV07XG4gICAgICAgICAgICAgICAgdGtbS0MgLyAyXSBePSAoU1t0dCAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgOCkgXlxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDI0KSAmIDB4RkZdIDw8IDI0KSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IChLQyAvIDIpICsgMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xuICAgICAgICAgICAgbGV0IGkgPSAwLCByLCBjO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBLQyAmJiB0IDwgcm91bmRLZXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHIgPSB0ID4+IDI7XG4gICAgICAgICAgICAgICAgYyA9IHQgJSA0O1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpW3JdW2NdID0gdGtbaV07XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gcl1bY10gPSB0a1tpKytdO1xuICAgICAgICAgICAgICAgIHQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbnZlcnNlLWNpcGhlci1pZnkgdGhlIGRlY3J5cHRpb24gcm91bmQga2V5IChmaXBzLTE5NyBzZWN0aW9uIDUuMylcbiAgICAgICAgZm9yIChsZXQgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA0OyBjKyspIHtcbiAgICAgICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdID0gKFUxWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUyWyh0dCA+PiAxNikgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUzWyh0dCA+PiA4KSAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgVTRbdHQgJiAweEZGXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91bmRzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIikubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgYSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXG4gICAgICAgIGxldCB0ID0gY29udmVydFRvSW50MzIocGxhaW50ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbMF1baV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgcm91bmQgdHJhbnNmb3Jtc1xuICAgICAgICBmb3IgKGxldCByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGFbaV0gPSAoVDFbKHRbaV0gPj4gMjQpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUM1sodFsoaSArIDIpICUgNF0gPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ0W3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gYS5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBsYXN0IHJvdW5kIGlzIHNwZWNpYWxcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBsZXQgdHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdHQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyb3VuZHNdW2ldO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpXSA9IChTWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU1sodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAyXSA9IChTWyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF4gKHR0ID4+IDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTW3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGEgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIC8vIGNvbnZlcnQgcGxhaW50ZXh0IHRvIChpbnRzIF4ga2V5KVxuICAgICAgICBsZXQgdCA9IGNvbnZlcnRUb0ludDMyKGNpcGhlcnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKVswXVtpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG4gICAgICAgIGZvciAobGV0IHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IChUNVsodFtpXSA+PiAyNCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ2Wyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ3Wyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgVDhbdFsoaSArIDEpICUgNF0gJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSBhLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGxhc3Qgcm91bmQgaXMgc3BlY2lhbFxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGxldCB0dCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JvdW5kc11baV07XG4gICAgICAgICAgICByZXN1bHRbNCAqIGldID0gKFNpWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU2lbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF4gKHR0ID4+IDE2KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+IDgpICYgMHhmZl0gXiAodHQgPj4gOCkpICYgMHhmZjtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDNdID0gKFNpW3RbKGkgKyAxKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuX0FFU19rZXkgPSBuZXcgV2Vha01hcCgpLCBfQUVTX0tkID0gbmV3IFdlYWtNYXAoKSwgX0FFU19LZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZXMuanMubWFwIiwiaW1wb3J0IHsgQUVTIH0gZnJvbSBcIi4vYWVzLmpzXCI7XG5leHBvcnQgY2xhc3MgTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBrZXksIGNscykge1xuICAgICAgICBpZiAoY2xzICYmICEodGhpcyBpbnN0YW5jZW9mIGNscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGluc3RhbnRpYXRlZCB3aXRoIFwibmV3XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBhZXM6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IG5ldyBBRVMoa2V5KSB9LFxuICAgICAgICAgICAgbmFtZTogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogbmFtZSB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUuanMubWFwIiwiLy8gQ2lwaGVyIEJsb2NrIENoYWluaW5nXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0NCQ19pdiwgX0NCQ19sYXN0QmxvY2s7XG5pbXBvcnQgeyBNb2RlT2ZPcGVyYXRpb24gfSBmcm9tIFwiLi9tb2RlLmpzXCI7XG5leHBvcnQgY2xhc3MgQ0JDIGV4dGVuZHMgTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGl2KSB7XG4gICAgICAgIHN1cGVyKFwiRUNDXCIsIGtleSwgQ0JDKTtcbiAgICAgICAgX0NCQ19pdi5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NCQ19sYXN0QmxvY2suc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmIChpdikge1xuICAgICAgICAgICAgaWYgKGl2Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgaXYgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DQkNfaXYsIG5ldyBVaW50OEFycmF5KGl2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0JDX2l2LCBuZXcgVWludDhBcnJheSgxNiksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCB0aGlzLml2LCBcImZcIik7XG4gICAgfVxuICAgIGdldCBpdigpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19pdiwgXCJmXCIpKTsgfVxuICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgIGlmIChwbGFpbnRleHQubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpW2pdIF49IHBsYWludGV4dFtpICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCB0aGlzLmFlcy5lbmNyeXB0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKSksIFwiZlwiKTtcbiAgICAgICAgICAgIGNpcGhlcnRleHQuc2V0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBuZXcgVWludDhBcnJheShjaXBoZXJ0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5hZXMuZGVjcnlwdChjaXBoZXJ0ZXh0LnN1YmFycmF5KGksIGkgKyAxNikpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0W2kgKyBqXSA9IGJsb2NrW2pdIF4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpW2pdO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIFwiZlwiKVtqXSA9IGNpcGhlcnRleHRbaSArIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfVxufVxuX0NCQ19pdiA9IG5ldyBXZWFrTWFwKCksIF9DQkNfbGFzdEJsb2NrID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtY2JjLmpzLm1hcCIsIi8vIENvdW50ZXIgTW9kZVxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9DVFJfcmVtYWluaW5nLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCBfQ1RSX2NvdW50ZXI7XG5pbXBvcnQgeyBNb2RlT2ZPcGVyYXRpb24gfSBmcm9tIFwiLi9tb2RlLmpzXCI7XG5leHBvcnQgY2xhc3MgQ1RSIGV4dGVuZHMgTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBzdXBlcihcIkNUUlwiLCBrZXksIENUUik7XG4gICAgICAgIC8vIFJlbWFpbmluZyBieXRlcyBmb3IgdGhlIG9uZS10aW1lIHBhZFxuICAgICAgICBfQ1RSX3JlbWFpbmluZy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NUUl9yZW1haW5pbmdJbmRleC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgY291bnRlclxuICAgICAgICBfQ1RSX2NvdW50ZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9jb3VudGVyLCBuZXcgVWludDhBcnJheSgxNiksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKS5maWxsKDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpLCBcImZcIik7IC8vIFRoaXMgd2lsbCBiZSBkaXNjYXJkZWQgaW1tZWRpYXRlbHlcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCAxNiwgXCJmXCIpO1xuICAgICAgICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoaW5pdGlhbFZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRDb3VudGVyVmFsdWUoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q291bnRlckJ5dGVzKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvdW50ZXIoKSB7IHJldHVybiBuZXcgVWludDhBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpKTsgfVxuICAgIHNldENvdW50ZXJWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjb3VudGVyIGluaXRpYWwgaW50ZWdlciB2YWx1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE1OyBpbmRleCA+PSAwOyAtLWluZGV4KSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2luZGV4XSA9IHZhbHVlICUgMjU2O1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gMjU2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDb3VudGVyQnl0ZXModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNvdW50ZXIgaW5pdGlhbCBVaW50OEFycmF5IHZhbHVlIGxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpLnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIGluY3JlbWVudCgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE1OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaV0gPT09IDI1NSkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpXSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNyeXB0dGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3J5cHR0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCBcImZcIikgPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZywgdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpKSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgMCwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcnlwdHRleHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX3JlbWFpbmluZywgXCJmXCIpW19fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgKF9iID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCBcImZcIiksIF9hID0gX2IrKywgX2IpLCBcImZcIiksIF9hXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3J5cHR0ZXh0O1xuICAgIH1cbiAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdChjaXBoZXJ0ZXh0KTtcbiAgICB9XG59XG5fQ1RSX3JlbWFpbmluZyA9IG5ldyBXZWFrTWFwKCksIF9DVFJfcmVtYWluaW5nSW5kZXggPSBuZXcgV2Vha01hcCgpLCBfQ1RSX2NvdW50ZXIgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS1jdHIuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIHBrY3M3UGFkKGRhdGEpIHtcbiAgICBjb25zdCBwYWRkZXIgPSAxNiAtIChkYXRhLmxlbmd0aCAlIDE2KTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIHBhZGRlcik7XG4gICAgcmVzdWx0LnNldChkYXRhKTtcbiAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gcGFkZGVyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBrY3M3U3RyaXAoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIGxlbmd0aCcpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkZXIgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgaWYgKHBhZGRlciA+IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BLQ1MjNyBwYWRkaW5nIGJ5dGUgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoIC0gcGFkZGVyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVyOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbbGVuZ3RoICsgaV0gIT09IHBhZGRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUEtDUyM3IGludmFsaWQgcGFkZGluZyBieXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEuc3ViYXJyYXkoMCwgbGVuZ3RoKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWRkaW5nLmpzLm1hcCIsIi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzQ29weSwgYXNzZXJ0QXJndW1lbnQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gbG9vc2VBcnJheWlmeShoZXhTdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIChoZXhTdHJpbmcpID09PSBcInN0cmluZ1wiICYmICFoZXhTdHJpbmcuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgIGhleFN0cmluZyA9IFwiMHhcIiArIGhleFN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIGdldEJ5dGVzQ29weShoZXhTdHJpbmcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHpwYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gJzAnICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXNzd29yZChwYXNzd29yZCkge1xuICAgIGlmICh0eXBlb2YgKHBhc3N3b3JkKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOEJ5dGVzKHBhc3N3b3JkLCBcIk5GS0NcIik7XG4gICAgfVxuICAgIHJldHVybiBnZXRCeXRlc0NvcHkocGFzc3dvcmQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwZWx1bmsob2JqZWN0LCBfcGF0aCkge1xuICAgIGNvbnN0IG1hdGNoID0gX3BhdGgubWF0Y2goL14oW2EtejAtOSRfLi1dKikoOihbYS16XSspKT8oISk/JC9pKTtcbiAgICBhc3NlcnRBcmd1bWVudChtYXRjaCAhPSBudWxsLCBcImludmFsaWQgcGF0aFwiLCBcInBhdGhcIiwgX3BhdGgpO1xuICAgIGNvbnN0IHBhdGggPSBtYXRjaFsxXTtcbiAgICBjb25zdCB0eXBlID0gbWF0Y2hbM107XG4gICAgY29uc3QgcmVxZCA9IChtYXRjaFs0XSA9PT0gXCIhXCIpO1xuICAgIGxldCBjdXIgPSBvYmplY3Q7XG4gICAgZm9yIChjb25zdCBjb21wIG9mIHBhdGgudG9Mb3dlckNhc2UoKS5zcGxpdCgnLicpKSB7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYSBjaGlsZCBvYmplY3Qgd2l0aCBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcga2V5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cikpIHtcbiAgICAgICAgICAgIGlmICghY29tcC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gY3VyW3BhcnNlSW50KGNvbXApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGN1cikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBjdXJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoIXJlcWQgfHwgY3VyICE9IG51bGwsIFwibWlzc2luZyByZXF1aXJlZCB2YWx1ZVwiLCBcInBhdGhcIiwgcGF0aCk7XG4gICAgaWYgKHR5cGUgJiYgY3VyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiaW50XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cikgPT09IFwic3RyaW5nXCIgJiYgY3VyLm1hdGNoKC9eLT9bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKGN1cikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjdXIpID09PSBcInN0cmluZ1wiICYmIGN1ci5tYXRjaCgvXi0/WzAtOS5dKiQvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjdXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlQXJyYXlpZnkoY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJhcnJheVwiICYmIEFycmF5LmlzQXJyYXkoY3VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gdHlwZW9mIChjdXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgd3JvbmcgdHlwZSBmb3VuZCBmb3IgJHt0eXBlfSBgLCBcInBhdGhcIiwgcGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBjdXI7XG59XG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGZvbGxvdyhvYmplY3Q6IGFueSwgcGF0aDogc3RyaW5nKTogbnVsbCB8IHN0cmluZyB7XG4gICAgbGV0IGN1cnJlbnRDaGlsZCA9IG9iamVjdDtcblxuICAgIGZvciAoY29uc3QgY29tcCBvZiBwYXRoLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy8nKSkge1xuXG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYSBjaGlsZCBvYmplY3Qgd2l0aCBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcga2V5XG4gICAgICAgIGxldCBtYXRjaGluZ0NoaWxkID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBjb21wKSB7XG4gICAgICAgICAgICAgICAgIG1hdGNoaW5nQ2hpbGQgPSBjdXJyZW50Q2hpbGRba2V5XTtcbiAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoaW5nQ2hpbGQgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgICBjdXJyZW50Q2hpbGQgPSBtYXRjaGluZ0NoaWxkO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50Q2hpbGQ7XG59XG5cbi8vIFwicGF0aC90by9zb21ldGhpbmc6dHlwZSFcIlxuZXhwb3J0IGZ1bmN0aW9uIGZvbGxvd1JlcXVpcmVkKGRhdGE6IGFueSwgcGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCB2YWx1ZSA9IGZvbGxvdyhkYXRhLCBwYXRoKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgeyByZXR1cm4gdmFsdWU7IH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdmFsdWVcIiwgYGRhdGE6JHsgcGF0aCB9YCxcbiAgICBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG59XG4qL1xuLy8gU2VlOiBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHQgKFNlY3Rpb24gNC40KVxuLypcbmV4cG9ydCBmdW5jdGlvbiB1dWlkVjQocmFuZG9tQnl0ZXM6IEJ5dGVzTGlrZSk6IHN0cmluZyB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhyYW5kb21CeXRlcywgXCJyYW5kb21CeXRlc1wiKTtcblxuICAgIC8vIFNlY3Rpb246IDQuMS4zOlxuICAgIC8vIC0gdGltZV9oaV9hbmRfdmVyc2lvblsxMjoxNl0gPSAwYjAxMDBcbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDtcblxuICAgIC8vIFNlY3Rpb24gNC40XG4gICAgLy8gLSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkWzZdID0gMGIwXG4gICAgLy8gLSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkWzddID0gMGIxXG4gICAgYnl0ZXNbOF0gPSAoYnl0ZXNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgICBjb25zdCB2YWx1ZSA9IGhleGxpZnkoYnl0ZXMpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMiwgMTApLFxuICAgICAgIHZhbHVlLnN1YnN0cmluZygxMCwgMTQpLFxuICAgICAgIHZhbHVlLnN1YnN0cmluZygxNCwgMTgpLFxuICAgICAgIHZhbHVlLnN1YnN0cmluZygxOCwgMjIpLFxuICAgICAgIHZhbHVlLnN1YnN0cmluZygyMiwgMzQpLFxuICAgIF0uam9pbihcIi1cIik7XG59XG4qL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiLyoqXG4gKiAgVGhlIEpTT04gV2FsbGV0IGZvcm1hdHMgYWxsb3cgYSBzaW1wbGUgd2F5IHRvIHN0b3JlIHRoZSBwcml2YXRlXG4gKiAga2V5cyBuZWVkZWQgaW4gRXRoZXJldW0gYWxvbmcgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uIGFuZCBhbGxvd3NcbiAqICBmb3IgZXh0ZW5zaWJsZSBmb3JtcyBvZiBlbmNyeXB0aW9uLlxuICpcbiAqICBUaGVzZSB1dGlsaXRpZXMgZmFjaWxpdGF0ZSBkZWNyeXB0aW5nIGFuZCBlbmNyeXB0aW5nIHRoZSBtb3N0IGNvbW1vblxuICogIEpTT04gV2FsbGV0IGZvcm1hdHMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3dhbGxldDpKU09OIFdhbGxldHMgIFtqc29uLXdhbGxldHNdXG4gKi9cbmltcG9ydCB7IENUUiB9IGZyb20gXCJhZXMtanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBwYmtkZjIsIHJhbmRvbUJ5dGVzLCBzY3J5cHQsIHNjcnlwdFN5bmMgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb21wdXRlQWRkcmVzcyB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBnZXRCeXRlcywgaGV4bGlmeSwgdXVpZFY0LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRQYXNzd29yZCwgc3BlbHVuaywgenBhZCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uLmpzXCI7XG5jb25zdCBkZWZhdWx0UGF0aCA9IFwibS80NCcvNjAnLzAnLzAvMFwiO1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlanNvbiUlIGlzIGEgdmFsaWQgSlNPTiBLZXlzdG9yZSBXYWxsZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0tleXN0b3JlSnNvbihqc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAoKGRhdGEudmVyc2lvbiAhPSBudWxsKSA/IHBhcnNlSW50KGRhdGEudmVyc2lvbikgOiAwKTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVjcnlwdChkYXRhLCBrZXksIGNpcGhlcnRleHQpIHtcbiAgICBjb25zdCBjaXBoZXIgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmNpcGhlcjpzdHJpbmdcIik7XG4gICAgaWYgKGNpcGhlciA9PT0gXCJhZXMtMTI4LWN0clwiKSB7XG4gICAgICAgIGNvbnN0IGl2ID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5jaXBoZXJwYXJhbXMuaXY6ZGF0YSFcIik7XG4gICAgICAgIGNvbnN0IGFlc0N0ciA9IG5ldyBDVFIoa2V5LCBpdik7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGFlc0N0ci5kZWNyeXB0KGNpcGhlcnRleHQpKTtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIGNpcGhlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJkZWNyeXB0XCJcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFjY291bnQoZGF0YSwgX2tleSkge1xuICAgIGNvbnN0IGtleSA9IGdldEJ5dGVzKF9rZXkpO1xuICAgIGNvbnN0IGNpcGhlcnRleHQgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmNpcGhlcnRleHQ6ZGF0YSFcIik7XG4gICAgY29uc3QgY29tcHV0ZWRNQUMgPSBoZXhsaWZ5KGtlY2NhazI1Nihjb25jYXQoW2tleS5zbGljZSgxNiwgMzIpLCBjaXBoZXJ0ZXh0XSkpKS5zdWJzdHJpbmcoMik7XG4gICAgYXNzZXJ0QXJndW1lbnQoY29tcHV0ZWRNQUMgPT09IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ubWFjOnN0cmluZyFcIikudG9Mb3dlckNhc2UoKSwgXCJpbmNvcnJlY3QgcGFzc3dvcmRcIiwgXCJwYXNzd29yZFwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gZGVjcnlwdChkYXRhLCBrZXkuc2xpY2UoMCwgMTYpLCBjaXBoZXJ0ZXh0KTtcbiAgICBjb25zdCBhZGRyZXNzID0gY29tcHV0ZUFkZHJlc3MocHJpdmF0ZUtleSk7XG4gICAgaWYgKGRhdGEuYWRkcmVzcykge1xuICAgICAgICBsZXQgY2hlY2sgPSBkYXRhLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCFjaGVjay5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGNoZWNrID0gXCIweFwiICsgY2hlY2s7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZ2V0QWRkcmVzcyhjaGVjaykgPT09IGFkZHJlc3MsIFwia2V5c3RvcmUgYWRkcmVzcy9wcml2YXRlS2V5IG1pc21hdGNoXCIsIFwiYWRkcmVzc1wiLCBkYXRhLmFkZHJlc3MpO1xuICAgIH1cbiAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzLCBwcml2YXRlS2V5IH07XG4gICAgLy8gVmVyc2lvbiAwLjEgeC1ldGhlcnMgbWV0YWRhdGEgbXVzdCBjb250YWluIGFuIGVuY3J5cHRlZCBtbmVtb25pYyBwaHJhc2VcbiAgICBjb25zdCB2ZXJzaW9uID0gc3BlbHVuayhkYXRhLCBcIngtZXRoZXJzLnZlcnNpb246c3RyaW5nXCIpO1xuICAgIGlmICh2ZXJzaW9uID09PSBcIjAuMVwiKSB7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljS2V5ID0ga2V5LnNsaWNlKDMyLCA2NCk7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQ2lwaGVydGV4dCA9IHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy5tbmVtb25pY0NpcGhlcnRleHQ6ZGF0YSFcIik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljSXYgPSBzcGVsdW5rKGRhdGEsIFwieC1ldGhlcnMubW5lbW9uaWNDb3VudGVyOmRhdGEhXCIpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0Flc0N0ciA9IG5ldyBDVFIobW5lbW9uaWNLZXksIG1uZW1vbmljSXYpO1xuICAgICAgICBhY2NvdW50Lm1uZW1vbmljID0ge1xuICAgICAgICAgICAgcGF0aDogKHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy5wYXRoOnN0cmluZ1wiKSB8fCBkZWZhdWx0UGF0aCksXG4gICAgICAgICAgICBsb2NhbGU6IChzcGVsdW5rKGRhdGEsIFwieC1ldGhlcnMubG9jYWxlOnN0cmluZ1wiKSB8fCBcImVuXCIpLFxuICAgICAgICAgICAgZW50cm9weTogaGV4bGlmeShnZXRCeXRlcyhtbmVtb25pY0Flc0N0ci5kZWNyeXB0KG1uZW1vbmljQ2lwaGVydGV4dCkpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudDtcbn1cbmZ1bmN0aW9uIGdldERlY3J5cHRLZGZQYXJhbXMoZGF0YSkge1xuICAgIGNvbnN0IGtkZiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmOnN0cmluZ1wiKTtcbiAgICBpZiAoa2RmICYmIHR5cGVvZiAoa2RmKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoa2RmLnRvTG93ZXJDYXNlKCkgPT09IFwic2NyeXB0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbHQgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5zYWx0OmRhdGEhXCIpO1xuICAgICAgICAgICAgY29uc3QgTiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLm46aW50IVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5yOmludCFcIik7XG4gICAgICAgICAgICBjb25zdCBwID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMucDppbnQhXCIpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIE4gaXMgYSBwb3dlciBvZiAyXG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOID4gMCAmJiAoTiAmIChOIC0gMSkpID09PSAwLCBcImludmFsaWQga2RmLk5cIiwgXCJrZGYuTlwiLCBOKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHIgPiAwICYmIHAgPiAwLCBcImludmFsaWQga2RmXCIsIFwia2RmXCIsIGtkZik7XG4gICAgICAgICAgICBjb25zdCBka0xlbiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmRrbGVuOmludCFcIik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChka0xlbiA9PT0gMzIsIFwiaW52YWxpZCBrZGYuZGtsZW5cIiwgXCJrZGYuZGZsZW5cIiwgZGtMZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJzY3J5cHRcIiwgc2FsdCwgTiwgciwgcCwgZGtMZW46IDY0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2RmLnRvTG93ZXJDYXNlKCkgPT09IFwicGJrZGYyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbHQgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5zYWx0OmRhdGEhXCIpO1xuICAgICAgICAgICAgY29uc3QgcHJmID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMucHJmOnN0cmluZyFcIik7XG4gICAgICAgICAgICBjb25zdCBhbGdvcml0aG0gPSBwcmYuc3BsaXQoXCItXCIpLnBvcCgpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWxnb3JpdGhtID09PSBcInNoYTI1NlwiIHx8IGFsZ29yaXRobSA9PT0gXCJzaGE1MTJcIiwgXCJpbnZhbGlkIGtkZi5wZGZcIiwgXCJrZGYucGRmXCIsIHByZik7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmM6aW50IVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRrTGVuID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuZGtsZW46aW50IVwiKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGRrTGVuID09PSAzMiwgXCJpbnZhbGlkIGtkZi5ka2xlblwiLCBcImtkZi5ka2xlblwiLCBka0xlbik7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcInBia2RmMlwiLCBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uXCIsIFwia2RmXCIsIGtkZik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhY2NvdW50IGRldGFpbHMgZm9yIHRoZSBKU09OIEtleXN0b3JlIFdhbGxldCAlJWpzb24lJVxuICogIHVzaW5nICUlcGFzc3dvcmQlJS5cbiAqXG4gKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZlcnNpb25dKGRlY3J5cHRLZXlzdG9yZUpzb24pXG4gKiAgaW5zdGVhZCwgd2hpY2ggYWxsb3dzIGEgW1tQcm9ncmVzc0NhbGxiYWNrXV0gdG8ga2VlcCB0aGUgdXNlciBpbmZvcm1lZFxuICogIGFzIHRvIHRoZSBkZWNyeXB0aW9uIHN0YXR1cy5cbiAqXG4gKiAgVGhpcyBtZXRob2Qgd2lsbCBibG9jayB0aGUgZXZlbnQgbG9vcCAoZnJlZXppbmcgYWxsIFVJKSB1bnRpbCBkZWNyeXB0aW9uXG4gKiAgaXMgY29tcGxldGUsIHdoaWNoIGNhbiB0YWtlIHF1aXRlIHNvbWUgdGltZSwgZGVwZW5kaW5nIG9uIHRoZSB3YWxsZXRcbiAqICBwYXJhbXRlcnMgYW5kIHBsYXRmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdEtleXN0b3JlSnNvblN5bmMoanNvbiwgX3Bhc3N3b3JkKSB7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgY29uc3QgcGFzc3dvcmQgPSBnZXRQYXNzd29yZChfcGFzc3dvcmQpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGdldERlY3J5cHRLZGZQYXJhbXMoZGF0YSk7XG4gICAgaWYgKHBhcmFtcy5uYW1lID09PSBcInBia2RmMlwiKSB7XG4gICAgICAgIGNvbnN0IHsgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0gfSA9IHBhcmFtcztcbiAgICAgICAgY29uc3Qga2V5ID0gcGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSk7XG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XG4gICAgfVxuICAgIGFzc2VydChwYXJhbXMubmFtZSA9PT0gXCJzY3J5cHRcIiwgXCJjYW5ub3QgYmUgcmVhY2hlZFwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBwYXJhbXMgfSk7XG4gICAgY29uc3QgeyBzYWx0LCBOLCByLCBwLCBka0xlbiB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGtleSA9IHNjcnlwdFN5bmMocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKTtcbiAgICByZXR1cm4gZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dCgoKSA9PiB7IHJlc29sdmUoKTsgfSwgZHVyYXRpb24pOyB9KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIHRoZSBkZWNyeXB0ZWQgSlNPTiBLZXlzdG9yZSBXYWxsZXQgJSVqc29uJSUgdXNpbmcgdGhlXG4gKiAgJSVwYXNzd29yZCUlLlxuICpcbiAqICBJZiBwcm92aWRlZCwgJSVwcm9ncmVzcyUlIHdpbGwgYmUgY2FsbGVkIHBlcmlvZGljYWxseSBkdXJpbmcgdGhlXG4gKiAgZGVjcnB5dGlvbiB0byBwcm92aWRlIGZlZWRiYWNrLCBhbmQgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAqICBgYGZhbHNlYGAgd2lsbCBoYWx0IGRlY3J5cHRpb24uXG4gKlxuICogIFRoZSAlJXByb2dyZXNzQ2FsbGJhY2slJSB3aWxsICoqYWx3YXlzKiogcmVjZWl2ZSBgYDBgYCBiZWZvcmVcbiAqICBkZWNyeXB0aW9uIGJlZ2lucyBhbmQgYGAxYGAgd2hlbiBjb21wbGV0ZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRLZXlzdG9yZUpzb24oanNvbiwgX3Bhc3N3b3JkLCBwcm9ncmVzcykge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gZ2V0UGFzc3dvcmQoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBwYXJhbXMgPSBnZXREZWNyeXB0S2RmUGFyYW1zKGRhdGEpO1xuICAgIGlmIChwYXJhbXMubmFtZSA9PT0gXCJwYmtkZjJcIikge1xuICAgICAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHByb2dyZXNzKDApO1xuICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBrZXkgPSBwYmtkZjIocGFzc3dvcmQsIHNhbHQsIGNvdW50LCBka0xlbiwgYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICBwcm9ncmVzcygxKTtcbiAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XG4gICAgfVxuICAgIGFzc2VydChwYXJhbXMubmFtZSA9PT0gXCJzY3J5cHRcIiwgXCJjYW5ub3QgYmUgcmVhY2hlZFwiLCBcIlVOS05PV05fRVJST1JcIiwgeyBwYXJhbXMgfSk7XG4gICAgY29uc3QgeyBzYWx0LCBOLCByLCBwLCBka0xlbiB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHNjcnlwdChwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIHByb2dyZXNzKTtcbiAgICByZXR1cm4gZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xufVxuZnVuY3Rpb24gZ2V0RW5jcnlwdEtkZlBhcmFtcyhvcHRpb25zKSB7XG4gICAgLy8gQ2hlY2svZ2VuZXJhdGUgdGhlIHNhbHRcbiAgICBjb25zdCBzYWx0ID0gKG9wdGlvbnMuc2FsdCAhPSBudWxsKSA/IGdldEJ5dGVzKG9wdGlvbnMuc2FsdCwgXCJvcHRpb25zLnNhbHRcIikgOiByYW5kb21CeXRlcygzMik7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIHNjcnlwdCBwYXNzd29yZC1iYXNlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzXG4gICAgbGV0IE4gPSAoMSA8PCAxNyksIHIgPSA4LCBwID0gMTtcbiAgICBpZiAob3B0aW9ucy5zY3J5cHQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0Lk4pIHtcbiAgICAgICAgICAgIE4gPSBvcHRpb25zLnNjcnlwdC5OO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5yKSB7XG4gICAgICAgICAgICByID0gb3B0aW9ucy5zY3J5cHQucjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQucCkge1xuICAgICAgICAgICAgcCA9IG9wdGlvbnMuc2NyeXB0LnA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChOKSA9PT0gXCJudW1iZXJcIiAmJiBOID4gMCAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihOKSAmJiAoQmlnSW50KE4pICYgQmlnSW50KE4gLSAxKSkgPT09IEJpZ0ludCgwKSwgXCJpbnZhbGlkIHNjcnlwdCBOIHBhcmFtZXRlclwiLCBcIm9wdGlvbnMuTlwiLCBOKTtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHIpID09PSBcIm51bWJlclwiICYmIHIgPiAwICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHIpLCBcImludmFsaWQgc2NyeXB0IHIgcGFyYW1ldGVyXCIsIFwib3B0aW9ucy5yXCIsIHIpO1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAocCkgPT09IFwibnVtYmVyXCIgJiYgcCA+IDAgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIocCksIFwiaW52YWxpZCBzY3J5cHQgcCBwYXJhbWV0ZXJcIiwgXCJvcHRpb25zLnBcIiwgcCk7XG4gICAgcmV0dXJuIHsgbmFtZTogXCJzY3J5cHRcIiwgZGtMZW46IDMyLCBzYWx0LCBOLCByLCBwIH07XG59XG5mdW5jdGlvbiBfZW5jcnlwdEtleXN0b3JlKGtleSwga2RmLCBhY2NvdW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGdldEJ5dGVzKGFjY291bnQucHJpdmF0ZUtleSwgXCJwcml2YXRlS2V5XCIpO1xuICAgIC8vIE92ZXJyaWRlIGluaXRpYWxpemF0aW9uIHZlY3RvclxuICAgIGNvbnN0IGl2ID0gKG9wdGlvbnMuaXYgIT0gbnVsbCkgPyBnZXRCeXRlcyhvcHRpb25zLml2LCBcIm9wdGlvbnMuaXZcIikgOiByYW5kb21CeXRlcygxNik7XG4gICAgYXNzZXJ0QXJndW1lbnQoaXYubGVuZ3RoID09PSAxNiwgXCJpbnZhbGlkIG9wdGlvbnMuaXYgbGVuZ3RoXCIsIFwib3B0aW9ucy5pdlwiLCBvcHRpb25zLml2KTtcbiAgICAvLyBPdmVycmlkZSB0aGUgdXVpZFxuICAgIGNvbnN0IHV1aWRSYW5kb20gPSAob3B0aW9ucy51dWlkICE9IG51bGwpID8gZ2V0Qnl0ZXMob3B0aW9ucy51dWlkLCBcIm9wdGlvbnMudXVpZFwiKSA6IHJhbmRvbUJ5dGVzKDE2KTtcbiAgICBhc3NlcnRBcmd1bWVudCh1dWlkUmFuZG9tLmxlbmd0aCA9PT0gMTYsIFwiaW52YWxpZCBvcHRpb25zLnV1aWQgbGVuZ3RoXCIsIFwib3B0aW9ucy51dWlkXCIsIG9wdGlvbnMuaXYpO1xuICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIHdhbGxldCAoYXMgcGVyIFdlYjMgc2VjcmV0IHN0b3JhZ2UpXG4gICAgLy8gLSAzMiBieXRlcyAgIEFzIG5vcm1hbCBmb3IgdGhlIFdlYjMgc2VjcmV0IHN0b3JhZ2UgKGRlcml2ZWRLZXksIG1hY1ByZWZpeClcbiAgICAvLyAtIDMyIGJ5dGVzICAgQUVTIGtleSB0byBlbmNyeXB0IG1uZW1vbmljIHdpdGggKHJlcXVpcmVkIGhlcmUgdG8gYmUgRXRoZXJzIFdhbGxldClcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0ga2V5LnNsaWNlKDAsIDE2KTtcbiAgICBjb25zdCBtYWNQcmVmaXggPSBrZXkuc2xpY2UoMTYsIDMyKTtcbiAgICAvLyBFbmNyeXB0IHRoZSBwcml2YXRlIGtleVxuICAgIGNvbnN0IGFlc0N0ciA9IG5ldyBDVFIoZGVyaXZlZEtleSwgaXYpO1xuICAgIGNvbnN0IGNpcGhlcnRleHQgPSBnZXRCeXRlcyhhZXNDdHIuZW5jcnlwdChwcml2YXRlS2V5KSk7XG4gICAgLy8gQ29tcHV0ZSB0aGUgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLCB1c2VkIHRvIGNoZWNrIHRoZSBwYXNzd29yZFxuICAgIGNvbnN0IG1hYyA9IGtlY2NhazI1Nihjb25jYXQoW21hY1ByZWZpeCwgY2lwaGVydGV4dF0pKTtcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvV2ViMy1TZWNyZXQtU3RvcmFnZS1EZWZpbml0aW9uXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgYWRkcmVzczogYWNjb3VudC5hZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBpZDogdXVpZFY0KHV1aWRSYW5kb20pLFxuICAgICAgICB2ZXJzaW9uOiAzLFxuICAgICAgICBDcnlwdG86IHtcbiAgICAgICAgICAgIGNpcGhlcjogXCJhZXMtMTI4LWN0clwiLFxuICAgICAgICAgICAgY2lwaGVycGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgaXY6IGhleGxpZnkoaXYpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0OiBoZXhsaWZ5KGNpcGhlcnRleHQpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgIGtkZjogXCJzY3J5cHRcIixcbiAgICAgICAgICAgIGtkZnBhcmFtczoge1xuICAgICAgICAgICAgICAgIHNhbHQ6IGhleGxpZnkoa2RmLnNhbHQpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgICAgICBuOiBrZGYuTixcbiAgICAgICAgICAgICAgICBka2xlbjogMzIsXG4gICAgICAgICAgICAgICAgcDoga2RmLnAsXG4gICAgICAgICAgICAgICAgcjoga2RmLnJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYWM6IG1hYy5zdWJzdHJpbmcoMilcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSWYgd2UgaGF2ZSBhIG1uZW1vbmljLCBlbmNyeXB0IGl0IGludG8gdGhlIEpTT04gd2FsbGV0XG4gICAgaWYgKGFjY291bnQubW5lbW9uaWMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gKG9wdGlvbnMuY2xpZW50ICE9IG51bGwpID8gb3B0aW9ucy5jbGllbnQgOiBgZXRoZXJzLyR7dmVyc2lvbn1gO1xuICAgICAgICBjb25zdCBwYXRoID0gYWNjb3VudC5tbmVtb25pYy5wYXRoIHx8IGRlZmF1bHRQYXRoO1xuICAgICAgICBjb25zdCBsb2NhbGUgPSBhY2NvdW50Lm1uZW1vbmljLmxvY2FsZSB8fCBcImVuXCI7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljS2V5ID0ga2V5LnNsaWNlKDMyLCA2NCk7XG4gICAgICAgIGNvbnN0IGVudHJvcHkgPSBnZXRCeXRlcyhhY2NvdW50Lm1uZW1vbmljLmVudHJvcHksIFwiYWNjb3VudC5tbmVtb25pYy5lbnRyb3B5XCIpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0l2ID0gcmFuZG9tQnl0ZXMoMTYpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0Flc0N0ciA9IG5ldyBDVFIobW5lbW9uaWNLZXksIG1uZW1vbmljSXYpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0NpcGhlcnRleHQgPSBnZXRCeXRlcyhtbmVtb25pY0Flc0N0ci5lbmNyeXB0KGVudHJvcHkpKTtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gKG5vdy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDTW9udGgoKSArIDEsIDIpICsgXCItXCIgK1xuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDRGF0ZSgpLCAyKSArIFwiVFwiICtcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ0hvdXJzKCksIDIpICsgXCItXCIgK1xuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDTWludXRlcygpLCAyKSArIFwiLVwiICtcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ1NlY29uZHMoKSwgMikgKyBcIi4wWlwiKTtcbiAgICAgICAgY29uc3QgZ2V0aEZpbGVuYW1lID0gKFwiVVRDLS1cIiArIHRpbWVzdGFtcCArIFwiLS1cIiArIGRhdGEuYWRkcmVzcyk7XG4gICAgICAgIGRhdGFbXCJ4LWV0aGVyc1wiXSA9IHtcbiAgICAgICAgICAgIGNsaWVudCwgZ2V0aEZpbGVuYW1lLCBwYXRoLCBsb2NhbGUsXG4gICAgICAgICAgICBtbmVtb25pY0NvdW50ZXI6IGhleGxpZnkobW5lbW9uaWNJdikuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgbW5lbW9uaWNDaXBoZXJ0ZXh0OiBoZXhsaWZ5KG1uZW1vbmljQ2lwaGVydGV4dCkuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgdmVyc2lvbjogXCIwLjFcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIEpTT04gS2V5c3RvcmUgV2FsbGV0IGZvciAlJWFjY291bnQlJSBlbmNyeXB0ZWQgd2l0aFxuICogICUlcGFzc3dvcmQlJS5cbiAqXG4gKiAgVGhlICUlb3B0aW9ucyUlIGNhbiBiZSB1c2VkIHRvIHR1bmUgdGhlIHBhc3N3b3JkLWJhc2VkIGtleVxuICogIGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVycywgZXhwbGljaXRseSBzZXQgdGhlIHJhbmRvbSB2YWx1ZXNcbiAqICB1c2VkLiBBbnkgcHJvdmlkZWQgW1tQcm9ncmVzc0NhbGxiYWNrXV0gaXMgaWdub3JkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jcnlwdEtleXN0b3JlSnNvblN5bmMoYWNjb3VudCwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFzc3dvcmRCeXRlcyA9IGdldFBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgICBjb25zdCBrZGYgPSBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGtleSA9IHNjcnlwdFN5bmMocGFzc3dvcmRCeXRlcywga2RmLnNhbHQsIGtkZi5OLCBrZGYuciwga2RmLnAsIDY0KTtcbiAgICByZXR1cm4gX2VuY3J5cHRLZXlzdG9yZShnZXRCeXRlcyhrZXkpLCBrZGYsIGFjY291bnQsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiAgUmVzb2x2ZWQgdG8gdGhlIEpTT04gS2V5c3RvcmUgV2FsbGV0IGZvciAlJWFjY291bnQlJSBlbmNyeXB0ZWRcbiAqICB3aXRoICUlcGFzc3dvcmQlJS5cbiAqXG4gKiAgVGhlICUlb3B0aW9ucyUlIGNhbiBiZSB1c2VkIHRvIHR1bmUgdGhlIHBhc3N3b3JkLWJhc2VkIGtleVxuICogIGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVycywgZXhwbGljaXRseSBzZXQgdGhlIHJhbmRvbSB2YWx1ZXNcbiAqICB1c2VkIGFuZCBwcm92aWRlIGEgW1tQcm9ncmVzc0NhbGxiYWNrXV0gdG8gcmVjZWl2ZSBwZXJpb2RpYyB1cGRhdGVzXG4gKiAgb24gdGhlIGNvbXBsZXRpb24gc3RhdHVzLi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRLZXlzdG9yZUpzb24oYWNjb3VudCwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFzc3dvcmRCeXRlcyA9IGdldFBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgICBjb25zdCBrZGYgPSBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHNjcnlwdChwYXNzd29yZEJ5dGVzLCBrZGYuc2FsdCwga2RmLk4sIGtkZi5yLCBrZGYucCwgNjQsIG9wdGlvbnMucHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgcmV0dXJuIF9lbmNyeXB0S2V5c3RvcmUoZ2V0Qnl0ZXMoa2V5KSwga2RmLCBhY2NvdW50LCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24ta2V5c3RvcmUuanMubWFwIiwiLyoqXG4gKiAgRXhwbGFpbiBIRCBXYWxsZXRzLi5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvd2FsbGV0OkhEIFdhbGxldHMgIFtoZC13YWxsZXRzXVxuICovXG5pbXBvcnQgeyBjb21wdXRlSG1hYywgcmFuZG9tQnl0ZXMsIHJpcGVtZDE2MCwgU2lnbmluZ0tleSwgc2hhMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVm9pZFNpZ25lciB9IGZyb20gXCIuLi9wcm92aWRlcnMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbXB1dGVBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFTbGljZSwgZGVjb2RlQmFzZTU4LCBkZWZpbmVQcm9wZXJ0aWVzLCBlbmNvZGVCYXNlNTgsIGdldEJ5dGVzLCBoZXhsaWZ5LCBpc0J5dGVzTGlrZSwgZ2V0TnVtYmVyLCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b0JlSGV4LCBhc3NlcnRQcml2YXRlLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBMYW5nRW4gfSBmcm9tIFwiLi4vd29yZGxpc3RzL2xhbmctZW4uanNcIjtcbmltcG9ydCB7IEJhc2VXYWxsZXQgfSBmcm9tIFwiLi9iYXNlLXdhbGxldC5qc1wiO1xuaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tIFwiLi9tbmVtb25pYy5qc1wiO1xuaW1wb3J0IHsgZW5jcnlwdEtleXN0b3JlSnNvbiwgZW5jcnlwdEtleXN0b3JlSnNvblN5bmMsIH0gZnJvbSBcIi4vanNvbi1rZXlzdG9yZS5qc1wiO1xuLyoqXG4gKiAgVGhlIGRlZmF1bHQgZGVyaXZhdGlvbiBwYXRoIGZvciBFdGhlcmV1bSBIRCBOb2Rlcy4gKGkuZS4gYGBcIm0vNDQnLzYwJy8wJy8wLzBcImBgKVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFBhdGggPSBcIm0vNDQnLzYwJy8wJy8wLzBcIjtcbi8vIFwiQml0Y29pbiBzZWVkXCJcbmNvbnN0IE1hc3RlclNlY3JldCA9IG5ldyBVaW50OEFycmF5KFs2NiwgMTA1LCAxMTYsIDk5LCAxMTEsIDEwNSwgMTEwLCAzMiwgMTE1LCAxMDEsIDEwMSwgMTAwXSk7XG5jb25zdCBIYXJkZW5lZEJpdCA9IDB4ODAwMDAwMDA7XG5jb25zdCBOID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxXCIpO1xuY29uc3QgTmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuZnVuY3Rpb24genBhZCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdCA9IE5pYmJsZXNbdmFsdWUgJSAxNl0gKyByZXN1bHQ7XG4gICAgICAgIHZhbHVlID0gTWF0aC50cnVuYyh2YWx1ZSAvIDE2KTtcbiAgICB9XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBsZW5ndGggKiAyKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gZW5jb2RlQmFzZTU4Q2hlY2soX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRCeXRlcyhfdmFsdWUpO1xuICAgIGNvbnN0IGNoZWNrID0gZGF0YVNsaWNlKHNoYTI1NihzaGEyNTYodmFsdWUpKSwgMCwgNCk7XG4gICAgY29uc3QgYnl0ZXMgPSBjb25jYXQoW3ZhbHVlLCBjaGVja10pO1xuICAgIHJldHVybiBlbmNvZGVCYXNlNTgoYnl0ZXMpO1xufVxuY29uc3QgX2d1YXJkID0ge307XG5mdW5jdGlvbiBzZXJfSShpbmRleCwgY2hhaW5Db2RlLCBwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoMzcpO1xuICAgIGlmIChpbmRleCAmIEhhcmRlbmVkQml0KSB7XG4gICAgICAgIGFzc2VydChwcml2YXRlS2V5ICE9IG51bGwsIFwiY2Fubm90IGRlcml2ZSBjaGlsZCBvZiBuZXV0ZXJlZCBub2RlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkZXJpdmVDaGlsZFwiXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEYXRhID0gMHgwMCB8fCBzZXJfMjU2KGtfcGFyKVxuICAgICAgICBkYXRhLnNldChnZXRCeXRlcyhwcml2YXRlS2V5KSwgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEYXRhID0gc2VyX3AocG9pbnQoa19wYXIpKVxuICAgICAgICBkYXRhLnNldChnZXRCeXRlcyhwdWJsaWNLZXkpKTtcbiAgICB9XG4gICAgLy8gRGF0YSArPSBzZXJfMzIoaSlcbiAgICBmb3IgKGxldCBpID0gMjQ7IGkgPj0gMDsgaSAtPSA4KSB7XG4gICAgICAgIGRhdGFbMzMgKyAoaSA+PiAzKV0gPSAoKGluZGV4ID4+ICgyNCAtIGkpKSAmIDB4ZmYpO1xuICAgIH1cbiAgICBjb25zdCBJID0gZ2V0Qnl0ZXMoY29tcHV0ZUhtYWMoXCJzaGE1MTJcIiwgY2hhaW5Db2RlLCBkYXRhKSk7XG4gICAgcmV0dXJuIHsgSUw6IEkuc2xpY2UoMCwgMzIpLCBJUjogSS5zbGljZSgzMikgfTtcbn1cbmZ1bmN0aW9uIGRlcml2ZVBhdGgobm9kZSwgcGF0aCkge1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICBhc3NlcnRBcmd1bWVudChjb21wb25lbnRzLmxlbmd0aCA+IDAsIFwiaW52YWxpZCBwYXRoXCIsIFwicGF0aFwiLCBwYXRoKTtcbiAgICBpZiAoY29tcG9uZW50c1swXSA9PT0gXCJtXCIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobm9kZS5kZXB0aCA9PT0gMCwgYGNhbm5vdCBkZXJpdmUgcm9vdCBwYXRoIChpLmUuIHBhdGggc3RhcnRpbmcgd2l0aCBcIm0vXCIpIGZvciBhIG5vZGUgYXQgbm9uLXplcm8gZGVwdGggJHtub2RlLmRlcHRofWAsIFwicGF0aFwiLCBwYXRoKTtcbiAgICAgICAgY29tcG9uZW50cy5zaGlmdCgpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gbm9kZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5tYXRjaCgvXlswLTldKyckLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoY29tcG9uZW50LnN1YnN0cmluZygwLCBjb21wb25lbnQubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIHBhdGggaW5kZXhcIiwgYHBhdGhbJHtpfV1gLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRlcml2ZUNoaWxkKEhhcmRlbmVkQml0ICsgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIHBhdGggaW5kZXhcIiwgYHBhdGhbJHtpfV1gLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRlcml2ZUNoaWxkKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgcGF0aCBjb21wb25lbnRcIiwgYHBhdGhbJHtpfV1gLCBjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBBbiAqKkhETm9kZVdhbGxldCoqIGlzIGEgW1tTaWduZXJdXSBiYWNrZWQgYnkgdGhlIHByaXZhdGUga2V5IGRlcml2ZWRcbiAqICBmcm9tIGFuIEhEIE5vZGUgdXNpbmcgdGhlIFtbbGluay1iaXAtMzJdXSBzdGFudGFyZC5cbiAqXG4gKiAgQW4gSEQgTm9kZSBmb3JtcyBhIGhpZXJhcmNoYWwgc3RydWN0dXJlIHdpdGggZWFjaCBIRCBOb2RlIGhhdmluZyBhXG4gKiAgcHJpdmF0ZSBrZXkgYW5kIHRoZSBhYmlsaXR5IHRvIGRlcml2ZSBjaGlsZCBIRCBOb2RlcywgZGVmaW5lZCBieVxuICogIGEgcGF0aCBpbmRpY2F0aW5nIHRoZSBpbmRleCBvZiBlYWNoIGNoaWxkLlxuICovXG5leHBvcnQgY2xhc3MgSEROb2RlV2FsbGV0IGV4dGVuZHMgQmFzZVdhbGxldCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICovXG4gICAgcHVibGljS2V5O1xuICAgIC8qKlxuICAgICAqICBUaGUgZmluZ2VycHJpbnQuXG4gICAgICpcbiAgICAgKiAgQSBmaW5nZXJwcmludCBhbGxvd3MgcXVpY2sgcWF5IHRvIGRldGVjdCBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzLFxuICAgICAqICBidXQgZGV2ZWxvcGVycyBzaG91bGQgYmUgcHJlcGFyZWQgdG8gZGVhbCB3aXRoIGNvbGxpc2lvbnMgYXMgaXRcbiAgICAgKiAgaXMgb25seSA0IGJ5dGVzLlxuICAgICAqL1xuICAgIGZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFyZW50IGZpbmdlcnByaW50LlxuICAgICAqL1xuICAgIHBhcmVudEZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbW5lbW9uaWMgdXNlZCB0byBjcmVhdGUgdGhpcyBIRCBOb2RlLCBpZiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiAgU291cmNlcyBzdWNoIGFzIGV4dGVuZGVkIGtleXMgZG8gbm90IGVuY29kZSB0aGUgbW5lbW9uaWMsIGluXG4gICAgICogIHdoaWNoIGNhc2UgdGhpcyB3aWxsIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIG1uZW1vbmljO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW5jb2RlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhIHB1YmxpYyBrZXkgdXNlZFxuICAgICAqICB0byBkZXJpdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY2hhaW5Db2RlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGVyaXZhdGlvbiBwYXRoIG9mIHRoaXMgd2FsbGV0LlxuICAgICAqXG4gICAgICogIFNpbmNlIGV4dGVuZGVkIGtleXMgZG8gbm90IHByb3ZpZGUgZnVsbCBwYXRoIGRldGFpbHMsIHRoaXNcbiAgICAgKiAgbWF5IGJlIGBgbnVsbGBgLCBpZiBpbnN0YW50aWF0ZWQgZnJvbSBhIHNvdXJjZSB0aGF0IGRvZXMgbm90XG4gICAgICogIGVuY29kZSBpdC5cbiAgICAgKi9cbiAgICBwYXRoO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hpbGQgaW5kZXggb2YgdGhpcyB3YWxsZXQuIFZhbHVlcyBvdmVyIGBgMiAqXFwqIDMxYGAgaW5kaWNhdGVcbiAgICAgKiAgdGhlIG5vZGUgaXMgaGFyZGVuZWQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXB0aCBvZiB0aGlzIHdhbGxldCwgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzXG4gICAgICogIGluIGl0cyBwYXRoLlxuICAgICAqL1xuICAgIGRlcHRoO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBzaWduaW5nS2V5LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGgsIG1uZW1vbmljLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihzaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJIRE5vZGVXYWxsZXRcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwdWJsaWNLZXk6IHNpZ25pbmdLZXkuY29tcHJlc3NlZFB1YmxpY0tleSB9KTtcbiAgICAgICAgY29uc3QgZmluZ2VycHJpbnQgPSBkYXRhU2xpY2UocmlwZW1kMTYwKHNoYTI1Nih0aGlzLnB1YmxpY0tleSkpLCAwLCA0KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludCwgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aFxuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG1uZW1vbmljIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSEROb2RlV2FsbGV0KF9ndWFyZCwgdGhpcy5zaWduaW5nS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5wYXRoLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCB0aGlzLm1uZW1vbmljLCBwcm92aWRlcik7XG4gICAgfVxuICAgICNhY2NvdW50KCkge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsIHByaXZhdGVLZXk6IHRoaXMucHJpdmF0ZUtleSB9O1xuICAgICAgICBjb25zdCBtID0gdGhpcy5tbmVtb25pYztcbiAgICAgICAgaWYgKHRoaXMucGF0aCAmJiBtICYmIG0ud29yZGxpc3QubG9jYWxlID09PSBcImVuXCIgJiYgbS5wYXNzd29yZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgYWNjb3VudC5tbmVtb25pYyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBcImVuXCIsXG4gICAgICAgICAgICAgICAgZW50cm9weTogbS5lbnRyb3B5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2NvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYSBbSlNPTiBLZXlzdG9yZSBXYWxsZXRdKGpzb24td2FsbGV0cykgZW5jcnlwdGVkIHdpdGhcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIElmICUlcHJvZ3Jlc3NDYWxsYmFjayUlIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZWNlaXZlIHBlcmlvZGljXG4gICAgICogIHVwZGF0ZXMgYXMgdGhlIGVuY3J5cHRpb24gcHJvY2VzcyBwcm9ncmVzZXMuXG4gICAgICovXG4gICAgYXN5bmMgZW5jcnlwdChwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZW5jcnlwdEtleXN0b3JlSnNvbih0aGlzLiNhY2NvdW50KCksIHBhc3N3b3JkLCB7IHByb2dyZXNzQ2FsbGJhY2sgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cGVkIHdpdGhcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2ZXJzaW9uXShlbmNyeXB0KSBpbnN0ZWFkLFxuICAgICAqICB3aGljaCBhbGxvd3MgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byBrZWVwIHRoZSB1c2VyIGluZm9ybWVkLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIHdpbGwgYmxvY2sgdGhlIGV2ZW50IGxvb3AgKGZyZWV6aW5nIGFsbCBVSSkgdW50aWxcbiAgICAgKiAgaXQgaXMgY29tcGxldGUsIHdoaWNoIG1heSBiZSBhIG5vbi10cml2aWFsIGR1cmF0aW9uLlxuICAgICAqL1xuICAgIGVuY3J5cHRTeW5jKHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyh0aGlzLiNhY2NvdW50KCksIHBhc3N3b3JkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBleHRlbmRlZCBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBrZXkgd2lsbCBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGB4cHJpdmBgIGFuZCBjYW4gYmUgdXNlZCB0b1xuICAgICAqICByZWNvbnN0cnVjdCB0aGlzIEhEIE5vZGUgdG8gZGVyaXZlIGl0cyBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBnZXQgZXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB0aGUgbWFpbm5ldCB2YWx1ZXMgZm9yIG5vdywgYnV0IGlmIGFueW9uZSBuZWVkc1xuICAgICAgICAvLyB0ZXN0bmV0IHZhbHVlcywgbGV0IG1lIGtub3cuIEkgYmVsaWV2ZSBjdXJyZW50IHNlbnRpbWVudCBpcyB0aGF0XG4gICAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgdXNlIG1haW5uZXQsIGFuZCB1c2UgQklQLTQ0IHRvIGRlcml2ZSB0aGUgbmV0d29ya1xuICAgICAgICAvLyAgIC0gTWFpbm5ldDogcHVibGljPTB4MDQ4OEIyMUUsIHByaXZhdGU9MHgwNDg4QURFNFxuICAgICAgICAvLyAgIC0gVGVzdG5ldDogcHVibGljPTB4MDQzNTg3Q0YsIHByaXZhdGU9MHgwNDM1ODM5NFxuICAgICAgICBhc3NlcnQodGhpcy5kZXB0aCA8IDI1NiwgXCJEZXB0aCB0b28gZGVlcFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJleHRlbmRlZEtleVwiIH0pO1xuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTU4Q2hlY2soY29uY2F0KFtcbiAgICAgICAgICAgIFwiMHgwNDg4QURFNFwiLCB6cGFkKHRoaXMuZGVwdGgsIDEpLCB0aGlzLnBhcmVudEZpbmdlcnByaW50LFxuICAgICAgICAgICAgenBhZCh0aGlzLmluZGV4LCA0KSwgdGhpcy5jaGFpbkNvZGUsXG4gICAgICAgICAgICBjb25jYXQoW1wiMHgwMFwiLCB0aGlzLnByaXZhdGVLZXldKVxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB3YWxsZXQgaGFzIGEgcGF0aCwgcHJvdmlkaW5nIGEgVHlwZSBHdWFyZFxuICAgICAqICB0aGF0IHRoZSBwYXRoIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGhhc1BhdGgoKSB7IHJldHVybiAodGhpcy5wYXRoICE9IG51bGwpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXV0ZXJlZCBIRCBOb2RlLCB3aGljaCByZW1vdmVzIHRoZSBwcml2YXRlIGRldGFpbHNcbiAgICAgKiAgb2YgYW4gSEQgTm9kZS5cbiAgICAgKlxuICAgICAqICBBIG5ldXRlcmVkIG5vZGUgaGFzIG5vIHByaXZhdGUga2V5LCBidXQgY2FuIGJlIHVzZWQgdG8gZGVyaXZlXG4gICAgICogIGNoaWxkIGFkZHJlc3NlcyBhbmQgb3RoZXIgcHVibGljIGRhdGEgYWJvdXQgdGhlIEhEIE5vZGUuXG4gICAgICovXG4gICAgbmV1dGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCB0aGlzLmFkZHJlc3MsIHRoaXMucHVibGljS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5wYXRoLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCB0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgY2hpbGQgZm9yICUlaW5kZXglJS5cbiAgICAgKi9cbiAgICBkZXJpdmVDaGlsZChfaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIoX2luZGV4LCBcImluZGV4XCIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8PSAweGZmZmZmZmZmLCBcImludmFsaWQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIC8vIEJhc2UgcGF0aFxuICAgICAgICBsZXQgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgSVIsIElMIH0gPSBzZXJfSShpbmRleCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucHVibGljS2V5LCB0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBraSA9IG5ldyBTaWduaW5nS2V5KHRvQmVIZXgoKHRvQmlnSW50KElMKSArIEJpZ0ludCh0aGlzLnByaXZhdGVLZXkpKSAlIE4sIDMyKSk7XG4gICAgICAgIHJldHVybiBuZXcgSEROb2RlV2FsbGV0KF9ndWFyZCwga2ksIHRoaXMuZmluZ2VycHJpbnQsIGhleGxpZnkoSVIpLCBwYXRoLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIHRoaXMubW5lbW9uaWMsIHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBIRE5vZGUgZm9yICUlcGF0aCUlIGZyb20gdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGRlcml2ZVBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gZGVyaXZlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICB9XG4gICAgc3RhdGljICNmcm9tU2VlZChfc2VlZCwgbW5lbW9uaWMpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNCeXRlc0xpa2UoX3NlZWQpLCBcImludmFsaWQgc2VlZFwiLCBcInNlZWRcIiwgXCJbUkVEQUNURURdXCIpO1xuICAgICAgICBjb25zdCBzZWVkID0gZ2V0Qnl0ZXMoX3NlZWQsIFwic2VlZFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2VlZC5sZW5ndGggPj0gMTYgJiYgc2VlZC5sZW5ndGggPD0gNjQsIFwiaW52YWxpZCBzZWVkXCIsIFwic2VlZFwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIGNvbnN0IEkgPSBnZXRCeXRlcyhjb21wdXRlSG1hYyhcInNoYTUxMlwiLCBNYXN0ZXJTZWNyZXQsIHNlZWQpKTtcbiAgICAgICAgY29uc3Qgc2lnbmluZ0tleSA9IG5ldyBTaWduaW5nS2V5KGhleGxpZnkoSS5zbGljZSgwLCAzMikpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBzaWduaW5nS2V5LCBcIjB4MDAwMDAwMDBcIiwgaGV4bGlmeShJLnNsaWNlKDMyKSksIFwibVwiLCAwLCAwLCBtbmVtb25pYywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEhEIE5vZGUgZnJvbSAlJWV4dGVuZGVkS2V5JSUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUlZXh0ZW5kZWRLZXklJSB3aWxsIGVpdGhlciBoYXZlIGEgcHJlZml4IG9yIGBgeHB1YmBgIG9yXG4gICAgICogIGBgeHByaXZgYCwgcmV0dXJuaW5nIGEgbmV1dGVyZWQgSEQgTm9kZSAoW1tIRE5vZGVWb2lkV2FsbGV0XV0pXG4gICAgICogIG9yIGZ1bGwgSEQgTm9kZSAoW1tIRE5vZGVXYWxsZXQpIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkS2V5KGV4dGVuZGVkS2V5KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdG9CZUFycmF5KGRlY29kZUJhc2U1OChleHRlbmRlZEtleSkpOyAvLyBAVE9ETzogcmVkYWN0XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gODIgfHwgZW5jb2RlQmFzZTU4Q2hlY2soYnl0ZXMuc2xpY2UoMCwgNzgpKSA9PT0gZXh0ZW5kZWRLZXksIFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIiwgXCJleHRlbmRlZEtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgY29uc3QgZGVwdGggPSBieXRlc1s0XTtcbiAgICAgICAgY29uc3QgcGFyZW50RmluZ2VycHJpbnQgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDUsIDkpKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDksIDEzKSkuc3Vic3RyaW5nKDIpLCAxNik7XG4gICAgICAgIGNvbnN0IGNoYWluQ29kZSA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMTMsIDQ1KSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGJ5dGVzLnNsaWNlKDQ1LCA3OCk7XG4gICAgICAgIHN3aXRjaCAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkpIHtcbiAgICAgICAgICAgIC8vIFB1YmxpYyBLZXlcbiAgICAgICAgICAgIGNhc2UgXCIweDA0ODhiMjFlXCI6XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDM1ODdjZlwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gaGV4bGlmeShrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSEROb2RlVm9pZFdhbGxldChfZ3VhcmQsIGNvbXB1dGVBZGRyZXNzKHB1YmxpY0tleSksIHB1YmxpY0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgbnVsbCwgaW5kZXgsIGRlcHRoLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByaXZhdGUgS2V5XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDg4YWRlNFwiOlxuICAgICAgICAgICAgY2FzZSBcIjB4MDQzNTgzOTQgXCI6XG4gICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBuZXcgU2lnbmluZ0tleShrZXkuc2xpY2UoMSkpLCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBudWxsLCBpbmRleCwgZGVwdGgsIG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZXh0ZW5kZWQga2V5IHByZWZpeFwiLCBcImV4dGVuZGVkS2V5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyByYW5kb20gSEROb2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSYW5kb20ocGFzc3dvcmQsIHBhdGgsIHdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcGF0aCA9IGRlZmF1bHRQYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IExhbmdFbi53b3JkbGlzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1uZW1vbmljID0gTW5lbW9uaWMuZnJvbUVudHJvcHkocmFuZG9tQnl0ZXMoMTYpLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhbiBIRCBOb2RlIGZyb20gJSVtbmVtb25pYyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW5lbW9uaWMobW5lbW9uaWMsIHBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gZGVmYXVsdFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQobW5lbW9uaWMuY29tcHV0ZVNlZWQoKSwgbW5lbW9uaWMpLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGFuIEhEIE5vZGUgZnJvbSBhIG1uZW1vbmljICUlcGhyYXNlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgcGF0aCwgd29yZGxpc3QpIHtcbiAgICAgICAgaWYgKHBhc3N3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhc3N3b3JkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXRoID0gZGVmYXVsdFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gTGFuZ0VuLndvcmRsaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW5lbW9uaWMgPSBNbmVtb25pYy5mcm9tUGhyYXNlKHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KTtcbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQobW5lbW9uaWMuY29tcHV0ZVNlZWQoKSwgbW5lbW9uaWMpLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGFuIEhEIE5vZGUgZnJvbSBhICUlc2VlZCUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2VlZChzZWVkKSB7XG4gICAgICAgIHJldHVybiBIRE5vZGVXYWxsZXQuI2Zyb21TZWVkKHNlZWQsIG51bGwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipIRE5vZGVWb2lkV2FsbGV0KiogY2Fubm90IHNpZ24sIGJ1dCBwcm92aWRlcyBhY2Nlc3MgdG9cbiAqICB0aGUgY2hpbGRyZW4gbm9kZXMgb2YgYSBbW2xpbmstYmlwLTMyXV0gSEQgd2FsbGV0IGFkZHJlc3Nlcy5cbiAqXG4gKiAgVGhlIGNhbiBiZSBjcmVhdGVkIGJ5IHVzaW5nIGFuIGV4dGVuZGVkIGBgeHB1YmBgIGtleSB0b1xuICogIFtbSEROb2RlV2FsbGV0X2Zyb21FeHRlbmRlZEtleV1dIG9yIGJ5XG4gKiAgW251ZXRlcmluZ10oSEROb2RlV2FsbGV0LW5ldXRlcikgYSBbW0hETm9kZVdhbGxldF1dLlxuICovXG5leHBvcnQgY2xhc3MgSEROb2RlVm9pZFdhbGxldCBleHRlbmRzIFZvaWRTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqL1xuICAgIHB1YmxpY0tleTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZpbmdlcnByaW50LlxuICAgICAqXG4gICAgICogIEEgZmluZ2VycHJpbnQgYWxsb3dzIHF1aWNrIHFheSB0byBkZXRlY3QgcGFyZW50IGFuZCBjaGlsZCBub2RlcyxcbiAgICAgKiAgYnV0IGRldmVsb3BlcnMgc2hvdWxkIGJlIHByZXBhcmVkIHRvIGRlYWwgd2l0aCBjb2xsaXNpb25zIGFzIGl0XG4gICAgICogIGlzIG9ubHkgNCBieXRlcy5cbiAgICAgKi9cbiAgICBmaW5nZXJwcmludDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcmVudCBub2RlIGZpbmdlcnByaW50LlxuICAgICAqL1xuICAgIHBhcmVudEZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW5jb2RlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhIHB1YmxpYyBrZXkgdXNlZFxuICAgICAqICB0byBkZXJpdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY2hhaW5Db2RlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGVyaXZhdGlvbiBwYXRoIG9mIHRoaXMgd2FsbGV0LlxuICAgICAqXG4gICAgICogIFNpbmNlIGV4dGVuZGVkIGtleXMgZG8gbm90IHByb3ZpZGVyIGZ1bGwgcGF0aCBkZXRhaWxzLCB0aGlzXG4gICAgICogIG1heSBiZSBgYG51bGxgYCwgaWYgaW5zdGFudGlhdGVkIGZyb20gYSBzb3VyY2UgdGhhdCBkb2VzIG5vdFxuICAgICAqICBlbm9jZGUgaXQuXG4gICAgICovXG4gICAgcGF0aDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoaWxkIGluZGV4IG9mIHRoaXMgd2FsbGV0LiBWYWx1ZXMgb3ZlciBgYDIgKlxcKiAzMWBgIGluZGljYXRlXG4gICAgICogIHRoZSBub2RlIGlzIGhhcmRlbmVkLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgZGVwdGggb2YgdGhpcyB3YWxsZXQsIHdoaWNoIGlzIHRoZSBudW1iZXIgb2YgY29tcG9uZW50c1xuICAgICAqICBpbiBpdHMgcGF0aC5cbiAgICAgKi9cbiAgICBkZXB0aDtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgYWRkcmVzcywgcHVibGljS2V5LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKGFkZHJlc3MsIHByb3ZpZGVyKTtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIkhETm9kZVZvaWRXYWxsZXRcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwdWJsaWNLZXkgfSk7XG4gICAgICAgIGNvbnN0IGZpbmdlcnByaW50ID0gZGF0YVNsaWNlKHJpcGVtZDE2MChzaGEyNTYocHVibGljS2V5KSksIDAsIDQpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHB1YmxpY0tleSwgZmluZ2VycHJpbnQsIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCB0aGlzLmFkZHJlc3MsIHRoaXMucHVibGljS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5wYXRoLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXh0ZW5kZWQga2V5LlxuICAgICAqXG4gICAgICogIFRoaXMga2V5IHdpbGwgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgeHB1YmBgIGFuZCBjYW4gYmUgdXNlZCB0b1xuICAgICAqICByZWNvbnN0cnVjdCB0aGlzIG5ldXRlcmVkIGtleSB0byBkZXJpdmUgaXRzIGNoaWxkcmVuIGFkZHJlc3Nlcy5cbiAgICAgKi9cbiAgICBnZXQgZXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB0aGUgbWFpbm5ldCB2YWx1ZXMgZm9yIG5vdywgYnV0IGlmIGFueW9uZSBuZWVkc1xuICAgICAgICAvLyB0ZXN0bmV0IHZhbHVlcywgbGV0IG1lIGtub3cuIEkgYmVsaWV2ZSBjdXJyZW50IHNlbnRpbWVudCBpcyB0aGF0XG4gICAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgdXNlIG1haW5uZXQsIGFuZCB1c2UgQklQLTQ0IHRvIGRlcml2ZSB0aGUgbmV0d29ya1xuICAgICAgICAvLyAgIC0gTWFpbm5ldDogcHVibGljPTB4MDQ4OEIyMUUsIHByaXZhdGU9MHgwNDg4QURFNFxuICAgICAgICAvLyAgIC0gVGVzdG5ldDogcHVibGljPTB4MDQzNTg3Q0YsIHByaXZhdGU9MHgwNDM1ODM5NFxuICAgICAgICBhc3NlcnQodGhpcy5kZXB0aCA8IDI1NiwgXCJEZXB0aCB0b28gZGVlcFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJleHRlbmRlZEtleVwiIH0pO1xuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTU4Q2hlY2soY29uY2F0KFtcbiAgICAgICAgICAgIFwiMHgwNDg4QjIxRVwiLFxuICAgICAgICAgICAgenBhZCh0aGlzLmRlcHRoLCAxKSxcbiAgICAgICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICB6cGFkKHRoaXMuaW5kZXgsIDQpLFxuICAgICAgICAgICAgdGhpcy5jaGFpbkNvZGUsXG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleSxcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgd2FsbGV0IGhhcyBhIHBhdGgsIHByb3ZpZGluZyBhIFR5cGUgR3VhcmRcbiAgICAgKiAgdGhhdCB0aGUgcGF0aCBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBoYXNQYXRoKCkgeyByZXR1cm4gKHRoaXMucGF0aCAhPSBudWxsKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGNoaWxkIGZvciAlJWluZGV4JSUuXG4gICAgICovXG4gICAgZGVyaXZlQ2hpbGQoX2luZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0TnVtYmVyKF9pbmRleCwgXCJpbmRleFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPD0gMHhmZmZmZmZmZiwgXCJpbnZhbGlkIGluZGV4XCIsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgICAgICAvLyBCYXNlIHBhdGhcbiAgICAgICAgbGV0IHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRoICs9IFwiL1wiICsgKGluZGV4ICYgfkhhcmRlbmVkQml0KTtcbiAgICAgICAgICAgIGlmIChpbmRleCAmIEhhcmRlbmVkQml0KSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSBcIidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IElSLCBJTCB9ID0gc2VyX0koaW5kZXgsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnB1YmxpY0tleSwgbnVsbCk7XG4gICAgICAgIGNvbnN0IEtpID0gU2lnbmluZ0tleS5hZGRQb2ludHMoSUwsIHRoaXMucHVibGljS2V5LCB0cnVlKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzKEtpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgYWRkcmVzcywgS2ksIHRoaXMuZmluZ2VycHJpbnQsIGhleGxpZnkoSVIpLCBwYXRoLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzaWduZXIgZm9yICUlcGF0aCUlIGZyb20gdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGRlcml2ZVBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gZGVyaXZlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICB9XG59XG4vKlxuZXhwb3J0IGNsYXNzIEhETm9kZVdhbGxldE1hbmFnZXIge1xuICAgICNyb290OiBIRE5vZGVXYWxsZXQ7XG5cbiAgICBjb25zdHJ1Y3RvcihwaHJhc2U6IHN0cmluZywgcGFzc3dvcmQ/OiBudWxsIHwgc3RyaW5nLCBwYXRoPzogbnVsbCB8IHN0cmluZywgbG9jYWxlPzogbnVsbCB8IFdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7IHBhc3N3b3JkID0gXCJcIjsgfVxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7IHBhdGggPSBcIm0vNDQnLzYwJy8wJy8wXCI7IH1cbiAgICAgICAgaWYgKGxvY2FsZSA9PSBudWxsKSB7IGxvY2FsZSA9IExhbmdFbi53b3JkbGlzdCgpOyB9XG4gICAgICAgIHRoaXMuI3Jvb3QgPSBIRE5vZGVXYWxsZXQuZnJvbVBocmFzZShwaHJhc2UsIHBhc3N3b3JkLCBwYXRoLCBsb2NhbGUpO1xuICAgIH1cblxuICAgIGdldFNpZ25lcihpbmRleD86IG51bWJlcik6IEhETm9kZVdhbGxldCB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyb290LmRlcml2ZUNoaWxkKChpbmRleCA9PSBudWxsKSA/IDA6IGluZGV4KTtcbiAgICB9XG59XG4qL1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgW1tsaW5rLWJpcC0zMl1dIHBhdGggZm9yIHRoZSBhY2NvdW50IGF0ICUlaW5kZXglJS5cbiAqXG4gKiAgVGhpcyBpcyB0aGUgcGF0dGVybiB1c2VkIGJ5IHdhbGxldHMgbGlrZSBMZWRnZXIuXG4gKlxuICogIFRoZXJlIGlzIGFsc28gYW4gW2FsdGVybmF0ZSBwYXR0ZXJuXShnZXRJbmRleGVkQWNjb3VudFBhdGgpIHVzZWQgYnlcbiAqICBzb21lIHNvZnR3YXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjb3VudFBhdGgoX2luZGV4KSB7XG4gICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIoX2luZGV4LCBcImluZGV4XCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAgJiYgaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIGFjY291bnQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgcmV0dXJuIGBtLzQ0Jy82MCcvJHtpbmRleH0nLzAvMGA7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBwYXRoIHVzaW5nIGFuIGFsdGVybmF0aXZlIHBhdHRlcm4gZm9yIGRlcml2aW5nIGFjY291bnRzLFxuICogIGF0ICUlaW5kZXglJS5cbiAqXG4gKiAgVGhpcyBkZXJpdmF0aW9uIHBhdGggdXNlcyB0aGUgLy9pbmRleC8vIGNvbXBvbmVudCByYXRoZXIgdGhhbiB0aGVcbiAqICAvL2FjY291bnQvLyBjb21wb25lbnQgdG8gZGVyaXZlIHNlcXVlbnRpYWwgYWNjb3VudHMuXG4gKlxuICogIFRoaXMgaXMgdGhlIHBhdHRlcm4gdXNlZCBieSB3YWxsZXRzIGxpa2UgTWV0YU1hc2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleGVkQWNjb3VudFBhdGgoX2luZGV4KSB7XG4gICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIoX2luZGV4LCBcImluZGV4XCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAgJiYgaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIGFjY291bnQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgcmV0dXJuIGBtLzQ0Jy82MCcvMCcvMC8ke2luZGV4fWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZHdhbGxldC5qcy5tYXAiLCIvKipcbiAqICBAX3N1YnNlY3Rpb246IGFwaS93YWxsZXQ6SlNPTiBXYWxsZXRzICBbanNvbi13YWxsZXRzXVxuICovXG5pbXBvcnQgeyBDQkMsIHBrY3M3U3RyaXAgfSBmcm9tIFwiYWVzLWpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0UGFzc3dvcmQsIGxvb3NlQXJyYXlpZnksIHNwZWx1bmsgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlanNvbiUlIGlzIGEgdmFsaWQgSlNPTiBDcm93ZHNhbGUgd2FsbGV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDcm93ZHNhbGVKc29uKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgaWYgKGRhdGEuZW5jc2VlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9weWV0aHNhbGV0b29sXG4vKipcbiAqICBCZWZvcmUgRXRoZXJldW0gbGF1bmNoZWQsIGl0IHdhcyBuZWNlc3NhcnkgdG8gY3JlYXRlIGEgd2FsbGV0XG4gKiAgZm9ybWF0IGZvciBiYWNrZXJzIHRvIHVzZSwgd2hpY2ggd291bGQgYmUgdXNlZCB0byByZWNlaXZlIGV0aGVyXG4gKiAgYXMgYSByZXdhcmQgZm9yIGNvbnRyaWJ1dGluZyB0byB0aGUgcHJvamVjdC5cbiAqXG4gKiAgVGhlIFtbbGluay1jcm93ZHNhbGVdXSBmb3JtYXQgaXMgbm93IG9ic29sZXRlLCBidXQgaXQgaXMgc3RpbGxcbiAqICB1c2VmdWwgdG8gc3VwcG9ydCBhbmQgdGhlIGFkZGl0aW9uYWwgY29kZSBpcyBmYWlybHkgdHJpdmlhbCBhc1xuICogIGFsbCB0aGUgcHJpbWl0aXZlcyByZXF1aXJlZCBhcmUgdXNlZCB0aHJvdWdoIGNvcmUgcG9ydGlvbnMgb2ZcbiAqICB0aGUgbGlicmFyeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHRDcm93ZHNhbGVKc29uKGpzb24sIF9wYXNzd29yZCkge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gZ2V0UGFzc3dvcmQoX3Bhc3N3b3JkKTtcbiAgICAvLyBFdGhlcmV1bSBBZGRyZXNzXG4gICAgY29uc3QgYWRkcmVzcyA9IGdldEFkZHJlc3Moc3BlbHVuayhkYXRhLCBcImV0aGFkZHI6c3RyaW5nIVwiKSk7XG4gICAgLy8gRW5jcnlwdGVkIFNlZWRcbiAgICBjb25zdCBlbmNzZWVkID0gbG9vc2VBcnJheWlmeShzcGVsdW5rKGRhdGEsIFwiZW5jc2VlZDpzdHJpbmchXCIpKTtcbiAgICBhc3NlcnRBcmd1bWVudChlbmNzZWVkICYmIChlbmNzZWVkLmxlbmd0aCAlIDE2KSA9PT0gMCwgXCJpbnZhbGlkIGVuY3NlZWRcIiwgXCJqc29uXCIsIGpzb24pO1xuICAgIGNvbnN0IGtleSA9IGdldEJ5dGVzKHBia2RmMihwYXNzd29yZCwgcGFzc3dvcmQsIDIwMDAsIDMyLCBcInNoYTI1NlwiKSkuc2xpY2UoMCwgMTYpO1xuICAgIGNvbnN0IGl2ID0gZW5jc2VlZC5zbGljZSgwLCAxNik7XG4gICAgY29uc3QgZW5jcnlwdGVkU2VlZCA9IGVuY3NlZWQuc2xpY2UoMTYpO1xuICAgIC8vIERlY3J5cHQgdGhlIHNlZWRcbiAgICBjb25zdCBhZXNDYmMgPSBuZXcgQ0JDKGtleSwgaXYpO1xuICAgIGNvbnN0IHNlZWQgPSBwa2NzN1N0cmlwKGdldEJ5dGVzKGFlc0NiYy5kZWNyeXB0KGVuY3J5cHRlZFNlZWQpKSk7XG4gICAgLy8gVGhpcyB3YWxsZXQgZm9ybWF0IGlzIHdlaXJkLi4uIENvbnZlcnQgdGhlIGJpbmFyeSBlbmNvZGVkIGhleCB0byBhIHN0cmluZy5cbiAgICBsZXQgc2VlZEhleCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlZWRIZXggKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzZWVkW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgYWRkcmVzcywgcHJpdmF0ZUtleTogaWQoc2VlZEhleCkgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24tY3Jvd2RzYWxlLmpzLm1hcCIsImltcG9ydCB7IFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQmFzZVdhbGxldCB9IGZyb20gXCIuL2Jhc2Utd2FsbGV0LmpzXCI7XG5pbXBvcnQgeyBIRE5vZGVXYWxsZXQgfSBmcm9tIFwiLi9oZHdhbGxldC5qc1wiO1xuaW1wb3J0IHsgZGVjcnlwdENyb3dkc2FsZUpzb24sIGlzQ3Jvd2RzYWxlSnNvbiB9IGZyb20gXCIuL2pzb24tY3Jvd2RzYWxlLmpzXCI7XG5pbXBvcnQgeyBkZWNyeXB0S2V5c3RvcmVKc29uLCBkZWNyeXB0S2V5c3RvcmVKc29uU3luYywgZW5jcnlwdEtleXN0b3JlSnNvbiwgZW5jcnlwdEtleXN0b3JlSnNvblN5bmMsIGlzS2V5c3RvcmVKc29uIH0gZnJvbSBcIi4vanNvbi1rZXlzdG9yZS5qc1wiO1xuaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tIFwiLi9tbmVtb25pYy5qc1wiO1xuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dCgoKSA9PiB7IHJlc29sdmUoKTsgfSwgZHVyYXRpb24pOyB9KTtcbn1cbi8qKlxuICogIEEgKipXYWxsZXQqKiBtYW5hZ2VzIGEgc2luZ2xlIHByaXZhdGUga2V5IHdoaWNoIGlzIHVzZWQgdG8gc2lnblxuICogIHRyYW5zYWN0aW9ucywgbWVzc2FnZXMgYW5kIG90aGVyIGNvbW1vbiBwYXlsb2Fkcy5cbiAqXG4gKiAgVGhpcyBjbGFzcyBpcyBnZW5lcmFsbHkgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIGRldmVsb3BlcnNcbiAqICB0aGF0IHdpc2ggdG8gdXNlIGEgcHJpdmF0ZSBrZXkgZGlyZWN0bHksIGFzIGl0IGNhbiBjcmVhdGVcbiAqICBpbnN0YW5jZXMgZnJvbSBhIGxhcmdlIHZhcmlldHkgb2YgY29tbW9uIHNvdXJjZXMsIGluY2x1ZGluZ1xuICogIHJhdyBwcml2YXRlIGtleSwgW1tsaW5rLWJpcC0zOV1dIG1uZW1vbmljcyBhbmQgZW5jcnlwdGUgSlNPTlxuICogIHdhbGxldHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXYWxsZXQgZXh0ZW5kcyBCYXNlV2FsbGV0IHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IHdhbGxldCBmb3IgdGhlIHByaXZhdGUgJSVrZXklJSwgb3B0aW9uYWxseSBjb25uZWN0ZWRcbiAgICAgKiAgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGtleSwgcHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIiAmJiAha2V5LnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAga2V5ID0gXCIweFwiICsga2V5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWduaW5nS2V5ID0gKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIikgPyBuZXcgU2lnbmluZ0tleShrZXkpIDoga2V5O1xuICAgICAgICBzdXBlcihzaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXYWxsZXQodGhpcy5zaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byBhIFtKU09OIEtleXN0b3JlIFdhbGxldF0oanNvbi13YWxsZXRzKSBlbmNyeXB0ZWQgd2l0aFxuICAgICAqICAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwcm9ncmVzc0NhbGxiYWNrJSUgaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlY2VpdmUgcGVyaW9kaWNcbiAgICAgKiAgdXBkYXRlcyBhcyB0aGUgZW5jcnlwdGlvbiBwcm9jZXNzIHByb2dyZXNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBlbmNyeXB0KHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3M6IHRoaXMuYWRkcmVzcywgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5IH07XG4gICAgICAgIHJldHVybiBhd2FpdCBlbmNyeXB0S2V5c3RvcmVKc29uKGFjY291bnQsIHBhc3N3b3JkLCB7IHByb2dyZXNzQ2FsbGJhY2sgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cGVkIHdpdGhcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2ZXJzaW9uXShlbmNyeXB0KSBpbnN0ZWFkLFxuICAgICAqICB3aGljaCBhbGxvd3MgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byBrZWVwIHRoZSB1c2VyIGluZm9ybWVkLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIHdpbGwgYmxvY2sgdGhlIGV2ZW50IGxvb3AgKGZyZWV6aW5nIGFsbCBVSSkgdW50aWxcbiAgICAgKiAgaXQgaXMgY29tcGxldGUsIHdoaWNoIG1heSBiZSBhIG5vbi10cml2aWFsIGR1cmF0aW9uLlxuICAgICAqL1xuICAgIGVuY3J5cHRTeW5jKHBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3M6IHRoaXMuYWRkcmVzcywgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5IH07XG4gICAgICAgIHJldHVybiBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyhhY2NvdW50LCBwYXNzd29yZCk7XG4gICAgfVxuICAgIHN0YXRpYyAjZnJvbUFjY291bnQoYWNjb3VudCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChhY2NvdW50LCBcImludmFsaWQgSlNPTiB3YWxsZXRcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICBpZiAoXCJtbmVtb25pY1wiIGluIGFjY291bnQgJiYgYWNjb3VudC5tbmVtb25pYyAmJiBhY2NvdW50Lm1uZW1vbmljLmxvY2FsZSA9PT0gXCJlblwiKSB7XG4gICAgICAgICAgICBjb25zdCBtbmVtb25pYyA9IE1uZW1vbmljLmZyb21FbnRyb3B5KGFjY291bnQubW5lbW9uaWMuZW50cm9weSk7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSBIRE5vZGVXYWxsZXQuZnJvbU1uZW1vbmljKG1uZW1vbmljLCBhY2NvdW50Lm1uZW1vbmljLnBhdGgpO1xuICAgICAgICAgICAgaWYgKHdhbGxldC5hZGRyZXNzID09PSBhY2NvdW50LmFkZHJlc3MgJiYgd2FsbGV0LnByaXZhdGVLZXkgPT09IGFjY291bnQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk5JTkc6IEpTT04gbWlzbWF0Y2ggYWRkcmVzcy9wcml2YXRlS2V5ICE9IG1uZW1vbmljOyBmYWxsYmFjayBvbnRvIHByaXZhdGUga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXQoYWNjb3VudC5wcml2YXRlS2V5KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQod2FsbGV0LmFkZHJlc3MgPT09IGFjY291bnQuYWRkcmVzcywgXCJhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyAoYXN5bmNocm9ub3VzbHkpIGEgKipXYWxsZXQqKiBieSBkZWNyeXB0aW5nIHRoZSAlJWpzb24lJVxuICAgICAqICB3aXRoICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBJZiAlJXByb2dyZXNzJSUgaXMgcHJvdmlkZWQsIGl0IGlzIGNhbGxlZCBwZXJpb2RpY2FsbHkgZHVyaW5nXG4gICAgICogIGRlY3J5cHRpb24gc28gdGhhdCBhbnkgVUkgY2FuIGJlIHVwZGF0ZWQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21FbmNyeXB0ZWRKc29uKGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzcykge1xuICAgICAgICBsZXQgYWNjb3VudCA9IG51bGw7XG4gICAgICAgIGlmIChpc0tleXN0b3JlSnNvbihqc29uKSkge1xuICAgICAgICAgICAgYWNjb3VudCA9IGF3YWl0IGRlY3J5cHRLZXlzdG9yZUpzb24oanNvbiwgcGFzc3dvcmQsIHByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Nyb3dkc2FsZUpzb24oanNvbikpIHtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzKDApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjb3VudCA9IGRlY3J5cHRDcm93ZHNhbGVKc29uKGpzb24sIHBhc3N3b3JkKTtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzKDEpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXYWxsZXQuI2Zyb21BY2NvdW50KGFjY291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhICoqV2FsbGV0KiogYnkgZGVjcnlwdGluZyB0aGUgJSVqc29uJSUgd2l0aCAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIFtbZnJvbUVuY3J5cHRlZEpzb25dXSBtZXRob2QgaXMgcHJlZmVycmVkLCBhcyB0aGlzIG1ldGhvZFxuICAgICAqICB3aWxsIGxvY2sgdXAgYW5kIGZyZWV6ZSB0aGUgVUkgZHVyaW5nIGRlY3J5cHRpb24sIHdoaWNoIG1heSB0YWtlXG4gICAgICogIHNvbWUgdGltZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUVuY3J5cHRlZEpzb25TeW5jKGpzb24sIHBhc3N3b3JkKSB7XG4gICAgICAgIGxldCBhY2NvdW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzS2V5c3RvcmVKc29uKGpzb24pKSB7XG4gICAgICAgICAgICBhY2NvdW50ID0gZGVjcnlwdEtleXN0b3JlSnNvblN5bmMoanNvbiwgcGFzc3dvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ3Jvd2RzYWxlSnNvbihqc29uKSkge1xuICAgICAgICAgICAgYWNjb3VudCA9IGRlY3J5cHRDcm93ZHNhbGVKc29uKGpzb24sIHBhc3N3b3JkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgSlNPTiB3YWxsZXRcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXYWxsZXQuI2Zyb21BY2NvdW50KGFjY291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyByYW5kb20gW1tIRE5vZGVXYWxsZXRdXSB1c2luZyB0aGUgYXZhaWxhYmxlXG4gICAgICogIFtjcnlwdG9ncmFwaGljIHJhbmRvbSBzb3VyY2VdKHJhbmRvbUJ5dGVzKS5cbiAgICAgKlxuICAgICAqICBJZiB0aGVyZSBpcyBubyBjcnl0b2dyYXBoaWMgcmFuZG9tIHNvdXJjZSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSYW5kb20ocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gSEROb2RlV2FsbGV0LmNyZWF0ZVJhbmRvbSgpO1xuICAgICAgICBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQuY29ubmVjdChwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBbW0hETm9kZVdhbGxldF1dIGZvciAlJXBocmFzZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUGhyYXNlKHBocmFzZSwgcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gSEROb2RlV2FsbGV0LmZyb21QaHJhc2UocGhyYXNlKTtcbiAgICAgICAgaWYgKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FsbGV0LmNvbm5lY3QocHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0LmpzLm1hcCIsIi8qKlxyXG4gKiBjb3JlL3N0b3JhZ2UuanNcclxuICpcclxuICogRW5jcnlwdGVkIHN0b3JhZ2Ugd3JhcHBlciBmb3IgQ2hyb21lIHN0b3JhZ2UgQVBJXHJcbiAqIEhhbmRsZXMgYm90aCBlbmNyeXB0ZWQgKGZvciBzZW5zaXRpdmUgZGF0YSkgYW5kIHVuZW5jcnlwdGVkIHN0b3JhZ2VcclxuICovXHJcblxyXG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xyXG5cclxuLyoqXHJcbiAqIFNhdmVzIHVuZW5jcnlwdGVkIGRhdGEgKGZvciBub24tc2Vuc2l0aXZlIGRhdGEpXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBTdG9yYWdlIGtleVxyXG4gKiBAcGFyYW0ge2FueX0gZGF0YSAtIERhdGEgdG8gc3RvcmVcclxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZShrZXksIGRhdGEpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHsgW2tleV06IGRhdGEgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBkYXRhOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgZGF0YScpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRzIHVuZW5jcnlwdGVkIGRhdGFcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFN0b3JhZ2Uga2V5XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFN0b3JlZCBkYXRhIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZChrZXkpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KGtleSk7XHJcbiAgICByZXR1cm4gcmVzdWx0W2tleV0gfHwgbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBkYXRhOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgZGF0YScpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgaXRlbSBmcm9tIHN0b3JhZ2VcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFN0b3JhZ2Uga2V5XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwucmVtb3ZlKGtleSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVtb3ZlIGRhdGEnKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhcnMgYWxsIHN0b3JhZ2UgKHVzZSB3aXRoIGNhdXRpb24hKVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhcigpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuY2xlYXIoKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgc3RvcmFnZTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjbGVhciBzdG9yYWdlJyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBhbGwga2V5cyBpbiBzdG9yYWdlXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxLZXlzKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBhbGwgPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQobnVsbCk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxsKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBrZXlzOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBzdG9yYWdlIGtleXMnKTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIGNvcmUvdmFsaWRhdGlvbi5qc1xyXG4gKlxyXG4gKiBJbnB1dCB2YWxpZGF0aW9uIGFuZCBzYW5pdGl6YXRpb24gZnVuY3Rpb25zXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgRXRoZXJldW0gYWRkcmVzc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBldGhlcnMuaXNBZGRyZXNzKGFkZHJlc3MpO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhbW91bnQgKG11c3QgYmUgcG9zaXRpdmUgbnVtYmVyKVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBbW91bnQoYW1vdW50KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IG51bSA9IHBhcnNlRmxvYXQoYW1vdW50KTtcclxuICAgIHJldHVybiAhaXNOYU4obnVtKSAmJiBudW0gPiAwICYmIGlzRmluaXRlKG51bSk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIG1uZW1vbmljIHBocmFzZSAoQklQMzkpXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtbmVtb25pY1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTW5lbW9uaWMobW5lbW9uaWMpIHtcclxuICB0cnkge1xyXG4gICAgLy8gVHJpbSBhbmQgbm9ybWFsaXplIHdoaXRlc3BhY2VcclxuICAgIGNvbnN0IGNsZWFuZWQgPSBtbmVtb25pYy50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xyXG5cclxuICAgIC8vIENoZWNrIGlmIGl0J3MgYSB2YWxpZCBtbmVtb25pYyB1c2luZyBldGhlcnNcclxuICAgIHJldHVybiBldGhlcnMuTW5lbW9uaWMuaXNWYWxpZE1uZW1vbmljKGNsZWFuZWQpO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBwcml2YXRlIGtleSAoaGV4IGZvcm1hdClcclxuICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXlcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBSZW1vdmUgMHggcHJlZml4IGlmIHByZXNlbnRcclxuICAgIGNvbnN0IGtleSA9IHByaXZhdGVLZXkuc3RhcnRzV2l0aCgnMHgnKSA/IHByaXZhdGVLZXkgOiAnMHgnICsgcHJpdmF0ZUtleTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBpdCdzIHZhbGlkIGhleCBhbmQgY29ycmVjdCBsZW5ndGggKDY2IGNoYXJzIHdpdGggMHgsIG9yIDY0IHdpdGhvdXQpXHJcbiAgICBpZiAoIS9eMHhbMC05YS1mQS1GXXs2NH0kLy50ZXN0KGtleSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSB0byBjcmVhdGUgYSB3YWxsZXQgd2l0aCBpdFxyXG4gICAgbmV3IGV0aGVycy5XYWxsZXQoa2V5KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBwYXNzd29yZCBzdHJlbmd0aFxyXG4gKiBSZXF1aXJlbWVudHM6XHJcbiAqIC0gTWluaW11bSAxMiBjaGFyYWN0ZXJzXHJcbiAqIC0gQXQgbGVhc3QgMSB1cHBlcmNhc2UgbGV0dGVyXHJcbiAqIC0gQXQgbGVhc3QgMSBsb3dlcmNhc2UgbGV0dGVyXHJcbiAqIC0gQXQgbGVhc3QgMSBudW1iZXJcclxuICogLSBBdCBsZWFzdCAxIHNwZWNpYWwgY2hhcmFjdGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB7IHZhbGlkOiBib29sZWFuLCBlcnJvcnM6IHN0cmluZ1tdIH1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBhc3N3b3JkU3RyZW5ndGgocGFzc3dvcmQpIHtcclxuICBjb25zdCBlcnJvcnMgPSBbXTtcclxuXHJcbiAgaWYgKCFwYXNzd29yZCB8fCBwYXNzd29yZC5sZW5ndGggPCAxMikge1xyXG4gICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgYmUgYXQgbGVhc3QgMTIgY2hhcmFjdGVycycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCEvW0EtWl0vLnRlc3QocGFzc3dvcmQpKSB7XHJcbiAgICBlcnJvcnMucHVzaCgnUGFzc3dvcmQgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSB1cHBlcmNhc2UgbGV0dGVyJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoIS9bYS16XS8udGVzdChwYXNzd29yZCkpIHtcclxuICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGxvd2VyY2FzZSBsZXR0ZXInKTtcclxuICB9XHJcblxyXG4gIGlmICghL1swLTldLy50ZXN0KHBhc3N3b3JkKSkge1xyXG4gICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgbnVtYmVyJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoIS9bIUAjJCVeJiooKV8rXFwtPVxcW1xcXXt9Oyc6XCJcXFxcfCwuPD5cXC8/XS8udGVzdChwYXNzd29yZCkpIHtcclxuICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHNwZWNpYWwgY2hhcmFjdGVyICghQCMkJV4mKiwgZXRjLiknKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB2YWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcclxuICAgIGVycm9yc1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTYW5pdGl6ZXMgdXNlciBpbnB1dCAocmVtb3ZlcyBwb3RlbnRpYWxseSBkYW5nZXJvdXMgY2hhcmFjdGVycylcclxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVJbnB1dChpbnB1dCkge1xyXG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSByZXR1cm4gJyc7XHJcblxyXG4gIC8vIFJlbW92ZSBudWxsIGJ5dGVzIGFuZCBjb250cm9sIGNoYXJhY3RlcnNcclxuICByZXR1cm4gaW5wdXRcclxuICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MUZcXHg3Rl0vZywgJycpXHJcbiAgICAudHJpbSgpO1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIGNoYWluIElEXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFpbklkXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRDaGFpbklkKGNoYWluSWQpIHtcclxuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjaGFpbklkKSAmJiBjaGFpbklkID4gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBkZWNpbWFsIHBsYWNlcyBzZXR0aW5nXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsc1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRGVjaW1hbFBsYWNlcyhkZWNpbWFscykge1xyXG4gIGNvbnN0IHZhbGlkID0gWzIsIDQsIDYsIDgsIDE4XTtcclxuICByZXR1cm4gdmFsaWQuaW5jbHVkZXMoZGVjaW1hbHMpO1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoZW1lIG5hbWVcclxuICogQHBhcmFtIHtzdHJpbmd9IHRoZW1lXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRUaGVtZSh0aGVtZSkge1xyXG4gIGNvbnN0IHZhbGlkID0gWydoaWdoLWNvbnRyYXN0JywgJ3Byb2Zlc3Npb25hbCcsICdhbWJlcicsICdjZ2EnLCAnY2xhc3NpYyddO1xyXG4gIHJldHVybiB2YWxpZC5pbmNsdWRlcyh0aGVtZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXRzIGFtb3VudCB0byBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXNcclxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBhbW91bnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QW1vdW50KGFtb3VudCwgZGVjaW1hbHMgPSA4KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IG51bSA9IHBhcnNlRmxvYXQoYW1vdW50KTtcclxuICAgIGlmIChpc05hTihudW0pKSByZXR1cm4gJzAnO1xyXG4gICAgcmV0dXJuIG51bS50b0ZpeGVkKGRlY2ltYWxzKTtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiAnMCc7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2hvcnRlbnMgYWRkcmVzcyBmb3IgZGlzcGxheSAoMHgxMjM0Li4uNTY3OClcclxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcclxuICogQHBhcmFtIHtudW1iZXJ9IGNoYXJzIC0gQ2hhcmFjdGVycyB0byBzaG93IG9uIGVhY2ggc2lkZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNob3J0ZW5BZGRyZXNzKGFkZHJlc3MsIGNoYXJzID0gNCkge1xyXG4gIGlmICghaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHJldHVybiBhZGRyZXNzO1xyXG4gIHJldHVybiBgJHthZGRyZXNzLnNsaWNlKDAsIGNoYXJzICsgMil9Li4uJHthZGRyZXNzLnNsaWNlKC1jaGFycyl9YDtcclxufVxyXG4iLCIvKipcclxuICogY29yZS93YWxsZXQuanNcclxuICpcclxuICogTXVsdGktd2FsbGV0IGNyZWF0aW9uLCBpbXBvcnQsIGFuZCBrZXkgbWFuYWdlbWVudFxyXG4gKlxyXG4gKiBTRUNVUklUWTogVXNlcyBzZWxmLWRlc2NyaWJpbmcgZW5jcnlwdGlvbiBmb3JtYXQgd2l0aCBpdGVyYXRpb24gbWV0YWRhdGFcclxuICogZm9yIGZ1dHVyZS1wcm9vZiBjcnlwdG9ncmFwaGljIGFnaWxpdHkuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcclxuaW1wb3J0IHsgc2F2ZSwgbG9hZCB9IGZyb20gJy4vc3RvcmFnZS5qcyc7XHJcbmltcG9ydCB7IGlzVmFsaWRNbmVtb25pYywgaXNWYWxpZFByaXZhdGVLZXksIHZhbGlkYXRlUGFzc3dvcmRTdHJlbmd0aCB9IGZyb20gJy4vdmFsaWRhdGlvbi5qcyc7XHJcblxyXG4vLyA9PT09PSBQQktERjIgSVRFUkFUSU9OIFJFQ09NTUVOREFUSU9OUyA9PT09PVxyXG4vLyBCYXNlZCBvbiBoaXN0b3JpY2FsIE9XQVNQIGRhdGEgYW5kIEdQVSBjcmFja2luZyBzcGVlZCB0cmVuZHNcclxuLy9cclxuLy8gSGlzdG9yaWNhbCBPV0FTUCBSZWNvbW1lbmRhdGlvbnM6XHJcbi8vIC0gMjAxNjogMTAsMDAwIGl0ZXJhdGlvbnNcclxuLy8gLSAyMDIxOiAzMTAsMDAwIGl0ZXJhdGlvbnMgKDMxeCBpbiA1IHllYXJzID0gOTclIENBR1IpXHJcbi8vIC0gMjAyMzogNjAwLDAwMCBpdGVyYXRpb25zICgxLjk0eCBpbiAyIHllYXJzID0gMzklIENBR1IpXHJcbi8vXHJcbi8vIEdQVSBDcmFja2luZyBTcGVlZCBHcm93dGggKDIwMTYtMjAyMik6XHJcbi8vIC0gR1RYIDEwODAg4oaSIFJUWCA0MDkwOiA4eCBpbXByb3ZlbWVudCA9IDM5JSBDQUdSXHJcbi8vXHJcbi8vIE1vZGVsOiAzNSUgQ0FHUiAoZG91YmxpbmcgZXZlcnkgfjIuMyB5ZWFycylcclxuLy8gUmF0aW9uYWxlOiBDb25zZXJ2YXRpdmUgZXN0aW1hdGUgbWF0Y2hpbmcgR1BVIGltcHJvdmVtZW50c1xyXG5jb25zdCBJVEVSQVRJT05fTUlMRVNUT05FUyA9IFtcclxuICAvLyBIaXN0b3JpY2FsIE9XQVNQIHJlY29tbWVuZGF0aW9ucyAoYWN0dWFsIGRhdGEpXHJcbiAgeyB5ZWFyOiAyMDE2LCBpdGVyYXRpb25zOiAxMDAwMCwgICBzb3VyY2U6ICdPV0FTUCAyMDE2JyB9LFxyXG4gIHsgeWVhcjogMjAyMSwgaXRlcmF0aW9uczogMzEwMDAwLCAgc291cmNlOiAnT1dBU1AgMjAyMScgfSxcclxuICB7IHllYXI6IDIwMjMsIGl0ZXJhdGlvbnM6IDYwMDAwMCwgIHNvdXJjZTogJ09XQVNQIDIwMjMnIH0sXHJcblxyXG4gIC8vIFByb2plY3RlZCB1c2luZyAzNSUgQ0FHUiBmcm9tIDIwMjMgYmFzZWxpbmVcclxuICB7IHllYXI6IDIwMjQsIGl0ZXJhdGlvbnM6IDgxMDAwMCwgIHNvdXJjZTogJ1Byb2plY3RlZCAoMzUlIENBR1IpJyB9LFxyXG4gIHsgeWVhcjogMjAyNSwgaXRlcmF0aW9uczogMTA5NDAwMCwgc291cmNlOiAnUHJvamVjdGVkICgzNSUgQ0FHUiknIH0sXHJcbiAgeyB5ZWFyOiAyMDI2LCBpdGVyYXRpb25zOiAxNDc3MDAwLCBzb3VyY2U6ICdQcm9qZWN0ZWQgKDM1JSBDQUdSKScgfSxcclxuICB7IHllYXI6IDIwMjcsIGl0ZXJhdGlvbnM6IDE5OTQwMDAsIHNvdXJjZTogJ1Byb2plY3RlZCAoMzUlIENBR1IpJyB9LFxyXG4gIHsgeWVhcjogMjAyOCwgaXRlcmF0aW9uczogMjY5MjAwMCwgc291cmNlOiAnUHJvamVjdGVkICgzNSUgQ0FHUiknIH0sXHJcbiAgeyB5ZWFyOiAyMDI5LCBpdGVyYXRpb25zOiAzNjM1MDAwLCBzb3VyY2U6ICdQcm9qZWN0ZWQgKDM1JSBDQUdSKScgfSxcclxuICB7IHllYXI6IDIwMzAsIGl0ZXJhdGlvbnM6IDQ5MDcwMDAsIHNvdXJjZTogJ1Byb2plY3RlZCAoMzUlIENBR1IpJyB9LFxyXG4gIHsgeWVhcjogMjAzMSwgaXRlcmF0aW9uczogNTAwMDAwMCwgc291cmNlOiAnQ2FwcGVkIGZvciBVWCAofjJzZWMgb24gc2xvdyBkZXZpY2VzKScgfSxcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHJlY29tbWVuZGVkIFBCS0RGMiBpdGVyYXRpb24gY291bnQgZm9yIGN1cnJlbnQgeWVhclxyXG4gKiBVc2VzIGhpc3RvcmljYWwgT1dBU1AgZGF0YSBhbmQgZXhwb25lbnRpYWwgZ3Jvd3RoIG1vZGVsXHJcbiAqXHJcbiAqIFNFQ1VSSVRZOiBJbmNsdWRlcyBtaW5pbXVtIGZsb29yIHRvIHByZXZlbnQgY2xvY2sgbWFuaXB1bGF0aW9uIGF0dGFja3NcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHllYXIgLSBZZWFyIHRvIGdldCByZWNvbW1lbmRhdGlvbiBmb3IgKGRlZmF1bHRzIHRvIGN1cnJlbnQgeWVhcilcclxuICogQHJldHVybnMge251bWJlcn0gUmVjb21tZW5kZWQgaXRlcmF0aW9uIGNvdW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFJlY29tbWVuZGVkSXRlcmF0aW9ucyh5ZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpKSB7XHJcbiAgLy8gU0VDVVJJVFk6IFByZXZlbnQgYmFja2RhdGluZyBjbG9jayB0byBnZXQgbG93ZXIgaXRlcmF0aW9uc1xyXG4gIC8vIElmIHN5c3RlbSB5ZWFyIGlzIGJlZm9yZSBidWlsZCB5ZWFyLCB1c2UgYnVpbGQgeWVhciBpbnN0ZWFkXHJcbiAgY29uc3Qgc2FmZVllYXIgPSBNYXRoLm1heCh5ZWFyLCBCVUlMRF9ZRUFSKTtcclxuXHJcbiAgLy8gRmluZCBleGFjdCBtYXRjaCBmaXJzdFxyXG4gIGNvbnN0IGV4YWN0TWF0Y2ggPSBJVEVSQVRJT05fTUlMRVNUT05FUy5maW5kKG0gPT4gbS55ZWFyID09PSBzYWZlWWVhcik7XHJcbiAgaWYgKGV4YWN0TWF0Y2gpIHtcclxuICAgIHJldHVybiBNYXRoLm1heChleGFjdE1hdGNoLml0ZXJhdGlvbnMsIE1JTklNVU1fSVRFUkFUSU9OUyk7XHJcbiAgfVxyXG5cclxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIG1pbGVzdG9uZXMgZm9yIGludGVycG9sYXRpb25cclxuICBjb25zdCBiZWZvcmUgPSBJVEVSQVRJT05fTUlMRVNUT05FU1xyXG4gICAgLmZpbHRlcihtID0+IG0ueWVhciA8IHNhZmVZZWFyKVxyXG4gICAgLnNvcnQoKGEsIGIpID0+IGIueWVhciAtIGEueWVhcilbMF07XHJcblxyXG4gIGNvbnN0IGFmdGVyID0gSVRFUkFUSU9OX01JTEVTVE9ORVNcclxuICAgIC5maWx0ZXIobSA9PiBtLnllYXIgPiBzYWZlWWVhcilcclxuICAgIC5zb3J0KChhLCBiKSA9PiBhLnllYXIgLSBiLnllYXIpWzBdO1xyXG5cclxuICAvLyBCZWZvcmUgYWxsIG1pbGVzdG9uZXM6IHVzZSBlYXJsaWVzdCAoYnV0IGF0IGxlYXN0IG1pbmltdW0pXHJcbiAgaWYgKCFiZWZvcmUpIHtcclxuICAgIHJldHVybiBNYXRoLm1heChJVEVSQVRJT05fTUlMRVNUT05FU1swXS5pdGVyYXRpb25zLCBNSU5JTVVNX0lURVJBVElPTlMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQWZ0ZXIgYWxsIG1pbGVzdG9uZXM6IHVzZSBsYXRlc3QgKGNhcHBlZClcclxuICBpZiAoIWFmdGVyKSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoSVRFUkFUSU9OX01JTEVTVE9ORVNbSVRFUkFUSU9OX01JTEVTVE9ORVMubGVuZ3RoIC0gMV0uaXRlcmF0aW9ucywgTUlOSU1VTV9JVEVSQVRJT05TKTtcclxuICB9XHJcblxyXG4gIC8vIEV4cG9uZW50aWFsIGludGVycG9sYXRpb24gKGFjY3VyYXRlIGZvciBDQUdSLWJhc2VkIGdyb3d0aClcclxuICBjb25zdCB5ZWFyUmFuZ2UgPSBhZnRlci55ZWFyIC0gYmVmb3JlLnllYXI7XHJcbiAgY29uc3QgaXRlcmF0aW9uUmF0aW8gPSBhZnRlci5pdGVyYXRpb25zIC8gYmVmb3JlLml0ZXJhdGlvbnM7XHJcbiAgY29uc3QgeWVhclByb2dyZXNzID0gKHNhZmVZZWFyIC0gYmVmb3JlLnllYXIpIC8geWVhclJhbmdlO1xyXG5cclxuICBjb25zdCBjYWxjdWxhdGVkID0gTWF0aC5mbG9vcihiZWZvcmUuaXRlcmF0aW9ucyAqIE1hdGgucG93KGl0ZXJhdGlvblJhdGlvLCB5ZWFyUHJvZ3Jlc3MpKTtcclxuXHJcbiAgLy8gU0VDVVJJVFk6IEFsd2F5cyBlbmZvcmNlIG1pbmltdW0gaXRlcmF0aW9uIGZsb29yXHJcbiAgcmV0dXJuIE1hdGgubWF4KGNhbGN1bGF0ZWQsIE1JTklNVU1fSVRFUkFUSU9OUyk7XHJcbn1cclxuXHJcbi8vIExlZ2FjeSBpdGVyYXRpb24gY291bnQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuY29uc3QgTEVHQUNZX0lURVJBVElPTlMgPSAxMDAwMDA7XHJcblxyXG4vLyBTZWN1cml0eTogTWluaW11bSBpdGVyYXRpb24gZmxvb3IgdG8gcHJldmVudCBjbG9jayBtYW5pcHVsYXRpb24gYXR0YWNrc1xyXG4vLyBBbiBhdHRhY2tlciB3aXRoIGxvY2FsIHN5c3RlbSBhY2Nlc3MgY291bGQgYmFja2RhdGUgdGhlIGNsb2NrIHRvIGZvcmNlIGxvd2VyIGl0ZXJhdGlvbnMuXHJcbi8vIFRoaXMgZmxvb3IgZW5zdXJlcyB3YWxsZXRzIGNyZWF0ZWQgd2l0aCB0aGlzIGJ1aWxkIGFsd2F5cyBtZWV0IG1pbmltdW0gc2VjdXJpdHkgc3RhbmRhcmRzLlxyXG5jb25zdCBCVUlMRF9ZRUFSID0gMjAyNTtcclxuY29uc3QgTUlOSU1VTV9JVEVSQVRJT05TID0gMTA5NDAwMDsgLy8gMjAyNSBiYXNlbGluZSBmcm9tIE9XQVNQIHByb2plY3Rpb25zXHJcblxyXG4vLyA9PT09PSBTRUxGLURFU0NSSUJJTkcgRU5DUllQVElPTiBGT1JNQVQgPT09PT1cclxuLy8gRm9ybWF0OiBbNCBieXRlczogaXRlcmF0aW9uIGNvdW50XVsxNiBieXRlczogc2FsdF1bMTIgYnl0ZXM6IElWXVt2YXJpYWJsZTogY2lwaGVydGV4dF1cclxuLy8gVGhpcyBhbGxvd3MgaXRlcmF0aW9uIGNvdW50IHRvIGV2b2x2ZSBvdmVyIHRpbWUgd2l0aG91dCBicmVha2luZyBleGlzdGluZyB3YWxsZXRzXHJcblxyXG4vKipcclxuICogRGVyaXZlcyBhbiBlbmNyeXB0aW9uIGtleSBmcm9tIHBhc3N3b3JkIHVzaW5nIFBCS0RGMlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gc2FsdCAtIFNhbHQgZm9yIGtleSBkZXJpdmF0aW9uICgxNiBieXRlcylcclxuICogQHBhcmFtIHtudW1iZXJ9IGl0ZXJhdGlvbnMgLSBQQktERjIgaXRlcmF0aW9uIGNvdW50XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPENyeXB0b0tleT59XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZXJpdmVFbmNyeXB0aW9uS2V5KHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zKSB7XHJcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gIGNvbnN0IHBhc3N3b3JkQnVmZmVyID0gZW5jb2Rlci5lbmNvZGUocGFzc3dvcmQpO1xyXG5cclxuICAvLyBJbXBvcnQgcGFzc3dvcmQgYXMga2V5IG1hdGVyaWFsXHJcbiAgY29uc3Qga2V5TWF0ZXJpYWwgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcclxuICAgICdyYXcnLFxyXG4gICAgcGFzc3dvcmRCdWZmZXIsXHJcbiAgICB7IG5hbWU6ICdQQktERjInIH0sXHJcbiAgICBmYWxzZSxcclxuICAgIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXVxyXG4gICk7XHJcblxyXG4gIC8vIERlcml2ZSBBRVMtR0NNIGtleVxyXG4gIHJldHVybiBhd2FpdCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ1BCS0RGMicsXHJcbiAgICAgIHNhbHQ6IHNhbHQsXHJcbiAgICAgIGl0ZXJhdGlvbnM6IGl0ZXJhdGlvbnMsXHJcbiAgICAgIGhhc2g6ICdTSEEtMjU2J1xyXG4gICAgfSxcclxuICAgIGtleU1hdGVyaWFsLFxyXG4gICAgeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMjU2IH0sXHJcbiAgICBmYWxzZSxcclxuICAgIFsnZW5jcnlwdCcsICdkZWNyeXB0J11cclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogRW5jcnlwdHMgZGF0YSB3aXRoIEFFUy1HQ00gYW5kIHN0b3JlcyBpdGVyYXRpb24gY291bnQgaW4gbWV0YWRhdGFcclxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBEYXRhIHRvIGVuY3J5cHRcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVXNlciBwYXNzd29yZFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaXRlcmF0aW9ucyAtIFBCS0RGMiBpdGVyYXRpb25zIChkZWZhdWx0cyB0byBjdXJyZW50IHJlY29tbWVuZGF0aW9uKVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBCYXNlNjQgZW5jb2RlZCBlbmNyeXB0ZWQgZGF0YSB3aXRoIG1ldGFkYXRhXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0V2l0aEFFUyhkYXRhLCBwYXNzd29yZCwgaXRlcmF0aW9ucyA9IGdldEN1cnJlbnRSZWNvbW1lbmRlZEl0ZXJhdGlvbnMoKSkge1xyXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcclxuICBjb25zdCBkYXRhQnVmZmVyID0gZW5jb2Rlci5lbmNvZGUoZGF0YSk7XHJcblxyXG4gIC8vIFNFQ1VSSVRZOiBHZW5lcmF0ZSBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gc2FsdCBhbmQgSVZcclxuICAvLyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgdXNlcyB0aGUgYnJvd3NlcidzIENTUFJORyAoQ3J5cHRvZ3JhcGhpY2FsbHkgU2VjdXJlXHJcbiAgLy8gUHNldWRvLVJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yKSwgd2hpY2ggZW5zdXJlczpcclxuICAvLyAxLiBUcnVlIHJhbmRvbW5lc3MgZnJvbSBoYXJkd2FyZSBlbnRyb3B5IHNvdXJjZXNcclxuICAvLyAyLiBJViB1bmlxdWVuZXNzIGlzIGNyeXB0b2dyYXBoaWNhbGx5IGd1YXJhbnRlZWQgKGNvbGxpc2lvbiBwcm9iYWJpbGl0eSA8IDJeLTY0KVxyXG4gIC8vIDMuIFVucHJlZGljdGFiaWxpdHkgLSBjYW5ub3QgYmUgZ3Vlc3NlZCBieSBhdHRhY2tlcnNcclxuICAvLyBFYWNoIGVuY3J5cHRpb24gb3BlcmF0aW9uIGdldHMgYSB1bmlxdWUgSVYsIHdoaWNoIGlzIGNyaXRpY2FsIGZvciBBRVMtR0NNIHNlY3VyaXR5XHJcbiAgY29uc3Qgc2FsdCA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKTtcclxuICBjb25zdCBpdiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTIpKTtcclxuXHJcbiAgLy8gRGVyaXZlIGtleSB3aXRoIHNwZWNpZmllZCBpdGVyYXRpb25zXHJcbiAgY29uc3Qga2V5ID0gYXdhaXQgZGVyaXZlRW5jcnlwdGlvbktleShwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucyk7XHJcblxyXG4gIC8vIEVuY3J5cHRcclxuICBjb25zdCBlbmNyeXB0ZWRCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoXHJcbiAgICB7IG5hbWU6ICdBRVMtR0NNJywgaXY6IGl2IH0sXHJcbiAgICBrZXksXHJcbiAgICBkYXRhQnVmZmVyXHJcbiAgKTtcclxuXHJcbiAgLy8gUHJlcGVuZCBpdGVyYXRpb24gY291bnQgYXMgNC1ieXRlIGJpZy1lbmRpYW4gaW50ZWdlclxyXG4gIGNvbnN0IGl0ZXJhdGlvbkJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XHJcbiAgbmV3IERhdGFWaWV3KGl0ZXJhdGlvbkJ5dGVzLmJ1ZmZlcikuc2V0VWludDMyKDAsIGl0ZXJhdGlvbnMsIGZhbHNlKTsgLy8gQmlnLWVuZGlhblxyXG5cclxuICAvLyBDb21iaW5lOiBbaXRlcmF0aW9uc11bc2FsdF1bSVZdW2NpcGhlcnRleHRdXHJcbiAgY29uc3QgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShcclxuICAgIDQgKyBzYWx0Lmxlbmd0aCArIGl2Lmxlbmd0aCArIGVuY3J5cHRlZEJ1ZmZlci5ieXRlTGVuZ3RoXHJcbiAgKTtcclxuICBjb21iaW5lZC5zZXQoaXRlcmF0aW9uQnl0ZXMsIDApO1xyXG4gIGNvbWJpbmVkLnNldChzYWx0LCA0KTtcclxuICBjb21iaW5lZC5zZXQoaXYsIDQgKyBzYWx0Lmxlbmd0aCk7XHJcbiAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZEJ1ZmZlciksIDQgKyBzYWx0Lmxlbmd0aCArIGl2Lmxlbmd0aCk7XHJcblxyXG4gIC8vIFJldHVybiBhcyBiYXNlNjRcclxuICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNvbWJpbmVkKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNyeXB0cyBBRVMtR0NNIGVuY3J5cHRlZCBkYXRhLCByZWFkaW5nIGl0ZXJhdGlvbiBjb3VudCBmcm9tIG1ldGFkYXRhXHJcbiAqIEhhbmRsZXMgYm90aCBuZXcgZm9ybWF0ICh3aXRoIGl0ZXJhdGlvbiBtZXRhZGF0YSkgYW5kIGxlZ2FjeSBmb3JtYXRcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGVuY3J5cHRlZERhdGEgLSBCYXNlNjQgZW5jb2RlZCBlbmNyeXB0ZWQgZGF0YVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IERlY3J5cHRlZCBkYXRhXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0V2l0aEFFUyhlbmNyeXB0ZWREYXRhLCBwYXNzd29yZCkge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBEZWNvZGUgZnJvbSBiYXNlNjRcclxuICAgIGNvbnN0IGNvbWJpbmVkID0gVWludDhBcnJheS5mcm9tKGF0b2IoZW5jcnlwdGVkRGF0YSksIGMgPT4gYy5jaGFyQ29kZUF0KDApKTtcclxuXHJcbiAgICBsZXQgaXRlcmF0aW9uQ291bnQ7XHJcbiAgICBsZXQgc2FsdCwgaXYsIGVuY3J5cHRlZDtcclxuXHJcbiAgICAvLyBBdXRvLWRldGVjdCBmb3JtYXQ6IG5ldyAod2l0aCBtZXRhZGF0YSkgdnMgbGVnYWN5XHJcbiAgICBpZiAoY29tYmluZWQubGVuZ3RoID49IDQpIHtcclxuICAgICAgY29uc3QgcG9zc2libGVJdGVyYXRpb25zID0gbmV3IERhdGFWaWV3KGNvbWJpbmVkLmJ1ZmZlciwgMCwgNCkuZ2V0VWludDMyKDAsIGZhbHNlKTtcclxuXHJcbiAgICAgIC8vIEhldXJpc3RpYzogdmFsaWQgaXRlcmF0aW9uIGNvdW50cyBhcmUgMTAway01TVxyXG4gICAgICAvLyBJZiBmaXJzdCA0IGJ5dGVzIGFyZSBpbiB0aGlzIHJhbmdlLCBpdCdzIHRoZSBuZXcgc2VsZi1kZXNjcmliaW5nIGZvcm1hdFxyXG4gICAgICBpZiAocG9zc2libGVJdGVyYXRpb25zID49IDEwMDAwMCAmJiBwb3NzaWJsZUl0ZXJhdGlvbnMgPD0gNTAwMDAwMCkge1xyXG4gICAgICAgIC8vIOKchSBORVcgRk9STUFUIC0gcmVhZCBpdGVyYXRpb24gY291bnQgZnJvbSBtZXRhZGF0YVxyXG4gICAgICAgIGl0ZXJhdGlvbkNvdW50ID0gcG9zc2libGVJdGVyYXRpb25zO1xyXG4gICAgICAgIHNhbHQgPSBjb21iaW5lZC5zbGljZSg0LCAyMCk7XHJcbiAgICAgICAgaXYgPSBjb21iaW5lZC5zbGljZSgyMCwgMzIpO1xyXG4gICAgICAgIGVuY3J5cHRlZCA9IGNvbWJpbmVkLnNsaWNlKDMyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyDinIUgTEVHQUNZIEZPUk1BVCAtIHVzZSBoYXJkY29kZWQgbGVnYWN5IGl0ZXJhdGlvbiBjb3VudFxyXG4gICAgICAgIGl0ZXJhdGlvbkNvdW50ID0gTEVHQUNZX0lURVJBVElPTlM7XHJcbiAgICAgICAgc2FsdCA9IGNvbWJpbmVkLnNsaWNlKDAsIDE2KTtcclxuICAgICAgICBpdiA9IGNvbWJpbmVkLnNsaWNlKDE2LCAyOCk7XHJcbiAgICAgICAgZW5jcnlwdGVkID0gY29tYmluZWQuc2xpY2UoMjgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jcnlwdGVkIGRhdGEgZm9ybWF0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVyaXZlIGtleSB1c2luZyB0aGUgc3RvcmVkIGl0ZXJhdGlvbiBjb3VudFxyXG4gICAgY29uc3Qga2V5ID0gYXdhaXQgZGVyaXZlRW5jcnlwdGlvbktleShwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9uQ291bnQpO1xyXG5cclxuICAgIC8vIERlY3J5cHRcclxuICAgIGNvbnN0IGRlY3J5cHRlZEJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGVjcnlwdChcclxuICAgICAgeyBuYW1lOiAnQUVTLUdDTScsIGl2OiBpdiB9LFxyXG4gICAgICBrZXksXHJcbiAgICAgIGVuY3J5cHRlZFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xyXG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xyXG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGRlY3J5cHRlZEJ1ZmZlcik7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnSW52YWxpZCBlbmNyeXB0ZWQgZGF0YSBmb3JtYXQnKSB7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZCAtIGluY29ycmVjdCBwYXNzd29yZCBvciBjb3JydXB0ZWQgZGF0YScpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3RzIGl0ZXJhdGlvbiBjb3VudCBmcm9tIGVuY3J5cHRlZCBkYXRhIHdpdGhvdXQgZGVjcnlwdGluZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jcnlwdGVkRGF0YSAtIEJhc2U2NCBlbmNvZGVkIGVuY3J5cHRlZCBkYXRhXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEl0ZXJhdGlvbiBjb3VudCwgb3IgTEVHQUNZX0lURVJBVElPTlMgaWYgbGVnYWN5IGZvcm1hdFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SXRlcmF0aW9uc0Zyb21FbmNyeXB0ZWQoZW5jcnlwdGVkRGF0YSkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjb21iaW5lZCA9IFVpbnQ4QXJyYXkuZnJvbShhdG9iKGVuY3J5cHRlZERhdGEpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XHJcblxyXG4gICAgaWYgKGNvbWJpbmVkLmxlbmd0aCA+PSA0KSB7XHJcbiAgICAgIGNvbnN0IHBvc3NpYmxlSXRlcmF0aW9ucyA9IG5ldyBEYXRhVmlldyhjb21iaW5lZC5idWZmZXIsIDAsIDQpLmdldFVpbnQzMigwLCBmYWxzZSk7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBpdCBsb29rcyBsaWtlIGEgdmFsaWQgaXRlcmF0aW9uIGNvdW50XHJcbiAgICAgIGlmIChwb3NzaWJsZUl0ZXJhdGlvbnMgPj0gMTAwMDAwICYmIHBvc3NpYmxlSXRlcmF0aW9ucyA8PSA1MDAwMDAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHBvc3NpYmxlSXRlcmF0aW9ucztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIExlZ2FjeSBmb3JtYXRcclxuICAgIHJldHVybiBMRUdBQ1lfSVRFUkFUSU9OUztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIExFR0FDWV9JVEVSQVRJT05TO1xyXG4gIH1cclxufVxyXG5cclxuLy8gU3RvcmFnZSBrZXlzXHJcbmNvbnN0IE9MRF9XQUxMRVRfS0VZID0gJ3dhbGxldF9lbmNyeXB0ZWQnOyAvLyBMZWdhY3kgc2luZ2xlIHdhbGxldFxyXG5jb25zdCBXQUxMRVRTX0tFWSA9ICd3YWxsZXRzX211bHRpJzsgLy8gTmV3IG11bHRpLXdhbGxldCBzdHJ1Y3R1cmVcclxuXHJcbi8vID09PT09IENPTkNVUlJFTkNZIENPTlRST0wgPT09PT1cclxuLy8gUHJldmVudHMgcmFjZSBjb25kaXRpb25zIHdoZW4gbXVsdGlwbGUgdGFicyB1cGdyYWRlIHRoZSBzYW1lIHdhbGxldCBzaW11bHRhbmVvdXNseVxyXG4vLyBNYXBzIHdhbGxldCBJRCB0byB1cGdyYWRlIFByb21pc2VcclxuY29uc3Qgb25nb2luZ1VwZ3JhZGVzID0gbmV3IE1hcCgpO1xyXG5cclxuLyoqXHJcbiAqIE1pZ3JhdGlvbjogQ29udmVydHMgb2xkIHNpbmdsZS13YWxsZXQgZm9ybWF0IHRvIG5ldyBtdWx0aS13YWxsZXQgZm9ybWF0XHJcbiAqIFJ1bnMgYXV0b21hdGljYWxseSBvbiBmaXJzdCBsb2FkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBUcnVlIGlmIG1pZ3JhdGlvbiBvY2N1cnJlZCwgZmFsc2UgaWYgYWxyZWFkeSBtaWdyYXRlZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGVUb011bHRpV2FsbGV0KCkge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHVzaW5nIG5ldyBmb3JtYXRcclxuICAgIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgbG9hZChXQUxMRVRTX0tFWSk7XHJcbiAgICBpZiAod2FsbGV0c0RhdGEpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBBbHJlYWR5IG1pZ3JhdGVkXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIG9sZCBmb3JtYXQgd2FsbGV0XHJcbiAgICBjb25zdCBvbGRXYWxsZXQgPSBhd2FpdCBsb2FkKE9MRF9XQUxMRVRfS0VZKTtcclxuICAgIGlmICghb2xkV2FsbGV0KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gd2FsbGV0IHRvIG1pZ3JhdGVcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgYWRkcmVzcyBmcm9tIG9sZCB3YWxsZXQgKHdlJ2xsIG5lZWQgdG8gdGVtcG9yYXJpbHkgZGVjcnlwdCBpdClcclxuICAgIC8vIEZvciBub3csIHdlJ2xsIGNyZWF0ZSBhIHBsYWNlaG9sZGVyIC0gdGhlIGFkZHJlc3Mgd2lsbCBiZSBwb3B1bGF0ZWQgb24gZmlyc3QgdW5sb2NrXHJcbiAgICBjb25zdCBuZXdGb3JtYXQgPSB7XHJcbiAgICAgIGFjdGl2ZVdhbGxldElkOiAnd2FsbGV0X21pZ3JhdGVkXycgKyBEYXRlLm5vdygpLFxyXG4gICAgICB3YWxsZXRMaXN0OiBbe1xyXG4gICAgICAgIGlkOiAnd2FsbGV0X21pZ3JhdGVkXycgKyBEYXRlLm5vdygpLFxyXG4gICAgICAgIG5pY2tuYW1lOiAnTWFpbiBXYWxsZXQnLFxyXG4gICAgICAgIGFkZHJlc3M6IG51bGwsIC8vIFdpbGwgYmUgcG9wdWxhdGVkIG9uIHVubG9ja1xyXG4gICAgICAgIGVuY3J5cHRlZEtleXN0b3JlOiBvbGRXYWxsZXQsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxyXG4gICAgICAgIGltcG9ydE1ldGhvZDogJ21pZ3JhdGVkJ1xyXG4gICAgICB9XVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTYXZlIG5ldyBmb3JtYXRcclxuICAgIGF3YWl0IHNhdmUoV0FMTEVUU19LRVksIG5ld0Zvcm1hdCk7XHJcblxyXG4gICAgLy8gS2VlcCBvbGQgd2FsbGV0IGZvciBzYWZldHkgZHVyaW5nIHRyYW5zaXRpb25cclxuICAgIC8vIENhbiBiZSBjbGVhbmVkIHVwIGxhdGVyXHJcblxyXG4gICAgLy8gTWlncmF0ZWQgdG8gbXVsdGktd2FsbGV0IGZvcm1hdFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBtaWdyYXRpb246JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgYWxsIHdhbGxldHMgZGF0YVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7YWN0aXZlV2FsbGV0SWQ6IHN0cmluZywgd2FsbGV0TGlzdDogQXJyYXl9Pn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxXYWxsZXRzKCkge1xyXG4gIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgbG9hZChXQUxMRVRTX0tFWSk7XHJcbiAgaWYgKCF3YWxsZXRzRGF0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYWN0aXZlV2FsbGV0SWQ6IG51bGwsXHJcbiAgICAgIHdhbGxldExpc3Q6IFtdXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gd2FsbGV0c0RhdGE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIGFjdGl2ZSB3YWxsZXQgaW5mbyAod2l0aG91dCBkZWNyeXB0aW5nKVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8bnVsbD59IEFjdGl2ZSB3YWxsZXQgbWV0YWRhdGEgb3IgbnVsbFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjdGl2ZVdhbGxldCgpIHtcclxuICBjb25zdCB3YWxsZXRzRGF0YSA9IGF3YWl0IGdldEFsbFdhbGxldHMoKTtcclxuICBpZiAoIXdhbGxldHNEYXRhLmFjdGl2ZVdhbGxldElkIHx8IHdhbGxldHNEYXRhLndhbGxldExpc3QubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGFjdGl2ZVdhbGxldCA9IHdhbGxldHNEYXRhLndhbGxldExpc3QuZmluZChcclxuICAgIHcgPT4gdy5pZCA9PT0gd2FsbGV0c0RhdGEuYWN0aXZlV2FsbGV0SWRcclxuICApO1xyXG5cclxuICByZXR1cm4gYWN0aXZlV2FsbGV0IHx8IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYW55IHdhbGxldCBleGlzdHNcclxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FsbGV0RXhpc3RzKCkge1xyXG4gIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgZ2V0QWxsV2FsbGV0cygpO1xyXG4gIHJldHVybiB3YWxsZXRzRGF0YS53YWxsZXRMaXN0Lmxlbmd0aCA+IDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgd2FsbGV0IElEIHVzaW5nIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb21cclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlV2FsbGV0SWQoKSB7XHJcbiAgLy8gR2VuZXJhdGUgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbSBieXRlc1xyXG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XHJcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XHJcbiAgY29uc3QgcmFuZG9tU3RyID0gQXJyYXkuZnJvbShhcnJheSwgYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDM2KSkuam9pbignJyk7XHJcbiAgcmV0dXJuICd3YWxsZXRfJyArIERhdGUubm93KCkgKyAnXycgKyByYW5kb21TdHI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB3YWxsZXQgd2l0aCB0aGUgZ2l2ZW4gYWRkcmVzcyBhbHJlYWR5IGV4aXN0c1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEV0aGVyZXVtIGFkZHJlc3NcclxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBpc0R1cGxpY2F0ZUFkZHJlc3MoYWRkcmVzcykge1xyXG4gIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgZ2V0QWxsV2FsbGV0cygpO1xyXG4gIHJldHVybiB3YWxsZXRzRGF0YS53YWxsZXRMaXN0LnNvbWUoXHJcbiAgICB3ID0+IHcuYWRkcmVzcyAmJiB3LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIGRlZmF1bHQgbmlja25hbWUgZm9yIGEgbmV3IHdhbGxldFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVEZWZhdWx0Tmlja25hbWUoKSB7XHJcbiAgY29uc3Qgd2FsbGV0c0RhdGEgPSBhd2FpdCBnZXRBbGxXYWxsZXRzKCk7XHJcbiAgY29uc3QgY291bnQgPSB3YWxsZXRzRGF0YS53YWxsZXRMaXN0Lmxlbmd0aDtcclxuICByZXR1cm4gJ1dhbGxldCAnICsgKGNvdW50ICsgMSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgbmV3IHdhbGxldCB0byB0aGUgd2FsbGV0IGxpc3RcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSAnY3JlYXRlJywgJ21uZW1vbmljJywgb3IgJ3ByaXZhdGVrZXknXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0ge21uZW1vbmljPywgcHJpdmF0ZUtleT99XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFVzZXIgcGFzc3dvcmQgZm9yIGVuY3J5cHRpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IG5pY2tuYW1lIC0gT3B0aW9uYWwgY3VzdG9tIG5pY2tuYW1lXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHtpZDogc3RyaW5nLCBhZGRyZXNzOiBzdHJpbmcsIG1uZW1vbmljPzogc3RyaW5nfT59XHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB2YWxpZGF0aW9uIGZhaWxzIG9yIHdhbGxldCBjcmVhdGlvbiBmYWlsc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZFdhbGxldCh0eXBlLCBkYXRhLCBwYXNzd29yZCwgbmlja25hbWUgPSBudWxsKSB7XHJcbiAgLy8gVmFsaWRhdGUgcGFzc3dvcmQgc3RyZW5ndGhcclxuICBjb25zdCBwYXNzd29yZENoZWNrID0gdmFsaWRhdGVQYXNzd29yZFN0cmVuZ3RoKHBhc3N3b3JkKTtcclxuICBpZiAoIXBhc3N3b3JkQ2hlY2sudmFsaWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihwYXNzd29yZENoZWNrLmVycm9ycy5qb2luKCcsICcpKTtcclxuICB9XHJcblxyXG4gIGxldCB3YWxsZXQ7XHJcbiAgbGV0IG1uZW1vbmljID0gbnVsbDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIENyZWF0ZSBvciBpbXBvcnQgd2FsbGV0IGJhc2VkIG9uIHR5cGVcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlICdjcmVhdGUnOlxyXG4gICAgICAgIHdhbGxldCA9IGV0aGVycy5XYWxsZXQuY3JlYXRlUmFuZG9tKCk7XHJcbiAgICAgICAgbW5lbW9uaWMgPSB3YWxsZXQubW5lbW9uaWMucGhyYXNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnbW5lbW9uaWMnOlxyXG4gICAgICAgIGlmICghZGF0YS5tbmVtb25pYyB8fCAhaXNWYWxpZE1uZW1vbmljKGRhdGEubW5lbW9uaWMpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW5lbW9uaWMgcGhyYXNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNsZWFuTW5lbW9uaWMgPSBkYXRhLm1uZW1vbmljLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XHJcbiAgICAgICAgd2FsbGV0ID0gZXRoZXJzLldhbGxldC5mcm9tUGhyYXNlKGNsZWFuTW5lbW9uaWMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAncHJpdmF0ZWtleSc6XHJcbiAgICAgICAgaWYgKCFkYXRhLnByaXZhdGVLZXkgfHwgIWlzVmFsaWRQcml2YXRlS2V5KGRhdGEucHJpdmF0ZUtleSkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIGtleScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXkgPSBkYXRhLnByaXZhdGVLZXkuc3RhcnRzV2l0aCgnMHgnKSA/IGRhdGEucHJpdmF0ZUtleSA6ICcweCcgKyBkYXRhLnByaXZhdGVLZXk7XHJcbiAgICAgICAgd2FsbGV0ID0gbmV3IGV0aGVycy5XYWxsZXQoa2V5KTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdhbGxldCB0eXBlOiAnICsgdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSBhZGRyZXNzXHJcbiAgICBpZiAoYXdhaXQgaXNEdXBsaWNhdGVBZGRyZXNzKHdhbGxldC5hZGRyZXNzKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgd2FsbGV0IGFscmVhZHkgZXhpc3RzIGluIHlvdXIgd2FsbGV0IGxpc3QnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgY3VycmVudCByZWNvbW1lbmRlZCBpdGVyYXRpb25zXHJcbiAgICBjb25zdCBjdXJyZW50SXRlcmF0aW9ucyA9IGdldEN1cnJlbnRSZWNvbW1lbmRlZEl0ZXJhdGlvbnMoKTtcclxuXHJcbiAgICAvLyBEb3VibGUgZW5jcnlwdGlvbjpcclxuICAgIC8vIDEuIEVuY3J5cHQgd2FsbGV0IHdpdGggZXRoZXJzLmpzIChjcmVhdGVzIGVuY3J5cHRlZCBKU09OIGtleXN0b3JlKVxyXG4gICAgY29uc3QgZW5jcnlwdGVkSnNvbiA9IGF3YWl0IHdhbGxldC5lbmNyeXB0KHBhc3N3b3JkKTtcclxuXHJcbiAgICAvLyAyLiBFbmNyeXB0IHRoZSBrZXlzdG9yZSBhZ2FpbiB3aXRoIEFFUy1HQ00gdXNpbmcgY3VycmVudCBpdGVyYXRpb24gcmVjb21tZW5kYXRpb25zXHJcbiAgICBjb25zdCBkb3VibGVFbmNyeXB0ZWQgPSBhd2FpdCBlbmNyeXB0V2l0aEFFUyhlbmNyeXB0ZWRKc29uLCBwYXNzd29yZCwgY3VycmVudEl0ZXJhdGlvbnMpO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIG5pY2tuYW1lIGlmIG5vdCBwcm92aWRlZFxyXG4gICAgY29uc3QgZmluYWxOaWNrbmFtZSA9IG5pY2tuYW1lIHx8IGF3YWl0IGdlbmVyYXRlRGVmYXVsdE5pY2tuYW1lKCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHdhbGxldCBlbnRyeSB3aXRoIGRvdWJsZS1lbmNyeXB0ZWQga2V5c3RvcmVcclxuICAgIGNvbnN0IHdhbGxldEVudHJ5ID0ge1xyXG4gICAgICBpZDogZ2VuZXJhdGVXYWxsZXRJZCgpLFxyXG4gICAgICBuaWNrbmFtZTogZmluYWxOaWNrbmFtZSxcclxuICAgICAgYWRkcmVzczogd2FsbGV0LmFkZHJlc3MsXHJcbiAgICAgIGVuY3J5cHRlZEtleXN0b3JlOiBkb3VibGVFbmNyeXB0ZWQsXHJcbiAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcclxuICAgICAgaW1wb3J0TWV0aG9kOiB0eXBlLFxyXG4gICAgICBsYXN0U2VjdXJpdHlVcGdyYWRlOiBEYXRlLm5vdygpLCAvLyBUcmFjayB3aGVuIGVuY3J5cHRpb24gd2FzIGxhc3QgdXBncmFkZWRcclxuICAgICAgY3VycmVudEl0ZXJhdGlvbnM6IGN1cnJlbnRJdGVyYXRpb25zIC8vIFN0b3JlIGZvciBVSSBkaXNwbGF5XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEdldCBjdXJyZW50IHdhbGxldHMgZGF0YVxyXG4gICAgY29uc3Qgd2FsbGV0c0RhdGEgPSBhd2FpdCBnZXRBbGxXYWxsZXRzKCk7XHJcblxyXG4gICAgLy8gQ2hlY2sgd2FsbGV0IGxpbWl0IChtYXggMTApXHJcbiAgICBpZiAod2FsbGV0c0RhdGEud2FsbGV0TGlzdC5sZW5ndGggPj0gMTApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIHdhbGxldCBsaW1pdCAoMTApIHJlYWNoZWQuIFBsZWFzZSBkZWxldGUgYSB3YWxsZXQgdG8gYWRkIGEgbmV3IG9uZS4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdG8gbGlzdFxyXG4gICAgd2FsbGV0c0RhdGEud2FsbGV0TGlzdC5wdXNoKHdhbGxldEVudHJ5KTtcclxuXHJcbiAgICAvLyBTZXQgYXMgYWN0aXZlIGlmIGl0J3MgdGhlIGZpcnN0IHdhbGxldFxyXG4gICAgaWYgKHdhbGxldHNEYXRhLndhbGxldExpc3QubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIHdhbGxldHNEYXRhLmFjdGl2ZVdhbGxldElkID0gd2FsbGV0RW50cnkuaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2F2ZSB1cGRhdGVkIGRhdGFcclxuICAgIGF3YWl0IHNhdmUoV0FMTEVUU19LRVksIHdhbGxldHNEYXRhKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+UkCBXYWxsZXQgY3JlYXRlZCB3aXRoICR7Y3VycmVudEl0ZXJhdGlvbnMudG9Mb2NhbGVTdHJpbmcoKX0gUEJLREYyIGl0ZXJhdGlvbnNgKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gd2FsbGV0IGluZm9cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiB3YWxsZXRFbnRyeS5pZCxcclxuICAgICAgYWRkcmVzczogd2FsbGV0LmFkZHJlc3MsXHJcbiAgICAgIG1uZW1vbmljOiBtbmVtb25pYyAvLyBPbmx5IHNldCBmb3IgbmV3bHkgY3JlYXRlZCB3YWxsZXRzXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgd2FsbGV0OicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIGFjdGl2ZSB3YWxsZXRcclxuICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIC0gV2FsbGV0IElEIHRvIHN3aXRjaCB0b1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgbmV3IGFjdGl2ZSB3YWxsZXQgaW5mb1xyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgd2FsbGV0IElEIG5vdCBmb3VuZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldEFjdGl2ZVdhbGxldCh3YWxsZXRJZCkge1xyXG4gIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgZ2V0QWxsV2FsbGV0cygpO1xyXG5cclxuICAvLyBGaW5kIHdhbGxldFxyXG4gIGNvbnN0IHdhbGxldCA9IHdhbGxldHNEYXRhLndhbGxldExpc3QuZmluZCh3ID0+IHcuaWQgPT09IHdhbGxldElkKTtcclxuICBpZiAoIXdhbGxldCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGZvdW5kJyk7XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgYWN0aXZlIHdhbGxldFxyXG4gIHdhbGxldHNEYXRhLmFjdGl2ZVdhbGxldElkID0gd2FsbGV0SWQ7XHJcbiAgYXdhaXQgc2F2ZShXQUxMRVRTX0tFWSwgd2FsbGV0c0RhdGEpO1xyXG5cclxuICByZXR1cm4gd2FsbGV0O1xyXG59XHJcblxyXG4vKipcclxuICogUmVuYW1lcyBhIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgLSBXYWxsZXQgSUQgdG8gcmVuYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdOaWNrbmFtZSAtIE5ldyBuaWNrbmFtZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cclxuICogQHRocm93cyB7RXJyb3J9IElmIHdhbGxldCBub3QgZm91bmQgb3Igbmlja25hbWUgaXMgaW52YWxpZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmFtZVdhbGxldCh3YWxsZXRJZCwgbmV3Tmlja25hbWUpIHtcclxuICBpZiAoIW5ld05pY2tuYW1lIHx8IG5ld05pY2tuYW1lLnRyaW0oKS5sZW5ndGggPT09IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTmlja25hbWUgY2Fubm90IGJlIGVtcHR5Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAobmV3Tmlja25hbWUubGVuZ3RoID4gMzApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTmlja25hbWUgdG9vIGxvbmcgKG1heCAzMCBjaGFyYWN0ZXJzKScpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgd2FsbGV0c0RhdGEgPSBhd2FpdCBnZXRBbGxXYWxsZXRzKCk7XHJcbiAgY29uc3Qgd2FsbGV0ID0gd2FsbGV0c0RhdGEud2FsbGV0TGlzdC5maW5kKHcgPT4gdy5pZCA9PT0gd2FsbGV0SWQpO1xyXG5cclxuICBpZiAoIXdhbGxldCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGZvdW5kJyk7XHJcbiAgfVxyXG5cclxuICB3YWxsZXQubmlja25hbWUgPSBuZXdOaWNrbmFtZS50cmltKCk7XHJcbiAgYXdhaXQgc2F2ZShXQUxMRVRTX0tFWSwgd2FsbGV0c0RhdGEpO1xyXG59XHJcblxyXG4vKipcclxuICogRGVsZXRlcyBhIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgLSBXYWxsZXQgSUQgdG8gZGVsZXRlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFVzZXIgcGFzc3dvcmQgZm9yIHZlcmlmaWNhdGlvblxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cclxuICogQHRocm93cyB7RXJyb3J9IElmIHBhc3N3b3JkIGlzIGluY29ycmVjdCBvciB3YWxsZXQgbm90IGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlV2FsbGV0KHdhbGxldElkLCBwYXNzd29yZCkge1xyXG4gIC8vIFZlcmlmeSBwYXNzd29yZCBmaXJzdCBieSB0cnlpbmcgdG8gdW5sb2NrIGFjdGl2ZSB3YWxsZXRcclxuICBhd2FpdCB1bmxvY2tXYWxsZXQocGFzc3dvcmQpO1xyXG5cclxuICBjb25zdCB3YWxsZXRzRGF0YSA9IGF3YWl0IGdldEFsbFdhbGxldHMoKTtcclxuICBjb25zdCB3YWxsZXRJbmRleCA9IHdhbGxldHNEYXRhLndhbGxldExpc3QuZmluZEluZGV4KHcgPT4gdy5pZCA9PT0gd2FsbGV0SWQpO1xyXG5cclxuICBpZiAod2FsbGV0SW5kZXggPT09IC0xKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgZm91bmQnKTtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB3YWxsZXQgZnJvbSBsaXN0XHJcbiAgd2FsbGV0c0RhdGEud2FsbGV0TGlzdC5zcGxpY2Uod2FsbGV0SW5kZXgsIDEpO1xyXG5cclxuICAvLyBJZiB3ZSBkZWxldGVkIHRoZSBhY3RpdmUgd2FsbGV0LCBzd2l0Y2ggdG8gZmlyc3QgYXZhaWxhYmxlXHJcbiAgaWYgKHdhbGxldHNEYXRhLmFjdGl2ZVdhbGxldElkID09PSB3YWxsZXRJZCkge1xyXG4gICAgd2FsbGV0c0RhdGEuYWN0aXZlV2FsbGV0SWQgPSB3YWxsZXRzRGF0YS53YWxsZXRMaXN0Lmxlbmd0aCA+IDBcclxuICAgICAgPyB3YWxsZXRzRGF0YS53YWxsZXRMaXN0WzBdLmlkXHJcbiAgICAgIDogbnVsbDtcclxuICB9XHJcblxyXG4gIGF3YWl0IHNhdmUoV0FMTEVUU19LRVksIHdhbGxldHNEYXRhKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVubG9ja3MgdGhlIGFjdGl2ZSB3YWxsZXQgYW5kIHJldHVybnMgc2lnbmVyXHJcbiAqIEF1dG8tdXBncmFkZXMgZW5jcnlwdGlvbiBpZiB1c2luZyBvdXRkYXRlZCBpdGVyYXRpb24gY291bnRcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVXNlciBwYXNzd29yZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbmFsIHNldHRpbmdzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5za2lwVXBncmFkZSAtIFNraXAgYXV0by11cGdyYWRlIChmb3IgdGVzdGluZylcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblVwZ3JhZGVTdGFydCAtIENhbGxiYWNrIHdoZW4gdXBncmFkZSBzdGFydHNcclxuICogQHJldHVybnMge1Byb21pc2U8e2FkZHJlc3M6IHN0cmluZywgc2lnbmVyOiBldGhlcnMuV2FsbGV0LCB1cGdyYWRlZD86IGJvb2xlYW59Pn1cclxuICogQHRocm93cyB7RXJyb3J9IElmIHBhc3N3b3JkIGlzIGluY29ycmVjdCBvciBubyBhY3RpdmUgd2FsbGV0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdW5sb2NrV2FsbGV0KHBhc3N3b3JkLCBvcHRpb25zID0ge30pIHtcclxuICBjb25zdCBhY3RpdmVXYWxsZXQgPSBhd2FpdCBnZXRBY3RpdmVXYWxsZXQoKTtcclxuXHJcbiAgaWYgKCFhY3RpdmVXYWxsZXQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm8gd2FsbGV0IGZvdW5kLiBQbGVhc2UgY3JlYXRlIG9yIGltcG9ydCBhIHdhbGxldC4nKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhd2FpdCB1bmxvY2tTcGVjaWZpY1dhbGxldChhY3RpdmVXYWxsZXQuaWQsIHBhc3N3b3JkLCBvcHRpb25zKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVubG9ja3MgYSBzcGVjaWZpYyB3YWxsZXQgYnkgSUQgd2l0aCBhdXRvLXVwZ3JhZGUgY2FwYWJpbGl0eVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgLSBXYWxsZXQgSUQgdG8gdW5sb2NrXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFVzZXIgcGFzc3dvcmRcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25hbCBzZXR0aW5nc1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2tpcFVwZ3JhZGUgLSBTa2lwIGF1dG8tdXBncmFkZSAoZm9yIHRlc3RpbmcvZXhwb3J0KVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uVXBncmFkZVN0YXJ0IC0gQ2FsbGJhY2sgd2hlbiB1cGdyYWRlIHN0YXJ0c1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7YWRkcmVzczogc3RyaW5nLCBzaWduZXI6IGV0aGVycy5XYWxsZXQsIHVwZ3JhZGVkPzogYm9vbGVhbiwgaXRlcmF0aW9uc0JlZm9yZT86IG51bWJlciwgaXRlcmF0aW9uc0FmdGVyPzogbnVtYmVyfT59XHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBwYXNzd29yZCBpcyBpbmNvcnJlY3Qgb3Igd2FsbGV0IG5vdCBmb3VuZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVubG9ja1NwZWNpZmljV2FsbGV0KHdhbGxldElkLCBwYXNzd29yZCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHdhbGxldHNEYXRhID0gYXdhaXQgZ2V0QWxsV2FsbGV0cygpO1xyXG4gICAgY29uc3Qgd2FsbGV0ID0gd2FsbGV0c0RhdGEud2FsbGV0TGlzdC5maW5kKHcgPT4gdy5pZCA9PT0gd2FsbGV0SWQpO1xyXG5cclxuICAgIGlmICghd2FsbGV0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBmb3VuZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlY3J5cHQgdGhlIEFFUy1HQ00gbGF5ZXIgKGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyBpdGVyYXRpb24gY291bnQpXHJcbiAgICBjb25zdCBrZXlzdG9yZUpzb24gPSBhd2FpdCBkZWNyeXB0V2l0aEFFUyh3YWxsZXQuZW5jcnlwdGVkS2V5c3RvcmUsIHBhc3N3b3JkKTtcclxuXHJcbiAgICAvLyBUaGVuIGRlY3J5cHQgd2FsbGV0IHVzaW5nIGV0aGVycy5qcyBrZXlzdG9yZVxyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZXRoZXJzLldhbGxldC5mcm9tRW5jcnlwdGVkSnNvbihcclxuICAgICAga2V5c3RvcmVKc29uLFxyXG4gICAgICBwYXNzd29yZFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgYWRkcmVzcyBpZiBpdCdzIG51bGwgKG1pZ3JhdGlvbiBjYXNlKVxyXG4gICAgaWYgKCF3YWxsZXQuYWRkcmVzcykge1xyXG4gICAgICB3YWxsZXQuYWRkcmVzcyA9IHNpZ25lci5hZGRyZXNzO1xyXG4gICAgICBhd2FpdCBzYXZlKFdBTExFVFNfS0VZLCB3YWxsZXRzRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT0gQVVUTy1VUEdSQURFIFNZU1RFTSA9PT09PVxyXG4gICAgLy8gQ2hlY2sgaWYgd2FsbGV0IGVuY3J5cHRpb24gbmVlZHMgc2VjdXJpdHkgdXBncmFkZVxyXG4gICAgaWYgKCFvcHRpb25zLnNraXBVcGdyYWRlKSB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRJdGVyYXRpb25zID0gZ2V0SXRlcmF0aW9uc0Zyb21FbmNyeXB0ZWQod2FsbGV0LmVuY3J5cHRlZEtleXN0b3JlKTtcclxuICAgICAgY29uc3QgcmVjb21tZW5kZWRJdGVyYXRpb25zID0gZ2V0Q3VycmVudFJlY29tbWVuZGVkSXRlcmF0aW9ucygpO1xyXG5cclxuICAgICAgLy8gVXBncmFkZSBpZiBjdXJyZW50IGl0ZXJhdGlvbnMgYXJlIGJlbG93IHJlY29tbWVuZGF0aW9uXHJcbiAgICAgIGlmIChjdXJyZW50SXRlcmF0aW9ucyA8IHJlY29tbWVuZGVkSXRlcmF0aW9ucykge1xyXG4gICAgICAgIC8vIENPTkNVUlJFTkNZIENPTlRST0w6IENoZWNrIGlmIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgdGhpcyB3YWxsZXRcclxuICAgICAgICBpZiAob25nb2luZ1VwZ3JhZGVzLmhhcyh3YWxsZXRJZCkpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDij7MgV2FsbGV0IHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2FpdGluZyBmb3IgY29tcGxldGlvbi4uLmApO1xyXG5cclxuICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBvbmdvaW5nIHVwZ3JhZGUgdG8gY29tcGxldGVcclxuICAgICAgICAgIGF3YWl0IG9uZ29pbmdVcGdyYWRlcy5nZXQod2FsbGV0SWQpO1xyXG5cclxuICAgICAgICAgIC8vIFJlbG9hZCB3YWxsZXQgZGF0YSBhZnRlciB1cGdyYWRlIGNvbXBsZXRlc1xyXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFdhbGxldHNEYXRhID0gYXdhaXQgZ2V0QWxsV2FsbGV0cygpO1xyXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFdhbGxldCA9IHVwZGF0ZWRXYWxsZXRzRGF0YS53YWxsZXRMaXN0LmZpbmQodyA9PiB3LmlkID09PSB3YWxsZXRJZCk7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHdpdGggdXBncmFkZWQgZmxhZyBzZXQgdG8gdHJ1ZSAoYW5vdGhlciB0YWIgZGlkIHRoZSB1cGdyYWRlKVxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWRkcmVzczogc2lnbmVyLmFkZHJlc3MsXHJcbiAgICAgICAgICAgIHNpZ25lcjogc2lnbmVyLFxyXG4gICAgICAgICAgICB1cGdyYWRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgaXRlcmF0aW9uc0JlZm9yZTogY3VycmVudEl0ZXJhdGlvbnMsXHJcbiAgICAgICAgICAgIGl0ZXJhdGlvbnNBZnRlcjogcmVjb21tZW5kZWRJdGVyYXRpb25zLFxyXG4gICAgICAgICAgICB1cGdyYWRlZEJ5Q29uY3VycmVudFRhYjogdHJ1ZVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN0YXJ0IHVwZ3JhZGUgYW5kIHRyYWNrIGl0XHJcbiAgICAgICAgY29uc3QgdXBncmFkZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgaXRlcmF0aW9uc0JlZm9yZSA9IGN1cnJlbnRJdGVyYXRpb25zO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflJAgV2FsbGV0IGVuY3J5cHRpb24gdXBncmFkZSBhdmFpbGFibGU6YCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBDdXJyZW50OiAke2N1cnJlbnRJdGVyYXRpb25zLnRvTG9jYWxlU3RyaW5nKCl9IGl0ZXJhdGlvbnNgKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFJlY29tbWVuZGVkOiAke3JlY29tbWVuZGVkSXRlcmF0aW9ucy50b0xvY2FsZVN0cmluZygpfSBpdGVyYXRpb25zYCk7XHJcblxyXG4gICAgICAgICAgICAvLyBOb3RpZnkgdXNlciB2aWEgY2FsbGJhY2sgaWYgcHJvdmlkZWRcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25VcGdyYWRlU3RhcnQpIHtcclxuICAgICAgICAgICAgICBvcHRpb25zLm9uVXBncmFkZVN0YXJ0KHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgcmVjb21tZW5kZWRJdGVyYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkVGltZU1zOiBNYXRoLmZsb29yKChyZWNvbW1lbmRlZEl0ZXJhdGlvbnMgLyAxMDAwMDApICogMTAwKSAvLyB+MTAwbXMgcGVyIDEwMGsgaXRlcmF0aW9uc1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBVcGdyYWRpbmcgd2FsbGV0IHNlY3VyaXR5Li4uYCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZ3JhZGVTdGFydCA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZS1lbmNyeXB0IHdpdGggY3VycmVudCByZWNvbW1lbmRhdGlvbnNcclxuICAgICAgICAgICAgLy8gTGF5ZXIgMTogZXRoZXJzLmpzIGtleXN0b3JlICh1bmNoYW5nZWQpXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0tleXN0b3JlSnNvbiA9IGF3YWl0IHNpZ25lci5lbmNyeXB0KHBhc3N3b3JkKTtcclxuXHJcbiAgICAgICAgICAgIC8vIExheWVyIDI6IEFFUy1HQ00gd2l0aCBuZXcgaXRlcmF0aW9uIGNvdW50XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuY3J5cHRlZCA9IGF3YWl0IGVuY3J5cHRXaXRoQUVTKFxyXG4gICAgICAgICAgICAgIG5ld0tleXN0b3JlSnNvbixcclxuICAgICAgICAgICAgICBwYXNzd29yZCxcclxuICAgICAgICAgICAgICByZWNvbW1lbmRlZEl0ZXJhdGlvbnNcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB3YWxsZXQgKHJlbG9hZCB0byBnZXQgbGF0ZXN0IHN0YXRlKVxyXG4gICAgICAgICAgICBjb25zdCBsYXRlc3RXYWxsZXRzRGF0YSA9IGF3YWl0IGdldEFsbFdhbGxldHMoKTtcclxuICAgICAgICAgICAgY29uc3QgbGF0ZXN0V2FsbGV0ID0gbGF0ZXN0V2FsbGV0c0RhdGEud2FsbGV0TGlzdC5maW5kKHcgPT4gdy5pZCA9PT0gd2FsbGV0SWQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFsYXRlc3RXYWxsZXQpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgZm91bmQgZHVyaW5nIHVwZ3JhZGUnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGF0ZXN0V2FsbGV0LmVuY3J5cHRlZEtleXN0b3JlID0gbmV3RW5jcnlwdGVkO1xyXG4gICAgICAgICAgICBsYXRlc3RXYWxsZXQubGFzdFNlY3VyaXR5VXBncmFkZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGxhdGVzdFdhbGxldC5jdXJyZW50SXRlcmF0aW9ucyA9IHJlY29tbWVuZGVkSXRlcmF0aW9ucztcclxuICAgICAgICAgICAgYXdhaXQgc2F2ZShXQUxMRVRTX0tFWSwgbGF0ZXN0V2FsbGV0c0RhdGEpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdXBncmFkZVRpbWUgPSBEYXRlLm5vdygpIC0gdXBncmFkZVN0YXJ0O1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFdhbGxldCB1cGdyYWRlZCB0byAke3JlY29tbWVuZGVkSXRlcmF0aW9ucy50b0xvY2FsZVN0cmluZygpfSBpdGVyYXRpb25zICgke3VwZ3JhZGVUaW1lfW1zKWApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBpdGVyYXRpb25zQmVmb3JlLFxyXG4gICAgICAgICAgICAgIGl0ZXJhdGlvbnNBZnRlcjogcmVjb21tZW5kZWRJdGVyYXRpb25zXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0cmFja2luZ1xyXG4gICAgICAgICAgICBvbmdvaW5nVXBncmFkZXMuZGVsZXRlKHdhbGxldElkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICAvLyBUcmFjayB0aGUgb25nb2luZyB1cGdyYWRlXHJcbiAgICAgICAgb25nb2luZ1VwZ3JhZGVzLnNldCh3YWxsZXRJZCwgdXBncmFkZVByb21pc2UpO1xyXG5cclxuICAgICAgICAvLyBXYWl0IGZvciB1cGdyYWRlIHRvIGNvbXBsZXRlXHJcbiAgICAgICAgY29uc3QgdXBncmFkZVJlc3VsdCA9IGF3YWl0IHVwZ3JhZGVQcm9taXNlO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgYWRkcmVzczogc2lnbmVyLmFkZHJlc3MsXHJcbiAgICAgICAgICBzaWduZXI6IHNpZ25lcixcclxuICAgICAgICAgIHVwZ3JhZGVkOiB0cnVlLFxyXG4gICAgICAgICAgLi4udXBncmFkZVJlc3VsdFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhZGRyZXNzOiBzaWduZXIuYWRkcmVzcyxcclxuICAgICAgc2lnbmVyOiBzaWduZXIsXHJcbiAgICAgIHVwZ3JhZGVkOiBmYWxzZVxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2luY29ycmVjdCBwYXNzd29yZCcpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0RlY3J5cHRpb24gZmFpbGVkJykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgcGFzc3dvcmQnKTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVubG9jayB3YWxsZXQ6ICcgKyBlcnJvci5tZXNzYWdlKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHBvcnRzIHByaXZhdGUga2V5IGZvciB0aGUgYWN0aXZlIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEhleCBwcml2YXRlIGtleVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgcGFzc3dvcmQgaXMgaW5jb3JyZWN0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0UHJpdmF0ZUtleShwYXNzd29yZCkge1xyXG4gIC8vIFNraXAgdXBncmFkZSB3aGVuIGV4cG9ydGluZyAodXNlciBqdXN0IHdhbnRzIHRoZSBrZXkpXHJcbiAgY29uc3QgeyBzaWduZXIgfSA9IGF3YWl0IHVubG9ja1dhbGxldChwYXNzd29yZCwgeyBza2lwVXBncmFkZTogdHJ1ZSB9KTtcclxuICByZXR1cm4gc2lnbmVyLnByaXZhdGVLZXk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHBvcnRzIG1uZW1vbmljIGZvciB0aGUgYWN0aXZlIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ3xudWxsPn0gMTItd29yZCBtbmVtb25pYyBvciBudWxsIGlmIHdhbGxldCB3YXMgaW1wb3J0ZWQgZnJvbSBwcml2YXRlIGtleVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgcGFzc3dvcmQgaXMgaW5jb3JyZWN0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0TW5lbW9uaWMocGFzc3dvcmQpIHtcclxuICAvLyBTa2lwIHVwZ3JhZGUgd2hlbiBleHBvcnRpbmcgKHVzZXIganVzdCB3YW50cyB0aGUgbW5lbW9uaWMpXHJcbiAgY29uc3QgeyBzaWduZXIgfSA9IGF3YWl0IHVubG9ja1dhbGxldChwYXNzd29yZCwgeyBza2lwVXBncmFkZTogdHJ1ZSB9KTtcclxuICByZXR1cm4gc2lnbmVyLm1uZW1vbmljID8gc2lnbmVyLm1uZW1vbmljLnBocmFzZSA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHBvcnRzIHByaXZhdGUga2V5IGZvciBhIHNwZWNpZmljIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgLSBXYWxsZXQgSURcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVXNlciBwYXNzd29yZFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBIZXggcHJpdmF0ZSBrZXlcclxuICogQHRocm93cyB7RXJyb3J9IElmIHBhc3N3b3JkIGlzIGluY29ycmVjdCBvciB3YWxsZXQgbm90IGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0UHJpdmF0ZUtleUZvcldhbGxldCh3YWxsZXRJZCwgcGFzc3dvcmQpIHtcclxuICBjb25zdCB7IHNpZ25lciB9ID0gYXdhaXQgdW5sb2NrU3BlY2lmaWNXYWxsZXQod2FsbGV0SWQsIHBhc3N3b3JkLCB7IHNraXBVcGdyYWRlOiB0cnVlIH0pO1xyXG4gIHJldHVybiBzaWduZXIucHJpdmF0ZUtleTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4cG9ydHMgbW5lbW9uaWMgZm9yIGEgc3BlY2lmaWMgd2FsbGV0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCAtIFdhbGxldCBJRFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ3xudWxsPn0gMTItd29yZCBtbmVtb25pYyBvciBudWxsIGlmIG5vdCBhdmFpbGFibGVcclxuICogQHRocm93cyB7RXJyb3J9IElmIHBhc3N3b3JkIGlzIGluY29ycmVjdCBvciB3YWxsZXQgbm90IGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0TW5lbW9uaWNGb3JXYWxsZXQod2FsbGV0SWQsIHBhc3N3b3JkKSB7XHJcbiAgY29uc3QgeyBzaWduZXIgfSA9IGF3YWl0IHVubG9ja1NwZWNpZmljV2FsbGV0KHdhbGxldElkLCBwYXNzd29yZCwgeyBza2lwVXBncmFkZTogdHJ1ZSB9KTtcclxuICByZXR1cm4gc2lnbmVyLm1uZW1vbmljID8gc2lnbmVyLm1uZW1vbmljLnBocmFzZSA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHNlY3VyaXR5IGluZm9ybWF0aW9uIGZvciBhIHdhbGxldFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgLSBXYWxsZXQgSURcclxuICogQHJldHVybnMge1Byb21pc2U8e2N1cnJlbnRJdGVyYXRpb25zOiBudW1iZXIsIHJlY29tbWVuZGVkSXRlcmF0aW9uczogbnVtYmVyLCBuZWVkc1VwZ3JhZGU6IGJvb2xlYW4sIGxhc3RVcGdyYWRlOiBudW1iZXJ9Pn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRXYWxsZXRTZWN1cml0eUluZm8od2FsbGV0SWQpIHtcclxuICBjb25zdCB3YWxsZXRzRGF0YSA9IGF3YWl0IGdldEFsbFdhbGxldHMoKTtcclxuICBjb25zdCB3YWxsZXQgPSB3YWxsZXRzRGF0YS53YWxsZXRMaXN0LmZpbmQodyA9PiB3LmlkID09PSB3YWxsZXRJZCk7XHJcblxyXG4gIGlmICghd2FsbGV0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgZm91bmQnKTtcclxuICB9XHJcblxyXG4gIC8vIFVzZSBtZXRhZGF0YSBmaWVsZCBpZiBhdmFpbGFibGUgKG1vcmUgZWZmaWNpZW50KSwgb3RoZXJ3aXNlIHBhcnNlIGVuY3J5cHRlZCBkYXRhXHJcbiAgY29uc3QgY3VycmVudEl0ZXJhdGlvbnMgPSB3YWxsZXQuY3VycmVudEl0ZXJhdGlvbnMgfHwgZ2V0SXRlcmF0aW9uc0Zyb21FbmNyeXB0ZWQod2FsbGV0LmVuY3J5cHRlZEtleXN0b3JlKTtcclxuICBjb25zdCByZWNvbW1lbmRlZEl0ZXJhdGlvbnMgPSBnZXRDdXJyZW50UmVjb21tZW5kZWRJdGVyYXRpb25zKCk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBjdXJyZW50SXRlcmF0aW9ucyxcclxuICAgIHJlY29tbWVuZGVkSXRlcmF0aW9ucyxcclxuICAgIG5lZWRzVXBncmFkZTogY3VycmVudEl0ZXJhdGlvbnMgPCByZWNvbW1lbmRlZEl0ZXJhdGlvbnMsXHJcbiAgICBsYXN0VXBncmFkZTogd2FsbGV0Lmxhc3RTZWN1cml0eVVwZ3JhZGUgfHwgd2FsbGV0LmNyZWF0ZWRBdFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMRUdBQ1k6IENyZWF0ZXMgZmlyc3Qgd2FsbGV0IChmb3IgaW5pdGlhbCBzZXR1cCBjb21wYXRpYmlsaXR5KVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHthZGRyZXNzOiBzdHJpbmcsIG1uZW1vbmljOiBzdHJpbmd9Pn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVXYWxsZXQocGFzc3dvcmQpIHtcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZGRXYWxsZXQoJ2NyZWF0ZScsIHt9LCBwYXNzd29yZCwgJ01haW4gV2FsbGV0Jyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGFkZHJlc3M6IHJlc3VsdC5hZGRyZXNzLFxyXG4gICAgbW5lbW9uaWM6IHJlc3VsdC5tbmVtb25pY1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMRUdBQ1k6IEltcG9ydHMgZnJvbSBtbmVtb25pYyAoZm9yIGluaXRpYWwgc2V0dXAgY29tcGF0aWJpbGl0eSlcclxuICogQHBhcmFtIHtzdHJpbmd9IG1uZW1vbmljIC0gMTItd29yZCBzZWVkIHBocmFzZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBVc2VyIHBhc3N3b3JkXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHthZGRyZXNzOiBzdHJpbmd9Pn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRGcm9tTW5lbW9uaWMobW5lbW9uaWMsIHBhc3N3b3JkKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWRkV2FsbGV0KCdtbmVtb25pYycsIHsgbW5lbW9uaWMgfSwgcGFzc3dvcmQsICdNYWluIFdhbGxldCcpO1xyXG4gIHJldHVybiB7XHJcbiAgICBhZGRyZXNzOiByZXN1bHQuYWRkcmVzc1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMRUdBQ1k6IEltcG9ydHMgZnJvbSBwcml2YXRlIGtleSAoZm9yIGluaXRpYWwgc2V0dXAgY29tcGF0aWJpbGl0eSlcclxuICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXkgLSBIZXggcHJpdmF0ZSBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVXNlciBwYXNzd29yZFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7YWRkcmVzczogc3RyaW5nfT59XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0RnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSwgcGFzc3dvcmQpIHtcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZGRXYWxsZXQoJ3ByaXZhdGVrZXknLCB7IHByaXZhdGVLZXkgfSwgcGFzc3dvcmQsICdNYWluIFdhbGxldCcpO1xyXG4gIHJldHVybiB7XHJcbiAgICBhZGRyZXNzOiByZXN1bHQuYWRkcmVzc1xyXG4gIH07XHJcbn1cclxuIiwiLyoqXHJcbiAqIGNvcmUvcnBjLmpzXHJcbiAqXHJcbiAqIFJQQyBwcm92aWRlciBmb3IgYmxvY2tjaGFpbiBpbnRlcmFjdGlvbiB3aXRoIGF1dG9tYXRpYyBmYWlsb3ZlclxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XHJcblxyXG4vLyBOZXR3b3JrIFJQQyBlbmRwb2ludHMgLSBNdWx0aXBsZSBlbmRwb2ludHMgcGVyIG5ldHdvcmsgZm9yIHJlZHVuZGFuY3lcclxuY29uc3QgUlBDX0VORFBPSU5UUyA9IHtcclxuICAncHVsc2VjaGFpblRlc3RuZXQnOiBbXHJcbiAgICAnaHR0cHM6Ly9ycGMudjQudGVzdG5ldC5wdWxzZWNoYWluLmNvbScsXHJcbiAgICAnaHR0cHM6Ly9ycGMtdGVzdG5ldC1wdWxzZWNoYWluLmc0bW00LmlvJ1xyXG4gIF0sXHJcbiAgJ3B1bHNlY2hhaW4nOiBbXHJcbiAgICAnaHR0cHM6Ly9ycGMucHVsc2VjaGFpbi5jb20nLFxyXG4gICAgJ2h0dHBzOi8vcHVsc2VjaGFpbi1ycGMucHVibGljbm9kZS5jb20nLFxyXG4gICAgJ2h0dHBzOi8vcnBjLXB1bHNlY2hhaW4uZzRtbTQuaW8nLFxyXG4gICAgJ2h0dHBzOi8vcHVsc2VjaGFpbi5wdWJsaWNub2RlLmNvbSdcclxuICBdLFxyXG4gICdldGhlcmV1bSc6IFtcclxuICAgICdodHRwczovL2V0aC5sbGFtYXJwYy5jb20nLFxyXG4gICAgJ2h0dHBzOi8vZXRoZXJldW0ucHVibGljbm9kZS5jb20nLFxyXG4gICAgJ2h0dHBzOi8vcnBjLmFua3IuY29tL2V0aCcsXHJcbiAgICAnaHR0cHM6Ly9jbG91ZGZsYXJlLWV0aC5jb20nXHJcbiAgXSxcclxuICAnc2Vwb2xpYSc6IFtcclxuICAgICdodHRwczovL3JwYy5zZXBvbGlhLm9yZycsXHJcbiAgICAnaHR0cHM6Ly9ldGhlcmV1bS1zZXBvbGlhLnB1YmxpY25vZGUuY29tJyxcclxuICAgICdodHRwczovL3JwYy5hbmtyLmNvbS9ldGhfc2Vwb2xpYSdcclxuICBdXHJcbn07XHJcblxyXG4vLyBDYWNoZWQgcHJvdmlkZXJzIHBlciBuZXR3b3JrXHJcbmNvbnN0IHByb3ZpZGVycyA9IHt9O1xyXG5cclxuLy8gVHJhY2sgZmFpbGVkIGVuZHBvaW50cyB0byBhdm9pZCByZXBlYXRlZCBmYWlsdXJlc1xyXG5jb25zdCBlbmRwb2ludEhlYWx0aCA9IG5ldyBNYXAoKTsgLy8gZW5kcG9pbnQgLT4geyBmYWlsdXJlczogbnVtYmVyLCBsYXN0Q2hlY2s6IHRpbWVzdGFtcCwgYmxhY2tsaXN0ZWQ6IGJvb2xlYW4gfVxyXG5cclxuLy8gSGVhbHRoIGNoZWNrIGNvbmZpZ3VyYXRpb25cclxuY29uc3QgSEVBTFRIX0NPTkZJRyA9IHtcclxuICBNQVhfRkFJTFVSRVM6IDMsICAgICAgICAgICAgICAvLyBCbGFja2xpc3QgYWZ0ZXIgMyBmYWlsdXJlc1xyXG4gIEJMQUNLTElTVF9EVVJBVElPTjogMzAwMDAwLCAgIC8vIDUgbWludXRlcyBibGFja2xpc3RcclxuICBIRUFMVEhfQ0hFQ0tfVElNRU9VVDogNTAwMCwgICAvLyA1IHNlY29uZCB0aW1lb3V0IGZvciBoZWFsdGggY2hlY2tzXHJcbiAgUkVUUllfREVMQVk6IDEwMDAgICAgICAgICAgICAgLy8gMSBzZWNvbmQgZGVsYXkgYmV0d2VlbiBlbmRwb2ludCBhdHRlbXB0c1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlY29yZHMgYW4gZW5kcG9pbnQgZmFpbHVyZSBmb3IgaGVhbHRoIHRyYWNraW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIFJQQyBlbmRwb2ludCBVUkxcclxuICovXHJcbmZ1bmN0aW9uIHJlY29yZEVuZHBvaW50RmFpbHVyZShlbmRwb2ludCkge1xyXG4gIGNvbnN0IGhlYWx0aCA9IGVuZHBvaW50SGVhbHRoLmdldChlbmRwb2ludCkgfHwgeyBmYWlsdXJlczogMCwgbGFzdENoZWNrOiBEYXRlLm5vdygpLCBibGFja2xpc3RlZDogZmFsc2UgfTtcclxuICBoZWFsdGguZmFpbHVyZXMrKztcclxuICBoZWFsdGgubGFzdENoZWNrID0gRGF0ZS5ub3coKTtcclxuICBcclxuICBpZiAoaGVhbHRoLmZhaWx1cmVzID49IEhFQUxUSF9DT05GSUcuTUFYX0ZBSUxVUkVTKSB7XHJcbiAgICBoZWFsdGguYmxhY2tsaXN0ZWQgPSB0cnVlO1xyXG4gICAgY29uc29sZS53YXJuKGDwn6uAIFJQQyBlbmRwb2ludCBibGFja2xpc3RlZCBhZnRlciAke2hlYWx0aC5mYWlsdXJlc30gZmFpbHVyZXM6ICR7ZW5kcG9pbnR9YCk7XHJcbiAgICBcclxuICAgIC8vIEF1dG8tcmVjb3ZlciBhZnRlciBibGFja2xpc3QgZHVyYXRpb25cclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBjb25zdCBjdXJyZW50SGVhbHRoID0gZW5kcG9pbnRIZWFsdGguZ2V0KGVuZHBvaW50KTtcclxuICAgICAgaWYgKGN1cnJlbnRIZWFsdGgpIHtcclxuICAgICAgICBjdXJyZW50SGVhbHRoLmJsYWNrbGlzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgY3VycmVudEhlYWx0aC5mYWlsdXJlcyA9IDA7XHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfq4AgUlBDIGVuZHBvaW50IHJlY292ZXJlZCBmcm9tIGJsYWNrbGlzdDogJHtlbmRwb2ludH1gKTtcclxuICAgICAgfVxyXG4gICAgfSwgSEVBTFRIX0NPTkZJRy5CTEFDS0xJU1RfRFVSQVRJT04pO1xyXG4gIH1cclxuICBcclxuICBlbmRwb2ludEhlYWx0aC5zZXQoZW5kcG9pbnQsIGhlYWx0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWNvcmRzIGFuIGVuZHBvaW50IHN1Y2Nlc3MgZm9yIGhlYWx0aCB0cmFja2luZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnQgLSBSUEMgZW5kcG9pbnQgVVJMXHJcbiAqL1xyXG5mdW5jdGlvbiByZWNvcmRFbmRwb2ludFN1Y2Nlc3MoZW5kcG9pbnQpIHtcclxuICBjb25zdCBoZWFsdGggPSBlbmRwb2ludEhlYWx0aC5nZXQoZW5kcG9pbnQpIHx8IHsgZmFpbHVyZXM6IDAsIGxhc3RDaGVjazogRGF0ZS5ub3coKSwgYmxhY2tsaXN0ZWQ6IGZhbHNlIH07XHJcbiAgaGVhbHRoLmZhaWx1cmVzID0gTWF0aC5tYXgoMCwgaGVhbHRoLmZhaWx1cmVzIC0gMSk7IC8vIEdyYWR1YWxseSByZWR1Y2UgZmFpbHVyZSBjb3VudFxyXG4gIGhlYWx0aC5sYXN0Q2hlY2sgPSBEYXRlLm5vdygpO1xyXG4gIGVuZHBvaW50SGVhbHRoLnNldChlbmRwb2ludCwgaGVhbHRoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhbiBlbmRwb2ludCBpcyBibGFja2xpc3RlZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnQgLSBSUEMgZW5kcG9pbnQgVVJMXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNFbmRwb2ludEJsYWNrbGlzdGVkKGVuZHBvaW50KSB7XHJcbiAgY29uc3QgaGVhbHRoID0gZW5kcG9pbnRIZWFsdGguZ2V0KGVuZHBvaW50KTtcclxuICByZXR1cm4gaGVhbHRoPy5ibGFja2xpc3RlZCB8fCBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgaGVhbHRoIGNoZWNrIG9uIGFuIFJQQyBlbmRwb2ludFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnQgLSBSUEMgZW5kcG9pbnQgVVJMXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBUcnVlIGlmIGhlYWx0aHlcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNoZWNrRW5kcG9pbnRIZWFsdGgoZW5kcG9pbnQpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihlbmRwb2ludCk7XHJcbiAgICBcclxuICAgIC8vIFJhY2UgdGhlIGhlYWx0aCBjaGVjayBhZ2FpbnN0IHRpbWVvdXRcclxuICAgIGNvbnN0IGhlYWx0aENoZWNrUHJvbWlzZSA9IHByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IFxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0hlYWx0aCBjaGVjayB0aW1lb3V0JykpLCBIRUFMVEhfQ09ORklHLkhFQUxUSF9DSEVDS19USU1FT1VUKVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtoZWFsdGhDaGVja1Byb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgb3IgY3JlYXRlcyBhbiBSUEMgcHJvdmlkZXIgZm9yIGEgbmV0d29yayB3aXRoIGF1dG9tYXRpYyBmYWlsb3ZlclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5IChlLmcuLCAncHVsc2VjaGFpblRlc3RuZXQnKVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxldGhlcnMuSnNvblJwY1Byb3ZpZGVyPn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm92aWRlcihuZXR3b3JrKSB7XHJcbiAgY29uc3QgZW5kcG9pbnRzID0gUlBDX0VORFBPSU5UU1tuZXR3b3JrXTtcclxuICBcclxuICBpZiAoIWVuZHBvaW50cykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5ldHdvcms6ICR7bmV0d29ya31gKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gSWYgd2UgaGF2ZSBhIGNhY2hlZCB3b3JraW5nIHByb3ZpZGVyLCByZXR1cm4gaXRcclxuICBpZiAocHJvdmlkZXJzW25ldHdvcmtdKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBRdWljayBoZWFsdGggY2hlY2sgb24gY2FjaGVkIHByb3ZpZGVyXHJcbiAgICAgIGF3YWl0IHByb3ZpZGVyc1tuZXR3b3JrXS5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICByZXR1cm4gcHJvdmlkZXJzW25ldHdvcmtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGDwn6uAIENhY2hlZCBwcm92aWRlciBmYWlsZWQgZm9yICR7bmV0d29ya30sIHRyeWluZyBmYWlsb3Zlci4uLmApO1xyXG4gICAgICBkZWxldGUgcHJvdmlkZXJzW25ldHdvcmtdOyAvLyBDbGVhciBmYWlsZWQgcHJvdmlkZXJcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gVHJ5IGVhY2ggZW5kcG9pbnQgdW50aWwgb25lIHdvcmtzXHJcbiAgY29uc3QgZW5kcG9pbnRzTGlzdCA9IEFycmF5LmlzQXJyYXkoZW5kcG9pbnRzKSA/IGVuZHBvaW50cyA6IFtlbmRwb2ludHNdO1xyXG4gIFxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kcG9pbnRzTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgZW5kcG9pbnQgPSBlbmRwb2ludHNMaXN0W2ldO1xyXG4gICAgXHJcbiAgICAvLyBTa2lwIGJsYWNrbGlzdGVkIGVuZHBvaW50c1xyXG4gICAgaWYgKGlzRW5kcG9pbnRCbGFja2xpc3RlZChlbmRwb2ludCkpIHtcclxuICAgICAgY29uc29sZS53YXJuKGDwn6uAIFNraXBwaW5nIGJsYWNrbGlzdGVkIGVuZHBvaW50OiAke2VuZHBvaW50fWApO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYPCfq4AgVHJ5aW5nIFJQQyBlbmRwb2ludCAoJHtpICsgMX0vJHtlbmRwb2ludHNMaXN0Lmxlbmd0aH0pOiAke2VuZHBvaW50fWApO1xyXG4gICAgICBcclxuICAgICAgLy8gQ3JlYXRlIHByb3ZpZGVyIGFuZCB0ZXN0IGl0XHJcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoZW5kcG9pbnQpO1xyXG4gICAgICBcclxuICAgICAgLy8gVmVyaWZ5IGl0IHdvcmtzIHdpdGggYSBxdWljayBjYWxsXHJcbiAgICAgIGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdWNjZXNzISBDYWNoZSBhbmQgcmV0dXJuXHJcbiAgICAgIHByb3ZpZGVyc1tuZXR3b3JrXSA9IHByb3ZpZGVyO1xyXG4gICAgICByZWNvcmRFbmRwb2ludFN1Y2Nlc3MoZW5kcG9pbnQpO1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+rgCBDb25uZWN0ZWQgdG8gUlBDOiAke2VuZHBvaW50fWApO1xyXG4gICAgICByZXR1cm4gcHJvdmlkZXI7XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihg8J+rgCBSUEMgZW5kcG9pbnQgZmFpbGVkOiAke2VuZHBvaW50fWAsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICByZWNvcmRFbmRwb2ludEZhaWx1cmUoZW5kcG9pbnQpO1xyXG4gICAgICBcclxuICAgICAgLy8gQWRkIGRlbGF5IGJlZm9yZSB0cnlpbmcgbmV4dCBlbmRwb2ludCAoZXhjZXB0IG9uIGxhc3QgYXR0ZW1wdClcclxuICAgICAgaWYgKGkgPCBlbmRwb2ludHNMaXN0Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgSEVBTFRIX0NPTkZJRy5SRVRSWV9ERUxBWSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEFsbCBlbmRwb2ludHMgZmFpbGVkXHJcbiAgdGhyb3cgbmV3IEVycm9yKGBBbGwgUlBDIGVuZHBvaW50cyBmYWlsZWQgZm9yIG5ldHdvcms6ICR7bmV0d29ya30uIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uYCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMRUdBQ1k6IFN5bmNocm9ub3VzIHByb3ZpZGVyIGdldHRlciAoZGVwcmVjYXRlZCwgdXNlIGFzeW5jIGdldFByb3ZpZGVyIGluc3RlYWQpXHJcbiAqIEtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYnV0IG1heSBmYWlsIGlmIHByb3ZpZGVyIGlzbid0IGNhY2hlZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5XHJcbiAqIEByZXR1cm5zIHtldGhlcnMuSnNvblJwY1Byb3ZpZGVyfVxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgYXN5bmMgZ2V0UHJvdmlkZXIoKSBpbnN0ZWFkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvdmlkZXJTeW5jKG5ldHdvcmspIHtcclxuICBpZiAocHJvdmlkZXJzW25ldHdvcmtdKSB7XHJcbiAgICByZXR1cm4gcHJvdmlkZXJzW25ldHdvcmtdO1xyXG4gIH1cclxuICBcclxuICAvLyBGYWxsYmFjazogY3JlYXRlIHByb3ZpZGVyIHdpdGggZmlyc3QgZW5kcG9pbnQgKG5vIGhlYWx0aCBjaGVjaylcclxuICBjb25zdCBlbmRwb2ludHMgPSBSUENfRU5EUE9JTlRTW25ldHdvcmtdO1xyXG4gIGlmICghZW5kcG9pbnRzKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbmV0d29yazogJHtuZXR3b3JrfWApO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBlbmRwb2ludCA9IEFycmF5LmlzQXJyYXkoZW5kcG9pbnRzKSA/IGVuZHBvaW50c1swXSA6IGVuZHBvaW50cztcclxuICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKGVuZHBvaW50KTtcclxuICBwcm92aWRlcnNbbmV0d29ya10gPSBwcm92aWRlcjtcclxuICByZXR1cm4gcHJvdmlkZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYWtlcyBhIHJhdyBSUEMgY2FsbCB3aXRoIGF1dG9tYXRpYyBmYWlsb3ZlclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgLSBSUEMgbWV0aG9kIG5hbWVcclxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIC0gUlBDIHBhcmFtZXRlcnNcclxuICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gUlBDIHJlc3VsdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJwY0NhbGwobmV0d29yaywgbWV0aG9kLCBwYXJhbXMgPSBbXSkge1xyXG4gIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIobmV0d29yayk7XHJcbiAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBiYWxhbmNlIGZvciBhbiBhZGRyZXNzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBFdGhlcmV1bSBhZGRyZXNzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEJhbGFuY2UgaW4gd2VpIChoZXggc3RyaW5nKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJhbGFuY2UobmV0d29yaywgYWRkcmVzcykge1xyXG4gIHJldHVybiBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfZ2V0QmFsYW5jZScsIFthZGRyZXNzLCAnbGF0ZXN0J10pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0cmFuc2FjdGlvbiBjb3VudCAobm9uY2UpIGZvciBhbiBhZGRyZXNzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBFdGhlcmV1bSBhZGRyZXNzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRyYW5zYWN0aW9uIGNvdW50IChoZXggc3RyaW5nKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uQ291bnQobmV0d29yaywgYWRkcmVzcykge1xyXG4gIHJldHVybiBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCcsIFthZGRyZXNzLCAnbGF0ZXN0J10pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBjdXJyZW50IGdhcyBwcmljZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEdhcyBwcmljZSBpbiB3ZWkgKGhleCBzdHJpbmcpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0R2FzUHJpY2UobmV0d29yaykge1xyXG4gIHJldHVybiBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfZ2FzUHJpY2UnLCBbXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBjdXJyZW50IGJhc2UgZmVlIGZyb20gdGhlIGxhdGVzdCBibG9jayAoRUlQLTE1NTkpXHJcbiAqIFRoaXMgaXMgbW9yZSBhY2N1cmF0ZSB0aGFuIGV0aF9nYXNQcmljZSBmb3IgZGV0ZXJtaW5pbmcgbWluaW11bSByZXF1aXJlZCBnYXNcclxuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIGtleVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBCYXNlIGZlZSBwZXIgZ2FzIGluIHdlaSAoaGV4IHN0cmluZylcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCYXNlRmVlKG5ldHdvcmspIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfZ2V0QmxvY2tCeU51bWJlcicsIFsnbGF0ZXN0JywgZmFsc2VdKTtcclxuICAgIGlmIChsYXRlc3RCbG9jayAmJiBsYXRlc3RCbG9jay5iYXNlRmVlUGVyR2FzKSB7XHJcbiAgICAgIHJldHVybiBsYXRlc3RCbG9jay5iYXNlRmVlUGVyR2FzO1xyXG4gICAgfVxyXG4gICAgLy8gRmFsbGJhY2sgdG8gZXRoX2dhc1ByaWNlIGlmIGJsb2NrIGRvZXNuJ3QgaGF2ZSBiYXNlRmVlUGVyR2FzIChwcmUtRUlQLTE1NTkpXHJcbiAgICByZXR1cm4gYXdhaXQgcnBjQ2FsbChuZXR3b3JrLCAnZXRoX2dhc1ByaWNlJywgW10pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGdldHRpbmcgYmFzZSBmZWUsIGZhbGxpbmcgYmFjayB0byBldGhfZ2FzUHJpY2U6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJwY0NhbGwobmV0d29yaywgJ2V0aF9nYXNQcmljZScsIFtdKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIGEgc2FmZSBnYXMgcHJpY2UgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGFjY291bnRzIGZvciBiYXNlIGZlZSB2b2xhdGlsaXR5XHJcbiAqIFJldHVybnMgbWF4KGV0aF9nYXNQcmljZSwgYmFzZUZlZSAqIDIpIHRvIGVuc3VyZSB0cmFuc2FjdGlvbnMgZ2V0IG1pbmVkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayBrZXlcclxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gU2FmZSBnYXMgcHJpY2UgaW4gd2VpIChoZXggc3RyaW5nKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNhZmVHYXNQcmljZShuZXR3b3JrKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IFtnYXNQcmljZSwgYmFzZUZlZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgIHJwY0NhbGwobmV0d29yaywgJ2V0aF9nYXNQcmljZScsIFtdKSxcclxuICAgICAgZ2V0QmFzZUZlZShuZXR3b3JrKVxyXG4gICAgXSk7XHJcblxyXG4gICAgY29uc3QgZ2FzUHJpY2VXZWkgPSBCaWdJbnQoZ2FzUHJpY2UpO1xyXG4gICAgY29uc3QgYmFzZUZlZVdlaSA9IEJpZ0ludChiYXNlRmVlKTtcclxuXHJcbiAgICAvLyBVc2UgdGhlIGhpZ2hlciBvZjpcclxuICAgIC8vIDEuIGV0aF9nYXNQcmljZSBmcm9tIFJQQ1xyXG4gICAgLy8gMi4gYmFzZUZlZSAqIDIgKHRvIGFjY291bnQgZm9yIHZvbGF0aWxpdHkpXHJcbiAgICBjb25zdCBzYWZlR2FzUHJpY2UgPSBnYXNQcmljZVdlaSA+IChiYXNlRmVlV2VpICogMm4pID8gZ2FzUHJpY2VXZWkgOiAoYmFzZUZlZVdlaSAqIDJuKTtcclxuXHJcbiAgICByZXR1cm4gJzB4JyArIHNhZmVHYXNQcmljZS50b1N0cmluZygxNik7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybignRXJyb3IgZ2V0dGluZyBzYWZlIGdhcyBwcmljZSwgZmFsbGluZyBiYWNrIHRvIGV0aF9nYXNQcmljZTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gYXdhaXQgcnBjQ2FsbChuZXR3b3JrLCAnZXRoX2dhc1ByaWNlJywgW10pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgY3VycmVudCBibG9jayBudW1iZXJcclxuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIGtleVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBCbG9jayBudW1iZXIgKGhleCBzdHJpbmcpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QmxvY2tOdW1iZXIobmV0d29yaykge1xyXG4gIHJldHVybiBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfYmxvY2tOdW1iZXInLCBbXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIGEgYmxvY2sgYnkgbnVtYmVyXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrTnVtYmVyIC0gQmxvY2sgbnVtYmVyIChoZXggc3RyaW5nIG9yICdsYXRlc3QnLCAnZWFybGllc3QnLCAncGVuZGluZycpXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZVRyYW5zYWN0aW9ucyAtIFdoZXRoZXIgdG8gaW5jbHVkZSBmdWxsIHRyYW5zYWN0aW9uIG9iamVjdHMgKGRlZmF1bHQgZmFsc2UpXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEJsb2NrIG9iamVjdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJsb2NrQnlOdW1iZXIobmV0d29yaywgYmxvY2tOdW1iZXIsIGluY2x1ZGVUcmFuc2FjdGlvbnMgPSBmYWxzZSkge1xyXG4gIHJldHVybiBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfZ2V0QmxvY2tCeU51bWJlcicsIFtibG9ja051bWJlciwgaW5jbHVkZVRyYW5zYWN0aW9uc10pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyByZWNlbnQgdHJhbnNhY3Rpb25zIGZvciBhbiBhZGRyZXNzXHJcbiAqIE5PVEU6IFRoaXMgaXMgYSBwbGFjZWhvbGRlciB0aGF0IHJldHVybnMgZW1wdHkgYXJyYXkuXHJcbiAqIFNjYW5uaW5nIGJsb2NrcyB2aWEgUlBDIGlzIHRvbyBleHBlbnNpdmUgKHdvdWxkIG1ha2UgMTAwKyByZXF1ZXN0cykuXHJcbiAqIFByb3BlciB0cmFuc2FjdGlvbiBoaXN0b3J5IHJlcXVpcmVzIGFuIGluZGV4ZXIvYmxvY2sgZXhwbG9yZXIgQVBJLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gRXRoZXJldW0gYWRkcmVzc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBNYXhpbXVtIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgdG8gcmV0dXJuIChkZWZhdWx0IDMpXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja3NUb1NjYW4gLSBOdW1iZXIgb2YgcmVjZW50IGJsb2NrcyB0byBzY2FuIChkZWZhdWx0IDUwKVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IEFycmF5IG9mIHRyYW5zYWN0aW9uIG9iamVjdHNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWNlbnRUcmFuc2FjdGlvbnMobmV0d29yaywgYWRkcmVzcywgbGltaXQgPSAzLCBibG9ja3NUb1NjYW4gPSA1MCkge1xyXG4gIC8vIFRyYW5zYWN0aW9uIGhpc3RvcnkgZGlzYWJsZWQgdG8gYXZvaWQgZXhjZXNzaXZlIFJQQyBjYWxsc1xyXG4gIC8vIFdvdWxkIHJlcXVpcmUgc2Nhbm5pbmcgaHVuZHJlZHMvdGhvdXNhbmRzIG9mIGJsb2Nrc1xyXG4gIC8vIFVzZXJzIGNhbiB2aWV3IHRyYW5zYWN0aW9ucyBvbiBibG9jayBleHBsb3JlciBpbnN0ZWFkXHJcbiAgcmV0dXJuIFtdO1xyXG5cclxuICAvKiBPUklHSU5BTCBJTVBMRU1FTlRBVElPTiAtIERJU0FCTEVEIERVRSBUTyBFWENFU1NJVkUgUlBDIENBTExTXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIobmV0d29yayk7XHJcbiAgICBjb25zdCBjdXJyZW50QmxvY2sgPSBhd2FpdCBwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgY29uc3QgZnJvbUJsb2NrID0gTWF0aC5tYXgoMCwgY3VycmVudEJsb2NrIC0gYmxvY2tzVG9TY2FuKTtcclxuXHJcbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBbXTtcclxuICAgIGNvbnN0IGFkZHJlc3NMb3dlciA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAvLyBUaGlzIHdvdWxkIG1ha2UgYmxvY2tzVG9TY2FuIFJQQyByZXF1ZXN0cyFcclxuICAgIGZvciAobGV0IGkgPSBjdXJyZW50QmxvY2s7IGkgPj0gZnJvbUJsb2NrICYmIHRyYW5zYWN0aW9ucy5sZW5ndGggPCBsaW1pdDsgaS0tKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCBwcm92aWRlci5nZXRCbG9jayhpLCB0cnVlKTtcclxuICAgICAgICBpZiAoYmxvY2sgJiYgYmxvY2sudHJhbnNhY3Rpb25zKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IHR4IG9mIGJsb2NrLnRyYW5zYWN0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA+PSBsaW1pdCkgYnJlYWs7XHJcbiAgICAgICAgICAgIGlmICh0eC5mcm9tPy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzTG93ZXIgfHwgdHgudG8/LnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3NMb3dlcikge1xyXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGhhc2g6IHR4Lmhhc2gsXHJcbiAgICAgICAgICAgICAgICBmcm9tOiB0eC5mcm9tLFxyXG4gICAgICAgICAgICAgICAgdG86IHR4LnRvLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHR4LnZhbHVlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdHguYmxvY2tOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGJsb2NrLnRpbWVzdGFtcCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR4LmZyb20/LnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3NMb3dlciA/ICdzZW50JyA6ICdyZWNlaXZlZCdcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoYmxvY2tFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGxvYWRpbmcgYmxvY2sgJHtpfTpgLCBibG9ja0Vycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9ucztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVjZW50IHRyYW5zYWN0aW9uczonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gICovXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFc3RpbWF0ZXMgZ2FzIGZvciBhIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayBrZXlcclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEVzdGltYXRlZCBnYXMgKGhleCBzdHJpbmcpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXN0aW1hdGVHYXMobmV0d29yaywgdHJhbnNhY3Rpb24pIHtcclxuICByZXR1cm4gYXdhaXQgcnBjQ2FsbChuZXR3b3JrLCAnZXRoX2VzdGltYXRlR2FzJywgW3RyYW5zYWN0aW9uXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeGVjdXRlcyBhIGNhbGwgKHJlYWQtb25seSB0cmFuc2FjdGlvbilcclxuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIGtleVxyXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNhY3Rpb24gLSBUcmFuc2FjdGlvbiBvYmplY3RcclxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQ2FsbCByZXN1bHQgKGhleCBzdHJpbmcpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbChuZXR3b3JrLCB0cmFuc2FjdGlvbikge1xyXG4gIHJldHVybiBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfY2FsbCcsIFt0cmFuc2FjdGlvbiwgJ2xhdGVzdCddKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlbmRzIGEgc2lnbmVkIHJhdyB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWduZWRUeCAtIFNpZ25lZCB0cmFuc2FjdGlvbiAoaGV4IHN0cmluZylcclxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVHJhbnNhY3Rpb24gaGFzaFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRSYXdUcmFuc2FjdGlvbihuZXR3b3JrLCBzaWduZWRUeCkge1xyXG4gIHJldHVybiBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJywgW3NpZ25lZFR4XSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIGEgdHJhbnNhY3Rpb24gcmVjZWlwdFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsga2V5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggLSBUcmFuc2FjdGlvbiBoYXNoXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRyYW5zYWN0aW9uIHJlY2VpcHQgb2JqZWN0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KG5ldHdvcmssIHR4SGFzaCkge1xyXG4gIHJldHVybiBhd2FpdCBycGNDYWxsKG5ldHdvcmssICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JywgW3R4SGFzaF0pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBhIHRyYW5zYWN0aW9uIGJ5IGhhc2hcclxuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIGtleVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHhIYXNoIC0gVHJhbnNhY3Rpb24gaGFzaFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUcmFuc2FjdGlvbiBvYmplY3RcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkJ5SGFzaChuZXR3b3JrLCB0eEhhc2gpIHtcclxuICByZXR1cm4gYXdhaXQgcnBjQ2FsbChuZXR3b3JrLCAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJywgW3R4SGFzaF0pO1xyXG59XHJcblxyXG4vKipcclxuICogRm9ybWF0cyBiYWxhbmNlIGZyb20gd2VpIHRvIGh1bWFuLXJlYWRhYmxlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFsYW5jZVdlaSAtIEJhbGFuY2UgaW4gd2VpIChoZXggc3RyaW5nKVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbHMgLSBOdW1iZXIgb2YgZGVjaW1hbHMgdG8gc2hvdyAoZGVmYXVsdCA0KVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBGb3JtYXR0ZWQgYmFsYW5jZSAoZS5nLiwgXCIxLjIzNDVcIilcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCYWxhbmNlKGJhbGFuY2VXZWksIGRlY2ltYWxzID0gNCkge1xyXG4gIGNvbnN0IGJhbGFuY2UgPSBldGhlcnMuZm9ybWF0RXRoZXIoYmFsYW5jZVdlaSk7XHJcbiAgY29uc3QgbnVtID0gcGFyc2VGbG9hdChiYWxhbmNlKTtcclxuICByZXR1cm4gbnVtLnRvRml4ZWQoZGVjaW1hbHMpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBoZWFsdGggc3RhdHVzIG9mIGFsbCBSUEMgZW5kcG9pbnRzXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWx0aCBzdGF0dXMgcGVyIGVuZHBvaW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UlBDSGVhbHRoU3RhdHVzKCkge1xyXG4gIGNvbnN0IHN0YXR1cyA9IHt9O1xyXG4gIFxyXG4gIGZvciAoY29uc3QgW25ldHdvcmssIGVuZHBvaW50c10gb2YgT2JqZWN0LmVudHJpZXMoUlBDX0VORFBPSU5UUykpIHtcclxuICAgIHN0YXR1c1tuZXR3b3JrXSA9IFtdO1xyXG4gICAgY29uc3QgZW5kcG9pbnRzTGlzdCA9IEFycmF5LmlzQXJyYXkoZW5kcG9pbnRzKSA/IGVuZHBvaW50cyA6IFtlbmRwb2ludHNdO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIGVuZHBvaW50c0xpc3QpIHtcclxuICAgICAgY29uc3QgaGVhbHRoID0gZW5kcG9pbnRIZWFsdGguZ2V0KGVuZHBvaW50KSB8fCB7IGZhaWx1cmVzOiAwLCBsYXN0Q2hlY2s6IG51bGwsIGJsYWNrbGlzdGVkOiBmYWxzZSB9O1xyXG4gICAgICBzdGF0dXNbbmV0d29ya10ucHVzaCh7XHJcbiAgICAgICAgZW5kcG9pbnQsXHJcbiAgICAgICAgZmFpbHVyZXM6IGhlYWx0aC5mYWlsdXJlcyxcclxuICAgICAgICBibGFja2xpc3RlZDogaGVhbHRoLmJsYWNrbGlzdGVkLFxyXG4gICAgICAgIGxhc3RDaGVjazogaGVhbHRoLmxhc3RDaGVja1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHN0YXR1cztcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFycyB0aGUgcHJvdmlkZXIgY2FjaGUgKHVzZWZ1bCBmb3IgZm9yY2luZyByZWNvbm5lY3Rpb24pXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayB0byBjbGVhciwgb3IgbnVsbCBmb3IgYWxsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJQcm92aWRlckNhY2hlKG5ldHdvcmsgPSBudWxsKSB7XHJcbiAgaWYgKG5ldHdvcmspIHtcclxuICAgIGRlbGV0ZSBwcm92aWRlcnNbbmV0d29ya107XHJcbiAgICBjb25zb2xlLmxvZyhg8J+rgCBDbGVhcmVkIHByb3ZpZGVyIGNhY2hlIGZvcjogJHtuZXR3b3JrfWApO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBPYmplY3Qua2V5cyhwcm92aWRlcnMpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBwcm92aWRlcnNba2V5XSk7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+rgCBDbGVhcmVkIGFsbCBwcm92aWRlciBjYWNoZXNgKTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbImNvcHkiLCJieXRlcyIsIkJOXzAiLCJCTl8xIiwibWFzayIsIk5pYmJsZXMiLCJvdXRwdXQiLCJpbml0IiwibG9ja2VkIiwiZ2V0VGltZSIsInJlc3BvbnNlIiwiZGVsYXkiLCJzdGFsbCIsIl9ndWFyZCIsIlplcm9zIiwic2lnbmVkIiwiYiIsIm9mZnNldCIsIm9iamVjdCIsImxlbmd0aCIsInBhcnNlVW5pdHMiLCJyYW5kb21CeXRlcyIsInBhc3NQcm9wZXJ0aWVzIiwibmFtZXMiLCJhcmdzIiwiZ2V0VmFsdWUiLCJuIiwiaGFzaCIsImNyeXB0byIsInU4YSIsInV0ZjhUb0J5dGVzIiwiY29uY2F0Qnl0ZXMiLCJhc3NlcnRIYXNoIiwiYXNzZXJ0RXhpc3RzIiwiYXNzZXJ0Qnl0ZXMiLCJhc3NlcnROdW1iZXIiLCJwYmtkZjIiLCJpc0xFIiwiXzMybiIsIlQxIiwiVDIiLCJzaGEyNTYiLCJzcGxpdCIsInNoYTUxMiIsIl8wbiIsIl8xbiIsIl8ybiIsInJvdGwiLCJyaXBlbWQxNjAiLCJub2JsZV9yaXBlbWQxNjAiLCJjcnlwdG9fcmFuZG9tIiwiTiIsInNjcnlwdCIsIlBpIiwiX25vYmxlQXN5bmMiLCJfbm9ibGVTeW5jIiwiSCIsImdlbiIsIl8zbiIsIm51bWJlciIsIlMiLCJGcCIsIm4yIiwiZiIsImJpdExlbiIsIndpbmRvdyIsInV0LnZhbGlkYXRlT2JqZWN0IiwicyIsInRvQnl0ZXMiLCJ1dC5jb25jYXRCeXRlcyIsInV0LmJ5dGVzVG9IZXgiLCJ1dC5ieXRlc1RvTnVtYmVyQkUiLCJtb2QubW9kIiwiVTEiLCJVMiIsImEiLCJtb2QuaW52ZXJ0IiwidXQubnVtYmVyVG9CeXRlc0JFIiwiU2lnbmF0dXJlIiwidXQuaGV4VG9CeXRlcyIsIm1vZC5nZXRNaW5IYXNoTGVuZ3RoIiwibW9kLm1hcEhhc2hUb0ZpZWxkIiwidXQuYml0TWFzayIsInV0LmNyZWF0ZUhtYWNEcmJnIiwiciIsIkJOXzIiLCJCTl8yNyIsIkJOXzI4IiwiQk5fMzUiLCJ2IiwiY2hlY2tzdW0iLCJCTl9NQVhfVUlOVDI1NiIsInZlcnNpb24iLCJkZWNvZGUiLCJhZGQiLCJWIiwiZyIsImRlY29tcG9zZWQiLCJuYW1lIiwidHlwZSIsInZhbHVlIiwidGhyb3dFcnJvciIsImludGVybmFsIiwicmVzdWx0IiwiaW5kZXhlZCIsImlucHV0cyIsIlBhbmljUmVhc29ucyIsImJsb2NrTnVtYmVyIiwicmVjZWlwdCIsImdldFByb3ZpZGVyIiwiZXN0aW1hdGVHYXMiLCJmcmFnbWVudCIsInQiLCJsaXN0ZW5lciIsImFkZHIiLCJ0YXJnZXQiLCJjb2RlIiwiZGF0YSIsImVycm9yIiwiYWxsb3dOdWxsIiwiZGVmYXVsdE9wdGlvbnMiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwiYWRkcmVzcyIsImZpbHRlciIsInR4IiwiZnJvbSIsInBheWxvYWQiLCJpZCIsImFjY291bnRzIiwid29yZHMiLCJ3b3JkbGlzdCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwiaSIsInpwYWQiLCJkZWZhdWx0UGF0aCIsInNhbHQiLCJka0xlbiIsImtleSIsIndhbGxldCIsImV0aGVycy5pc0FkZHJlc3MiLCJldGhlcnMuTW5lbW9uaWMiLCJldGhlcnMuV2FsbGV0IiwiZXRoZXJzLkpzb25ScGNQcm92aWRlciIsImV0aGVycy5mb3JtYXRFdGhlciJdLCJtYXBwaW5ncyI6IkFBSVksTUFBQyxVQUFVO0FDQ3ZCLFNBQVMsVUFBVSxPQUFPLE1BQU0sTUFBTTtBQUNsQyxRQUFNLFFBQVEsS0FBSyxNQUFNLEdBQUcsRUFBRSxJQUFJLE9BQUssRUFBRSxNQUFNO0FBQy9DLFdBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFDbkMsWUFBUSxNQUFJO0FBQUEsTUFDUixLQUFLO0FBQ0Q7QUFBQSxNQUNKLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFB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TyxNQUFNLENBQUM7QUFFbEUsTUFBTSxRQUFRLENBQUMsR0FBRyxJQUFJLE1BQU0sTUFBTTtBQUNsQyxNQUFNLFFBQVEsQ0FBQyxHQUFHLEdBQUcsTUFBTyxLQUFNLEtBQUssSUFBTyxNQUFNO0FBRXBELE1BQU0sU0FBUyxDQUFDLEdBQUcsR0FBRyxNQUFPLE1BQU0sSUFBTSxLQUFNLEtBQUs7QUFDcEQsTUFBTSxTQUFTLENBQUMsR0FBRyxHQUFHLE1BQU8sS0FBTSxLQUFLLElBQU8sTUFBTTtBQUVyRCxNQUFNLFNBQVMsQ0FBQyxHQUFHLEdBQUcsTUFBTyxLQUFNLEtBQUssSUFBTyxNQUFPLElBQUk7QUFDMUQsTUFBTSxTQUFTLENBQUMsR0FBRyxHQUFHLE1BQU8sTUFBTyxJQUFJLEtBQVEsS0FBTSxLQUFLO0FBRTNELE1BQU0sVUFBVSxDQUFDLElBQUksTUFBTTtBQUMzQixNQUFNLFVBQVUsQ0FBQyxHQUFHLE9BQU87QUFFM0IsTUFBTSxTQUFTLENBQUMsR0FBRyxHQUFHLE1BQU8sS0FBSyxJQUFNLE1BQU8sS0FBSztBQUNwRCxNQUFNLFNBQVMsQ0FBQyxHQUFHLEdBQUcsTUFBTyxLQUFLLElBQU0sTUFBTyxLQUFLO0FBRXBELE1BQU0sU0FBUyxDQUFDLEdBQUcsR0FBRyxNQUFPLEtBQU0sSUFBSSxLQUFRLE1BQU8sS0FBSztBQUMzRCxNQUFNLFNBQVMsQ0FBQyxHQUFHLEdBQUcsTUFBTyxLQUFNLElBQUksS0FBUSxNQUFPLEtBQUs7QUFHM0QsU0FBUyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFDekIsUUFBTSxLQUFLLE9BQU8sTUFBTSxPQUFPO0FBQy9CLFNBQU8sRUFBRSxHQUFJLEtBQUssTUFBTyxJQUFJLEtBQUssS0FBTSxLQUFNLEdBQUcsR0FBRyxJQUFJLEVBQUM7QUFDN0Q7QUFFQSxNQUFNLFFBQVEsQ0FBQyxJQUFJLElBQUksUUFBUSxPQUFPLE1BQU0sT0FBTyxNQUFNLE9BQU87QUFDaEUsTUFBTSxRQUFRLENBQUMsS0FBSyxJQUFJLElBQUksT0FBUSxLQUFLLEtBQUssTUFBTyxN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Q3ZCLFNBQUssS0FBSyxhQUFhO0FBQ3ZCLFNBQUssS0FBSyxhQUFhO0FBQ3ZCLFNBQUssS0FBSyxhQUFhO0FBQ3ZCLFNBQUssS0FBSyxhQUFhO0FBQ3ZCLFNBQUssS0FBSyxhQUFhO0FBQ3ZCLFNBQUssS0FBSyxhQUFhO0FBQ3ZCLFNBQUssS0FBSyxhQUFhO0FBQ3ZCLFNBQUssS0FBSyxhQUFhO0FBQ3ZCLFNBQUssS0FBSyxZQUFhO0FBQ3ZCLFNBQUssS0FBSyxZQUFhO0FBQ3ZCLFNBQUssS0FBSyxhQUFhO0FBQ3ZCLFNBQUssS0FBSyxhQUFhO0FBQ3ZCLFNBQUssS0FBSyxZQUFhO0FBQUEsRUFDM0I7QUFBQTtBQUFBLEVBRUEsTUFBTTtBQUNGLFVBQU0sRUFBRSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxHQUFFLElBQUs7QUFDM0UsV0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7QUFBQSxFQUMxRTtBQUFBO0FBQUEsRUFFQSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFDaEUsU0FBSyxLQUFLLEtBQUs7QUFDZixTQUFLLEtBQUssS0FBSztBQUNmLFNBQUssS0FBSyxLQUFLO0FBQ2YsU0FBSyxLQUFLLEtBQUs7QUFDZixTQUFLLEtBQUssS0FBSztBQUNmLFNBQUssS0FBSyxLQUFLO0FBQ2YsU0FBSyxLQUFLLEtBQUs7QUFDZixTQUFLLEtBQUssS0FBSztBQUNmLFNBQUssS0FBSyxLQUFLO0FBQ2YsU0FBSyxLQUFLLEtBQUs7QUFDZixTQUFLLEtBQUssS0FBSztBQUNmLFNBQUssS0FBSyxLQUFLO0FBQ2YsU0FBSyxLQUFLLEtBQUs7QUFDZixTQUFLLEtBQUssS0FBSztBQUNmLFNBQUss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QVEsS0FBSyxLQUFPLEtBQUssS0FBTyxLQUFLO0FBQzNDLFlBQU0sT0FBUSxLQUFLLEtBQU8sS0FBSyxLQUFPLEtBQUs7QUFDM0MsV0FBSyxLQUFLO0FBQ1YsV0FBSyxLQUFLO0FBQ1YsV0FBSyxLQUFLO0FBQ1YsV0FBSyxLQUFLO0FBQ1YsV0FBSyxLQUFLO0FBQ1YsV0FBSyxLQUFLO0FBQ1YsT0FBQyxFQUFFLEdBQUcsSUFBSSxHQUFHLEdBQUUsSUFBSyxJQUFJLElBQUksS0FBSyxHQUFHLEtBQUssR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQzVELFdBQUssS0FBSztBQUNWLFdBQUssS0FBSztBQUNWLFdBQUssS0FBSztBQUNWLFdBQUssS0FBSztBQUNWLFdBQUssS0FBSztBQUNWLFdBQUssS0FBSztBQUNWLFlBQU0sTUFBTSxJQUFJLE1BQU0sS0FBSyxTQUFTLElBQUk7QUFDeEMsV0FBSyxJQUFJLE1BQU0sS0FBSyxLQUFLLFNBQVMsSUFBSTtBQUN0QyxXQUFLLE1BQU07QUFBQSxJQUNmO0FBRUEsS0FBQyxFQUFFLEdBQUcsSUFBSSxHQUFHLE9BQU8sSUFBSSxJQUFJLEtBQUssS0FBSyxHQUFHLEtBQUssS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDcEUsS0FBQyxFQUFFLEdBQUcsSUFBSSxHQUFHLE9BQU8sSUFBSSxJQUFJLEtBQUssS0FBSyxHQUFHLEtBQUssS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDcEUsS0FBQyxFQUFFLEdBQUcsSUFBSSxHQUFHLE9BQU8sSUFBSSxJQUFJLEtBQUssS0FBSyxHQUFHLEtBQUssS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDcEUsS0FBQyxFQUFFLEdBQUcsSUFBSSxHQUFHLE9BQU8sSUFBSSxJQUFJLEtBQUssS0FBSyxHQUFHLEtBQUssS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDcEUsS0FBQyxFQUFFLEdBQUcsSUFBSSxHQUFHLE9BQU8sSUFBSSxJQUFJLEtBQUssS0FBSyxHQUFHLEtBQUssS0FB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QUFNLElBQUksR0FBRyxNQUFNLEtBQUssSUFBSSxJQUFJLE1BQU0sSUFBSTtBQUNqRSxNQUFJLE1BQU0sS0FBSyxJQUFJLElBQUksTUFBTSxJQUFJLEdBQUcsTUFBTSxLQUFLLElBQUksSUFBSSxNQUFNLElBQUk7QUFDakUsTUFBSSxNQUFNLEtBQUssSUFBSSxJQUFJLE1BQU0sSUFBSSxHQUFHLE1BQU0sS0FBSyxJQUFJLElBQUksTUFBTSxJQUFJO0FBQ2pFLE1BQUksTUFBTSxLQUFLLElBQUksSUFBSSxNQUFNLElBQUksR0FBRyxNQUFNLEtBQUssSUFBSSxJQUFJLE1BQU0sSUFBSTtBQUNqRSxNQUFJLE1BQU0sS0FBSyxJQUFJLElBQUksTUFBTSxJQUFJLEdBQUcsTUFBTSxLQUFLLElBQUksSUFBSSxNQUFNLElBQUk7QUFFakUsTUFBSSxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNO0FBRS9LLFdBQVMsSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLLEdBQUc7QUFDM0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDNUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFDN0IsV0FBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLEVBQUU7QUFBQSxFQUNqQztBQUVBLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUMxQixNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDMUIsTUFBSSxJQUFJLElBQUss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QUksS0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUN0QixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFVBQUksS0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUN0QixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLEdBQUcsRUFBRTtBQUNqQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxHQUFHLEVBQUU7QUFDakIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLEdBQUcsRUFBRTtBQUNqQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixhQUFPLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtBQUFBLElBQy9CO0FBQUEsSUFDQSxTQUFTLE9BQU87QUFDWixhQUFPLEtBQUssSUFBSSxNQUFNLE9BQU0sQ0FBRTtBQUFBLElBQ2xDO0FBQUEsSUFDQSxNQUFNO0FBQ0YsYUFBTyxLQUFLLE9BQU8sTUFBTSxJQUFJO0FBQUEsSUFDakM7QUFBQSxJQUNBLEtBQUtuQyxJQUFHO0FBQ0osYUFBTyxLQUFLLFdBQVcsTUFBTSxrQkFBa0JBLElBQUcsQ0FBQyxTQUFTO0FBQ3hELGNBQU0sUUFBUW1DLElBQUcsWUFBWSxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDO0FBQ2xELGVBQU8sS0FBSyxJQUFJLENBQUMsR0FBRyxNQUFNLEVBQUUsU0FBUyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxNQUFNLFVBQVU7QUFBQSxNQUN4RSxDQUFDO0FBQUEsSUFDTDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQU1BLGVBQWVuQyxJQUFHO0FBQ2QsWUFBTSxJQUFJLE1BQU07QUFDaEIsVUFBSUEsT0FBTTtBQUNOLGVBQU87QUFDWCxlQUFTQSxFQUFDO0FBQ1YsVUFBSUEsT0FBTW1CO0FBQ04sZUFBTztBQUNYLFlBQU0sRUFBRSxLQUFJLElBQUs7QUFDakIsVUFBSSxDQUFDO0FBQ0QsZUFBTyxLQUFLLGFBQWEsTUFBTW5CLEVBQUM7QUFFcEMsVUFBSSxFQUFFLE9BQU8sSUFBSSxPQUFPLEdBQUUsSUFBSyxLQUFLLFlBQVlBLEVBQUM7QUFDakQsVUFBSSxNQUFNO0FBQ1YsVUFBSSxNQUFNO0FBQ1YsVUFBSSxJQUFJO0FBQ1IsYUFBTyxLQUFLLE9BQU8sS0FBSyxLQUFLO0FBQ3pCLFlBQUksS0FBS21CO0FBQ0wsZ0JBQU0sSUFBSSxJQUFJLENBQUM7QUFDbkIsWUFBSSxLQUFLQTtBQUNMLGdCQUFNLElBQUksSUFBSSxDQUFDO0FBQ25CLFlBQUksRUFBRSxPQUFNO0FBQ1osZUFBT0E7QUFDUCxlQUFPQTtBQUFBQSxNQUNYO0FBQ0EsVUFBSTtBQUNBLGNBQU0sSUFBSSxPQUFNO0FBQ3BCLFVBQUk7QUFDQSxjQUFNLElBQUksT0FBTTtBQUNwQixZQUFNLElBQUksTUFBTWdCLElBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLElBQUksRUFBRTtBQUN6RCxhQUFPLElBQUksSUFBSSxHQUFHO0FBQUEsSUFDdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQVVBLFNBQVMsUUFBUTtBQUNiLGVBQVMsTUFBTTtBQUNmLFVBQUluQyxLQUFJO0FBQ1IsVUFBSSxPQUFPO0FBQ1gsWUFBTSxFQUFFLEtBQUksSUFBSztBQUNqQixVQUFJLE1BQU07QUFDTixjQUFNLEVBQUUsT0FBTyxJQUFJLE9BQU8sR0FBRSxJQUFLLEtBQUssWUFBWUEsRUFBQztBQUNuRCxZQUFJLEVBQUUsR0FBRyxLQUFLLEdBQUcsSUFBRyxJQUFLLEtBQUssS0FBSyxFQUFFO0FBQ3JDLFlBQUksRUFBRSxHQUFHLEtBQUssR0FBRyxJQUFHLElBQUssS0FBSyxLQUFLLEVBQUU7QUFDckMsY0FBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsY0FBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsY0FBTSxJQUFJLE1BQU1tQyxJQUFHLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLEVBQUU7QUFDekQsZ0JBQVEsSUFBSSxJQUFJLEdBQUc7QUFDbkIsZUFBTyxJQUFJLElBQUksR0FBRztBQUFBLE1BQ3RCLE9BQ0s7QUFDRCxjQUFNLEVBQUUsR0FBRyxHQUFBRSxHQUFDLElBQUssS0FBSyxLQUFLckMsRUFBQztBQUM1QixnQkFBUTtBQUNSLGVBQU9xQztBQUFBLE1BQ1g7QUFFQSxhQUFPLE1BQU0sV0FBVyxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUFBLElBQzVDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFPQSxxQkFBcUIsR0FBRyxHQUFHL0MsSUFBRztBQUMxQixZQUFNLElBQUksTUFBTTtBQUNoQixZQUFNLE1BQU0sQ0FBQyxHQUFHMkQsT0FDVkEsT0FBTSxPQUFPQSxPQUFNOUIsU0FBTyxDQUFDLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxlQUFlOEIsRUFBQyxJQUFJLEVBQUUsU0FBU0EsRUFBQztBQUNqRixZQUFNLE1BQU0sSUFBSSxNQUFNLENBQUMsRUFBRSxJQUFJLElBQUksR0FBRzNELEVBQUMsQ0FBQztBQUN0QyxhQUFPLElBQUksUUFBUSxTQUFZO0FBQUEsSUFDbkM7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUlBLFNBQVMsSUFBSTtBQUNULFlBQU0sRUFBRSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksRUFBQyxJQUFLO0FBQ2hDLFlBQU0sTUFBTSxLQUFLLElBQUc7QUFHcEIsVUFBSSxNQUFNO0FBQ04sYUFBSyxNQUFNNkMsSUFBRyxNQUFNQSxJQUFHLElBQUksQ0FBQztBQUNoQyxZQUFNLEtBQUtBLElBQUcsSUFBSSxHQUFHLEVBQUU7QUFDdkIsWUFBTSxLQUFLQSxJQUFHLElBQUksR0FBRyxFQUFFO0FBQ3ZCLFlBQU0sS0FBS0EsSUFBRyxJQUFJLEdBQUcsRUFBRTtBQUN2QixVQUFJO0FBQ0EsZUFBTyxFQUFFLEdBQUdBLElBQUcsTUFBTSxHQUFHQSxJQUFHLEtBQUk7QUFDbkMsVUFBSSxDQUFDQSxJQUFHLElBQUksSUFBSUEsSUFBRyxHQUFHO0FBQ2xCLGNBQU0sSUFBSSxNQUFNLGtCQUFrQjtBQUN0QyxhQUFPLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRTtBQUFBLElBQ3pCO0FBQUEsSUFDQSxnQkFBZ0I7QUFDWixZQUFNLEVBQUUsR0FBRyxVQUFVLGNBQWEsSUFBSztBQUN2QyxVQUFJLGFBQWFoQjtBQUNiLGVBQU87QUFDWCxVQUFJO0FBQ0EsZUFBTyxjQUFjLE9BQU8sSUFBSTtBQUNwQyxZQUFNLElBQUksTUFBTSw4REFBOEQ7QUFBQSxJQUNsRjtBQUFBLElBQ0EsZ0JBQWdCO0FBQ1osWUFBTSxFQUFFLEdBQUcsVUFBVSxjQUFhLElBQUs7QUFDdkMsVUFBSSxhQUFhQTtBQUNiLGVBQU87QUFDWCxVQUFJO0FBQ0EsZUFBTyxjQUFjLE9BQU8sSUFBSTtBQUNwQyxhQUFPLEtBQUssZUFBZSxNQUFNLENBQUM7QUFBQSxJQUN0QztBQUFBLElBQ0EsV0FBVyxlQUFlLE1BQU07QUFDNUIsV0FBSyxlQUFjO0FBQ25CLGFBQU91QixTQUFRLE9BQU8sTUFBTSxZQUFZO0FBQUEsSUFDNUM7QUFBQSxJQUNBLE1BQU0sZUFBZSxNQUFNO0FBQ3ZCLGFBQU9FLFdBQWMsS0FBSyxXQUFXLFlBQVksQ0FBQztBQUFBLElBQ3REO0FBQUEsRUFDUjtBQUNJLFFBQU0sT0FBTyxJQUFJLE1BQU0sTUFBTSxJQUFJLE1BQU0sSUFBSVQsSUFBRyxHQUFHO0FBQ2pELFFBQU0sT0FBTyxJQUFJLE1BQU1BLElBQUcsTUFBTUEsSUFBRyxLQUFLQSxJQUFHLElBQUk7QUFDL0MsUUFBTSxRQUFRLE1BQU07QUFDcEIsUUFBTSxPQUFPLEtBQUssT0FBTyxNQUFNLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxJQUFJLEtBQUs7QUFFbEUsU0FBTztBQUFBLElBQ0g7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNSO0FBQ0E7QUFDQSxTQUFTLGFBQWEsT0FBTztBQUN6QixRQUFNLE9BQU8sY0FBYyxLQUFLO0FBQ2hDSyxpQkFBa0IsTUFBTTtBQUFBLElBQ3BCLE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNyQixHQUFPO0FBQUEsSUFDQyxVQUFVO0FBQUEsSUFDVixlQUFlO0FBQUEsSUFDZixNQUFNO0FBQUEsRUFDZCxDQUFLO0FBQ0QsU0FBTyxPQUFPLE9BQU8sRUFBRSxNQUFNLE1BQU0sR0FBRyxNQUFNO0FBQ2hEO0FBQ08sU0FBUyxZQUFZLFVBQVU7QUFDbEMsUUFBTSxRQUFRLGFBQWEsUUFBUTtBQUNuQyxRQUFNLEVBQUUsSUFBQUwsS0FBSSxHQUFHLFlBQVcsSUFBSztBQUMvQixRQUFNLGdCQUFnQkEsSUFBRyxRQUFRO0FBQ2pDLFFBQU0sa0JBQWtCLElBQUlBLElBQUcsUUFBUTtBQUN2QyxXQUFTLG9CQUFvQixLQUFLO0FBQzlCLFdBQU8sTUFBTSxPQUFPLE1BQU1BLElBQUc7QUFBQSxFQUNqQztBQUNBLFdBQVMsS0FBSyxHQUFHO0FBQ2IsV0FBT1csSUFBUSxHQUFHLFdBQVc7QUFBQSxFQUNqQztBQUNBLFdBQVMsS0FBSyxHQUFHO0FBQ2IsV0FBT0ksT0FBVyxHQUFHLFdBQVc7QUFBQSxFQUNwQztBQUNBLFFBQU0sRUFBRSxpQkFBaUIsT0FBTyx3QkFBd0IscUJBQXFCLG1CQUFrQixJQUFNLGtCQUFrQjtBQUFBLElBQ25ILEdBQUc7QUFBQSxJQUNILFFBQVEsSUFBSSxPQUFPLGNBQWM7QUFDN0IsWUFBTSxJQUFJLE1BQU0sU0FBUTtBQUN4QixZQUFNLElBQUlmLElBQUcsUUFBUSxFQUFFLENBQUM7QUFDeEIsWUFBTSxNQUFNUTtBQUNaLFVBQUksY0FBYztBQUNkLGVBQU8sSUFBSSxXQUFXLEtBQUssQ0FBQyxNQUFNLFNBQVEsSUFBSyxJQUFPLENBQUksQ0FBQyxHQUFHLENBQUM7QUFBQSxNQUNuRSxPQUNLO0FBQ0QsZUFBTyxJQUFJLFdBQVcsS0FBSyxDQUFDLENBQUksQ0FBQyxHQUFHLEdBQUdSLElBQUcsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUFBLE1BQzFEO0FBQUEsSUFDSjtBQUFBLElBQ0EsVUFBVTVELFFBQU87QUFDYixZQUFNLE1BQU1BLE9BQU07QUFDbEIsWUFBTSxPQUFPQSxPQUFNLENBQUM7QUFDcEIsWUFBTSxPQUFPQSxPQUFNLFNBQVMsQ0FBQztBQUU3QixVQUFJLFFBQVEsa0JBQWtCLFNBQVMsS0FBUSxTQUFTLElBQU87QUFDM0QsY0FBTSxJQUFJc0UsZ0JBQW1CLElBQUk7QUFDakMsWUFBSSxDQUFDLG9CQUFvQixDQUFDO0FBQ3RCLGdCQUFNLElBQUksTUFBTSx1QkFBdUI7QUFDM0MsY0FBTSxLQUFLLG9CQUFvQixDQUFDO0FBQ2hDLFlBQUksSUFBSVYsSUFBRyxLQUFLLEVBQUU7QUFDbEIsY0FBTSxVQUFVLElBQUloQixXQUFTQTtBQUU3QixjQUFNLGFBQWEsT0FBTyxPQUFPO0FBQ2pDLFlBQUksY0FBYztBQUNkLGNBQUlnQixJQUFHLElBQUksQ0FBQztBQUNoQixlQUFPLEVBQUUsR0FBRyxFQUFDO0FBQUEsTUFDakIsV0FDUyxRQUFRLG1CQUFtQixTQUFTLEdBQU07QUFDL0MsY0FBTSxJQUFJQSxJQUFHLFVBQVUsS0FBSyxTQUFTLEdBQUdBLElBQUcsS0FBSyxDQUFDO0FBQ2pELGNBQU0sSUFBSUEsSUFBRyxVQUFVLEtBQUssU0FBU0EsSUFBRyxPQUFPLElBQUlBLElBQUcsS0FBSyxDQUFDO0FBQzVELGVBQU8sRUFBRSxHQUFHLEVBQUM7QUFBQSxNQUNqQixPQUNLO0FBQ0QsY0FBTSxJQUFJLE1BQU0sbUJBQW1CLEdBQUcsMEJBQTBCLGFBQWEsd0JBQXdCLGVBQWUscUJBQXFCO0FBQUEsTUFDN0k7QUFBQSxJQUNKO0FBQUEsRUFDUixDQUFLO0FBQ0QsUUFBTSxnQkFBZ0IsQ0FBQyxRQUFRUyxXQUFjTyxnQkFBbUIsS0FBSyxNQUFNLFdBQVcsQ0FBQztBQUN2RixXQUFTLHNCQUFzQmxCLFNBQVE7QUFDbkMsVUFBTSxPQUFPLGVBQWVkO0FBQzVCLFdBQU9jLFVBQVM7QUFBQSxFQUNwQjtBQUNBLFdBQVMsV0FBVyxHQUFHO0FBQ25CLFdBQU8sc0JBQXNCLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJO0FBQUEsRUFDakQ7QUFFQSxRQUFNLFNBQVMsQ0FBQzNDLElBQUcsTUFBTSxPQUFPdUQsZ0JBQW1CdkQsR0FBRSxNQUFNLE1BQU0sRUFBRSxDQUFDO0FBQUEsRUFJcEUsTUFBTThELFdBQVU7QUFBQSxJQUNaLFlBQVksR0FBRyxHQUFHLFVBQVU7QUFDeEIsV0FBSyxJQUFJO0FBQ1QsV0FBSyxJQUFJO0FBQ1QsV0FBSyxXQUFXO0FBQ2hCLFdBQUssZUFBYztBQUFBLElBQ3ZCO0FBQUE7QUFBQSxJQUVBLE9BQU8sWUFBWSxLQUFLO0FBQ3BCLFlBQU0sSUFBSSxNQUFNO0FBQ2hCLFlBQU0sWUFBWSxvQkFBb0IsS0FBSyxJQUFJLENBQUM7QUFDaEQsYUFBTyxJQUFJQSxXQUFVLE9BQU8sS0FBSyxHQUFHLENBQUMsR0FBRyxPQUFPLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQztBQUFBLElBQ2pFO0FBQUE7QUFBQTtBQUFBLElBR0EsT0FBTyxRQUFRLEtBQUs7QUFDaEIsWUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLE1BQU0sWUFBWSxPQUFPLEdBQUcsQ0FBQztBQUNsRCxhQUFPLElBQUlBLFdBQVUsR0FBRyxDQUFDO0FBQUEsSUFDN0I7QUFBQSxJQUNBLGlCQUFpQjtBQUViLFVBQUksQ0FBQyxtQkFBbUIsS0FBSyxDQUFDO0FBQzFCLGNBQU0sSUFBSSxNQUFNLDJCQUEyQjtBQUMvQyxVQUFJLENBQUMsbUJBQW1CLEtBQUssQ0FBQztBQUMxQixjQUFNLElBQUksTUFBTSwyQkFBMkI7QUFBQSxJQUNuRDtBQUFBLElBQ0EsZUFBZSxVQUFVO0FBQ3JCLGFBQU8sSUFBSUEsV0FBVSxLQUFLLEdBQUcsS0FBSyxHQUFHLFFBQVE7QUFBQSxJQUNqRDtBQUFBLElBQ0EsaUJBQWlCLFNBQVM7QUFDdEIsWUFBTSxFQUFFLEdBQUcsR0FBRyxVQUFVLElBQUcsSUFBSztBQUNoQyxZQUFNLElBQUksY0FBYyxZQUFZLFdBQVcsT0FBTyxDQUFDO0FBQ3ZELFVBQUksT0FBTyxRQUFRLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEVBQUUsU0FBUyxHQUFHO0FBQ3pDLGNBQU0sSUFBSSxNQUFNLHFCQUFxQjtBQUN6QyxZQUFNLE9BQU8sUUFBUSxLQUFLLFFBQVEsSUFBSSxJQUFJLE1BQU0sSUFBSTtBQUNwRCxVQUFJLFFBQVFqQixJQUFHO0FBQ1gsY0FBTSxJQUFJLE1BQU0sNEJBQTRCO0FBQ2hELFlBQU0sVUFBVSxNQUFNLE9BQU8sSUFBSSxPQUFPO0FBQ3hDLFlBQU0sSUFBSSxNQUFNLFFBQVEsU0FBUyxjQUFjLElBQUksQ0FBQztBQUNwRCxZQUFNLEtBQUssS0FBSyxJQUFJO0FBQ3BCLFlBQU0sS0FBSyxLQUFLLENBQUMsSUFBSSxFQUFFO0FBQ3ZCLFlBQU0sS0FBSyxLQUFLLElBQUksRUFBRTtBQUN0QixZQUFNLElBQUksTUFBTSxLQUFLLHFCQUFxQixHQUFHLElBQUksRUFBRTtBQUNuRCxVQUFJLENBQUM7QUFDRCxjQUFNLElBQUksTUFBTSxtQkFBbUI7QUFDdkMsUUFBRSxlQUFjO0FBQ2hCLGFBQU87QUFBQSxJQUNYO0FBQUE7QUFBQSxJQUVBLFdBQVc7QUFDUCxhQUFPLHNCQUFzQixLQUFLLENBQUM7QUFBQSxJQUN2QztBQUFBLElBQ0EsYUFBYTtBQUNULGFBQU8sS0FBSyxTQUFRLElBQUssSUFBSWlCLFdBQVUsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLFFBQVEsSUFBSTtBQUFBLElBQ25GO0FBQUE7QUFBQSxJQUVBLGdCQUFnQjtBQUNaLGFBQU9DLFdBQWMsS0FBSyxVQUFVO0FBQUEsSUFDeEM7QUFBQSxJQUNBLFdBQVc7QUFDUCxhQUFPLElBQUksV0FBVyxFQUFFLEdBQUcsS0FBSyxHQUFHLEdBQUcsS0FBSyxHQUFHO0FBQUEsSUFDbEQ7QUFBQTtBQUFBLElBRUEsb0JBQW9CO0FBQ2hCLGFBQU9BLFdBQWMsS0FBSyxjQUFjO0FBQUEsSUFDNUM7QUFBQSxJQUNBLGVBQWU7QUFDWCxhQUFPLGNBQWMsS0FBSyxDQUFDLElBQUksY0FBYyxLQUFLLENBQUM7QUFBQSxJQUN2RDtBQUFBLEVBQ1I7QUFDSSxRQUFNLFFBQVE7QUFBQSxJQUNWLGtCQUFrQixZQUFZO0FBQzFCLFVBQUk7QUFDQSwrQkFBdUIsVUFBVTtBQUNqQyxlQUFPO0FBQUEsTUFDWCxTQUNPLE9BQU87QUFDVixlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFBQSxJQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUtBLGtCQUFrQixNQUFNO0FBQ3BCLFlBQU0sU0FBU0MsaUJBQXFCLE1BQU0sQ0FBQztBQUMzQyxhQUFPQyxlQUFtQixNQUFNLFlBQVksTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUFBLElBQ2hFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBU0EsV0FBVyxhQUFhLEdBQUcsUUFBUSxNQUFNLE1BQU07QUFDM0MsWUFBTSxlQUFlLFVBQVU7QUFDL0IsWUFBTSxTQUFTLE9BQU8sQ0FBQyxDQUFDO0FBQ3hCLGFBQU87QUFBQSxJQUNYO0FBQUEsRUFDUjtBQU9JLFdBQVMsYUFBYSxZQUFZLGVBQWUsTUFBTTtBQUNuRCxXQUFPLE1BQU0sZUFBZSxVQUFVLEVBQUUsV0FBVyxZQUFZO0FBQUEsRUFDbkU7QUFJQSxXQUFTLFVBQVUsTUFBTTtBQUNyQixVQUFNLE1BQU0sZ0JBQWdCO0FBQzVCLFVBQU0sTUFBTSxPQUFPLFNBQVM7QUFDNUIsVUFBTSxPQUFPLE9BQU8sUUFBUSxLQUFLO0FBQ2pDLFFBQUk7QUFDQSxhQUFPLFFBQVEsaUJBQWlCLFFBQVE7QUFDNUMsUUFBSTtBQUNBLGFBQU8sUUFBUSxJQUFJLGlCQUFpQixRQUFRLElBQUk7QUFDcEQsUUFBSSxnQkFBZ0I7QUFDaEIsYUFBTztBQUNYLFdBQU87QUFBQSxFQUNYO0FBV0EsV0FBUyxnQkFBZ0IsVUFBVSxTQUFTLGVBQWUsTUFBTTtBQUM3RCxRQUFJLFVBQVUsUUFBUTtBQUNsQixZQUFNLElBQUksTUFBTSwrQkFBK0I7QUFDbkQsUUFBSSxDQUFDLFVBQVUsT0FBTztBQUNsQixZQUFNLElBQUksTUFBTSwrQkFBK0I7QUFDbkQsVUFBTWpFLEtBQUksTUFBTSxRQUFRLE9BQU87QUFDL0IsV0FBT0EsR0FBRSxTQUFTLHVCQUF1QixRQUFRLENBQUMsRUFBRSxXQUFXLFlBQVk7QUFBQSxFQUMvRTtBQUtBLFFBQU0sV0FBVyxNQUFNLFlBQ25CLFNBQVVmLFFBQU87QUFHYixVQUFNLE1BQU1zRSxnQkFBbUJ0RSxNQUFLO0FBQ3BDLFVBQU0sUUFBUUEsT0FBTSxTQUFTLElBQUksTUFBTTtBQUN2QyxXQUFPLFFBQVEsSUFBSSxPQUFPLE9BQU8sS0FBSyxJQUFJO0FBQUEsRUFDOUM7QUFDSixRQUFNLGdCQUFnQixNQUFNLGlCQUN4QixTQUFVQSxRQUFPO0FBQ2IsV0FBTyxLQUFLLFNBQVNBLE1BQUssQ0FBQztBQUFBLEVBQy9CO0FBRUosUUFBTSxhQUFhaUYsUUFBVyxNQUFNLFVBQVU7QUFJOUMsV0FBUyxXQUFXLEtBQUs7QUFDckIsUUFBSSxPQUFPLFFBQVE7QUFDZixZQUFNLElBQUksTUFBTSxpQkFBaUI7QUFDckMsUUFBSSxFQUFFLE9BQU8sT0FBTyxNQUFNO0FBQ3RCLFlBQU0sSUFBSSxNQUFNLHVCQUF1QixNQUFNLFVBQVUsRUFBRTtBQUU3RCxXQUFPTCxnQkFBbUIsS0FBSyxNQUFNLFdBQVc7QUFBQSxFQUNwRDtBQU1BLFdBQVMsUUFBUSxTQUFTLFlBQVksT0FBTyxnQkFBZ0I7QUFDekQsUUFBSSxDQUFDLGFBQWEsV0FBVyxFQUFFLEtBQUssQ0FBQyxNQUFNLEtBQUssSUFBSTtBQUNoRCxZQUFNLElBQUksTUFBTSxxQ0FBcUM7QUFDekQsVUFBTSxFQUFFLE1BQUFsRCxPQUFNLGFBQUFOLGFBQVcsSUFBSztBQUM5QixRQUFJLEVBQUUsTUFBTSxTQUFTLGNBQWMsSUFBRyxJQUFLO0FBQzNDLFFBQUksUUFBUTtBQUNSLGFBQU87QUFDWCxjQUFVLFlBQVksV0FBVyxPQUFPO0FBQ3hDLFFBQUk7QUFDQSxnQkFBVSxZQUFZLHFCQUFxQk0sTUFBSyxPQUFPLENBQUM7QUFJNUQsVUFBTSxRQUFRLGNBQWMsT0FBTztBQUNuQyxVQUFNLElBQUksdUJBQXVCLFVBQVU7QUFDM0MsVUFBTSxXQUFXLENBQUMsV0FBVyxDQUFDLEdBQUcsV0FBVyxLQUFLLENBQUM7QUFFbEQsUUFBSSxPQUFPLE1BQU07QUFFYixZQUFNLElBQUksUUFBUSxPQUFPTixhQUFZd0MsSUFBRyxLQUFLLElBQUk7QUFDakQsZUFBUyxLQUFLLFlBQVksZ0JBQWdCLENBQUMsQ0FBQztBQUFBLElBQ2hEO0FBQ0EsVUFBTSxPQUFPUSxZQUFlLEdBQUcsUUFBUTtBQUN2QyxVQUFNLElBQUk7QUFFVixhQUFTLE1BQU0sUUFBUTtBQUVuQixZQUFNLElBQUksU0FBUyxNQUFNO0FBQ3pCLFVBQUksQ0FBQyxtQkFBbUIsQ0FBQztBQUNyQjtBQUNKLFlBQU0sS0FBSyxLQUFLLENBQUM7QUFDakIsWUFBTSxJQUFJLE1BQU0sS0FBSyxTQUFTLENBQUMsRUFBRTtBQUNqQyxZQUFNLElBQUksS0FBSyxFQUFFLENBQUM7QUFDbEIsVUFBSSxNQUFNO0FBQ047QUFJSixZQUFNLElBQUksS0FBSyxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQztBQUNuQyxVQUFJLE1BQU07QUFDTjtBQUNKLFVBQUksWUFBWSxFQUFFLE1BQU0sSUFBSSxJQUFJLEtBQUssT0FBTyxFQUFFLElBQUl4QixLQUFHO0FBQ3JELFVBQUksUUFBUTtBQUNaLFVBQUksUUFBUSxzQkFBc0IsQ0FBQyxHQUFHO0FBQ2xDLGdCQUFRLFdBQVcsQ0FBQztBQUNwQixvQkFBWTtBQUFBLE1BQ2hCO0FBQ0EsYUFBTyxJQUFJaUMsV0FBVSxHQUFHLE9BQU8sUUFBUTtBQUFBLElBQzNDO0FBQ0EsV0FBTyxFQUFFLE1BQU0sTUFBSztBQUFBLEVBQ3hCO0FBQ0EsUUFBTSxpQkFBaUIsRUFBRSxNQUFNLE1BQU0sTUFBTSxTQUFTLE1BQUs7QUFDekQsUUFBTSxpQkFBaUIsRUFBRSxNQUFNLE1BQU0sTUFBTSxTQUFTLE1BQUs7QUFjekQsV0FBUyxLQUFLLFNBQVMsU0FBUyxPQUFPLGdCQUFnQjtBQUNuRCxVQUFNLEVBQUUsTUFBTSxNQUFLLElBQUssUUFBUSxTQUFTLFNBQVMsSUFBSTtBQUN0RCxVQUFNLElBQUk7QUFDVixVQUFNLE9BQU9LLGVBQWtCLEVBQUUsS0FBSyxXQUFXLEVBQUUsYUFBYSxFQUFFLElBQUk7QUFDdEUsV0FBTyxLQUFLLE1BQU0sS0FBSztBQUFBLEVBQzNCO0FBRUEsUUFBTSxLQUFLLGVBQWUsQ0FBQztBQWUzQixXQUFTLE9BQU8sV0FBVyxTQUFTLFdBQVcsT0FBTyxnQkFBZ0I7QUFDbEUsVUFBTSxLQUFLO0FBQ1gsY0FBVSxZQUFZLFdBQVcsT0FBTztBQUN4QyxnQkFBWSxZQUFZLGFBQWEsU0FBUztBQUM5QyxRQUFJLFlBQVk7QUFDWixZQUFNLElBQUksTUFBTSxvQ0FBb0M7QUFDeEQsVUFBTSxFQUFFLE1BQU0sUUFBTyxJQUFLO0FBQzFCLFFBQUksT0FBTztBQUNYLFFBQUk7QUFDSixRQUFJO0FBQ0EsVUFBSSxPQUFPLE9BQU8sWUFBWSxjQUFjLFlBQVk7QUFHcEQsWUFBSTtBQUNBLGlCQUFPTCxXQUFVLFFBQVEsRUFBRTtBQUFBLFFBQy9CLFNBQ08sVUFBVTtBQUNiLGNBQUksRUFBRSxvQkFBb0IsSUFBSTtBQUMxQixrQkFBTTtBQUNWLGlCQUFPQSxXQUFVLFlBQVksRUFBRTtBQUFBLFFBQ25DO0FBQUEsTUFDSixXQUNTLE9BQU8sT0FBTyxZQUFZLE9BQU8sR0FBRyxNQUFNLFlBQVksT0FBTyxHQUFHLE1BQU0sVUFBVTtBQUNyRixjQUFNLEVBQUUsR0FBQU0sSUFBRyxHQUFBakIsR0FBQyxJQUFLO0FBQ2pCLGVBQU8sSUFBSVcsV0FBVU0sSUFBR2pCLEVBQUM7QUFBQSxNQUM3QixPQUNLO0FBQ0QsY0FBTSxJQUFJLE1BQU0sT0FBTztBQUFBLE1BQzNCO0FBQ0EsVUFBSSxNQUFNLFFBQVEsU0FBUztBQUFBLElBQy9CLFNBQ08sT0FBTztBQUNWLFVBQUksTUFBTSxZQUFZO0FBQ2xCLGNBQU0sSUFBSSxNQUFNLGdFQUFnRTtBQUNwRixhQUFPO0FBQUEsSUFDWDtBQUNBLFFBQUksUUFBUSxLQUFLLFNBQVE7QUFDckIsYUFBTztBQUNYLFFBQUk7QUFDQSxnQkFBVSxNQUFNLEtBQUssT0FBTztBQUNoQyxVQUFNLEVBQUUsR0FBRyxFQUFDLElBQUs7QUFDakIsVUFBTSxJQUFJLGNBQWMsT0FBTztBQUMvQixVQUFNLEtBQUssS0FBSyxDQUFDO0FBQ2pCLFVBQU0sS0FBSyxLQUFLLElBQUksRUFBRTtBQUN0QixVQUFNLEtBQUssS0FBSyxJQUFJLEVBQUU7QUFDdEIsVUFBTSxJQUFJLE1BQU0sS0FBSyxxQkFBcUIsR0FBRyxJQUFJLEVBQUUsR0FBRztBQUN0RCxRQUFJLENBQUM7QUFDRCxhQUFPO0FBQ1gsVUFBTSxJQUFJLEtBQUssRUFBRSxDQUFDO0FBQ2xCLFdBQU8sTUFBTTtBQUFBLEVBQ2pCO0FBQ0EsU0FBTztBQUFBLElBQ0g7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxpQkFBaUI7QUFBQSxJQUNqQixXQUFBVztBQUFBLElBQ0E7QUFBQSxFQUNSO0FBQ0E7QUMvNUJPLFNBQVMsUUFBUW5ELE9BQU07QUFDMUIsU0FBTztBQUFBLElBQ0gsTUFBQUE7QUFBQSxJQUNBLE1BQU0sQ0FBQyxRQUFRLFNBQVMsS0FBS0EsT0FBTSxLQUFLSSxjQUFZLEdBQUcsSUFBSSxDQUFDO0FBQUEsSUFDcEUsYUFBUVY7QUFBQUEsRUFDUjtBQUNBO0FBQ08sU0FBUyxZQUFZLFVBQVUsU0FBUztBQUMzQyxRQUFNLFNBQVMsQ0FBQ00sVUFBUyxZQUFZLEVBQUUsR0FBRyxVQUFVLEdBQUcsUUFBUUEsS0FBSSxHQUFHO0FBQ3RFLFNBQU8sT0FBTyxPQUFPLEVBQUUsR0FBRyxPQUFPLE9BQU8sR0FBRyxRQUFRO0FBQ3ZEO0FDUEEsTUFBTSxhQUFhLE9BQU8sb0VBQW9FO0FBQzlGLE1BQU0sYUFBYSxPQUFPLG9FQUFvRTtBQUM5RixNQUFNLE1BQU0sT0FBTyxDQUFDO0FBQ3BCLE1BQU0sTUFBTSxPQUFPLENBQUM7QUFDcEIsTUFBTSxhQUFhLENBQUMsR0FBR1gsUUFBTyxJQUFJQSxLQUFJLE9BQU9BO0FBSzdDLFNBQVMsUUFBUSxHQUFHO0FBQ2hCLFFBQU0sSUFBSTtBQUVWLFFBQU0wQyxPQUFNLE9BQU8sQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsT0FBTyxPQUFPLEVBQUUsR0FBRyxPQUFPLE9BQU8sRUFBRTtBQUUzRSxRQUFNLE9BQU8sT0FBTyxFQUFFLEdBQUcsT0FBTyxPQUFPLEVBQUUsR0FBRyxPQUFPLE9BQU8sRUFBRTtBQUM1RCxRQUFNLEtBQU0sSUFBSSxJQUFJLElBQUs7QUFDekIsUUFBTSxLQUFNLEtBQUssS0FBSyxJQUFLO0FBQzNCLFFBQU0sS0FBTSxLQUFLLElBQUlBLE1BQUssQ0FBQyxJQUFJLEtBQU07QUFDckMsUUFBTSxLQUFNLEtBQUssSUFBSUEsTUFBSyxDQUFDLElBQUksS0FBTTtBQUNyQyxRQUFNLE1BQU8sS0FBSyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQU07QUFDdEMsUUFBTSxNQUFPLEtBQUssS0FBSyxNQUFNLENBQUMsSUFBSSxNQUFPO0FBQ3pDLFFBQU0sTUFBTyxLQUFLLEtBQUssTUFBTSxDQUFDLElBQUksTUFBTztBQUN6QyxRQUFNLE1BQU8sS0FBSyxLQUFLLE1BQU0sQ0FBQyxJQUFJLE1BQU87QUFDekMsUUFBTSxPQUFRLEtBQUssS0FBSyxNQUFNLENBQUMsSUFBSSxNQUFPO0FBQzFDLFFBQU0sT0FBUSxLQUFLLE1BQU0sTUFBTSxDQUFDLElBQUksTUFBTztBQUMzQyxRQUFNLE9BQVEsS0FBSyxNQUFNQSxNQUFLLENBQUMsSUFBSSxLQUFNO0FBQ3pDLFFBQU0sS0FBTSxLQUFLLE1BQU0sTUFBTSxDQUFDLElBQUksTUFBTztBQUN6QyxRQUFNLEtBQU0sS0FBSyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQU07QUFDckMsUUFBTSxPQUFPLEtBQUssSUFBSSxLQUFLLENBQUM7QUFDNUIsTUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksSUFBSSxHQUFHLENBQUM7QUFDdkIsVUFBTSxJQUFJLE1BQU0seUJBQXlCO0FBQzdDLFNBQU87QUFDWDtBQUNBLE1BQU0sS0FBSyxNQUFNLFlBQVksUUFBVyxRQUFXLEVBQUUsTUFBTSxTQUFTO0FBQzdELE1BQU0sWUFBWSxZQUFZO0FBQUEsRUFDakMsR0FBRyxPQUFPLENBQUM7QUFBQSxFQUNYLEdBQUcsT0FBTyxDQUFDO0FBQUEsRUFDWDtBQUFBLEVBQ0EsR0FBRztBQUFBO0FBQUEsRUFFSCxJQUFJLE9BQU8sK0VBQStFO0FBQUEsRUFDMUYsSUFBSSxPQUFPLCtFQUErRTtBQUFBLEVBQzFGLEdBQUcsT0FBTyxDQUFDO0FBQUEsRUFDWCxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPTixNQUFNO0FBQUEsSUFDRixNQUFNLE9BQU8sb0VBQW9FO0FBQUEsSUFDakYsYUFBYSxDQUFDLE1BQU07QUFDaEIsWUFBTWhDLEtBQUk7QUFDVixZQUFNLEtBQUssT0FBTyxvQ0FBb0M7QUFDdEQsWUFBTSxLQUFLLENBQUMsTUFBTSxPQUFPLG9DQUFvQztBQUM3RCxZQUFNLEtBQUssT0FBTyxxQ0FBcUM7QUFDdkQsWUFBTSxLQUFLO0FBQ1gsWUFBTSxZQUFZLE9BQU8scUNBQXFDO0FBQzlELFlBQU0sS0FBSyxXQUFXLEtBQUssR0FBR0EsRUFBQztBQUMvQixZQUFNLEtBQUssV0FBVyxDQUFDLEtBQUssR0FBR0EsRUFBQztBQUNoQyxVQUFJLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxLQUFLLElBQUlBLEVBQUM7QUFDckMsVUFBSSxLQUFLLElBQUksQ0FBQyxLQUFLLEtBQUssS0FBSyxJQUFJQSxFQUFDO0FBQ2xDLFlBQU0sUUFBUSxLQUFLO0FBQ25CLFlBQU0sUUFBUSxLQUFLO0FBQ25CLFVBQUk7QUFDQSxhQUFLQSxLQUFJO0FBQ2IsVUFBSTtBQUNBLGFBQUtBLEtBQUk7QUFDYixVQUFJLEtBQUssYUFBYSxLQUFLLFdBQVc7QUFDbEMsY0FBTSxJQUFJLE1BQU0seUNBQXlDLENBQUM7QUFBQSxNQUM5RDtBQUNBLGFBQU8sRUFBRSxPQUFPLElBQUksT0FBTyxHQUFFO0FBQUEsSUFDakM7QUFBQSxFQUNSO0FBQ0EsR0FBR2UsUUFBTTtBQUdHLE9BQU8sQ0FBQztBQW1CTixVQUFVO0FDcEdaLE1BQUMsY0FBYztBQ0FmLE1BQUMsV0FBVztBQ0NaLE1BQUMsY0FBYztBQU1mLE1BQUMsZ0JBQWdCO0FDVDdCLE1BQU12QyxTQUFPLE9BQU8sQ0FBQztBQUNyQixNQUFNQyxTQUFPLE9BQU8sQ0FBQztBQUNyQixNQUFNa0YsU0FBTyxPQUFPLENBQUM7QUFDckIsTUFBTUMsVUFBUSxPQUFPLEVBQUU7QUFDdkIsTUFBTUMsVUFBUSxPQUFPLEVBQUU7QUFDdkIsTUFBTUMsVUFBUSxPQUFPLEVBQUU7QUFDdkIsTUFBTTNFLFdBQVMsQ0FBQTtBQUNmLFNBQVMsVUFBVSxPQUFPO0FBQ3RCLFNBQU8sYUFBYSxVQUFVLEtBQUssR0FBRyxFQUFFO0FBQzVDO0FBT08sTUFBTSxVQUFVO0FBQUEsRUFDbkI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLElBQUksSUFBSTtBQUFFLFdBQU8sS0FBSztBQUFBLEVBQUk7QUFBQSxFQUMxQixJQUFJLEVBQUUsT0FBTztBQUNULG1CQUFlLFdBQVcsS0FBSyxNQUFNLElBQUksYUFBYSxTQUFTLEtBQUs7QUFDcEUsU0FBSyxLQUFLLFFBQVEsS0FBSztBQUFBLEVBQzNCO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxJQUFJLElBQUk7QUFDSixtQkFBZSxTQUFTLEtBQUssR0FBRyxVQUFVLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyw0QkFBNEIsS0FBSyxLQUFLLEVBQUU7QUFDOUYsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFBQSxFQUNBLElBQUksRUFBRSxRQUFRO0FBQ1YsbUJBQWUsV0FBVyxNQUFNLE1BQU0sSUFBSSxhQUFhLFNBQVMsTUFBTTtBQUN0RSxTQUFLLEtBQUssUUFBUSxNQUFNO0FBQUEsRUFDNUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFTQSxJQUFJLEtBQUs7QUFBRSxXQUFPLEtBQUs7QUFBQSxFQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJM0IsVUFBVTtBQUNOLFdBQVEsU0FBUyxLQUFLLEdBQUcsVUFBVSxHQUFHLENBQUMsQ0FBQyxJQUFJO0FBQUEsRUFDaEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBV0EsSUFBSSxJQUFJO0FBQUUsV0FBTyxLQUFLO0FBQUEsRUFBSTtBQUFBLEVBQzFCLElBQUksRUFBRSxPQUFPO0FBQ1QsVUFBTSxJQUFJLFVBQVUsT0FBTyxPQUFPO0FBQ2xDLG1CQUFlLE1BQU0sTUFBTSxNQUFNLElBQUksYUFBYSxLQUFLLEtBQUs7QUFDNUQsU0FBSyxLQUFLO0FBQUEsRUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxJQUFJLFdBQVc7QUFBRSxXQUFPLEtBQUs7QUFBQSxFQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUt4QyxJQUFJLGdCQUFnQjtBQUNoQixVQUFNLElBQUksS0FBSztBQUNmLFFBQUksS0FBSyxNQUFNO0FBQ1gsYUFBTztBQUFBLElBQ1g7QUFDQSxXQUFPLFVBQVUsV0FBVyxDQUFDO0FBQUEsRUFDakM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxJQUFJLFVBQVU7QUFDVixXQUFRLEtBQUssTUFBTSxLQUFNLElBQUk7QUFBQSxFQUNqQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxJQUFJLGNBQWM7QUFFZCxVQUFNLGNBQWMsU0FBUyxLQUFLLENBQUM7QUFDbkMsUUFBSSxLQUFLLFNBQVM7QUFDZCxrQkFBWSxDQUFDLEtBQUs7QUFBQSxJQUN0QjtBQUNBLFdBQU8sUUFBUSxXQUFXO0FBQUEsRUFDOUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlBLElBQUksb0JBQW9CO0FBQ3BCLFdBQU8sT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLFdBQVcsQ0FBQztBQUFBLEVBQzVDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxJQUFJLGFBQWE7QUFDYixXQUFPLE9BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFJLEtBQUssVUFBVSxTQUFTLE9BQVE7QUFBQSxFQUNwRTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUEsWUFBWSxPQUFPLEdBQUcsR0FBRyxHQUFHO0FBQ3hCLGtCQUFjLE9BQU9BLFVBQVEsV0FBVztBQUN4QyxTQUFLLEtBQUs7QUFDVixTQUFLLEtBQUs7QUFDVixTQUFLLEtBQUs7QUFDVixTQUFLLFlBQVk7QUFBQSxFQUNyQjtBQUFBLEVBQ0EsQ0FBQyxPQUFPLElBQUksNEJBQTRCLENBQUMsSUFBSTtBQUN6QyxXQUFPLG1CQUFtQixLQUFLLENBQUMsVUFBVSxLQUFLLEVBQUUsSUFBSSxLQUFLLFFBQU8sSUFBSyxLQUFLLGtCQUFrQixjQUFjLEtBQUssT0FBTyxlQUFlLEtBQUssUUFBUTtBQUFBLEVBQ3ZKO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxRQUFRO0FBQ0osVUFBTSxRQUFRLElBQUksVUFBVUEsVUFBUSxLQUFLLEdBQUcsS0FBSyxJQUFJLEtBQUssQ0FBQztBQUMzRCxRQUFJLEtBQUssVUFBVTtBQUNmLFlBQU0sWUFBWSxLQUFLO0FBQUEsSUFDM0I7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUEsU0FBUztBQUNMLFVBQU0sV0FBVyxLQUFLO0FBQ3RCLFdBQU87QUFBQSxNQUNILE9BQU87QUFBQSxNQUNQLFVBQVksWUFBWSxPQUFRLFNBQVMsU0FBUSxJQUFLO0FBQUEsTUFDdEQsR0FBRyxLQUFLO0FBQUEsTUFBRyxHQUFHLEtBQUs7QUFBQSxNQUFJLEdBQUcsS0FBSztBQUFBLElBQzNDO0FBQUEsRUFDSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFXQSxPQUFPLFdBQVcsR0FBRztBQUNqQixVQUFNLEtBQUssVUFBVSxHQUFHLEdBQUc7QUFFM0IsUUFBSyxNQUFNeUUsV0FBVyxNQUFNQyxTQUFRO0FBQ2hDLGFBQU9yRjtBQUFBQSxJQUNYO0FBRUEsbUJBQWUsTUFBTXNGLFNBQU8scUJBQXFCLEtBQUssQ0FBQztBQUN2RCxZQUFRLEtBQUtBLFdBQVNIO0FBQUFBLEVBQzFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBZUEsT0FBTyxZQUFZLFNBQVMsR0FBRztBQUMzQixXQUFRLFVBQVUsT0FBTyxJQUFJQSxTQUFRLE9BQU8sS0FBSyxJQUFJLEVBQUU7QUFBQSxFQUMzRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBc0JBLE9BQU8sZUFBZSxHQUFHO0FBQ3JCLFVBQU0sS0FBSyxVQUFVLENBQUM7QUFDdEIsUUFBSSxPQUFPbkYsVUFBUSxPQUFPb0YsU0FBTztBQUM3QixhQUFPO0FBQUEsSUFDWDtBQUNBLFFBQUksT0FBT25GLFVBQVEsT0FBT29GLFNBQU87QUFDN0IsYUFBTztBQUFBLElBQ1g7QUFDQSxtQkFBZSxNQUFNQyxTQUFPLGFBQWEsS0FBSyxDQUFDO0FBRS9DLFdBQVEsS0FBS3JGLFNBQVEsS0FBSztBQUFBLEVBQzlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBU0EsT0FBTyxLQUFLLEtBQUs7QUFDYixhQUFTLFlBQVksT0FBTyxTQUFTO0FBQ2pDLHFCQUFlLE9BQU8sU0FBUyxhQUFhLEdBQUc7QUFBQSxJQUNuRDtBQUVBLFFBQUksT0FBTyxNQUFNO0FBQ2IsYUFBTyxJQUFJLFVBQVVVLFVBQVEsVUFBVSxVQUFVLEVBQUU7QUFBQSxJQUN2RDtBQUNBLFFBQUksT0FBUSxRQUFTLFVBQVU7QUFDM0IsWUFBTVosU0FBUSxTQUFTLEtBQUssV0FBVztBQUN2QyxVQUFJQSxPQUFNLFdBQVcsSUFBSTtBQUNyQixjQUFNbUYsS0FBSSxRQUFRbkYsT0FBTSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ3BDLGNBQU1rRSxLQUFJbEUsT0FBTSxNQUFNLElBQUksRUFBRTtBQUM1QixjQUFNd0YsS0FBS3RCLEdBQUUsQ0FBQyxJQUFJLE1BQVEsS0FBSztBQUMvQixRQUFBQSxHQUFFLENBQUMsS0FBSztBQUNSLGVBQU8sSUFBSSxVQUFVdEQsVUFBUXVFLElBQUcsUUFBUWpCLEVBQUMsR0FBR3NCLEVBQUM7QUFBQSxNQUNqRDtBQUNBLFVBQUl4RixPQUFNLFdBQVcsSUFBSTtBQUNyQixjQUFNbUYsS0FBSSxRQUFRbkYsT0FBTSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ3BDLGNBQU1rRSxLQUFJLFFBQVFsRSxPQUFNLE1BQU0sSUFBSSxFQUFFLENBQUM7QUFDckMsY0FBTXdGLEtBQUksVUFBVSxlQUFleEYsT0FBTSxFQUFFLENBQUM7QUFDNUMsZUFBTyxJQUFJLFVBQVVZLFVBQVF1RSxJQUFHakIsSUFBR3NCLEVBQUM7QUFBQSxNQUN4QztBQUNBLGtCQUFZLE9BQU8sOEJBQThCO0FBQUEsSUFDckQ7QUFDQSxRQUFJLGVBQWUsV0FBVztBQUMxQixhQUFPLElBQUksTUFBSztBQUFBLElBQ3BCO0FBRUEsVUFBTSxLQUFLLElBQUk7QUFDZixnQkFBWSxNQUFNLE1BQU0sV0FBVztBQUNuQyxVQUFNLElBQUksVUFBVSxFQUFFO0FBRXRCLFVBQU0sS0FBSyxTQUFVdEIsSUFBRyxhQUFhO0FBQ2pDLFVBQUlBLE1BQUssTUFBTTtBQUNYLGVBQU8sVUFBVUEsRUFBQztBQUFBLE1BQ3RCO0FBQ0EsVUFBSSxlQUFlLE1BQU07QUFDckIsb0JBQVksWUFBWSxhQUFhLEVBQUUsR0FBRyxxQkFBcUI7QUFDL0QsY0FBTWxFLFNBQVEsU0FBUyxXQUFXO0FBQ2xDLFFBQUFBLE9BQU0sQ0FBQyxLQUFLO0FBQ1osZUFBTyxRQUFRQSxNQUFLO0FBQUEsTUFDeEI7QUFDQSxrQkFBWSxPQUFPLFdBQVc7QUFBQSxJQUNsQyxHQUFHLElBQUksR0FBRyxJQUFJLFdBQVc7QUFFekIsVUFBTSxFQUFFLFVBQVUsRUFBQyxLQUFNLFNBQVUsSUFBSSxhQUFhLFNBQVM7QUFDekQsVUFBSSxNQUFNLE1BQU07QUFDWixjQUFNd0YsS0FBSSxVQUFVLEVBQUU7QUFDdEIsZUFBTztBQUFBLFVBQ0gsVUFBWUEsTUFBS0QsVUFBU0MsS0FBSTtBQUFBLFVBQzlCLEdBQUcsVUFBVSxlQUFlQSxFQUFDO0FBQUEsUUFDakQ7QUFBQSxNQUNZO0FBQ0EsVUFBSSxlQUFlLE1BQU07QUFDckIsb0JBQVksWUFBWSxhQUFhLEVBQUUsR0FBRyxxQkFBcUI7QUFDL0QsZUFBTyxFQUFFLEdBQUssU0FBUyxXQUFXLEVBQUUsQ0FBQyxJQUFJLE1BQVEsS0FBSyxHQUFHO0FBQUEsTUFDN0Q7QUFDQSxVQUFJLFdBQVcsTUFBTTtBQUNqQixnQkFBUSxVQUFVLFNBQVMsYUFBYSxHQUFDO0FBQUEsVUFDckMsS0FBSztBQUFHLG1CQUFPLEVBQUUsR0FBRyxHQUFFO0FBQUEsVUFDdEIsS0FBSztBQUFHLG1CQUFPLEVBQUUsR0FBRyxHQUFFO0FBQUEsUUFDMUM7QUFDZ0Isb0JBQVksT0FBTyxpQkFBaUI7QUFBQSxNQUN4QztBQUNBLGtCQUFZLE9BQU8sV0FBVztBQUFBLElBQ2xDLEdBQUcsSUFBSSxHQUFHLElBQUksYUFBYSxJQUFJLE9BQU87QUFDdEMsVUFBTSxTQUFTLElBQUksVUFBVTVFLFVBQVEsR0FBRyxHQUFHLENBQUM7QUFDNUMsUUFBSSxVQUFVO0FBQ1YsYUFBTyxZQUFZO0FBQUEsSUFDdkI7QUFFQSxnQkFBWSxJQUFJLFdBQVcsUUFBUSxVQUFVLElBQUksU0FBUyxhQUFhLE1BQU0sT0FBTyxTQUFTLGtCQUFrQjtBQUMvRyxnQkFBWSxJQUFJLGVBQWUsUUFBUSxJQUFJLGdCQUFnQixPQUFPLGFBQWEsc0JBQXNCO0FBQ3JHLFdBQU87QUFBQSxFQUNYO0FBQ0o7QUM3U08sTUFBTSxXQUFXO0FBQUEsRUFDcEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlBLFlBQVksWUFBWTtBQUNwQixtQkFBZSxXQUFXLFVBQVUsTUFBTSxJQUFJLHVCQUF1QixjQUFjLFlBQVk7QUFDL0YsU0FBSyxjQUFjLFFBQVEsVUFBVTtBQUFBLEVBQ3pDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxJQUFJLGFBQWE7QUFBRSxXQUFPLEtBQUs7QUFBQSxFQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPNUMsSUFBSSxZQUFZO0FBQUUsV0FBTyxXQUFXLGlCQUFpQixLQUFLLFdBQVc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVF4RSxJQUFJLHNCQUFzQjtBQUFFLFdBQU8sV0FBVyxpQkFBaUIsS0FBSyxhQUFhLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJeEYsS0FBSyxRQUFRO0FBQ1QsbUJBQWUsV0FBVyxNQUFNLE1BQU0sSUFBSSx5QkFBeUIsVUFBVSxNQUFNO0FBQ25GLFVBQU0sTUFBTSxVQUFVLEtBQUssYUFBYSxNQUFNLEdBQUcsYUFBYSxLQUFLLFdBQVcsR0FBRztBQUFBLE1BQzdFLE1BQU07QUFBQSxJQUNsQixDQUFTO0FBQ0QsV0FBTyxVQUFVLEtBQUs7QUFBQSxNQUNsQixHQUFHLFFBQVEsSUFBSSxHQUFHLEVBQUU7QUFBQSxNQUNwQixHQUFHLFFBQVEsSUFBSSxHQUFHLEVBQUU7QUFBQSxNQUNwQixHQUFJLElBQUksV0FBVyxLQUFPO0FBQUEsSUFDdEMsQ0FBUztBQUFBLEVBQ0w7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBdUJBLG9CQUFvQixPQUFPO0FBQ3ZCLFVBQU0sU0FBUyxXQUFXLGlCQUFpQixLQUFLO0FBQ2hELFdBQU8sUUFBUSxVQUFVLGdCQUFnQixhQUFhLEtBQUssV0FBVyxHQUFHLFNBQVMsTUFBTSxHQUFHLEtBQUssQ0FBQztBQUFBLEVBQ3JHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQTBCQSxPQUFPLGlCQUFpQixLQUFLLFlBQVk7QUFDckMsUUFBSVosU0FBUSxTQUFTLEtBQUssS0FBSztBQUUvQixRQUFJQSxPQUFNLFdBQVcsSUFBSTtBQUNyQixZQUFNLFNBQVMsVUFBVSxhQUFhQSxRQUFPLENBQUMsQ0FBQyxVQUFVO0FBQ3pELGFBQU8sUUFBUSxNQUFNO0FBQUEsSUFDekI7QUFFQSxRQUFJQSxPQUFNLFdBQVcsSUFBSTtBQUNyQixZQUFNLE1BQU0sSUFBSSxXQUFXLEVBQUU7QUFDN0IsVUFBSSxDQUFDLElBQUk7QUFDVCxVQUFJLElBQUlBLFFBQU8sQ0FBQztBQUNoQixNQUFBQSxTQUFRO0FBQUEsSUFDWjtBQUNBLFVBQU0sUUFBUSxVQUFVLGdCQUFnQixRQUFRQSxNQUFLO0FBQ3JELFdBQU8sUUFBUSxNQUFNLFdBQVcsVUFBVSxDQUFDO0FBQUEsRUFDL0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQW1CQSxPQUFPLGlCQUFpQixRQUFRLFdBQVc7QUFDdkMsbUJBQWUsV0FBVyxNQUFNLE1BQU0sSUFBSSx5QkFBeUIsVUFBVSxNQUFNO0FBQ25GLFVBQU0sTUFBTSxVQUFVLEtBQUssU0FBUztBQUNwQyxRQUFJLFVBQVUsVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsRixjQUFVLFFBQVEsZUFBZSxJQUFJLE9BQU87QUFDNUMsVUFBTSxTQUFTLFFBQVEsaUJBQWlCLGFBQWEsTUFBTSxDQUFDO0FBQzVELG1CQUFlLFVBQVUsTUFBTSxnQ0FBZ0MsYUFBYSxTQUFTO0FBQ3JGLFdBQU8sT0FBTyxPQUFPLE1BQU0sS0FBSztBQUFBLEVBQ3BDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVdBLE9BQU8sVUFBVSxJQUFJLElBQUksWUFBWTtBQUNqQyxVQUFNLE9BQU8sVUFBVSxnQkFBZ0IsUUFBUSxXQUFXLGlCQUFpQixFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDM0YsVUFBTSxPQUFPLFVBQVUsZ0JBQWdCLFFBQVEsV0FBVyxpQkFBaUIsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQzNGLFdBQU8sT0FBTyxLQUFLLElBQUksSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLFVBQVU7QUFBQSxFQUNuRDtBQUNKO0FDbEtBLE1BQU1DLFNBQU8sT0FBTyxDQUFDO0FBQ3JCLE1BQU0sUUFBUSxPQUFPLEVBQUU7QUFDdkIsU0FBUyxtQkFBbUIsU0FBUztBQUlqQyxZQUFVLFFBQVEsWUFBVztBQUM3QixRQUFNLFFBQVEsUUFBUSxVQUFVLENBQUMsRUFBRSxNQUFNLEVBQUU7QUFDM0MsUUFBTSxXQUFXLElBQUksV0FBVyxFQUFFO0FBQ2xDLFdBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxLQUFLO0FBQ3pCLGFBQVMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLFdBQVcsQ0FBQztBQUFBLEVBQ3ZDO0FBQ0EsUUFBTSxTQUFTLFNBQVMsVUFBVSxRQUFRLENBQUM7QUFDM0MsV0FBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLEtBQUssR0FBRztBQUM1QixRQUFLLE9BQU8sS0FBSyxDQUFDLEtBQUssS0FBTSxHQUFHO0FBQzVCLFlBQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLFlBQVc7QUFBQSxJQUNuQztBQUNBLFNBQUssT0FBTyxLQUFLLENBQUMsSUFBSSxPQUFTLEdBQUc7QUFDOUIsWUFBTSxJQUFJLENBQUMsSUFBSSxNQUFNLElBQUksQ0FBQyxFQUFFLFlBQVc7QUFBQSxJQUMzQztBQUFBLEVBQ0o7QUFDQSxTQUFPLE9BQU8sTUFBTSxLQUFLLEVBQUU7QUFDL0I7QUFHQSxNQUFNLGFBQWEsQ0FBQTtBQUNuQixTQUFTLElBQUksR0FBRyxJQUFJLElBQUksS0FBSztBQUN6QixhQUFXLE9BQU8sQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDO0FBQ3BDO0FBQ0EsU0FBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLEtBQUs7QUFDekIsYUFBVyxPQUFPLGFBQWEsS0FBSyxDQUFDLENBQUMsSUFBSSxPQUFPLEtBQUssQ0FBQztBQUMzRDtBQUdBLE1BQU0sYUFBYTtBQUNuQixTQUFTLGFBQWEsU0FBUztBQUMzQixZQUFVLFFBQVEsWUFBVztBQUM3QixZQUFVLFFBQVEsVUFBVSxDQUFDLElBQUksUUFBUSxVQUFVLEdBQUcsQ0FBQyxJQUFJO0FBQzNELE1BQUksV0FBVyxRQUFRLE1BQU0sRUFBRSxFQUFFLElBQUksQ0FBQyxNQUFNO0FBQUUsV0FBTyxXQUFXLENBQUM7QUFBQSxFQUFHLENBQUMsRUFBRSxLQUFLLEVBQUU7QUFFOUUsU0FBTyxTQUFTLFVBQVUsWUFBWTtBQUNsQyxRQUFJLFFBQVEsU0FBUyxVQUFVLEdBQUcsVUFBVTtBQUM1QyxlQUFXLFNBQVMsT0FBTyxFQUFFLElBQUksS0FBSyxTQUFTLFVBQVUsTUFBTSxNQUFNO0FBQUEsRUFDekU7QUFDQSxNQUFJd0YsWUFBVyxPQUFPLEtBQU0sU0FBUyxVQUFVLEVBQUUsSUFBSSxFQUFHO0FBQ3hELFNBQU9BLFVBQVMsU0FBUyxHQUFHO0FBQ3hCLElBQUFBLFlBQVcsTUFBTUE7QUFBQSxFQUNyQjtBQUNBLFNBQU9BO0FBQ1g7QUFFQSxNQUFNLFVBQVUsV0FBWTtBQUV4QixRQUFNLFNBQVMsQ0FBQTtBQUNmLFdBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxLQUFLO0FBQ3pCLFVBQU0sTUFBTSx1Q0FBdUMsQ0FBQztBQUNwRCxXQUFPLEdBQUcsSUFBSSxPQUFPLENBQUM7QUFBQSxFQUMxQjtBQUNBLFNBQU87QUFDWCxHQUFDO0FBQ0QsU0FBUyxXQUFXLE9BQU87QUFDdkIsVUFBUSxNQUFNLFlBQVc7QUFDekIsTUFBSSxTQUFTeEY7QUFDYixXQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLO0FBQ25DLGFBQVMsU0FBUyxRQUFRLE9BQU8sTUFBTSxDQUFDLENBQUM7QUFBQSxFQUM3QztBQUNBLFNBQU87QUFDWDtBQW9DTyxTQUFTLFdBQVcsU0FBUztBQUNoQyxpQkFBZSxPQUFRLFlBQWEsVUFBVSxtQkFBbUIsV0FBVyxPQUFPO0FBQ25GLE1BQUksUUFBUSxNQUFNLHdCQUF3QixHQUFHO0FBRXpDLFFBQUksQ0FBQyxRQUFRLFdBQVcsSUFBSSxHQUFHO0FBQzNCLGdCQUFVLE9BQU87QUFBQSxJQUNyQjtBQUNBLFVBQU0sU0FBUyxtQkFBbUIsT0FBTztBQUV6QyxtQkFBZSxDQUFDLFFBQVEsTUFBTSwrQkFBK0IsS0FBSyxXQUFXLFNBQVMsd0JBQXdCLFdBQVcsT0FBTztBQUNoSSxXQUFPO0FBQUEsRUFDWDtBQUVBLE1BQUksUUFBUSxNQUFNLGdDQUFnQyxHQUFHO0FBRWpELG1CQUFlLFFBQVEsVUFBVSxHQUFHLENBQUMsTUFBTSxhQUFhLE9BQU8sR0FBRyxxQkFBcUIsV0FBVyxPQUFPO0FBQ3pHLFFBQUksU0FBUyxXQUFXLFFBQVEsVUFBVSxDQUFDLENBQUMsRUFBRSxTQUFTLEVBQUU7QUFDekQsV0FBTyxPQUFPLFNBQVMsSUFBSTtBQUN2QixlQUFTLE1BQU07QUFBQSxJQUNuQjtBQUNBLFdBQU8sbUJBQW1CLE9BQU8sTUFBTTtBQUFBLEVBQzNDO0FBQ0EsaUJBQWUsT0FBTyxtQkFBbUIsV0FBVyxPQUFPO0FBQy9EO0FBbUJPLFNBQVMsZUFBZSxTQUFTO0FBRXBDLE1BQUksU0FBUyxPQUFPLFdBQVcsT0FBTyxDQUFDLEVBQUUsU0FBUyxFQUFFLEVBQUUsWUFBVztBQUNqRSxTQUFPLE9BQU8sU0FBUyxJQUFJO0FBQ3ZCLGFBQVMsTUFBTTtBQUFBLEVBQ25CO0FBQ0EsU0FBTyxPQUFPLGFBQWEsU0FBUyxNQUFNLElBQUk7QUFDbEQ7QUNwSU8sU0FBUyxpQkFBaUIsSUFBSTtBQUNqQyxRQUFNLE9BQU8sV0FBVyxHQUFHLElBQUk7QUFDL0IsUUFBTSxRQUFRLFVBQVUsR0FBRyxPQUFPLFVBQVU7QUFDNUMsTUFBSSxXQUFXLE1BQU0sU0FBUyxFQUFFO0FBQ2hDLE1BQUksYUFBYSxLQUFLO0FBQ2xCLGVBQVc7QUFBQSxFQUNmLFdBQ1MsU0FBUyxTQUFTLEdBQUc7QUFDMUIsZUFBVyxRQUFRO0FBQUEsRUFDdkIsT0FDSztBQUNELGVBQVcsT0FBTztBQUFBLEVBQ3RCO0FBQ0EsU0FBTyxXQUFXLFVBQVUsVUFBVSxVQUFVLENBQUMsTUFBTSxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUMzRTtBQXdCTyxTQUFTLGtCQUFrQixPQUFPLE9BQU8sZUFBZTtBQUMzRCxRQUFNLE9BQU8sV0FBVyxLQUFLO0FBQzdCLFFBQU0sT0FBTyxTQUFTLE9BQU8sTUFBTTtBQUNuQyxRQUFNLGVBQWUsU0FBUyxlQUFlLGNBQWM7QUFDM0QsaUJBQWUsS0FBSyxXQUFXLElBQUkseUJBQXlCLFFBQVEsS0FBSztBQUN6RSxpQkFBZSxhQUFhLFdBQVcsSUFBSSxpQ0FBaUMsZ0JBQWdCLGFBQWE7QUFDekcsU0FBTyxXQUFXLFVBQVUsVUFBVSxPQUFPLENBQUMsUUFBUSxNQUFNLE1BQU0sWUFBWSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDMUY7QUNuRE8sU0FBUyxjQUFjLE9BQU87QUFDakMsU0FBUSxTQUFTLE9BQVEsTUFBTSxlQUFnQjtBQUNuRDtBQTBCTyxTQUFTLFVBQVUsT0FBTztBQUM3QixNQUFJO0FBQ0EsZUFBVyxLQUFLO0FBQ2hCLFdBQU87QUFBQSxFQUNYLFNBQ08sT0FBTztBQUFBLEVBQUU7QUFDaEIsU0FBTztBQUNYO0FBQ0EsZUFBZSxhQUFhLFFBQVEsU0FBUztBQUN6QyxRQUFNLFNBQVMsTUFBTTtBQUNyQixNQUFJLFVBQVUsUUFBUSxXQUFXLDhDQUE4QztBQUMzRSxXQUFPLE9BQVEsV0FBWSxVQUFVLHFCQUFxQixxQkFBcUIsRUFBRSxPQUFPLFFBQVE7QUFDaEcsbUJBQWUsT0FBTyxpRUFBaUUsVUFBVSxNQUFNO0FBQUEsRUFDM0c7QUFDQSxTQUFPLFdBQVcsTUFBTTtBQUM1QjtBQXNDTyxTQUFTLGVBQWUsUUFBUSxVQUFVO0FBQzdDLE1BQUksT0FBUSxXQUFZLFVBQVU7QUFDOUIsUUFBSSxPQUFPLE1BQU0sbUJBQW1CLEdBQUc7QUFDbkMsYUFBTyxXQUFXLE1BQU07QUFBQSxJQUM1QjtBQUNBLFdBQU8sWUFBWSxNQUFNLHNDQUFzQyx5QkFBeUIsRUFBRSxXQUFXLGVBQWU7QUFDcEgsV0FBTyxhQUFhLFFBQVEsU0FBUyxZQUFZLE1BQU0sQ0FBQztBQUFBLEVBQzVELFdBQ1MsY0FBYyxNQUFNLEdBQUc7QUFDNUIsV0FBTyxhQUFhLFFBQVEsT0FBTyxXQUFVLENBQUU7QUFBQSxFQUNuRCxXQUNTLFVBQVUsT0FBUSxPQUFPLFNBQVUsWUFBWTtBQUNwRCxXQUFPLGFBQWEsUUFBUSxNQUFNO0FBQUEsRUFDdEM7QUFDQSxpQkFBZSxPQUFPLGlDQUFpQyxVQUFVLE1BQU07QUFDM0U7QUNqR0EsTUFBTSxTQUFTLENBQUE7QUFDZixTQUFTLEVBQUUsT0FBTyxPQUFPO0FBQ3JCLE1BQUlhLFVBQVM7QUFDYixNQUFJLFFBQVEsR0FBRztBQUNYLElBQUFBLFVBQVM7QUFDVCxhQUFTO0FBQUEsRUFDYjtBQUVBLFNBQU8sSUFBSSxNQUFNLFFBQVEsR0FBR0EsVUFBUyxLQUFLLEdBQUcsTUFBTSxLQUFLLElBQUksT0FBTyxFQUFFLFFBQUFBLFNBQVEsTUFBSyxDQUFFO0FBQ3hGO0FBQ0EsU0FBUyxFQUFFLE9BQU8sTUFBTTtBQUVwQixTQUFPLElBQUksTUFBTSxRQUFRLFFBQVMsT0FBUSxPQUFPLEVBQUUsSUFBSSxPQUFPLEVBQUUsS0FBSSxDQUFFO0FBQzFFO0FBQ0EsTUFBTSxlQUFlLE9BQU8sSUFBSSxlQUFlO0FBSXhDLE1BQU0sTUFBTTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSWY7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlBO0FBQUEsRUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlBLFlBQVksT0FBTyxNQUFNLE9BQU8sU0FBUztBQUNyQyxRQUFJLFdBQVcsTUFBTTtBQUNqQixnQkFBVTtBQUFBLElBQ2Q7QUFDQSxrQkFBYyxRQUFRLE9BQU8sT0FBTztBQUNwQyxxQkFBaUIsTUFBTSxFQUFFLGNBQWMsTUFBTSxNQUFLLENBQUU7QUFDcEQsU0FBSyxXQUFXO0FBRWhCLFNBQUssT0FBTTtBQUFBLEVBQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlBLFNBQVM7QUFDTCxRQUFJLEtBQUssU0FBUyxTQUFTO0FBQ3ZCLFlBQU0sSUFBSSxNQUFNLEVBQUU7QUFBQSxJQUN0QixXQUNTLEtBQUssU0FBUyxnQkFBZ0I7QUFDbkMsWUFBTSxJQUFJLE1BQU0sRUFBRTtBQUFBLElBQ3RCLFdBQ1MsS0FBSyxTQUFTLFNBQVM7QUFDNUIsYUFBTyxTQUFTLEtBQUssTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFFLE9BQU0sQ0FBRSxFQUFFLEtBQUssR0FBRyxDQUFDO0FBQUEsSUFDL0Q7QUFDQSxXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUEsZUFBZTtBQUNYLFdBQU87QUFBQSxFQUNYO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxXQUFXO0FBQ1AsV0FBTztBQUFBLEVBQ1g7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlBLFdBQVc7QUFDUCxXQUFPO0FBQUEsRUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUEsV0FBVztBQUNQLFdBQU8sQ0FBQyxDQUFFLEtBQUssS0FBSyxNQUFNLGVBQWU7QUFBQSxFQUM3QztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUEsU0FBUztBQUNMLFdBQU8sS0FBSyxLQUFLLFdBQVcsT0FBTztBQUFBLEVBQ3ZDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxXQUFXO0FBQ1AsV0FBUSxLQUFLLFNBQVM7QUFBQSxFQUMxQjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUEsSUFBSSxZQUFZO0FBQ1osUUFBSSxLQUFLLFNBQVMsU0FBUztBQUN2QixZQUFNLFVBQVUsYUFBYTtBQUFBLElBQ2pDO0FBQ0EsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVVBLElBQUksY0FBYztBQUNkLFFBQUksS0FBSyxTQUFTLFNBQVM7QUFDdkIsWUFBTSxVQUFVLGNBQWM7QUFBQSxJQUNsQztBQUNBLFFBQUksS0FBSyxhQUFhLE1BQU07QUFDeEIsYUFBTztBQUFBLElBQ1g7QUFDQSxRQUFJLEtBQUssYUFBYSxPQUFPO0FBQ3pCLGFBQVEsS0FBSyxNQUFPO0FBQUEsSUFDeEI7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUEsT0FBTyxLQUFLLE1BQU0sT0FBTztBQUNyQixXQUFPLElBQUksTUFBTSxRQUFRLE1BQU0sS0FBSztBQUFBLEVBQ3hDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxPQUFPLE1BQU0sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sS0FBSyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLEtBQUssR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbEMsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE1BQU0sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE1BQU0sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE1BQU0sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sSUFBSSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSW5DLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsQ0FBQztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSW5DLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsQ0FBQztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSW5DLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsQ0FBQztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxJQUFJLE1BQU0sUUFBUSxXQUFXLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJNUQsT0FBTyxLQUFLLEdBQUc7QUFBRSxXQUFPLElBQUksTUFBTSxRQUFRLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJeEQsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLElBQUksTUFB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TSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEdBQUk7QUFFaE0sTUFBTSxJQUFJLENBQUMsSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sR0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sR0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sR0FBTSxLQUFNLEdBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxHQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxHQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxHQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLElBQU0sR0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEdBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sR0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sRUFBSTtBQUN6Z0QsTUFBTSxLQUFLLENBQUMsSUFBTSxHQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sR0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sR0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEdBQU0sS0FBTSxLQUFNLElBQU0sR0FBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEdBQU0sS0FBTSxLQUFNLEtBQU0sR0FBTSxHQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEdBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxJQUFNLEdBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxJQUFNLElBQU0sR0FBSTtBQUUxZ0QsTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxHQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksU0FBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxHQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxVQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksU0FBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxHQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksU0FBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxHQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksU0FBVTtBQUUxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFVBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksR0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksR0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksR0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksVUFBWSxZQUFZLFVBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksVUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksR0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksVUFBVTtBQUUxZ0csTUFBTSxLQUFLLENBQUMsR0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsR0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksVUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksVUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsR0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsR0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFVBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZ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ZUFBZSxlQUFlLFNBQVM7QUFDNUMsU0FBTyxNQUFNLFFBQVEsU0FBUyxtQkFBbUIsQ0FBQSxDQUFFO0FBQ3JEO0FBU08sZUFBZSxpQkFBaUIsU0FBUyxhQUFhLHNCQUFzQixPQUFPO0FBQ3hGLFNBQU8sTUFBTSxRQUFRLFNBQVMsd0JBQXdCLENBQUMsYUFBYSxtQkFBbUIsQ0FBQztBQUMxRjtBQWtFTyxlQUFlLFlBQVksU0FBUyxhQUFhO0FBQ3RELFNBQU8sTUFBTSxRQUFRLFNBQVMsbUJBQW1CLENBQUMsV0FBVyxDQUFDO0FBQ2hFO0FBUU8sZUFBZSxLQUFLLFNBQVMsYUFBYTtBQUMvQyxTQUFPLE1BQU0sUUFBUSxTQUFTLFlBQVksQ0FBQyxhQUFhLFFBQVEsQ0FBQztBQUNuRTtBQVFPLGVBQWUsbUJBQW1CLFNBQVMsVUFBVTtBQUMxRCxTQUFPLE1BQU0sUUFBUSxTQUFTLDBCQUEwQixDQUFDLFFBQVEsQ0FBQztBQUNwRTtBQVFPLGVBQWUsc0JBQXNCLFNBQVMsUUFBUTtBQUMzRCxTQUFPLE1BQU0sUUFBUSxTQUFTLDZCQUE2QixDQUFDLE1BQU0sQ0FBQztBQUNyRTtBQVFPLGVBQWUscUJBQXFCLFNBQVMsUUFBUTtBQUMxRCxTQUFPLE1BQU0sUUFBUSxTQUFTLDRCQUE0QixDQUFDLE1BQU0sQ0FBQztBQUNwRTtBQVFPLFNBQVMsY0FBYyxZQUFZLFdBQVcsR0FBRztBQUN0RCxRQUFNLFVBQVVDLFlBQW1CLFVBQVU7QUFDN0MsUUFBTSxNQUFNLFdBQVcsT0FBTztBQUM5QixTQUFPLElBQUksUUFBUSxRQUFRO0FBQzdCOyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDkxLDkyLDkzLDk0LDk1LDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyXX0=

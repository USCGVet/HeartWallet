const version = "6.15.0";
function checkType(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v, index) => {
    accum[keys[index]] = v;
    return accum;
  }, {});
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}
function stringify(value, seen) {
  if (value == null) {
    return "null";
  }
  if (seen == null) {
    seen = /* @__PURE__ */ new Set();
  }
  if (typeof value === "object") {
    if (seen.has(value)) {
      return "[Circular]";
    }
    seen.add(value);
  }
  if (Array.isArray(value)) {
    return "[ " + value.map((v) => stringify(v, seen)).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON(), seen);
  }
  switch (typeof value) {
    case "boolean":
    case "number":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code) {
  return error && error.code === code;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
const _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertNormalize(form) {
  assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
function _getBytes(value, name, copy2) {
  if (value instanceof Uint8Array) {
    if (copy2) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
const HexCharacters = "0123456789abcdef";
function hexlify(data) {
  const bytes2 = getBytes(data);
  let result = "0x";
  for (let i = 0; i < bytes2.length; i++) {
    const v = bytes2[i];
    result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes2 = getBytes(data);
  if (end != null && end > bytes2.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes2,
      length: bytes2.length,
      offset: end
    });
  }
  return hexlify(bytes2.slice(start == null ? 0 : start, end == null ? bytes2.length : end));
}
function stripZerosLeft(data) {
  let bytes2 = hexlify(data).substring(2);
  while (bytes2.startsWith("00")) {
    bytes2 = bytes2.substring(2);
  }
  return "0x" + bytes2;
}
function zeroPad(data, length, left) {
  const bytes2 = getBytes(data);
  assert(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes2),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes2, length - bytes2.length);
  } else {
    result.set(bytes2, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}
const BN_0$9 = BigInt(0);
const BN_1$3 = BigInt(1);
const maxValue = 9007199254740991;
function fromTwos(_value, _width) {
  const value = getUint(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value >> width === BN_0$9, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value
  });
  if (value >> width - BN_1$3) {
    const mask2 = (BN_1$3 << width) - BN_1$3;
    return -((~value & mask2) + BN_1$3);
  }
  return value;
}
function toTwos(_value, _width) {
  let value = getBigInt(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1$3 << width - BN_1$3;
  if (value < BN_0$9) {
    value = -value;
    assert(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
    const mask2 = (BN_1$3 << width) - BN_1$3;
    return (~value & mask2) + BN_1$3;
  } else {
    assert(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
  }
  return value;
}
function mask(_value, _bits) {
  const value = getUint(_value, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1$3 << bits) - BN_1$3;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert(result >= BN_0$9, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
const Nibbles$1 = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles$1[v >> 4];
      result += Nibbles$1[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e) {
        assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value, _width) {
  const value = getUint(_value, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value) {
  const value = getUint(_value, "value");
  if (value === BN_0$9) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
let Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
}
const BN_0$8 = BigInt(0);
const BN_58 = BigInt(58);
function encodeBase58(_value) {
  const bytes2 = getBytes(_value);
  let value = toBigInt(bytes2);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i = 0; i < bytes2.length; i++) {
    if (bytes2[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_0$8;
  for (let i = 0; i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}
function decodeBase64(textData) {
  textData = atob(textData);
  const data = new Uint8Array(textData.length);
  for (let i = 0; i < textData.length; i++) {
    data[i] = textData.charCodeAt(i);
  }
  return getBytes(data);
}
function encodeBase64(_data) {
  const data = getBytes(_data);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}
class EventPayload {
  /**
   *  The event filter.
   */
  filter;
  /**
   *  The **EventEmitterable**.
   */
  emitter;
  #listener;
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter) {
    this.#listener = listener;
    defineProperties(this, { emitter, filter });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (this.#listener == null) {
      return;
    }
    await this.emitter.off(this.filter, this.#listener);
  }
}
function errorFunc(reason, offset, bytes2, output2, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1; o < bytes2.length; o++) {
      if (bytes2[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset, bytes2);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes2 = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes2.length) {
    const c = bytes2[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes2, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes2, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes2.length) {
      i += onError("OVERRUN", i - 1, bytes2, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes2[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes2, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function toUtf8CodePoints(str, form) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
function createGetUrl(options) {
  async function getUrl(req, _signal) {
    assert(_signal == null || !_signal.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let error = null;
    const controller = new AbortController();
    const timer = setTimeout(() => {
      error = makeError("request timeout", "TIMEOUT");
      controller.abort();
    }, req.timeout);
    if (_signal) {
      _signal.addListener(() => {
        error = makeError("request cancelled", "CANCELLED");
        controller.abort();
      });
    }
    const init2 = Object.assign({}, options, {
      method: req.method,
      headers: new Headers(Array.from(req)),
      body: req.body || void 0,
      signal: controller.signal
    });
    let resp;
    try {
      resp = await fetch(req.url, init2);
    } catch (_error) {
      clearTimeout(timer);
      if (error) {
        throw error;
      }
      throw _error;
    }
    clearTimeout(timer);
    const headers = {};
    resp.headers.forEach((value, key) => {
      headers[key.toLowerCase()] = value;
    });
    const respBody = await resp.arrayBuffer();
    const body = respBody == null ? null : new Uint8Array(respBody);
    return {
      statusCode: resp.status,
      statusMessage: resp.statusText,
      headers,
      body
    };
  }
  return getUrl;
}
const MAX_ATTEMPTS = 12;
const SLOT_INTERVAL = 250;
let defaultGetUrlFunc = createGetUrl();
const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
const reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let locked$5 = false;
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
const Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
const fetchSignals = /* @__PURE__ */ new WeakMap();
class FetchCancelSignal {
  #listeners;
  #cancelled;
  constructor(request) {
    this.#listeners = [];
    this.#cancelled = false;
    fetchSignals.set(request, () => {
      if (this.#cancelled) {
        return;
      }
      this.#cancelled = true;
      for (const listener of this.#listeners) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      this.#listeners = [];
    });
  }
  addListener(listener) {
    assert(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    this.#listeners.push(listener);
  }
  get cancelled() {
    return this.#cancelled;
  }
  checkSignal() {
    assert(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
class FetchRequest {
  #allowInsecure;
  #gzip;
  #headers;
  #method;
  #timeout;
  #url;
  #body;
  #bodyType;
  #creds;
  // Hooks
  #preflight;
  #process;
  #retry;
  #signal;
  #throttle;
  #getUrlFunc;
  /**
   *  The fetch URL to request.
   */
  get url() {
    return this.#url;
  }
  set url(url) {
    this.#url = String(url);
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (this.#body == null) {
      return null;
    }
    return new Uint8Array(this.#body);
  }
  set body(body) {
    if (body == null) {
      this.#body = void 0;
      this.#bodyType = void 0;
    } else if (typeof body === "string") {
      this.#body = toUtf8Bytes(body);
      this.#bodyType = "text/plain";
    } else if (body instanceof Uint8Array) {
      this.#body = body;
      this.#bodyType = "application/octet-stream";
    } else if (typeof body === "object") {
      this.#body = toUtf8Bytes(JSON.stringify(body));
      this.#bodyType = "application/json";
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (this.#method) {
      return this.#method;
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    this.#method = String(method).toUpperCase();
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, this.#headers);
    if (this.#creds) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`;
    }
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && this.#bodyType) {
      headers["content-type"] = this.#bodyType;
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key, value) {
    this.#headers[String(key).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    this.#headers = {};
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return this.#creds || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    this.#creds = `${username}:${password}`;
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return this.#gzip;
  }
  set allowGzip(value) {
    this.#gzip = !!value;
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!this.#allowInsecure;
  }
  set allowInsecureAuthentication(value) {
    this.#allowInsecure = !!value;
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return this.#timeout;
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    this.#timeout = timeout;
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return this.#preflight || null;
  }
  set preflightFunc(preflight) {
    this.#preflight = preflight;
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return this.#process || null;
  }
  set processFunc(process) {
    this.#process = process;
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return this.#retry || null;
  }
  set retryFunc(retry) {
    this.#retry = retry;
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return this.#getUrlFunc || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    this.#getUrlFunc = value;
  }
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url) {
    this.#url = String(url);
    this.#allowInsecure = false;
    this.#gzip = true;
    this.#headers = {};
    this.#method = "";
    this.#timeout = 3e5;
    this.#throttle = {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    };
    this.#getUrlFunc = null;
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      this.#throttle.slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      this.#throttle.maxAttempts = params.maxAttempts;
    }
  }
  async #send(attempt, expires, delay, _request, _response) {
    if (attempt >= this.#throttle.maxAttempts) {
      return _response.makeServerError("exceeded maximum retry limit");
    }
    assert(getTime$1() <= expires, "timeout", "TIMEOUT", {
      operation: "request.send",
      reason: "timeout",
      request: _request
    });
    if (delay > 0) {
      await wait(delay);
    }
    let req = this.clone();
    const scheme = (req.url.split(":")[0] || "").toLowerCase();
    if (scheme in Gateways) {
      const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));
      if (result instanceof FetchResponse) {
        let response2 = result;
        if (this.processFunc) {
          checkSignal(_request.#signal);
          try {
            response2 = await this.processFunc(req, response2);
          } catch (error) {
            if (error.throttle == null || typeof error.stall !== "number") {
              response2.makeServerError("error in post-processing function", error).assertOk();
            }
          }
        }
        return response2;
      }
      req = result;
    }
    if (this.preflightFunc) {
      req = await this.preflightFunc(req);
    }
    const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));
    let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
    if (response.statusCode === 301 || response.statusCode === 302) {
      try {
        const location = response.headers.location || "";
        return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
      } catch (error) {
      }
      return response;
    } else if (response.statusCode === 429) {
      if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
        const retryAfter = response.headers["retry-after"];
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
          delay2 = parseInt(retryAfter);
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    if (this.processFunc) {
      checkSignal(_request.#signal);
      try {
        response = await this.processFunc(req, response);
      } catch (error) {
        if (error.throttle == null || typeof error.stall !== "number") {
          response.makeServerError("error in post-processing function", error).assertOk();
        }
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (error.stall >= 0) {
          delay2 = error.stall;
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    return response;
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    this.#signal = new FetchCancelSignal(this);
    return this.#send(0, getTime$1() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    req.#headers = Object.assign({}, this.#headers);
    if (this.#body) {
      req.#body = new Uint8Array(this.#body);
    }
    req.#bodyType = this.#bodyType;
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new FetchRequest(this.url);
    clone.#method = this.#method;
    if (this.#body) {
      clone.#body = this.#body;
    }
    clone.#bodyType = this.#bodyType;
    clone.#headers = Object.assign({}, this.#headers);
    clone.#creds = this.#creds;
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    clone.#preflight = this.#preflight;
    clone.#process = this.#process;
    clone.#retry = this.#retry;
    clone.#throttle = Object.assign({}, this.#throttle);
    clone.#getUrlFunc = this.#getUrlFunc;
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked$5 = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked$5) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl) {
    if (locked$5) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl(options);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
}
class FetchResponse {
  #statusCode;
  #statusMessage;
  #headers;
  #body;
  #request;
  #error;
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return this.#statusCode;
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return this.#statusMessage;
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, this.#headers);
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return this.#body == null ? null : new Uint8Array(this.#body);
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return this.#body == null ? "" : toUtf8String(this.#body);
    } catch (error) {
      assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  constructor(statusCode, statusMessage, headers, body, request) {
    this.#statusCode = statusCode;
    this.#statusMessage = statusMessage;
    this.#headers = Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {});
    this.#body = body == null ? null : new Uint8Array(body);
    this.#request = request || null;
    this.#error = { message: "" };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || void 0);
    response.#error = { message, error };
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall2) {
    if (stall2 == null) {
      stall2 = -1;
    } else {
      assertArgument(Number.isInteger(stall2) && stall2 >= 0, "invalid stall timeout", "stall", stall2);
    }
    const error = new Error(message || "throttling requests");
    defineProperties(error, { stall: stall2, throttle: true });
    throw error;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return this.#request;
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = this.#error;
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (this.#body) {
        responseBody = toUtf8String(this.#body);
      }
    } catch (e) {
    }
    assert(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
}
function getTime$1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  assert(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset2
    });
  };
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data[offset]) };
}
function decodeRlp(_data) {
  const data = getBytes(_data, "data");
  const decoded = _decode(data, 0);
  assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
  return decoded.result;
}
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data = Array.prototype.slice.call(getBytes(object2, "object"));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
const nibbles = "0123456789abcdef";
function encodeRlp(object2) {
  let result = "0x";
  for (const v of _encode(object2)) {
    result += nibbles[v >> 4];
    result += nibbles[v & 15];
  }
  return result;
}
function uuidV4(randomBytes2) {
  const bytes2 = getBytes(randomBytes2, "randomBytes");
  bytes2[6] = bytes2[6] & 15 | 64;
  bytes2[8] = bytes2[8] & 63 | 128;
  const value = hexlify(bytes2);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
const WordSize = 32;
const Padding = new Uint8Array(WordSize);
const passProperties$1 = ["then"];
const _guard$4 = {};
const resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names) {
  resultNames.set(result, names);
}
function throwError(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
function toObject(names, items, deep) {
  if (names.indexOf(null) >= 0) {
    return items.map((item, index) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names.reduce((accum, name, index) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
class Result extends Array {
  // No longer used; but cannot be removed as it will remove the
  // #private field from the .d.ts which may break backwards
  // compatibility
  #names;
  /**
   *  @private
   */
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names = (args[2] || []).slice();
    let wrap = true;
    if (guard !== _guard$4) {
      items = args;
      names = [];
      wrap = false;
    }
    super(items.length);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item, index) => {
      const name = names[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    this.#names = [];
    if (this.#names == null) {
      void this.#names;
    }
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index = getNumber(prop, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties$1.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError(`index ${index}`, item);
      }
      if (deep && item instanceof Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names = getNames(this);
    return names.reduce((accum, name, index) => {
      assert(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names = getNames(this);
    const result = [], names = [];
    for (let i = start; i < end; i++) {
      result.push(this[i]);
      names.push(_names[i]);
    }
    return new Result(_guard$4, result, names);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names = getNames(this);
    const result = [], names = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names.push(_names[i]);
      }
    }
    return new Result(_guard$4, result, names);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index = getNames(this).indexOf(name);
    if (index === -1) {
      return void 0;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new Result(_guard$4, items, keys);
  }
}
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object2) {
    if (!Array.isArray(object2)) {
      return;
    }
    for (let key in object2) {
      const childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object2[key]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
function getValue$1(value) {
  let bytes2 = toBeArray(value);
  assert(bytes2.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize, offset: bytes2.length });
  if (bytes2.length !== WordSize) {
    bytes2 = getBytesCopy(concat([Padding.slice(bytes2.length % WordSize), bytes2]));
  }
  return bytes2;
}
class Coder {
  // The coder name:
  //   - address, uint256, tuple, array, etc.
  name;
  // The fully expanded type, including composite types:
  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
  type;
  // The localName bound in the signature, in this example it is "baz":
  //   - tuple(address foo, uint bar) baz
  localName;
  // Whether this type is dynamic:
  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
  dynamic;
  constructor(name, type, localName, dynamic) {
    defineProperties(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
}
class Writer {
  // An array of WordSize lengthed objects to concatenation
  #data;
  #dataLength;
  constructor() {
    this.#data = [];
    this.#dataLength = 0;
  }
  get data() {
    return concat(this.#data);
  }
  get length() {
    return this.#dataLength;
  }
  #writeData(data) {
    this.#data.push(data);
    this.#dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this.#writeData(getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes2 = getBytesCopy(value);
    const paddingOffset = bytes2.length % WordSize;
    if (paddingOffset) {
      bytes2 = getBytesCopy(concat([bytes2, Padding.slice(paddingOffset)]));
    }
    return this.#writeData(bytes2);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return this.#writeData(getValue$1(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = this.#data.length;
    this.#data.push(Padding);
    this.#dataLength += WordSize;
    return (value) => {
      this.#data[offset] = getValue$1(value);
    };
  }
}
class Reader {
  // Allows incomplete unpadded data to be read; otherwise an error
  // is raised if attempting to overrun the buffer. This is required
  // to deal with an old Solidity bug, in which event data for
  // external (not public thoguh) was tightly packed.
  allowLoose;
  #data;
  #offset;
  #bytesRead;
  #parent;
  #maxInflation;
  constructor(data, allowLoose, maxInflation) {
    defineProperties(this, { allowLoose: !!allowLoose });
    this.#data = getBytesCopy(data);
    this.#bytesRead = 0;
    this.#parent = null;
    this.#maxInflation = maxInflation != null ? maxInflation : 1024;
    this.#offset = 0;
  }
  get data() {
    return hexlify(this.#data);
  }
  get dataLength() {
    return this.#data.length;
  }
  get consumed() {
    return this.#offset;
  }
  get bytes() {
    return new Uint8Array(this.#data);
  }
  #incrementBytesRead(count) {
    if (this.#parent) {
      return this.#parent.#incrementBytesRead(count);
    }
    this.#bytesRead += count;
    assert(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
      buffer: getBytesCopy(this.#data),
      offset: this.#offset,
      length: count,
      info: {
        bytesRead: this.#bytesRead,
        dataLength: this.dataLength
      }
    });
  }
  #peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / WordSize) * WordSize;
    if (this.#offset + alignedLength > this.#data.length) {
      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
        alignedLength = length;
      } else {
        assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
          buffer: getBytesCopy(this.#data),
          length: this.#data.length,
          offset: this.#offset + alignedLength
        });
      }
    }
    return this.#data.slice(this.#offset, this.#offset + alignedLength);
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
    reader.#parent = this;
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes2 = this.#peekBytes(0, length, !!loose);
    this.#incrementBytesRead(length);
    this.#offset += bytes2.length;
    return bytes2.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
}
function number$1(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes$1(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash$1(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(hash2.outputLen);
  number$1(hash2.blockLen);
}
function exists$1(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$1(out, instance) {
  bytes$1(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const u8a$2 = (a) => a instanceof Uint8Array;
const u32$1 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView$2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr$2 = (word, shift) => word << 32 - shift | word >>> shift;
const isLE$2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$2)
  throw new Error("Non little-endian hardware is not supported");
const nextTick$1 = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick$1();
    ts += diff;
  }
}
function utf8ToBytes$3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$1(data) {
  if (typeof data === "string")
    data = utf8ToBytes$3(data);
  if (!u8a$2(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
let Hash$1 = class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
const toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor$1(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$1(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
let HMAC$1 = class HMAC extends Hash$1 {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash$1(hash2);
    const key = toBytes$1(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists$1(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists$1(this);
    bytes$1(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
const hmac$2 = (hash2, key, message) => new HMAC$1(hash2, key).update(message).digest();
hmac$2.create = (hash2, key) => new HMAC$1(hash2, key);
function pbkdf2Init(hash2, _password, _salt, _opts) {
  hash$1(hash2);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number$1(c);
  number$1(dkLen);
  number$1(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes$1(_password);
  const salt = toBytes$1(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac$2.create(hash2, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf2$1(hash2, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView$2(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
function setBigUint64$1(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
let SHA2$1 = class SHA2 extends Hash$1 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$2(this.buffer);
  }
  update(data) {
    exists$1(this);
    const { view, buffer, blockLen } = this;
    data = toBytes$1(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView$2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists$1(this);
    output$1(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64$1(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView$2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};
const Chi$2 = (a, b2, c) => a & b2 ^ ~a & c;
const Maj$2 = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
const SHA256_K$2 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W$2 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$1 = class SHA256 extends SHA2$1 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV$1[0] | 0;
    this.B = IV$1[1] | 0;
    this.C = IV$1[2] | 0;
    this.D = IV$1[3] | 0;
    this.E = IV$1[4] | 0;
    this.F = IV$1[5] | 0;
    this.G = IV$1[6] | 0;
    this.H = IV$1[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G: G2, H } = this;
    return [A, B, C, D, E, F, G2, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G2, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G2 | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W$2[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W$2[i - 15];
      const W2 = SHA256_W$2[i - 2];
      const s0 = rotr$2(W15, 7) ^ rotr$2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr$2(W2, 17) ^ rotr$2(W2, 19) ^ W2 >>> 10;
      SHA256_W$2[i] = s1 + SHA256_W$2[i - 7] + s0 + SHA256_W$2[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G: G2, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr$2(E, 6) ^ rotr$2(E, 11) ^ rotr$2(E, 25);
      const T12 = H + sigma1 + Chi$2(E, F, G2) + SHA256_K$2[i] + SHA256_W$2[i] | 0;
      const sigma0 = rotr$2(A, 2) ^ rotr$2(A, 13) ^ rotr$2(A, 22);
      const T22 = sigma0 + Maj$2(A, B, C) | 0;
      H = G2;
      G2 = F;
      F = E;
      E = D + T12 | 0;
      D = C;
      C = B;
      B = A;
      A = T12 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G2 = G2 + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G2, H);
  }
  roundClean() {
    SHA256_W$2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
const sha256$3 = /* @__PURE__ */ wrapConstructor$1(() => new SHA256$1());
const U32_MASK64$1 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n$1 = /* @__PURE__ */ BigInt(32);
function fromBig$1(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64$1), l: Number(n2 >> _32n$1 & U32_MASK64$1) };
  return { h: Number(n2 >> _32n$1 & U32_MASK64$1) | 0, l: Number(n2 & U32_MASK64$1) | 0 };
}
function split$1(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig$1(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
const toBig = (h, l) => BigInt(h >>> 0) << _32n$1 | BigInt(l >>> 0);
const shrSH = (h, _l, s) => h >>> s;
const shrSL = (h, l, s) => h << 32 - s | l >>> s;
const rotrSH$1 = (h, l, s) => h >>> s | l << 32 - s;
const rotrSL$1 = (h, l, s) => h << 32 - s | l >>> s;
const rotrBH$1 = (h, l, s) => h << 64 - s | l >>> s - 32;
const rotrBL$1 = (h, l, s) => h >>> s - 32 | l << 64 - s;
const rotr32H$1 = (_h, l) => l;
const rotr32L$1 = (h, _l) => h;
const rotlSH = (h, l, s) => h << s | l >>> 32 - s;
const rotlSL = (h, l, s) => l << s | h >>> 32 - s;
const rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add$1(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
const add3L$1 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H$1 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
const u64 = {
  fromBig: fromBig$1,
  split: split$1,
  toBig,
  shrSH,
  shrSL,
  rotrSH: rotrSH$1,
  rotrSL: rotrSL$1,
  rotrBH: rotrBH$1,
  rotrBL: rotrBL$1,
  rotr32H: rotr32H$1,
  rotr32L: rotr32L$1,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add: add$1,
  add3L: add3L$1,
  add3H: add3H$1,
  add4L,
  add4H,
  add5H,
  add5L
};
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends SHA2$1 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64.add3L(T1l, sigma0l, MAJl);
      Ah = u64.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512$1 = /* @__PURE__ */ wrapConstructor$1(() => new SHA512());
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
const crypto$1 = anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256$3.create();
    case "sha512":
      return sha512$1.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key) {
  const algo = { sha256: sha256$3, sha512: sha512$1 }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac$2.create(algo, key);
}
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  const algo = { sha256: sha256$3, sha512: sha512$1 }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf2$1(algo, password, salt, { c: iterations, dkLen: keylen });
}
function randomBytes$2(length) {
  assert(crypto$1 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  const result = new Uint8Array(length);
  crypto$1.getRandomValues(result);
  return result;
}
let locked$4 = false;
const _computeHmac = function(algorithm, key, data) {
  return createHmac(algorithm, key).update(data).digest();
};
let __computeHmac = _computeHmac;
function computeHmac(algorithm, _key, _data) {
  const key = getBytes(_key, "key");
  const data = getBytes(_data, "data");
  return hexlify(__computeHmac(algorithm, key, data));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked$4 = true;
};
computeHmac.register = function(func) {
  if (locked$4) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n$4 = /* @__PURE__ */ BigInt(0);
const _1n$5 = /* @__PURE__ */ BigInt(1);
const _2n$3 = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R = _1n$5, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n$4;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n$5 ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n$3)
      t ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(j)) - _1n$5;
  }
  _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split$1(_SHA3_IOTA, true);
const rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
class Keccak extends Hash$1 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number$1(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32$1(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists$1(this);
    const { blockLen, state } = this;
    data = toBytes$1(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists$1(this, false);
    bytes$1(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number$1(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output$1(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor$1(() => new Keccak(blockLen, suffix, outputLen));
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
let locked$3 = false;
const _keccak256 = function(data) {
  return keccak_256(data);
};
let __keccak256 = _keccak256;
function keccak256(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked$3 = true;
};
keccak256.register = function(func) {
  if (locked$3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
const Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
const rotl$1 = (word, shift) => word << shift | word >>> 32 - shift;
function f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  else if (group === 1)
    return x & y | ~x & z;
  else if (group === 2)
    return (x | ~y) ^ z;
  else if (group === 3)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
}
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends SHA2$1 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl$1(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl$1(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl$1(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl$1(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
}
const ripemd160$1 = /* @__PURE__ */ wrapConstructor$1(() => new RIPEMD160());
let locked$2 = false;
const _ripemd160 = function(data) {
  return ripemd160$1(data);
};
let __ripemd160 = _ripemd160;
function ripemd160(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__ripemd160(data));
}
ripemd160._ = _ripemd160;
ripemd160.lock = function() {
  locked$2 = true;
};
ripemd160.register = function(func) {
  if (locked$2) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd160);
let locked$1 = false;
const _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
let __pbkdf2 = _pbkdf2;
function pbkdf2(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf2._ = _pbkdf2;
pbkdf2.lock = function() {
  locked$1 = true;
};
pbkdf2.register = function(func) {
  if (locked$1) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf2);
let locked = false;
const _randomBytes = function(length) {
  return new Uint8Array(randomBytes$2(length));
};
let __randomBytes = _randomBytes;
function randomBytes$1(length) {
  return __randomBytes(length);
}
randomBytes$1._ = _randomBytes;
randomBytes$1.lock = function() {
  locked = true;
};
randomBytes$1.register = function(func) {
  if (locked) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes$1);
const rotl = (a, b2) => a << b2 | a >>> 32 - b2;
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0; i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N2, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  number$1(N2);
  number$1(r);
  number$1(p);
  number$1(dkLen);
  number$1(asyncTick);
  number$1(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N2 <= 1 || (N2 & N2 - 1) !== 0 || N2 >= 2 ** (blockSize / 8) || N2 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N2 + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf2$1(sha256$3, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32$1(B);
  const V = u32$1(new Uint8Array(blockSize * N2));
  const tmp = u32$1(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N2 * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N2, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf2$1(sha256$3, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt$1(password, salt, opts) {
  const { N: N2, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0; i < N2 - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N2 - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    for (let i = 0; i < N2; i++) {
      const j = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N: N2, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    let pos = 0;
    await asyncLoop(N2 - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix(V, (N2 - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    await asyncLoop(N2, asyncTick, () => {
      const j = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
let lockedSync = false, lockedAsync = false;
const _scryptAsync = async function(passwd, salt, N2, r, p, dkLen, onProgress) {
  return await scryptAsync(passwd, salt, { N: N2, r, p, dkLen, onProgress });
};
const _scryptSync = function(passwd, salt, N2, r, p, dkLen) {
  return scrypt$1(passwd, salt, { N: N2, r, p, dkLen });
};
let __scryptAsync = _scryptAsync;
let __scryptSync = _scryptSync;
async function scrypt(_passwd, _salt, N2, r, p, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N2, r, p, dkLen, progress));
}
scrypt._ = _scryptAsync;
scrypt.lock = function() {
  lockedAsync = true;
};
scrypt.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt);
function scryptSync(_passwd, _salt, N2, r, p, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N2, r, p, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function() {
  lockedSync = true;
};
scryptSync.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);
const _sha256 = function(data) {
  return createHash("sha256").update(data).digest();
};
const _sha512 = function(data) {
  return createHash("sha512").update(data).digest();
};
let __sha256 = _sha256;
let __sha512 = _sha512;
let locked256 = false, locked512 = false;
function sha256$2(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__sha256(data));
}
sha256$2._ = _sha256;
sha256$2.lock = function() {
  locked256 = true;
};
sha256$2.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha256$2);
function sha512(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__sha512(data));
}
sha512._ = _sha512;
sha512.lock = function() {
  locked512 = true;
};
sha512.register = function(func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha256$2);
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
const u8a$1 = (a) => a instanceof Uint8Array;
const createView$1 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr$1 = (word, shift) => word << 32 - shift | word >>> shift;
const isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$1)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes$2(data);
  if (!u8a$1(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes$1(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a$1(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
class Hash2 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
class SHA22 extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$1(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView$1(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView$1(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}
const Chi$1 = (a, b2, c) => a & b2 ^ ~a & c;
const Maj$1 = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
const SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
class SHA2562 extends SHA22 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G: G2, H } = this;
    return [A, B, C, D, E, F, G2, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G2, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G2 | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W$1[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W$1[i - 15];
      const W2 = SHA256_W$1[i - 2];
      const s0 = rotr$1(W15, 7) ^ rotr$1(W15, 18) ^ W15 >>> 3;
      const s1 = rotr$1(W2, 17) ^ rotr$1(W2, 19) ^ W2 >>> 10;
      SHA256_W$1[i] = s1 + SHA256_W$1[i - 7] + s0 + SHA256_W$1[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G: G2, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr$1(E, 6) ^ rotr$1(E, 11) ^ rotr$1(E, 25);
      const T12 = H + sigma1 + Chi$1(E, F, G2) + SHA256_K$1[i] + SHA256_W$1[i] | 0;
      const sigma0 = rotr$1(A, 2) ^ rotr$1(A, 13) ^ rotr$1(A, 22);
      const T22 = sigma0 + Maj$1(A, B, C) | 0;
      H = G2;
      G2 = F;
      F = E;
      E = D + T12 | 0;
      D = C;
      C = B;
      B = A;
      A = T12 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G2 = G2 + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G2, H);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
const sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA2562());
const _0n$3 = BigInt(0);
const _1n$4 = BigInt(1);
const _2n$2 = BigInt(2);
const u8a = (a) => a instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n$3; n2 >>= _1n$4, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n$4;
}
const bitSet = (n2, pos, value) => {
  return n2 | (value ? _1n$4 : _0n$3) << BigInt(pos);
};
const bitMask = (n2) => (_2n$2 << BigInt(n2 - 1)) - _1n$4;
const u8n = (data) => new Uint8Array(data);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b2) => hmacFn(k, v, ...b2);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes: utf8ToBytes$1,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3);
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a, b2) {
  const result = a % b2;
  return result >= _0n$2 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$2 || power < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$3)
    return _0n$2;
  let res = _1n$3;
  while (power > _0n$2) {
    if (power & _1n$3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n$2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$2 || modulo <= _0n$2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b2 = modulo;
  let x = _0n$2, u = _1n$3;
  while (a !== _0n$2) {
    const q = b2 / a;
    const r = b2 % a;
    const m = x - u * q;
    b2 = a, a = r, x = u, u = m;
  }
  const gcd = b2;
  if (gcd !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P2) {
  const legendreC = (P2 - _1n$3) / _2n$1;
  let Q, S2, Z;
  for (Q = P2 - _1n$3, S2 = 0; Q % _2n$1 === _0n$2; Q /= _2n$1, S2++)
    ;
  for (Z = _2n$1; Z < P2 && pow(Z, legendreC, P2) !== P2 - _1n$3; Z++)
    ;
  if (S2 === 1) {
    const p1div4 = (P2 + _1n$3) / _4n;
    return function tonelliFast(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n$3) / _2n$1;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S2;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b2); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge = Fp2.pow(g, _1n$3 << BigInt(r - m - 1));
      g = Fp2.sqr(ge);
      x = Fp2.mul(x, ge);
      b2 = Fp2.mul(b2, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n === _3n$1) {
    const p1div4 = (P2 + _1n$3) / _4n;
    return function sqrt3mod4(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _8n === _5n) {
    const c1 = (P2 - _5n) / _8n;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n$1);
      const v = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n$1), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  return tonelliShanks(P2);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n$2)
    throw new Error("Expected power > 0");
  if (power === _0n$2)
    return f2.ONE;
  if (power === _1n$3)
    return num;
  let p = f2.ONE;
  let d = num;
  while (power > _0n$2) {
    if (power & _1n$3)
      p = f2.mul(p, d);
    d = f2.sqr(d);
    power >>= _1n$3;
  }
  return p;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$2,
    isOdd: (num) => (num & _1n$3) === _1n$3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b2, c) => c ? b2 : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
const _0n$1 = BigInt(0);
const _1n$2 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p = c.ZERO;
      let d = elm;
      while (n2 > _0n$1) {
        if (n2 & _1n$2)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n$2;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n2) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f2 = c.BASE;
      const mask2 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$2;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFCached(P2, precomputesMap, n2, transform) {
      const W = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W);
        if (W !== 1) {
          precomputesMap.set(P2, transform(comp));
        }
      }
      return this.wNAF(W, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
const _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b: b2 } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P2 = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I = Point.ZERO;
      if (n2 === _0n)
        return I;
      assertGE(n2);
      if (n2 === _1n$1)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n$1)
          k1p = k1p.add(d);
        if (k2 & _1n$1)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n$1;
        k2 >>= _1n$1;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(n2);
        point = p;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b2) {
      const G2 = Point.BASE;
      const mul3 = (P2, a2) => a2 === _0n || a2 === _1n$1 || !P2.equals(G2) ? P2.multiplyUnsafe(a2) : P2.multiply(a2);
      const sum = mul3(this, a).add(mul3(Q, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$1)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$1)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n < num && num < Fp2.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n$1) === _1n$1;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$1;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE(b2.slice(from, to));
  class Signature2 {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature2(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$1);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P2;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature2.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature2(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h * is);
    const u2 = modN(r * is);
    const R = Point.BASE.multiplyAndAddUnsafe(P2, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature: Signature2,
    utils
  };
}
class HMAC2 extends Hash2 {
  constructor(hash$12, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash$12);
    const key = toBytes(_key);
    this.iHash = hash$12.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash$12.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash$12.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac$1 = (hash2, key, message) => new HMAC2(hash2, key).update(message).digest();
hmac$1.create = (hash2, key) => new HMAC2(hash2, key);
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac$1(hash2, key, concatBytes$1(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b2) => (a + b2 / _2n) / b2;
function sqrtMod(y) {
  const P2 = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P2;
  const b3 = b2 * b2 * y % P2;
  const b6 = pow2(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2(b9, _2n, P2) * b2 % P2;
  const b22 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2(t1, _6n, P2) * b2 % P2;
  const root = pow2(t2, _2n, P2);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n2);
      const c2 = divNearest(-b1 * k, n2);
      let k1 = mod(k - c1 * a1 - c2 * a2, n2);
      let k2 = mod(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k2 = n2 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256$1);
BigInt(0);
secp256k1.ProjectivePoint;
const ZeroAddress = "0x0000000000000000000000000000000000000000";
const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
const EtherSymbol = "";
const MessagePrefix = "Ethereum Signed Message:\n";
const BN_0$7 = BigInt(0);
const BN_1$2 = BigInt(1);
const BN_2$2 = BigInt(2);
const BN_27$1 = BigInt(27);
const BN_28$1 = BigInt(28);
const BN_35$1 = BigInt(35);
const _guard$3 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
class Signature {
  #r;
  #s;
  #v;
  #networkV;
  /**
   *  The ``r`` value for a signature.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return this.#r;
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    this.#r = hexlify(value);
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    assertArgument(parseInt(this.#s.substring(0, 3)) < 8, "non-canonical s; use ._s", "s", this.#s);
    return this.#s;
  }
  set s(_value) {
    assertArgument(dataLength(_value) === 32, "invalid s", "value", _value);
    this.#s = hexlify(_value);
  }
  /**
   *  Return the s value, unchecked for EIP-2 compliance.
   *
   *  This should generally not be used and is for situations where
   *  a non-canonical S value might be relevant, such as Frontier blocks
   *  that were mined prior to EIP-2 or invalid Authorization List
   *  signatures.
   */
  get _s() {
    return this.#s;
  }
  /**
   *  Returns true if the Signature is valid for [[link-eip-2]] signatures.
   */
  isValid() {
    return parseInt(this.#s.substring(0, 3)) < 8;
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return this.#v;
  }
  set v(value) {
    const v = getNumber(value, "value");
    assertArgument(v === 27 || v === 28, "invalid v", "v", value);
    this.#v = v;
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return this.#networkV;
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v = this.networkV;
    if (v == null) {
      return null;
    }
    return Signature.getChainId(v);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  /**
   *  @private
   */
  constructor(guard, r, s, v) {
    assertPrivate(guard, _guard$3, "Signature");
    this.#r = r;
    this.#s = s;
    this.#v = v;
    this.#networkV = null;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new Signature(_guard$3, this.r, this._s, this.v);
    if (this.networkV) {
      clone.#networkV = this.networkV;
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this._s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v) {
    const bv = getBigInt(v, "v");
    if (bv == BN_27$1 || bv == BN_28$1) {
      return BN_0$7;
    }
    assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v);
    return (bv - BN_35$1) / BN_2$2;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v) {
    return getBigInt(chainId) * BN_2$2 + BigInt(35 + v - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v) {
    const bv = getBigInt(v);
    if (bv === BN_0$7 || bv === BN_27$1) {
      return 27;
    }
    if (bv === BN_1$2 || bv === BN_28$1) {
      return 28;
    }
    assertArgument(bv >= BN_35$1, "invalid v", "v", v);
    return bv & BN_1$2 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    if (sig == null) {
      return new Signature(_guard$3, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes2 = getBytes(sig, "signature");
      if (bytes2.length === 64) {
        const r2 = hexlify(bytes2.slice(0, 32));
        const s2 = bytes2.slice(32, 64);
        const v2 = s2[0] & 128 ? 28 : 27;
        s2[0] &= 127;
        return new Signature(_guard$3, r2, hexlify(s2), v2);
      }
      if (bytes2.length === 65) {
        const r2 = hexlify(bytes2.slice(0, 32));
        const s2 = hexlify(bytes2.slice(32, 64));
        const v2 = Signature.getNormalizedV(bytes2[64]);
        return new Signature(_guard$3, r2, s2, v2);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof Signature) {
      return sig.clone();
    }
    const _r = sig.r;
    assertError(_r != null, "missing r");
    const r = toUint256(_r);
    const s = (function(s2, yParityAndS) {
      if (s2 != null) {
        return toUint256(s2);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes2 = getBytes(yParityAndS);
        bytes2[0] &= 127;
        return hexlify(bytes2);
      }
      assertError(false, "missing s");
    })(sig.s, sig.yParityAndS);
    const { networkV, v } = (function(_v, yParityAndS, yParity) {
      if (_v != null) {
        const v2 = getBigInt(_v);
        return {
          networkV: v2 >= BN_35$1 ? v2 : void 0,
          v: Signature.getNormalizedV(v2)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    })(sig.v, sig.yParityAndS, sig.yParity);
    const result = new Signature(_guard$3, r, s, v);
    if (networkV) {
      result.#networkV = networkV;
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
}
class SigningKey {
  #privateKey;
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    this.#privateKey = hexlify(privateKey);
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return this.#privateKey;
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return SigningKey.computePublicKey(this.#privateKey);
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return SigningKey.computePublicKey(this.#privateKey, true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(this.#privateKey), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes2 = getBytes(key, "key");
    if (bytes2.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes2, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes2.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes2, 1);
      bytes2 = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes2);
    return hexlify(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature.from(signature);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signature for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
}
const BN_0$6 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block2 = expanded.substring(0, safeDigits);
    expanded = parseInt(block2, 10) % 97 + expanded.substring(block2.length);
  }
  let checksum2 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum2.length < 2) {
    checksum2 = "0" + checksum2;
  }
  return checksum2;
}
const Base36 = (function() {
  const result = {};
  for (let i = 0; i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
})();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_0$6;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getIcapAddress(address) {
  let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getCreateAddress(tx) {
  const from = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
function getCreate2Address(_from, _salt, _initCodeHash) {
  const from = getAddress(_from);
  const salt = getBytes(_salt, "salt");
  const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
  assertArgument(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  assertArgument(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return getAddress(dataSlice(keccak256(concat(["0xff", from, salt, initCodeHash])), 12));
}
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
function isAddress(value) {
  try {
    getAddress(value);
    return true;
  } catch (error) {
  }
  return false;
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
const _gaurd = {};
function n(value, width) {
  let signed2 = false;
  if (width < 0) {
    signed2 = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
}
function b(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
}
const _typedSymbol = Symbol.for("_ethers_typed");
class Typed {
  /**
   *  The type, as a Solidity-compatible type.
   */
  type;
  /**
   *  The actual value.
   */
  value;
  #options;
  /**
   *  @_ignore:
   */
  _typedSymbol;
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options) {
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type, value });
    this.#options = options;
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v) => v.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return this.#options;
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (this.#options === true) {
      return -1;
    }
    if (this.#options === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new Typed(_gaurd, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v) {
    return n(v, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v) {
    return n(v, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v) {
    return n(v, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v) {
    return n(v, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v) {
    return n(v, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v) {
    return n(v, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v) {
    return n(v, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v) {
    return n(v, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v) {
    return n(v, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v) {
    return n(v, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v) {
    return n(v, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v) {
    return n(v, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v) {
    return n(v, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v) {
    return n(v, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v) {
    return n(v, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v) {
    return n(v, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v) {
    return n(v, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v) {
    return n(v, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v) {
    return n(v, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v) {
    return n(v, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v) {
    return n(v, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v) {
    return n(v, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v) {
    return n(v, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v) {
    return n(v, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v) {
    return n(v, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v) {
    return n(v, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v) {
    return n(v, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v) {
    return n(v, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v) {
    return n(v, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v) {
    return n(v, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v) {
    return n(v, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v) {
    return n(v, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v) {
    return n(v, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v) {
    return n(v, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v) {
    return n(v, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v) {
    return n(v, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v) {
    return n(v, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v) {
    return n(v, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v) {
    return n(v, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v) {
    return n(v, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v) {
    return n(v, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v) {
    return n(v, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v) {
    return n(v, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v) {
    return n(v, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v) {
    return n(v, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v) {
    return n(v, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v) {
    return n(v, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v) {
    return n(v, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v) {
    return n(v, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v) {
    return n(v, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v) {
    return n(v, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v) {
    return n(v, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v) {
    return n(v, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v) {
    return n(v, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v) {
    return n(v, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v) {
    return n(v, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v) {
    return n(v, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v) {
    return n(v, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v) {
    return n(v, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v) {
    return n(v, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v) {
    return n(v, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v) {
    return n(v, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v) {
    return b(v, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v) {
    return b(v, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v) {
    return b(v, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v) {
    return b(v, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v) {
    return b(v, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v) {
    return b(v, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v) {
    return b(v, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v) {
    return b(v, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v) {
    return b(v, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v) {
    return b(v, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v) {
    return b(v, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v) {
    return b(v, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v) {
    return b(v, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v) {
    return b(v, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v) {
    return b(v, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v) {
    return b(v, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v) {
    return b(v, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v) {
    return b(v, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v) {
    return b(v, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v) {
    return b(v, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v) {
    return b(v, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v) {
    return b(v, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v) {
    return b(v, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v) {
    return b(v, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v) {
    return b(v, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v) {
    return b(v, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v) {
    return b(v, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v) {
    return b(v, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v) {
    return b(v, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v) {
    return b(v, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v) {
    return b(v, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v) {
    return b(v, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v) {
    return new Typed(_gaurd, "address", v);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v) {
    return new Typed(_gaurd, "bool", !!v);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v) {
    return new Typed(_gaurd, "bytes", v);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v) {
    return new Typed(_gaurd, "string", v);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v, dynamic) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v, name) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v) {
    return new Typed(_gaurd, "overrides", Object.assign({}, v));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
}
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value) {
    let value = Typed.dereference(_value, "string");
    try {
      value = getAddress(value);
    } catch (error) {
      return this._throwError(error.message, _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
}
class AnonymousCoder extends Coder {
  coder;
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}
class ArrayCoder extends Coder {
  coder;
  length;
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
}
class FixedBytesCoder extends Coder {
  size;
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    defineProperties(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value) {
    let data = getBytesCopy(Typed.dereference(_value, this.type));
    if (data.length !== this.size) {
      this._throwError("incorrect data length", _value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
}
const Empty = new Uint8Array([]);
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
}
const BN_0$5 = BigInt(0);
const BN_1$1 = BigInt(1);
const BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class NumberCoder extends Coder {
  size;
  signed;
  constructor(size, signed2, localName) {
    const name = (signed2 ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    defineProperties(this, { size, signed: signed2 }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value) {
    let value = getBigInt(Typed.dereference(_value, this.type));
    let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_1$1)) {
        this._throwError("value out-of-bounds", _value);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_0$5 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  coders;
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b2) => a.address.localeCompare(b2.address));
  return result;
}
function authorizationify(auth) {
  return {
    address: getAddress(auth.address),
    nonce: getBigInt(auth.nonce != null ? auth.nonce : 0),
    chainId: getBigInt(auth.chainId != null ? auth.chainId : 0),
    signature: Signature.from(auth.signature)
  };
}
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}
const BN_0$4 = BigInt(0);
const BN_2$1 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const BLOB_SIZE = 4096 * 32;
function getKzgLibrary(kzg) {
  const blobToKzgCommitment = (blob) => {
    if ("computeBlobProof" in kzg) {
      if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
        return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));
      }
    } else if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
      return getBytes(kzg.blobToKzgCommitment(blob));
    }
    if ("blobToKZGCommitment" in kzg && typeof kzg.blobToKZGCommitment === "function") {
      return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  const computeBlobKzgProof = (blob, commitment) => {
    if ("computeBlobProof" in kzg && typeof kzg.computeBlobProof === "function") {
      return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));
    }
    if ("computeBlobKzgProof" in kzg && typeof kzg.computeBlobKzgProof === "function") {
      return kzg.computeBlobKzgProof(blob, commitment);
    }
    if ("computeBlobKZGProof" in kzg && typeof kzg.computeBlobKZGProof === "function") {
      return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  return { blobToKzgCommitment, computeBlobKzgProof };
}
function getVersionedHash(version2, hash2) {
  let versioned = version2.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha256$2(hash2).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleAuthorizationList(value, param) {
  try {
    if (!Array.isArray(value)) {
      throw new Error("authorizationList: invalid array");
    }
    const result = [];
    for (let i = 0; i < value.length; i++) {
      const auth = value[i];
      if (!Array.isArray(auth)) {
        throw new Error(`authorization[${i}]: invalid array`);
      }
      if (auth.length !== 6) {
        throw new Error(`authorization[${i}]: wrong length`);
      }
      if (!auth[1]) {
        throw new Error(`authorization[${i}]: null address`);
      }
      result.push({
        address: handleAddress(auth[1]),
        nonce: handleUint(auth[2], "nonce"),
        chainId: handleUint(auth[0], "chainId"),
        signature: Signature.from({
          yParity: handleNumber(auth[3], "yParity"),
          r: zeroPadValue(auth[4], 32),
          s: zeroPadValue(auth[5], 32)
        })
      });
    }
    return result;
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value, param) {
  if (_value === "0x") {
    return 0;
  }
  return getNumber(_value, param);
}
function handleUint(_value, param) {
  if (_value === "0x") {
    return BN_0$4;
  }
  const value = getBigInt(_value, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value, name) {
  const value = getBigInt(_value, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function formatAuthorizationList(value) {
  return value.map((a) => {
    return [
      formatNumber(a.chainId, "chainId"),
      a.address,
      formatNumber(a.nonce, "nonce"),
      formatNumber(a.signature.yParity, "yParity"),
      toBeArray(a.signature.r),
      toBeArray(a.signature.s)
    ];
  });
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0; i < value.length; i++) {
    assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy(data) {
  const fields = decodeRlp(data);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_0$4
  };
  if (fields.length === 6) {
    return tx;
  }
  const v = handleUint(fields[6], "v");
  const r = handleUint(fields[7], "r");
  const s = handleUint(fields[8], "s");
  if (r === BN_0$4 && s === BN_0$4) {
    tx.chainId = v;
  } else {
    let chainId = (v - BN_35) / BN_2$1;
    if (chainId < BN_0$4) {
      chainId = BN_0$4;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_0$4 || (v === BN_27 || v === BN_28), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_0$4;
  if (tx.chainId != BN_0$4) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_0$4) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v = BigInt(27 + sig.yParity);
  if (chainId !== BN_0$4) {
    v = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r = zeroPadValue(fields[1], 32);
  const s = zeroPadValue(fields[2], 32);
  const signature = Signature.from({ r, s, yParity });
  tx.signature = signature;
}
function _parseEip1559(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data) {
  let fields = decodeRlp(getBytes(data).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i = 0; i < fields[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b2) => b2.data),
          blobs.map((b2) => b2.commitment),
          blobs.map((b2) => b2.proof)
        ])
      ]);
    }
  }
  return concat(["0x03", encodeRlp(fields)]);
}
function _parseEip7702(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), "invalid field count for transaction type: 4", "data", hexlify(data));
  const tx = {
    type: 4,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    authorizationList: handleAuthorizationList(fields[9], "authorizationList")
  };
  if (fields.length === 10) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(10));
  return tx;
}
function _serializeEip7702(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatAuthorizationList(tx.authorizationList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x04", encodeRlp(fields)]);
}
class Transaction {
  #type;
  #to;
  #data;
  #nonce;
  #gasLimit;
  #gasPrice;
  #maxPriorityFeePerGas;
  #maxFeePerGas;
  #value;
  #chainId;
  #sig;
  #accessList;
  #maxFeePerBlobGas;
  #blobVersionedHashes;
  #kzg;
  #blobs;
  #auths;
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return this.#type;
  }
  set type(value) {
    switch (value) {
      case null:
        this.#type = null;
        break;
      case 0:
      case "legacy":
        this.#type = 0;
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        this.#type = 1;
        break;
      case 2:
      case "london":
      case "eip-1559":
        this.#type = 2;
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        this.#type = 3;
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        this.#type = 4;
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = this.#to;
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    this.#to = value == null ? null : getAddress(value);
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return this.#nonce;
  }
  set nonce(value) {
    this.#nonce = getNumber(value, "value");
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return this.#gasLimit;
  }
  set gasLimit(value) {
    this.#gasLimit = getBigInt(value);
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = this.#gasPrice;
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_0$4;
    }
    return value;
  }
  set gasPrice(value) {
    this.#gasPrice = value == null ? null : getBigInt(value, "gasPrice");
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = this.#maxPriorityFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, "maxPriorityFeePerGas");
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = this.#maxFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    this.#maxFeePerGas = value == null ? null : getBigInt(value, "maxFeePerGas");
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return this.#data;
  }
  set data(value) {
    this.#data = hexlify(value);
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return this.#value;
  }
  set value(value) {
    this.#value = getBigInt(value, "value");
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value);
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return this.#sig || null;
  }
  set signature(value) {
    this.#sig = value == null ? null : Signature.from(value);
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = this.#accessList || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    this.#accessList = value == null ? null : accessListify(value);
  }
  get authorizationList() {
    const value = this.#auths || null;
    if (value == null) {
      if (this.type === 4) {
        return [];
      }
    }
    return value;
  }
  set authorizationList(auths) {
    this.#auths = auths == null ? null : auths.map((a) => authorizationify(a));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = this.#maxFeePerBlobGas;
    if (value == null && this.type === 3) {
      return BN_0$4;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    this.#maxFeePerBlobGas = value == null ? null : getBigInt(value, "maxFeePerBlobGas");
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = this.#blobVersionedHashes;
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0; i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    this.#blobVersionedHashes = value;
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (this.#blobs == null) {
      return null;
    }
    return this.#blobs.map((b2) => Object.assign({}, b2));
  }
  set blobs(_blobs) {
    if (_blobs == null) {
      this.#blobs = null;
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i = 0; i < _blobs.length; i++) {
      const blob = _blobs[i];
      if (isBytesLike(blob)) {
        assert(this.#kzg, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data = getBytes(blob);
        assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
        if (data.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data);
          data = padded;
        }
        const commit = this.#kzg.blobToKzgCommitment(data);
        const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));
        blobs.push({
          data: hexlify(data),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob.commitment);
        blobs.push({
          data: hexlify(blob.data),
          commitment: commit,
          proof: hexlify(blob.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    this.#blobs = blobs;
    this.#blobVersionedHashes = versionedHashes;
  }
  get kzg() {
    return this.#kzg;
  }
  set kzg(kzg) {
    if (kzg == null) {
      this.#kzg = null;
    } else {
      this.#kzg = getKzgLibrary(kzg);
    }
  }
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    this.#type = null;
    this.#to = null;
    this.#nonce = 0;
    this.#gasLimit = BN_0$4;
    this.#gasPrice = null;
    this.#maxPriorityFeePerGas = null;
    this.#maxFeePerGas = null;
    this.#data = "0x";
    this.#value = BN_0$4;
    this.#chainId = BN_0$4;
    this.#sig = null;
    this.#accessList = null;
    this.#maxFeePerBlobGas = null;
    this.#blobVersionedHashes = null;
    this.#kzg = null;
    this.#blobs = null;
    this.#auths = null;
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(this.#getSerialized(true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  #getSerialized(signed2, sidecar) {
    assert(!signed2 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    const sig = signed2 ? this.signature : null;
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy(this, sig);
      case 1:
        return _serializeEip2930(this, sig);
      case 2:
        return _serializeEip1559(this, sig);
      case 3:
        return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
      case 4:
        return _serializeEip7702(this, sig);
    }
    assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return this.#getSerialized(true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return this.#getSerialized(false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (this.authorizationList && this.authorizationList.length) {
        types.push(4);
      } else if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s = (v) => {
      if (v == null) {
        return null;
      }
      return v.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s(this.gasLimit),
      gasPrice: s(this.gasPrice),
      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
      maxFeePerGas: s(this.maxFeePerGas),
      value: s(this.value),
      chainId: s(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return Transaction.from(_parseEip2930(payload));
        case 2:
          return Transaction.from(_parseEip1559(payload));
        case 3:
          return Transaction.from(_parseEip4844(payload));
        case 4:
          return Transaction.from(_parseEip7702(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new Transaction();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.authorizationList != null) {
      result.authorizationList = tx.authorizationList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
}
function hashAuthorization(auth) {
  assertArgument(typeof auth.address === "string", "invalid address for hashAuthorization", "auth.address", auth);
  return keccak256(concat([
    "0x05",
    encodeRlp([
      auth.chainId != null ? toBeArray(auth.chainId) : "0x",
      getAddress(auth.address),
      auth.nonce != null ? toBeArray(auth.nonce) : "0x"
    ])
  ]));
}
function verifyAuthorization(auth, sig) {
  return recoverAddress(hashAuthorization(auth), sig);
}
function id(value) {
  return keccak256(toUtf8Bytes(value));
}
var COMPRESSED$1 = "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";
const FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
const NSM_MAX = 4;
function decode_arithmetic(bytes2) {
  let pos = 0;
  function u16() {
    return bytes2[pos++] << 8 | bytes2[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes2[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = 2 ** N2;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N2; i++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b2 - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 2:
        return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 1:
        return offset + bytes2[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
}
function unsafe_atob(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
  let n2 = s.length;
  let ret = new Uint8Array(6 * n2 >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0; i < n2; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n2, next) {
  let v = Array(n2);
  for (let i = 0, x = 0; i < n2; i++) v[i] = x += signed(next());
  return v;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n2 = next();
    if (!n2) break;
    prev += x;
    for (let i = 0; i < n2; i++) {
      ret.push(prev + i);
    }
    prev += n2 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v = read_sorted(next);
    if (v.length) return v;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0) break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0) break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x) break;
    v.push(x);
  }
  return v;
}
function read_transposed(n2, w, next) {
  let m = Array(n2).fill().map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n2, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
}
function read_replacement_table(w, next) {
  let n2 = 1 + next();
  let m = read_transposed(n2, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand2(decode2([]), []);
  return ret;
  function decode2(Q) {
    let S2 = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i) => sorted[i]);
      if (cps.length) return decode2(cps);
    });
    return { S: S2, B, Q };
  }
  function expand2({ S: S2, B }, cps, saved) {
    if (S2 & 4 && saved === cps[cps.length - 1]) return;
    if (S2 & 2) saved = cps[cps.length - 1];
    if (S2 & 1) ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand2(br, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s) {
  let cps = [];
  for (let pos = 0, len = s.length; pos < len; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0; i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a, b2) {
  let n2 = a.length;
  let c = n2 - b2.length;
  for (let i = 0; c == 0 && i < n2; i++) c = a[i] - b2[i];
  return c;
}
var COMPRESSED = "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";
const S0 = 44032;
const L0 = 4352;
const V0 = 4449;
const T0 = 4519;
const L_COUNT = 19;
const V_COUNT = 21;
const T_COUNT = 28;
const N_COUNT = V_COUNT * T_COUNT;
const S_COUNT = L_COUNT * N_COUNT;
const S1 = S0 + S_COUNT;
const L1 = L0 + L_COUNT;
const V1 = V0 + V_COUNT;
const T1$1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
let SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;
function init$1() {
  let r = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a, b2] = cps;
      let bucket = RECOMP.get(a);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a, bucket);
      }
      bucket.set(b2, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a, b2) {
  if (a >= L0 && a < L1 && b2 >= V0 && b2 < V1) {
    return S0 + (a - L0) * N_COUNT + (b2 - V0) * T_COUNT;
  } else if (is_hangul(a) && b2 > T0 && b2 < T1$1 && (a - S0) % T_COUNT == 0) {
    return a + (b2 - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b2);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add2(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add2(L0 + l_index);
        add2(V0 + v_index);
        if (t_index > 0) add2(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add2(cp);
        }
      }
      if (!buf.length) break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1; i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j) break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc) break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
const HYPHEN = 45;
const STOP_CH = ".";
const FE0F = 65039;
const UNIQUE_PH = 1;
const Array_from = (x) => Array.from(x);
function group_has_cp(g, cp) {
  return g.P.has(cp) || g.Q.has(cp);
}
class Emoji extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
}
let MAPPED, IGNORED, CM, NSM, ESCAPE, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;
function init() {
  if (MAPPED) return;
  let r = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v) => v.forEach((x) => set.add(x));
  MAPPED = new Map(read_mapped(r));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  read_sorted_set();
  let chunks = read_sorted_arrays(r);
  let unrestricted = r();
  const read_chunked = () => {
    let set = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i) => {
    let N2 = read_array_while(r).map((x) => x + 96);
    if (N2.length) {
      let R = i >= unrestricted;
      N2[0] -= 32;
      N2 = str_from_cps(N2);
      if (R) N2 = `Restricted[${N2}]`;
      let P2 = read_chunked();
      let Q = read_chunked();
      let M = !r();
      return { N: N2, P: P2, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b2) => a - b2);
  wholes.forEach((cp, i) => {
    let d = r();
    let w = wholes[i] = d ? wholes[i - d] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g) => group_has_cp(g, cp));
      let rec = recs.find(({ G: G2 }) => gs.some((g) => G2.has(g)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x) => Array_from(x.G));
    for (let { G: G2, V: V2 } of recs) {
      let complement = new Set(union.filter((g) => !G2.has(g)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g of GROUPS) {
    for (let cp of g.P) add_to_union(cp);
    for (let cp of g.Q) add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r).map((v) => Emoji.from(v)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s) {
  return `"${s}"`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev) throw error_placement(`leading ${prev}`);
  let n2 = cps.length;
  let last = -1;
  for (let i = 1; i < n2; i++) {
    cp = cps[i];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i) throw error_placement(`${prev} + ${match}`);
      last = i + 1;
      prev = match;
    }
  }
  if (last == n2) throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0])) buf.push("");
  if (cps.length > max) {
    max >>= 1;
    cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
  }
  let prev = 0;
  let n2 = cps.length;
  for (let i = 0; i < n2; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n2)));
  return buf.join("");
}
function is_combining_mark(cp) {
  init();
  return CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
function ens_normalize(name) {
  return flatten(split(name, nfc, filter_fe0f));
}
function split(name, nf, ef) {
  if (!name) return [];
  init();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
      // codepoint, not substring!
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0])) throw error_placement("leading combining mark");
          for (let i = 1; i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g] = determine_group(unique);
          check_group(g, chars);
          check_whole(g, unique);
          type = g.N;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH) return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set);
      if (!maker.length) return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => group_has_cp(g, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => group_has_cp(g, cp));
    if (!gs.length) {
      if (!GROUPS.some((g) => group_has_cp(g, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1) break;
  }
  return groups;
}
function flatten(split2) {
  return split2.map(({ input, error, output: output2 }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split2.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g, cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (g.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e = decomposed2.length; i < e; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp; j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i; k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node) break;
    let { V } = node;
    if (V) {
      emoji = V;
      cps.length = pos;
    }
  }
  return emoji;
}
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  const bytes2 = toUtf8Bytes(ensNormalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes2.length; i++) {
    const d = bytes2[i];
    if (d === 46) {
      comps.push(checkComponent(bytes2.slice(last, i)));
      last = i + 1;
    }
  }
  assertArgument(last < bytes2.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes2.slice(last)));
  return comps;
}
function ensNormalize(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name);
  } catch (error) {
    assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
  }
}
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
  let result = Zeros;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name, _maxLength) {
  const length = _maxLength != null ? _maxLength : 63;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
function verifyMessage(message, sig) {
  const digest = hashMessage(message);
  return recoverAddress(digest, sig);
}
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0$3 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = getBytes(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return concat([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
const hexTrue = toBeHex(BN_1, 32);
const hexFalse = toBeHex(BN_0$3, 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value) {
    const value = getBigInt(_value, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes2 = getBytes(value, "domain.salt");
    assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes2);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT256, signed2 ? width - 1 : width);
      const boundsLower = signed2 ? (boundsUpper + BN_1) * BN__1 : BN_0$3;
      return function(_value) {
        const value = getBigInt(_value, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed2 ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes2 = getBytes(value);
        assertArgument(bytes2.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
function splitArray(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
class TypedDataEncoder {
  /**
   *  The primary type for the structured [[types]].
   *
   *  This is derived automatically from the [[types]], since no
   *  recursion is possible, once the DAG for the types is consturcted
   *  internally, the primary type must be the only remaining type with
   *  no parent nodes.
   */
  primaryType;
  #types;
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(this.#types);
  }
  #fullTypes;
  #encoderCache;
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types) {
    this.#fullTypes = /* @__PURE__ */ new Map();
    this.#encoderCache = /* @__PURE__ */ new Map();
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types = {};
    Object.keys(_types).forEach((type) => {
      types[type] = _types[type].map(({ name, type: type2 }) => {
        let { base, index } = splitArray(type2);
        if (base === "int" && !_types["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types["uint"]) {
          base = "uint256";
        }
        return { name, type: base + (index || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    this.#types = JSON.stringify(types);
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(""));
    }
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = this.#encoderCache.get(type);
    if (!encoder) {
      encoder = this.#getEncoder(type);
      this.#encoderCache.set(type, encoder);
    }
    return encoder;
  }
  #getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const array = splitArray(type).array;
    if (array) {
      const subtype = array.prefix;
      const subEncoder = this.getEncoder(subtype);
      return (value) => {
        assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
        let result = value.map(subEncoder);
        if (this.#fullTypes.has(subtype)) {
          result = result.map(keccak256);
        }
        return keccak256(concat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this.#fullTypes.get(type));
      return (value) => {
        const values = fields.map(({ name, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name]);
          if (this.#fullTypes.has(type2)) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return concat(values);
      };
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = this.#fullTypes.get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray(type).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v) => this._visit(array.prefix, v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new TypedDataEncoder(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return TypedDataEncoder.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return TypedDataEncoder.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type = domainFieldTypes[name];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type });
    }
    domainFields.sort((a, b2) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types, value) {
    return concat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types, value) {
    return keccak256(TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = TypedDataEncoder.from(types);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = TypedDataEncoder.from(types);
    types = encoder.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
}
function verifyTypedData(domain, types, value, signature) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);
}
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
const _kwVisib = "constant external internal payable private public pure view override";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
const SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
class TokenString {
  #offset;
  #tokens;
  get offset() {
    return this.#offset;
  }
  get length() {
    return this.#tokens.length - this.#offset;
  }
  constructor(tokens) {
    this.#offset = 0;
    this.#tokens = tokens.slice();
  }
  clone() {
    return new TokenString(this.#tokens);
  }
  reset() {
    this.#offset = 0;
  }
  #subTokenString(from = 0, to = 0) {
    return new TokenString(this.#tokens.slice(from, to).map((t) => {
      return Object.freeze(Object.assign({}, t, {
        match: t.match - from,
        linkBack: t.linkBack - from,
        linkNext: t.linkNext - from
      }));
    }));
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = this.#subTokenString(this.#offset + 1, top.match + 1);
    this.#offset = top.match + 1;
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (this.#offset < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(this.#subTokenString(this.#offset + 1, link));
      this.#offset = link;
    }
    this.#offset = top.match + 1;
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (this.#offset >= this.#tokens.length) {
      throw new Error("out-of-bounds");
    }
    return this.#tokens[this.#offset];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    this.#offset++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = this.#offset; i < this.#tokens.length; i++) {
      const token = this.#tokens[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
}
function lex(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t) => Object.freeze(t)));
}
function allowSingle(set, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
const _guard$2 = {};
const internal$1 = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
class ParamType {
  /**
   *  The local name of the parameter (or ``""`` if unbound)
   */
  name;
  /**
   *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
   *  ``"uint256[3][]"``)
   */
  type;
  /**
   *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
   */
  baseType;
  /**
   *  True if the parameters is indexed.
   *
   *  For non-indexable types this is ``null``.
   */
  indexed;
  /**
   *  The components for the tuple.
   *
   *  For non-tuple types this is ``null``.
   */
  components;
  /**
   *  The array length, or ``-1`` for dynamic-lengthed arrays.
   *
   *  For non-array types this is ``null``.
   */
  arrayLength;
  /**
   *  The type of each child in the array.
   *
   *  For non-array types this is ``null``.
   */
  arrayChildren;
  /**
   *  @private
   */
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    assertPrivate(guard, _guard$2, "ParamType");
    Object.defineProperty(this, internal$1, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c) => JSON.parse(c.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v) => _this.arrayChildren.walk(v, process));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v, i) => _this.components[i].walk(v, process));
    }
    return process(this.type, value);
  }
  #walkAsync(promises, value, process, setValue) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const childType = this.arrayChildren;
      const result2 = value.slice();
      result2.forEach((value2, index) => {
        childType.#walkAsync(promises, value2, process, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    if (this.isTuple()) {
      const components = this.components;
      let result2;
      if (Array.isArray(value)) {
        result2 = value.slice();
      } else {
        if (value == null || typeof value !== "object") {
          throw new Error("invalid tuple value");
        }
        result2 = components.map((param) => {
          if (!param.name) {
            throw new Error("cannot use object value with unnamed components");
          }
          if (!(param.name in value)) {
            throw new Error(`missing value for component ${param.name}`);
          }
          return value[param.name];
        });
      }
      if (result2.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      result2.forEach((value2, index) => {
        components[index].#walkAsync(promises, value2, process, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    const result = process(this.type, value);
    if (result.then) {
      promises.push((async function() {
        setValue(await result);
      })());
    } else {
      setValue(result);
    }
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process) {
    const promises = [];
    const result = [value];
    this.#walkAsync(promises, value, process, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ParamType.from(lex(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => ParamType.from(t));
        type2 = `tuple(${comps.map((c) => c.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new ParamType(_guard$2, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new ParamType(_guard$2, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new ParamType(_guard$2, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c) => ParamType.from(c)) : null;
      const tuple = new ParamType(_guard$2, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType(obj.type);
    return new ParamType(_guard$2, name || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal$1] === ParamTypeInternal;
  }
}
class Fragment {
  /**
   *  The type of the fragment.
   */
  type;
  /**
   *  The inputs for the fragment.
   */
  inputs;
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    assertPrivate(guard, _guard$2, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e) {
      }
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
}
class NamedFragment extends Fragment {
  /**
   *  The name of the fragment.
   */
  name;
  /**
   *  @private
   */
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
}
function joinParams(format, params) {
  return "(" + params.map((p) => p.format(format)).join(format === "full" ? ", " : ",") + ")";
}
class ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal$1, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard$2, name, inputs);
    }
    return new ErrorFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ErrorFragmentInternal;
  }
}
class EventFragment extends NamedFragment {
  /**
   *  Whether this event is anonymous.
   */
  anonymous;
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    Object.defineProperty(this, internal$1, { value: EventFragmentInternal });
    defineProperties(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new EventFragment(_guard$2, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return EventFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard$2, name, inputs, anonymous);
    }
    return new EventFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === EventFragmentInternal;
  }
}
class ConstructorFragment extends Fragment {
  /**
   *  Whether the constructor can receive an endowment.
   */
  payable;
  /**
   *  The recommended gas limit for deployment or ``null``.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    Object.defineProperty(this, internal$1, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format) {
    assert(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [`constructor${joinParams(format, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ConstructorFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard$2, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard$2, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ConstructorFragmentInternal;
  }
}
class FallbackFragment extends Fragment {
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    Object.defineProperty(this, internal$1, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FallbackFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard$2, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard$2, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard$2, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard$2, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FallbackFragmentInternal;
  }
}
class FunctionFragment extends NamedFragment {
  /**
   *  If the function is constant (e.g. ``pure`` or ``view`` functions).
   */
  constant;
  /**
   *  The returned types for the result of calling this function.
   */
  outputs;
  /**
   *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
   *  or ``pure``)
   */
  stateMutability;
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  /**
   *  The recommended gas limit to send when calling this function.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    Object.defineProperty(this, internal$1, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new FunctionFragment(_guard$2, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FunctionFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard$2, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard$2, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FunctionFragmentInternal;
  }
}
class StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal$1, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return StructFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard$2, name, inputs);
    }
    return new StructFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === StructFragmentInternal;
  }
}
const PanicReasons$1 = /* @__PURE__ */ new Map();
PanicReasons$1.set(0, "GENERIC_PANIC");
PanicReasons$1.set(1, "ASSERT_FALSE");
PanicReasons$1.set(17, "OVERFLOW");
PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
PanicReasons$1.set(34, "BAD_STORAGE_DATA");
PanicReasons$1.set(49, "STACK_UNDERFLOW");
PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(65, "OUT_OF_MEMORY");
PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data) {
    message = "execution reverted";
    const bytes2 = getBytes(data);
    data = hexlify(data);
    if (bytes2.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes2.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes2.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes2.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes2.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes2.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons$1.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data,
    reason,
    transaction,
    invocation,
    revert
  });
}
class AbiCoder {
  #getCoder(param) {
    if (param.isArray()) {
      return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
      return new TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);
    }
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
      return new FixedBytesCoder(size, param.name);
    }
    assertArgument(false, "invalid type", "type", param.type);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types) {
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types, values) {
    assertArgumentCount(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types, data, loose) {
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data) {
    return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
  }
}
class LogDescription {
  /**
   *  The matching fragment for the ``topic0``.
   */
  fragment;
  /**
   *  The name of the Event.
   */
  name;
  /**
   *  The full Event signature.
   */
  signature;
  /**
   *  The topic hash for the Event.
   */
  topic;
  /**
   *  The arguments passed into the Event with ``emit``.
   */
  args;
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature,
      topic,
      args
    });
  }
}
class TransactionDescription {
  /**
   *  The matching fragment from the transaction ``data``.
   */
  fragment;
  /**
   *  The name of the Function from the transaction ``data``.
   */
  name;
  /**
   *  The arguments passed to the Function from the transaction ``data``.
   */
  args;
  /**
   *  The full Function signature from the transaction ``data``.
   */
  signature;
  /**
   *  The selector for the Function from the transaction ``data``.
   */
  selector;
  /**
   *  The ``value`` (in wei) from the transaction.
   */
  value;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector,
      value
    });
  }
}
class ErrorDescription {
  /**
   *  The matching fragment.
   */
  fragment;
  /**
   *  The name of the Error.
   */
  name;
  /**
   *  The arguments passed to the Error with ``revert``.
   */
  args;
  /**
   *  The full Error signature.
   */
  signature;
  /**
   *  The selector for the Error.
   */
  selector;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector
    });
  }
}
class Indexed {
  /**
   *  The ``keccak256`` of the value logged.
   */
  hash;
  /**
   *  @_ignore:
   */
  _isIndexed;
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
  /**
   *  @_ignore:
   */
  constructor(hash2) {
    defineProperties(this, { hash: hash2, _isIndexed: true });
  }
}
const PanicReasons = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons[code.toString()]) {
        reason = PanicReasons[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};
class Interface {
  /**
   *  All the Contract ABI members (i.e. methods, events, errors, etc).
   */
  fragments;
  /**
   *  The Contract constructor.
   */
  deploy;
  /**
   *  The Fallback method, if any.
   */
  fallback;
  /**
   *  If receiving ether is supported.
   */
  receive;
  #errors;
  #events;
  #functions;
  //    #structs: Map<string, StructFragment>;
  #abiCoder;
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    this.#functions = /* @__PURE__ */ new Map();
    this.#errors = /* @__PURE__ */ new Map();
    this.#events = /* @__PURE__ */ new Map();
    const frags = [];
    for (const a of abi) {
      try {
        frags.push(Fragment.from(a));
      } catch (error) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    this.#abiCoder = this.getAbiCoder();
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = this.#functions;
          break;
        case "event":
          bucket = this.#events;
          break;
        case "error":
          bucket = this.#errors;
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f2) => f2.format(format));
    return abi;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi.map((j) => JSON.parse(j)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  #getFunction(key, values, forceUnique) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      for (const fragment of this.#functions.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#functions) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        const lastValue = values.length > 0 ? values[values.length - 1] : null;
        let valueLength = values.length;
        let allowOptions = true;
        if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
          allowOptions = false;
          valueLength--;
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs.length;
          if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (j >= inputs.length) {
              if (values[j].type === "overrides") {
                continue;
              }
              matching.splice(i, 1);
              break;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
        const lastArg = values[values.length - 1];
        if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
          matching.splice(0, 1);
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#functions.get(FunctionFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = this.#getFunction(key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!this.#getFunction(key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return this.#getFunction(key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names = Array.from(this.#functions.keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(this.#functions.get(name), i);
    }
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  #getEvent(key, values, forceUnique) {
    if (isHexString(key)) {
      const eventTopic = key.toLowerCase();
      for (const fragment of this.#events.values()) {
        if (eventTopic === fragment.topicHash) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#events) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        for (let i = matching.length - 1; i >= 0; i--) {
          if (matching[i].inputs.length < values.length) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#events.get(EventFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = this.#getEvent(key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!this.#getEvent(key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return this.#getEvent(key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names = Array.from(this.#events.keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(this.#events.get(name), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of this.#errors.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#errors) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = this.#errors.get(key);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names = Array.from(this.#errors.keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(this.#errors.get(name), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data) {
    return this.#abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this.#abiCoder.encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes2 = getBytesCopy(data);
    if (bytes2.length % 32 === 0) {
      try {
        return this.#abiCoder.decode(fragment.outputs, bytes2);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes2),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data, tx) {
    const data = getBytes(_data, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = this.#abiCoder.decode(ef.inputs, data.slice(4));
          error.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        this.#abiCoder.encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this.#abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this.#abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, concat(topics)) : null;
    const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data) {
    const hexData = hexlify(data);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new Interface(value.format("json"));
    }
    return new Interface(value);
  }
}
const BN_0$2 = BigInt(0);
function getValue(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
class FeeData {
  /**
   *  The gas price for legacy networks.
   */
  gasPrice;
  /**
   *  The maximum fee to pay per gas.
   *
   *  The base fee per gas is defined by the network and based on
   *  congestion, increasing the cost during times of heavy load
   *  and lowering when less busy.
   *
   *  The actual fee per gas will be the base fee for the block
   *  and the priority fee, up to the max fee per gas.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxFeePerGas;
  /**
   *  The additional amout to pay per gas to encourage a validator
   *  to include the transaction.
   *
   *  The purpose of this is to compensate the validator for the
   *  adjusted risk for including a given transaction.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxPriorityFeePerGas;
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    defineProperties(this, {
      gasPrice: getValue(gasPrice),
      maxFeePerGas: getValue(maxFeePerGas),
      maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if (req.authorizationList) {
    result.authorizationList = req.authorizationList.slice();
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b2) => {
      if (isBytesLike(b2)) {
        return hexlify(b2);
      }
      return Object.assign({}, b2);
    });
  }
  return result;
}
class Block {
  /**
   *  The provider connected to the block used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The block number, sometimes called the block height. This is a
   *  sequential number that is one higher than the parent block.
   */
  number;
  /**
   *  The block hash.
   *
   *  This hash includes all properties, so can be safely used to identify
   *  an exact set of block properties.
   */
  hash;
  /**
   *  The timestamp for this block, which is the number of seconds since
   *  epoch that this block was included.
   */
  timestamp;
  /**
   *  The block hash of the parent block.
   */
  parentHash;
  /**
   *  The hash tree root of the parent beacon block for the given
   *  execution block. See [[link-eip-4788]].
   */
  parentBeaconBlockRoot;
  /**
   *  The nonce.
   *
   *  On legacy networks, this is the random number inserted which
   *  permitted the difficulty target to be reached.
   */
  nonce;
  /**
   *  The difficulty target.
   *
   *  On legacy networks, this is the proof-of-work target required
   *  for a block to meet the protocol rules to be included.
   *
   *  On modern networks, this is a random number arrived at using
   *  randao.  @TODO: Find links?
   */
  difficulty;
  /**
   *  The total gas limit for this block.
   */
  gasLimit;
  /**
   *  The total gas used in this block.
   */
  gasUsed;
  /**
   *  The root hash for the global state after applying changes
   *  in this block.
   */
  stateRoot;
  /**
   *  The hash of the transaction receipts trie.
   */
  receiptsRoot;
  /**
   *  The total amount of blob gas consumed by the transactions
   *  within the block. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The running total of blob gas consumed in excess of the
   *  target, prior to the block. See [[link-eip-4844]].
   */
  excessBlobGas;
  /**
   *  The miner coinbase address, wihch receives any subsidies for
   *  including this block.
   */
  miner;
  /**
   *  The latest RANDAO mix of the post beacon state of
   *  the previous block.
   */
  prevRandao;
  /**
   *  Any extra data the validator wished to include.
   */
  extraData;
  /**
   *  The base fee per gas that all transactions in this block were
   *  charged.
   *
   *  This adjusts after each block, depending on how congested the network
   *  is.
   */
  baseFeePerGas;
  #transactions;
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block2, provider) {
    this.#transactions = block2.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    });
    defineProperties(this, {
      provider,
      hash: getValue(block2.hash),
      number: block2.number,
      timestamp: block2.timestamp,
      parentHash: block2.parentHash,
      parentBeaconBlockRoot: block2.parentBeaconBlockRoot,
      nonce: block2.nonce,
      difficulty: block2.difficulty,
      gasLimit: block2.gasLimit,
      gasUsed: block2.gasUsed,
      blobGasUsed: block2.blobGasUsed,
      excessBlobGas: block2.excessBlobGas,
      miner: block2.miner,
      prevRandao: getValue(block2.prevRandao),
      extraData: block2.extraData,
      baseFeePerGas: getValue(block2.baseFeePerGas),
      stateRoot: block2.stateRoot,
      receiptsRoot: block2.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return this.#transactions.map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = this.#transactions.slice();
    if (txs.length === 0) {
      return [];
    }
    assert(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash2, miner, prevRandao, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash: hash2,
      miner,
      prevRandao,
      nonce,
      number: number2,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return this.#transactions.length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = this.#transactions[indexOrHash];
    } else {
      const hash2 = indexOrHash.toLowerCase();
      for (const v of this.#transactions) {
        if (typeof v === "string") {
          if (v !== hash2) {
            continue;
          }
          tx = v;
          break;
        } else {
          if (v.hash !== hash2) {
            continue;
          }
          tx = v;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
}
class Log {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The transaction hash of the transaction this log occurred in. Use the
   *  [[Log-getTransaction]] to get the [[TransactionResponse]].
   */
  transactionHash;
  /**
   *  The block hash of the block this log occurred in. Use the
   *  [[Log-getBlock]] to get the [[Block]].
   */
  blockHash;
  /**
   *  The block number of the block this log occurred in. It is preferred
   *  to use the [[Block-hash]] when fetching the related [[Block]],
   *  since in the case of an orphaned block, the block at that height may
   *  have changed.
   */
  blockNumber;
  /**
   *  If the **Log** represents a block that was removed due to an orphaned
   *  block, this will be true.
   *
   *  This can only happen within an orphan event listener.
   */
  removed;
  /**
   *  The address of the contract that emitted this log.
   */
  address;
  /**
   *  The data included in this log when it was emitted.
   */
  data;
  /**
   *  The indexed topics included in this log when it was emitted.
   *
   *  All topics are included in the bloom filters, so they can be
   *  efficiently filtered using the [[Provider-getLogs]] method.
   */
  topics;
  /**
   *  The index within the block this log occurred at. This is generally
   *  not useful to developers, but can be used with the various roots
   *  to proof inclusion within a block.
   */
  index;
  /**
   *  The index within the transaction of this log.
   */
  transactionIndex;
  /**
   *  @_ignore:
   */
  constructor(log, provider) {
    this.provider = provider;
    const topics = Object.freeze(log.topics.slice());
    defineProperties(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block2 = await this.provider.getBlock(this.blockHash);
    assert(!!block2, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block2;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter(this);
  }
}
class TransactionReceipt {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The address the transaction was sent to.
   */
  to;
  /**
   *  The sender of the transaction.
   */
  from;
  /**
   *  The address of the contract if the transaction was directly
   *  responsible for deploying one.
   *
   *  This is non-null **only** if the ``to`` is empty and the ``data``
   *  was successfully executed as initcode.
   */
  contractAddress;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The index of this transaction within the block transactions.
   */
  index;
  /**
   *  The block hash of the [[Block]] this transaction was included in.
   */
  blockHash;
  /**
   *  The block number of the [[Block]] this transaction was included in.
   */
  blockNumber;
  /**
   *  The bloom filter bytes that represent all logs that occurred within
   *  this transaction. This is generally not useful for most developers,
   *  but can be used to validate the included logs.
   */
  logsBloom;
  /**
   *  The actual amount of gas used by this transaction.
   *
   *  When creating a transaction, the amount of gas that will be used can
   *  only be approximated, but the sender must pay the gas fee for the
   *  entire gas limit. After the transaction, the difference is refunded.
   */
  gasUsed;
  /**
   *  The gas used for BLObs. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The amount of gas used by all transactions within the block for this
   *  and all transactions with a lower ``index``.
   *
   *  This is generally not useful for developers but can be used to
   *  validate certain aspects of execution.
   */
  cumulativeGasUsed;
  /**
   *  The actual gas price used during execution.
   *
   *  Due to the complexity of [[link-eip-1559]] this value can only
   *  be caluclated after the transaction has been mined, snce the base
   *  fee is protocol-enforced.
   */
  gasPrice;
  /**
   *  The price paid per BLOB in gas. See [[link-eip-4844]].
   */
  blobGasPrice;
  /**
   *  The [[link-eip-2718]] transaction type.
   */
  type;
  //readonly byzantium!: boolean;
  /**
   *  The status of this transaction, indicating success (i.e. ``1``) or
   *  a revert (i.e. ``0``).
   *
   *  This is available in post-byzantium blocks, but some backends may
   *  backfill this value.
   */
  status;
  /**
   *  The root hash of this transaction.
   *
   *  This is no present and was only included in pre-byzantium blocks, but
   *  could be used to validate certain parts of the receipt.
   */
  root;
  #logs;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.#logs = Object.freeze(tx.logs.map((log) => {
      return new Log(log, provider);
    }));
    let gasPrice = BN_0$2;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return this.#logs;
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash2,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash2,
      index,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block2 = await this.provider.getBlock(this.blockHash);
    if (block2 == null) {
      throw new Error("TODO");
    }
    return block2;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
}
class TransactionResponse {
  /**
   *  The provider this is connected to, which will influence how its
   *  methods will resolve its async inspection methods.
   */
  provider;
  /**
   *  The block number of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockNumber;
  /**
   *  The blockHash of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockHash;
  /**
   *  The index within the block that this transaction resides at.
   */
  index;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The [[link-eip-2718]] transaction envelope type. This is
   *  ``0`` for legacy transactions types.
   */
  type;
  /**
   *  The receiver of this transaction.
   *
   *  If ``null``, then the transaction is an initcode transaction.
   *  This means the result of executing the [[data]] will be deployed
   *  as a new contract on chain (assuming it does not revert) and the
   *  address may be computed using [[getCreateAddress]].
   */
  to;
  /**
   *  The sender of this transaction. It is implicitly computed
   *  from the transaction pre-image hash (as the digest) and the
   *  [[signature]] using ecrecover.
   */
  from;
  /**
   *  The nonce, which is used to prevent replay attacks and offer
   *  a method to ensure transactions from a given sender are explicitly
   *  ordered.
   *
   *  When sending a transaction, this must be equal to the number of
   *  transactions ever sent by [[from]].
   */
  nonce;
  /**
   *  The maximum units of gas this transaction can consume. If execution
   *  exceeds this, the entries transaction is reverted and the sender
   *  is charged for the full amount, despite not state changes being made.
   */
  gasLimit;
  /**
   *  The gas price can have various values, depending on the network.
   *
   *  In modern networks, for transactions that are included this is
   *  the //effective gas price// (the fee per gas that was actually
   *  charged), while for transactions that have not been included yet
   *  is the [[maxFeePerGas]].
   *
   *  For legacy transactions, or transactions on legacy networks, this
   *  is the fee that will be charged per unit of gas the transaction
   *  consumes.
   */
  gasPrice;
  /**
   *  The maximum priority fee (per unit of gas) to allow a
   *  validator to charge the sender. This is inclusive of the
   *  [[maxFeeFeePerGas]].
   */
  maxPriorityFeePerGas;
  /**
   *  The maximum fee (per unit of gas) to allow this transaction
   *  to charge the sender.
   */
  maxFeePerGas;
  /**
   *  The [[link-eip-4844]] max fee per BLOb gas.
   */
  maxFeePerBlobGas;
  /**
   *  The data.
   */
  data;
  /**
   *  The value, in wei. Use [[formatEther]] to format this value
   *  as ether.
   */
  value;
  /**
   *  The chain ID.
   */
  chainId;
  /**
   *  The signature.
   */
  signature;
  /**
   *  The [[link-eip-2930]] access list for transaction types that
   *  support it, otherwise ``null``.
   */
  accessList;
  /**
   *  The [[link-eip-4844]] BLOb versioned hashes.
   */
  blobVersionedHashes;
  /**
   *  The [[link-eip-7702]] authorizations (if any).
   */
  authorizationList;
  #startBlock;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;
    this.#startBlock = -1;
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index, hash: hash2, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash2,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature,
      to,
      index,
      type,
      value: toJson(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block2 = this.provider.getBlock(blockNumber);
    if (block2 == null) {
      throw new Error("TODO");
    }
    return block2;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout == null ? 0 : _timeout;
    let startBlock = this.#startBlock;
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < this.#startBlock) {
          nextScan = this.#startBlock;
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block2 = await this.provider.getBlock(nextScan, true);
        if (block2 == null) {
          return;
        }
        for (const hash2 of block2) {
          if (hash2 === this.hash) {
            return;
          }
        }
        for (let i = 0; i < block2.length; i++) {
          const tx = await block2.getTransaction(i);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$2) {
              reason = "cancelled";
            }
            assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (confirms === 1 || await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c) => c());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new TransactionResponse(this, this.provider);
    tx.#startBlock = startBlock;
    return tx;
  }
}
function createOrphanedBlockFilter(block2) {
  return { orphan: "drop-block", hash: block2.hash, number: block2.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
}
class EventLog extends Log {
  /**
   *  The Contract Interface.
   */
  interface;
  /**
   *  The matching event.
   */
  fragment;
  /**
   *  The parsed arguments passed to the event by ``emit``.
   */
  args;
  /**
   * @_ignore:
   */
  constructor(log, iface, fragment) {
    super(log, log.provider);
    const args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties(this, { args, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class UndecodedEventLog extends Log {
  /**
   *  The error encounted when trying to decode the log.
   */
  error;
  /**
   * @_ignore:
   */
  constructor(log, error) {
    super(log, log.provider);
    defineProperties(this, { error });
  }
}
class ContractTransactionReceipt extends TransactionReceipt {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log) => {
      const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log, this.#iface, fragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return log;
    });
  }
}
class ContractTransactionResponse extends TransactionResponse {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
  }
}
class ContractUnknownEventPayload extends EventPayload {
  /**
   *  The log with no matching events.
   */
  log;
  /**
   *  @_event:
   */
  constructor(contract, listener, filter, log) {
    super(contract, listener, filter);
    defineProperties(this, { log });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class ContractEventPayload extends ContractUnknownEventPayload {
  /**
   *  @_ignore:
   */
  constructor(contract, listener, filter, fragment, _log) {
    super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const BN_0$1 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
class PreparedTopicFilter {
  #filter;
  fragment;
  constructor(contract, fragment, args) {
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    this.#filter = (async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v) => resolveAddress(v, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    })();
  }
  getTopicFilter() {
    return this.#filter;
  }
}
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_0$1, "overrides.value") === BN_0$1;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(...args) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract.interface.getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract.interface.getEventName(key),
    _contract: contract,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
const internal = Symbol.for("_ethersInternal_contract");
const internalValues = /* @__PURE__ */ new WeakMap();
function setInternal(contract, values) {
  internalValues.set(contract[internal], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e) => {
      if (e == null) {
        return null;
      }
      if (Array.isArray(e)) {
        return e.map(topicHashify);
      }
      return topicHashify(e);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider = getProvider(contract.runner);
  assert(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter = { address, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
let lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error) {
    }
    return !once;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {
  }
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
const passProperties = ["then"];
class BaseContract {
  /**
   *  The target to connect to.
   *
   *  This can be an address, ENS name or any [[Addressable]], such as
   *  another contract. To get the resovled address, use the ``getAddress``
   *  method.
   */
  target;
  /**
   *  The contract Interface.
   */
  interface;
  /**
   *  The connected runner. This is generally a [[Provider]] or a
   *  [[Signer]], which dictates what operations are supported.
   *
   *  For example, a **Contract** connected to a [[Provider]] may
   *  only execute read-only operations.
   */
  runner;
  /**
   *  All the Events available on this contract.
   */
  filters;
  /**
   *  @_ignore:
   */
  [internal];
  /**
   *  The fallback or receive function if any.
   */
  fallback;
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi, runner, _deployTx) {
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider = getProvider(this.runner);
    assert(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider = getProvider(this.runner);
    assert(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve(this);
          }
          provider.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash2) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider = getProvider(this.runner);
    assert(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter)).map((log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return new Log(log, provider);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi) {
    class CustomContract extends BaseContract {
      constructor(address, runner = null) {
        super(address, abi, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi, runner);
    return contract;
  }
}
function _ContractBase() {
  return BaseContract;
}
class Contract extends _ContractBase() {
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
class MulticoinProviderPlugin {
  /**
   *  The name.
   */
  name;
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data) {
    throw new Error("unsupported coin");
  }
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
class EnsResolver {
  /**
   *  The connected provider.
   */
  provider;
  /**
   *  The address of the resolver.
   */
  address;
  /**
   *  The name this resolver was resolved against.
   */
  name;
  // For EIP-2544 names, the ancestor that provided the resolver
  #supports2544;
  #resolver;
  constructor(provider, address, name) {
    defineProperties(this, { provider, address, name });
    this.#supports2544 = null;
    this.#resolver = new Contract(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider);
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (this.#supports2544 == null) {
      this.#supports2544 = (async () => {
        try {
          return await this.#resolver.supportsInterface("0x9061b923");
        } catch (error) {
          if (isError(error, "CALL_EXCEPTION")) {
            return false;
          }
          this.#supports2544 = null;
          throw error;
        }
      })();
    }
    return await this.#supports2544;
  }
  async #fetch(funcName, params) {
    params = (params || []).slice();
    const iface = this.#resolver.interface;
    params.unshift(namehash(this.name));
    let fragment = null;
    if (await this.supportsWildcard()) {
      fragment = iface.getFunction(funcName);
      assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
        info: { funcName }
      });
      params = [
        dnsEncode(this.name, 255),
        iface.encodeFunctionData(fragment, params)
      ];
      funcName = "resolve(bytes,bytes)";
    }
    params.push({
      enableCcipRead: true
    });
    try {
      const result = await this.#resolver[funcName](...params);
      if (fragment) {
        return iface.decodeFunctionResult(fragment, result)[0];
      }
      return result;
    } catch (error) {
      if (!isError(error, "CALL_EXCEPTION")) {
        throw error;
      }
    }
    return null;
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await this.#fetch("addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error) {
        if (isError(error, "CALL_EXCEPTION")) {
          return null;
        }
        throw error;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data2 = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data2, 20)) {
        return getAddress(data2);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data = await this.#fetch("addr(bytes32,uint)", [coinType]);
    if (data == null || data === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data);
    if (address != null) {
      return address;
    }
    assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key) {
    const data = await this.#fetch("text(bytes32,string)", [key]);
    if (data == null || data === "0x") {
      return null;
    }
    return data;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data = await this.#fetch("contenthash(bytes32)");
    if (data == null || data === "0x") {
      return null;
    }
    const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i = 0; i < matchers.length; i++) {
        const match = avatar.match(matchers[i]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract = new Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error2) {
                const bytes2 = response.body;
                if (bytes2) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes2) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider) {
    const network = await provider.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  static async #getResolver(provider, name) {
    const ensAddr = await EnsResolver.getEnsAddress(provider);
    try {
      const contract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], provider);
      const addr = await contract.resolver(namehash(name), {
        enableCcipRead: true
      });
      if (addr === ZeroAddress) {
        return null;
      }
      return addr;
    } catch (error) {
      throw error;
    }
    return null;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider, name) {
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await EnsResolver.#getResolver(provider, currentName);
      if (addr != null) {
        const resolver = new EnsResolver(provider, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
}
const BN_0 = BigInt(0);
function allowNull(format, nullValue) {
  return (function(value) {
    if (value == null) {
      return nullValue;
    }
    return format(value);
  });
}
function arrayOf(format, allowNull2) {
  return ((array) => {
    if (allowNull2 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format(i));
  });
}
function object(format, altNames) {
  return ((value) => {
    const result = {};
    for (const key in format) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format[key](value[srcKey]);
        if (nv !== void 0) {
          result[key] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  });
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
const _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
const _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
const _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
const _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_0) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object({
    hash: formatHash,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull(getNumber, void 0),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    authorizationList: allowNull(arrayOf((v) => {
      let sig;
      if (v.signature) {
        sig = v.signature;
      } else {
        let yParity = v.yParity;
        if (yParity === "0x1b") {
          yParity = 0;
        } else if (yParity === "0x1c") {
          yParity = 1;
        }
        sig = Object.assign({}, v, { yParity });
      }
      return {
        address: getAddress(v.address),
        chainId: getBigInt(v.chainId),
        nonce: getBigInt(v.nonce),
        signature: Signature.from(sig)
      };
    }, false), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature.from(value.signature);
  } else {
    result.signature = Signature.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
    result.blockHash = null;
  }
  return result;
}
const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class NetworkPlugin {
  /**
   *  The name of the plugin.
   *
   *  It is recommended to use reverse-domain-notation, which permits
   *  unique names with a known authority as well as hierarchal entries.
   */
  name;
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new NetworkPlugin(this.name);
  }
}
class GasCostPlugin extends NetworkPlugin {
  /**
   *  The block number to treat these values as valid from.
   *
   *  This allows a hardfork to have updated values included as well as
   *  mulutiple hardforks to be supported.
   */
  effectiveBlock;
  /**
   *  The transactions base fee.
   */
  txBase;
  /**
   *  The fee for creating a new account.
   */
  txCreate;
  /**
   *  The fee per zero-byte in the data.
   */
  txDataZero;
  /**
   *  The fee per non-zero-byte in the data.
   */
  txDataNonzero;
  /**
   *  The fee per storage key in the [[link-eip-2930]] access list.
   */
  txAccessListStorageKey;
  /**
   *  The fee per address in the [[link-eip-2930]] access list.
   */
  txAccessListAddress;
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    const props = { effectiveBlock };
    function set(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set("txBase", 21e3);
    set("txCreate", 32e3);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}
class EnsPlugin extends NetworkPlugin {
  /**
   *  The ENS Registrty Contract address.
   */
  address;
  /**
   *  The chain ID that the ENS contract lives on.
   */
  targetNetwork;
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    defineProperties(this, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}
class FeeDataNetworkPlugin extends NetworkPlugin {
  #feeDataFunc;
  /**
   *  The fee data function provided to the constructor.
   */
  get feeDataFunc() {
    return this.#feeDataFunc;
  }
  /**
   *  Creates a new **FeeDataNetworkPlugin**.
   */
  constructor(feeDataFunc) {
    super("org.ethers.plugins.network.FeeData");
    this.#feeDataFunc = feeDataFunc;
  }
  /**
   *  Resolves to the fee data.
   */
  async getFeeData(provider) {
    return await this.#feeDataFunc(provider);
  }
  clone() {
    return new FeeDataNetworkPlugin(this.#feeDataFunc);
  }
}
class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  #url;
  #processFunc;
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return this.#url;
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return this.#processFunc;
  }
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    this.#url = url;
    this.#processFunc = processFunc;
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
const Networks = /* @__PURE__ */ new Map();
class Network {
  #name;
  #chainId;
  #plugins;
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name, chainId) {
    this.#name = name;
    this.#chainId = getBigInt(chainId);
    this.#plugins = /* @__PURE__ */ new Map();
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return this.#name;
  }
  set name(value) {
    this.#name = value;
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value, "chainId");
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename) {
    return this.plugins.filter((p) => p.name.split("#")[0] === basename);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i = 2; i < tx.data.length; i += 2) {
        if (tx.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom = new Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
}
function parseUnits(_value, decimals) {
  const value = String(_value);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
    }
  });
}
let injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin());
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}
function copy$2(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class PollingBlockSubscriber {
  #provider;
  #poller;
  #interval;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#poller = null;
    this.#interval = 4e3;
    this.#blockNumber = -2;
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return this.#interval;
  }
  set pollingInterval(value) {
    this.#interval = value;
  }
  async #poll() {
    try {
      const blockNumber = await this.#provider.getBlockNumber();
      if (this.#blockNumber === -2) {
        this.#blockNumber = blockNumber;
        return;
      }
      if (blockNumber !== this.#blockNumber) {
        for (let b2 = this.#blockNumber + 1; b2 <= blockNumber; b2++) {
          if (this.#poller == null) {
            return;
          }
          await this.#provider.emit("block", b2);
        }
        this.#blockNumber = blockNumber;
      }
    } catch (error) {
    }
    if (this.#poller == null) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
  }
  start() {
    if (this.#poller) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    this.#poll();
  }
  stop() {
    if (!this.#poller) {
      return;
    }
    this.#provider._clearTimeout(this.#poller);
    this.#poller = null;
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
}
class OnBlockSubscriber {
  #provider;
  #poll;
  #running;
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#running = false;
    this.#poll = (blockNumber) => {
      this._poll(blockNumber, this.#provider);
    };
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
    this.#provider.on("block", this.#poll);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poll);
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
class PollingBlockTagSubscriber extends OnBlockSubscriber {
  #tag;
  #lastBlock;
  constructor(provider, tag) {
    super(provider);
    this.#tag = tag;
    this.#lastBlock = -2;
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#lastBlock = -2;
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider) {
    const block2 = await provider.getBlock(this.#tag);
    if (block2 == null) {
      return;
    }
    if (this.#lastBlock === -2) {
      this.#lastBlock = block2.number;
    } else if (block2.number > this.#lastBlock) {
      provider.emit(this.#tag, block2.number);
      this.#lastBlock = block2.number;
    }
  }
}
class PollingOrphanSubscriber extends OnBlockSubscriber {
  #filter;
  constructor(provider, filter) {
    super(provider);
    this.#filter = copy$2(filter);
  }
  async _poll(blockNumber, provider) {
    throw new Error("@TODO");
  }
}
class PollingTransactionSubscriber extends OnBlockSubscriber {
  #hash;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider, hash2) {
    super(provider);
    this.#hash = hash2;
  }
  async _poll(blockNumber, provider) {
    const tx = await provider.getTransactionReceipt(this.#hash);
    if (tx) {
      provider.emit(this.#hash, tx);
    }
  }
}
class PollingEventSubscriber {
  #provider;
  #filter;
  #poller;
  #running;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = copy$2(filter);
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#blockNumber = -2;
  }
  async #poll(blockNumber) {
    if (this.#blockNumber === -2) {
      return;
    }
    const filter = copy$2(this.#filter);
    filter.fromBlock = this.#blockNumber + 1;
    filter.toBlock = blockNumber;
    const logs = await this.#provider.getLogs(filter);
    if (logs.length === 0) {
      if (this.#blockNumber < blockNumber - 60) {
        this.#blockNumber = blockNumber - 60;
      }
      return;
    }
    for (const log of logs) {
      this.#provider.emit(this.#filter, log);
      this.#blockNumber = log.blockNumber;
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    if (this.#blockNumber === -2) {
      this.#provider.getBlockNumber().then((blockNumber) => {
        this.#blockNumber = blockNumber;
      });
    }
    this.#provider.on("block", this.#poller);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
}
const BN_2 = BigInt(2);
const MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k, v) => {
    if (v == null) {
      return "null";
    }
    if (typeof v === "bigint") {
      return `bigint:${v.toString()}`;
    }
    if (typeof v === "string") {
      return v.toLowerCase();
    }
    if (typeof v === "object" && !Array.isArray(v)) {
      const keys = Object.keys(v);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v[key];
        return accum;
      }, {});
    }
    return v;
  });
}
class UnmanagedSubscriber {
  /**
   *  The name fof the event.
   */
  name;
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
}
function copy$1(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event, provider) {
  if (_event == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event)) {
    _event = { topics: _event };
  }
  if (typeof _event === "string") {
    switch (_event) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event, tag: _event };
      }
    }
  }
  if (isHexString(_event, 32)) {
    const hash2 = _event.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash: hash2 }), hash: hash2 };
  }
  if (_event.orphan) {
    const event = _event;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy$1(event) };
  }
  if (_event.address || _event.topics) {
    const event = _event;
    const filter = {
      topics: (event.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter.address = concisify(addresses.map((a) => a.toLowerCase()));
    }
    return { filter, tag: getTag("event", filter), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const defaultOptions$1 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class AbstractProvider {
  #subs;
  #plugins;
  // null=unpaused, true=paused+dropWhilePaused, false=paused
  #pausedState;
  #destroyed;
  #networkPromise;
  #anyNetwork;
  #performCache;
  // The most recent block number if running an event or -1 if no "block" event
  #lastBlockNumber;
  #nextTimer;
  #timers;
  #disableCcipRead;
  #options;
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network, options) {
    this.#options = Object.assign({}, defaultOptions$1, options || {});
    if (_network === "any") {
      this.#anyNetwork = true;
      this.#networkPromise = null;
    } else if (_network) {
      const network = Network.from(_network);
      this.#anyNetwork = false;
      this.#networkPromise = Promise.resolve(network);
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      this.#anyNetwork = false;
      this.#networkPromise = null;
    }
    this.#lastBlockNumber = -1;
    this.#performCache = /* @__PURE__ */ new Map();
    this.#subs = /* @__PURE__ */ new Map();
    this.#plugins = /* @__PURE__ */ new Map();
    this.#pausedState = null;
    this.#destroyed = false;
    this.#nextTimer = 1;
    this.#timers = /* @__PURE__ */ new Map();
    this.#disableCcipRead = false;
  }
  get pollingInterval() {
    return this.#options.pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return this.#disableCcipRead;
  }
  set disableCcipRead(value) {
    this.#disableCcipRead = !!value;
  }
  // Shares multiple identical requests made during the same 250ms
  async #perform(req) {
    const timeout = this.#options.cacheTimeout;
    if (timeout < 0) {
      return await this._perform(req);
    }
    const tag = getTag(req.method, req);
    let perform = this.#performCache.get(tag);
    if (!perform) {
      perform = this._perform(req);
      this.#performCache.set(tag, perform);
      setTimeout(() => {
        if (this.#performCache.get(tag) === perform) {
          this.#performCache.delete(tag);
        }
      }, timeout);
    }
    return await perform;
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data = calldata.toLowerCase();
    const errorMessages = [];
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const href = url.replace("{sender}", sender).replace("{data}", data);
      const request = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request.body = { data, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
      let errorMessage = "unknown error";
      let resp;
      try {
        resp = await request.send();
      } catch (error) {
        errorMessages.push(error.message);
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error } });
        continue;
      }
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
      } catch (error) {
      }
      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network) {
    return new Block(formatBlock(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network) {
    return new Log(formatLog(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber(await this.#perform({ method: "getBlockNumber" }), "%response");
    if (this.#lastBlockNumber >= 0) {
      this.#lastBlockNumber = blockNumber;
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (this.#lastBlockNumber >= 0) {
        return toQuantity(this.#lastBlockNumber + blockTag);
      }
      return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        return concisify(t.map((t2) => t2.toLowerCase()));
      }
      return t.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a) => typeof a !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request) {
    const request = copyRequest(_request);
    const promises = [];
    ["to", "from"].forEach((key) => {
      if (request[key] == null) {
        return;
      }
      const addr = resolveAddress(request[key], this);
      if (isPromise(addr)) {
        promises.push((async function() {
          request[key] = await addr;
        })());
      } else {
        request[key] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise(blockTag)) {
        promises.push((async function() {
          request.blockTag = await blockTag;
        })());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return (async function() {
        await Promise.all(promises);
        return request;
      })();
    }
    return request;
  }
  async getNetwork() {
    if (this.#networkPromise == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error) {
          if (this.#networkPromise === detectNetwork) {
            this.#networkPromise = null;
          }
          throw error;
        }
      })();
      this.#networkPromise = detectNetwork;
      return (await detectNetwork).clone();
    }
    const networkPromise = this.#networkPromise;
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (this.#anyNetwork) {
        this.emit("network", actual, expected);
        if (this.#networkPromise === networkPromise) {
          this.#networkPromise = Promise.resolve(actual);
        }
      } else {
        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties({
        _block: this.#getBlock("latest", false),
        gasPrice: (async () => {
          try {
            const value = await this.#perform({ method: "getGasPrice" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await this.#perform({ method: "getPriorityFee" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block2 = this._wrapBlock(_block, network);
      if (block2 && block2.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block2.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise(tx)) {
      tx = await tx;
    }
    return getBigInt(await this.#perform({
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async #call(tx, blockTag, attempt) {
    assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
      reason: "TOO_MANY_REDIRECTS",
      transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
    });
    const transaction = copyRequest(tx);
    try {
      return hexlify(await this._perform({ method: "call", transaction, blockTag }));
    } catch (error) {
      if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
        const data = error.data;
        const txSender = await resolveAddress(transaction.to, this);
        let ccipArgs;
        try {
          ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
        } catch (error2) {
          assert(false, error2.message, "OFFCHAIN_FAULT", {
            reason: "BAD_DATA",
            transaction,
            info: { data }
          });
        }
        assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
          action: "call",
          data,
          reason: "OffchainLookup",
          transaction,
          invocation: null,
          revert: {
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            name: "OffchainLookup",
            args: ccipArgs.errorArgs
          }
        });
        const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
        assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
          reason: "FETCH_FAILED",
          transaction,
          info: { data: error.data, errorArgs: ccipArgs.errorArgs }
        });
        const tx2 = {
          to: txSender,
          data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
        };
        this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
        try {
          const result = await this.#call(tx2, blockTag, attempt + 1);
          this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
          return result;
        } catch (error2) {
          this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
          throw error2;
        }
      }
      throw error;
    }
  }
  async #checkNetwork(promise) {
    const { value } = await resolveProperties({
      network: this.getNetwork(),
      value: promise
    });
    return value;
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  // Account
  async #getAccountValue(request, _address, _blockTag) {
    let address = this._getAddress(_address);
    let blockTag = this._getBlockTag(_blockTag);
    if (typeof address !== "string" || typeof blockTag !== "string") {
      [address, blockTag] = await Promise.all([address, blockTag]);
    }
    return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));
  }
  async getBalance(address, blockTag) {
    return getBigInt(await this.#getAccountValue({ method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber(await this.#getAccountValue({ method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify(await this.#getAccountValue({ method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await this.#getAccountValue({ method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash2, network } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash2) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  async #getBlock(block2, includeTransactions) {
    if (isHexString(block2, 32)) {
      return await this.#perform({
        method: "getBlock",
        blockHash: block2,
        includeTransactions
      });
    }
    let blockTag = this._getBlockTag(block2);
    if (typeof blockTag !== "string") {
      blockTag = await blockTag;
    }
    return await this.#perform({
      method: "getBlock",
      blockTag,
      includeTransactions
    });
  }
  // Queries
  async getBlock(block2, prefetchTxs) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#getBlock(block2, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash2) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransaction", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash2) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransactionReceipt", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await this.#perform({ method: "getTransaction", hash: hash2 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash2) {
    const { result } = await resolveProperties({
      network: this.getNetwork(),
      result: this.#perform({ method: "getTransactionResult", hash: hash2 })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  // Bloom-filter Queries
  async getLogs(_filter) {
    let filter = this._getFilter(_filter);
    if (isPromise(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getLogs", filter })
    });
    return params.map((p) => this._wrapLog(p, network));
  }
  // ENS
  _getProvider(chainId) {
    assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress(address);
    const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check = await this.resolveName(name);
      if (check !== address) {
        return null;
      }
      return name;
    } catch (error) {
      if (isError(error, "BAD_DATA") && error.value === "0x") {
        return null;
      }
      if (isError(error, "CALL_EXCEPTION")) {
        return null;
      }
      throw error;
    }
    return null;
  }
  async waitForTransaction(hash2, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash2);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = (async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash2);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error) {
          console.log("EEE", error);
        }
        this.once("block", listener);
      });
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = this.#timers.get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    this.#timers.delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = this.#nextTimer++;
    const func = () => {
      this.#timers.delete(timerId);
      _func();
    };
    if (this.paused) {
      this.#timers.set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      this.#timers.set(timerId, { timer, func, time: getTime() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub of this.#subs.values()) {
      func(sub.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub.type);
      case "event":
        return new PollingEventSubscriber(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of this.#subs.values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (this.#pausedState != null) {
          newSub.pause(this.#pausedState);
        }
        break;
      }
    }
  }
  async #hasSub(event, emitArgs) {
    let sub = await getSubscription(event, this);
    if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
      sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
    }
    return this.#subs.get(sub.tag) || null;
  }
  async #getSub(event) {
    const subscription = await getSubscription(event, this);
    const tag = subscription.tag;
    let sub = this.#subs.get(tag);
    if (!sub) {
      const subscriber = this._getSubscriber(subscription);
      const addressableMap = /* @__PURE__ */ new WeakMap();
      const nameMap = /* @__PURE__ */ new Map();
      sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
      this.#subs.set(tag, sub);
    }
    return sub;
  }
  async on(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub = await this.#hasSub(event, args);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once }) => {
      const payload = new EventPayload(this, once ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error) {
      }
      return !once;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners } of this.#subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners } of this.#subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await this.#hasSub(event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await this.#getSub(event);
      if (started) {
        subscriber.stop();
      }
      this.#subs.delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of this.#subs) {
        if (started) {
          subscriber.stop();
        }
        this.#subs.delete(tag);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of this.#timers.keys()) {
      this._clearTimeout(timerId);
    }
    this.#destroyed = true;
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return this.#pausedState != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    this.#lastBlockNumber = -1;
    if (this.#pausedState != null) {
      if (this.#pausedState == !!dropWhilePaused) {
        return;
      }
      assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s) => s.pause(dropWhilePaused));
    this.#pausedState = !!dropWhilePaused;
    for (const timer of this.#timers.values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (this.#pausedState == null) {
      return;
    }
    this._forEachSubscriber((s) => s.resume());
    this.#pausedState = null;
    for (const timer of this.#timers.values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime();
      setTimeout(timer.func, timeout);
    }
  }
}
function _parseString(result, start) {
  try {
    const bytes2 = _parseBytes(result, start);
    if (bytes2) {
      return toUtf8String(bytes2);
    }
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error) {
  }
  return null;
}
function numPad(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
const empty = new Uint8Array([]);
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data = getBytes(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return concat(result);
}
const zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data, 0, 32);
  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data, 32, 64));
    const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data, urlsOffset + 32);
    for (let u = 0; u < urlsLength; u++) {
      const url = _parseString(urlsData, u * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data, 96, 100);
  try {
    const extraData = _parseBytes(data, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
  return result;
}
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}
class AbstractSigner {
  /**
   *  The provider this signer is connected to.
   */
  provider;
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    defineProperties(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          if (pop.authorizationList && pop.authorizationList.length) {
            pop.type = 4;
          } else {
            pop.type = 2;
          }
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async populateAuthorization(_auth) {
    const auth = Object.assign({}, _auth);
    if (auth.chainId == null) {
      auth.chainId = (await checkProvider(this, "getNetwork").getNetwork()).chainId;
    }
    if (auth.nonce == null) {
      auth.nonce = await this.getNonce();
    }
    return auth;
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
  // @TODO: in v7 move this to be abstract
  authorize(authorization) {
    assert(false, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
  }
}
class VoidSigner extends AbstractSigner {
  /**
   *  The signer address.
   */
  address;
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  constructor(address, provider) {
    super(provider);
    defineProperties(this, { address });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
  #throwUnsupported(suffix, operation) {
    assert(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
  }
  async signTransaction(tx) {
    this.#throwUnsupported("transactions", "signTransaction");
  }
  async signMessage(message) {
    this.#throwUnsupported("messages", "signMessage");
  }
  async signTypedData(domain, types, value) {
    this.#throwUnsupported("typed-data", "signTypedData");
  }
}
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class FilterIdSubscriber {
  #provider;
  #filterIdPromise;
  #poller;
  #running;
  #network;
  #hault;
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#filterIdPromise = null;
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#network = null;
    this.#hault = false;
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider, result) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider) {
    throw new Error("subclasses must override this");
  }
  async #poll(blockNumber) {
    try {
      if (this.#filterIdPromise == null) {
        this.#filterIdPromise = this._subscribe(this.#provider);
      }
      let filterId = null;
      try {
        filterId = await this.#filterIdPromise;
      } catch (error) {
        if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
          throw error;
        }
      }
      if (filterId == null) {
        this.#filterIdPromise = null;
        this.#provider._recoverSubscriber(this, this._recover(this.#provider));
        return;
      }
      const network = await this.#provider.getNetwork();
      if (!this.#network) {
        this.#network = network;
      }
      if (this.#network.chainId !== network.chainId) {
        throw new Error("chaid changed");
      }
      if (this.#hault) {
        return;
      }
      const result = await this.#provider.send("eth_getFilterChanges", [filterId]);
      await this._emitResults(this.#provider, result);
    } catch (error) {
      console.log("@TODO", error);
    }
    this.#provider.once("block", this.#poller);
  }
  #teardown() {
    const filterIdPromise = this.#filterIdPromise;
    if (filterIdPromise) {
      this.#filterIdPromise = null;
      filterIdPromise.then((filterId) => {
        if (this.#provider.destroyed) {
          return;
        }
        this.#provider.send("eth_uninstallFilter", [filterId]);
      });
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#hault = true;
    this.#teardown();
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#teardown();
    }
    this.#provider.off("block", this.#poller);
  }
  resume() {
    this.start();
  }
}
class FilterIdEventSubscriber extends FilterIdSubscriber {
  #event;
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider, filter) {
    super(provider);
    this.#event = copy(filter);
  }
  _recover(provider) {
    return new PollingEventSubscriber(provider, this.#event);
  }
  async _subscribe(provider) {
    const filterId = await provider.send("eth_newFilter", [this.#event]);
    return filterId;
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit(this.#event, provider._wrapLog(result, provider._network));
    }
  }
}
class FilterIdPendingSubscriber extends FilterIdSubscriber {
  async _subscribe(provider) {
    return await provider.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit("pending", result);
    }
  }
}
const Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall$2(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
const defaultOptions = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class JsonRpcSigner extends AbstractSigner {
  address;
  constructor(provider, address) {
    super(provider);
    address = getAddress(address);
    defineProperties(this, { address });
  }
  connect(provider) {
    assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises = [];
    if (tx.from) {
      const _from = tx.from;
      promises.push((async () => {
        const from = await resolveAddress(_from, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to = tx.to;
      promises.push((async () => {
        tx.to = await resolveAddress(_to, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash2 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash2);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error) {
          if (isError(error, "CANCELLED") || isError(error, "BAD_DATA") || isError(error, "NETWORK_ERROR") || isError(error, "UNSUPPORTED_OPERATION")) {
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash2;
            reject(error);
            return;
          }
          if (isError(error, "INVALID_ARGUMENT")) {
            invalids++;
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash2;
            if (invalids > 10) {
              reject(error);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from = await resolveAddress(tx.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain, types, _value) {
    const value = deepCopy(_value);
    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value2) => {
      const address = await resolveAddress(value2);
      assertArgument(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
}
class JsonRpcApiProvider extends AbstractProvider {
  #options;
  // The next ID to use for the JSON-RPC ID field
  #nextId;
  // Payloads are queued and triggered in batches using the drainTimer
  #payloads;
  #drainTimer;
  #notReady;
  #network;
  #pendingDetectNetwork;
  #scheduleDrain() {
    if (this.#drainTimer) {
      return;
    }
    const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    this.#drainTimer = setTimeout(() => {
      this.#drainTimer = null;
      const payloads = this.#payloads;
      this.#payloads = [];
      while (payloads.length) {
        const batch = [payloads.shift()];
        while (payloads.length) {
          if (batch.length === this.#options.batchMaxCount) {
            break;
          }
          batch.push(payloads.shift());
          const bytes2 = JSON.stringify(batch.map((p) => p.payload));
          if (bytes2.length > this.#options.batchMaxSize) {
            payloads.unshift(batch.pop());
            break;
          }
        }
        (async () => {
          const payload = batch.length === 1 ? batch[0].payload : batch.map((p) => p.payload);
          this.emit("debug", { action: "sendRpcPayload", payload });
          try {
            const result = await this._send(payload);
            this.emit("debug", { action: "receiveRpcResult", result });
            for (const { resolve, reject, payload: payload2 } of batch) {
              if (this.destroyed) {
                reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                continue;
              }
              const resp = result.filter((r) => r.id === payload2.id)[0];
              if (resp == null) {
                const error = makeError("missing response for request", "BAD_DATA", {
                  value: result,
                  info: { payload: payload2 }
                });
                this.emit("error", error);
                reject(error);
                continue;
              }
              if ("error" in resp) {
                reject(this.getRpcError(payload2, resp));
                continue;
              }
              resolve(resp.result);
            }
          } catch (error) {
            this.emit("debug", { action: "receiveRpcError", error });
            for (const { reject } of batch) {
              reject(error);
            }
          }
        })();
      }
    }, stallTime);
  }
  constructor(network, options) {
    super(network, options);
    this.#nextId = 1;
    this.#options = Object.assign({}, defaultOptions, options || {});
    this.#payloads = [];
    this.#drainTimer = null;
    this.#network = null;
    this.#pendingDetectNetwork = null;
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      this.#notReady = { promise, resolve };
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        this.#network = Network.from(network);
      }
    } else if (staticNetwork) {
      assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      this.#network = staticNetwork;
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key) {
    return this.#options[key];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert(this.#network, "network is not available yet", "NETWORK_ERROR");
    return this.#network;
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (this.#network) {
          return this.#network;
        }
      } else {
        return network;
      }
    }
    if (this.#pendingDetectNetwork) {
      return await this.#pendingDetectNetwork;
    }
    if (this.ready) {
      this.#pendingDetectNetwork = (async () => {
        try {
          const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
          this.#pendingDetectNetwork = null;
          return result;
        } catch (error) {
          this.#pendingDetectNetwork = null;
          throw error;
        }
      })();
      return await this.#pendingDetectNetwork;
    }
    this.#pendingDetectNetwork = (async () => {
      const payload = {
        id: this.#nextId++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        this.#pendingDetectNetwork = null;
      } catch (error) {
        this.#pendingDetectNetwork = null;
        this.emit("debug", { action: "receiveRpcError", error });
        throw error;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network.from(getBigInt(result.result));
      }
      throw this.getRpcError(payload, result);
    })();
    return await this.#pendingDetectNetwork;
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (this.#notReady == null || this.#notReady.resolve == null) {
      return;
    }
    this.#notReady.resolve();
    this.#notReady = null;
    (async () => {
      while (this.#network == null && !this.destroyed) {
        try {
          this.#network = await this._detectNetwork();
        } catch (error) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
          await stall$2(1e3);
        }
      }
      this.#scheduleDrain();
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (this.#notReady == null) {
      return;
    }
    return await this.#notReady.promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub.filter);
      }
      return new FilterIdEventSubscriber(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return this.#notReady == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result[key] = hexlify(tx[key]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h) => h.toLowerCase());
    }
    if (tx.authorizationList) {
      result["authorizationList"] = tx.authorizationList.map((_a) => {
        const a = authorizationify(_a);
        return {
          address: a.address,
          nonce: toQuantity(a.nonce),
          chainId: toQuantity(a.chainId),
          yParity: toQuantity(a.signature.yParity),
          r: toQuantity(a.signature.r),
          s: toQuantity(a.signature.s)
        };
      });
    }
    return result;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error) {
    const { method } = payload;
    const { error } = _error;
    if (method === "eth_estimateGas" && error.message) {
      const msg = error.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      } else if (msg.match(/nonce/i) && msg.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error);
      const e = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e.info = { error, payload };
      return e;
    }
    const message = JSON.stringify(spelunkMessage(error));
    if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error && error.details && error.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id2 = this.#nextId++;
    const promise = new Promise((resolve, reject) => {
      this.#payloads.push({
        resolve,
        reject,
        payload: { method, params, id: id2, jsonrpc: "2.0" }
      });
    });
    this.#scheduleDrain();
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress(address);
    for (const account of accounts) {
      if (getAddress(account) === address) {
        return new JsonRpcSigner(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a) => new JsonRpcSigner(this, a));
  }
  destroy() {
    if (this.#drainTimer) {
      clearTimeout(this.#drainTimer);
      this.#drainTimer = null;
    }
    for (const { payload, reject } of this.#payloads) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    this.#payloads = [];
    super.destroy();
  }
}
class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
  #pollingInterval;
  constructor(network, options) {
    super(network, options);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions.pollingInterval;
    }
    this.#pollingInterval = pollingInterval;
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = this.#pollingInterval;
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return this.#pollingInterval;
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    this.#pollingInterval = value;
    this._forEachSubscriber((sub) => {
      if (isPollable(sub)) {
        sub.pollingInterval = this.#pollingInterval;
      }
    });
  }
}
class JsonRpcProvider extends JsonRpcApiPollingProvider {
  #connect;
  constructor(url, network, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network, options);
    if (typeof url === "string") {
      this.#connect = new FetchRequest(url);
    } else {
      this.#connect = url.clone();
    }
  }
  _getConnection() {
    return this.#connect.clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
}
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunkData(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {
    }
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage(value[key], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {
    }
  }
}
function spelunkMessage(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
}
class BaseWallet extends AbstractSigner {
  /**
   *  The wallet address.
   */
  address;
  #signingKey;
  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  constructor(privateKey, provider) {
    super(provider);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    this.#signingKey = privateKey;
    const address = computeAddress(this.signingKey.publicKey);
    defineProperties(this, { address });
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  get signingKey() {
    return this.#signingKey;
  }
  /**
   *  The private key for this wallet.
   */
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new BaseWallet(this.#signingKey, provider);
  }
  async signTransaction(tx) {
    tx = copyRequest(tx);
    const { to, from } = await resolveProperties({
      to: tx.to ? resolveAddress(tx.to, this) : void 0,
      from: tx.from ? resolveAddress(tx.from, this) : void 0
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  // @TODO: Add a secialized signTx and signTyped sync that enforces
  // all parameters are known?
  /**
   *  Returns the signature for %%message%% signed with this wallet.
   */
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage(message)).serialized;
  }
  /**
   *  Returns the Authorization for %%auth%%.
   */
  authorizeSync(auth) {
    assertArgument(typeof auth.address === "string", "invalid address for authorizeSync", "auth.address", auth);
    const signature = this.signingKey.sign(hashAuthorization(auth));
    return Object.assign({}, {
      address: getAddress(auth.address),
      nonce: getBigInt(auth.nonce || 0),
      chainId: getBigInt(auth.chainId || 0)
    }, { signature });
  }
  /**
   *  Resolves to the Authorization for %%auth%%.
   */
  async authorize(auth) {
    auth = Object.assign({}, auth, {
      address: await resolveAddress(auth.address, this)
    });
    return this.authorizeSync(await this.populateAuthorization(auth));
  }
  async signTypedData(domain, types, value) {
    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name) => {
      assert(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name }
      });
      const address = await this.provider.resolveName(name);
      assert(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name
      });
      return address;
    });
    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;
  }
}
const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
const Word = /^[a-z]*$/i;
function unfold(words2, sep) {
  let initial = 97;
  return words2.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode(data, subs) {
  for (let i = subsChrs.length - 1; i >= 0; i--) {
    data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  const clumps = [];
  const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
    if (semi) {
      for (let i = parseInt(semi); i >= 0; i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data) {
  assertArgument(data[0] === "0", "unsupported auwl data", "data", data);
  return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}
class Wordlist {
  locale;
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  constructor(locale) {
    defineProperties(this, { locale });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  /**
   *  Sub-classes may override this to provider a language-specific
   *  method for joining %%words%% into a phrase.
   *
   *  By default, %%words%% are joined by a single space.
   */
  join(words2) {
    return words2.join(" ");
  }
}
class WordlistOwl extends Wordlist {
  #data;
  #checksum;
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  constructor(locale, data, checksum2) {
    super(locale);
    this.#data = data;
    this.#checksum = checksum2;
    this.#words = null;
  }
  /**
   *  The OWL-encoded data.
   */
  get _data() {
    return this.#data;
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwl(this.#data);
  }
  #words;
  #loadWords() {
    if (this.#words == null) {
      const words2 = this._decodeWords();
      const checksum2 = id(words2.join("\n") + "\n");
      if (checksum2 !== this.#checksum) {
        throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
      }
      this.#words = words2;
    }
    return this.#words;
  }
  getWord(index) {
    const words2 = this.#loadWords();
    assertArgument(index >= 0 && index < words2.length, `invalid word index: ${index}`, "index", index);
    return words2[index];
  }
  getWordIndex(word) {
    return this.#loadWords().indexOf(word);
  }
}
const words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
const checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
let wordlist = null;
class LangEn extends WordlistOwl {
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("en", words, checksum);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist == null) {
      wordlist = new LangEn();
    }
    return wordlist;
  }
}
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits & 255;
}
function getLowerMask(bits) {
  return (1 << bits) - 1 & 255;
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  assertNormalize("NFKD");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const words2 = wordlist2.split(mnemonic);
  assertArgument(words2.length % 3 === 0 && words2.length >= 12 && words2.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words2.length / 8));
  let offset = 0;
  for (let i = 0; i < words2.length; i++) {
    let index = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = getBytes(sha256$2(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = parseInt(sha256$2(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
const _guard$1 = {};
class Mnemonic {
  /**
   *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
   *
   *  Use the [[wordlist]] ``split`` method to get the individual words.
   */
  phrase;
  /**
   *  The password used for this mnemonic. If no password is used this
   *  is the empty string (i.e. ``""``) as per the specification.
   */
  password;
  /**
   *  The wordlist for this mnemonic.
   */
  wordlist;
  /**
   *  The underlying entropy which the mnemonic encodes.
   */
  entropy;
  /**
   *  @private
   */
  constructor(guard, entropy, phrase, password, wordlist2) {
    if (password == null) {
      password = "";
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    assertPrivate(guard, _guard$1, "Mnemonic");
    defineProperties(this, { phrase, password, wordlist: wordlist2, entropy });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf2(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  /**
   *  Creates a new Mnemonic for the %%phrase%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromPhrase(phrase, password, wordlist2) {
    const entropy = mnemonicToEntropy(phrase, wordlist2);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist2);
    return new Mnemonic(_guard$1, entropy, phrase, password, wordlist2);
  }
  /**
   *  Create a new **Mnemonic** from the %%entropy%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromEntropy(_entropy, password, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist2);
    return new Mnemonic(_guard$1, hexlify(entropy), phrase, password, wordlist2);
  }
  /**
   *  Returns the phrase for %%mnemonic%%.
   */
  static entropyToPhrase(_entropy, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist2);
  }
  /**
   *  Returns the entropy for %%phrase%%.
   */
  static phraseToEntropy(phrase, wordlist2) {
    return mnemonicToEntropy(phrase, wordlist2);
  }
  /**
   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
   *
   *  This checks all the provided words belong to the %%wordlist%%,
   *  that the length is valid and the checksum is correct.
   */
  static isValidMnemonic(phrase, wordlist2) {
    try {
      mnemonicToEntropy(phrase, wordlist2);
      return true;
    } catch (error) {
    }
    return false;
  }
}
var __classPrivateFieldGet$2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet$2 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AES_key, _AES_Kd, _AES_Ke;
const numberOfRounds = { 16: 10, 24: 12, 32: 14 };
const rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
const S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
const Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
const T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
const T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
const T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
const T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
const T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
const T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
const T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
const T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
const U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
const U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
const U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
const U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function convertToInt32(bytes2) {
  const result = [];
  for (let i = 0; i < bytes2.length; i += 4) {
    result.push(bytes2[i] << 24 | bytes2[i + 1] << 16 | bytes2[i + 2] << 8 | bytes2[i + 3]);
  }
  return result;
}
class AES {
  get key() {
    return __classPrivateFieldGet$2(this, _AES_key, "f").slice();
  }
  constructor(key) {
    _AES_key.set(this, void 0);
    _AES_Kd.set(this, void 0);
    _AES_Ke.set(this, void 0);
    if (!(this instanceof AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet$2(this, _AES_key, new Uint8Array(key), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet$2(this, _AES_Ke, [], "f");
    __classPrivateFieldSet$2(this, _AES_Kd, [], "f");
    for (let i = 0; i <= rounds; i++) {
      __classPrivateFieldGet$2(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet$2(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk = convertToInt32(this.key);
    let index;
    for (let i = 0; i < KC; i++) {
      index = i >> 2;
      __classPrivateFieldGet$2(this, _AES_Ke, "f")[index][i % 4] = tk[i];
      __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
    }
    let rconpointer = 0;
    let t = KC, tt;
    while (t < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i2 = 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      } else {
        for (let i2 = 1; i2 < KC / 2; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i2 = KC / 2 + 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      }
      let i = 0, r, c;
      while (i < KC && t < roundKeyCount) {
        r = t >> 2;
        c = t % 4;
        __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][c] = tk[i];
        __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - r][c] = tk[i++];
        t++;
      }
    }
    for (let r = 1; r < rounds; r++) {
      for (let c = 0; c < 4; c++) {
        tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c];
        __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$2(this, _AES_Ke, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(plaintext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet$2(this, _AES_Ke, "f")[0][i];
    }
    for (let r = 1; r < rounds; r++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T1[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$2(this, _AES_Ke, "f")[rounds][i];
      result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$2(this, _AES_Kd, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(ciphertext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet$2(this, _AES_Kd, "f")[0][i];
    }
    for (let r = 1; r < rounds; r++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds][i];
      result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
}
_AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();
class ModeOfOperation {
  constructor(name, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key) },
      name: { enumerable: true, value: name }
    });
  }
}
var __classPrivateFieldSet$1 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$1 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CBC_iv, _CBC_lastBlock;
class CBC extends ModeOfOperation {
  constructor(key, iv) {
    super("ECC", key, CBC);
    _CBC_iv.set(this, void 0);
    _CBC_lastBlock.set(this, void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet$1(this, _CBC_lastBlock, this.iv, "f");
  }
  get iv() {
    return new Uint8Array(__classPrivateFieldGet$1(this, _CBC_iv, "f"));
  }
  encrypt(plaintext) {
    if (plaintext.length % 16) {
      throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
    }
    const ciphertext = new Uint8Array(plaintext.length);
    for (let i = 0; i < plaintext.length; i += 16) {
      for (let j = 0; j < 16; j++) {
        __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
      }
      __classPrivateFieldSet$1(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet$1(this, _CBC_lastBlock, "f")), "f");
      ciphertext.set(__classPrivateFieldGet$1(this, _CBC_lastBlock, "f"), i);
    }
    return ciphertext;
  }
  decrypt(ciphertext) {
    if (ciphertext.length % 16) {
      throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
    }
    const plaintext = new Uint8Array(ciphertext.length);
    for (let i = 0; i < ciphertext.length; i += 16) {
      const block2 = this.aes.decrypt(ciphertext.subarray(i, i + 16));
      for (let j = 0; j < 16; j++) {
        plaintext[i + j] = block2[j] ^ __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j];
        __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
      }
    }
    return plaintext;
  }
}
_CBC_iv = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
class CTR extends ModeOfOperation {
  constructor(key, initialValue) {
    super("CTR", key, CTR);
    _CTR_remaining.set(this, void 0);
    _CTR_remainingIndex.set(this, void 0);
    _CTR_counter.set(this, void 0);
    __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index = 15; index >= 0; --index) {
      __classPrivateFieldGet(this, _CTR_counter, "f")[index] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
  }
  increment() {
    for (let i = 15; i >= 0; i--) {
      if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
      } else {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a, _b;
    const crypttext = new Uint8Array(plaintext);
    for (let i = 0; i < crypttext.length; i++) {
      if (__classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, "f"), _a = _b++, _b), "f"), _a];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
}
_CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();
function pkcs7Strip(data) {
  if (data.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data[data.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data.length - padder;
  for (let i = 0; i < padder; i++) {
    if (data[length + i] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data.subarray(0, length));
}
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad$1(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk(object2, _path) {
  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match != null, "invalid path", "path", _path);
  const path = match[1];
  const type = match[3];
  const reqd = match[4] === "!";
  let cur = object2;
  for (const comp of path.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key in cur) {
        if (key.toLowerCase() === comp) {
          found = cur[key];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === typeof cur) {
      return cur;
    }
    assertArgument(false, `wrong type found for ${type} `, "path", path);
  }
  return cur;
}
const defaultPath$1 = "m/44'/60'/0'/0/0";
function isKeystoreJson(json) {
  try {
    const data = JSON.parse(json);
    const version2 = data.version != null ? parseInt(data.version) : 0;
    if (version2 === 3) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decrypt(data, key, ciphertext) {
  const cipher = spelunk(data, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk(data, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR(key, iv);
    return hexlify(aesCtr.decrypt(ciphertext));
  }
  assert(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount(data, _key) {
  const key = getBytes(_key);
  const ciphertext = spelunk(data, "crypto.ciphertext:data!");
  const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    assertArgument(getAddress(check) === address, "keystore address/privateKey mismatch", "address", data.address);
  }
  const account = { address, privateKey };
  const version2 = spelunk(data, "x-ethers.version:string");
  if (version2 === "0.1") {
    const mnemonicKey = key.slice(32, 64);
    const mnemonicCiphertext = spelunk(data, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk(data, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: spelunk(data, "x-ethers.path:string") || defaultPath$1,
      locale: spelunk(data, "x-ethers.locale:string") || "en",
      entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams(data) {
  const kdf = spelunk(data, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const N2 = spelunk(data, "crypto.kdfparams.n:int!");
      const r = spelunk(data, "crypto.kdfparams.r:int!");
      const p = spelunk(data, "crypto.kdfparams.p:int!");
      assertArgument(N2 > 0 && (N2 & N2 - 1) === 0, "invalid kdf.N", "kdf.N", N2);
      assertArgument(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N2, r, p, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const prf = spelunk(data, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count = spelunk(data, "crypto.kdfparams.c:int!");
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count, dkLen, algorithm };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
}
function decryptKeystoreJsonSync(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count, dkLen2, algorithm);
    return getAccount(data, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r, p, dkLen } = params;
  const key = scryptSync(password, salt, N2, r, p, dkLen);
  return getAccount(data, key);
}
function stall$1(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
async function decryptKeystoreJson(json, _password, progress) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    if (progress) {
      progress(0);
      await stall$1(0);
    }
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count, dkLen2, algorithm);
    if (progress) {
      progress(1);
      await stall$1(0);
    }
    return getAccount(data, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r, p, dkLen } = params;
  const key = await scrypt(password, salt, N2, r, p, dkLen, progress);
  return getAccount(data, key);
}
function getEncryptKdfParams(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes$1(32);
  let N2 = 1 << 17, r = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  assertArgument(typeof N2 === "number" && N2 > 0 && Number.isSafeInteger(N2) && (BigInt(N2) & BigInt(N2 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N2);
  assertArgument(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
  assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return { name: "scrypt", dkLen: 32, salt, N: N2, r, p };
}
function _encryptKeystore(key, kdf, account, options) {
  const privateKey = getBytes(account.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes$1(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes$1(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak256(concat([macPrefix, ciphertext]));
  const data = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client = options.client != null ? options.client : `ethers/${version}`;
    const path = account.mnemonic.path || defaultPath$1;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes$1(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = /* @__PURE__ */ new Date();
    const timestamp = now.getUTCFullYear() + "-" + zpad$1(now.getUTCMonth() + 1, 2) + "-" + zpad$1(now.getUTCDate(), 2) + "T" + zpad$1(now.getUTCHours(), 2) + "-" + zpad$1(now.getUTCMinutes(), 2) + "-" + zpad$1(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data.address;
    data["x-ethers"] = {
      client,
      gethFilename,
      path,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data);
}
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
async function encryptKeystoreJson(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = await scrypt(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
const defaultPath = "m/44'/60'/0'/0/0";
const MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
const HardenedBit = 2147483648;
const N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const Nibbles = "0123456789abcdef";
function zpad(value, length) {
  let result = "";
  while (value) {
    result = Nibbles[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value) {
  const value = getBytes(_value);
  const check = dataSlice(sha256$2(sha256$2(value)), 0, 4);
  const bytes2 = concat([value, check]);
  return encodeBase58(bytes2);
}
const _guard = {};
function ser_I(index, chainCode, publicKey, privateKey) {
  const data = new Uint8Array(37);
  if (index & HardenedBit) {
    assert(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data.set(getBytes(privateKey), 1);
  } else {
    data.set(getBytes(publicKey));
  }
  for (let i = 24; i >= 0; i -= 8) {
    data[33 + (i >> 3)] = index >> 24 - i & 255;
  }
  const I = getBytes(computeHmac("sha512", chainCode, data));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath(node, path) {
  const components = path.split("/");
  assertArgument(components.length > 0, "invalid path", "path", path);
  if (components[0] === "m") {
    assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path);
    components.shift();
  }
  let result = node;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      const index = parseInt(component.substring(0, component.length - 1));
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(HardenedBit + index);
    } else if (component.match(/^[0-9]+$/)) {
      const index = parseInt(component);
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(index);
    } else {
      assertArgument(false, "invalid path component", `path[${i}]`, component);
    }
  }
  return result;
}
class HDNodeWallet extends BaseWallet {
  /**
   *  The compressed public key.
   */
  publicKey;
  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */
  fingerprint;
  /**
   *  The parent fingerprint.
   */
  parentFingerprint;
  /**
   *  The mnemonic used to create this HD Node, if available.
   *
   *  Sources such as extended keys do not encode the mnemonic, in
   *  which case this will be ``null``.
   */
  mnemonic;
  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */
  chainCode;
  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provide full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  encode it.
   */
  path;
  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */
  index;
  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */
  depth;
  /**
   *  @private
   */
  constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
    super(signingKey, provider);
    assertPrivate(guard, _guard, "HDNodeWallet");
    defineProperties(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd160(sha256$2(this.publicKey)), 0, 4);
    defineProperties(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path,
      index,
      depth
    });
    defineProperties(this, { mnemonic });
  }
  connect(provider) {
    return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
  }
  #account() {
    const account = { address: this.address, privateKey: this.privateKey };
    const m = this.mnemonic;
    if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
      account.mnemonic = {
        path: this.path,
        locale: "en",
        entropy: m.entropy
      };
    }
    return account;
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(this.#account(), password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    return encryptKeystoreJsonSync(this.#account(), password);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpriv`` and can be used to
   *  reconstruct this HD Node to derive its children.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488ADE4",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      concat(["0x00", this.privateKey])
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Returns a neutered HD Node, which removes the private details
   *  of an HD Node.
   *
   *  A neutered node has no private key, but can be used to derive
   *  child addresses and other public data about the HD Node.
   */
  neuter() {
    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
    const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));
    return new HDNodeWallet(_guard, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
  }
  /**
   *  Return the HDNode for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
  static #fromSeed(_seed, mnemonic) {
    assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
    const seed = getBytes(_seed, "seed");
    assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
    const I = getBytes(computeHmac("sha512", MasterSecret, seed));
    const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
    return new HDNodeWallet(_guard, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic, null);
  }
  /**
   *  Creates a new HD Node from %%extendedKey%%.
   *
   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
   *  or full HD Node ([[HDNodeWallet) respectively.
   */
  static fromExtendedKey(extendedKey) {
    const bytes2 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes2.length === 82 || encodeBase58Check(bytes2.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes2[4];
    const parentFingerprint = hexlify(bytes2.slice(5, 9));
    const index = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes2.slice(13, 45));
    const key = bytes2.slice(45, 78);
    switch (hexlify(bytes2.slice(0, 4))) {
      // Public Key
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify(key);
        return new HDNodeVoidWallet(_guard, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
      }
      // Private Key
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new HDNodeWallet(_guard, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  /**
   *  Creates a new random HDNode.
   */
  static createRandom(password, path, wordlist2) {
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromEntropy(randomBytes$1(16), password, wordlist2);
    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Create an HD Node from %%mnemonic%%.
   */
  static fromMnemonic(mnemonic, path) {
    if (!path) {
      path = defaultPath;
    }
    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a mnemonic %%phrase%%.
   */
  static fromPhrase(phrase, password, path, wordlist2) {
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist2);
    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a %%seed%%.
   */
  static fromSeed(seed) {
    return HDNodeWallet.#fromSeed(seed, null);
  }
}
class HDNodeVoidWallet extends VoidSigner {
  /**
   *  The compressed public key.
   */
  publicKey;
  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */
  fingerprint;
  /**
   *  The parent node fingerprint.
   */
  parentFingerprint;
  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */
  chainCode;
  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provider full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  enocde it.
   */
  path;
  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */
  index;
  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */
  depth;
  /**
   *  @private
   */
  constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
    super(address, provider);
    assertPrivate(guard, _guard, "HDNodeVoidWallet");
    defineProperties(this, { publicKey });
    const fingerprint = dataSlice(ripemd160(sha256$2(publicKey)), 0, 4);
    defineProperties(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path,
      index,
      depth
    });
  }
  connect(provider) {
    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpub`` and can be used to
   *  reconstruct this neutered key to derive its children addresses.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488B21E",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
    const Ki = SigningKey.addPoints(IL, this.publicKey, true);
    const address = computeAddress(Ki);
    return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);
  }
  /**
   *  Return the signer for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
}
function getAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/${index}'/0/0`;
}
function getIndexedAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/0'/0/${index}`;
}
function isCrowdsaleJson(json) {
  try {
    const data = JSON.parse(json);
    if (data.encseed) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decryptCrowdsaleJson(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const address = getAddress(spelunk(data, "ethaddr:string!"));
  const encseed = looseArrayify(spelunk(data, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  const key = getBytes(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC(key, iv);
  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  return { address, privateKey: id(seedHex) };
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
class Wallet extends BaseWallet {
  /**
   *  Create a new wallet for the private %%key%%, optionally connected
   *  to %%provider%%.
   */
  constructor(key, provider) {
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    let signingKey = typeof key === "string" ? new SigningKey(key) : key;
    super(signingKey, provider);
  }
  connect(provider) {
    return new Wallet(this.signingKey, provider);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    const account = { address: this.address, privateKey: this.privateKey };
    return await encryptKeystoreJson(account, password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    const account = { address: this.address, privateKey: this.privateKey };
    return encryptKeystoreJsonSync(account, password);
  }
  static #fromAccount(account) {
    assertArgument(account, "invalid JSON wallet", "json", "[ REDACTED ]");
    if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
      const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
      const wallet2 = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
      if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
        return wallet2;
      }
      console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
    }
    const wallet = new Wallet(account.privateKey);
    assertArgument(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
    return wallet;
  }
  /**
   *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
   *  with %%password%%.
   *
   *  If %%progress%% is provided, it is called periodically during
   *  decryption so that any UI can be updated.
   */
  static async fromEncryptedJson(json, password, progress) {
    let account = null;
    if (isKeystoreJson(json)) {
      account = await decryptKeystoreJson(json, password, progress);
    } else if (isCrowdsaleJson(json)) {
      if (progress) {
        progress(0);
        await stall(0);
      }
      account = decryptCrowdsaleJson(json, password);
      if (progress) {
        progress(1);
        await stall(0);
      }
    }
    return Wallet.#fromAccount(account);
  }
  /**
   *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
   *
   *  The [[fromEncryptedJson]] method is preferred, as this method
   *  will lock up and freeze the UI during decryption, which may take
   *  some time.
   */
  static fromEncryptedJsonSync(json, password) {
    let account = null;
    if (isKeystoreJson(json)) {
      account = decryptKeystoreJsonSync(json, password);
    } else if (isCrowdsaleJson(json)) {
      account = decryptCrowdsaleJson(json, password);
    } else {
      assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
    }
    return Wallet.#fromAccount(account);
  }
  /**
   *  Creates a new random [[HDNodeWallet]] using the available
   *  [cryptographic random source](randomBytes).
   *
   *  If there is no crytographic random source, this will throw.
   */
  static createRandom(provider) {
    const wallet = HDNodeWallet.createRandom();
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
  /**
   *  Creates a [[HDNodeWallet]] for %%phrase%%.
   */
  static fromPhrase(phrase, provider) {
    const wallet = HDNodeWallet.fromPhrase(phrase);
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
}
async function save(key, data) {
  try {
    await chrome.storage.local.set({ [key]: data });
  } catch (error) {
    console.error("Error saving data:", error);
    throw new Error("Failed to save data");
  }
}
async function load(key) {
  try {
    const result = await chrome.storage.local.get(key);
    return result[key] || null;
  } catch (error) {
    console.error("Error loading data:", error);
    throw new Error("Failed to load data");
  }
}
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n2, title = "") {
  if (!Number.isSafeInteger(n2) || n2 < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n2}`);
  }
}
function abytes(value, length, title = "") {
  const bytes2 = isBytes(value);
  const len = value?.length;
  const needsLen = length !== void 0;
  if (!bytes2 || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes2 ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out, void 0, "digestInto() output");
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error('"digestInto() output" expected to be of length >=' + min);
  }
}
function u8(arr) {
  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
const swap8IfBE = isLE ? (n2) => n2 : (n2) => byteSwap(n2);
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
  return arr;
}
const swap32IfBE = isLE ? (u) => u : byteSwap32;
const nextTick = async () => {
};
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function kdfInputToBytes(data, errorTitle = "") {
  if (typeof data === "string")
    return utf8ToBytes(data);
  return abytes(data, void 0, errorTitle);
}
function createHasher(hashCons, info = {}) {
  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
const oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});
class _HMAC {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = false;
  destroyed = false;
  constructor(hash2, key) {
    ahash(hash2);
    abytes(key, void 0, "key");
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen, "output");
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash2, key, message) => new _HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new _HMAC(hash2, key);
function extract(hash2, ikm, salt) {
  ahash(hash2);
  if (salt === void 0)
    salt = new Uint8Array(hash2.outputLen);
  return hmac(hash2, salt, ikm);
}
const HKDF_COUNTER = /* @__PURE__ */ Uint8Array.of(0);
const EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();
function expand(hash2, prk, info, length = 32) {
  ahash(hash2);
  anumber(length, "length");
  const olen = hash2.outputLen;
  if (length > 255 * olen)
    throw new Error("Length must be <= 255*HashLen");
  const blocks = Math.ceil(length / olen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  else
    abytes(info, void 0, "info");
  const okm = new Uint8Array(blocks * olen);
  const HMAC3 = hmac.create(hash2, prk);
  const HMACTmp = HMAC3._cloneInto();
  const T = new Uint8Array(HMAC3.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, olen * counter);
    HMAC3._cloneInto(HMACTmp);
  }
  HMAC3.destroy();
  HMACTmp.destroy();
  clean(T, HKDF_COUNTER);
  return okm.slice(0, length);
}
const hkdf = (hash2, ikm, salt, info, length) => expand(hash2, extract(hash2, ikm, salt), info, length);
function Chi(a, b2, c) {
  return a & b2 ^ ~a & c;
}
function Maj(a, b2, c) {
  return a & b2 ^ a & c ^ b2 & c;
}
class HashMD {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = false;
  length = 0;
  pos = 0;
  destroyed = false;
  constructor(blockLen, outputLen, padOffset, isLE2) {
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    abytes(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to ||= new this.constructor();
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
}
const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
const rotrSH = (h, l, s) => h >>> s | l << 32 - s;
const rotrSL = (h, l, s) => h << 32 - s | l >>> s;
const rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
const rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
const rotr32H = (_h, l) => l;
const rotr32L = (h, _l) => h;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA2_32B extends HashMD {
  constructor(outputLen) {
    super(64, outputLen, 8, false);
  }
  get() {
    const { A, B, C, D, E, F, G: G2, H } = this;
    return [A, B, C, D, E, F, G2, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G2, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G2 | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G: G2, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T12 = H + sigma1 + Chi(E, F, G2) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T22 = sigma0 + Maj(A, B, C) | 0;
      H = G2;
      G2 = F;
      F = E;
      E = D + T12 | 0;
      D = C;
      C = B;
      B = A;
      A = T12 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G2 = G2 + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G2, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
}
class _SHA256 extends SHA2_32B {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = SHA256_IV[0] | 0;
  B = SHA256_IV[1] | 0;
  C = SHA256_IV[2] | 0;
  D = SHA256_IV[3] | 0;
  E = SHA256_IV[4] | 0;
  F = SHA256_IV[5] | 0;
  G = SHA256_IV[6] | 0;
  H = SHA256_IV[7] | 0;
  constructor() {
    super(32);
  }
}
const sha256 = /* @__PURE__ */ createHasher(
  () => new _SHA256(),
  /* @__PURE__ */ oidNist(1)
);
const BSIGMA = /* @__PURE__ */ Uint8Array.from([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]);
const B2B_IV = /* @__PURE__ */ Uint32Array.from([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
const BBUF = /* @__PURE__ */ new Uint32Array(32);
function G1b(a, b2, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b2], Bh = BBUF[2 * b2 + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b2] = Bl, BBUF[2 * b2 + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function G2b(a, b2, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b2], Bh = BBUF[2 * b2 + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b2] = Bl, BBUF[2 * b2 + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {
  anumber(keyLen);
  if (outputLen < 0 || outputLen > keyLen)
    throw new Error("outputLen bigger than keyLen");
  const { key, salt, personalization } = opts;
  if (key !== void 0 && (key.length < 1 || key.length > keyLen))
    throw new Error('"key" expected to be undefined or of length=1..' + keyLen);
  if (salt !== void 0)
    abytes(salt, saltLen, "salt");
  if (personalization !== void 0)
    abytes(personalization, persLen, "personalization");
}
class _BLAKE2 {
  buffer;
  buffer32;
  finished = false;
  destroyed = false;
  length = 0;
  pos = 0;
  blockLen;
  outputLen;
  constructor(blockLen, outputLen) {
    anumber(blockLen);
    anumber(outputLen);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.buffer = new Uint8Array(blockLen);
    this.buffer32 = u32(this.buffer);
  }
  update(data) {
    aexists(this);
    abytes(data);
    const { blockLen, buffer, buffer32 } = this;
    const len = data.length;
    const offset = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        swap32IfBE(buffer32);
        this.compress(buffer32, 0, false);
        swap32IfBE(buffer32);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        swap32IfBE(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        swap32IfBE(data32);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    clean(this.buffer.subarray(pos));
    swap32IfBE(buffer32);
    this.compress(buffer32, 0, true);
    swap32IfBE(buffer32);
    const out32 = u32(out);
    this.get().forEach((v, i) => out32[i] = swap8IfBE(v));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to ||= new this.constructor({ dkLen: outputLen });
    to.set(...this.get());
    to.buffer.set(buffer);
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    to.outputLen = outputLen;
    return to;
  }
  clone() {
    return this._cloneInto();
  }
}
class _BLAKE2b extends _BLAKE2 {
  // Same as SHA-512, but LE
  v0l = B2B_IV[0] | 0;
  v0h = B2B_IV[1] | 0;
  v1l = B2B_IV[2] | 0;
  v1h = B2B_IV[3] | 0;
  v2l = B2B_IV[4] | 0;
  v2h = B2B_IV[5] | 0;
  v3l = B2B_IV[6] | 0;
  v3h = B2B_IV[7] | 0;
  v4l = B2B_IV[8] | 0;
  v4h = B2B_IV[9] | 0;
  v5l = B2B_IV[10] | 0;
  v5h = B2B_IV[11] | 0;
  v6l = B2B_IV[12] | 0;
  v6h = B2B_IV[13] | 0;
  v7l = B2B_IV[14] | 0;
  v7h = B2B_IV[15] | 0;
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 64 : opts.dkLen;
    super(128, olen);
    checkBlake2Opts(olen, opts, 64, 16, 16);
    let { key, personalization, salt } = opts;
    let keyLength = 0;
    if (key !== void 0) {
      abytes(key, void 0, "key");
      keyLength = key.length;
    }
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      abytes(salt, void 0, "salt");
      const slt = u32(salt);
      this.v4l ^= swap8IfBE(slt[0]);
      this.v4h ^= swap8IfBE(slt[1]);
      this.v5l ^= swap8IfBE(slt[2]);
      this.v5h ^= swap8IfBE(slt[3]);
    }
    if (personalization !== void 0) {
      abytes(personalization, void 0, "personalization");
      const pers = u32(personalization);
      this.v6l ^= swap8IfBE(pers[0]);
      this.v6h ^= swap8IfBE(pers[1]);
      this.v7l ^= swap8IfBE(pers[2]);
      this.v7h ^= swap8IfBE(pers[3]);
    }
    if (key !== void 0) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v, i) => BBUF[i] = v);
    BBUF.set(B2B_IV, 16);
    let { h, l } = fromBig(BigInt(this.length));
    BBUF[24] = B2B_IV[8] ^ l;
    BBUF[25] = B2B_IV[9] ^ h;
    if (isLast) {
      BBUF[28] = ~BBUF[28];
      BBUF[29] = ~BBUF[29];
    }
    let j = 0;
    const s = BSIGMA;
    for (let i = 0; i < 12; i++) {
      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
    }
    this.v0l ^= BBUF[0] ^ BBUF[16];
    this.v0h ^= BBUF[1] ^ BBUF[17];
    this.v1l ^= BBUF[2] ^ BBUF[18];
    this.v1h ^= BBUF[3] ^ BBUF[19];
    this.v2l ^= BBUF[4] ^ BBUF[20];
    this.v2h ^= BBUF[5] ^ BBUF[21];
    this.v3l ^= BBUF[6] ^ BBUF[22];
    this.v3h ^= BBUF[7] ^ BBUF[23];
    this.v4l ^= BBUF[8] ^ BBUF[24];
    this.v4h ^= BBUF[9] ^ BBUF[25];
    this.v5l ^= BBUF[10] ^ BBUF[26];
    this.v5h ^= BBUF[11] ^ BBUF[27];
    this.v6l ^= BBUF[12] ^ BBUF[28];
    this.v6h ^= BBUF[13] ^ BBUF[29];
    this.v7l ^= BBUF[14] ^ BBUF[30];
    this.v7h ^= BBUF[15] ^ BBUF[31];
    clean(BBUF);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const blake2b = /* @__PURE__ */ createHasher((opts) => new _BLAKE2b(opts));
const AT = { Argond2d: 0, Argon2i: 1, Argon2id: 2 };
const ARGON2_SYNC_POINTS = 4;
const abytesOrZero = (buf, errorTitle = "") => {
  if (buf === void 0)
    return Uint8Array.of();
  return kdfInputToBytes(buf, errorTitle);
};
function mul(a, b2) {
  const aL = a & 65535;
  const aH = a >>> 16;
  const bL = b2 & 65535;
  const bH = b2 >>> 16;
  const ll = Math.imul(aL, bL);
  const hl = Math.imul(aH, bL);
  const lh = Math.imul(aL, bH);
  const hh = Math.imul(aH, bH);
  const carry = (ll >>> 16) + (hl & 65535) + lh;
  const high = hh + (hl >>> 16) + (carry >>> 16) | 0;
  const low = carry << 16 | ll & 65535;
  return { h: high, l: low };
}
function mul2(a, b2) {
  const { h, l } = mul(a, b2);
  return { h: (h << 1 | l >>> 31) & 4294967295, l: l << 1 & 4294967295 };
}
function blamka(Ah, Al, Bh, Bl) {
  const { h: Ch, l: Cl } = mul2(Al, Bl);
  const Rll = add3L(Al, Bl, Cl);
  return { h: add3H(Rll, Ah, Bh, Ch), l: Rll | 0 };
}
const A2_BUF = new Uint32Array(256);
function G(a, b2, c, d) {
  let Al = A2_BUF[2 * a], Ah = A2_BUF[2 * a + 1];
  let Bl = A2_BUF[2 * b2], Bh = A2_BUF[2 * b2 + 1];
  let Cl = A2_BUF[2 * c], Ch = A2_BUF[2 * c + 1];
  let Dl = A2_BUF[2 * d], Dh = A2_BUF[2 * d + 1];
  ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh) });
  ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });
  ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });
  A2_BUF[2 * a] = Al, A2_BUF[2 * a + 1] = Ah;
  A2_BUF[2 * b2] = Bl, A2_BUF[2 * b2 + 1] = Bh;
  A2_BUF[2 * c] = Cl, A2_BUF[2 * c + 1] = Ch;
  A2_BUF[2 * d] = Dl, A2_BUF[2 * d + 1] = Dh;
}
function P(v00, v01, v02, v03, v04, v05, v06, v07, v08, v09, v10, v11, v12, v13, v14, v15) {
  G(v00, v04, v08, v12);
  G(v01, v05, v09, v13);
  G(v02, v06, v10, v14);
  G(v03, v07, v11, v15);
  G(v00, v05, v10, v15);
  G(v01, v06, v11, v12);
  G(v02, v07, v08, v13);
  G(v03, v04, v09, v14);
}
function block(x, xPos, yPos, outPos, needXor) {
  for (let i = 0; i < 256; i++)
    A2_BUF[i] = x[xPos + i] ^ x[yPos + i];
  for (let i = 0; i < 128; i += 16) {
    P(i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9, i + 10, i + 11, i + 12, i + 13, i + 14, i + 15);
  }
  for (let i = 0; i < 16; i += 2) {
    P(i, i + 1, i + 16, i + 17, i + 32, i + 33, i + 48, i + 49, i + 64, i + 65, i + 80, i + 81, i + 96, i + 97, i + 112, i + 113);
  }
  if (needXor)
    for (let i = 0; i < 256; i++)
      x[outPos + i] ^= A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];
  else
    for (let i = 0; i < 256; i++)
      x[outPos + i] = A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];
  clean(A2_BUF);
}
function Hp(A, dkLen) {
  const A8 = u8(A);
  const T = new Uint32Array(1);
  const T82 = u8(T);
  T[0] = dkLen;
  if (dkLen <= 64)
    return blake2b.create({ dkLen }).update(T82).update(A8).digest();
  const out = new Uint8Array(dkLen);
  let V = blake2b.create({}).update(T82).update(A8).digest();
  let pos = 0;
  out.set(V.subarray(0, 32));
  pos += 32;
  for (; dkLen - pos > 64; pos += 32) {
    const Vh = blake2b.create({}).update(V);
    Vh.digestInto(V);
    Vh.destroy();
    out.set(V.subarray(0, 32), pos);
  }
  out.set(blake2b(V, { dkLen: dkLen - pos }), pos);
  clean(V, T);
  return u32(out);
}
function indexAlpha(r, s, laneLen, segmentLen, index, randL, sameLane = false) {
  let area;
  if (r === 0) {
    if (s === 0)
      area = index - 1;
    else if (sameLane)
      area = s * segmentLen + index - 1;
    else
      area = s * segmentLen + (index == 0 ? -1 : 0);
  } else if (sameLane)
    area = laneLen - segmentLen + index - 1;
  else
    area = laneLen - segmentLen + (index == 0 ? -1 : 0);
  const startPos = r !== 0 && s !== ARGON2_SYNC_POINTS - 1 ? (s + 1) * segmentLen : 0;
  const rel = area - 1 - mul(area, mul(randL, randL).h).h;
  return (startPos + rel) % laneLen;
}
const maxUint32 = Math.pow(2, 32);
function isU32(num) {
  return Number.isSafeInteger(num) && num >= 0 && num < maxUint32;
}
function argon2Opts(opts) {
  const merged = {
    version: 19,
    dkLen: 32,
    maxmem: maxUint32 - 1,
    asyncTick: 10
  };
  for (let [k, v] of Object.entries(opts))
    if (v !== void 0)
      merged[k] = v;
  const { dkLen, p, m, t, version: version2, onProgress, asyncTick } = merged;
  if (!isU32(dkLen) || dkLen < 4)
    throw new Error('"dkLen" must be 4..');
  if (!isU32(p) || p < 1 || p >= Math.pow(2, 24))
    throw new Error('"p" must be 1..2^24');
  if (!isU32(m))
    throw new Error('"m" must be 0..2^32');
  if (!isU32(t) || t < 1)
    throw new Error('"t" (iterations) must be 1..2^32');
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error('"progressCb" must be a function');
  anumber(asyncTick, "asyncTick");
  if (!isU32(m) || m < 8 * p)
    throw new Error('"m" (memory) must be at least 8*p bytes');
  if (version2 !== 16 && version2 !== 19)
    throw new Error('"version" must be 0x10 or 0x13, got ' + version2);
  return merged;
}
function argon2Init(password, salt, type, opts) {
  password = kdfInputToBytes(password, "password");
  salt = kdfInputToBytes(salt, "salt");
  if (!isU32(password.length))
    throw new Error('"password" must be less of length 1..4Gb');
  if (!isU32(salt.length) || salt.length < 8)
    throw new Error('"salt" must be of length 8..4Gb');
  if (!Object.values(AT).includes(type))
    throw new Error('"type" was invalid');
  let { p, dkLen, m, t, version: version2, key, personalization, maxmem, onProgress, asyncTick } = argon2Opts(opts);
  key = abytesOrZero(key, "key");
  personalization = abytesOrZero(personalization, "personalization");
  const h = blake2b.create();
  const BUF2 = new Uint32Array(1);
  const BUF8 = u8(BUF2);
  for (let item of [p, dkLen, m, t, version2, type]) {
    BUF2[0] = item;
    h.update(BUF8);
  }
  for (let i of [password, salt, key, personalization]) {
    BUF2[0] = i.length;
    h.update(BUF8).update(i);
  }
  const H0 = new Uint32Array(18);
  const H0_8 = u8(H0);
  h.digestInto(H0_8);
  const lanes = p;
  const mP = 4 * p * Math.floor(m / (ARGON2_SYNC_POINTS * p));
  const laneLen = Math.floor(mP / p);
  const segmentLen = Math.floor(laneLen / ARGON2_SYNC_POINTS);
  const memUsed = mP * 256;
  if (!isU32(maxmem) || memUsed > maxmem)
    throw new Error('"maxmem" expected <2**32, got: maxmem=' + maxmem + ", memused=" + memUsed);
  const B = new Uint32Array(memUsed);
  for (let l = 0; l < p; l++) {
    const i = 256 * laneLen * l;
    H0[17] = l;
    H0[16] = 0;
    B.set(Hp(H0, 1024), i);
    H0[16] = 1;
    B.set(Hp(H0, 1024), i + 256);
  }
  let perBlock = () => {
  };
  if (onProgress) {
    const totalBlock = t * ARGON2_SYNC_POINTS * p * segmentLen;
    const callbackPer = Math.max(Math.floor(totalBlock / 1e4), 1);
    let blockCnt = 0;
    perBlock = () => {
      blockCnt++;
      if (onProgress && (!(blockCnt % callbackPer) || blockCnt === totalBlock))
        onProgress(blockCnt / totalBlock);
    };
  }
  clean(BUF2, H0);
  return { type, mP, p, t, version: version2, B, laneLen, lanes, segmentLen, dkLen, perBlock, asyncTick };
}
function argon2Output(B, p, laneLen, dkLen) {
  const B_final = new Uint32Array(256);
  for (let l = 0; l < p; l++)
    for (let j = 0; j < 256; j++)
      B_final[j] ^= B[256 * (laneLen * l + laneLen - 1) + j];
  const res = u8(Hp(B_final, dkLen));
  clean(B_final);
  return res;
}
function processBlock(B, address, l, r, s, index, laneLen, segmentLen, lanes, offset, prev, dataIndependent, needXor) {
  if (offset % laneLen)
    prev = offset - 1;
  let randL, randH;
  if (dataIndependent) {
    let i128 = index % 128;
    if (i128 === 0) {
      address[256 + 12]++;
      block(address, 256, 2 * 256, 0, false);
      block(address, 0, 2 * 256, 0, false);
    }
    randL = address[2 * i128];
    randH = address[2 * i128 + 1];
  } else {
    const T = 256 * prev;
    randL = B[T];
    randH = B[T + 1];
  }
  const refLane = r === 0 && s === 0 ? l : randH % lanes;
  const refPos = indexAlpha(r, s, laneLen, segmentLen, index, randL, refLane == l);
  const refBlock = laneLen * refLane + refPos;
  block(B, 256 * prev, 256 * refBlock, offset * 256, needXor);
}
async function argon2Async(type, password, salt, opts) {
  const { mP, p, t, version: version2, B, laneLen, lanes, segmentLen, dkLen, perBlock, asyncTick } = argon2Init(password, salt, type, opts);
  const address = new Uint32Array(3 * 256);
  address[256 + 6] = mP;
  address[256 + 8] = t;
  address[256 + 10] = type;
  let ts = Date.now();
  for (let r = 0; r < t; r++) {
    const needXor = r !== 0 && version2 === 19;
    address[256 + 0] = r;
    for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {
      address[256 + 4] = s;
      const dataIndependent = r === 0 && s < 2;
      for (let l = 0; l < p; l++) {
        address[256 + 2] = l;
        address[256 + 12] = 0;
        let startPos = 0;
        if (r === 0 && s === 0) {
          startPos = 2;
          if (dataIndependent) {
            address[256 + 12]++;
            block(address, 256, 2 * 256, 0, false);
            block(address, 0, 2 * 256, 0, false);
          }
        }
        let offset = l * laneLen + s * segmentLen + startPos;
        let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;
        for (let index = startPos; index < segmentLen; index++, offset++, prev++) {
          perBlock();
          processBlock(B, address, l, r, s, index, laneLen, segmentLen, lanes, offset, prev, dataIndependent, needXor);
          const diff = Date.now() - ts;
          if (!(diff >= 0 && diff < asyncTick)) {
            await nextTick();
            ts += diff;
          }
        }
      }
    }
  }
  clean(address);
  return argon2Output(B, p, laneLen, dkLen);
}
const argon2idAsync = (password, salt, opts) => argon2Async(AT.Argon2id, password, salt, opts);
function WorkerWrapper(options) {
  return new Worker(
    "/assets/argon2-worker-r6PAvJiu.js",
    {
      name: options?.name
    }
  );
}
export {
  isError as $,
  sha256$2 as A,
  sha512 as B,
  Contract as C,
  hexlify as D,
  concat as E,
  toUtf8Bytes as F,
  toTwos as G,
  zeroPadValue as H,
  Interface as I,
  JsonRpcProvider as J,
  toBeArray as K,
  dataLength as L,
  Mnemonic as M,
  zeroPadBytes as N,
  BaseContract as O,
  copyOverrides as P,
  resolveArgs as Q,
  getCreateAddress as R,
  Signature as S,
  Transaction as T,
  Network as U,
  FetchRequest as V,
  Wallet as W,
  resolveProperties as X,
  AbstractProvider as Y,
  toQuantity as Z,
  accessListify as _,
  assertPrivate as a,
  computeAddress as a$,
  AbiCoder as a0,
  NetworkPlugin as a1,
  JsonRpcApiProvider as a2,
  UnmanagedSubscriber as a3,
  makeError as a4,
  AbstractSigner as a5,
  JsonRpcApiPollingProvider as a6,
  isHexString as a7,
  decodeOwl as a8,
  WordlistOwl as a9,
  HDNodeWallet as aA,
  Indexed as aB,
  JsonRpcSigner as aC,
  Log as aD,
  LogDescription as aE,
  MessagePrefix as aF,
  MulticoinProviderPlugin as aG,
  NamedFragment as aH,
  ParamType as aI,
  Result as aJ,
  SigningKey as aK,
  StructFragment as aL,
  TransactionDescription as aM,
  TransactionReceipt as aN,
  TransactionResponse as aO,
  Typed as aP,
  TypedDataEncoder as aQ,
  UndecodedEventLog as aR,
  Utf8ErrorFuncs as aS,
  VoidSigner as aT,
  Wordlist as aU,
  ZeroAddress as aV,
  ZeroHash as aW,
  assertArgumentCount as aX,
  assertNormalize as aY,
  authorizationify as aZ,
  checkResultErrors as a_,
  LangEn as aa,
  BaseWallet as ab,
  Block as ac,
  ConstructorFragment as ad,
  ContractEventPayload as ae,
  ContractTransactionReceipt as af,
  ContractTransactionResponse as ag,
  ContractUnknownEventPayload as ah,
  EnsPlugin as ai,
  EnsResolver as aj,
  ErrorDescription as ak,
  ErrorFragment as al,
  EtherSymbol as am,
  EventFragment as an,
  EventLog as ao,
  EventPayload as ap,
  FallbackFragment as aq,
  FeeData as ar,
  FeeDataNetworkPlugin as as,
  FetchCancelSignal as at,
  FetchResponse as au,
  FetchUrlFeeDataNetworkPlugin as av,
  Fragment as aw,
  FunctionFragment as ax,
  GasCostPlugin as ay,
  HDNodeVoidWallet as az,
  assertArgument as b,
  copyRequest as b0,
  dataSlice as b1,
  decodeBase58 as b2,
  decodeBase64 as b3,
  decodeRlp as b4,
  decryptCrowdsaleJson as b5,
  decryptKeystoreJson as b6,
  decryptKeystoreJsonSync as b7,
  defaultPath as b8,
  dnsEncode as b9,
  toNumber as bA,
  toUtf8CodePoints as bB,
  uuidV4 as bC,
  verifyAuthorization as bD,
  verifyMessage as bE,
  verifyTypedData as bF,
  version as bG,
  encodeBase58 as ba,
  encodeBase64 as bb,
  encodeRlp as bc,
  encryptKeystoreJson as bd,
  encryptKeystoreJsonSync as be,
  ensNormalize as bf,
  getAccountPath as bg,
  getBytesCopy as bh,
  getCreate2Address as bi,
  getIcapAddress as bj,
  getIndexedAccountPath as bk,
  getUint as bl,
  hashAuthorization as bm,
  hashMessage as bn,
  id as bo,
  isAddressable as bp,
  isBytesLike as bq,
  isCallException as br,
  isCrowdsaleJson as bs,
  isKeystoreJson as bt,
  isValidName as bu,
  namehash as bv,
  recoverAddress as bw,
  resolveAddress as bx,
  stripZerosLeft as by,
  toBeHex as bz,
  assert as c,
  defineProperties as d,
  getBigInt as e,
  getBytes as f,
  getNumber as g,
  fromTwos as h,
  isAddress as i,
  getAddress as j,
  WorkerWrapper as k,
  load as l,
  mask as m,
  argon2idAsync as n,
  hkdf as o,
  sha256 as p,
  toUtf8String as q,
  computeHmac as r,
  save as s,
  toBigInt as t,
  keccak256 as u,
  pbkdf2 as v,
  randomBytes$1 as w,
  ripemd160 as x,
  scrypt as y,
  scryptSync as z
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJnb24yLXdvcmtlci5qcyIsInNvdXJjZXMiOlsiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL192ZXJzaW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3Byb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2RhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTU4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2Jhc2U2NC1icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2V2ZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91dGY4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2dldHVybC1icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2ZldGNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3JscC1kZWNvZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWVuY29kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91dWlkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vcGJrZGYyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9jcnlwdG8tYnJvd3Nlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vaG1hYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2tlY2Nhay5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3JpcGVtZDE2MC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vcmlwZW1kMTYwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9wYmtkZjIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3JhbmRvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NjcnlwdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2NyeXB0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaGEyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL2FkZHJlc3Nlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaGFzaGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9zdHJpbmdzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaWduYXR1cmUuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25pbmcta2V5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvYWRkcmVzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NvbnRyYWN0LWFkZHJlc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jaGVja3MuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL3R5cGVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWRkcmVzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fub255bW91cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYm9vbGVhbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2J5dGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvZml4ZWQtYnl0ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvbnVtYmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvc3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvdHVwbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWNjZXNzbGlzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hdXRob3JpemF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FkZHJlc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9hdXRob3JpemF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvaWQuanMiLCIuLi9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL25hbWVoYXNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvbWVzc2FnZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL3R5cGVkLWRhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ZyYWdtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvYWJpLWNvZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9pbnRlcmZhY2UuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L3dyYXBwZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L2NvbnRyYWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Zvcm1hdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcGx1Z2lucy1uZXR3b3JrLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9uZXR3b3JrLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9zdWJzY3JpYmVyLXBvbGxpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9hYnN0cmFjdC1zaWduZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItZmlsdGVyaWQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWpzb25ycGMuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L2Jhc2Utd2FsbGV0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy9kZWNvZGUtb3dsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy93b3JkbGlzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvd29yZGxpc3Qtb3dsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy9sYW5nLWVuLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9tbmVtb25pYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9hZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWNiYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWN0ci5qcyIsIi4uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9wYWRkaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvanNvbi1rZXlzdG9yZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvaGR3YWxsZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L2pzb24tY3Jvd2RzYWxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC93YWxsZXQuanMiLCIuLi9zcmMvY29yZS9zdG9yYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvaGtkZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19tZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL191NjQuanMiLCIuLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX2JsYWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvYmxha2UyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvYXJnb24yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIERvIE5PVCBtb2RpZnkgdGhpcyBmaWxlOyBzZWUgL3NyYy50cy9fYWRtaW4vdXBkYXRlLXZlcnNpb24udHMgKi9cbi8qKlxuICogIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXRoZXJzLlxuICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiNi4xNS4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCIvKipcbiAqICBQcm9wZXJ0eSBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlByb3BlcnRpZXMgIFthYm91dC1wcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpLm1hcCh0ID0+IHQudHJpbSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xuICAgIGVycm9yLmNvZGUgPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xuICAgIHRocm93IGVycm9yO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mICUldmFsdWUlJSwgYnV0IHdpdGggYWxsXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXModmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcCgoaykgPT4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlW2tdKSkpO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0sIHYsIGluZGV4KSA9PiB7XG4gICAgICAgIGFjY3VtW2tleXNbaW5kZXhdXSA9IHY7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqICBBc3NpZ25zIHRoZSAlJXZhbHVlcyUlIHRvICUldGFyZ2V0JSUgYXMgcmVhZC1vbmx5IHZhbHVlcy5cbiAqXG4gKiAgSXQgJSV0eXBlcyUlIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlcyBhcmUgY2hlY2tlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCB2YWx1ZXMsIHR5cGVzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHZhbHVlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgY29uc3QgdHlwZSA9ICh0eXBlcyA/IHR5cGVzW2tleV0gOiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCIsIi8qKlxuICogIEFsbCBlcnJvcnMgaW4gZXRoZXJzIGluY2x1ZGUgcHJvcGVydGllcyB0byBlbnN1cmUgdGhleSBhcmUgYm90aFxuICogIGh1bWFuLXJlYWRhYmxlIChpLmUuIGBgLm1lc3NhZ2VgYCkgYW5kIG1hY2hpbmUtcmVhZGFibGUgKGkuZS4gYGAuY29kZWBgKS5cbiAqXG4gKiAgVGhlIFtbaXNFcnJvcl1dIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoZSBlcnJvciBgYGNvZGVgYCBhbmRcbiAqICBwcm92aWRlIGEgdHlwZSBndWFyZCBmb3IgdGhlIHByb3BlcnRpZXMgcHJlc2VudCBvbiB0aGF0IGVycm9yIGludGVyZmFjZS5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvdXRpbHMvZXJyb3JzOkVycm9ycyAgW2Fib3V0LWVycm9yc11cbiAqL1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fdmVyc2lvbi5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgc2Vlbikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgaWYgKHNlZW4gPT0gbnVsbCkge1xuICAgICAgICBzZWVuID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyXVwiO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uYWRkKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBcIlsgXCIgKyAodmFsdWUubWFwKCh2KSA9PiBzdHJpbmdpZnkodiwgc2VlbikpKS5qb2luKFwiLCBcIikgKyBcIiBdXCI7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgY29uc3QgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gPj4gNF07XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldICYgMHhmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mICh2YWx1ZS50b0pTT04pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh2YWx1ZS50b0pTT04oKSwgc2Vlbik7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gXCJ7IFwiICsga2V5cy5tYXAoKGspID0+IGAke3N0cmluZ2lmeShrLCBzZWVuKX06ICR7c3RyaW5naWZ5KHZhbHVlW2tdLCBzZWVuKX1gKS5qb2luKFwiLCBcIikgKyBcIiB9XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGBbIENPVUxEIE5PVCBTRVJJQUxJWkUgXWA7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgdGhlICUlZXJyb3IlJSBtYXRjaGVzIGFuIGVycm9yIHRocm93biBieSBldGhlcnNcbiAqICB0aGF0IG1hdGNoZXMgdGhlIGVycm9yICUlY29kZSUlLlxuICpcbiAqICBJbiBUeXBlU2NyaXB0IGVudmlyb25tZW50cywgdGhpcyBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGF0ICUlZXJyb3IlJVxuICogIG1hdGNoZXMgYW4gRXRoZXJzRXJyb3IgdHlwZSwgd2hpY2ggbWVhbnMgdGhlIGV4cGVjdGVkIHByb3BlcnRpZXMgd2lsbFxuICogIGJlIHNldC5cbiAqXG4gKiAgQFNlZSBbRXJyb3JDb2Rlc10oYXBpOkVycm9yQ29kZSlcbiAqICBAZXhhbXBsZVxuICogICAgdHJ5IHtcbiAqICAgICAgLy8gY29kZS4uLi5cbiAqICAgIH0gY2F0Y2ggKGUpIHtcbiAqICAgICAgaWYgKGlzRXJyb3IoZSwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICogICAgICAgICAgLy8gVGhlIFR5cGUgR3VhcmQgaGFzIHZhbGlkYXRlZCB0aGlzIG9iamVjdFxuICogICAgICAgICAgY29uc29sZS5sb2coZS5kYXRhKTtcbiAqICAgICAgfVxuICogICAgfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcihlcnJvciwgY29kZSkge1xuICAgIHJldHVybiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gY29kZSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSVlcnJvciUlIGlzIGEgW1tDYWxsRXhjZXB0aW9uRXJyb3JdLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDYWxsRXhjZXB0aW9uKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIik7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgbmV3IEVycm9yIGNvbmZpZ3VyZWQgdG8gdGhlIGZvcm1hdCBldGhlcnMgZW1pdHMgZXJyb3JzLCB3aXRoXG4gKiAgdGhlICUlbWVzc2FnZSUlLCBbW2FwaTpFcnJvckNvZGVdXSAlJWNvZGUlJSBhbmQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiAgZm9yIHRoZSBjb3JyZXNwb25kaW5nIEV0aGVyc0Vycm9yLlxuICpcbiAqICBFYWNoIGVycm9yIGluIGV0aGVycyBpbmNsdWRlcyB0aGUgdmVyc2lvbiBvZiBldGhlcnMsIGFcbiAqICBtYWNoaW5lLXJlYWRhYmxlIFtbRXJyb3JDb2RlXV0sIGFuZCBkZXBlbmRpbmcgb24gJSVjb2RlJSUsIGFkZGl0aW9uYWxcbiAqICByZXF1aXJlZCBwcm9wZXJ0aWVzLiBUaGUgZXJyb3IgbWVzc2FnZSB3aWxsIGFsc28gaW5jbHVkZSB0aGUgJSVtZXNzYWdlJSUsXG4gKiAgZXRoZXJzIHZlcnNpb24sICUlY29kZSUlIGFuZCBhbGwgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLCBzZXJpYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBsZXQgc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICB7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGlmIChcIm1lc3NhZ2VcIiBpbiBpbmZvIHx8IFwiY29kZVwiIGluIGluZm8gfHwgXCJuYW1lXCIgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgd2lsbCBvdmVyd3JpdGUgcG9wdWxhdGVkIHZhbHVlczogJHtzdHJpbmdpZnkoaW5mbyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJzaG9ydE1lc3NhZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoaW5mb1trZXldKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIHN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1NTVwiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVtjb3VsZCBub3Qgc2VyaWFsaXplIG9iamVjdF1cIik7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XG4gICAgICAgIGRldGFpbHMucHVzaChgdmVyc2lvbj0ke3ZlcnNpb259YCk7XG4gICAgICAgIGlmIChkZXRhaWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBkZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlcnJvcjtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSBcIklOVkFMSURfQVJHVU1FTlRcIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTlVNRVJJQ19GQVVMVFwiOlxuICAgICAgICBjYXNlIFwiQlVGRkVSX09WRVJSVU5cIjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKGVycm9yLCB7IGNvZGUgfSk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlcnJvciwgaW5mbyk7XG4gICAgfVxuICAgIGlmIChlcnJvci5zaG9ydE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKGVycm9yLCB7IHNob3J0TWVzc2FnZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuLyoqXG4gKiAgVGhyb3dzIGFuIEV0aGVyc0Vycm9yIHdpdGggJSVtZXNzYWdlJSUsICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIGVycm9yXG4gKiAgJSVpbmZvJSUgd2hlbiAlJWNoZWNrJSUgaXMgZmFsc2lzaC4uXG4gKlxuICogIEBzZWUgW1thcGk6bWFrZUVycm9yXV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChjaGVjaywgbWVzc2FnZSwgY29kZSwgaW5mbykge1xuICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgdGhyb3cgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGluZm8pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgc2ltcGxlIGhlbHBlciB0byBzaW1wbHkgZW5zdXJpbmcgcHJvdmlkZWQgYXJndW1lbnRzIG1hdGNoIGV4cGVjdGVkXG4gKiAgY29uc3RyYWludHMsIHRocm93aW5nIGlmIG5vdC5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoZSAlJWNoZWNrJSUgaGFzIGJlZW4gYXNzZXJ0ZWQgdHJ1ZSwgc29cbiAqICBhbnkgZnVydGhlciBjb2RlIGRvZXMgbm90IG5lZWQgYWRkaXRpb25hbCBjb21waWxlLXRpbWUgY2hlY2tzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnQoY2hlY2ssIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gXCI6IFwiICsgbWVzc2FnZTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvdW50ID49IGV4cGVjdGVkQ291bnQsIFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgXCJNSVNTSU5HX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG4gICAgYXNzZXJ0KGNvdW50IDw9IGV4cGVjdGVkQ291bnQsIFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBcIlVORVhQRUNURURfQVJHVU1FTlRcIiwge1xuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICB9KTtcbn1cbmNvbnN0IF9ub3JtYWxpemVGb3JtcyA9IFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLnJlZHVjZSgoYWNjdW0sIGZvcm0pID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBHZW5lcmFsIHRlc3QgZm9yIG5vcm1hbGl6ZVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShmb3JtKSAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZFwiKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmIChmb3JtID09PSBcIk5GRFwiKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChjaGVjayAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtLnB1c2goZm9ybSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGFjY3VtO1xufSwgW10pO1xuLyoqXG4gKiAgVGhyb3dzIGlmIHRoZSBub3JtYWxpemF0aW9uICUlZm9ybSUlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3JtYWxpemUoZm9ybSkge1xuICAgIGFzc2VydChfbm9ybWFsaXplRm9ybXMuaW5kZXhPZihmb3JtKSA+PSAwLCBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgaW5mbzogeyBmb3JtIH1cbiAgICB9KTtcbn1cbi8qKlxuICogIE1hbnkgY2xhc3NlcyB1c2UgZmlsZS1zY29wZWQgdmFsdWVzIHRvIGd1YXJkIHRoZSBjb25zdHJ1Y3RvcixcbiAqICBtYWtpbmcgaXQgZWZmZWN0aXZlbHkgcHJpdmF0ZS4gVGhpcyBmYWNpbGl0YXRlcyB0aGF0IHBhdHRlcm5cbiAqICBieSBlbnN1cmluZyB0aGUgJSVnaXZlbkdhdXJkJSUgbWF0Y2hlcyB0aGUgZmlsZS1zY29wZWQgJSVndWFyZCUlLFxuICogIHRocm93aW5nIGlmIG5vdCwgaW5kaWNhdGluZyB0aGUgJSVjbGFzc05hbWUlJSBpZiBwcm92aWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFByaXZhdGUoZ2l2ZW5HdWFyZCwgZ3VhcmQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWUgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoZ2l2ZW5HdWFyZCAhPT0gZ3VhcmQpIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IGNsYXNzTmFtZSwgb3BlcmF0aW9uID0gXCJuZXdcIjtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgbWV0aG9kICs9IFwiLlwiO1xuICAgICAgICAgICAgb3BlcmF0aW9uICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYHByaXZhdGUgY29uc3RydWN0b3I7IHVzZSAke21ldGhvZH1mcm9tKiBtZXRob2RzYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCIvKipcbiAqICBTb21lIGRhdGEgaGVscGVycy5cbiAqXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6RGF0YSBIZWxwZXJzICBbYWJvdXQtZGF0YV1cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBjb3B5KSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tYXRjaCgvXjB4KD86WzAtOWEtZl1bMC05YS1mXSkqJC9pKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyAyKSwgMTYpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCeXRlc0xpa2UgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJS4gSWYgYWxyZWFkeSBhIFVpbnQ4QXJyYXlcbiAqICB0aGUgb3JpZ2luYWwgJSV2YWx1ZSUlIGlzIHJldHVybmVkOyBpZiBhIGNvcHkgaXMgcmVxdWlyZWQgdXNlXG4gKiAgW1tnZXRCeXRlc0NvcHldXS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNDb3B5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGZhbHNlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJSwgY3JlYXRpbmcgYSBjb3B5IGlmIG5lY2Vzc2FyeVxuICogIHRvIHByZXZlbnQgYW55IG1vZGlmaWNhdGlvbnMgb2YgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gYmVpbmdcbiAqICByZWZsZWN0ZWQgZWxzZXdoZXJlLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qnl0ZXNDb3B5KHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgdHJ1ZSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tIZXhTdHJpbmddXS5cbiAqXG4gKiAgSWYgJSVsZW5ndGglJSBpcyBgYHRydWVgYCBvciBhIC8vbnVtYmVyLy8sIGl0IGFsc28gY2hlY2tzIHRoYXRcbiAqICAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWxlbmd0aCUlIChpZiBhIC8vbnVtYmVyLy8pXG4gKiAgYnl0ZXMgb2YgZGF0YSAoZS5nLiBgYDB4MTIzNGBgIGlzIDIgYnl0ZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGxlbmd0aCkgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IHRydWUgJiYgKHZhbHVlLmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYXJiaXRyYXJ5XG4gKiAgZGF0YSAoaS5lLiBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9yIGEgVWludDhBcnJheSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKTtcbn1cbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSByZXByZXNlbnRhdGlvbiBvZiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleGxpZnkoZGF0YSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBieXRlc1tpXTtcbiAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IGNvbmNhdGVuYXRpbmcgYWxsIHZhbHVlc1xuICogIHdpdGhpbiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChkYXRhcykge1xuICAgIHJldHVybiBcIjB4XCIgKyBkYXRhcy5tYXAoKGQpID0+IGhleGxpZnkoZCkuc3Vic3RyaW5nKDIpKS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLCBpbiBieXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFMZW5ndGgoZGF0YSkge1xuICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSkubGVuZ3RoO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IHNsaWNpbmcgJSVkYXRhJSUgZnJvbSB0aGUgJSVzdGFydCUlXG4gKiAgb2Zmc2V0IHRvIHRoZSAlJWVuZCUlIG9mZnNldC5cbiAqXG4gKiAgQnkgZGVmYXVsdCAlJXN0YXJ0JSUgaXMgMCBhbmQgJSVlbmQlJSBpcyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YVNsaWNlKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGlmIChlbmQgIT0gbnVsbCAmJiBlbmQgPiBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBzbGljZSBiZXlvbmQgZGF0YSBib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IGJ5dGVzLmxlbmd0aCwgb2Zmc2V0OiBlbmRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzLnNsaWNlKChzdGFydCA9PSBudWxsKSA/IDAgOiBzdGFydCwgKGVuZCA9PSBudWxsKSA/IGJ5dGVzLmxlbmd0aCA6IGVuZCkpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSByZXN1bHQgYnkgc3RyaXBwaW5nIGFsbCAqKmxlYWRpbmcqKlxuICoqIHplcm8gYnl0ZXMgZnJvbSAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3NMZWZ0KGRhdGEpIHtcbiAgICBsZXQgYnl0ZXMgPSBoZXhsaWZ5KGRhdGEpLnN1YnN0cmluZygyKTtcbiAgICB3aGlsZSAoYnl0ZXMuc3RhcnRzV2l0aChcIjAwXCIpKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgYnl0ZXM7XG59XG5mdW5jdGlvbiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgbGVmdCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgYXNzZXJ0KGxlbmd0aCA+PSBieXRlcy5sZW5ndGgsIFwicGFkZGluZyBleGNlZWRzIGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KGJ5dGVzKSxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIG9mZnNldDogbGVuZ3RoICsgMVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LmZpbGwoMCk7XG4gICAgaWYgKGxlZnQpIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgbGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIDApO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqbGVmdCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKip2YWx1ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYHVpbnQxMjhgYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkVmFsdWUoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCB0cnVlKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKnJpZ2h0KipcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxuICpcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXG4gKiAgdGhyb3duLlxuICpcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKmJ5dGVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGBieXRlczE2YGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZEJ5dGVzKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgZmFsc2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiLCIvKipcbiAqICBTb21lIG1hdGhlbWF0aWMgb3BlcmF0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6TWF0aCBIZWxwZXJzICBbYWJvdXQtbWF0aHNdXG4gKi9cbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG4vL2NvbnN0IEJOX01heDI1NiA9IChCTl8xIDw8IEJpZ0ludCgyNTYpKSAtIEJOXzE7XG4vLyBJRUVFIDc1NCBzdXBwb3J0IDUzLWJpdHMgb2YgbWFudGlzc2FcbmNvbnN0IG1heFZhbHVlID0gMHgxZmZmZmZmZmZmZmZmZjtcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIGZyb20gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2YgJSV3aWR0aCUlXG4gKiAgYml0cyB0byBpdHMgdmFsdWUuXG4gKlxuICogIElmIHRoZSBoaWdoZXN0IGJpdCBpcyBgYDFgYCwgdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGFzc2VydCgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgIGlmICh2YWx1ZSA8IEJOXzApIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8PSBsaW1pdCwgXCJ0b28gbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gKCh+dmFsdWUpICYgbWFzaykgKyBCTl8xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiAgTWFzayAlJXZhbHVlJSUgd2l0aCBhIGJpdG1hc2sgb2YgJSViaXRzJSUgb25lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2soX3ZhbHVlLCBfYml0cykge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgYml0cyA9IEJpZ0ludChnZXROdW1iZXIoX2JpdHMsIFwiYml0c1wiKSk7XG4gICAgcmV0dXJuIHZhbHVlICYgKChCTl8xIDw8IGJpdHMpIC0gQk5fMSk7XG59XG4vKipcbiAqICBHZXRzIGEgQmlnSW50IGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxuICogIGEgQmlnSW50LCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6IHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIgJiYgdmFsdWVbMV0gIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtQmlnSW50KHZhbHVlLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgQmlnTnVtYmVyaXNoIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgJSV2YWx1ZSUlIGFzIGEgYmlnaW50LCB2YWxpZGF0aW5nIGl0IGlzIHZhbGlkIGFzIGEgYmlnaW50XG4gKiAgdmFsdWUgYW5kIHRoYXQgaXQgaXMgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50KHZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKTtcbiAgICBhc3NlcnQocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qXG4gKiBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXIodmFsdWUsIG5hbWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcihCaWdJbnQodmFsdWUpLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIG51bWVyaWMgc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIG51bWJlci4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcbiAqICBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS4gVGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc2FmZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldE51bWJlcih0b0JpZ0ludCh2YWx1ZSkpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBoZXhzdHJpbmcsIG9wdGlvbmFsbHkgcGFkZGVkIHRvXG4gKiAgJSV3aWR0aCUlIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgIGFzc2VydCh3aWR0aCAqIDIgPj0gcmVzdWx0Lmxlbmd0aCwgYHZhbHVlIGV4Y2VlZHMgd2lkdGggKCR7d2lkdGh9IGJ5dGVzKWAsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9CZUhleFwiLFxuICAgICAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIixcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFBhZCB0aGUgdmFsdWUgdG8gdGhlIHJlcXVpcmVkIHdpZHRoXG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgKHdpZHRoICogMikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JlQXJyYXkoX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAodmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICB9XG4gICAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogMjtcbiAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tIZXhTdHJpbmddXSBmb3IgJSV2YWx1ZSUlIHNhZmUgdG8gdXNlIGFzIGEgLy9RdWFudGl0eS8vLlxuICpcbiAqICBBIC8vUXVhbnRpdHkvLyBkb2VzIG5vdCBoYXZlIGFuZCBsZWFkaW5nIDAgdmFsdWVzIHVubGVzcyB0aGUgdmFsdWUgaXNcbiAqICB0aGUgbGl0ZXJhbCB2YWx1ZSBgMHgwYC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgZm9yIEpTU09OLVJQQ1xuICogIG51bWVyaWMgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9RdWFudGl0eSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBoZXhsaWZ5KGlzQnl0ZXNMaWtlKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChyZXN1bHQuc3RhcnRzV2l0aChcIjBcIikpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhzLmpzLm1hcCIsIi8qKlxuICogIFRoZSBbQmFzZTU4IEVuY29kaW5nXShsaW5rLWJhc2U1OCkgc2NoZW1lIGFsbG93cyBhICoqbnVtZXJpYyoqIHZhbHVlXG4gKiAgdG8gYmUgZW5jb2RlZCBhcyBhIGNvbXBhY3Qgc3RyaW5nIHVzaW5nIGEgcmFkaXggb2YgNTggdXNpbmcgb25seVxuICogIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy4gQ29uZnVzaW5nbHkgc2ltaWxhciBjaGFyYWN0ZXJzIGFyZSBvbWl0dGVkXG4gKiAgKGkuZS4gYGBcImwwT1wiYGApLlxuICpcbiAqICBOb3RlIHRoYXQgQmFzZTU4IGVuY29kZXMgYSAqKm51bWVyaWMqKiB2YWx1ZSwgbm90IGFyYml0cmFyeSBieXRlcyxcbiAqICBzaW5jZSBhbnkgemVyby1ieXRlcyBvbiB0aGUgbGVmdCB3b3VsZCBnZXQgcmVtb3ZlZC4gVG8gbWl0aWdhdGUgdGhpc1xuICogIGlzc3VlIG1vc3Qgc2NoZW1lcyB0aGF0IHVzZSBCYXNlNTggY2hvb3NlIHNwZWNpZmljIGhpZ2gtb3JkZXIgdmFsdWVzXG4gKiAgdG8gZW5zdXJlIG5vbi16ZXJvIHByZWZpeGVzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNTggRW5jb2RpbmcgW2Fib3V0LWJhc2U1OF1cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgdG9CaWdJbnQgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuY29uc3QgQWxwaGFiZXQgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjtcbmxldCBMb29rdXAgPSBudWxsO1xuZnVuY3Rpb24gZ2V0QWxwaGEobGV0dGVyKSB7XG4gICAgaWYgKExvb2t1cCA9PSBudWxsKSB7XG4gICAgICAgIExvb2t1cCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBMb29rdXBbQWxwaGFiZXRbaV1dID0gQmlnSW50KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IExvb2t1cFtsZXR0ZXJdO1xuICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdCAhPSBudWxsLCBgaW52YWxpZCBiYXNlNTggdmFsdWVgLCBcImxldHRlclwiLCBsZXR0ZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fNTggPSBCaWdJbnQoNTgpO1xuLyoqXG4gKiAgRW5jb2RlICUldmFsdWUlJSBhcyBhIEJhc2U1OC1lbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJhc2U1OChfdmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKF92YWx1ZSk7XG4gICAgbGV0IHZhbHVlID0gdG9CaWdJbnQoYnl0ZXMpO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICByZXN1bHQgPSBBbHBoYWJldFtOdW1iZXIodmFsdWUgJSBCTl81OCldICsgcmVzdWx0O1xuICAgICAgICB2YWx1ZSAvPSBCTl81ODtcbiAgICB9XG4gICAgLy8gQWNjb3VudCBmb3IgbGVhZGluZyBwYWRkaW5nIHplcm9zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYnl0ZXNbaV0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IEFscGhhYmV0WzBdICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgRGVjb2RlIHRoZSBCYXNlNTgtZW5jb2RlZCAlJXZhbHVlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNTgodmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCAqPSBCTl81ODtcbiAgICAgICAgcmVzdWx0ICs9IGdldEFscGhhKHZhbHVlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U1OC5qcy5tYXAiLCIvLyB1dGlscy9iYXNlNjQtYnJvd3NlclxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTY0KHRleHREYXRhKSB7XG4gICAgdGV4dERhdGEgPSBhdG9iKHRleHREYXRhKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dERhdGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSB0ZXh0RGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTY0KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhKTtcbiAgICBsZXQgdGV4dERhdGEgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZXh0RGF0YSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYSh0ZXh0RGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQtYnJvd3Nlci5qcy5tYXAiLCIvKipcbiAqICBFdmVudHMgYWxsb3cgZm9yIGFwcGxpY2F0aW9ucyB0byB1c2UgdGhlIG9ic2VydmVyIHBhdHRlcm4sIHdoaWNoXG4gKiAgYWxsb3dzIHN1YnNjcmliaW5nIGFuZCBwdWJsaXNoaW5nIGV2ZW50cywgb3V0c2lkZSB0aGUgbm9ybWFsXG4gKiAgZXhlY3V0aW9uIHBhdGhzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2V2ZW50czpFdmVudHMgIFthYm91dC1ldmVudHNdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG4vKipcbiAqICBXaGVuIGFuIFtbRXZlbnRFbWl0dGVyYWJsZV1dIHRyaWdnZXJzIGEgW1tMaXN0ZW5lcl1dLCB0aGVcbiAqICBjYWxsYmFjayBhbHdheXMgYWhhcyBvbmUgYWRkaXRpb25hbCBhcmd1bWVudCBwYXNzZWQsIHdoaWNoIGlzXG4gKiAgYW4gKipFdmVudFBheWxvYWQqKi5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBmaWx0ZXIuXG4gICAgICovXG4gICAgZmlsdGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgKipFdmVudEVtaXR0ZXJhYmxlKiouXG4gICAgICovXG4gICAgZW1pdHRlcjtcbiAgICAjbGlzdGVuZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkV2ZW50UGF5bG9hZCoqIGZvciAlJWVtaXR0ZXIlJSB3aXRoXG4gICAgICogIHRoZSAlJWxpc3RlbmVyJSUgYW5kIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVtaXR0ZXIsIGxpc3RlbmVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGVtaXR0ZXIsIGZpbHRlciB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVucmVnaXN0ZXIgdGhlIHRyaWdnZXJlZCBsaXN0ZW5lciBmb3IgZnV0dXJlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuI2xpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmVtaXR0ZXIub2ZmKHRoaXMuZmlsdGVyLCB0aGlzLiNsaXN0ZW5lcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCIsIi8qKlxuICogIFVzaW5nIHN0cmluZ3MgaW4gRXRoZXJldW0gKG9yIGFueSBzZWN1cml0eS1iYXNkIHN5c3RlbSkgcmVxdWlyZXNcbiAqICBhZGRpdGlvbmFsIGNhcmUuIFRoZXNlIHV0aWxpdGllcyBhdHRlbXB0IHRvIG1pdGlnYXRlIHNvbWUgb2YgdGhlXG4gKiAgc2FmZXR5IGlzc3VlcyBhcyB3ZWxsIGFzIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gcmVjb3ZlciBhbmQgYW5hbHlzZVxuICogIHN0cmluZ3MuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6U3RyaW5ncyBhbmQgVVRGLTggIFthYm91dC1zdHJpbmdzXVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBhc3NlcnROb3JtYWxpemUgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLCBcImJ5dGVzXCIsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGludmFsaWQgcHJlZml4IChpbmNsdWRpbmcgc3RyYXkgY29udGludWF0aW9uKSwgc2tpcCBhbnkgYWRkaXRpb25hbCBjb250aW51YXRpb24gYnl0ZXNcbiAgICBpZiAocmVhc29uID09PSBcIkJBRF9QUkVGSVhcIiB8fCByZWFzb24gPT09IFwiVU5FWFBFQ1RFRF9DT05USU5VRVwiKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgbyA9IG9mZnNldCArIDE7IG8gPCBieXRlcy5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG4gICAgLy8gKGJ1dCB0aGUgZmlyc3QgYnl0ZSB3YXMgcmVhZCBhbHJlYWR5IHJlYWQgYW5kIHRoZXJlZm9yZSBza2lwcGVkKVxuICAgIGlmIChyZWFzb24gPT09IFwiT1ZFUlJVTlwiKSB7XG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuICAgIH1cbiAgICAvLyBOb3RoaW5nIHRvIHNraXBcbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSTE9OR1wiKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoYmFkQ29kZXBvaW50KSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIGJhZCBjb2RlIHBvaW50IGZvciByZXBsYWNlbWVudFwiLCBcImJhZENvZGVwb2ludFwiLCBiYWRDb2RlcG9pbnQpO1xuICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XG4gICAgb3V0cHV0LnB1c2goMHhmZmZkKTtcbiAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgYXMgaWYgaWdub3JpbmcgZXJyb3JzXG4gICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XG59XG4vKipcbiAqICBBIGhhbmRmdWwgb2YgcG9wdWxhciwgYnVpbHQtaW4gVVRGLTggZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ2llcy5cbiAqXG4gKiAgKipgYFwiZXJyb3JcImBgKiogLSB0aHJvd3Mgb24gQU5ZIGlsbGVnYWwgVVRGLTggc2VxdWVuY2Ugb3JcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50cyAodGhpcyBpcyB0aGUgZGVmYXVsdClcbiAqXG4gKiAgKipgYFwiaWdub3JlXCJgYCoqIC0gc2lsZW50bHkgZHJvcHMgYW55IGlsbGVnYWwgVVRGLTggc2VxdWVuY2VcbiAqICBhbmQgYWNjZXB0cyBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICAqKmBgXCJyZXBsYWNlXCJgYCoqIC0gcmVwbGFjZSBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSB3aXRoIHRoZVxuICogIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoaS5lLiBgYFwiXFxcXHVmZmZkXCJgYCkgYW5kIGFjY2VwdHNcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICBAcmV0dXJuczogUmVjb3JkPFwiZXJyb3JcIiB8IFwiaWdub3JlXCIgfCBcInJlcGxhY2VcIiwgVXRmOEVycm9yRnVuYz5cbiAqL1xuZXhwb3J0IGNvbnN0IFV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhfYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG4gICAgICAgIG9uRXJyb3IgPSBVdGY4RXJyb3JGdW5jcy5lcnJvcjtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhfYnl0ZXMsIFwiYnl0ZXNcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgLy8gMHh4eCB4eHh4XG4gICAgICAgIGlmIChjID4+IDcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlieXRlOyBob3cgbWFueSBieXRlcyBsZWZ0IGZvciB0aGlzIGNoYXJhY3Rlcj9cbiAgICAgICAgbGV0IGV4dHJhTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgbGV0IG92ZXJsb25nTWFzayA9IG51bGw7XG4gICAgICAgIC8vIDExMHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgaWYgKChjICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2Y7XG4gICAgICAgICAgICAvLyAxMTEwIHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2ZmO1xuICAgICAgICAgICAgLy8gMTExMSAweHh4IDEweHggeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAzO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHhmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChjICYgMHhjMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIkJBRF9QUkVGSVhcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG4gICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1ZFUlJVTlwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgICBsZXQgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk1JU1NJTkdfQ09OVElOVUVcIiwgaSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgNikgfCAobmV4dENoYXIgJiAweDNmKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgYWJvdmUgbG9vcCBmb3IgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXhpbXVtIGNvZGUgcG9pbnRcbiAgICAgICAgaWYgKHJlcyA+IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVVRfT0ZfUkFOR0VcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVVEYxNl9TVVJST0dBVEVcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG4gICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSTE9OR1wiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggYnl0ZSByZXByZXNlbnRhdGlvbiBvZiAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoc3RyKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZyB2YWx1ZVwiLCBcInN0clwiLCBzdHIpO1xuICAgIGlmIChmb3JtICE9IG51bGwpIHtcbiAgICAgICAgYXNzZXJ0Tm9ybWFsaXplKGZvcm0pO1xuICAgICAgICBzdHIgPSBzdHIubm9ybWFsaXplKGZvcm0pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaSA8IHN0ci5sZW5ndGggJiYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCksIFwiaW52YWxpZCBzdXJyb2dhdGUgcGFpclwiLCBcInN0clwiLCBzdHIpO1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG47XG4vL2V4cG9ydCBcbmZ1bmN0aW9uIF90b1V0ZjhTdHJpbmcoY29kZVBvaW50cykge1xuICAgIHJldHVybiBjb2RlUG9pbnRzLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSwgKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApKTtcbiAgICB9KS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5IHRoZSBVVEYtOCBkYXRhICUlYnl0ZXMlJS5cbiAqXG4gKiAgV2hlbiAlJW9uRXJyb3IlJSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IGlzIGNhbGxlZCBvbiBVVEYtOFxuICogIGVycm9ycyBhbGxvd2luZyByZWNvdmVyeSB1c2luZyB0aGUgW1tVdGY4RXJyb3JGdW5jXV0gQVBJLlxuICogIChkZWZhdWx0OiBbZXJyb3JdKFV0ZjhFcnJvckZ1bmNzKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBjb2RlLXBvaW50cyBmb3IgJSVzdHIlJS5cbiAqXG4gKiAgSWYgJSVmb3JtJSUgaXMgc3BlY2lmaWVkLCB0aGUgc3RyaW5nIGlzIG5vcm1hbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhDb2RlUG9pbnRzKHN0ciwgZm9ybSkge1xuICAgIHJldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0LCBtYWtlRXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHZXRVcmwob3B0aW9ucykge1xuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFVybChyZXEsIF9zaWduYWwpIHtcbiAgICAgICAgYXNzZXJ0KF9zaWduYWwgPT0gbnVsbCB8fCAhX3NpZ25hbC5jYW5jZWxsZWQsIFwicmVxdWVzdCBjYW5jZWxsZWQgYmVmb3JlIHNlbmRpbmdcIiwgXCJDQU5DRUxMRURcIik7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gcmVxLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYXNzZXJ0KHByb3RvY29sID09PSBcImh0dHBcIiB8fCBwcm90b2NvbCA9PT0gXCJodHRwc1wiLCBgdW5zdXBwb3J0ZWQgcHJvdG9jb2wgJHtwcm90b2NvbH1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBpbmZvOiB7IHByb3RvY29sIH0sXG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBhc3NlcnQocHJvdG9jb2wgPT09IFwiaHR0cHNcIiB8fCAhcmVxLmNyZWRlbnRpYWxzIHx8IHJlcS5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24sIFwiaW5zZWN1cmUgYXV0aG9yaXplZCBjb25uZWN0aW9ucyB1bnN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZXJyb3IgPSBtYWtlRXJyb3IoXCJyZXF1ZXN0IHRpbWVvdXRcIiwgXCJUSU1FT1VUXCIpO1xuICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9LCByZXEudGltZW91dCk7XG4gICAgICAgIGlmIChfc2lnbmFsKSB7XG4gICAgICAgICAgICBfc2lnbmFsLmFkZExpc3RlbmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG1ha2VFcnJvcihcInJlcXVlc3QgY2FuY2VsbGVkXCIsIFwiQ0FOQ0VMTEVEXCIpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXQgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhBcnJheS5mcm9tKHJlcSkpLFxuICAgICAgICAgICAgYm9keTogcmVxLmJvZHkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlc3A7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwID0gYXdhaXQgZmV0Y2gocmVxLnVybCwgaW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgX2Vycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmVzcC5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwQm9keSA9IGF3YWl0IHJlc3AuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgYm9keSA9IChyZXNwQm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheShyZXNwQm9keSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2U6IHJlc3Auc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnMsIGJvZHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFVybDtcbn1cbi8vIEBUT0RPOiByZW1vdmUgaW4gdjc7IHByb3ZpZGVkIGZvciBiYWNrd2FyZHMgY29tcGF0XG5jb25zdCBkZWZhdWx0R2V0VXJsID0gY3JlYXRlR2V0VXJsKHt9KTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVcmwocmVxLCBfc2lnbmFsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRHZXRVcmwocmVxLCBfc2lnbmFsKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHVybC1icm93c2VyLmpzLm1hcCIsIi8qKlxuICogIEZldGNoaW5nIGNvbnRlbnQgZnJvbSB0aGUgd2ViIGlzIGVudmlyb25tZW50LXNwZWNpZmljLCBzbyBFdGhlcnNcbiAqICBwcm92aWRlcyBhbiBhYnN0cmFjdGlvbiB0aGF0IGVhY2ggZW52aXJvbm1lbnQgY2FuIGltcGxlbWVudCB0byBwcm92aWRlXG4gKiAgdGhpcyBzZXJ2aWNlLlxuICpcbiAqICBPbiBbTm9kZS5qc10obGluay1ub2RlKSwgdGhlIGBgaHR0cGBgIGFuZCBgYGh0dHBzYGAgbGlicyBhcmUgdXNlZCB0b1xuICogIGNyZWF0ZSBhIHJlcXVlc3Qgb2JqZWN0LCByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgYW5kIHByb2Nlc3MgZGF0YVxuICogIGFuZCBwb3B1bGF0ZSB0aGUgW1tGZXRjaFJlc3BvbnNlXV0uXG4gKlxuICogIEluIGEgYnJvd3NlciwgdGhlIFtET00gZmV0Y2hdKGxpbmstanMtZmV0Y2gpIGlzIHVzZWQsIGFuZCB0aGUgcmVzdWx0aW5nXG4gKiAgYGBQcm9taXNlYGAgaXMgd2FpdGVkIG9uIHRvIHJldHJpZXZlIHRoZSBwYXlsb2FkLlxuICpcbiAqICBUaGUgW1tGZXRjaFJlcXVlc3RdXSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgbWFueSBjb21tb24gc2l0dWF0aW9ucyxcbiAqICBzdWNoIGFzIHJlZGlyZWN0cywgc2VydmVyIHRocm90dGxpbmcsIGF1dGhlbnRpY2F0aW9uLCBldGMuXG4gKlxuICogIEl0IGFsc28gaGFuZGxlcyBjb21tb24gZ2F0ZXdheXMsIHN1Y2ggYXMgSVBGUyBhbmQgZGF0YSBVUklzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2ZldGNoaW5nOkZldGNoaW5nIFdlYiBDb250ZW50ICBbYWJvdXQtZmV0Y2hdXG4gKi9cbmltcG9ydCB7IGRlY29kZUJhc2U2NCwgZW5jb2RlQmFzZTY0IH0gZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi91dGY4LmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVHZXRVcmwgfSBmcm9tIFwiLi9nZXR1cmwuanNcIjtcbmNvbnN0IE1BWF9BVFRFTVBUUyA9IDEyO1xuY29uc3QgU0xPVF9JTlRFUlZBTCA9IDI1MDtcbi8vIFRoZSBnbG9iYWwgRmV0Y2hHZXRVcmxGdW5jIGltcGxlbWVudGF0aW9uLlxubGV0IGRlZmF1bHRHZXRVcmxGdW5jID0gY3JlYXRlR2V0VXJsKCk7XG5jb25zdCByZURhdGEgPSBuZXcgUmVnRXhwKFwiXmRhdGE6KFteOzpdKik/KDtiYXNlNjQpPywoLiopJFwiLCBcImlcIik7XG5jb25zdCByZUlwZnMgPSBuZXcgUmVnRXhwKFwiXmlwZnM6L1xcLyhpcGZzLyk/KC4qKSRcIiwgXCJpXCIpO1xuLy8gSWYgbG9ja2VkLCBuZXcgR2F0ZXdheXMgY2Fubm90IGJlIGFkZGVkXG5sZXQgbG9ja2VkID0gZmFsc2U7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJMc1xuYXN5bmMgZnVuY3Rpb24gZGF0YUdhdGV3YXlGdW5jKHVybCwgc2lnbmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVEYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSgyMDAsIFwiT0tcIiwge1xuICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogKG1hdGNoWzFdIHx8IFwidGV4dC9wbGFpblwiKSxcbiAgICAgICAgfSwgKG1hdGNoWzJdID8gZGVjb2RlQmFzZTY0KG1hdGNoWzNdKSA6IHVucGVyY2VudChtYXRjaFszXSkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIFwiQkFEIFJFUVVFU1QgKGludmFsaWQgZGF0YTogVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tGZXRjaEdhdGV3YXlGdW5jXV0gZm9yIGZldGNoaW5nIGNvbnRlbnQgZnJvbSBhIHN0YW5kYXJkXG4gKiAgSVBGUyBnYXRld2F5IGhvc3RlZCBhdCAlJWJhc2VVcmwlJS5cbiAqL1xuZnVuY3Rpb24gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnYXRld2F5SXBmcyh1cmwsIHNpZ25hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVJcGZzKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGxpbmtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVxdWVzdChgJHtiYXNlVXJsfSR7bWF0Y2hbMl19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIElQRlMgVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2F0ZXdheUlwZnM7XG59XG5jb25zdCBHYXRld2F5cyA9IHtcbiAgICBcImRhdGFcIjogZGF0YUdhdGV3YXlGdW5jLFxuICAgIFwiaXBmc1wiOiBnZXRJcGZzR2F0ZXdheUZ1bmMoXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCIpXG59O1xuY29uc3QgZmV0Y2hTaWduYWxzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaENhbmNlbFNpZ25hbCB7XG4gICAgI2xpc3RlbmVycztcbiAgICAjY2FuY2VsbGVkO1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBmZXRjaFNpZ25hbHMuc2V0KHJlcXVlc3QsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgbGlzdGVuZXIoKTsgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy4jY2FuY2VsbGVkLCBcInNpbmdhbCBhbHJlYWR5IGNhbmNlbGxlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZmV0Y2hDYW5jZWxTaWduYWwuYWRkQ2FuY2VsTGlzdGVuZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICBnZXQgY2FuY2VsbGVkKCkgeyByZXR1cm4gdGhpcy4jY2FuY2VsbGVkOyB9XG4gICAgY2hlY2tTaWduYWwoKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5jYW5jZWxsZWQsIFwiY2FuY2VsbGVkXCIsIFwiQ0FOQ0VMTEVEXCIsIHt9KTtcbiAgICB9XG59XG4vLyBDaGVjayB0aGUgc2lnbmFsLCB0aHJvd2luZyBpZiBpdCBpcyBjYW5jZWxsZWRcbmZ1bmN0aW9uIGNoZWNrU2lnbmFsKHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgfVxuICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xuICAgIHJldHVybiBzaWduYWw7XG59XG4vKipcbiAqICBSZXByZXNlbnRzIGEgcmVxdWVzdCBmb3IgYSByZXNvdXJjZSB1c2luZyBhIFVSSS5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgdGhlIHN1cHBvcnRlZCBzY2hlbWVzIGFyZSBgYEhUVFBgYCwgYGBIVFRQU2BgLCBgYGRhdGE6YGAsXG4gKiAgYW5kIGBgSVBGUzpgYC5cbiAqXG4gKiAgQWRkaXRpb25hbCBzY2hlbWVzIGNhbiBiZSBhZGRlZCBnbG9iYWxseSB1c2luZyBbW3JlZ2lzdGVyR2F0ZXdheV1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QoXCJodHRwczovL3d3dy5yaWNtb28uY29tXCIpXG4gKiAgICByZXNwID0gYXdhaXQgcmVxLnNlbmQoKVxuICogICAgcmVzcC5ib2R5Lmxlbmd0aFxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hSZXF1ZXN0IHtcbiAgICAjYWxsb3dJbnNlY3VyZTtcbiAgICAjZ3ppcDtcbiAgICAjaGVhZGVycztcbiAgICAjbWV0aG9kO1xuICAgICN0aW1lb3V0O1xuICAgICN1cmw7XG4gICAgI2JvZHk7XG4gICAgI2JvZHlUeXBlO1xuICAgICNjcmVkcztcbiAgICAvLyBIb29rc1xuICAgICNwcmVmbGlnaHQ7XG4gICAgI3Byb2Nlc3M7XG4gICAgI3JldHJ5O1xuICAgICNzaWduYWw7XG4gICAgI3Rocm90dGxlO1xuICAgICNnZXRVcmxGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmV0Y2ggVVJMIHRvIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxuICAgIHNldCB1cmwodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGZldGNoIGJvZHksIGlmIGFueSwgdG8gc2VuZCBhcyB0aGUgcmVxdWVzdCBib2R5LiAvLyhkZWZhdWx0OiBudWxsKS8vXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGEgYm9keSwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiAgc2V0IGFuZCB3aWxsIGJlIHVzZWQgaWYgKipub3Qgb3ZlcnJpZGRlbioqIGJ5IHNldHRpbmcgYSBjdXN0b21cbiAgICAgKiAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIElmICUlYm9keSUlIGlzIG51bGwsIHRoZSBib2R5IGlzIGNsZWFyZWQgKGFsb25nIHdpdGggdGhlXG4gICAgICogIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgKS5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIHN0cmluZywgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIHNldCB0b1xuICAgICAqICBgYHRleHQvcGxhaW5gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIFVpbnQ4QXJyYXksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhbnkgb3RoZXIgb2JqZWN0LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXNcbiAgICAgKiAgc2V0IHRvIGBgYXBwbGljYXRpb24vanNvbmBgLlxuICAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICBpZiAodGhpcy4jYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICAgIHNldCBib2R5KGJvZHkpIHtcbiAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhib2R5KTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhKU09OLnN0cmluZ2lmeShib2R5KSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib2R5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBJZiBubyBtZXRob2RcbiAgICAgKiAgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQsIHRoZW4gYGBHRVRgYCBpcyB1c2VkIGlmIHRoZSBib2R5IGlzXG4gICAgICogIG51bGwgYW5kIGBgUE9TVGBgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICBpZiAodGhpcy4jbWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0JvZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUE9TVFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkdFVFwiO1xuICAgIH1cbiAgICBzZXQgbWV0aG9kKG1ldGhvZCkge1xuICAgICAgICBpZiAobWV0aG9kID09IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWV0aG9kID0gU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBBbGxcbiAgICAgKiAga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKlxuICAgICAqICBUaGlzIG9iamVjdCBpcyBhIGNvcHksIHNvIGFueSBjaGFuZ2VzIHdpbGwgKipOT1QqKiBiZSByZWZsZWN0ZWRcbiAgICAgKiAgaW4gdGhlIGBgRmV0Y2hSZXF1ZXN0YGAuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IGEgaGVhZGVyIGVudHJ5LCB1c2UgdGhlIGBgc2V0SGVhZGVyYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNjcmVkcykge1xuICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmFzaWMgJHtlbmNvZGVCYXNlNjQodG9VdGY4Qnl0ZXModGhpcy4jY3JlZHMpKX1gO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdID0gXCJnemlwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPT0gbnVsbCAmJiB0aGlzLiNib2R5VHlwZSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHRoaXMuI2JvZHlUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IFN0cmluZyh0aGlzLmJvZHkubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgaGVhZGVyIGZvciAlJWtleSUlLCBpZ25vcmluZyBjYXNlLlxuICAgICAqL1xuICAgIGdldEhlYWRlcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSB0byAlJXZhbHVlJSUuIEFsbCB2YWx1ZXMgYXJlIGNvZXJjZWRcbiAgICAgKiAgdG8gYSBzdHJpbmcuXG4gICAgICovXG4gICAgc2V0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy4jaGVhZGVyc1tTdHJpbmcoa2V5KS50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDbGVhciBhbGwgaGVhZGVycywgcmVzZXR0aW5nIGFsbCBpbnRyaW5zaWMgaGVhZGVycy5cbiAgICAgKi9cbiAgICBjbGVhckhlYWRlcnMoKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtrZXksIGhlYWRlcnNba2V5XV0sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgc2VudCBmb3IgdGhlIGBgQXV0aG9yaXphdGlvbmBgIGhlYWRlci5cbiAgICAgKlxuICAgICAqICBUbyBzZXQgdGhlIGNyZWRlbnRpYWxzLCB1c2UgdGhlIGBgc2V0Q3JlZGVudGlhbHNgYCBtZXRob2QuXG4gICAgICovXG4gICAgZ2V0IGNyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY3JlZHMgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldHMgYW4gYGBBdXRob3JpemF0aW9uYGAgZm9yICUldXNlcm5hbWUlJSB3aXRoICUlcGFzc3dvcmQlJS5cbiAgICAgKi9cbiAgICBzZXRDcmVkZW50aWFscyh1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXVzZXJuYW1lLm1hdGNoKC86LyksIFwiaW52YWxpZCBiYXNpYyBhdXRoZW50aWNhdGlvbiB1c2VybmFtZVwiLCBcInVzZXJuYW1lXCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgdGhpcy4jY3JlZHMgPSBgJHt1c2VybmFtZX06JHtwYXNzd29yZH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5hYmxlIGFuZCByZXF1ZXN0IGd6aXAtZW5jb2RlZCByZXNwb25zZXMuIFRoZSByZXNwb25zZSB3aWxsXG4gICAgICogIGF1dG9tYXRpY2FsbHkgYmUgZGVjb21wcmVzc2VkLiAvLyhkZWZhdWx0OiB0cnVlKS8vXG4gICAgICovXG4gICAgZ2V0IGFsbG93R3ppcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2d6aXA7XG4gICAgfVxuICAgIHNldCBhbGxvd0d6aXAodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ3ppcCA9ICEhdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGxvdyBgYEF1dGhlbnRpY2F0aW9uYGAgY3JlZGVudGlhbHMgdG8gYmUgc2VudCBvdmVyIGluc2VjdXJlXG4gICAgICogIGNoYW5uZWxzLiAvLyhkZWZhdWx0OiBmYWxzZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2FsbG93SW5zZWN1cmU7XG4gICAgfVxuICAgIHNldCBhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jYWxsb3dJbnNlY3VyZSA9ICEhdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKSB0byB3YWl0IGZvciBhIGNvbXBsZXRlIHJlc3BvbnNlLlxuICAgICAqICAvLyhkZWZhdWx0OiA1IG1pbnV0ZXMpLy9cbiAgICAgKi9cbiAgICBnZXQgdGltZW91dCgpIHsgcmV0dXJuIHRoaXMuI3RpbWVvdXQ7IH1cbiAgICBzZXQgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHRpbWVvdXQgPj0gMCwgXCJ0aW1lb3V0IG11c3QgYmUgbm9uLXplcm9cIiwgXCJ0aW1lb3V0XCIsIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHByaW9yIHRvIGVhY2ggcmVxdWVzdCwgZm9yIGV4YW1wbGVcbiAgICAgKiAgZHVyaW5nIGEgcmVkaXJlY3Rpb24gb3IgcmV0cnkgaW4gY2FzZSBvZiBzZXJ2ZXIgdGhyb3R0bGluZy5cbiAgICAgKlxuICAgICAqICBUaGlzIG9mZmVycyBhbiBvcHBvcnR1bml0eSB0byBwb3B1bGF0ZSBoZWFkZXJzIG9yIHVwZGF0ZVxuICAgICAqICBjb250ZW50IGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXQgcHJlZmxpZ2h0RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3ByZWZsaWdodCB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcHJlZmxpZ2h0RnVuYyhwcmVmbGlnaHQpIHtcbiAgICAgICAgdGhpcy4jcHJlZmxpZ2h0ID0gcHJlZmxpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCByZXNwb25zZSwgb2ZmZXJpbmcgYW5cbiAgICAgKiAgb3Bwb3J0dW5pdHkgdG8gcHJvdmlkZSBjbGllbnQtbGV2ZWwgdGhyb3R0bGluZyBvciB1cGRhdGluZ1xuICAgICAqICByZXNwb25zZSBkYXRhLlxuICAgICAqXG4gICAgICogIEFueSBlcnJvciB0aHJvd24gaW4gdGhpcyBjYXVzZXMgdGhlIGBgc2VuZCgpYGAgdG8gdGhyb3cuXG4gICAgICpcbiAgICAgKiAgVG8gc2NoZWR1bGUgYSByZXRyeSBhdHRlbXB0IChhc3N1bWluZyB0aGUgbWF4aW11bSByZXRyeSBsaW1pdFxuICAgICAqICBoYXMgbm90IGJlZW4gcmVhY2hlZCksIHVzZSBbW3Jlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcl1dLlxuICAgICAqL1xuICAgIGdldCBwcm9jZXNzRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3MgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByb2Nlc3NGdW5jKHByb2Nlc3MpIHtcbiAgICAgICAgdGhpcy4jcHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIHJldHJ5IGF0dGVtcHQuXG4gICAgICovXG4gICAgZ2V0IHJldHJ5RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JldHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIHNldCByZXRyeUZ1bmMocmV0cnkpIHtcbiAgICAgICAgdGhpcy4jcmV0cnkgPSByZXRyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGZldGNoIGNvbnRlbnQgZnJvbSBIVFRQIGFuZFxuICAgICAqICBIVFRQUyBVUkxzIGFuZCBpcyBwbGF0Zm9ybSBzcGVjaWZpYyAoZS5nLiBub2RlanMgdnNcbiAgICAgKiAgYnJvd3NlcnMpLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYnkgZGVmYXVsdCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybFxuICAgICAqICBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIGNoYW5nZWQgdXNpbmcgW1tyZWdpc3RlckdldFVybF1dLlxuICAgICAqICBJZiB0aGlzIGhhcyBiZWVuIHNldCwgc2V0dGluZyBpcyB0byBgYG51bGxgYCB3aWxsIGNhdXNlXG4gICAgICogIHRoaXMgRmV0Y2hSZXF1ZXN0IChhbmQgYW55IGZ1dHVyZSBjbG9uZXMpIHRvIHJldmVydCBiYWNrIHRvXG4gICAgICogIHVzaW5nIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBnbG9iYWwgZ2V0VXJsIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgdGhpcyBpcyBnZW5lcmFsbHkgbm90IG5lY2Vzc2FyeSwgYnV0IG1heSBiZSB1c2VmdWxcbiAgICAgKiAgZm9yIGRldmVsb3BlcnMgdGhhdCB3aXNoIHRvIGludGVyY2VwdCByZXF1ZXN0cyBvciB0b1xuICAgICAqICBjb25maWd1cmVnZSBhIHByb3h5IG9yIG90aGVyIGFnZW50LlxuICAgICAqL1xuICAgIGdldCBnZXRVcmxGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0VXJsRnVuYyB8fCBkZWZhdWx0R2V0VXJsRnVuYztcbiAgICB9XG4gICAgc2V0IGdldFVybEZ1bmModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2V0VXJsRnVuYyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEZldGNoUmVxdWVzdCBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIE9uY2UgY3JlYXRlZCwgZWFjaCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGJlZm9yZSBpc3N1aW5nIGFcbiAgICAgKiAgYGAuc2VuZCgpYGAgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy4jdXJsID0gU3RyaW5nKHVybCk7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jZ3ppcCA9IHRydWU7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gXCJcIjtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IDMwMDAwMDtcbiAgICAgICAgdGhpcy4jdGhyb3R0bGUgPSB7XG4gICAgICAgICAgICBzbG90SW50ZXJ2YWw6IFNMT1RfSU5URVJWQUwsXG4gICAgICAgICAgICBtYXhBdHRlbXB0czogTUFYX0FUVEVNUFRTXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSBudWxsO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXF1ZXN0IG1ldGhvZD0ke0pTT04uc3RyaW5naWZ5KHRoaXMubWV0aG9kKX0gdXJsPSR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSBoZWFkZXJzPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKX0gYm9keT0ke3RoaXMuI2JvZHkgPyBoZXhsaWZ5KHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVcGRhdGUgdGhlIHRocm90dGxlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXRlcm1pbmUgbWF4aW11bVxuICAgICAqICBhdHRlbXB0cyBhbmQgZXhwb25lbnRpYWwtYmFja29mZiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNldFRocm90dGxlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnNsb3RJbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgPSBwYXJhbXMuc2xvdEludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWF4QXR0ZW1wdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMgPSBwYXJhbXMubWF4QXR0ZW1wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI3NlbmQoYXR0ZW1wdCwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCBfcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGF0dGVtcHQgPj0gdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXhjZWVkZWQgbWF4aW11bSByZXRyeSBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZ2V0VGltZSgpIDw9IGV4cGlyZXMsIFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3Quc2VuZFwiLCByZWFzb246IFwidGltZW91dFwiLCByZXF1ZXN0OiBfcmVxdWVzdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgd2FpdChkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgc2NoZW1lID0gKHJlcS51cmwuc3BsaXQoXCI6XCIpWzBdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIFByb2Nlc3MgYW55IEdhdGV3YXlzXG4gICAgICAgIGlmIChzY2hlbWUgaW4gR2F0ZXdheXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEdhdGV3YXlzW3NjaGVtZV0ocmVxLnVybCwgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZldGNoUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc0Z1bmMocmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgcHJvY2Vzc2luZzsgdGhyb3cgYSA1eHggc2VydmVyIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IudGhyb3R0bGUgPT0gbnVsbCB8fCB0eXBlb2YgKGVycm9yLnN0YWxsKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aHJvdHRsaW5nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgYSBwcmVmbGlnaHQgZnVuY3Rpb247IHVwZGF0ZSB0aGUgcmVxdWVzdFxuICAgICAgICBpZiAodGhpcy5wcmVmbGlnaHRGdW5jKSB7XG4gICAgICAgICAgICByZXEgPSBhd2FpdCB0aGlzLnByZWZsaWdodEZ1bmMocmVxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5nZXRVcmxGdW5jKHJlcSwgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCkpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBuZXcgRmV0Y2hSZXNwb25zZShyZXNwLnN0YXR1c0NvZGUsIHJlc3Auc3RhdHVzTWVzc2FnZSwgcmVzcC5oZWFkZXJzLCByZXNwLmJvZHksIF9yZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpIHtcbiAgICAgICAgICAgIC8vIFJlZGlyZWN0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXEucmVkaXJlY3QobG9jYXRpb24pLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCAwLCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIFRoaW5ncyB3b24ndCBnZXQgYW55IGJldHRlciBvbiBhbm90aGVyIGF0dGVtcHQ7IGFib3J0XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDI5KSB7XG4gICAgICAgICAgICAvLyBUaHJvdHRsZVxuICAgICAgICAgICAgaWYgKHRoaXMucmV0cnlGdW5jID09IG51bGwgfHwgKGF3YWl0IHRoaXMucmV0cnlGdW5jKHJlcSwgcmVzcG9uc2UsIGF0dGVtcHQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzW1wicmV0cnktYWZ0ZXJcIl07XG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsICogTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5QWZ0ZXIpID09PSBcInN0cmluZ1wiICYmIHJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKCkuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZSA9PSBudWxsIHx8IHR5cGVvZiAoZXJyb3Iuc3RhbGwpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhyb3R0bGVcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgKiBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5zdGFsbCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gZXJyb3Iuc3RhbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXEuY2xvbmUoKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIGJ5IHNlbmRpbmcgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgc2VuZCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI3NpZ25hbCA9PSBudWxsLCBcInJlcXVlc3QgYWxyZWFkeSBzZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZldGNoUmVxdWVzdC5zZW5kXCIgfSk7XG4gICAgICAgIHRoaXMuI3NpZ25hbCA9IG5ldyBGZXRjaENhbmNlbFNpZ25hbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3NlbmQoMCwgZ2V0VGltZSgpICsgdGhpcy50aW1lb3V0LCAwLCB0aGlzLCBuZXcgRmV0Y2hSZXNwb25zZSgwLCBcIlwiLCB7fSwgbnVsbCwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FuY2VscyB0aGUgaW5mbGlnaHQgcmVzcG9uc2UsIGNhdXNpbmcgYSBgYENBTkNFTExFRGBgXG4gICAgICogIGVycm9yIHRvIGJlIHJlamVjdGVkIGZyb20gdGhlIFtbc2VuZF1dLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI3NpZ25hbCAhPSBudWxsLCBcInJlcXVlc3QgaGFzIG5vdCBiZWVuIHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LmNhbmNlbFwiIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBmZXRjaFNpZ25hbHMuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAoIXNpZ25hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZldGNoUmVxdWVzdF1dIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVkaXJlY3Rpb25cbiAgICAgKiAgdG8gJSVsb2NhdGlvbiUlLlxuICAgICAqL1xuICAgIHJlZGlyZWN0KGxvY2F0aW9uKSB7XG4gICAgICAgIC8vIFJlZGlyZWN0aW9uOyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBhYnNvbHV0ZSBsb2NhdGlvbnNcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhdGlvbi5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcmVkaXJlY3Rpbmc6XG4gICAgICAgIC8vIC0gbm9uLUdFVCByZXF1ZXN0c1xuICAgICAgICAvLyAtIGRvd25ncmFkaW5nIHRoZSBzZWN1cml0eSAoZS5nLiBodHRwcyA9PiBodHRwKVxuICAgICAgICAvLyAtIHRvIG5vbi1IVFRQIChvciBub24tSFRUUFMpIHByb3RvY29scyBbdGhpcyBjb3VsZCBiZSByZWxheGVkP11cbiAgICAgICAgYXNzZXJ0KHRoaXMubWV0aG9kID09PSBcIkdFVFwiICYmIChjdXJyZW50ICE9PSBcImh0dHBzXCIgfHwgdGFyZ2V0ICE9PSBcImh0dHBcIikgJiYgbG9jYXRpb24ubWF0Y2goL15odHRwcz86LyksIGB1bnN1cHBvcnRlZCByZWRpcmVjdGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlZGlyZWN0KCR7dGhpcy5tZXRob2R9ICR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSA9PiAke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0pYFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHJlcXVlc3QsIHdpdGggYSBuZXcgVVJMXG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QobG9jYXRpb24pO1xuICAgICAgICByZXEubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgcmVxLmFsbG93R3ppcCA9IHRoaXMuYWxsb3dHemlwO1xuICAgICAgICByZXEudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgcmVxLiNoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICByZXEuI2JvZHkgPSBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXEuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIERvIG5vdCBmb3J3YXJkIGNyZWRlbnRpYWxzIHVubGVzcyBvbiB0aGUgc2FtZSBkb21haW47IG9ubHkgYWJzb2x1dGVcbiAgICAgICAgLy9yZXEuYWxsb3dJbnNlY3VyZSA9IGZhbHNlO1xuICAgICAgICAvLyBwYXRocyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZDsgbWF5IHdhbnQgYSB3YXkgdG8gc3BlY2lmeSB0byBmb3J3YXJkP1xuICAgICAgICAvL3NldFN0b3JlKHJlcS4jcHJvcHMsIFwiY3JlZHNcIiwgZ2V0U3RvcmUodGhpcy4jcHJvcywgXCJjcmVkc1wiKSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgY29weSBvZiB0aGlzIHJlcXVlc3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IEZldGNoUmVxdWVzdCh0aGlzLnVybCk7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBtZXRob2RcIiAoaS5lLiBudWxsKVxuICAgICAgICBjbG9uZS4jbWV0aG9kID0gdGhpcy4jbWV0aG9kO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgYm9keVwiIHdpdGggdHlwZSwgY29weWluZyB0aGUgVWludDhBcnJheSBpcyBwcmVzZW50XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICBjbG9uZS4jYm9keSA9IHRoaXMuI2JvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBoZWFkZXJzXCJcbiAgICAgICAgY2xvbmUuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgLy8gQ3JlZGVudGlhbHMgaXMgcmVhZG9ubHksIHNvIHdlIGNvcHkgaW50ZXJuYWxseVxuICAgICAgICBjbG9uZS4jY3JlZHMgPSB0aGlzLiNjcmVkcztcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBjbG9uZS5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGlmICh0aGlzLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbikge1xuICAgICAgICAgICAgY2xvbmUuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS4jcHJlZmxpZ2h0ID0gdGhpcy4jcHJlZmxpZ2h0O1xuICAgICAgICBjbG9uZS4jcHJvY2VzcyA9IHRoaXMuI3Byb2Nlc3M7XG4gICAgICAgIGNsb25lLiNyZXRyeSA9IHRoaXMuI3JldHJ5O1xuICAgICAgICBjbG9uZS4jdGhyb3R0bGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiN0aHJvdHRsZSk7XG4gICAgICAgIGNsb25lLiNnZXRVcmxGdW5jID0gdGhpcy4jZ2V0VXJsRnVuYztcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgTG9ja3MgYWxsIHN0YXRpYyBjb25maWd1cmF0aW9uIGZvciBnYXRld2F5cyBhbmQgRmV0Y2hHZXRVcmxGdW5jXG4gICAgICogIHJlZ2lzdHJhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9ja0NvbmZpZygpIHtcbiAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgY3VycmVudCBHYXRld2F5IGZ1bmN0aW9uIGZvciAlJXNjaGVtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRHYXRld2F5KHNjaGVtZSkge1xuICAgICAgICByZXR1cm4gR2F0ZXdheXNbc2NoZW1lLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVc2UgdGhlICUlZnVuYyUlIHdoZW4gZmV0Y2hpbmcgVVJJcyB1c2luZyAlJXNjaGVtZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdhdGV3YXkoc2NoZW1lLCBmdW5jKSB7XG4gICAgICAgIHNjaGVtZSA9IHNjaGVtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc2NoZW1lID09PSBcImh0dHBcIiB8fCBzY2hlbWUgPT09IFwiaHR0cHNcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgaW50ZXJjZXB0ICR7c2NoZW1lfTsgdXNlIHJlZ2lzdGVyR2V0VXJsYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIEdhdGV3YXlzW3NjaGVtZV0gPSBmdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlICUlZ2V0VXJsJSUgd2hlbiBmZXRjaGluZyBVUklzIG92ZXIgSFRUUCBhbmQgSFRUUFMgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgYWZmZWN0cyBhbGwgcmVxdWVzdHMgZ2xvYmFsbHkuXG4gICAgICpcbiAgICAgKiAgSWYgW1tsb2NrQ29uZmlnXV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjaGFuZ2UgaXMgbWFkZSBhbmQgdGhpc1xuICAgICAqICB0aHJvd3MuXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyR2V0VXJsKGdldFVybCkge1xuICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYXRld2F5cyBsb2NrZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdEdldFVybEZ1bmMgPSBnZXRVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZ2V0VXJsIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyBjb250ZW50IGZyb20gSFRUUCBhbmRcbiAgICAgKiAgSFRUUFMgVVJMcy5cbiAgICAgKlxuICAgICAqICBUaGUgYXZhaWxhYmxlICUlb3B0aW9ucyUlIGFyZSBkZXBlbmRlbnQgb24gdGhlIHBsYXRmb3JtXG4gICAgICogIGltcGxlbWVudGF0aW9uIG9mIHRoZSBkZWZhdWx0IGdldFVybCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgaXMgdXNlZnVsXG4gICAgICogIHdoZW4gdHJ5aW5nIHRvIGN1c3RvbWl6ZSBzaW1wbGUgYmVoYXZpb3VyIHdoZW4gZmV0Y2hpbmcgSFRUUFxuICAgICAqICBjb250ZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVHZXRVcmxGdW5jKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUdldFVybChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBcImZldGNoXCIgZGF0YSBVUklzLlxuICAgICAqXG4gICAgICogIE5vdGUgdGhhdCB0aGlzIGlzIGF1dG9tYXRpY2FsbHkgZG9uZSBpbnRlcm5hbGx5IHRvIHN1cHBvcnRcbiAgICAgKiAgZGF0YSBVUklzLCBzbyBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHJlZ2lzdGVyIGl0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGdlbmVyYWxseSBzb21ldGhpbmcgdGhhdCBpcyBuZWVkZWQsIGJ1dCBtYXlcbiAgICAgKiAgYmUgdXNlZnVsIGluIGEgd3JhcHBlciB0byBwZXJmb20gY3VzdG9tIGRhdGEgVVJJIGZ1bmN0aW9uYWxpdHkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURhdGFHYXRld2F5KCkge1xuICAgICAgICByZXR1cm4gZGF0YUdhdGV3YXlGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBmZXRjaCBJUEZTICh1bnZhbGlkYXRlZCkgZnJvbVxuICAgICAqICBhIGN1c3RvbSBnYXRld2F5IGJhc2VVcmwuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgSVBGUyBnYXRld2F5IHVzZWQgaW50ZXJuYWxseSBpc1xuICAgICAqICBgYFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiYGAuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUlwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgICAgIHJldHVybiBnZXRJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCk7XG4gICAgfVxufVxuO1xuLyoqXG4gKiAgVGhlIHJlc3BvbnNlIGZvciBhIEZldGNoUmVxdWVzdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoUmVzcG9uc2Uge1xuICAgICNzdGF0dXNDb2RlO1xuICAgICNzdGF0dXNNZXNzYWdlO1xuICAgICNoZWFkZXJzO1xuICAgICNib2R5O1xuICAgICNyZXF1ZXN0O1xuICAgICNlcnJvcjtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXNwb25zZSBzdGF0dXM9JHt0aGlzLnN0YXR1c0NvZGV9IGJvZHk9JHt0aGlzLiNib2R5ID8gaGV4bGlmeSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNDb2RlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzQ29kZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2Ugc3RhdHVzIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c01lc3NhZ2UoKSB7IHJldHVybiB0aGlzLiNzdGF0dXNNZXNzYWdlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBoZWFkZXJzLiBBbGwga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5LCBvciBgYG51bGxgYCBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHkgYXMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZywgb3IgdGhlIGVtcHR5XG4gICAgICogIHN0cmluZyAoaS5lLiBgYFwiXCJgYCkgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICpcbiAgICAgKiAgQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBib2R5IGlzIGludmFsaWQgVVRGLTggZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYm9keVRleHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgPT0gbnVsbCkgPyBcIlwiIDogdG9VdGY4U3RyaW5nKHRoaXMuI2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIFVURi04IGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5VGV4dFwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgZGVjb2RlZCBhcyBKU09OLlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIEpTT04tZW5jb2RlZCBkYXRhXG4gICAgICogIG9yIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqL1xuICAgIGdldCBib2R5SnNvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYm9keVRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIEpTT05cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5SnNvblwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHksIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIHRoaXMuI3N0YXR1c01lc3NhZ2UgPSBzdGF0dXNNZXNzYWdlO1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChhY2N1bSwgaykgPT4ge1xuICAgICAgICAgICAgYWNjdW1bay50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyhoZWFkZXJzW2tdKTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLiNib2R5ID0gKChib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KGJvZHkpKTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IChyZXF1ZXN0IHx8IG51bGwpO1xuICAgICAgICB0aGlzLiNlcnJvciA9IHsgbWVzc2FnZTogXCJcIiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgUmVzcG9uc2Ugd2l0aCBtYXRjaGluZyBoZWFkZXJzIGFuZCBib2R5LCBidXQgd2l0aFxuICAgICAqICBhbiBlcnJvciBzdGF0dXMgY29kZSAoaS5lLiA1OTkpIGFuZCAlJW1lc3NhZ2UlJSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUlZXJyb3IlJS5cbiAgICAgKi9cbiAgICBtYWtlU2VydmVyRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgbGV0IHN0YXR1c01lc3NhZ2U7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YDtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX07ICR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgc3RhdHVzTWVzc2FnZSwgdGhpcy5oZWFkZXJzLCB0aGlzLmJvZHksIHRoaXMuI3JlcXVlc3QgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzcG9uc2UuI2Vycm9yID0geyBtZXNzYWdlLCBlcnJvciB9O1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBjYWxsZWQgd2l0aGluIGEgW3JlcXVlc3QucHJvY2Vzc0Z1bmNdKEZldGNoUmVxdWVzdC1wcm9jZXNzRnVuYylcbiAgICAgKiAgY2FsbCwgY2F1c2VzIHRoZSByZXF1ZXN0IHRvIHJldHJ5IGFzIGlmIHRocm90dGxlZCBmb3IgJSVzdGFsbCUlXG4gICAgICogIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICB0aHJvd1Rocm90dGxlRXJyb3IobWVzc2FnZSwgc3RhbGwpIHtcbiAgICAgICAgaWYgKHN0YWxsID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YWxsID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YWxsKSAmJiBzdGFsbCA+PSAwLCBcImludmFsaWQgc3RhbGwgdGltZW91dFwiLCBcInN0YWxsXCIsIHN0YWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwidGhyb3R0bGluZyByZXF1ZXN0c1wiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzdGFsbCwgdGhyb3R0bGU6IHRydWUgfSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBoZWFkZXIgdmFsdWUgZm9yICUla2V5JSUsIGlnbm9yaW5nIGNhc2UuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVxdWVzdCBtYWRlIGZvciB0aGlzIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkgeyByZXR1cm4gdGhpcy4jcmVxdWVzdDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyByZXNwb25zZSB3YXMgYSBzdWNjZXNzIHN0YXR1c0NvZGUuXG4gICAgICovXG4gICAgb2soKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jZXJyb3IubWVzc2FnZSA9PT0gXCJcIiAmJiB0aGlzLnN0YXR1c0NvZGUgPj0gMjAwICYmIHRoaXMuc3RhdHVzQ29kZSA8IDMwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaHJvd3MgYSBgYFNFUlZFUl9FUlJPUmBgIGlmIHRoaXMgcmVzcG9uc2UgaXMgbm90IG9rLlxuICAgICAqL1xuICAgIGFzc2VydE9rKCkge1xuICAgICAgICBpZiAodGhpcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgbWVzc2FnZSwgZXJyb3IgfSA9IHRoaXMuI2Vycm9yO1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGBzZXJ2ZXIgcmVzcG9uc2UgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RVcmwgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXF1ZXN0VXJsID0gdGhpcy5yZXF1ZXN0LnVybDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2VCb2R5ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VCb2R5ID0gdG9VdGY4U3RyaW5nKHRoaXMuI2JvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBtZXNzYWdlLCBcIlNFUlZFUl9FUlJPUlwiLCB7XG4gICAgICAgICAgICByZXF1ZXN0OiAodGhpcy5yZXF1ZXN0IHx8IFwidW5rbm93biByZXF1ZXN0XCIpLCByZXNwb25zZTogdGhpcywgZXJyb3IsXG4gICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFVybCwgcmVzcG9uc2VCb2R5LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlU3RhdHVzOiBgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmZ1bmN0aW9uIHVucGVyY2VudCh2YWx1ZSkge1xuICAgIHJldHVybiB0b1V0ZjhCeXRlcyh2YWx1ZS5yZXBsYWNlKC8lKFswLTlhLWZdWzAtOWEtZl0pL2dpLCAoYWxsLCBjb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNvZGUsIDE2KSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gd2FpdChkZWxheSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIiwiLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5mdW5jdGlvbiBoZXhsaWZ5Qnl0ZSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIGNoaWxkT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoY2hpbGRPZmZzZXQgPCBvZmZzZXQgKyAxICsgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGRhdGEsIGNoaWxkT2Zmc2V0KTtcbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xuICAgICAgICBjaGlsZE9mZnNldCArPSBkZWNvZGVkLmNvbnN1bWVkO1xuICAgICAgICBhc3NlcnQoY2hpbGRPZmZzZXQgPD0gb2Zmc2V0ICsgMSArIGxlbmd0aCwgXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBhc3NlcnQoZGF0YS5sZW5ndGggIT09IDAsIFwiZGF0YSB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoOiAwLCBvZmZzZXQ6IDFcbiAgICB9KTtcbiAgICBjb25zdCBjaGVja09mZnNldCA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgYXNzZXJ0KG9mZnNldCA8PSBkYXRhLmxlbmd0aCwgXCJkYXRhIHNob3J0IHNlZ21lbnQgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IGRhdGEubGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBBcnJheSB3aXRoIGV4dHJhIGxlbmd0aCBwcmVmaXhcbiAgICBpZiAoZGF0YVtvZmZzZXRdID49IDB4ZjgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhmNztcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhiOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGI3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBoZXhsaWZ5KGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMSArIGxlbmd0aCkpO1xuICAgICAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGgpLCByZXN1bHQ6IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjb25zdW1lZDogMSwgcmVzdWx0OiBoZXhsaWZ5Qnl0ZShkYXRhW29mZnNldF0pIH07XG59XG4vKipcbiAqICBEZWNvZGVzICUlZGF0YSUlIGludG8gdGhlIHN0cnVjdHVyZWQgZGF0YSBpdCByZXByZXNlbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmxwKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgMCk7XG4gICAgYXNzZXJ0QXJndW1lbnQoZGVjb2RlZC5jb25zdW1lZCA9PT0gZGF0YS5sZW5ndGgsIFwidW5leHBlY3RlZCBqdW5rIGFmdGVyIHJscCBwYXlsb2FkXCIsIFwiZGF0YVwiLCBfZGF0YSk7XG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmxwLWRlY29kZS5qcy5tYXAiLCIvL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgIHZhbHVlID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGxldCBwYXlsb2FkID0gW107XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgcGF5bG9hZC51bnNoaWZ0KDB4YzAgKyBwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIocGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICBsZW5ndGgudW5zaGlmdCgweGY3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ2V0Qnl0ZXMob2JqZWN0LCBcIm9iamVjdFwiKSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0gPD0gMHg3Zikge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgZGF0YS51bnNoaWZ0KDB4ODAgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIoZGF0YS5sZW5ndGgpO1xuICAgIGxlbmd0aC51bnNoaWZ0KDB4YjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChkYXRhKTtcbn1cbmNvbnN0IG5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIEVuY29kZXMgJSVvYmplY3QlJSBhcyBhbiBSTFAtZW5jb2RlZCBbW0RhdGFIZXhTdHJpbmddXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJscChvYmplY3QpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGZvciAoY29uc3QgdiBvZiBfZW5jb2RlKG9iamVjdCkpIHtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiA+PiA0XTtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiAmIDB4Zl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZW5jb2RlLmpzLm1hcCIsIi8qKlxuICogIEV4cGxhaW4gVVVJRCBhbmQgbGluayB0byBSRkMgaGVyZS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6VVVJRCAgW2Fib3V0LXV1aWRdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgdmVyc2lvbiA0IFtbbGluay11dWlkXV0gZm9yIHRoZSAlJXJhbmRvbUJ5dGVzJSUuXG4gKlxuICogIEBzZWU6IGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmM0MTIyLnR4dCAoU2VjdGlvbiA0LjQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dWlkVjQocmFuZG9tQnl0ZXMpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHJhbmRvbUJ5dGVzLCBcInJhbmRvbUJ5dGVzXCIpO1xuICAgIC8vIFNlY3Rpb246IDQuMS4zOlxuICAgIC8vIC0gdGltZV9oaV9hbmRfdmVyc2lvblsxMjoxNl0gPSAwYjAxMDBcbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgICAvLyBTZWN0aW9uIDQuNFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs2XSA9IDBiMFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs3XSA9IDBiMVxuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xuICAgIGNvbnN0IHZhbHVlID0gaGV4bGlmeShieXRlcyk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDIsIDEwKSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDEwLCAxNCksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygxNCwgMTgpLFxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTgsIDIyKSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDIyLCAzNCksXG4gICAgXS5qb2luKFwiLVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV1aWQuanMubWFwIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgY29uY2F0LCBnZXRCeXRlc0NvcHksIGdldE51bWJlciwgaGV4bGlmeSwgdG9CZUFycmF5LCB0b0JpZ0ludCwgdG9OdW1iZXIsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnRcbi8qLCBpc0Vycm9yKi9cbiB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGNvbnN0IFdvcmRTaXplID0gMzI7XG5jb25zdCBQYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoV29yZFNpemUpO1xuLy8gUHJvcGVydGllcyB1c2VkIHRvIGltbWVkaWF0ZSBwYXNzIHRocm91Z2ggdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0XG4vLyAtIGB0aGVuYCBpcyB1c2VkIHRvIGRldGVjdCBpZiBhbiBvYmplY3QgaXMgYSBQcm9taXNlIGZvciBhd2FpdFxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuY29uc3QgX2d1YXJkID0ge307XG5jb25zdCByZXN1bHROYW1lcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBnZXROYW1lcyhyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0TmFtZXMuZ2V0KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBzZXROYW1lcyhyZXN1bHQsIG5hbWVzKSB7XG4gICAgcmVzdWx0TmFtZXMuc2V0KHJlc3VsdCwgbmFtZXMpO1xufVxuZnVuY3Rpb24gdGhyb3dFcnJvcihuYW1lLCBlcnJvcikge1xuICAgIGNvbnN0IHdyYXBwZWQgPSBuZXcgRXJyb3IoYGRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyAke25hbWV9YCk7XG4gICAgd3JhcHBlZC5lcnJvciA9IGVycm9yO1xuICAgIHRocm93IHdyYXBwZWQ7XG59XG5mdW5jdGlvbiB0b09iamVjdChuYW1lcywgaXRlbXMsIGRlZXApIHtcbiAgICBpZiAobmFtZXMuaW5kZXhPZihudWxsKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b09iamVjdChnZXROYW1lcyhpdGVtKSwgaXRlbSwgZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgaXRlbSA9IGl0ZW1zLmdldFZhbHVlKG5hbWUpO1xuICAgICAgICBpZiAoIShuYW1lIGluIGFjY3VtKSkge1xuICAgICAgICAgICAgaWYgKGRlZXAgJiYgaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0b09iamVjdChnZXROYW1lcyhpdGVtKSwgaXRlbSwgZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2N1bVtuYW1lXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogIEEgW1tSZXN1bHRdXSBpcyBhIHN1Yi1jbGFzcyBvZiBBcnJheSwgd2hpY2ggYWxsb3dzIGFjY2Vzc2luZyBhbnlcbiAqICBvZiBpdHMgdmFsdWVzIGVpdGhlciBwb3NpdGlvbmFsbHkgYnkgaXRzIGluZGV4IG9yLCBpZiBrZXlzIGFyZVxuICogIHByb3ZpZGVkIGJ5IGl0cyBuYW1lLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2FiaVxuICovXG5leHBvcnQgY2xhc3MgUmVzdWx0IGV4dGVuZHMgQXJyYXkge1xuICAgIC8vIE5vIGxvbmdlciB1c2VkOyBidXQgY2Fubm90IGJlIHJlbW92ZWQgYXMgaXQgd2lsbCByZW1vdmUgdGhlXG4gICAgLy8gI3ByaXZhdGUgZmllbGQgZnJvbSB0aGUgLmQudHMgd2hpY2ggbWF5IGJyZWFrIGJhY2t3YXJkc1xuICAgIC8vIGNvbXBhdGliaWxpdHlcbiAgICAjbmFtZXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAvLyBUbyBwcm9wZXJseSBzdWItY2xhc3MgQXJyYXkgc28gdGhlIG90aGVyIGJ1aWx0LWluXG4gICAgICAgIC8vIGZ1bmN0aW9ucyB3b3JrLCB0aGUgY29uc3RydWN0b3IgaGFzIHRvIGJlaGF2ZSBmYWlybHlcbiAgICAgICAgLy8gd2VsbC4gU28sIGluIHRoZSBldmVudCB3ZSBhcmUgY3JlYXRlZCB2aWEgZnJvbUl0ZW1zKClcbiAgICAgICAgLy8gd2UgYnVpbGQgdGhlIHJlYWQtb25seSBSZXN1bHQgb2JqZWN0IHdlIHdhbnQsIGJ1dCBvblxuICAgICAgICAvLyBhbnkgb3RoZXIgaW5wdXQsIHdlIHVzZSB0aGUgZGVmYXVsdCBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBjb25zdHJ1Y3RvcihndWFyZDogYW55LCBpdGVtczogQXJyYXk8YW55Piwga2V5cz86IEFycmF5PG51bGwgfCBzdHJpbmc+KTtcbiAgICAgICAgY29uc3QgZ3VhcmQgPSBhcmdzWzBdO1xuICAgICAgICBsZXQgaXRlbXMgPSBhcmdzWzFdO1xuICAgICAgICBsZXQgbmFtZXMgPSAoYXJnc1syXSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgbGV0IHdyYXAgPSB0cnVlO1xuICAgICAgICBpZiAoZ3VhcmQgIT09IF9ndWFyZCkge1xuICAgICAgICAgICAgaXRlbXMgPSBhcmdzO1xuICAgICAgICAgICAgbmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHdyYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW4ndCBqdXN0IHBhc3MgaW4gLi4uaXRlbXMgc2luY2UgYW4gYXJyYXkgb2YgbGVuZ3RoIDFcbiAgICAgICAgLy8gaXMgYSBzcGVjaWFsIGNhc2UgaW4gdGhlIHN1cGVyLlxuICAgICAgICBzdXBlcihpdGVtcy5sZW5ndGgpO1xuICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4geyB0aGlzW2luZGV4XSA9IGl0ZW07IH0pO1xuICAgICAgICAvLyBGaW5kIGFsbCB1bmlxdWUga2V5c1xuICAgICAgICBjb25zdCBuYW1lQ291bnRzID0gbmFtZXMucmVkdWNlKChhY2N1bSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBhY2N1bS5zZXQobmFtZSwgKGFjY3VtLmdldChuYW1lKSB8fCAwKSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCAobmV3IE1hcCgpKSk7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkga2V5IHRoYXRzIG5vdCB1bmlxdWVcbiAgICAgICAgc2V0TmFtZXModGhpcywgT2JqZWN0LmZyZWV6ZShpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lQ291bnRzLmdldChuYW1lKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKSk7XG4gICAgICAgIC8vIER1bW15IG9wZXJhdGlvbnMgdG8gcHJldmVudCBUeXBlU2NyaXB0IGZyb20gY29tcGxhaW5pbmdcbiAgICAgICAgdGhpcy4jbmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuI25hbWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHZvaWQgKHRoaXMuI25hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdyYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHdyYXBwZWQgUmVzdWx0IGlzIGltbXV0YWJsZVxuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICAvLyBQcm94eSBpbmRpY2VzIGFuZCBuYW1lcyBzbyB3ZSBjYW4gdHJhcCBkZWZlcnJlZCBlcnJvcnNcbiAgICAgICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGV4IGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihwcm9wLCBcIiVpbmRleFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByZXN1bHQgcmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGFyZ2V0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb25zIHdvcmsgd2l0aCBwcml2YXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eSNub19wcml2YXRlX3Byb3BlcnR5X2ZvcndhcmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSgodGhpcyA9PT0gcmVjZWl2ZXIpID8gdGFyZ2V0IDogdGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSBuYW1lIGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldFZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldE5hbWVzKHByb3h5LCBnZXROYW1lcyh0aGlzKSk7XG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFJlc3VsdCBhcyBhIG5vcm1hbCBBcnJheS4gSWYgJSVkZWVwJSUsIGFueSBjaGlsZHJlblxuICAgICAqICB3aGljaCBhcmUgUmVzdWx0IG9iamVjdHMgYXJlIGFsc28gY29udmVydGVkIHRvIGEgbm9ybWFsIEFycmF5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkXG4gICAgICogIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b0FycmF5KGRlZXApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZXAgJiYgaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnRvQXJyYXkoZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYW4gT2JqZWN0IHdpdGggZWFjaCBuYW1lLXZhbHVlIHBhaXIuIElmXG4gICAgICogICUlZGVlcCUlLCBhbnkgY2hpbGRyZW4gd2hpY2ggYXJlIFJlc3VsdCBvYmplY3RzIGFyZSBhbHNvXG4gICAgICogIGNvbnZlcnRlZCB0byBhbiBPYmplY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIGFueSB2YWx1ZSBpcyB1bm5hbWVkLCBvciBpZiB0aGVyZSBhcmVcbiAgICAgKiAgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b09iamVjdChkZWVwKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gZ2V0TmFtZXModGhpcyk7XG4gICAgICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0KG5hbWUgIT0gbnVsbCwgYHZhbHVlIGF0IGluZGV4ICR7aW5kZXh9IHVubmFtZWRgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvT2JqZWN0KClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdG9PYmplY3QobmFtZXMsIHRoaXMsIGRlZXApO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgZW5kICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgICAgICBlbmQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX25hbWVzID0gZ2V0TmFtZXModGhpcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpc1tpXSk7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKF9uYW1lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCByZXN1bHQsIG5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgZmlsdGVyKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IF9uYW1lcyA9IGdldE5hbWVzKHRoaXMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goX25hbWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIHJlc3VsdCwgbmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBtYXAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpfWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHZhbHVlIGZvciAlJW5hbWUlJS5cbiAgICAgKlxuICAgICAqICBTaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGEga2V5IHdob3NlIG5hbWUgY29uZmxpY3RzIHdpdGhcbiAgICAgKiAgYSBtZXRob2Qgb24gYSBbW1Jlc3VsdF1dIG9yIGl0cyBzdXBlcmNsYXNzIEFycmF5LCBvciBhbnlcbiAgICAgKiAgSmF2YVNjcmlwdCBrZXl3b3JkLCB0aGlzIGVuc3VyZXMgYWxsIG5hbWVkIHZhbHVlcyBhcmUgc3RpbGxcbiAgICAgKiAgYWNjZXNzaWJsZSBieSBuYW1lLlxuICAgICAqL1xuICAgIGdldFZhbHVlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXROYW1lcyh0aGlzKS5pbmRleE9mKG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIHZhbHVlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbUmVzdWx0XV0gZm9yICUlaXRlbXMlJSB3aXRoIGVhY2ggZW50cnlcbiAgICAgKiAgYWxzbyBhY2Nlc3NpYmxlIGJ5IGl0cyBjb3JyZXNwb25kaW5nIG5hbWUgaW4gJSVrZXlzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21JdGVtcyhpdGVtcywga2V5cykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIGl0ZW1zLCBrZXlzKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGFsbCBlcnJvcnMgZm91bmQgaW4gYSBbW1Jlc3VsdF1dLlxuICpcbiAqICBTaW5jZSBjZXJ0YWluIGVycm9ycyBlbmNvdW50ZXJlZCB3aGVuIGNyZWF0aW5nIGEgW1tSZXN1bHRdXSBkb1xuICogIG5vdCBpbXBhY3QgdGhlIGFiaWxpdHkgdG8gY29udGludWUgcGFyc2luZyBkYXRhLCB0aGV5IGFyZVxuICogIGRlZmVycmVkIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5IGFjY2Vzc2VkLiBIZW5jZSBhIGZhdWx0eSBzdHJpbmdcbiAqICBpbiBhbiBFdmVudCB0aGF0IGlzIG5ldmVyIHVzZWQgZG9lcyBub3QgaW1wYWN0IHRoZSBwcm9ncmFtIGZsb3cuXG4gKlxuICogIEhvd2V2ZXIsIHNvbWV0aW1lcyBpdCBtYXkgYmUgdXNlZnVsIHRvIGFjY2VzcywgaWRlbnRpZnkgb3JcbiAqICB2YWxpZGF0ZSBjb3JyZWN0bmVzcyBvZiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIEBfZG9jbG9jIGFwaS9hYmlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVzdWx0RXJyb3JzKHJlc3VsdCkge1xuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGVycm9yIChpZiBhbnkpXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY2hlY2tFcnJvcnMgPSBmdW5jdGlvbiAocGF0aCwgb2JqZWN0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRQYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjaGVja0Vycm9ycyhbXSwgcmVzdWx0KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBsZXQgYnl0ZXMgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGFzc2VydChieXRlcy5sZW5ndGggPD0gV29yZFNpemUsIFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBXb3JkU2l6ZSwgb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gV29yZFNpemUpIHtcbiAgICAgICAgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoY29uY2F0KFtQYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplKSwgYnl0ZXNdKSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlciB7XG4gICAgLy8gVGhlIGNvZGVyIG5hbWU6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlLCBhcnJheSwgZXRjLlxuICAgIG5hbWU7XG4gICAgLy8gVGhlIGZ1bGx5IGV4cGFuZGVkIHR5cGUsIGluY2x1ZGluZyBjb21wb3NpdGUgdHlwZXM6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlKGFkZHJlc3MsYnl0ZXMpLCB1aW50MjU2WzNdWzRdW10sICBldGMuXG4gICAgdHlwZTtcbiAgICAvLyBUaGUgbG9jYWxOYW1lIGJvdW5kIGluIHRoZSBzaWduYXR1cmUsIGluIHRoaXMgZXhhbXBsZSBpdCBpcyBcImJhelwiOlxuICAgIC8vICAgLSB0dXBsZShhZGRyZXNzIGZvbywgdWludCBiYXIpIGJhelxuICAgIGxvY2FsTmFtZTtcbiAgICAvLyBXaGV0aGVyIHRoaXMgdHlwZSBpcyBkeW5hbWljOlxuICAgIC8vICAtIER5bmFtaWM6IGJ5dGVzLCBzdHJpbmcsIGFkZHJlc3NbXSwgdHVwbGUoYm9vbGVhbltdKSwgZXRjLlxuICAgIC8vICAtIE5vdCBEeW5hbWljOiBhZGRyZXNzLCB1aW50MjU2LCBib29sZWFuWzNdLCB0dXBsZShhZGRyZXNzLCB1aW50OClcbiAgICBkeW5hbWljO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyaW5nXCIsIHR5cGU6IFwic3RyaW5nXCIsIGxvY2FsTmFtZTogXCJzdHJpbmdcIiwgZHluYW1pYzogXCJib29sZWFuXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBXcml0ZXIge1xuICAgIC8vIEFuIGFycmF5IG9mIFdvcmRTaXplIGxlbmd0aGVkIG9iamVjdHMgdG8gY29uY2F0ZW5hdGlvblxuICAgICNkYXRhO1xuICAgICNkYXRhTGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiNkYXRhID0gW107XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCh0aGlzLiNkYXRhKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI2RhdGFMZW5ndGg7IH1cbiAgICAjd3JpdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGFwcGVuZFdyaXRlcih3cml0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShnZXRCeXRlc0NvcHkod3JpdGVyLmRhdGEpKTtcbiAgICB9XG4gICAgLy8gQXJyYXlpc2ggaXRlbTsgcGFkIG9uIHRoZSByaWdodCB0byAqbmVhcmVzdCogV29yZFNpemVcbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGdldEJ5dGVzQ29weSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdPZmZzZXQgPSBieXRlcy5sZW5ndGggJSBXb3JkU2l6ZTtcbiAgICAgICAgaWYgKHBhZGRpbmdPZmZzZXQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbYnl0ZXMsIFBhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShieXRlcyk7XG4gICAgfVxuICAgIC8vIE51bWVyaWMgaXRlbTsgcGFkIG9uIHRoZSBsZWZ0ICp0byogV29yZFNpemVcbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0VmFsdWUodmFsdWUpKTtcbiAgICB9XG4gICAgLy8gSW5zZXJ0cyBhIG51bWVyaWMgcGxhY2UtaG9sZGVyLCByZXR1cm5pbmcgYSBjYWxsYmFjayB0aGF0IGNhblxuICAgIC8vIGJlIHVzZWQgdG8gYXNqdXN0IHRoZSB2YWx1ZSBsYXRlclxuICAgIHdyaXRlVXBkYXRhYmxlVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuI2RhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goUGFkZGluZyk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gV29yZFNpemU7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RhdGFbb2Zmc2V0XSA9IGdldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgUmVhZGVyIHtcbiAgICAvLyBBbGxvd3MgaW5jb21wbGV0ZSB1bnBhZGRlZCBkYXRhIHRvIGJlIHJlYWQ7IG90aGVyd2lzZSBhbiBlcnJvclxuICAgIC8vIGlzIHJhaXNlZCBpZiBhdHRlbXB0aW5nIHRvIG92ZXJydW4gdGhlIGJ1ZmZlci4gVGhpcyBpcyByZXF1aXJlZFxuICAgIC8vIHRvIGRlYWwgd2l0aCBhbiBvbGQgU29saWRpdHkgYnVnLCBpbiB3aGljaCBldmVudCBkYXRhIGZvclxuICAgIC8vIGV4dGVybmFsIChub3QgcHVibGljIHRob2d1aCkgd2FzIHRpZ2h0bHkgcGFja2VkLlxuICAgIGFsbG93TG9vc2U7XG4gICAgI2RhdGE7XG4gICAgI29mZnNldDtcbiAgICAjYnl0ZXNSZWFkO1xuICAgICNwYXJlbnQ7XG4gICAgI21heEluZmxhdGlvbjtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBhbGxvd0xvb3NlLCBtYXhJbmZsYXRpb24pIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFsbG93TG9vc2U6ICEhYWxsb3dMb29zZSB9KTtcbiAgICAgICAgdGhpcy4jZGF0YSA9IGdldEJ5dGVzQ29weShkYXRhKTtcbiAgICAgICAgdGhpcy4jYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4SW5mbGF0aW9uID0gKG1heEluZmxhdGlvbiAhPSBudWxsKSA/IG1heEluZmxhdGlvbiA6IDEwMjQ7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gaGV4bGlmeSh0aGlzLiNkYXRhKTsgfVxuICAgIGdldCBkYXRhTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YS5sZW5ndGg7IH1cbiAgICBnZXQgY29uc3VtZWQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgYnl0ZXMoKSB7IHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNkYXRhKTsgfVxuICAgICNpbmNyZW1lbnRCeXRlc1JlYWQoY291bnQpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudC4jaW5jcmVtZW50Qnl0ZXNSZWFkKGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNieXRlc1JlYWQgKz0gY291bnQ7XG4gICAgICAgIC8vIENoZWNrIGZvciBleGNlc3NpdmUgaW5mbGF0aW9uIChzZWU6ICM0NTM3KVxuICAgICAgICBhc3NlcnQodGhpcy4jbWF4SW5mbGF0aW9uIDwgMSB8fCB0aGlzLiNieXRlc1JlYWQgPD0gdGhpcy4jbWF4SW5mbGF0aW9uICogdGhpcy5kYXRhTGVuZ3RoLCBgY29tcHJlc3NlZCBBQkkgZGF0YSBleGNlZWRzIGluZmxhdGlvbiByYXRpbyBvZiAke3RoaXMuI21heEluZmxhdGlvbn0gKCBzZWU6IGh0dHBzOi9cXC9naXRodWIuY29tL2V0aGVycy1pby9ldGhlcnMuanMvaXNzdWVzLzQ1MzcgKWAsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBnZXRCeXRlc0NvcHkodGhpcy4jZGF0YSksIG9mZnNldDogdGhpcy4jb2Zmc2V0LFxuICAgICAgICAgICAgbGVuZ3RoOiBjb3VudCwgaW5mbzoge1xuICAgICAgICAgICAgICAgIGJ5dGVzUmVhZDogdGhpcy4jYnl0ZXNSZWFkLFxuICAgICAgICAgICAgICAgIGRhdGFMZW5ndGg6IHRoaXMuZGF0YUxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgI3BlZWtCeXRlcyhvZmZzZXQsIGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGFsaWduZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gV29yZFNpemUpICogV29yZFNpemU7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoID4gdGhpcy4jZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TG9vc2UgJiYgbG9vc2UgJiYgdGhpcy4jb2Zmc2V0ICsgbGVuZ3RoIDw9IHRoaXMuI2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogZ2V0Qnl0ZXNDb3B5KHRoaXMuI2RhdGEpLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuI2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQsIHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBzdWItcmVhZGVyIHdpdGggdGhlIHNhbWUgdW5kZXJseWluZyBkYXRhLCBidXQgb2Zmc2V0XG4gICAgc3ViUmVhZGVyKG9mZnNldCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgUmVhZGVyKHRoaXMuI2RhdGEuc2xpY2UodGhpcy4jb2Zmc2V0ICsgb2Zmc2V0KSwgdGhpcy5hbGxvd0xvb3NlLCB0aGlzLiNtYXhJbmZsYXRpb24pO1xuICAgICAgICByZWFkZXIuI3BhcmVudCA9IHRoaXM7XG4gICAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfVxuICAgIC8vIFJlYWQgYnl0ZXNcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSB0aGlzLiNwZWVrQnl0ZXMoMCwgbGVuZ3RoLCAhIWxvb3NlKTtcbiAgICAgICAgdGhpcy4jaW5jcmVtZW50Qnl0ZXNSZWFkKGxlbmd0aCk7XG4gICAgICAgIHRoaXMuI29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFJlYWQgYSBudW1lcmljIHZhbHVlc1xuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnSW50KHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxuICAgIHJlYWRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtY29kZXIuanMubWFwIiwiZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiLCIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCF1OGEoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5jb25zdCB0b1N0ciA9IHt9LnRvU3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiLCJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIG51bWJlciBhcyBhc3NlcnROdW1iZXIgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJy4vaG1hYy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVWaWV3LCB0b0J5dGVzLCBjaGVja09wdHMsIGFzeW5jTG9vcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gQ29tbW9uIHByb2xvZ3VlIGFuZCBlcGlsb2d1ZSBmb3Igc3luYy9hc3luYyBmdW5jdGlvbnNcbmZ1bmN0aW9uIHBia2RmMkluaXQoaGFzaCwgX3Bhc3N3b3JkLCBfc2FsdCwgX29wdHMpIHtcbiAgICBhc3NlcnRIYXNoKGhhc2gpO1xuICAgIGNvbnN0IG9wdHMgPSBjaGVja09wdHMoeyBka0xlbjogMzIsIGFzeW5jVGljazogMTAgfSwgX29wdHMpO1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljayB9ID0gb3B0cztcbiAgICBhc3NlcnROdW1iZXIoYyk7XG4gICAgYXNzZXJ0TnVtYmVyKGRrTGVuKTtcbiAgICBhc3NlcnROdW1iZXIoYXN5bmNUaWNrKTtcbiAgICBpZiAoYyA8IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUEJLREYyOiBpdGVyYXRpb25zIChjKSBzaG91bGQgYmUgPj0gMScpO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gdG9CeXRlcyhfcGFzc3dvcmQpO1xuICAgIGNvbnN0IHNhbHQgPSB0b0J5dGVzKF9zYWx0KTtcbiAgICAvLyBESyA9IFBCS0RGMihQUkYsIFBhc3N3b3JkLCBTYWx0LCBjLCBka0xlbik7XG4gICAgY29uc3QgREsgPSBuZXcgVWludDhBcnJheShka0xlbik7XG4gICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgY29uc3QgUFJGID0gaG1hYy5jcmVhdGUoaGFzaCwgcGFzc3dvcmQpO1xuICAgIGNvbnN0IFBSRlNhbHQgPSBQUkYuX2Nsb25lSW50bygpLnVwZGF0ZShzYWx0KTtcbiAgICByZXR1cm4geyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH07XG59XG5mdW5jdGlvbiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSkge1xuICAgIFBSRi5kZXN0cm95KCk7XG4gICAgUFJGU2FsdC5kZXN0cm95KCk7XG4gICAgaWYgKHByZlcpXG4gICAgICAgIHByZlcuZGVzdHJveSgpO1xuICAgIHUuZmlsbCgwKTtcbiAgICByZXR1cm4gREs7XG59XG4vKipcbiAqIFBCS0RGMi1ITUFDOiBSRkMgMjg5OCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc3dvcmQgZnJvbSB3aGljaCBhIGRlcml2ZWQga2V5IGlzIGdlbmVyYXRlZFxuICogQHBhcmFtIHNhbHQgLSBjcnlwdG9ncmFwaGljIHNhbHRcbiAqIEBwYXJhbSBvcHRzIC0ge2MsIGRrTGVufSB3aGVyZSBjIGlzIHdvcmsgZmFjdG9yIGFuZCBka0xlbiBpcyBvdXRwdXQgbWVzc2FnZSBzaXplXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYmtkZjIoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBmb3IgKGxldCB1aSA9IDE7IHVpIDwgYzsgdWkrKykge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGJrZGYyQXN5bmMoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChjIC0gMSwgYXN5bmNUaWNrLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWPiiJIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGJrZGYyLmpzLm1hcCIsImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuZXhwb3J0IGNsYXNzIFNIQTIgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCIsImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiLCJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIiwiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHU2NCBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBSb3VuZCBjb250YW50cyAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFtTSEE1MTJfS2gsIFNIQTUxMl9LbF0gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmV4cG9ydCBjbGFzcyBTSEE1MTIgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMTI4LCA2NCwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZSB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIEFsc28gbG9va3MgY2xlYW5lciBhbmQgZWFzaWVyIHRvIHZlcmlmeSB3aXRoIHNwZWMuXG4gICAgICAgIC8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg2YTA5ZTY2NyB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGYzYmNjOTA4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4YmI2N2FlODUgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4NGNhYTczYiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDNjNmVmMzcyIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4ZmU5NGY4MmIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHhhNTRmZjUzYSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDVmMWQzNmYxIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NTEwZTUyN2YgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhZGU2ODJkMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDliMDU2ODhjIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MmIzZTZjMWYgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgxZjgzZDlhYiB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweGZiNDFiZDZiIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NWJlMGNkMTkgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHgxMzdlMjE3OSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEE1MTJfV19ILmZpbGwoMCk7XG4gICAgICAgIFNIQTUxMl9XX0wuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDhjM2QzN2M4IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4MTk1NDRkYTIgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg3M2UxOTk2NiB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg5ZGNkNGQ2IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MWRmYWI3YWUgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMmZmOWM4MiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDY3OWRkNTE0IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTgyZjlmY2YgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHgwZjZkMmI2OSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweDdiZDQ0ZGE4IHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4NzdlMzZmNzMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgwNGM0ODk0MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDNmOWQ4NWE4IHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NmExZDM2YzggfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgxMTEyZTZhZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDkxZDY5MmExIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4MjIzMTIxOTQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmYzJiZjcyYyB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDlmNTU1ZmEzIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4Yzg0YzY0YzIgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgyMzkzYjg2YiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDZmNTNiMTUxIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4OTYzODc3MTkgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1OTQwZWFiZCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDk2MjgzZWUyIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YTg4ZWZmZTMgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHhiZTVlMWUyNSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDUzODYzOTkyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MmIwMTk5ZmMgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHgyYzg1YjhhYSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDBlYjcyZGRjIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4ODFjNTJjYTIgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDMyO1xuICAgIH1cbn1cbmNsYXNzIFNIQTM4NCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweGNiYmI5ZDVkIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg2MjlhMjkyYSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4OTE1OTAxNWEgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDE1MmZlY2Q4IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg2NzMzMjY2NyB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OGViNDRhODcgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweGRiMGMyZTBkIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg0N2I1NDgxZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSA0ODtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2hhNTEyID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyKCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTM4NCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTUxMi5qcy5tYXAiLCIvKiBCcm93c2VyIENyeXB0byBTaGltcyAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2htYWNcIjtcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3Bia2RmMlwiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5pbXBvcnQgeyBzaGE1MTIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGE1MTJcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG47XG5jb25zdCBhbnlHbG9iYWwgPSBnZXRHbG9iYWwoKTtcbmNvbnN0IGNyeXB0byA9IGFueUdsb2JhbC5jcnlwdG8gfHwgYW55R2xvYmFsLm1zQ3J5cHRvO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2goYWxnbykge1xuICAgIHN3aXRjaCAoYWxnbykge1xuICAgICAgICBjYXNlIFwic2hhMjU2XCI6IHJldHVybiBzaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgIGNhc2UgXCJzaGE1MTJcIjogcmV0dXJuIHNoYTUxMi5jcmVhdGUoKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBoYXNoaW5nIGFsZ29yaXRobSBuYW1lXCIsIFwiYWxnb3JpdGhtXCIsIGFsZ28pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWMoX2FsZ28sIGtleSkge1xuICAgIGNvbnN0IGFsZ28gPSAoeyBzaGEyNTYsIHNoYTUxMiB9W19hbGdvXSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoYWxnbyAhPSBudWxsLCBcImludmFsaWQgaG1hYyBhbGdvcml0aG1cIiwgXCJhbGdvcml0aG1cIiwgX2FsZ28pO1xuICAgIHJldHVybiBobWFjLmNyZWF0ZShhbGdvLCBrZXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgX2FsZ28pIHtcbiAgICBjb25zdCBhbGdvID0gKHsgc2hhMjU2LCBzaGE1MTIgfVtfYWxnb10pO1xuICAgIGFzc2VydEFyZ3VtZW50KGFsZ28gIT0gbnVsbCwgXCJpbnZhbGlkIHBia2RmMiBhbGdvcml0aG1cIiwgXCJhbGdvcml0aG1cIiwgX2FsZ28pO1xuICAgIHJldHVybiBwYmtkZjIoYWxnbywgcGFzc3dvcmQsIHNhbHQsIHsgYzogaXRlcmF0aW9ucywgZGtMZW46IGtleWxlbiB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGgpIHtcbiAgICBhc3NlcnQoY3J5cHRvICE9IG51bGwsIFwicGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCBzZWN1cmUgcmFuZG9tIG51bWJlcnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwicmFuZG9tQnl0ZXNcIlxuICAgIH0pO1xuICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIobGVuZ3RoKSAmJiBsZW5ndGggPiAwICYmIGxlbmd0aCA8PSAxMDI0LCBcImludmFsaWQgbGVuZ3RoXCIsIFwibGVuZ3RoXCIsIGxlbmd0aCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by1icm93c2VyLmpzLm1hcCIsIi8qKlxuICogIEFuICoqSE1BQyoqIGVuYWJsZXMgdmVyaWZpY2F0aW9uIHRoYXQgYSBnaXZlbiBrZXkgd2FzIHVzZWRcbiAqICB0byBhdXRoZW50aWNhdGUgYSBwYXlsb2FkLlxuICpcbiAqICBTZWU6IFtbbGluay13aWtpLWhtYWNdXVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86SE1BQyAgW2Fib3V0LWhtYWNdXG4gKi9cbmltcG9ydCB7IGNyZWF0ZUhtYWMgfSBmcm9tIFwiLi9jcnlwdG8uanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfY29tcHV0ZUhtYWMgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICByZXR1cm4gY3JlYXRlSG1hYyhhbGdvcml0aG0sIGtleSkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufTtcbmxldCBfX2NvbXB1dGVIbWFjID0gX2NvbXB1dGVIbWFjO1xuLyoqXG4gKiAgUmV0dXJuIHRoZSBITUFDIGZvciAlJWRhdGElJSB1c2luZyB0aGUgJSVrZXklJSBrZXkgd2l0aCB0aGUgdW5kZXJseWluZ1xuICogICUlYWxnbyUlIHVzZWQgZm9yIGNvbXByZXNzaW9uLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGtleSA9IGlkKFwic29tZS1zZWNyZXRcIilcbiAqXG4gKiAgICAvLyBDb21wdXRlIHRoZSBITUFDXG4gKiAgICBjb21wdXRlSG1hYyhcInNoYTI1NlwiLCBrZXksIFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVG8gY29tcHV0ZSB0aGUgSE1BQyBvZiBVVEYtOCBkYXRhLCB0aGUgZGF0YSBtdXN0IGJlXG4gKiAgICAvLyBjb252ZXJ0ZWQgdG8gVVRGLTggYnl0ZXNcbiAqICAgIGNvbXB1dGVIbWFjKFwic2hhMjU2XCIsIGtleSwgdG9VdGY4Qnl0ZXMoXCJIZWxsbyBXb3JsZFwiKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSG1hYyhhbGdvcml0aG0sIF9rZXksIF9kYXRhKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0Qnl0ZXMoX2tleSwgXCJrZXlcIik7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19jb21wdXRlSG1hYyhhbGdvcml0aG0sIGtleSwgZGF0YSkpO1xufVxuY29tcHV0ZUhtYWMuXyA9IF9jb21wdXRlSG1hYztcbmNvbXB1dGVIbWFjLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5jb21wdXRlSG1hYy5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wdXRlSG1hYyBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fY29tcHV0ZUhtYWMgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoY29tcHV0ZUhtYWMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiLCJpbXBvcnQgeyBieXRlcywgZXhpc3RzLCBudW1iZXIsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyByb3RsQkgsIHJvdGxCTCwgcm90bFNILCByb3RsU0wsIHNwbGl0IH0gZnJvbSAnLi9fdTY0LmpzJztcbmltcG9ydCB7IEhhc2gsIHUzMiwgdG9CeXRlcywgd3JhcENvbnN0cnVjdG9yLCB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cywgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTMgKGtlY2NhaykgaXMgYmFzZWQgb24gYSBuZXcgZGVzaWduOiBiYXNpY2FsbHksIHRoZSBpbnRlcm5hbCBzdGF0ZSBpcyBiaWdnZXIgdGhhbiBvdXRwdXQgc2l6ZS5cbi8vIEl0J3MgY2FsbGVkIGEgc3BvbmdlIGZ1bmN0aW9uLlxuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgW1NIQTNfUEksIFNIQTNfUk9UTCwgX1NIQTNfSU9UQV0gPSBbW10sIFtdLCBbXV07XG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xuY29uc3QgXzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG5jb25zdCBfN24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IC8qIEBfX1BVUkVfXyAqLyBzcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcbi8vIExlZnQgcm90YXRpb24gKHdpdGhvdXQgMCwgMzIsIDY0KVxuY29uc3Qgcm90bEggPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCSChoLCBsLCBzKSA6IHJvdGxTSChoLCBsLCBzKSk7XG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJMKGgsIGwsIHMpIDogcm90bFNMKGgsIGwsIHMpKTtcbi8vIFNhbWUgYXMga2VjY2FrZjE2MDAsIGJ1dCBhbGxvd3MgdG8gc2tpcCBzb21lIHJvdW5kc1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgIEIuZmlsbCgwKTtcbn1cbmV4cG9ydCBjbGFzcyBLZWNjYWsgZXh0ZW5kcyBIYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgIG51bWJlcihvdXRwdXRMZW4pO1xuICAgICAgICAvLyAxNjAwID0gNXg1IG1hdHJpeCBvZiA2NGJpdC4gIDE2MDAgYml0cyA9PT0gMjAwIGJ5dGVzXG4gICAgICAgIGlmICgwID49IHRoaXMuYmxvY2tMZW4gfHwgdGhpcy5ibG9ja0xlbiA+PSAyMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYTMgc3VwcG9ydHMgb25seSBrZWNjYWstZjE2MDAgZnVuY3Rpb24nKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KDIwMCk7XG4gICAgICAgIHRoaXMuc3RhdGUzMiA9IHUzMih0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBieXRlcyhvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBidWZmZXJPdXQgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgbnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBzaGEzXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydCBjb25zdCBzaGEzXzUxMiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBrZWNjYWtfMjU2ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzUxMiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cygob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IG91dHB1dExlbiA6IG9wdHMuZGtMZW4sIHRydWUpKTtcbmV4cG9ydCBjb25zdCBzaGFrZTEyOCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMjU2ID0gLyogQF9fUFVSRV9fICovIGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCIsIi8qKlxuICogIENyeXB0b2dyYXBoaWMgaGFzaGluZyBmdW5jdGlvbnNcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zIFthYm91dC1jcnlwdG8taGFzaGluZ11cbiAqL1xuaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfa2VjY2FrMjU2ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4ga2VjY2FrXzI1NihkYXRhKTtcbn07XG5sZXQgX19rZWNjYWsyNTYgPSBfa2VjY2FrMjU2O1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBLRUNDQUsyNTYgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgVGhlICUlZGF0YSUlICoqbXVzdCoqIGJlIGEgZGF0YSByZXByZXNlbnRhdGlvbiwgdG8gY29tcHV0ZSB0aGVcbiAqICBoYXNoIG9mIFVURi04IGRhdGEgdXNlIHRoZSBbW2lkXV0gZnVuY3Rpb24uXG4gKlxuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqICBAZXhhbXBsZTpcbiAqICAgIGtlY2NhazI1NihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAga2VjY2FrMjU2KFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAga2VjY2FrMjU2KG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBTdHJpbmdzIGFyZSBhc3N1bWVkIHRvIGJlIERhdGFIZXhTdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsXG4gKiAgICAvLyB0aHJvdy4gVG8gaGFzaCBVVEYtOCBkYXRhLCBzZWUgdGhlIG5vdGUgYWJvdmUuXG4gKiAgICBrZWNjYWsyNTYoXCJIZWxsbyBXb3JsZFwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX2tlY2NhazI1NihkYXRhKSk7XG59XG5rZWNjYWsyNTYuXyA9IF9rZWNjYWsyNTY7XG5rZWNjYWsyNTYubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbmtlY2NhazI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2VjY2FrMjU2IGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19rZWNjYWsyNTYgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoa2VjY2FrMjU2KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtlY2Nhay5qcy5tYXAiLCJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwLmh0bWxcbi8vIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwL3BkZi9BQi05NjAxL0FCLTk2MDEucGRmXG5jb25zdCBSaG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoWzcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDhdKTtcbmNvbnN0IElkID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbSh7IGxlbmd0aDogMTYgfSwgKF8sIGkpID0+IGkpO1xuY29uc3QgUGkgPSAvKiBAX19QVVJFX18gKi8gSWQubWFwKChpKSA9PiAoOSAqIGkgKyA1KSAlIDE2KTtcbmxldCBpZHhMID0gW0lkXTtcbmxldCBpZHhSID0gW1BpXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgIGZvciAobGV0IGogb2YgW2lkeEwsIGlkeFJdKVxuICAgICAgICBqLnB1c2goaltpXS5tYXAoKGspID0+IFJob1trXSkpO1xuY29uc3Qgc2hpZnRzID0gLyogQF9fUFVSRV9fICovIFtcbiAgICBbMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4XSxcbiAgICBbMTIsIDEzLCAxMSwgMTUsIDYsIDksIDksIDcsIDEyLCAxNSwgMTEsIDEzLCA3LCA4LCA3LCA3XSxcbiAgICBbMTMsIDE1LCAxNCwgMTEsIDcsIDcsIDYsIDgsIDEzLCAxNCwgMTMsIDEyLCA1LCA1LCA2LCA5XSxcbiAgICBbMTQsIDExLCAxMiwgMTQsIDgsIDYsIDUsIDUsIDE1LCAxMiwgMTUsIDE0LCA5LCA5LCA4LCA2XSxcbiAgICBbMTUsIDEyLCAxMywgMTMsIDksIDUsIDgsIDYsIDE0LCAxMSwgMTIsIDExLCA4LCA2LCA1LCA1XSxcbl0ubWFwKChpKSA9PiBuZXcgVWludDhBcnJheShpKSk7XG5jb25zdCBzaGlmdHNMID0gLyogQF9fUFVSRV9fICovIGlkeEwubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0c1tpXVtqXSkpO1xuY29uc3Qgc2hpZnRzUiA9IC8qIEBfX1BVUkVfXyAqLyBpZHhSLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHNbaV1bal0pKTtcbmNvbnN0IEtsID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZSxcbl0pO1xuY29uc3QgS3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDUwYTI4YmU2LCAweDVjNGRkMTI0LCAweDZkNzAzZWYzLCAweDdhNmQ3NmU5LCAweDAwMDAwMDAwLFxuXSk7XG4vLyBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RsID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCBzaGlmdCkgfCAod29yZCA+Pj4gKDMyIC0gc2hpZnQpKTtcbi8vIEl0J3MgY2FsbGVkIGYoKSBpbiBzcGVjLlxuZnVuY3Rpb24gZihncm91cCwgeCwgeSwgeikge1xuICAgIGlmIChncm91cCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgICBlbHNlIGlmIChncm91cCA9PT0gMSlcbiAgICAgICAgcmV0dXJuICh4ICYgeSkgfCAofnggJiB6KTtcbiAgICBlbHNlIGlmIChncm91cCA9PT0gMilcbiAgICAgICAgcmV0dXJuICh4IHwgfnkpIF4gejtcbiAgICBlbHNlIGlmIChncm91cCA9PT0gMylcbiAgICAgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmIH56KTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB4IF4gKHkgfCB+eik7XG59XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbmNvbnN0IEJVRiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoMTYpO1xuZXhwb3J0IGNsYXNzIFJJUEVNRDE2MCBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMjAsIDgsIHRydWUpO1xuICAgICAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMSB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSAweGVmY2RhYjg5IHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IDB4OThiYWRjZmUgfCAwO1xuICAgICAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NiB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSAweGMzZDJlMWYwIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IGgwLCBoMSwgaDIsIGgzLCBoNCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtoMCwgaDEsIGgyLCBoMywgaDRdO1xuICAgIH1cbiAgICBzZXQoaDAsIGgxLCBoMiwgaDMsIGg0KSB7XG4gICAgICAgIHRoaXMuaDAgPSBoMCB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSBoMSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSBoMiB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSBoMyB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSBoNCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBCVUZbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IGFsID0gdGhpcy5oMCB8IDAsIGFyID0gYWwsIGJsID0gdGhpcy5oMSB8IDAsIGJyID0gYmwsIGNsID0gdGhpcy5oMiB8IDAsIGNyID0gY2wsIGRsID0gdGhpcy5oMyB8IDAsIGRyID0gZGwsIGVsID0gdGhpcy5oNCB8IDAsIGVyID0gZWw7XG4gICAgICAgIC8vIEluc3RlYWQgb2YgaXRlcmF0aW5nIDAgdG8gODAsIHdlIHNwbGl0IGl0IGludG8gNSBncm91cHNcbiAgICAgICAgLy8gQW5kIHVzZSB0aGUgZ3JvdXBzIGluIGNvbnN0YW50cywgZnVuY3Rpb25zLCBldGMuIE11Y2ggc2ltcGxlclxuICAgICAgICBmb3IgKGxldCBncm91cCA9IDA7IGdyb3VwIDwgNTsgZ3JvdXArKykge1xuICAgICAgICAgICAgY29uc3Qgckdyb3VwID0gNCAtIGdyb3VwO1xuICAgICAgICAgICAgY29uc3QgaGJsID0gS2xbZ3JvdXBdLCBoYnIgPSBLcltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcmwgPSBpZHhMW2dyb3VwXSwgcnIgPSBpZHhSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBzbCA9IHNoaWZ0c0xbZ3JvdXBdLCBzciA9IHNoaWZ0c1JbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRsID0gKHJvdGwoYWwgKyBmKGdyb3VwLCBibCwgY2wsIGRsKSArIEJVRltybFtpXV0gKyBoYmwsIHNsW2ldKSArIGVsKSB8IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBlbCwgZWwgPSBkbCwgZGwgPSByb3RsKGNsLCAxMCkgfCAwLCBjbCA9IGJsLCBibCA9IHRsOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIgbG9vcHMgYXJlIDEwJSBmYXN0ZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gKHJvdGwoYXIgKyBmKHJHcm91cCwgYnIsIGNyLCBkcikgKyBCVUZbcnJbaV1dICsgaGJyLCBzcltpXSkgKyBlcikgfCAwO1xuICAgICAgICAgICAgICAgIGFyID0gZXIsIGVyID0gZHIsIGRyID0gcm90bChjciwgMTApIHwgMCwgY3IgPSBiciwgYnIgPSB0cjsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgdGhpcy5zZXQoKHRoaXMuaDEgKyBjbCArIGRyKSB8IDAsICh0aGlzLmgyICsgZGwgKyBlcikgfCAwLCAodGhpcy5oMyArIGVsICsgYXIpIHwgMCwgKHRoaXMuaDQgKyBhbCArIGJyKSB8IDAsICh0aGlzLmgwICsgYmwgKyBjcikgfCAwKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgQlVGLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuLyoqXG4gKiBSSVBFTUQtMTYwIC0gYSBoYXNoIGZ1bmN0aW9uIGZyb20gMTk5MHMuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1zZyB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3QgcmlwZW1kMTYwID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgUklQRU1EMTYwKCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlwZW1kMTYwLmpzLm1hcCIsImltcG9ydCB7IHJpcGVtZDE2MCBhcyBub2JsZV9yaXBlbWQxNjAgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjBcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfcmlwZW1kMTYwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbm9ibGVfcmlwZW1kMTYwKGRhdGEpO1xufTtcbmxldCBfX3JpcGVtZDE2MCA9IF9yaXBlbWQxNjA7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFJJUEVNRC0xNjAgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnNcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgcmlwZW1kMTYwKFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICByaXBlbWQxNjAoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICByaXBlbWQxNjAobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJpcGVtZDE2MChfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fcmlwZW1kMTYwKGRhdGEpKTtcbn1cbnJpcGVtZDE2MC5fID0gX3JpcGVtZDE2MDtcbnJpcGVtZDE2MC5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xucmlwZW1kMTYwLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyaXBlbWQxNjAgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3JpcGVtZDE2MCA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShyaXBlbWQxNjApO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlwZW1kMTYwLmpzLm1hcCIsIi8qKlxuICogIEEgKipQYXNzd29yZC1CYXNlZCBLZXktRGVyaXZhdGlvbiBGdW5jdGlvbioqIGlzIGRlc2lnbmVkIHRvIGNyZWF0ZVxuICogIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3VpdGlibGUgYXMgYSAqKmtleSoqIGZyb20gYSBodW1hbi1yZW1lbWJlcmFibGVcbiAqICBwYXNzd29yZC5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOlBhc3N3b3JkcyAgW2Fib3V0LXBia2RmXVxuICovXG5pbXBvcnQgeyBwYmtkZjJTeW5jIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX3Bia2RmMiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBhbGdvKSB7XG4gICAgcmV0dXJuIHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbyk7XG59O1xubGV0IF9fcGJrZGYyID0gX3Bia2RmMjtcbi8qKlxuICogIFJldHVybiB0aGUgW1tsaW5rLXBia2RmMl1dIGZvciAlJWtleWxlbiUlIGJ5dGVzIGZvciAlJXBhc3N3b3JkJSUgdXNpbmdcbiAqICB0aGUgJSVzYWx0JSUgYW5kIHVzaW5nICUlaXRlcmF0aW9ucyUlIG9mICUlYWxnbyUlLlxuICpcbiAqICBUaGlzIFBCS0RGIGlzIG91dGRhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgaW4gbmV3IHByb2plY3RzLCBidXQgaXNcbiAqICByZXF1aXJlZCB0byBkZWNyeXB0IG9sZGVyIGZpbGVzLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBwYXNzd29yZCBtdXN0IGJlIGNvbnZlcnRlZCB0byBieXRlcywgYW5kIGl0IGlzIGdlbmVyYWxseVxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxuICogICAgLy8gZm9ybWF0cyBleHBsaWNpdGx5IGluZGljYXRlIHRoZSBub3JtYWxpemF0aW9uIGZvcm0gdG8gdXNlLlxuICogICAgcGFzc3dvcmQgPSBcImhlbGxvXCJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXG4gKlxuICogICAgc2FsdCA9IGlkKFwic29tZS1zYWx0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgUEJLREYyXG4gKiAgICBwYmtkZjIocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgMTYsIFwic2hhMjU2XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYmtkZjIoX3Bhc3N3b3JkLCBfc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBhbGdvKSB7XG4gICAgY29uc3QgcGFzc3dvcmQgPSBnZXRCeXRlcyhfcGFzc3dvcmQsIFwicGFzc3dvcmRcIik7XG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19wYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbykpO1xufVxucGJrZGYyLl8gPSBfcGJrZGYyO1xucGJrZGYyLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5wYmtkZjIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGJrZGYyIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19wYmtkZjIgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUocGJrZGYyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiLCIvKipcbiAqICBBICoqQ3J5cHRvZ3JhcGhpY2FsbHkgU2VjdXJlIFJhbmRvbSBWYWx1ZSoqIGlzIG9uZSB0aGF0IGhhcyBiZWVuXG4gKiAgZ2VuZXJhdGVkIHdpdGggYWRkaXRpb25hbCBjYXJlIHRha2UgdG8gcHJldmVudCBzaWRlLWNoYW5uZWxzXG4gKiAgZnJvbSBhbGxvd2luZyBvdGhlcnMgdG8gZGV0ZWN0IGl0IGFuZCBwcmV2ZW50IG90aGVycyBmcm9tIHRocm91Z2hcbiAqICBjb2luY2lkZW5jZSBnZW5lcmF0ZSB0aGUgc2FtZSB2YWx1ZXMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpSYW5kb20gVmFsdWVzICBbYWJvdXQtY3J5cHRvLXJhbmRvbV1cbiAqL1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgYXMgY3J5cHRvX3JhbmRvbSB9IGZyb20gXCIuL2NyeXB0by5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX3JhbmRvbUJ5dGVzID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjcnlwdG9fcmFuZG9tKGxlbmd0aCkpO1xufTtcbmxldCBfX3JhbmRvbUJ5dGVzID0gX3JhbmRvbUJ5dGVzO1xuLyoqXG4gKiAgUmV0dXJuICUlbGVuZ3RoJSUgYnl0ZXMgb2YgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbSBkYXRhLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJhbmRvbUJ5dGVzKDgpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGgpIHtcbiAgICByZXR1cm4gX19yYW5kb21CeXRlcyhsZW5ndGgpO1xufVxucmFuZG9tQnl0ZXMuXyA9IF9yYW5kb21CeXRlcztcbnJhbmRvbUJ5dGVzLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5yYW5kb21CeXRlcy5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb21CeXRlcyBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fcmFuZG9tQnl0ZXMgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUocmFuZG9tQnl0ZXMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLmpzLm1hcCIsImltcG9ydCB7IG51bWJlciBhcyBhc3NlcnROdW1iZXIgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnLi9zaGEyNTYuanMnO1xuaW1wb3J0IHsgcGJrZGYyIH0gZnJvbSAnLi9wYmtkZjIuanMnO1xuaW1wb3J0IHsgYXN5bmNMb29wLCBjaGVja09wdHMsIHUzMiB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUkZDIDc5MTQgU2NyeXB0IEtERlxuLy8gTGVmdCByb3RhdGUgZm9yIHVpbnQzMlxuY29uc3Qgcm90bCA9IChhLCBiKSA9PiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSk7XG4vLyBUaGUgbWFpbiBTY3J5cHQgbG9vcDogdXNlcyBTYWxzYSBleHRlbnNpdmVseS5cbi8vIFNpeCB2ZXJzaW9ucyBvZiB0aGUgZnVuY3Rpb24gd2VyZSB0cmllZCwgdGhpcyBpcyB0aGUgZmFzdGVzdCBvbmUuXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIFhvckFuZFNhbHNhKHByZXYsIHBpLCBpbnB1dCwgaWksIG91dCwgb2kpIHtcbiAgICAvLyBCYXNlZCBvbiBodHRwczovL2NyLnlwLnRvL3NhbHNhMjAuaHRtbFxuICAgIC8vIFhvciBibG9ja3NcbiAgICBsZXQgeTAwID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDEgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwMiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTAzID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTA2ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDcgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwOCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTA5ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MTAgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxMSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTEyID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MTMgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkxNCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTE1ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlcyAoc2Fsc2EpXG4gICAgbGV0IHgwMCA9IHkwMCwgeDAxID0geTAxLCB4MDIgPSB5MDIsIHgwMyA9IHkwMywgeDA0ID0geTA0LCB4MDUgPSB5MDUsIHgwNiA9IHkwNiwgeDA3ID0geTA3LCB4MDggPSB5MDgsIHgwOSA9IHkwOSwgeDEwID0geTEwLCB4MTEgPSB5MTEsIHgxMiA9IHkxMiwgeDEzID0geTEzLCB4MTQgPSB5MTQsIHgxNSA9IHkxNTtcbiAgICAvLyBNYWluIGxvb3AgKHNhbHNhKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG4gICAgICAgIHgwNCBePSByb3RsKHgwMCArIHgxMiB8IDAsIDcpO1xuICAgICAgICB4MDggXj0gcm90bCh4MDQgKyB4MDAgfCAwLCA5KTtcbiAgICAgICAgeDEyIF49IHJvdGwoeDA4ICsgeDA0IHwgMCwgMTMpO1xuICAgICAgICB4MDAgXj0gcm90bCh4MTIgKyB4MDggfCAwLCAxOCk7XG4gICAgICAgIHgwOSBePSByb3RsKHgwNSArIHgwMSB8IDAsIDcpO1xuICAgICAgICB4MTMgXj0gcm90bCh4MDkgKyB4MDUgfCAwLCA5KTtcbiAgICAgICAgeDAxIF49IHJvdGwoeDEzICsgeDA5IHwgMCwgMTMpO1xuICAgICAgICB4MDUgXj0gcm90bCh4MDEgKyB4MTMgfCAwLCAxOCk7XG4gICAgICAgIHgxNCBePSByb3RsKHgxMCArIHgwNiB8IDAsIDcpO1xuICAgICAgICB4MDIgXj0gcm90bCh4MTQgKyB4MTAgfCAwLCA5KTtcbiAgICAgICAgeDA2IF49IHJvdGwoeDAyICsgeDE0IHwgMCwgMTMpO1xuICAgICAgICB4MTAgXj0gcm90bCh4MDYgKyB4MDIgfCAwLCAxOCk7XG4gICAgICAgIHgwMyBePSByb3RsKHgxNSArIHgxMSB8IDAsIDcpO1xuICAgICAgICB4MDcgXj0gcm90bCh4MDMgKyB4MTUgfCAwLCA5KTtcbiAgICAgICAgeDExIF49IHJvdGwoeDA3ICsgeDAzIHwgMCwgMTMpO1xuICAgICAgICB4MTUgXj0gcm90bCh4MTEgKyB4MDcgfCAwLCAxOCk7XG4gICAgICAgIHgwMSBePSByb3RsKHgwMCArIHgwMyB8IDAsIDcpO1xuICAgICAgICB4MDIgXj0gcm90bCh4MDEgKyB4MDAgfCAwLCA5KTtcbiAgICAgICAgeDAzIF49IHJvdGwoeDAyICsgeDAxIHwgMCwgMTMpO1xuICAgICAgICB4MDAgXj0gcm90bCh4MDMgKyB4MDIgfCAwLCAxOCk7XG4gICAgICAgIHgwNiBePSByb3RsKHgwNSArIHgwNCB8IDAsIDcpO1xuICAgICAgICB4MDcgXj0gcm90bCh4MDYgKyB4MDUgfCAwLCA5KTtcbiAgICAgICAgeDA0IF49IHJvdGwoeDA3ICsgeDA2IHwgMCwgMTMpO1xuICAgICAgICB4MDUgXj0gcm90bCh4MDQgKyB4MDcgfCAwLCAxOCk7XG4gICAgICAgIHgxMSBePSByb3RsKHgxMCArIHgwOSB8IDAsIDcpO1xuICAgICAgICB4MDggXj0gcm90bCh4MTEgKyB4MTAgfCAwLCA5KTtcbiAgICAgICAgeDA5IF49IHJvdGwoeDA4ICsgeDExIHwgMCwgMTMpO1xuICAgICAgICB4MTAgXj0gcm90bCh4MDkgKyB4MDggfCAwLCAxOCk7XG4gICAgICAgIHgxMiBePSByb3RsKHgxNSArIHgxNCB8IDAsIDcpO1xuICAgICAgICB4MTMgXj0gcm90bCh4MTIgKyB4MTUgfCAwLCA5KTtcbiAgICAgICAgeDE0IF49IHJvdGwoeDEzICsgeDEyIHwgMCwgMTMpO1xuICAgICAgICB4MTUgXj0gcm90bCh4MTQgKyB4MTMgfCAwLCAxOCk7XG4gICAgfVxuICAgIC8vIFdyaXRlIG91dHB1dCAoc2Fsc2EpXG4gICAgb3V0W29pKytdID0gKHkwMCArIHgwMCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDEgKyB4MDEpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAyICsgeDAyKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMyArIHgwMykgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDQgKyB4MDQpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA1ICsgeDA1KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNiArIHgwNikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDcgKyB4MDcpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA4ICsgeDA4KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOSArIHgwOSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTAgKyB4MTApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTExICsgeDExKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMiArIHgxMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTMgKyB4MTMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTE0ICsgeDE0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNSArIHgxNSkgfCAwO1xufVxuZnVuY3Rpb24gQmxvY2tNaXgoaW5wdXQsIGlpLCBvdXQsIG9pLCByKSB7XG4gICAgLy8gVGhlIGJsb2NrIEIgaXMgciAxMjgtYnl0ZSBjaHVua3MgKHdoaWNoIGlzIGVxdWl2YWxlbnQgb2YgMnIgNjQtYnl0ZSBjaHVua3MpXG4gICAgbGV0IGhlYWQgPSBvaSArIDA7XG4gICAgbGV0IHRhaWwgPSBvaSArIDE2ICogcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgICAgIG91dFt0YWlsICsgaV0gPSBpbnB1dFtpaSArICgyICogciAtIDEpICogMTYgKyBpXTsgLy8gWCDihpAgQlsycuKIkjFdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByOyBpKyssIGhlYWQgKz0gMTYsIGlpICs9IDE2KSB7XG4gICAgICAgIC8vIFdlIHdyaXRlIG9kZCAmIGV2ZW4gWWkgYXQgc2FtZSB0aW1lLiBFdmVuOiAwYlhYWFhYMCBPZGQ6ICAwYlhYWFhYMVxuICAgICAgICBYb3JBbmRTYWxzYShvdXQsIHRhaWwsIGlucHV0LCBpaSwgb3V0LCBoZWFkKTsgLy8gaGVhZFtpXSA9IFNhbHNhKGJsb2NrSW5bMippXSBeIHRhaWxbaS0xXSlcbiAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgICAgdGFpbCArPSAxNjsgLy8gRmlyc3QgaXRlcmF0aW9uIG92ZXJ3cml0ZXMgdG1wIHZhbHVlIGluIHRhaWxcbiAgICAgICAgWG9yQW5kU2Fsc2Eob3V0LCBoZWFkLCBpbnB1dCwgKGlpICs9IDE2KSwgb3V0LCB0YWlsKTsgLy8gdGFpbFtpXSA9IFNhbHNhKGJsb2NrSW5bMippKzFdIF4gaGVhZFtpXSlcbiAgICB9XG59XG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gc2NyeXB0SW5pdChwYXNzd29yZCwgc2FsdCwgX29wdHMpIHtcbiAgICAvLyBNYXhtZW0gLSAxR0IrMUtCIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBvcHRzID0gY2hlY2tPcHRzKHtcbiAgICAgICAgZGtMZW46IDMyLFxuICAgICAgICBhc3luY1RpY2s6IDEwLFxuICAgICAgICBtYXhtZW06IDEwMjQgKiogMyArIDEwMjQsXG4gICAgfSwgX29wdHMpO1xuICAgIGNvbnN0IHsgTiwgciwgcCwgZGtMZW4sIGFzeW5jVGljaywgbWF4bWVtLCBvblByb2dyZXNzIH0gPSBvcHRzO1xuICAgIGFzc2VydE51bWJlcihOKTtcbiAgICBhc3NlcnROdW1iZXIocik7XG4gICAgYXNzZXJ0TnVtYmVyKHApO1xuICAgIGFzc2VydE51bWJlcihka0xlbik7XG4gICAgYXNzZXJ0TnVtYmVyKGFzeW5jVGljayk7XG4gICAgYXNzZXJ0TnVtYmVyKG1heG1lbSk7XG4gICAgaWYgKG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb25Qcm9ncmVzcyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9ncmVzc0NiIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIGNvbnN0IGJsb2NrU2l6ZSA9IDEyOCAqIHI7XG4gICAgY29uc3QgYmxvY2tTaXplMzIgPSBibG9ja1NpemUgLyA0O1xuICAgIGlmIChOIDw9IDEgfHwgKE4gJiAoTiAtIDEpKSAhPT0gMCB8fCBOID49IDIgKiogKGJsb2NrU2l6ZSAvIDgpIHx8IE4gPiAyICoqIDMyKSB7XG4gICAgICAgIC8vIE5PVEU6IHdlIGxpbWl0IE4gdG8gYmUgbGVzcyB0aGFuIDIqKjMyIGJlY2F1c2Ugb2YgMzIgYml0IHZhcmlhbnQgb2YgSW50ZWdyaWZ5IGZ1bmN0aW9uXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIEpTIGVuZ2luZXMgdGhhdCBhbGxvd3MgYWxvY2F0ZSBtb3JlIHRoYW4gNEdCIHBlciBzaW5nbGUgVWludDhBcnJheSBmb3Igbm93LCBidXQgY2FuIGNoYW5nZSBpbiBmdXR1cmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NyeXB0OiBOIG11c3QgYmUgbGFyZ2VyIHRoYW4gMSwgYSBwb3dlciBvZiAyLCBsZXNzIHRoYW4gMl4oMTI4ICogciAvIDgpIGFuZCBsZXNzIHRoYW4gMl4zMicpO1xuICAgIH1cbiAgICBpZiAocCA8IDAgfHwgcCA+ICgoMiAqKiAzMiAtIDEpICogMzIpIC8gYmxvY2tTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NyeXB0OiBwIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiBvciBlcXVhbCB0byAoKDJeMzIgLSAxKSAqIDMyKSAvICgxMjggKiByKScpO1xuICAgIH1cbiAgICBpZiAoZGtMZW4gPCAwIHx8IGRrTGVuID4gKDIgKiogMzIgLSAxKSAqIDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NyeXB0OiBka0xlbiBzaG91bGQgYmUgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gKDJeMzIgLSAxKSAqIDMyJyk7XG4gICAgfVxuICAgIGNvbnN0IG1lbVVzZWQgPSBibG9ja1NpemUgKiAoTiArIHApO1xuICAgIGlmIChtZW1Vc2VkID4gbWF4bWVtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NyeXB0OiBwYXJhbWV0ZXJzIHRvbyBsYXJnZSwgJHttZW1Vc2VkfSAoMTI4ICogciAqIChOICsgcCkpID4gJHttYXhtZW19IChtYXhtZW0pYCk7XG4gICAgfVxuICAgIC8vIFtCMC4uLkJw4oiSMV0g4oaQIFBCS0RGMkhNQUMtU0hBMjU2KFBhc3NwaHJhc2UsIFNhbHQsIDEsIGJsb2NrU2l6ZSpQYXJhbGxlbGl6YXRpb25GYWN0b3IpXG4gICAgLy8gU2luY2UgaXQgaGFzIG9ubHkgb25lIGl0ZXJhdGlvbiB0aGVyZSBpcyBubyByZWFzb24gdG8gdXNlIGFzeW5jIHZhcmlhbnRcbiAgICBjb25zdCBCID0gcGJrZGYyKHNoYTI1NiwgcGFzc3dvcmQsIHNhbHQsIHsgYzogMSwgZGtMZW46IGJsb2NrU2l6ZSAqIHAgfSk7XG4gICAgY29uc3QgQjMyID0gdTMyKEIpO1xuICAgIC8vIFJlLXVzZWQgYmV0d2VlbiBwYXJhbGxlbCBpdGVyYXRpb25zLiBBcnJheShpdGVyYXRpb25zKSBvZiBCXG4gICAgY29uc3QgViA9IHUzMihuZXcgVWludDhBcnJheShibG9ja1NpemUgKiBOKSk7XG4gICAgY29uc3QgdG1wID0gdTMyKG5ldyBVaW50OEFycmF5KGJsb2NrU2l6ZSkpO1xuICAgIGxldCBibG9ja01peENiID0gKCkgPT4geyB9O1xuICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsQmxvY2tNaXggPSAyICogTiAqIHA7XG4gICAgICAgIC8vIEludm9rZSBjYWxsYmFjayBpZiBwcm9ncmVzcyBjaGFuZ2VzIGZyb20gMTAuMDEgdG8gMTAuMDJcbiAgICAgICAgLy8gQWxsb3dzIHRvIGRyYXcgc21vb3RoIHByb2dyZXNzIGJhciBvbiB1cCB0byA4SyBzY3JlZW5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tQZXIgPSBNYXRoLm1heChNYXRoLmZsb29yKHRvdGFsQmxvY2tNaXggLyAxMDAwMCksIDEpO1xuICAgICAgICBsZXQgYmxvY2tNaXhDbnQgPSAwO1xuICAgICAgICBibG9ja01peENiID0gKCkgPT4ge1xuICAgICAgICAgICAgYmxvY2tNaXhDbnQrKztcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzICYmICghKGJsb2NrTWl4Q250ICUgY2FsbGJhY2tQZXIpIHx8IGJsb2NrTWl4Q250ID09PSB0b3RhbEJsb2NrTWl4KSlcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKGJsb2NrTWl4Q250IC8gdG90YWxCbG9ja01peCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9O1xufVxuZnVuY3Rpb24gc2NyeXB0T3V0cHV0KHBhc3N3b3JkLCBka0xlbiwgQiwgViwgdG1wKSB7XG4gICAgY29uc3QgcmVzID0gcGJrZGYyKHNoYTI1NiwgcGFzc3dvcmQsIEIsIHsgYzogMSwgZGtMZW4gfSk7XG4gICAgQi5maWxsKDApO1xuICAgIFYuZmlsbCgwKTtcbiAgICB0bXAuZmlsbCgwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBTY3J5cHQgS0RGIGZyb20gUkZDIDc5MTQuXG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBwYXNzXG4gKiBAcGFyYW0gc2FsdCAtIHNhbHRcbiAqIEBwYXJhbSBvcHRzIC0gcGFyYW1ldGVyc1xuICogLSBgTmAgaXMgY3B1L21lbSB3b3JrIGZhY3RvciAocG93ZXIgb2YgMiBlLmcuIDIqKjE4KVxuICogLSBgcmAgaXMgYmxvY2sgc2l6ZSAoOCBpcyBjb21tb24pLCBmaW5lLXR1bmVzIHNlcXVlbnRpYWwgbWVtb3J5IHJlYWQgc2l6ZSBhbmQgcGVyZm9ybWFuY2VcbiAqIC0gYHBgIGlzIHBhcmFsbGVsaXphdGlvbiBmYWN0b3IgKDEgaXMgY29tbW9uKVxuICogLSBgZGtMZW5gIGlzIG91dHB1dCBrZXkgbGVuZ3RoIGluIGJ5dGVzIGUuZy4gMzIuXG4gKiAtIGBhc3luY1RpY2tgIC0gKGRlZmF1bHQ6IDEwKSBtYXggdGltZSBpbiBtcyBmb3Igd2hpY2ggYXN5bmMgZnVuY3Rpb24gY2FuIGJsb2NrIGV4ZWN1dGlvblxuICogLSBgbWF4bWVtYCAtIChkZWZhdWx0OiBgMTAyNCAqKiAzICsgMTAyNGAgYWthIDFHQisxS0IpLiBBIGxpbWl0IHRoYXQgdGhlIGFwcCBjb3VsZCB1c2UgZm9yIHNjcnlwdFxuICogLSBgb25Qcm9ncmVzc2AgLSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIGV4ZWN1dGVkIGZvciBwcm9ncmVzcyByZXBvcnRcbiAqIEByZXR1cm5zIERlcml2ZWQga2V5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY3J5cHQocGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IgfSA9IHNjcnlwdEluaXQocGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGZvciAobGV0IHBpID0gMDsgcGkgPCBwOyBwaSsrKSB7XG4gICAgICAgIGNvbnN0IFBpID0gYmxvY2tTaXplMzIgKiBwaTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemUzMjsgaSsrKVxuICAgICAgICAgICAgVltpXSA9IEIzMltQaSArIGldOyAvLyBWWzBdID0gQltpXVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IE4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIEJsb2NrTWl4KFYsIHBvcywgViwgKHBvcyArPSBibG9ja1NpemUzMiksIHIpOyAvLyBWW2ldID0gQmxvY2tNaXgoVltpLTFdKTtcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfVxuICAgICAgICBCbG9ja01peChWLCAoTiAtIDEpICogYmxvY2tTaXplMzIsIEIzMiwgUGksIHIpOyAvLyBQcm9jZXNzIGxhc3QgZWxlbWVudFxuICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCB1MzIgb2YgdGhlIGxhc3QgNjQtYnl0ZSBibG9jayAodTMyIGlzIExFKVxuICAgICAgICAgICAgY29uc3QgaiA9IEIzMltQaSArIGJsb2NrU2l6ZTMyIC0gMTZdICUgTjsgLy8gaiA9IEludGVncmlmeShYKSAlIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYmxvY2tTaXplMzI7IGsrKylcbiAgICAgICAgICAgICAgICB0bXBba10gPSBCMzJbUGkgKyBrXSBeIFZbaiAqIGJsb2NrU2l6ZTMyICsga107IC8vIHRtcCA9IEIgXiBWW2pdXG4gICAgICAgICAgICBCbG9ja01peCh0bXAsIDAsIEIzMiwgUGksIHIpOyAvLyBCID0gQmxvY2tNaXgoQiBeIFZbal0pXG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjcnlwdE91dHB1dChwYXNzd29yZCwgZGtMZW4sIEIsIFYsIHRtcCk7XG59XG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNjcnlwdEFzeW5jKHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBOLCByLCBwLCBka0xlbiwgYmxvY2tTaXplMzIsIFYsIEIzMiwgQiwgdG1wLCBibG9ja01peENiLCBhc3luY1RpY2sgfSA9IHNjcnlwdEluaXQocGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGZvciAobGV0IHBpID0gMDsgcGkgPCBwOyBwaSsrKSB7XG4gICAgICAgIGNvbnN0IFBpID0gYmxvY2tTaXplMzIgKiBwaTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemUzMjsgaSsrKVxuICAgICAgICAgICAgVltpXSA9IEIzMltQaSArIGldOyAvLyBWWzBdID0gQltpXVxuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgYXdhaXQgYXN5bmNMb29wKE4gLSAxLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgICAgICAgIEJsb2NrTWl4KFYsIHBvcywgViwgKHBvcyArPSBibG9ja1NpemUzMiksIHIpOyAvLyBWW2ldID0gQmxvY2tNaXgoVltpLTFdKTtcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEJsb2NrTWl4KFYsIChOIC0gMSkgKiBibG9ja1NpemUzMiwgQjMyLCBQaSwgcik7IC8vIFByb2Nlc3MgbGFzdCBlbGVtZW50XG4gICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgYXdhaXQgYXN5bmNMb29wKE4sIGFzeW5jVGljaywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gRmlyc3QgdTMyIG9mIHRoZSBsYXN0IDY0LWJ5dGUgYmxvY2sgKHUzMiBpcyBMRSlcbiAgICAgICAgICAgIGNvbnN0IGogPSBCMzJbUGkgKyBibG9ja1NpemUzMiAtIDE2XSAlIE47IC8vIGogPSBJbnRlZ3JpZnkoWCkgJSBpdGVyYXRpb25zXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGJsb2NrU2l6ZTMyOyBrKyspXG4gICAgICAgICAgICAgICAgdG1wW2tdID0gQjMyW1BpICsga10gXiBWW2ogKiBibG9ja1NpemUzMiArIGtdOyAvLyB0bXAgPSBCIF4gVltqXVxuICAgICAgICAgICAgQmxvY2tNaXgodG1wLCAwLCBCMzIsIFBpLCByKTsgLy8gQiA9IEJsb2NrTWl4KEIgXiBWW2pdKVxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjcnlwdE91dHB1dChwYXNzd29yZCwgZGtMZW4sIEIsIFYsIHRtcCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3J5cHQuanMubWFwIiwiaW1wb3J0IHsgc2NyeXB0IGFzIF9ub2JsZVN5bmMsIHNjcnlwdEFzeW5jIGFzIF9ub2JsZUFzeW5jIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2NyeXB0XCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSBhcyBIIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5sZXQgbG9ja2VkU3luYyA9IGZhbHNlLCBsb2NrZWRBc3luYyA9IGZhbHNlO1xuY29uc3QgX3NjcnlwdEFzeW5jID0gYXN5bmMgZnVuY3Rpb24gKHBhc3N3ZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIG9uUHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gYXdhaXQgX25vYmxlQXN5bmMocGFzc3dkLCBzYWx0LCB7IE4sIHIsIHAsIGRrTGVuLCBvblByb2dyZXNzIH0pO1xufTtcbmNvbnN0IF9zY3J5cHRTeW5jID0gZnVuY3Rpb24gKHBhc3N3ZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pIHtcbiAgICByZXR1cm4gX25vYmxlU3luYyhwYXNzd2QsIHNhbHQsIHsgTiwgciwgcCwgZGtMZW4gfSk7XG59O1xubGV0IF9fc2NyeXB0QXN5bmMgPSBfc2NyeXB0QXN5bmM7XG5sZXQgX19zY3J5cHRTeW5jID0gX3NjcnlwdFN5bmM7XG4vKipcbiAqICBUaGUgW1tsaW5rLXdpa2ktc2NyeXB0XV0gdXNlcyBhIG1lbW9yeSBhbmQgY3B1IGhhcmQgbWV0aG9kIG9mXG4gKiAgZGVyaXZhdGlvbiB0byBpbmNyZWFzZSB0aGUgcmVzb3VyY2UgY29zdCB0byBicnV0ZS1mb3JjZSBhIHBhc3N3b3JkXG4gKiAgZm9yIGEgZ2l2ZW4ga2V5LlxuICpcbiAqICBUaGlzIG1lYW5zIHRoaXMgYWxnb3JpdGhtIGlzIGludGVudGlvbmFsbHkgc2xvdywgYW5kIGNhbiBiZSB0dW5lZCB0b1xuICogIGJlY29tZSBzbG93ZXIuIEFzIGNvbXB1dGF0aW9uIGFuZCBtZW1vcnkgc3BlZWQgaW1wcm92ZSBvdmVyIHRpbWUsXG4gKiAgaW5jcmVhc2luZyB0aGUgZGlmZmljdWx0eSBtYWludGFpbnMgdGhlIGNvc3Qgb2YgYW4gYXR0YWNrZXIuXG4gKlxuICogIEZvciBleGFtcGxlLCBpZiBhIHRhcmdldCB0aW1lIG9mIDUgc2Vjb25kcyBpcyB1c2VkLCBhIGxlZ2l0aW1hdGUgdXNlclxuICogIHdoaWNoIGtub3dzIHRoZWlyIHBhc3N3b3JkIHJlcXVpcmVzIG9ubHkgNSBzZWNvbmRzIHRvIHVubG9jayB0aGVpclxuICogIGFjY291bnQuIEEgNiBjaGFyYWN0ZXIgcGFzc3dvcmQgaGFzIDY4IGJpbGxpb24gcG9zc2liaWxpdGllcywgd2hpY2hcbiAqICB3b3VsZCByZXF1aXJlIGFuIGF0dGFja2VyIHRvIGludmVzdCBvdmVyIDEwLDAwMCB5ZWFycyBvZiBDUFUgdGltZS4gVGhpc1xuICogIGlzIG9mIGNvdXJzZSBhIGNydWRlIGV4YW1wbGUgKGFzIHBhc3N3b3JkIGdlbmVyYWxseSBhcmVuJ3QgcmFuZG9tKSxcbiAqICBidXQgZGVtb25zdHJhdGVzIHRvIHZhbHVlIG9mIGltcG9zaW5nIGxhcmdlIGNvc3RzIHRvIGRlY3J5cHRpb24uXG4gKlxuICogIEZvciB0aGlzIHJlYXNvbiwgaWYgYnVpbGRpbmcgYSBVSSB3aGljaCBpbnZvbHZlZCBkZWNyeXB0aW5nIG9yXG4gKiAgZW5jcnlwdGluZyBkYXRzYSB1c2luZyBzY3J5cHQsIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhXG4gKiAgW1tQcm9ncmVzc0NhbGxiYWNrXV0gKGFzIGV2ZW50IHNob3J0IHBlcmlvZHMgY2FuIHNlZW0gbGlrIGFuIGV0ZXJuaXR5XG4gKiAgaWYgdGhlIFVJIGZyZWV6ZXMpLiBJbmNsdWRpbmcgdGhlIHBocmFzZSAvL1wiZGVjcnlwdGluZ1wiLy8gaW4gdGhlIFVJXG4gKiAgY2FuIGFsc28gaGVscCwgYXNzdXJpbmcgdGhlIHVzZXIgdGhlaXIgd2FpdGluZyBpcyBmb3IgYSBnb29kIHJlYXNvbi5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86UGFzc3dvcmRzXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVGhlIHBhc3N3b3JkIG11c3QgYmUgY29udmVydGVkIHRvIGJ5dGVzLCBhbmQgaXQgaXMgZ2VuZXJhbGx5XG4gKiAgICAvLyBiZXN0IHByYWN0aWNlcyB0byBlbnN1cmUgdGhlIHN0cmluZyBoYXMgYmVlbiBub3JtYWxpemVkLiBNYW55XG4gKiAgICAvLyBmb3JtYXRzIGV4cGxpY2l0bHkgaW5kaWNhdGUgdGhlIG5vcm1hbGl6YXRpb24gZm9ybSB0byB1c2UuXG4gKiAgICBwYXNzd29yZCA9IFwiaGVsbG9cIlxuICogICAgcGFzc3dvcmRCeXRlcyA9IHRvVXRmOEJ5dGVzKHBhc3N3b3JkLCBcIk5GS0NcIilcbiAqXG4gKiAgICBzYWx0ID0gaWQoXCJzb21lLXNhbHRcIilcbiAqXG4gKiAgICAvLyBDb21wdXRlIHRoZSBzY3J5cHRcbiAqICAgIHNjcnlwdChwYXNzd29yZEJ5dGVzLCBzYWx0LCAxMDI0LCA4LCAxLCAxNilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNjcnlwdChfcGFzc3dkLCBfc2FsdCwgTiwgciwgcCwgZGtMZW4sIHByb2dyZXNzKSB7XG4gICAgY29uc3QgcGFzc3dkID0gZ2V0Qnl0ZXMoX3Bhc3N3ZCwgXCJwYXNzd2RcIik7XG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XG4gICAgcmV0dXJuIEgoYXdhaXQgX19zY3J5cHRBc3luYyhwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzcykpO1xufVxuc2NyeXB0Ll8gPSBfc2NyeXB0QXN5bmM7XG5zY3J5cHQubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkQXN5bmMgPSB0cnVlOyB9O1xuc2NyeXB0LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkQXN5bmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NyeXB0IGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19zY3J5cHRBc3luYyA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzY3J5cHQpO1xuLyoqXG4gKiAgUHJvdmlkZXMgYSBzeW5jaHJvbm91cyB2YXJpYW50IG9mIFtbc2NyeXB0XV0uXG4gKlxuICogIFRoaXMgd2lsbCBjb21wbGV0ZWx5IGxvY2sgdXAgYW5kIGZyZWV6ZSB0aGUgVUkgaW4gYSBicm93c2VyIGFuZCB3aWxsXG4gKiAgcHJldmVudCBhbnkgZXZlbnQgbG9vcCBmcm9tIHByb2dyZXNzaW5nLiBGb3IgdGhpcyByZWFzb24sIGl0IGlzXG4gKiAgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZhcmlhbnRdKHNjcnlwdCkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlBhc3N3b3Jkc1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBwYXNzd29yZCBtdXN0IGJlIGNvbnZlcnRlZCB0byBieXRlcywgYW5kIGl0IGlzIGdlbmVyYWxseVxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxuICogICAgLy8gZm9ybWF0cyBleHBsaWNpdGx5IGluZGljYXRlIHRoZSBub3JtYWxpemF0aW9uIGZvcm0gdG8gdXNlLlxuICogICAgcGFzc3dvcmQgPSBcImhlbGxvXCJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXG4gKlxuICogICAgc2FsdCA9IGlkKFwic29tZS1zYWx0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgc2NyeXB0XG4gKiAgICBzY3J5cHRTeW5jKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIDEwMjQsIDgsIDEsIDE2KVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NyeXB0U3luYyhfcGFzc3dkLCBfc2FsdCwgTiwgciwgcCwgZGtMZW4pIHtcbiAgICBjb25zdCBwYXNzd2QgPSBnZXRCeXRlcyhfcGFzc3dkLCBcInBhc3N3ZFwiKTtcbiAgICBjb25zdCBzYWx0ID0gZ2V0Qnl0ZXMoX3NhbHQsIFwic2FsdFwiKTtcbiAgICByZXR1cm4gSChfX3NjcnlwdFN5bmMocGFzc3dkLCBzYWx0LCBOLCByLCBwLCBka0xlbikpO1xufVxuc2NyeXB0U3luYy5fID0gX3NjcnlwdFN5bmM7XG5zY3J5cHRTeW5jLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZFN5bmMgPSB0cnVlOyB9O1xuc2NyeXB0U3luYy5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZFN5bmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NyeXB0U3luYyBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fc2NyeXB0U3luYyA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzY3J5cHRTeW5jKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcnlwdC5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgX3NoYTI1NiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufTtcbmNvbnN0IF9zaGE1MTIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKFwic2hhNTEyXCIpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5sZXQgX19zaGEyNTYgPSBfc2hhMjU2O1xubGV0IF9fc2hhNTEyID0gX3NoYTUxMjtcbmxldCBsb2NrZWQyNTYgPSBmYWxzZSwgbG9ja2VkNTEyID0gZmFsc2U7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFNIQTItMjU2IGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHNoYTI1NihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhMjU2KFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhMjU2KG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGEyNTYoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX3NoYTI1NihkYXRhKSk7XG59XG5zaGEyNTYuXyA9IF9zaGEyNTY7XG5zaGEyNTYubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkMjU2ID0gdHJ1ZTsgfTtcbnNoYTI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZDI1Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGEyNTYgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NoYTI1NiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzaGEyNTYpO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBTSEEyLTUxMiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBzaGE1MTIoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTUxMihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTUxMihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGE1MTIoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX3NoYTUxMihkYXRhKSk7XG59XG5zaGE1MTIuXyA9IF9zaGE1MTI7XG5zaGE1MTIubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkNTEyID0gdHJ1ZTsgfTtcbnNoYTUxMi5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZDUxMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGE1MTIgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NoYTUxMiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzaGEyNTYpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiLCJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCIsImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCIsIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIXU4YShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuZXhwb3J0IGNsYXNzIFNIQTIgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCIsImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiLCIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHU4YShoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYjEsIGIyKSB7XG4gICAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCB0aW1pbmcgYXR0YWNrcyBoZXJlXG4gICAgaWYgKGIxLmxlbmd0aCAhPT0gYjIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgY29uc3QgYml0U2V0ID0gKG4sIHBvcywgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn07XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdThmciA9IChhcnIpID0+IFVpbnQ4QXJyYXkuZnJvbShhcnIpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHsgYml0TWFzaywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyQkUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJMRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIiwiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiLCIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxuaW1wb3J0ICogYXMgbW9kIGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgKiBhcyB1dCBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyB3TkFGLCB2YWxpZGF0ZUJhc2ljIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbi8vIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXNcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnQgY29uc3QgREVSID0ge1xuICAgIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICAgIEVycjogY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgICAgIHN1cGVyKG0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfcGFyc2VJbnQoZGF0YSkge1xuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT09IDB4MDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWcnKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YVsxXTtcbiAgICAgICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICAgICAgaWYgKCFsZW4gfHwgcmVzLmxlbmd0aCAhPT0gbGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aCcpO1xuICAgICAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAgICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAgICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgICAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgICAgIGlmIChyZXNbMF0gJiAwYjEwMDAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgIShyZXNbMV0gJiAwYjEwMDAwMDAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgcmV0dXJuIHsgZDogYjJuKHJlcyksIGw6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTsgLy8gZCBpcyBkYXRhLCBsIGlzIGxlZnRcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpOGEgZXhwZWN0ZWQnKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJpdmF0ZSBrZXkgbXVzdCBiZSAke25CeXRlTGVuZ3RofSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcFByaXZhdGVLZXkpXG4gICAgICAgICAgICBudW0gPSBtb2QubW9kKG51bSwgbik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICBhc3NlcnRHRShudW0pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIHBvaW50IGJ5IHByaXZhdGVLZXkuXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxuICAgICAgICAgICAgICAgIC8vICgwLCAwLCAwKSBpcyB3cm9uZyByZXByZXNlbnRhdGlvbiBvZiBaRVJPIGFuZCBpcyBhbHdheXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAodGhpcy5weSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB4LCB5IGFyZSB2YWxpZCBmaWVsZCBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4IG9yIHkgbm90IEZFJyk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5wrJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChsZWZ0LCByaWdodCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoRnAuaXNPZGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IFUxID0gRnAuZXFsKEZwLm11bChYMSwgWjIpLCBGcC5tdWwoWDIsIFoxKSk7XG4gICAgICAgICAgICBjb25zdCBVMiA9IEZwLmVxbChGcC5tdWwoWTEsIFoyKSwgRnAubXVsKFkyLCBaMSkpO1xuICAgICAgICAgICAgcmV0dXJuIFUxICYmIFUyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5weCwgRnAubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgZG91YmxpbmcgZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAzXG4gICAgICAgIC8vIENvc3Q6IDhNICsgM1MgKyAzKmEgKyAyKmIzICsgMTVhZGQuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMSk7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLm11bChYMSwgWTEpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChYMywgWTMpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBZMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYjMsIFozKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAubXVsKGEsIHQzKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQyLCB0Myk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDFcbiAgICAgICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGEgPSBDVVJWRS5hO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0MCwgdDEpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDUgPSBGcC5hZGQoWDIsIFoyKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0NSwgdDQpOyAvLyBzdGVwIDM1XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQzLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIHQwKTsgLy8gc3RlcCA0MFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIChjb21wKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChjb21wLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgICAqIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseVVuc2FmZShuKSB7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBhc3NlcnRHRShuKTsgLy8gV2lsbCB0aHJvdyBvbiAwXG4gICAgICAgICAgICBpZiAobiA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmICghZW5kbylcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgbik7XG4gICAgICAgICAgICAvLyBBcHBseSBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XG4gICAgICAgICAgICBsZXQgazJwID0gSTtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgYXNzZXJ0R0Uoc2NhbGFyKTtcbiAgICAgICAgICAgIGxldCBuID0gc2NhbGFyO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsxcCwgZjogZjFwIH0gPSB0aGlzLndOQUYoazEpO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIpO1xuICAgICAgICAgICAgICAgIGsxcCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsxbmVnLCBrMXApO1xuICAgICAgICAgICAgICAgIGsycCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsybmVnLCBrMnApO1xuICAgICAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGYxcC5hZGQoZjJwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gdGhpcy53TkFGKG4pO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gdGhpcy5pczAoKTtcbiAgICAgICAgICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KHopO1xuICAgICAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICAgICAgY29uc3QgYXkgPSBGcC5tdWwoeSwgaXopO1xuICAgICAgICAgICAgY29uc3QgenogPSBGcC5tdWwoeiwgaXopO1xuICAgICAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuICAgICAgICB9XG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBzdWJncm91cHMsIGFsd2F5cyB0b3JzaW9uLWZyZWVcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXNUb3JzaW9uRnJlZSgpIGhhcyBub3QgYmVlbiBkZWNsYXJlZCBmb3IgdGhlIGVsbGlwdGljIGN1cnZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGNsZWFyQ29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdG9CeXRlcyhQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIEZwLk9ORSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgRnAuT1JERVI7IC8vIDAgaXMgYmFubmVkIHNpbmNlIGl0J3Mgbm90IGludmVydGlibGUgRkVcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QubW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBtb2QuaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7bGVufSB3YXMgaW52YWxpZC4gRXhwZWN0ZWQgJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBjYW4gdXNlIGFzc2VydEdFIGhlcmVcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uJyk7XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9OQnl0ZVN0cihyYWRqKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAgICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG1vZC5nZXRNaW5IYXNoTGVuZ3RoKENVUlZFLm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1vZC5tYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goZW5zdXJlQnl0ZXMoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IHV0LmNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHNnIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2c7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCIsImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMsIGV4aXN0cyBhcyBhc3NlcnRFeGlzdHMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhc3NlcnRIYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Qnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCIsIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuLy8gY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiLCIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgRmllbGQsIG1vZCwgcG93MiB9IGZyb20gJy4vYWJzdHJhY3QvbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tICcuL19zaG9ydHdfdXRpbHMuanMnO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnAgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBCaWdJbnQoMCksXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEZwLFxuICAgIG46IHNlY3AyNTZrMU4sXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBoOiBCaWdJbnQoMSksXG4gICAgbG93UzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IGZlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMU47XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiBzaGEyNTYoY29uY2F0Qnl0ZXModGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IHNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKGJ5dGVzVG9OdW1iZXJCRShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChieXRlc1RvTnVtYmVyQkUocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghZmUocikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgIG1vZCxcbiAgICB9LFxufSkpKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlzb2dlbnlNYXAoRnAsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5oYXNoVG9DdXJ2ZSkoKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiLCIvKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgemVybyBhZGRyZXNzLlxuICpcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBaZXJvQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIiwiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gaGFzaC5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0hhc2ggPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVzLmpzLm1hcCIsIi8vIE5GS0MgKGNvbXBvc2VkKSAgICAgICAgICAgICAvLyAoZGVjb21wb3NlZClcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBldGhlciBzeW1ib2wgKG5vcm1hbGl6ZWQgdXNpbmcgTkZLQykuXG4gKlxuICogICgqKmkuZS4qKiBgYFwiXFxcXHUwMzllXCJgYClcbiAqL1xuZXhwb3J0IGNvbnN0IEV0aGVyU3ltYm9sID0gXCJcXHUwMzllXCI7IC8vIFwiXFx1RDgzNVxcdURGNjNcIjtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBbW2xpbmstZWlwLTE5MV1dIHBlcnNvbmFsIG1lc3NhZ2UgcHJlZml4LlxuICpcbiAqICAoKippLmUuKiogYGBcIlxcXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXFxcblwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBNZXNzYWdlUHJlZml4ID0gXCJcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiLCJpbXBvcnQgeyBaZXJvSGFzaCB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIGlzSGV4U3RyaW5nLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vLyBDb25zdGFudHNcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IF9ndWFyZCA9IHt9O1xuZnVuY3Rpb24gdG9VaW50MjU2KHZhbHVlKSB7XG4gICAgcmV0dXJuIHplcm9QYWRWYWx1ZSh0b0JlQXJyYXkodmFsdWUpLCAzMik7XG59XG4vKipcbiAqICBBIFNpZ25hdHVyZSAgQFRPRE9cbiAqXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlNpZ25pbmdcbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgI3I7XG4gICAgI3M7XG4gICAgI3Y7XG4gICAgI25ldHdvcmtWO1xuICAgIC8qKlxuICAgICAqICBUaGUgYGByYGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFRoaXMgcmVwcmVzZW50cyB0aGUgYGB4YGAgY29vcmRpbmF0ZSBvZiBhIFwicmVmZXJlbmNlXCIgb3JcbiAgICAgKiAgY2hhbGxlbmdlIHBvaW50LCBmcm9tIHdoaWNoIHRoZSBgYHlgYCBjYW4gYmUgY29tcHV0ZWQuXG4gICAgICovXG4gICAgZ2V0IHIoKSB7IHJldHVybiB0aGlzLiNyOyB9XG4gICAgc2V0IHIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aCh2YWx1ZSkgPT09IDMyLCBcImludmFsaWQgclwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy4jciA9IGhleGxpZnkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgc2BgIHZhbHVlIGZvciBhIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgcygpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocGFyc2VJbnQodGhpcy4jcy5zdWJzdHJpbmcoMCwgMykpIDwgOCwgXCJub24tY2Fub25pY2FsIHM7IHVzZSAuX3NcIiwgXCJzXCIsIHRoaXMuI3MpO1xuICAgICAgICByZXR1cm4gdGhpcy4jcztcbiAgICB9XG4gICAgc2V0IHMoX3ZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgoX3ZhbHVlKSA9PT0gMzIsIFwiaW52YWxpZCBzXCIsIFwidmFsdWVcIiwgX3ZhbHVlKTtcbiAgICAgICAgdGhpcy4jcyA9IGhleGxpZnkoX3ZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcyB2YWx1ZSwgdW5jaGVja2VkIGZvciBFSVAtMiBjb21wbGlhbmNlLlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgdXNlZCBhbmQgaXMgZm9yIHNpdHVhdGlvbnMgd2hlcmVcbiAgICAgKiAgYSBub24tY2Fub25pY2FsIFMgdmFsdWUgbWlnaHQgYmUgcmVsZXZhbnQsIHN1Y2ggYXMgRnJvbnRpZXIgYmxvY2tzXG4gICAgICogIHRoYXQgd2VyZSBtaW5lZCBwcmlvciB0byBFSVAtMiBvciBpbnZhbGlkIEF1dGhvcml6YXRpb24gTGlzdFxuICAgICAqICBzaWduYXR1cmVzLlxuICAgICAqL1xuICAgIGdldCBfcygpIHsgcmV0dXJuIHRoaXMuI3M7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSBTaWduYXR1cmUgaXMgdmFsaWQgZm9yIFtbbGluay1laXAtMl1dIHNpZ25hdHVyZXMuXG4gICAgICovXG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIChwYXJzZUludCh0aGlzLiNzLnN1YnN0cmluZygwLCAzKSkgPCA4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHZgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiAgU2luY2UgYSBnaXZlbiBgYHhgYCB2YWx1ZSBmb3IgYGByYGAgaGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMgZm9yXG4gICAgICogIGl0cyBjb3JyZXNwb25kaW4gYGB5YGAsIHRoZSBgYHZgYCBpbmRpY2F0ZXMgd2hpY2ggb2YgdGhlIHR3byBgYHlgYFxuICAgICAqICB2YWx1ZXMgdG8gdXNlLlxuICAgICAqXG4gICAgICogIEl0IGlzIG5vcm1hbGl6ZWQgdG8gdGhlIHZhbHVlcyBgYDI3YGAgb3IgYGAyOGBgIGZvciBsZWdhY3lcbiAgICAgKiAgcHVycG9zZXMuXG4gICAgICovXG4gICAgZ2V0IHYoKSB7IHJldHVybiB0aGlzLiN2OyB9XG4gICAgc2V0IHYodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdiA9IGdldE51bWJlcih2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodiA9PT0gMjcgfHwgdiA9PT0gMjgsIFwiaW52YWxpZCB2XCIsIFwidlwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEVJUC0xNTUgYGB2YGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMuIEZvciBub24tbGVnYWN5XG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbmV0d29ya1YoKSB7IHJldHVybiB0aGlzLiNuZXR3b3JrVjsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgZm9yIEVJUC0xNTUgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCB0aGlzIHZhbHVlIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBsZWdhY3lDaGFpbklkKCkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5nZXRDaGFpbklkKHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgeVBhcml0eWBgIGZvciB0aGUgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNlZSBgYHZgYCBmb3IgbW9yZSBkZXRhaWxzIG9uIGhvdyB0aGlzIHZhbHVlIGlzIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52ID09PSAyNykgPyAwIDogMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgYHlQYXJpdHlgYFxuICAgICAqICBhbmQgYGBzYGAgY29tcGFjdGVkIGludG8gYSBzaW5nbGUgYGBieXRlczMyYGAuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHlBbmRTKCkge1xuICAgICAgICAvLyBUaGUgRUlQLTIwOTggY29tcGFjdCByZXByZXNlbnRhdGlvblxuICAgICAgICBjb25zdCB5UGFyaXR5QW5kUyA9IGdldEJ5dGVzKHRoaXMucyk7XG4gICAgICAgIGlmICh0aGlzLnlQYXJpdHkpIHtcbiAgICAgICAgICAgIHlQYXJpdHlBbmRTWzBdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkoeVBhcml0eUFuZFMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjA5OF1dIGNvbXBhY3QgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZ2V0IGNvbXBhY3RTZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFt0aGlzLnIsIHRoaXMueVBhcml0eUFuZFNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFt0aGlzLnIsIHRoaXMucywgKHRoaXMueVBhcml0eSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCByLCBzLCB2KSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJTaWduYXR1cmVcIik7XG4gICAgICAgIHRoaXMuI3IgPSByO1xuICAgICAgICB0aGlzLiNzID0gcztcbiAgICAgICAgdGhpcy4jdiA9IHY7XG4gICAgICAgIHRoaXMuI25ldHdvcmtWID0gbnVsbDtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gYFNpZ25hdHVyZSB7IHI6IFwiJHt0aGlzLnJ9XCIsIHM6IFwiJHt0aGlzLl9zfVwiJHt0aGlzLmlzVmFsaWQoKSA/IFwiXCIgOiAnLCB2YWxpZDogXCJmYWxzZVwiJ30sIHlQYXJpdHk6ICR7dGhpcy55UGFyaXR5fSwgbmV0d29ya1Y6ICR7dGhpcy5uZXR3b3JrVn0gfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IGlkZW50aWNhbCBbW1NpZ25hdHVyZV1dLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCB0aGlzLnIsIHRoaXMuX3MsIHRoaXMudik7XG4gICAgICAgIGlmICh0aGlzLm5ldHdvcmtWKSB7XG4gICAgICAgICAgICBjbG9uZS4jbmV0d29ya1YgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBgYEpTT04uc3RyaW5naWZ5YGAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJzaWduYXR1cmVcIixcbiAgICAgICAgICAgIG5ldHdvcmtWOiAoKG5ldHdvcmtWICE9IG51bGwpID8gbmV0d29ya1YudG9TdHJpbmcoKSA6IG51bGwpLFxuICAgICAgICAgICAgcjogdGhpcy5yLCBzOiB0aGlzLl9zLCB2OiB0aGlzLnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBjaGFpbiBJRCBmcm9tIHRoZSBgYHZgYCBpbiBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZCg0NSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZCg0NilcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgc3RhdGljIGdldENoYWluSWQodikge1xuICAgICAgICBjb25zdCBidiA9IGdldEJpZ0ludCh2LCBcInZcIik7XG4gICAgICAgIC8vIFRoZSB2IGlzIG5vdCBhbiBFSVAtMTU1IHYsIHNvIGl0IGlzIHRoZSB1bnNwZWNpZmllZCBjaGFpbiBJRFxuICAgICAgICBpZiAoKGJ2ID09IEJOXzI3KSB8fCAoYnYgPT0gQk5fMjgpKSB7XG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWQgdmFsdWUgZm9yIGFuIEVJUC0xNTUgdlxuICAgICAgICBhc3NlcnRBcmd1bWVudChidiA+PSBCTl8zNSwgXCJpbnZhbGlkIEVJUC0xNTUgdlwiLCBcInZcIiwgdik7XG4gICAgICAgIHJldHVybiAoYnYgLSBCTl8zNSkgLyBCTl8yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgYGB2YGAgZm9yIGEgY2hhaW4gSUQgZm9yIGEgbGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogIExlZ2FjeSB0cmFuc2FjdGlvbnMgd2hpY2ggdXNlIFtbbGluay1laXAtMTU1XV0gaGlqYWNrIHRoZSBgYHZgYFxuICAgICAqICBwcm9wZXJ0eSB0byBpbmNsdWRlIHRoZSBjaGFpbiBJRC5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoNSwgMjcpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWRWKDUsIDI4KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGFpbklkVihjaGFpbklkLCB2KSB7XG4gICAgICAgIHJldHVybiAoZ2V0QmlnSW50KGNoYWluSWQpICogQk5fMikgKyBCaWdJbnQoMzUgKyB2IC0gMjcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgbm9ybWFsaXplZCBsZWdhY3kgdHJhbnNhY3Rpb24gYGB2YGAgZnJvbSBhIGBgeVBhcmlydHlgYCxcbiAgICAgKiAgYSBsZWdhY3kgdHJhbnNhY3Rpb24gYGB2YGAgb3IgYSBsZWdhY3kgW1tsaW5rLWVpcC0xNTVdXSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICAvLyBUaGUgdmFsdWVzIDAgYW5kIDEgaW1wbHkgdiBpcyBhY3R1YWxseSB5UGFyaXR5XG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDApXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gTGVnYWN5IG5vbi1FSVAtMTU1OSB0cmFuc2FjdGlvbiAoaS5lLiAyNyBvciAyOClcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoMjcpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gTGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb24gKGkuZS4gPj0gMzUpXG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDQ2KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIEludmFsaWQgdmFsdWVzIHRocm93XG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDUpXG4gICAgICogICAgLy9fZXJyb3I6XG4gICAgICovXG4gICAgc3RhdGljIGdldE5vcm1hbGl6ZWRWKHYpIHtcbiAgICAgICAgY29uc3QgYnYgPSBnZXRCaWdJbnQodik7XG4gICAgICAgIGlmIChidiA9PT0gQk5fMCB8fCBidiA9PT0gQk5fMjcpIHtcbiAgICAgICAgICAgIHJldHVybiAyNztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnYgPT09IEJOXzEgfHwgYnYgPT09IEJOXzI4KSB7XG4gICAgICAgICAgICByZXR1cm4gMjg7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnYgPj0gQk5fMzUsIFwiaW52YWxpZCB2XCIsIFwidlwiLCB2KTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBFSVAtMTU1IHYgbWVhbnMgb2RkIGlzIDI3IGFuZCBldmVuIGlzIDI4XG4gICAgICAgIHJldHVybiAoYnYgJiBCTl8xKSA/IDI3IDogMjg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbU2lnbmF0dXJlXV0uXG4gICAgICpcbiAgICAgKiAgSWYgbm8gJSVzaWclJSBpcyBwcm92aWRlZCwgYSBuZXcgW1tTaWduYXR1cmVdXSBpcyBjcmVhdGVkXG4gICAgICogIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAgSWYgJSVzaWclJSBpcyBhIHN0cmluZywgaXQgaXMgcGFyc2VkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHNpZykge1xuICAgICAgICBmdW5jdGlvbiBhc3NlcnRFcnJvcihjaGVjaywgbWVzc2FnZSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoY2hlY2ssIG1lc3NhZ2UsIFwic2lnbmF0dXJlXCIsIHNpZyk7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoc2lnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgWmVyb0hhc2gsIFplcm9IYXNoLCAyNyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoc2lnKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhzaWcsIFwic2lnbmF0dXJlXCIpO1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBieXRlcy5zbGljZSgzMiwgNjQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSAoc1swXSAmIDB4ODApID8gMjggOiAyNztcbiAgICAgICAgICAgICAgICBzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCBoZXhsaWZ5KHMpLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKGJ5dGVzWzY0XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCBzLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcImludmFsaWQgcmF3IHNpZ25hdHVyZSBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZyBpbnN0YW5jZW9mIFNpZ25hdHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZy5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCByXG4gICAgICAgIGNvbnN0IF9yID0gc2lnLnI7XG4gICAgICAgIGFzc2VydEVycm9yKF9yICE9IG51bGwsIFwibWlzc2luZyByXCIpO1xuICAgICAgICBjb25zdCByID0gdG9VaW50MjU2KF9yKTtcbiAgICAgICAgLy8gR2V0IHM7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxuICAgICAgICBjb25zdCBzID0gKGZ1bmN0aW9uIChzLCB5UGFyaXR5QW5kUykge1xuICAgICAgICAgICAgaWYgKHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1VpbnQyNTYocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eUFuZFMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGlzSGV4U3RyaW5nKHlQYXJpdHlBbmRTLCAzMiksIFwiaW52YWxpZCB5UGFyaXR5QW5kU1wiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHlQYXJpdHlBbmRTKTtcbiAgICAgICAgICAgICAgICBieXRlc1swXSAmPSAweDdmO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3Npbmcgc1wiKTtcbiAgICAgICAgfSkoc2lnLnMsIHNpZy55UGFyaXR5QW5kUyk7XG4gICAgICAgIC8vIEdldCB2OyBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh3ZSBjaGVjayBjb25zaXN0ZW5jeSBiZWxvdylcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrViwgdiB9ID0gKGZ1bmN0aW9uIChfdiwgeVBhcml0eUFuZFMsIHlQYXJpdHkpIHtcbiAgICAgICAgICAgIGlmIChfdiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IGdldEJpZ0ludChfdik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Y6ICgodiA+PSBCTl8zNSkgPyB2IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgdjogU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKHYpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5QW5kUyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoaXNIZXhTdHJpbmcoeVBhcml0eUFuZFMsIDMyKSwgXCJpbnZhbGlkIHlQYXJpdHlBbmRTXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHY6ICgoZ2V0Qnl0ZXMoeVBhcml0eUFuZFMpWzBdICYgMHg4MCkgPyAyOCA6IDI3KSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZ2V0TnVtYmVyKHlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4geyB2OiAyNyB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiB7IHY6IDI4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcImludmFsaWQgeVBhcml0eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3NpbmcgdlwiKTtcbiAgICAgICAgfSkoc2lnLnYsIHNpZy55UGFyaXR5QW5kUywgc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgcywgdik7XG4gICAgICAgIGlmIChuZXR3b3JrVikge1xuICAgICAgICAgICAgcmVzdWx0LiNuZXR3b3JrViA9IG5ldHdvcmtWO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG11bHRpcGxlIG9mIHYsIHlQYXJpdHksIHlQYXJpdHlBbmRTIHdlIGdpdmVuLCBjaGVjayB0aGV5IG1hdGNoXG4gICAgICAgIGFzc2VydEVycm9yKHNpZy55UGFyaXR5ID09IG51bGwgfHwgZ2V0TnVtYmVyKHNpZy55UGFyaXR5LCBcInNpZy55UGFyaXR5XCIpID09PSByZXN1bHQueVBhcml0eSwgXCJ5UGFyaXR5IG1pc21hdGNoXCIpO1xuICAgICAgICBhc3NlcnRFcnJvcihzaWcueVBhcml0eUFuZFMgPT0gbnVsbCB8fCBzaWcueVBhcml0eUFuZFMgPT09IHJlc3VsdC55UGFyaXR5QW5kUywgXCJ5UGFyaXR5QW5kUyBtaXNtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIiwiLyoqXG4gKiAgQWRkIGRldGFpbHMgYWJvdXQgc2lnbmluZyBoZXJlLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86U2lnbmluZyAgW2Fib3V0LXNpZ25pbmddXG4gKi9cbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5LCB0b0JlSGV4LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLmpzXCI7XG4vKipcbiAqICBBICoqU2lnbmluZ0tleSoqIHByb3ZpZGVzIGhpZ2gtbGV2ZWwgYWNjZXNzIHRvIHRoZSBlbGxpcHRpYyBjdXJ2ZVxuICogIGNyeXB0b2dyYXBoeSAoRUNDKSBvcGVyYXRpb25zIGFuZCBrZXkgbWFuYWdlbWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25pbmdLZXkge1xuICAgICNwcml2YXRlS2V5O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqU2lnbmluZ0tleSoqIGZvciAlJXByaXZhdGVLZXklJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgocHJpdmF0ZUtleSkgPT09IDMyLCBcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgdGhpcy4jcHJpdmF0ZUtleSA9IGhleGxpZnkocHJpdmF0ZUtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJpdmF0ZSBrZXkuXG4gICAgICovXG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7IHJldHVybiB0aGlzLiNwcml2YXRlS2V5OyB9XG4gICAgLyoqXG4gICAgICogIFRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgMHgwNGBgIGFuZCBiZSAxMzJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcgKHRoZSBgYDB4YGAgcHJlZml4IGFuZCAxMzAgaGV4YWRlY2ltYWwgbmliYmxlcykuXG4gICAgICovXG4gICAgZ2V0IHB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5KTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCBlaXRoZXIgdGhlIHByZWZpeCBgYDB4MDJgYCBvciBgYDB4MDNgYFxuICAgICAqICBhbmQgYmUgNjggY2hhcmFjdGVycyBsb25nICh0aGUgYGAweGBgIHByZWZpeCBhbmQgMzMgaGV4YWRlY2ltYWxcbiAgICAgKiAgbmliYmxlcylcbiAgICAgKi9cbiAgICBnZXQgY29tcHJlc3NlZFB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5LCB0cnVlKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkICUlZGlnZXN0JSUuXG4gICAgICovXG4gICAgc2lnbihkaWdlc3QpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChkaWdlc3QpID09PSAzMiwgXCJpbnZhbGlkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24oZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCksIGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwge1xuICAgICAgICAgICAgbG93UzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgIHI6IHRvQmVIZXgoc2lnLnIsIDMyKSxcbiAgICAgICAgICAgIHM6IHRvQmVIZXgoc2lnLnMsIDMyKSxcbiAgICAgICAgICAgIHY6IChzaWcucmVjb3ZlcnkgPyAweDFjIDogMHgxYilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBbW2xpbmstd2lraS1lY2RoXV0gc2hhcmVkIHNlY3JldCBiZXR3ZWVuIHRoaXNcbiAgICAgKiAgcHJpdmF0ZSBrZXkgYW5kIHRoZSAlJW90aGVyJSUga2V5LlxuICAgICAqXG4gICAgICogIFRoZSAlJW90aGVyJSUga2V5IG1heSBiZSBhbnkgdHlwZSBvZiBrZXksIGEgcmF3IHB1YmxpYyBrZXksXG4gICAgICogIGEgY29tcHJlc3NlZC91bmNvbXByZXNzZWQgcHViaWMga2V5IG9yIGFwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqICBCZXN0IHByYWN0aWNlIGlzIHVzdWFsbHkgdG8gdXNlIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIG9uIHRoZVxuICAgICAqICByZXR1cm5lZCB2YWx1ZSBiZWZvcmUgdXNpbmcgaXQgYXMgYSBzeW1ldHJpYyBzZWNyZXQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgc2lnbjEgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTFcIikpXG4gICAgICogICAgc2lnbjIgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTJcIikpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhhdCBwcml2QS5jb21wdXRlU2hhcmVkU2VjcmV0KHB1YkIpLi4uXG4gICAgICogICAgc2lnbjEuY29tcHV0ZVNoYXJlZFNlY3JldChzaWduMi5wdWJsaWNLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gcHJpdkIuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJBKS5cbiAgICAgKiAgICBzaWduMi5jb21wdXRlU2hhcmVkU2VjcmV0KHNpZ24xLnB1YmxpY0tleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgY29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcikge1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkob3RoZXIpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwgZ2V0Qnl0ZXMocHViS2V5KSwgZmFsc2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yICUla2V5JSUsIG9wdGlvbmFsbHkgJSVjb21wcmVzc2VkJSUuXG4gICAgICpcbiAgICAgKiAgVGhlICUla2V5JSUgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSwgYVxuICAgICAqICBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJsaWMga2V5IG9yIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIHNpZ24gPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKTtcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHJpdmF0ZUtleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5LCB0cnVlKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHVibGljS2V5LCBmYWxzZSk7XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgQ29tcHJlc3NlZCBhIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIHRydWUpO1xuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcHV0ZVB1YmxpY0tleShrZXksIGNvbXByZXNzZWQpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXMoa2V5LCBcImtleVwiKTtcbiAgICAgICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoYnl0ZXMsICEhY29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShwdWJLZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJhdyBwdWJsaWMga2V5OyB1c2UgdW5jb21wcmVzc2VkIGtleSB3aXRoIDB4MDQgcHJlZml4XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICBjb25zdCBwdWIgPSBuZXcgVWludDhBcnJheSg2NSk7XG4gICAgICAgICAgICBwdWJbMF0gPSAweDA0O1xuICAgICAgICAgICAgcHViLnNldChieXRlcywgMSk7XG4gICAgICAgICAgICBieXRlcyA9IHB1YjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChieXRlcyk7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHBvaW50LnRvUmF3Qnl0ZXMoY29tcHJlc3NlZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcHVibGljIGtleSBmb3IgdGhlIHByaXZhdGUga2V5IHdoaWNoIHByb2R1Y2VkIHRoZVxuICAgICAqICAlJXNpZ25hdHVyZSUlIGZvciB0aGUgZ2l2ZW4gJSVkaWdlc3QlJS5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBrZXkgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKVxuICAgICAqICAgIGRpZ2VzdCA9IGlkKFwiaGVsbG8gd29ybGRcIilcbiAgICAgKiAgICBzaWcgPSBrZXkuc2lnbihkaWdlc3QpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhlIHNpZ25lciBwdWJsaWMga2V5Li4uXG4gICAgICogICAga2V5LnB1YmxpY0tleVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHRoZSByZWNvdmVyZWQgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKGRpZ2VzdCkgPT09IDMyLCBcImludmFsaWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICBjb25zdCBzaWcgPSBTaWduYXR1cmUuZnJvbShzaWduYXR1cmUpO1xuICAgICAgICBsZXQgc2VjcFNpZyA9IHNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbUNvbXBhY3QoZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbc2lnLnIsIHNpZy5zXSkpKTtcbiAgICAgICAgc2VjcFNpZyA9IHNlY3BTaWcuYWRkUmVjb3ZlcnlCaXQoc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwU2lnLnJlY292ZXJQdWJsaWNLZXkoZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCkpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwdWJLZXkgIT0gbnVsbCwgXCJpbnZhbGlkIHNpZ25hdHVyZSBmb3IgZGlnZXN0XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWJLZXkudG9IZXgoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcG9pbnQgcmVzdWx0aW5nIGZyb20gYWRkaW5nIHRoZSBlbGxpcGljIGN1cnZlIHBvaW50c1xuICAgICAqICAlJXAwJSUgYW5kICUlcDElJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBhIGNvbW1vbiBmdW5jdGlvbiBtb3N0IGRldmVsb3BlcnMgc2hvdWxkIHJlcXVpcmUsIGJ1dFxuICAgICAqICBjYW4gYmUgdXNlZnVsIGZvciBjZXJ0YWluIHByaXZhY3ktc3BlY2lmaWMgdGVjaG5pcXVlcy5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgaXQgaXMgdXNlZCBieSBbW0hETm9kZVdhbGxldF1dIHRvIGNvbXB1dGUgY2hpbGRcbiAgICAgKiAgYWRkcmVzc2VzIGZyb20gcGFyZW50IHB1YmxpYyBrZXlzIGFuZCBjaGFpbiBjb2Rlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUG9pbnRzKHAwLCBwMSwgY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBwdWIwID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMCkuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgY29uc3QgcHViMSA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkocDEpLnN1YnN0cmluZygyKSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWIwLmFkZChwdWIxKS50b0hleCghIWNvbXByZXNzZWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25pbmcta2V5LmpzLm1hcCIsImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzM2ID0gQmlnSW50KDM2KTtcbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgLy8gICAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzLCAyMCkpIHtcbiAgICAvLyAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgLy8gICAgfVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBnZXRCeXRlcyhrZWNjYWsyNTYoZXhwYW5kZWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBjaGFycy5qb2luKFwiXCIpO1xufVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcbi8vIENyZWF0ZSBsb29rdXAgdGFibGVcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuLy8gaS5lLiBNYXRoLmZsb29yKE1hdGgubG9nMTAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbmNvbnN0IHNhZmVEaWdpdHMgPSAxNTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5jb25zdCBCYXNlMzYgPSAoZnVuY3Rpb24gKCkge1xuICAgIDtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM2OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIltpXTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBCaWdJbnQoaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59KSgpO1xuZnVuY3Rpb24gZnJvbUJhc2UzNih2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIEJOXzM2ICsgQmFzZTM2W3ZhbHVlW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBub3JtYWxpemVkIGFuZCBjaGVja3N1bWVkIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLlxuICogIFRoaXMgYWNjZXB0cyBub24tY2hlY2tzdW0gYWRkcmVzc2VzLCBjaGVja3N1bSBhZGRyZXNzZXMgYW5kXG4gKiAgW1tnZXRJY2FwQWRkcmVzc11dIGZvcm1hdHMuXG4gKlxuICogIFRoZSBjaGVja3N1bSBpbiBFdGhlcmV1bSB1c2VzIHRoZSBjYXBpdGFsaXphdGlvbiAodXBwZXItY2FzZVxuICogIHZzIGxvd2VyLWNhc2UpIG9mIHRoZSBjaGFyYWN0ZXJzIHdpdGhpbiBhbiBhZGRyZXNzIHRvIGVuY29kZVxuICogIGl0cyBjaGVja3N1bSwgd2hpY2ggb2ZmZXJzLCBvbiBhdmVyYWdlLCBhIGNoZWNrc3VtIG9mIDE1LWJpdHMuXG4gKlxuICogIElmICUlYWRkcmVzcyUlIGNvbnRhaW5zIGJvdGggdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSwgaXQgaXNcbiAqICBhc3N1bWVkIHRvIGFscmVhZHkgYmUgYSBjaGVja3N1bSBhZGRyZXNzIGFuZCBpdHMgY2hlY2tzdW0gaXNcbiAqICB2YWxpZGF0ZWQsIGFuZCBpZiB0aGUgYWRkcmVzcyBmYWlscyBpdHMgZXhwZWN0ZWQgY2hlY2tzdW0gYW5cbiAqICBlcnJvciBpcyB0aHJvd24uXG4gKlxuICogIElmIHlvdSB3aXNoIHRoZSBjaGVja3N1bSBvZiAlJWFkZHJlc3MlJSB0byBiZSBpZ25vcmUsIGl0IHNob3VsZFxuICogIGJlIGNvbnZlcnRlZCB0byBsb3dlci1jYXNlIChpLmUuIGBgLnRvTG93ZXJjYXNlKClgYCkgYmVmb3JlXG4gKiAgYmVpbmcgcGFzc2VkIGluLiBUaGlzIHNob3VsZCBiZSBhIHZlcnkgcmFyZSBzaXR1YXRpb24gdGhvdWdoLFxuICogIHRoYXQgeW91IHdpc2ggdG8gYnlwYXNzIHRoZSBzYWZlZ2F1cmRzIGluIHBsYWNlIHRvIHByb3RlY3RcbiAqICBhZ2FpbnN0IGFuIGFkZHJlc3MgdGhhdCBoYXMgYmVlbiBpbmNvcnJlY3RseSBjb3BpZWQgZnJvbSBhbm90aGVyXG4gKiAgc291cmNlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIEFkZHMgdGhlIGNoZWNrc3VtICh2aWEgdXBwZXItY2FzaW5nIHNwZWNpZmljIGxldHRlcnMpXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udmVydHMgSUNBUCBhZGRyZXNzIGFuZCBhZGRzIGNoZWNrc3VtXG4gKiAgICBnZXRBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFuIGFkZHJlc3MgY29udGFpbnMgbWl4ZWQgY2FzZSxcbiAqICAgIC8vIGJ1dCB0aGUgY2hlY2tzdW0gZmFpbHNcbiAqICAgIGdldEFkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG4gICAgICAgIGlmICghYWRkcmVzcy5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgfHwgcmVzdWx0ID09PSBhZGRyZXNzLCBcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcbiAgICAgICAgLy8gSXQgaXMgYW4gSUNBUCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgPT09IGliYW5DaGVja3N1bShhZGRyZXNzKSwgXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBmcm9tQmFzZTM2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKS50b1N0cmluZygxNik7XG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbn1cbi8qKlxuICogIFRoZSBbSUNBUCBBZGRyZXNzIGZvcm1hdF0obGluay1pY2FwKSBmb3JtYXQgaXMgYW4gZWFybHkgY2hlY2tzdW1cbiAqICBmb3JtYXQgd2hpY2ggYXR0ZW1wdHMgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBiYW5raW5nXG4gKiAgaW5kdXN0cnkgW0lCQU4gZm9ybWF0XShsaW5rLXdpa2ktaWJhbikgZm9yIGJhbmsgYWNjb3VudHMuXG4gKlxuICogIEl0IGlzIG5vIGxvbmdlciBjb21tb24gb3IgYSByZWNvbW1lbmRlZCBmb3JtYXQuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIElDQVAgY2hlY2tzdW0gaXMgd3JvbmdcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzdcIik7XG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvL2xldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcbiAgICBsZXQgYmFzZTM2ID0gQmlnSW50KGdldEFkZHJlc3MoYWRkcmVzcykpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG4gICAgfVxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFTbGljZSwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZW5jb2RlUmxwLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcbi8vIGh0dHA6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNzYwL2hvdy1pcy10aGUtYWRkcmVzcy1vZi1hbi1ldGhlcmV1bS1jb250cmFjdC1jb21wdXRlZFxuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIGEgYGBDUkVBVEVgYCBmb3IgJSV0eCUlLlxuICpcbiAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGFkZHJlc3MgYSBjb250cmFjdCB3aWxsIGJlXG4gKiAgZGVwbG95ZWQgdG8gYnkgYW4gRU9BIHdoZW4gc2VuZGluZyBhIGRlcGxveW1lbnQgdHJhbnNhY3Rpb24gKGkuZS5cbiAqICB3aGVuIHRoZSBgYHRvYGAgYWRkcmVzcyBpcyBgYG51bGxgYCkuXG4gKlxuICogIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGEgY29udHJhY3QsIGJ5IHVzaW5nIHRoZSBjb250cmFjdCdzIGFkZHJlc3MgYXMgdGhlXG4gKiAgYGB0b2BgIGFuZCB0aGUgY29udHJhY3QncyBub25jZS5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiO1xuICogICAgbm9uY2UgPSA1O1xuICpcbiAqICAgIGdldENyZWF0ZUFkZHJlc3MoeyBmcm9tLCBub25jZSB9KTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZUFkZHJlc3ModHgpIHtcbiAgICBjb25zdCBmcm9tID0gZ2V0QWRkcmVzcyh0eC5mcm9tKTtcbiAgICBjb25zdCBub25jZSA9IGdldEJpZ0ludCh0eC5ub25jZSwgXCJ0eC5ub25jZVwiKTtcbiAgICBsZXQgbm9uY2VIZXggPSBub25jZS50b1N0cmluZygxNik7XG4gICAgaWYgKG5vbmNlSGV4ID09PSBcIjBcIikge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9uY2VIZXgubGVuZ3RoICUgMikge1xuICAgICAgICBub25jZUhleCA9IFwiMHgwXCIgKyBub25jZUhleDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vbmNlSGV4ID0gXCIweFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGFTbGljZShrZWNjYWsyNTYoZW5jb2RlUmxwKFtmcm9tLCBub25jZUhleF0pKSwgMTIpKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBhIGBgQ1JFQVRFMmBgIG9wZXJhdGlvblxuICogIHdpdGggdGhlIGdpdmVuICUlZnJvbSUlLCAlJXNhbHQlJSBhbmQgJSVpbml0Q29kZUhhc2glJS5cbiAqXG4gKiAgVG8gY29tcHV0ZSB0aGUgJSVpbml0Q29kZUhhc2glJSBmcm9tIGEgY29udHJhY3QncyBpbml0IGNvZGUsIHVzZVxuICogIHRoZSBbW2tlY2NhazI1Nl1dIGZ1bmN0aW9uLlxuICpcbiAqICBGb3IgYSBxdWljayBvdmVydmlldyBhbmQgZXhhbXBsZSBvZiBgYENSRUFURTJgYCwgc2VlIFtbbGluay1yaWNtb28td2lzcHNdXS5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgIC8vIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdFxuICogICAgZnJvbSA9IFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCJcbiAqXG4gKiAgICAvLyBUaGUgc2FsdFxuICogICAgc2FsdCA9IGlkKFwiSGVsbG9Xb3JsZFwiKVxuICpcbiAqICAgIC8vIFRoZSBoYXNoIG9mIHRoZSBpbml0Q29kZVxuICogICAgaW5pdENvZGUgPSBcIjB4NjM5NDE5OGRmMTYwMDA1MjYxMDNmZjYwMjA2MDA0NjAxYzMzNWFmYTYwNDA1MTYwNjBmM1wiO1xuICogICAgaW5pdENvZGVIYXNoID0ga2VjY2FrMjU2KGluaXRDb2RlKVxuICpcbiAqICAgIGdldENyZWF0ZTJBZGRyZXNzKGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKF9mcm9tLCBfc2FsdCwgX2luaXRDb2RlSGFzaCkge1xuICAgIGNvbnN0IGZyb20gPSBnZXRBZGRyZXNzKF9mcm9tKTtcbiAgICBjb25zdCBzYWx0ID0gZ2V0Qnl0ZXMoX3NhbHQsIFwic2FsdFwiKTtcbiAgICBjb25zdCBpbml0Q29kZUhhc2ggPSBnZXRCeXRlcyhfaW5pdENvZGVIYXNoLCBcImluaXRDb2RlSGFzaFwiKTtcbiAgICBhc3NlcnRBcmd1bWVudChzYWx0Lmxlbmd0aCA9PT0gMzIsIFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwic2FsdFwiLCBfc2FsdCk7XG4gICAgYXNzZXJ0QXJndW1lbnQoaW5pdENvZGVIYXNoLmxlbmd0aCA9PT0gMzIsIFwiaW5pdENvZGVIYXNoIG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJpbml0Q29kZUhhc2hcIiwgX2luaXRDb2RlSGFzaCk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoZGF0YVNsaWNlKGtlY2NhazI1Nihjb25jYXQoW1wiMHhmZlwiLCBmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2hdKSksIDEyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cmFjdC1hZGRyZXNzLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZVxuICogIFtbQWRkcmVzc2FibGVdXSBpbnRlcmZhY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gV2FsbGV0cyBhbmQgQWJzdHJhY3RTaWduZXIgc3ViLWNsYXNzZXNcbiAqICAgIGlzQWRkcmVzc2FibGUoV2FsbGV0LmNyZWF0ZVJhbmRvbSgpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIENvbnRyYWN0c1xuICogICAgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgWyBdLCBwcm92aWRlcilcbiAqICAgIGlzQWRkcmVzc2FibGUoY29udHJhY3QpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3NhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVmFsaWQgYWRkcmVzc1xuICogICAgaXNBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVmFsaWQgSUNBUCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgY2hlY2tzdW1cbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQmE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgSUNBUCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gTm90IGFuIGFkZHJlc3MgKGFuIEVOUyBuYW1lIHJlcXVpcmVzIGEgcHJvdmlkZWQgYW5kIGFuXG4gKiAgICAvLyBhc3luY2hyb25vdXMgQVBJIHRvIGFjY2VzcylcbiAqICAgIGlzQWRkcmVzcyhcInJpY21vby5ldGhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja0FkZHJlc3ModGFyZ2V0LCBwcm9taXNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHRhcmdldCkgIT09IFwic3RyaW5nXCIsIFwidW5jb25maWd1cmVkIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7IHZhbHVlOiB0YXJnZXQgfSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQWRkcmVzc0xpa2UgdmFsdWU7IGRpZCBub3QgcmVzb2x2ZSB0byBhIHZhbHVlIGFkZHJlc3NcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MocmVzdWx0KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGFuIGFkZHJlc3MgZm9yIHRoZSAlJXRhcmdldCUlLCB3aGljaCBtYXkgYmUgYW55XG4gKiAgc3VwcG9ydGVkIGFkZHJlc3MgdHlwZSwgYW4gW1tBZGRyZXNzYWJsZV1dIG9yIGEgUHJvbWlzZSB3aGljaFxuICogIHJlc29sdmVzIHRvIGFuIGFkZHJlc3MuXG4gKlxuICogIElmIGFuIEVOUyBuYW1lIGlzIHByb3ZpZGVkLCBidXQgdGhhdCBuYW1lIGhhcyBub3QgYmVlbiBjb3JyZWN0bHlcbiAqICBjb25maWd1cmVkIGEgW1tVbmNvbmZpZ3VyZWROYW1lRXJyb3JdXSBpcyB0aHJvd24uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgYWRkciA9IFwiMHg2QjE3NTQ3NEU4OTA5NEM0NERhOThiOTU0RWVkZUFDNDk1MjcxZDBGXCJcbiAqXG4gKiAgICAvLyBBZGRyZXNzZXMgYXJlIHJldHVybiBzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBBZGRyZXNzIHByb21pc2VzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoUHJvbWlzZS5yZXNvbHZlKGFkZHIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3NhYmxlIG9iamVjdHMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyLCBbIF0pXG4gKiAgICByZXNvbHZlQWRkcmVzcyhjb250cmFjdCwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVW5jb25maWd1cmVkIEVOUyBuYW1lcyByZWplY3RcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyBFTlMgbmFtZXMgcmVxdWlyZSBhIE5hbWVSZXNvbHZlciBvYmplY3QgcGFzc2VkIGluXG4gKiAgICAvLyAobm90aWNlIHRoZSBwcm92aWRlciB3YXMgb21pdHRlZClcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3ModGFyZ2V0LCByZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaCgvXjB4WzAtOWEtZl17NDB9JC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocmVzb2x2ZXIgIT0gbnVsbCwgXCJFTlMgcmVzb2x1dGlvbiByZXF1aXJlcyBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIgfSk7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBZGRyZXNzYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQuZ2V0QWRkcmVzcygpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiAodGFyZ2V0LnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGFkZHJlc3NhYmxlIHZhbHVlXCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIiwiLyoqXG4gKiAgQSBUeXBlZCBvYmplY3QgYWxsb3dzIGEgdmFsdWUgdG8gaGF2ZSBpdHMgdHlwZSBleHBsaWNpdGx5XG4gKiAgc3BlY2lmaWVkLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW4gU29saWRpdHksIHRoZSB2YWx1ZSBgYDQ1YGAgY291bGQgcmVwcmVzZW50IGFcbiAqICBgYHVpbnQ4YGAgb3IgYSBgYHVpbnQyNTZgYC4gVGhlIHZhbHVlIGBgMHgxMjM0YGAgY291bGQgcmVwcmVzZW50XG4gKiAgYSBgYGJ5dGVzMmBgIG9yIGBgYnl0ZXNgYC5cbiAqXG4gKiAgU2luY2UgSmF2YVNjcmlwdCBoYXMgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gZXhwbGljaXRseSBpbmZvcm0gYW55XG4gKiAgQVBJcyB3aGljaCB3aGF0IHRoZSB0eXBlIGlzLCB0aGlzIGFsbG93cyB0cmFuc3BhcmVudCBpbnRlcm9wZXJhdGlvblxuICogIHdpdGggU29sZGl0eS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvYWJpOlR5cGVkIFZhbHVlc1xuICovXG5pbXBvcnQgeyBhc3NlcnRQcml2YXRlLCBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBfZ2F1cmQgPSB7fTtcbmZ1bmN0aW9uIG4odmFsdWUsIHdpZHRoKSB7XG4gICAgbGV0IHNpZ25lZCA9IGZhbHNlO1xuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgd2lkdGggKj0gLTE7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYCR7c2lnbmVkID8gXCJcIiA6IFwidVwifWludCR7d2lkdGh9YCwgdmFsdWUsIHsgc2lnbmVkLCB3aWR0aCB9KTtcbn1cbmZ1bmN0aW9uIGIodmFsdWUsIHNpemUpIHtcbiAgICAvLyBAVE9ETzogQ2hlY2sgcmFuZ2UgaXMgdmFsaWQgZm9yIHZhbHVlXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGBieXRlcyR7KHNpemUpID8gc2l6ZSA6IFwiXCJ9YCwgdmFsdWUsIHsgc2l6ZSB9KTtcbn1cbmNvbnN0IF90eXBlZFN5bWJvbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX3R5cGVkXCIpO1xuLyoqXG4gKiAgVGhlICoqVHlwZWQqKiBjbGFzcyB0byB3cmFwIHZhbHVlcyBwcm92aWRpbmcgZXhwbGljaXQgdHlwZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUsIGFzIGEgU29saWRpdHktY29tcGF0aWJsZSB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF90eXBlZFN5bWJvbDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2F1cmQsIHR5cGUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFByaXZhdGUoX2dhdXJkLCBnYXVyZCwgXCJUeXBlZFwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IF90eXBlZFN5bWJvbCwgdHlwZSwgdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBDaGVjayB0aGUgdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgdGhpcy5mb3JtYXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEZvcm1hdCB0aGUgdHlwZSBhcyBhIEh1bWFuLVJlYWRhYmxlIHR5cGUuXG4gICAgICovXG4gICAgZm9ybWF0KCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiZHluYW1pY0FycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGB0dXBsZSgke3RoaXMudmFsdWUubWFwKCh2KSA9PiB2LmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgdGhpcyB0eXBlLlxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWluaW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtaW5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtYXhWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRCaWdJbnRdXS5cbiAgICAgKi9cbiAgICBpc0JpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMudHlwZS5tYXRjaCgvXnU/aW50WzAtOV0rJC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZERhdGFdXS5cbiAgICAgKi9cbiAgICBpc0RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3RhcnRzV2l0aChcImJ5dGVzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkU3RyaW5nXV0uXG4gICAgICovXG4gICAgaXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSBcInN0cmluZ1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHR1cGxlIG5hbWUsIGlmIHRoaXMgaXMgYSB0dXBsZS4gVGhyb3dzIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgdHVwbGVOYW1lKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5vdCBhIHR1cGxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhpcyB0eXBlIGFzIGFuIGFycmF5XG4gICAgLy8gLSBgbnVsbGAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgdW5mb3JjZWQsIGl0IGNvdWxkIGJlIGR5bmFtaWNcbiAgICAvLyAtIGAtMWAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgZHluYW1pY1xuICAgIC8vIC0gYW55IG90aGVyIHZhbHVlIGluZGljYXRlcyBpdCBpcyBhIHN0YXRpYyBhcnJheSBhbmQgaXMgaXRzIGxlbmd0aFxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHR5cGUgb3IgYGAtMWBgIGlmIGl0IGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSB0eXBlIGlzIG5vdCBhbiBhcnJheS5cbiAgICAgKi9cbiAgICBnZXQgYXJyYXlMZW5ndGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipUeXBlZCoqIG9mICUldHlwZSUlIHdpdGggdGhlICUldmFsdWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgdHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgodikgeyByZXR1cm4gbih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2KHYpIHsgcmV0dXJuIG4odiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQodikgeyByZXR1cm4gbih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQzMih2KSB7IHJldHVybiBuKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDQwKHYpIHsgcmV0dXJuIG4odiwgNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDgodikgeyByZXR1cm4gbih2LCA0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ1Nih2KSB7IHJldHVybiBuKHYsIDU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDY0KHYpIHsgcmV0dXJuIG4odiwgNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NzIodikgeyByZXR1cm4gbih2LCA3Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDgwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4MCh2KSB7IHJldHVybiBuKHYsIDgwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDg4KHYpIHsgcmV0dXJuIG4odiwgODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OTYodikgeyByZXR1cm4gbih2LCA5Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEwNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTA0KHYpIHsgcmV0dXJuIG4odiwgMTA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMTIodikgeyByZXR1cm4gbih2LCAxMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEyMCh2KSB7IHJldHVybiBuKHYsIDEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTI4KHYpIHsgcmV0dXJuIG4odiwgMTI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMzYodikgeyByZXR1cm4gbih2LCAxMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE0NCh2KSB7IHJldHVybiBuKHYsIDE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTUyKHYpIHsgcmV0dXJuIG4odiwgMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNjAodikgeyByZXR1cm4gbih2LCAxNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2OCh2KSB7IHJldHVybiBuKHYsIDE2OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTc2KHYpIHsgcmV0dXJuIG4odiwgMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxODQodikgeyByZXR1cm4gbih2LCAxODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxOTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE5Mih2KSB7IHJldHVybiBuKHYsIDE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjAwKHYpIHsgcmV0dXJuIG4odiwgMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjA4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDgodikgeyByZXR1cm4gbih2LCAyMDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIxNih2KSB7IHJldHVybiBuKHYsIDIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjI0KHYpIHsgcmV0dXJuIG4odiwgMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMzIodikgeyByZXR1cm4gbih2LCAyMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0MCh2KSB7IHJldHVybiBuKHYsIDI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNTYodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludCh2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4KHYpIHsgcmV0dXJuIG4odiwgLTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2KHYpIHsgcmV0dXJuIG4odiwgLTE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNCh2KSB7IHJldHVybiBuKHYsIC0yNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MzIodikgeyByZXR1cm4gbih2LCAtMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQwKHYpIHsgcmV0dXJuIG4odiwgLTQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ0OCh2KSB7IHJldHVybiBuKHYsIC00OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NTYodikgeyByZXR1cm4gbih2LCAtNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDY0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDY0KHYpIHsgcmV0dXJuIG4odiwgLTY0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ3Mih2KSB7IHJldHVybiBuKHYsIC03Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODAodikgeyByZXR1cm4gbih2LCAtODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDg4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDg4KHYpIHsgcmV0dXJuIG4odiwgLTg4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ5Nih2KSB7IHJldHVybiBuKHYsIC05Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEwNCh2KSB7IHJldHVybiBuKHYsIC0xMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDExMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMTIodikgeyByZXR1cm4gbih2LCAtMTEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTIwKHYpIHsgcmV0dXJuIG4odiwgLTEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEyOCh2KSB7IHJldHVybiBuKHYsIC0xMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMzYodikgeyByZXR1cm4gbih2LCAtMTM2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgLTE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTUyKHYpIHsgcmV0dXJuIG4odiwgLTE1Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2MCh2KSB7IHJldHVybiBuKHYsIC0xNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNjgodikgeyByZXR1cm4gbih2LCAtMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTc2KHYpIHsgcmV0dXJuIG4odiwgLTE3Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE4NCh2KSB7IHJldHVybiBuKHYsIC0xODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDkyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE5Mih2KSB7IHJldHVybiBuKHYsIC0xOTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDAodikgeyByZXR1cm4gbih2LCAtMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjA4KHYpIHsgcmV0dXJuIG4odiwgLTIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIxNih2KSB7IHJldHVybiBuKHYsIC0yMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMjQodikgeyByZXR1cm4gbih2LCAtMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjMyKHYpIHsgcmV0dXJuIG4odiwgLTIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0MCh2KSB7IHJldHVybiBuKHYsIC0yNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNDgodikgeyByZXR1cm4gbih2LCAtMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjU2KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludCh2KSB7IHJldHVybiBuKHYsIC0yNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEodikgeyByZXR1cm4gYih2LCAxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyKHYpIHsgcmV0dXJuIGIodiwgMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMyh2KSB7IHJldHVybiBiKHYsIDMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczQodikgeyByZXR1cm4gYih2LCA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM1KHYpIHsgcmV0dXJuIGIodiwgNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNih2KSB7IHJldHVybiBiKHYsIDYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczcodikgeyByZXR1cm4gYih2LCA3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM4KHYpIHsgcmV0dXJuIGIodiwgOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzOSh2KSB7IHJldHVybiBiKHYsIDkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMCh2KSB7IHJldHVybiBiKHYsIDEwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczExYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTEodikgeyByZXR1cm4gYih2LCAxMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEyKHYpIHsgcmV0dXJuIGIodiwgMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMyh2KSB7IHJldHVybiBiKHYsIDEzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTQodikgeyByZXR1cm4gYih2LCAxNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE1KHYpIHsgcmV0dXJuIGIodiwgMTUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNih2KSB7IHJldHVybiBiKHYsIDE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTcodikgeyByZXR1cm4gYih2LCAxNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE4KHYpIHsgcmV0dXJuIGIodiwgMTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxOSh2KSB7IHJldHVybiBiKHYsIDE5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjAodikgeyByZXR1cm4gYih2LCAyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIxKHYpIHsgcmV0dXJuIGIodiwgMjEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMih2KSB7IHJldHVybiBiKHYsIDIyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjModikgeyByZXR1cm4gYih2LCAyMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI0KHYpIHsgcmV0dXJuIGIodiwgMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNSh2KSB7IHJldHVybiBiKHYsIDI1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjYodikgeyByZXR1cm4gYih2LCAyNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI3KHYpIHsgcmV0dXJuIGIodiwgMjcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOCh2KSB7IHJldHVybiBiKHYsIDI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjkodikgeyByZXR1cm4gYih2LCAyOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMwKHYpIHsgcmV0dXJuIGIodiwgMzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMSh2KSB7IHJldHVybiBiKHYsIDMxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzIodikgeyByZXR1cm4gYih2LCAzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYWRkcmVzc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRyZXNzKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYWRkcmVzc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBib29sYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJvb2wodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJib29sXCIsICEhdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJieXRlc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBzdHJpbmdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwic3RyaW5nXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFycmF5YGAgdHlwZSBmb3IgJSV2JSUsIGFsbG93aW5nICUlZHluYW1pYyUlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXkodiwgZHluYW1pYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhcnJheVwiLCB2LCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHR1cGxlYGAgdHlwZSBmb3IgJSV2JSUsIHdpdGggdGhlIG9wdGlvbmFsICUlbmFtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB0dXBsZSh2LCBuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInR1cGxlXCIsIHYsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgb3ZlcnJpZGVzKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwib3ZlcnJpZGVzXCIsIE9iamVjdC5hc3NpZ24oe30sIHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmICUldmFsdWUlJSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUeXBlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlXG4gICAgICAgICAgICAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgJiYgXCJfdHlwZWRTeW1ib2xcIiBpbiB2YWx1ZVxuICAgICAgICAgICAgJiYgdmFsdWUuX3R5cGVkU3ltYm9sID09PSBfdHlwZWRTeW1ib2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIHZhbHVlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLCB2YWxpZGF0ZXMgdGhlIHVuZGVybHlpbmcgdmFsdWVcbiAgICAgKiAgYW5kIHJldHVybnMgaXQsIG90aGVyd2lzZSByZXR1cm5zIHZhbHVlIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciBmdW5jdGlvbnMgdGhhdCB3aXRoIHRvIGFjY2VwdCBlaXRoZXIgYSBbW1R5cGVkXV1cbiAgICAgKiAgb2JqZWN0IG9yIHZhbHVlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKFR5cGVkLmlzVHlwZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlOiBleHBlY2V0ZCAke3R5cGV9LCBnb3QgJHt2YWx1ZS50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uLy4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHRvQmVIZXggfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQWRkcmVzc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModG9CZUhleChyZWFkZXIucmVhZFZhbHVlKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiLCJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBDbG9uZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gZXhpc3RpbmcgQ29kZXIsIGJ1dCB3aXRob3V0IGEgbG9jYWxOYW1lXG4gKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBbm9ueW1vdXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb2RlcjtcbiAgICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgICAgICBzdXBlcihjb2Rlci5uYW1lLCBjb2Rlci50eXBlLCBcIl9cIiwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFub255bW91cy5qcy5tYXAiLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRBcmd1bWVudENvdW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIsIFJlc3VsdCwgV29yZFNpemUsIFdyaXRlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBbm9ueW1vdXNDb2RlciB9IGZyb20gXCIuL2Fub255bW91cy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlcykge1xuICAgIGxldCBhcnJheVZhbHVlcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGV0IHVuaXF1ZSA9IHt9O1xuICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgYXNzZXJ0KG5hbWUsIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIGFzc2VydCghdW5pcXVlW25hbWVdLCBcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBkdXBsaWNhdGUgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIHVuaXF1ZVtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgdHVwbGUgdmFsdWVcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb2RlcnMubGVuZ3RoID09PSBhcnJheVZhbHVlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICBsZXQgc3RhdGljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCB1cGRhdGVGdW5jcyA9IFtdO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZHluYW1pYyBvZmZzZXQgKGZvciB0aGUgZnV0dXJlIHBvaW50ZXIpXG4gICAgICAgICAgICBsZXQgZHluYW1pY09mZnNldCA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSBkeW5hbWljIHZhbHVlIGludG8gdGhlIGR5bmFtaWNXcml0ZXJcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShkeW5hbWljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuYyA9IHN0YXRpY1dyaXRlci53cml0ZVVwZGF0YWJsZVZhbHVlKCk7XG4gICAgICAgICAgICB1cGRhdGVGdW5jcy5wdXNoKChiYXNlT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEJhY2tmaWxsIGFsbCB0aGUgZHluYW1pYyBvZmZzZXRzLCBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0aWMgbGVuZ3RoXG4gICAgdXBkYXRlRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKHN0YXRpY1dyaXRlci5sZW5ndGgpOyB9KTtcbiAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xuICAgIGxlbmd0aCArPSB3cml0ZXIuYXBwZW5kV3JpdGVyKGR5bmFtaWNXcml0ZXIpO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrKHJlYWRlciwgY29kZXJzKSB7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBrZXlzID0gW107XG4gICAgLy8gQSByZWFkZXIgYW5jaG9yZWQgdG8gdGhpcyBiYXNlXG4gICAgbGV0IGJhc2VSZWFkZXIgPSByZWFkZXIuc3ViUmVhZGVyKDApO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRSZWFkZXIgPSBiYXNlUmVhZGVyLnN1YlJlYWRlcihvZmZzZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQlVGRkVSX09WRVJSVU5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlc3RpZ2F0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIGtleXMucHVzaChjb2Rlci5sb2NhbE5hbWUgfHwgbnVsbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVyO1xuICAgIGxlbmd0aDtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IChjb2Rlci50eXBlICsgXCJbXCIgKyAobGVuZ3RoID49IDAgPyBsZW5ndGggOiBcIlwiKSArIFwiXVwiKTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IChsZW5ndGggPT09IC0xIHx8IGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb2RlciwgbGVuZ3RoIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIC8vIFZlcmlmaWVzIHRoZSBjaGlsZCBjb2RlciBpcyB2YWxpZCAoZXZlbiBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYyBvciAwLWxlbmd0aClcbiAgICAgICAgY29uc3QgZGVmYXVsdENoaWxkID0gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVmYXVsdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYXJyYXlcIik7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgKnJvdWdobHkqIGVub3VnaCBkYXRhIHRvIGVuc3VyZVxuICAgICAgICAgICAgLy8gc3RyYXkgcmFuZG9tIGRhdGEgaXMgbm90IGJlaW5nIHJlYWQgYXMgYSBsZW5ndGguIEVhY2hcbiAgICAgICAgICAgIC8vIHNsb3QgcmVxdWlyZXMgYXQgbGVhc3QgMzIgYnl0ZXMgZm9yIHRoZWlyIHZhbHVlIChvciAzMlxuICAgICAgICAgICAgLy8gYnl0ZXMgYXMgYSBsaW5rIHRvIHRoZSBkYXRhKS4gVGhpcyBjb3VsZCB1c2UgYSBtdWNoXG4gICAgICAgICAgICAvLyB0aWdodGVyIGJvdW5kLCBidXQgd2UgYXJlIGVycm9yaW5nIG9uIHRoZSBzaWRlIG9mIHNhZmV0eS5cbiAgICAgICAgICAgIGFzc2VydChjb3VudCAqIFdvcmRTaXplIDw9IHJlYWRlci5kYXRhTGVuZ3RoLCBcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiByZWFkZXIuYnl0ZXMsIG9mZnNldDogY291bnQgKiBXb3JkU2l6ZSwgbGVuZ3RoOiByZWFkZXIuZGF0YUxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IEFub255bW91c0NvZGVyKHRoaXMuY29kZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5wYWNrKHJlYWRlciwgY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCJpbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEJvb2xlYW5Db2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJib29sXCIsIFwiYm9vbFwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJib29sXCIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUgPyAxIDogMCk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuICEhcmVhZGVyLnJlYWRWYWx1ZSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xlYW4uanMubWFwIiwiaW1wb3J0IHsgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRHluYW1pY0J5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHR5cGUsIGxvY2FsTmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRCeXRlc0NvcHkodmFsdWUpO1xuICAgICAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoICs9IHdyaXRlci53cml0ZUJ5dGVzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRCeXRlcyhyZWFkZXIucmVhZEluZGV4KCksIHRydWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJ5dGVzXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBGaXhlZEJ5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgc2l6ZTtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBcImJ5dGVzXCIgKyBTdHJpbmcoc2l6ZSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgc2l6ZSB9LCB7IHNpemU6IFwibnVtYmVyXCIgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIChcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKS5zdWJzdHJpbmcoMCwgMiArIHRoaXMuc2l6ZSAqIDIpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBnZXRCeXRlc0NvcHkoVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCB0aGlzLnR5cGUpKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJpbmNvcnJlY3QgZGF0YSBsZW5ndGhcIiwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoZGF0YSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkocmVhZGVyLnJlYWRCeXRlcyh0aGlzLnNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZC1ieXRlcy5qcy5tYXAiLCJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5jb25zdCBFbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBOdWxsQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwibnVsbFwiLCBcIlwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJub3QgbnVsbFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKEVtcHR5KTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZWFkZXIucmVhZEJ5dGVzKDApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGZyb21Ud29zLCBnZXRCaWdJbnQsIG1hc2ssIHRvVHdvcyB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyLCBXb3JkU2l6ZSB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOX01BWF9VSU5UMjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIE51bWJlckNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIHNpemU7XG4gICAgc2lnbmVkO1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHNpZ25lZCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoKHNpZ25lZCA/IFwiaW50XCIgOiBcInVpbnRcIikgKyAoc2l6ZSAqIDgpKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBzaXplLCBzaWduZWQgfSwgeyBzaXplOiBcIm51bWJlclwiLCBzaWduZWQ6IFwiYm9vbGVhblwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIC8vIENoZWNrIGJvdW5kcyBhcmUgc2FmZSBmb3IgZW5jb2RpbmdcbiAgICAgICAgbGV0IG1heFVpbnRWYWx1ZSA9IG1hc2soQk5fTUFYX1VJTlQyNTYsIFdvcmRTaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgbGV0IGJvdW5kcyA9IG1hc2sobWF4VWludFZhbHVlLCAodGhpcy5zaXplICogOCkgLSAxKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IGJvdW5kcyB8fCB2YWx1ZSA8IC0oYm91bmRzICsgQk5fMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB0b1R3b3ModmFsdWUsIDggKiBXb3JkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCBCTl8wIHx8IHZhbHVlID4gbWFzayhtYXhVaW50VmFsdWUsIHRoaXMuc2l6ZSAqIDgpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbWFzayhyZWFkZXIucmVhZFZhbHVlKCksIHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbVR3b3ModmFsdWUsIHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIiwiaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi8uLi91dGlscy91dGY4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgRHluYW1pY0J5dGVzQ29kZXIgfSBmcm9tIFwiLi9ieXRlcy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcInN0cmluZ1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuY29kZSh3cml0ZXIsIHRvVXRmOEJ5dGVzKFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJzdHJpbmdcIikpKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwIiwiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgcGFjaywgdW5wYWNrIH0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUdXBsZUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVycztcbiAgICBjb25zdHJ1Y3Rvcihjb2RlcnMsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlcy5wdXNoKGNvZGVyLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IChcInR1cGxlKFwiICsgdHlwZXMuam9pbihcIixcIikgKyBcIilcIik7XG4gICAgICAgIHN1cGVyKFwidHVwbGVcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyczogT2JqZWN0LmZyZWV6ZShjb2RlcnMuc2xpY2UoKSkgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChjb2Rlci5kZWZhdWx0VmFsdWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB0aGlzLmNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gQWRkIG5hbWVkIHZhbHVlc1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInR1cGxlXCIpO1xuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIHRoaXMuY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiLCJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBpc0hleFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gYWNjZXNzU2V0aWZ5KGFkZHIsIHN0b3JhZ2VLZXlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyhhZGRyKSxcbiAgICAgICAgc3RvcmFnZUtleXM6IHN0b3JhZ2VLZXlzLm1hcCgoc3RvcmFnZUtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHN0b3JhZ2VLZXksIDMyKSwgXCJpbnZhbGlkIHNsb3RcIiwgYHN0b3JhZ2VLZXlzWyR7aW5kZXh9XWAsIHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VLZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbQWNjZXNzTGlzdF1dIGZyb20gYW55IGV0aGVycy1zdXBwb3J0ZWQgYWNjZXNzLWxpc3Qgc3RydWN0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWNjZXNzTGlzdGlmeSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChzZXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXQpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0Lmxlbmd0aCA9PT0gMiwgXCJpbnZhbGlkIHNsb3Qgc2V0XCIsIGB2YWx1ZVske2luZGV4fV1gLCBzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0WzBdLCBzZXRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0ICE9IG51bGwgJiYgdHlwZW9mIChzZXQpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWRkcmVzcy1zbG90IHNldFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWNjZXNzIGxpc3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoYWRkcikgPT4ge1xuICAgICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHZhbHVlW2FkZHJdLnJlZHVjZSgoYWNjdW0sIHN0b3JhZ2VLZXkpID0+IHtcbiAgICAgICAgICAgIGFjY3VtW3N0b3JhZ2VLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KGFkZHIsIE9iamVjdC5rZXlzKHN0b3JhZ2VLZXlzKS5zb3J0KCkpO1xuICAgIH0pO1xuICAgIHJlc3VsdC5zb3J0KChhLCBiKSA9PiAoYS5hZGRyZXNzLmxvY2FsZUNvbXBhcmUoYi5hZGRyZXNzKSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3NsaXN0LmpzLm1hcCIsImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gYXV0aG9yaXphdGlvbmlmeShhdXRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyhhdXRoLmFkZHJlc3MpLFxuICAgICAgICBub25jZTogZ2V0QmlnSW50KChhdXRoLm5vbmNlICE9IG51bGwpID8gYXV0aC5ub25jZSA6IDApLFxuICAgICAgICBjaGFpbklkOiBnZXRCaWdJbnQoKGF1dGguY2hhaW5JZCAhPSBudWxsKSA/IGF1dGguY2hhaW5JZCA6IDApLFxuICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tKGF1dGguc2lnbmF0dXJlKVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRob3JpemF0aW9uLmpzLm1hcCIsImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBTaWduaW5nS2V5IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyBmb3IgdGhlICUla2V5JSUuXG4gKlxuICogIFRoZSBrZXkgbWF5IGJlIGFueSBzdGFuZGFyZCBmb3JtIG9mIHB1YmxpYyBrZXkgb3IgYSBwcml2YXRlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGtleSkge1xuICAgIGxldCBwdWJrZXk7XG4gICAgaWYgKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwdWJrZXkgPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoa2V5LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdWJrZXkgPSBrZXkucHVibGljS2V5O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhrZWNjYWsyNTYoXCIweFwiICsgcHVia2V5LnN1YnN0cmluZyg0KSkuc3Vic3RyaW5nKDI2KSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSByZWNvdmVyZWQgYWRkcmVzcyBmb3IgdGhlIHByaXZhdGUga2V5IHRoYXQgd2FzXG4gKiAgdXNlZCB0byBzaWduICUlZGlnZXN0JSUgdGhhdCByZXN1bHRlZCBpbiAlJXNpZ25hdHVyZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MoU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCIsImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2FkZHJlc3Nlcy5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBzaGEyNTYsIFNpZ25hdHVyZSwgU2lnbmluZ0tleSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGVjb2RlUmxwLCBlbmNvZGVSbHAsIGdldEJ5dGVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNCeXRlc0xpa2UsIGlzSGV4U3RyaW5nLCB0b0JlQXJyYXksIHplcm9QYWRWYWx1ZSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuL2FjY2Vzc2xpc3QuanNcIjtcbmltcG9ydCB7IGF1dGhvcml6YXRpb25pZnkgfSBmcm9tIFwiLi9hdXRob3JpemF0aW9uLmpzXCI7XG5pbXBvcnQgeyByZWNvdmVyQWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgQk5fMjcgPSBCaWdJbnQoMjcpO1xuY29uc3QgQk5fMjggPSBCaWdJbnQoMjgpO1xuY29uc3QgQk5fMzUgPSBCaWdJbnQoMzUpO1xuY29uc3QgQk5fTUFYX1VJTlQgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG5jb25zdCBCTE9CX1NJWkUgPSA0MDk2ICogMzI7XG5mdW5jdGlvbiBnZXRLemdMaWJyYXJ5KGt6Zykge1xuICAgIGNvbnN0IGJsb2JUb0t6Z0NvbW1pdG1lbnQgPSAoYmxvYikgPT4ge1xuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYlByb29mXCIgaW4ga3pnKSB7XG4gICAgICAgICAgICAvLyBtaWNyby1lY2Mtc2lnbmVyOyBjaGVjayBmb3IgY29tcHV0ZUJsb2JQcm9vZiBzaW5jZSB0aGlzIEFQSVxuICAgICAgICAgICAgLy8gZXhwZWN0cyBhIHN0cmluZyB3aGlsZSB0aGUga3pnLXdhc20gYmVsb3cgZXhwZWN0cyBhIFVuaXQ4QXJyYXlcbiAgICAgICAgICAgIGlmIChcImJsb2JUb0t6Z0NvbW1pdG1lbnRcIiBpbiBremcgJiYgdHlwZW9mIChremcuYmxvYlRvS3pnQ29tbWl0bWVudCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuYmxvYlRvS3pnQ29tbWl0bWVudChoZXhsaWZ5KGJsb2IpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJibG9iVG9LemdDb21taXRtZW50XCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIGt6Zy13YXNtIDwwLjUuMDsgYmxvYlRvS3pnQ29tbWl0bWVudChVaW50OEFycmF5KSA9PiBVaW50OEFycmF5XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQoYmxvYikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGt6Zy13YXNtID49IDAuNS4wOyBibG9iVG9LWkdDb21taXRtZW50KHN0cmluZykgPT4gc3RyaW5nXG4gICAgICAgIGlmIChcImJsb2JUb0taR0NvbW1pdG1lbnRcIiBpbiBremcgJiYgdHlwZW9mIChremcuYmxvYlRvS1pHQ29tbWl0bWVudCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5ibG9iVG9LWkdDb21taXRtZW50KGhleGxpZnkoYmxvYikpKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBLWkcgbGlicmFyeVwiLCBcImt6Z1wiLCBremcpO1xuICAgIH07XG4gICAgY29uc3QgY29tcHV0ZUJsb2JLemdQcm9vZiA9IChibG9iLCBjb21taXRtZW50KSA9PiB7XG4gICAgICAgIC8vIG1pY3JvLWVjYy1zaWduZXJcbiAgICAgICAgaWYgKFwiY29tcHV0ZUJsb2JQcm9vZlwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5jb21wdXRlQmxvYlByb29mKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmNvbXB1dGVCbG9iUHJvb2YoaGV4bGlmeShibG9iKSwgaGV4bGlmeShjb21taXRtZW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGt6Zy13YXNtIDwwLjUuMDsgY29tcHV0ZUJsb2JLemdQcm9vZihVaW50OEFycmF5LCBVaW50OEFycmF5KSA9PiBVaW50OEFycmF5XG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iS3pnUHJvb2ZcIiBpbiBremcgJiYgdHlwZW9mIChremcuY29tcHV0ZUJsb2JLemdQcm9vZikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGt6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKGJsb2IsIGNvbW1pdG1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGt6Zy13YXNtID49IDAuNS4wOyBjb21wdXRlQmxvYktaR1Byb29mKHN0cmluZywgc3RyaW5nKSA9PiBzdHJpbmdcbiAgICAgICAgaWYgKFwiY29tcHV0ZUJsb2JLWkdQcm9vZlwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5jb21wdXRlQmxvYktaR1Byb29mKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmNvbXB1dGVCbG9iS1pHUHJvb2YoaGV4bGlmeShibG9iKSwgaGV4bGlmeShjb21taXRtZW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIEtaRyBsaWJyYXJ5XCIsIFwia3pnXCIsIGt6Zyk7XG4gICAgfTtcbiAgICByZXR1cm4geyBibG9iVG9LemdDb21taXRtZW50LCBjb21wdXRlQmxvYkt6Z1Byb29mIH07XG59XG5mdW5jdGlvbiBnZXRWZXJzaW9uZWRIYXNoKHZlcnNpb24sIGhhc2gpIHtcbiAgICBsZXQgdmVyc2lvbmVkID0gdmVyc2lvbi50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHZlcnNpb25lZC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHZlcnNpb25lZCA9IFwiMFwiICsgdmVyc2lvbmVkO1xuICAgIH1cbiAgICB2ZXJzaW9uZWQgKz0gc2hhMjU2KGhhc2gpLnN1YnN0cmluZyg0KTtcbiAgICByZXR1cm4gXCIweFwiICsgdmVyc2lvbmVkO1xufVxuZnVuY3Rpb24gaGFuZGxlQWRkcmVzcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBY2Nlc3NMaXN0KHZhbHVlLCBwYXJhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBwYXJhbSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUF1dGhvcml6YXRpb25MaXN0KHZhbHVlLCBwYXJhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF1dGhvcml6YXRpb25MaXN0OiBpbnZhbGlkIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhdXRoID0gdmFsdWVbaV07XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXV0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF1dGhvcml6YXRpb25bJHtpfV06IGludmFsaWQgYXJyYXlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdXRoLmxlbmd0aCAhPT0gNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXV0aG9yaXphdGlvblske2l9XTogd3JvbmcgbGVuZ3RoYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWF1dGhbMV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF1dGhvcml6YXRpb25bJHtpfV06IG51bGwgYWRkcmVzc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGhhbmRsZUFkZHJlc3MoYXV0aFsxXSksXG4gICAgICAgICAgICAgICAgbm9uY2U6IGhhbmRsZVVpbnQoYXV0aFsyXSwgXCJub25jZVwiKSxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGF1dGhbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eTogaGFuZGxlTnVtYmVyKGF1dGhbM10sIFwieVBhcml0eVwiKSxcbiAgICAgICAgICAgICAgICAgICAgcjogemVyb1BhZFZhbHVlKGF1dGhbNF0sIDMyKSxcbiAgICAgICAgICAgICAgICAgICAgczogemVyb1BhZFZhbHVlKGF1dGhbNV0sIDMyKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIHBhcmFtLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlTnVtYmVyKF92YWx1ZSwgcGFyYW0pIHtcbiAgICBpZiAoX3ZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBnZXROdW1iZXIoX3ZhbHVlLCBwYXJhbSk7XG59XG5mdW5jdGlvbiBoYW5kbGVVaW50KF92YWx1ZSwgcGFyYW0pIHtcbiAgICBpZiAoX3ZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgcGFyYW0pO1xuICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlIDw9IEJOX01BWF9VSU5ULCBcInZhbHVlIGV4Y2VlZHMgdWludCBzaXplXCIsIHBhcmFtLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKF92YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCByZXN1bHQgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5sZW5ndGggPD0gMzIsIGB2YWx1ZSB0b28gbGFyZ2VgLCBgdHguJHtuYW1lfWAsIHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ybWF0QWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKS5tYXAoKHNldCkgPT4gW3NldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXNdKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEF1dGhvcml6YXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcCgoYSkgPT4ge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZm9ybWF0TnVtYmVyKGEuY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICAgICAgYS5hZGRyZXNzLFxuICAgICAgICAgICAgZm9ybWF0TnVtYmVyKGEubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgICAgICBmb3JtYXROdW1iZXIoYS5zaWduYXR1cmUueVBhcml0eSwgXCJ5UGFyaXR5XCIpLFxuICAgICAgICAgICAgdG9CZUFycmF5KGEuc2lnbmF0dXJlLnIpLFxuICAgICAgICAgICAgdG9CZUFycmF5KGEuc2lnbmF0dXJlLnMpXG4gICAgICAgIF07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRIYXNoZXModmFsdWUsIHBhcmFtKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSksIGBpbnZhbGlkICR7cGFyYW19YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZVtpXSwgMzIpLCBcImludmFsaWQgJHsgcGFyYW0gfSBoYXNoXCIsIGB2YWx1ZVske2l9XWAsIHZhbHVlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3BhcnNlTGVnYWN5KGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZGF0YSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA5IHx8IGZpZWxkcy5sZW5ndGggPT09IDYpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvblwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDAsXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzBdLCBcIm5vbmNlXCIpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlVWludChmaWVsZHNbMV0sIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzNdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s1XSksXG4gICAgICAgIGNoYWluSWQ6IEJOXzBcbiAgICB9O1xuICAgIC8vIExlZ2FjeSB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgY29uc3QgdiA9IGhhbmRsZVVpbnQoZmllbGRzWzZdLCBcInZcIik7XG4gICAgY29uc3QgciA9IGhhbmRsZVVpbnQoZmllbGRzWzddLCBcInJcIik7XG4gICAgY29uc3QgcyA9IGhhbmRsZVVpbnQoZmllbGRzWzhdLCBcInNcIik7XG4gICAgaWYgKHIgPT09IEJOXzAgJiYgcyA9PT0gQk5fMCkge1xuICAgICAgICAvLyBFSVAtMTU1IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgICAgIHR4LmNoYWluSWQgPSB2O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgRUlQLTE1NSBjaGFpbiBJRCAob3IgMCBmb3IgbGVnYWN5KVxuICAgICAgICBsZXQgY2hhaW5JZCA9ICh2IC0gQk5fMzUpIC8gQk5fMjtcbiAgICAgICAgaWYgKGNoYWluSWQgPCBCTl8wKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICB0eC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgLy8gU2lnbmVkIExlZ2FjeSBUcmFuc2FjdGlvblxuICAgICAgICBhc3NlcnRBcmd1bWVudChjaGFpbklkICE9PSBCTl8wIHx8ICh2ID09PSBCTl8yNyB8fCB2ID09PSBCTl8yOCksIFwibm9uLWNhbm9uaWNhbCBsZWdhY3kgdlwiLCBcInZcIiwgZmllbGRzWzZdKTtcbiAgICAgICAgdHguc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xuICAgICAgICAgICAgcjogemVyb1BhZFZhbHVlKGZpZWxkc1s3XSwgMzIpLFxuICAgICAgICAgICAgczogemVyb1BhZFZhbHVlKGZpZWxkc1s4XSwgMzIpLFxuICAgICAgICAgICAgdlxuICAgICAgICB9KTtcbiAgICAgICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplTGVnYWN5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICBdO1xuICAgIGxldCBjaGFpbklkID0gQk5fMDtcbiAgICBpZiAodHguY2hhaW5JZCAhPSBCTl8wKSB7XG4gICAgICAgIC8vIEEgY2hhaW5JZCB3YXMgcHJvdmlkZWQ7IGlmIG5vbi16ZXJvIHdlJ2xsIHVzZSBFSVAtMTU1XG4gICAgICAgIGNoYWluSWQgPSBnZXRCaWdJbnQodHguY2hhaW5JZCwgXCJ0eC5jaGFpbklkXCIpO1xuICAgICAgICAvLyBXZSBoYXZlIGEgY2hhaW5JZCBpbiB0aGUgdHggYW5kIGFuIEVJUC0xNTUgdiBpbiB0aGUgc2lnbmF0dXJlLFxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhleSBhZ3JlZSB3aXRoIGVhY2ggb3RoZXJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXNpZyB8fCBzaWcubmV0d29ya1YgPT0gbnVsbCB8fCBzaWcubGVnYWN5Q2hhaW5JZCA9PT0gY2hhaW5JZCwgXCJ0eC5jaGFpbklkL3NpZy52IG1pc21hdGNoXCIsIFwic2lnXCIsIHNpZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR4LnNpZ25hdHVyZSkge1xuICAgICAgICAvLyBObyBleHBsaWNpdCBjaGFpbklkLCBidXQgRUlQLTE1NSBoYXZlIGEgZGVyaXZlZCBpbXBsaWNpdCBjaGFpbklkXG4gICAgICAgIGNvbnN0IGxlZ2FjeSA9IHR4LnNpZ25hdHVyZS5sZWdhY3lDaGFpbklkO1xuICAgICAgICBpZiAobGVnYWN5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBsZWdhY3k7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVxdWVzdGluZyBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgIGlmICghc2lnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcbiAgICAgICAgaWYgKGNoYWluSWQgIT09IEJOXzApIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShjaGFpbklkKSk7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xuICAgICAgICAgICAgZmllbGRzLnB1c2goXCIweFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlUmxwKGZpZWxkcyk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgY2hlY2sgdGhhdCB0eC5zaWduYXR1cmUsIGNoYWluSWQsIGFuZCBzaWdcbiAgICAvLyAgICAgICAgbWF0Y2ggYnV0IHRoYXQgbG9naWMgY291bGQgYnJlYWsgZXhpc3RpbmcgY29kZSwgc28gc2NoZWR1bGVcbiAgICAvLyAgICAgICAgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgYnVtcC5cbiAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IHZcbiAgICBsZXQgdiA9IEJpZ0ludCgyNyArIHNpZy55UGFyaXR5KTtcbiAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xuICAgICAgICB2ID0gU2lnbmF0dXJlLmdldENoYWluSWRWKGNoYWluSWQsIHNpZy52KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQmlnSW50KHNpZy52KSAhPT0gdikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ0eC5jaGFpbklkL3NpZy52IG1pc21hdGNoXCIsIFwic2lnXCIsIHNpZyk7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgc2lnbmF0dXJlXG4gICAgZmllbGRzLnB1c2godG9CZUFycmF5KHYpKTtcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICByZXR1cm4gZW5jb2RlUmxwKGZpZWxkcyk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcykge1xuICAgIGxldCB5UGFyaXR5O1xuICAgIHRyeSB7XG4gICAgICAgIHlQYXJpdHkgPSBoYW5kbGVOdW1iZXIoZmllbGRzWzBdLCBcInlQYXJpdHlcIik7XG4gICAgICAgIGlmICh5UGFyaXR5ICE9PSAwICYmIHlQYXJpdHkgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCB5UGFyaXR5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHlQYXJpdHlcIiwgXCJ5UGFyaXR5XCIsIGZpZWxkc1swXSk7XG4gICAgfVxuICAgIGNvbnN0IHIgPSB6ZXJvUGFkVmFsdWUoZmllbGRzWzFdLCAzMik7XG4gICAgY29uc3QgcyA9IHplcm9QYWRWYWx1ZShmaWVsZHNbMl0sIDMyKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7IHIsIHMsIHlQYXJpdHkgfSk7XG4gICAgdHguc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMTU1OShkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDkgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTIpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDJcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAyLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzZdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s3XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzhdLCBcImFjY2Vzc0xpc3RcIiksXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMTU1OSBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDkpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMTU1OSh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMlwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMjkzMChkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDggfHwgZmllbGRzLmxlbmd0aCA9PT0gMTEpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbM10sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s1XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbNl0pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s3XSwgXCJhY2Nlc3NMaXN0XCIpXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMjkzMCBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDgpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNQcmljZSB8fCAwLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMVwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwNDg0NChkYXRhKSB7XG4gICAgbGV0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgbGV0IHR5cGVOYW1lID0gXCIzXCI7XG4gICAgbGV0IGJsb2JzID0gbnVsbDtcbiAgICAvLyBQYXJzZSB0aGUgbmV0d29yayBmb3JtYXRcbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gNCAmJiBBcnJheS5pc0FycmF5KGZpZWxkc1swXSkpIHtcbiAgICAgICAgdHlwZU5hbWUgPSBcIjMgKG5ldHdvcmsgZm9ybWF0KVwiO1xuICAgICAgICBjb25zdCBmQmxvYnMgPSBmaWVsZHNbMV0sIGZDb21taXRzID0gZmllbGRzWzJdLCBmUHJvb2ZzID0gZmllbGRzWzNdO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZCbG9icyksIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogYmxvYnMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzFdXCIsIGZCbG9icyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZkNvbW1pdHMpLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGNvbW1pdG1lbnRzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1syXVwiLCBmQ29tbWl0cyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZlByb29mcyksIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogcHJvb2ZzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1szXVwiLCBmUHJvb2ZzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZkJsb2JzLmxlbmd0aCA9PT0gZkNvbW1pdHMubGVuZ3RoLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGJsb2JzL2NvbW1pdG1lbnRzIGxlbmd0aCBtaXNtYXRjaFwiLCBcImZpZWxkc1wiLCBmaWVsZHMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmQmxvYnMubGVuZ3RoID09PSBmUHJvb2ZzLmxlbmd0aCwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBibG9icy9wcm9vZnMgbGVuZ3RoIG1pc21hdGNoXCIsIFwiZmllbGRzXCIsIGZpZWxkcyk7XG4gICAgICAgIGJsb2JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzWzFdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBibG9icy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBmQmxvYnNbaV0sXG4gICAgICAgICAgICAgICAgY29tbWl0bWVudDogZkNvbW1pdHNbaV0sXG4gICAgICAgICAgICAgICAgcHJvb2Y6IGZQcm9vZnNbaV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMgPSBmaWVsZHNbMF07XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gMTEgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTQpLCBgaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogJHt0eXBlTmFtZX1gLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDMsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbMl0sIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICAgICAgbWF4RmVlUGVyQmxvYkdhczogaGFuZGxlVWludChmaWVsZHNbOV0sIFwibWF4RmVlUGVyQmxvYkdhc1wiKSxcbiAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlczogZmllbGRzWzEwXVxuICAgIH07XG4gICAgaWYgKGJsb2JzKSB7XG4gICAgICAgIHR4LmJsb2JzID0gYmxvYnM7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KHR4LnRvICE9IG51bGwsIGBpbnZhbGlkIGFkZHJlc3MgZm9yIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHlwZU5hbWV9YCwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkodHguYmxvYlZlcnNpb25lZEhhc2hlcyksIFwiaW52YWxpZCBibG9iVmVyc2lvbmVkSGFzaGVzOiBtdXN0IGJlIGFuIGFycmF5XCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodHguYmxvYlZlcnNpb25lZEhhc2hlc1tpXSwgMzIpLCBgaW52YWxpZCBibG9iVmVyc2lvbmVkSGFzaCBhdCBpbmRleCAke2l9OiBtdXN0IGJlIGxlbmd0aCAzMmAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICB9XG4gICAgLy8gVW5zaWduZWQgRUlQLTQ4NDQgVHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMTEpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvLyBAVE9ETzogRG8gd2UgbmVlZCB0byBkbyB0aGlzPyBUaGlzIGlzIG9ubHkgY2FsbGVkIGludGVybmFsbHlcbiAgICAvLyBhbmQgdXNlZCB0byB2ZXJpZnkgaGFzaGVzOyBpdCBtaWdodCBzYXZlIHRpbWUgdG8gbm90IGRvIHRoaXNcbiAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoY29uY2F0KFsgXCIweDAzXCIsIGVuY29kZVJscChmaWVsZHMpIF0pKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSgxMSkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXA0ODQ0KHR4LCBzaWcsIGJsb2JzKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBaZXJvQWRkcmVzcyksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckJsb2JHYXMgfHwgMCwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpLFxuICAgICAgICBmb3JtYXRIYXNoZXModHguYmxvYlZlcnNpb25lZEhhc2hlcyB8fCBbXSwgXCJibG9iVmVyc2lvbmVkSGFzaGVzXCIpXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJ5UGFyaXR5XCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgICAgICAvLyBXZSBoYXZlIGJsb2JzOyByZXR1cm4gdGhlIG5ldHdvcmsgd3JhcHBlZCBmb3JtYXRcbiAgICAgICAgaWYgKGJsb2JzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgICAgICBcIjB4MDNcIixcbiAgICAgICAgICAgICAgICBlbmNvZGVSbHAoW1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIGJsb2JzLm1hcCgoYikgPT4gYi5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgYmxvYnMubWFwKChiKSA9PiBiLmNvbW1pdG1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIucHJvb2YpLFxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDNcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDc3MDIoZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSAxMCB8fCBmaWVsZHMubGVuZ3RoID09PSAxMyksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogNFwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDQsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbMl0sIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICAgICAgYXV0aG9yaXphdGlvbkxpc3Q6IGhhbmRsZUF1dGhvcml6YXRpb25MaXN0KGZpZWxkc1s5XSwgXCJhdXRob3JpemF0aW9uTGlzdFwiKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC03NzAyIFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoMTApKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwNzcwMih0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSksXG4gICAgICAgIGZvcm1hdEF1dGhvcml6YXRpb25MaXN0KHR4LmF1dGhvcml6YXRpb25MaXN0IHx8IFtdKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDA0XCIsIGVuY29kZVJscChmaWVsZHMpXSk7XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb24qKiBkZXNjcmliZXMgYW4gb3BlcmF0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uXG4gKiAgRXRoZXJldW0gYnkgYW4gRXh0ZXJuYWxseSBPd25lZCBBY2NvdW50IChFT0EpLiBJdCBpbmNsdWRlc1xuICogIHdobyAodGhlIFtbdG9dXSBhZGRyZXNzKSwgd2hhdCAodGhlIFtbZGF0YV1dKSBhbmQgaG93IG11Y2ggKHRoZVxuICogIFtbdmFsdWVdXSBpbiBldGhlcikgdGhlIG9wZXJhdGlvbiBzaG91bGQgZW50YWlsLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHR4ID0gbmV3IFRyYW5zYWN0aW9uKClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICB0eC5kYXRhID0gXCIweDEyMzRcIjtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICAjdHlwZTtcbiAgICAjdG87XG4gICAgI2RhdGE7XG4gICAgI25vbmNlO1xuICAgICNnYXNMaW1pdDtcbiAgICAjZ2FzUHJpY2U7XG4gICAgI21heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICNtYXhGZWVQZXJHYXM7XG4gICAgI3ZhbHVlO1xuICAgICNjaGFpbklkO1xuICAgICNzaWc7XG4gICAgI2FjY2Vzc0xpc3Q7XG4gICAgI21heEZlZVBlckJsb2JHYXM7XG4gICAgI2Jsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgI2t6ZztcbiAgICAjYmxvYnM7XG4gICAgI2F1dGhzO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKlxuICAgICAqICBJZiBudWxsLCB0aGUgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgYmFzZWQgb25cbiAgICAgKiAgZXhwbGljaXQgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuI3R5cGU7IH1cbiAgICBzZXQgdHlwZSh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIFwibGVnYWN5XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiYmVybGluXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTI5MzBcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJsb25kb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtMTU1OVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FzZSBcImNhbmN1blwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC00ODQ0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBjYXNlIFwicGVjdHJhXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTc3MDJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcInR5cGVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBcImxlZ2FjeVwiO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gXCJlaXAtMjkzMFwiO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gXCJlaXAtMTU1OVwiO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gXCJlaXAtNDg0NFwiO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gXCJlaXAtNzcwMlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdG9gYCBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb24gb3IgYGBudWxsYGAgaWYgdGhlXG4gICAgICogIHRyYW5zYWN0aW9uIGlzIGFuIGBgaW5pdGBgIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB0bygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiN0bztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gWmVyb0FkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgdG8odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdG8gPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gbm9uY2UuXG4gICAgICovXG4gICAgZ2V0IG5vbmNlKCkgeyByZXR1cm4gdGhpcy4jbm9uY2U7IH1cbiAgICBzZXQgbm9uY2UodmFsdWUpIHsgdGhpcy4jbm9uY2UgPSBnZXROdW1iZXIodmFsdWUsIFwidmFsdWVcIik7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBsaW1pdC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzTGltaXQoKSB7IHJldHVybiB0aGlzLiNnYXNMaW1pdDsgfVxuICAgIHNldCBnYXNMaW1pdCh2YWx1ZSkgeyB0aGlzLiNnYXNMaW1pdCA9IGdldEJpZ0ludCh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MgdGhpcyBkZWZpbmVzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIHBhaWQuIE9uXG4gICAgICogIEVJUC0xNTU5IG5ldHdvcmtzLCB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzUHJpY2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZ2FzUHJpY2U7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICh0aGlzLnR5cGUgPT09IDAgfHwgdGhpcy50eXBlID09PSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgZ2FzUHJpY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcImdhc1ByaWNlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIHBlciB1bml0IG9mIGdhcyB0byBwYXkuIE9uIGxlZ2FjeVxuICAgICAqICBuZXR3b3JrcyB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAyIHx8IHRoaXMudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gdG90YWwgZmVlIHBlciB1bml0IG9mIGdhcyB0byBwYXkuIE9uIGxlZ2FjeVxuICAgICAqICBuZXR3b3JrcyB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbWF4RmVlUGVyR2FzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heEZlZVBlckdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhGZWVQZXJHYXModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEJpZ0ludCh2YWx1ZSwgXCJtYXhGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gZGF0YS4gRm9yIGBgaW5pdGBgIHRyYW5zYWN0aW9ucyB0aGlzIGlzIHRoZVxuICAgICAqICBkZXBsb3ltZW50IGNvZGUuXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiB0aGlzLiNkYXRhOyB9XG4gICAgc2V0IGRhdGEodmFsdWUpIHsgdGhpcy4jZGF0YSA9IGhleGxpZnkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBhbW91bnQgb2YgZXRoZXIgKGluIHdlaSkgdG8gc2VuZCBpbiB0aGlzIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLiN2YWx1ZTsgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiN2YWx1ZSA9IGdldEJpZ0ludCh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCB0aGlzIHRyYW5zYWN0aW9uIGlzIHZhbGlkIG9uLlxuICAgICAqL1xuICAgIGdldCBjaGFpbklkKCkgeyByZXR1cm4gdGhpcy4jY2hhaW5JZDsgfVxuICAgIHNldCBjaGFpbklkKHZhbHVlKSB7IHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIElmIHNpZ25lZCwgdGhlIHNpZ25hdHVyZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmF0dXJlKCkgeyByZXR1cm4gdGhpcy4jc2lnIHx8IG51bGw7IH1cbiAgICBzZXQgc2lnbmF0dXJlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3NpZyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBTaWduYXR1cmUuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYWNjZXNzIGxpc3QuXG4gICAgICpcbiAgICAgKiAgQW4gYWNjZXNzIGxpc3QgcGVybWl0cyBkaXNjb3VudGVkIChidXQgcHJlLXBhaWQpIGFjY2VzcyB0b1xuICAgICAqICBieXRlY29kZSBhbmQgc3RhdGUgdmFyaWFibGUgYWNjZXNzIHdpdGhpbiBjb250cmFjdCBleGVjdXRpb24uXG4gICAgICovXG4gICAgZ2V0IGFjY2Vzc0xpc3QoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jYWNjZXNzTGlzdCB8fCBudWxsO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMSB8fCB0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IGluIHY3LCB0aGlzIHNob3VsZCBhc3NpZ24gdGhlIHZhbHVlIG9yIGJlY29tZVxuICAgICAgICAgICAgICAgIC8vIGEgbGl2ZSBvYmplY3QgaXRzZWxmLCBvdGhlcndpc2UgbXV0YXRpb24gaXMgaW5jb25zaXN0ZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNhY2Nlc3NMaXN0ID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGFjY2Vzc0xpc3RpZnkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgYXV0aG9yaXphdGlvbkxpc3QoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jYXV0aHMgfHwgbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaW4gdjcsIHRoaXMgc2hvdWxkIGJlY29tZSBhIGxpdmUgb2JqZWN0IGl0c2VsZixcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgbXV0YXRpb24gaXMgaW5jb25zaXN0ZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGF1dGhvcml6YXRpb25MaXN0KGF1dGhzKSB7XG4gICAgICAgIHRoaXMuI2F1dGhzID0gKGF1dGhzID09IG51bGwpID8gbnVsbCA6IGF1dGhzLm1hcCgoYSkgPT4gYXV0aG9yaXphdGlvbmlmeShhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4IGZlZSBwZXIgYmxvYiBnYXMgZm9yIENhbmN1biB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IG1heEZlZVBlckJsb2JHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyQmxvYkdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhGZWVQZXJCbG9iR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckJsb2JHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heEZlZVBlckJsb2JHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQkxPYiB2ZXJzaW9uZWQgaGFzaGVzIGZvciBDYW5jdW4gdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldCBibG9iVmVyc2lvbmVkSGFzaGVzKCkge1xuICAgICAgICAvLyBAVE9ETzogTXV0YXRpb24gaXMgaW5jb25zaXN0ZW50OyBpZiB1bnNldCwgdGhlIHJldHVybmVkIHZhbHVlXG4gICAgICAgIC8vIGNhbm5vdCBtdXRhdGUgdGhlIG9iamVjdCwgaWYgc2V0IGl0IGNhblxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBibG9iVmVyc2lvbmVkSGFzaGVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KHZhbHVlKSwgXCJibG9iVmVyc2lvbmVkSGFzaGVzIG11c3QgYmUgYW4gQXJyYXlcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWVbaV0sIDMyKSwgXCJpbnZhbGlkIGJsb2JWZXJzaW9uZWRIYXNoXCIsIGB2YWx1ZVske2l9XWAsIHZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQkxPYnMgZm9yIHRoZSBUcmFuc2FjdGlvbiwgaWYgYW55LlxuICAgICAqXG4gICAgICogIElmIGBgYmxvYnNgYCBpcyBub24tYGBudWxsYGAsIHRoZW4gdGhlIFtbc2VyaWFpbGl6ZWRdXVxuICAgICAqICB3aWxsIHJldHVybiB0aGUgbmV0d29yayBmb3JtYXR0ZWQgc2lkZWNhciwgb3RoZXJ3aXNlIGl0XG4gICAgICogIHdpbGwgcmV0dXJuIHRoZSBzdGFuZGFyZCBbW2xpbmstZWlwLTI3MThdXSBwYXlsb2FkLiBUaGVcbiAgICAgKiAgW1t1bnNpZ25lZFNlcmlhbGl6ZWRdXSBpcyB1bmFmZmVjdGVkIHJlZ2FyZGxlc3MuXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGBgYmxvYnNgYCwgZWl0aGVyIGZ1bGx5IHZhbGlkIFtbQmxvYl1dIG9iamVjdHNcbiAgICAgKiAgbWF5IGJlIHNwZWNpZmllZCAoaS5lLiBjb3JyZWN0bHkgcGFkZGVkLCB3aXRoIGNvcnJlY3RcbiAgICAgKiAgY29tbWl0dG1lbnRzIGFuZCBwcm9vZnMpIG9yIGEgcmF3IFtbQnl0ZXNMaWtlXV0gbWF5XG4gICAgICogIGJlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogIElmIHJhdyBbW0J5dGVzTGlrZV1dIGFyZSBwcm92aWRlZCwgdGhlIFtba3pnXV0gcHJvcGVydHkgKiptdXN0KipcbiAgICAgKiAgYmUgYWxyZWFkeSBzZXQuIFRoZSBibG9iIHdpbGwgYmUgY29ycmVjdGx5IHBhZGRlZCBhbmQgdGhlXG4gICAgICogIFtbS3pnTGlicmFyeV1dIHdpbGwgYmUgdXNlZCB0byBjb21wdXRlIHRoZSBjb21taXR0bWVudCBhbmRcbiAgICAgKiAgcHJvb2YgZm9yIHRoZSBibG9iLlxuICAgICAqXG4gICAgICogIEEgQkxPYiBpcyBhIHNlcXVlbmNlIG9mIGZpZWxkIGVsZW1lbnRzLCBlYWNoIG9mIHdoaWNoIG11c3RcbiAgICAgKiAgYmUgd2l0aGluIHRoZSBCTFMgZmllbGQgbW9kdWxvLCBzbyBzb21lIGFkZGl0aW9uYWwgcHJvY2Vzc2luZ1xuICAgICAqICBtYXkgYmUgcmVxdWlyZWQgdG8gZW5jb2RlIGFyYml0cmFyeSBkYXRhIHRvIGVuc3VyZSBlYWNoIDMyIGJ5dGVcbiAgICAgKiAgZmllbGQgaXMgd2l0aGluIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIHRoaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZXMgW1tibG9iVmVyc2lvbmVkSGFzaGVzXV0sXG4gICAgICogIG92ZXJ3cml0aW5nIGFueSBleGlzdGluZyB2YWx1ZXMuIFNldHRpbmcgdGhpcyB0byBgYG51bGxgYFxuICAgICAqICBkb2VzICoqbm90KiogcmVtb3ZlIHRoZSBbW2Jsb2JWZXJzaW9uZWRIYXNoZXNdXSwgbGVhdmluZyB0aGVtXG4gICAgICogIHByZXNlbnQuXG4gICAgICovXG4gICAgZ2V0IGJsb2JzKCkge1xuICAgICAgICBpZiAodGhpcy4jYmxvYnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jsb2JzLm1hcCgoYikgPT4gT2JqZWN0LmFzc2lnbih7fSwgYikpO1xuICAgIH1cbiAgICBzZXQgYmxvYnMoX2Jsb2JzKSB7XG4gICAgICAgIGlmIChfYmxvYnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvYnMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2JzID0gW107XG4gICAgICAgIGNvbnN0IHZlcnNpb25lZEhhc2hlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9ibG9icy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IF9ibG9ic1tpXTtcbiAgICAgICAgICAgIGlmIChpc0J5dGVzTGlrZShibG9iKSkge1xuICAgICAgICAgICAgICAgIGFzc2VydCh0aGlzLiNremcsIFwiYWRkaW5nIGEgcmF3IGJsb2IgcmVxdWlyZXMgYSBLWkcgbGlicmFyeVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXQgYmxvYnMoKVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBnZXRCeXRlcyhibG9iKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhLmxlbmd0aCA8PSBCTE9CX1NJWkUsIFwiYmxvYiBpcyB0b28gbGFyZ2VcIiwgYGJsb2JzWyR7aX1dYCwgYmxvYik7XG4gICAgICAgICAgICAgICAgLy8gUGFkIGJsb2IgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBCTE9CX1NJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoQkxPQl9TSVpFKTtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGVkLnNldChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBhZGRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWl0ID0gdGhpcy4ja3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvb2YgPSBoZXhsaWZ5KHRoaXMuI2t6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKGRhdGEsIGNvbW1pdCkpO1xuICAgICAgICAgICAgICAgIGJsb2JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhsaWZ5KGRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBoZXhsaWZ5KGNvbW1pdCksXG4gICAgICAgICAgICAgICAgICAgIHByb29mXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbmVkSGFzaGVzLnB1c2goZ2V0VmVyc2lvbmVkSGFzaCgxLCBjb21taXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1pdCA9IGhleGxpZnkoYmxvYi5jb21taXRtZW50KTtcbiAgICAgICAgICAgICAgICBibG9icy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4bGlmeShibG9iLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBjb21taXQsXG4gICAgICAgICAgICAgICAgICAgIHByb29mOiBoZXhsaWZ5KGJsb2IucHJvb2YpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbmVkSGFzaGVzLnB1c2goZ2V0VmVyc2lvbmVkSGFzaCgxLCBjb21taXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNibG9icyA9IGJsb2JzO1xuICAgICAgICB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzID0gdmVyc2lvbmVkSGFzaGVzO1xuICAgIH1cbiAgICBnZXQga3pnKCkgeyByZXR1cm4gdGhpcy4ja3pnOyB9XG4gICAgc2V0IGt6ZyhremcpIHtcbiAgICAgICAgaWYgKGt6ZyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNremcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4ja3pnID0gZ2V0S3pnTGlicmFyeShremcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFRyYW5zYWN0aW9uIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI3R5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLiN0byA9IG51bGw7XG4gICAgICAgIHRoaXMuI25vbmNlID0gMDtcbiAgICAgICAgdGhpcy4jZ2FzTGltaXQgPSBCTl8wO1xuICAgICAgICB0aGlzLiNnYXNQcmljZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGF0YSA9IFwiMHhcIjtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBCTl8wO1xuICAgICAgICB0aGlzLiNjaGFpbklkID0gQk5fMDtcbiAgICAgICAgdGhpcy4jc2lnID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYWNjZXNzTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckJsb2JHYXMgPSBudWxsO1xuICAgICAgICB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy4ja3pnID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYmxvYnMgPSBudWxsO1xuICAgICAgICB0aGlzLiNhdXRocyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaCwgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBoYXNoKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLiNnZXRTZXJpYWxpemVkKHRydWUsIGZhbHNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJlLWltYWdlIGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHRoZSBkaWdlc3QgdGhhdCBhIFtbU2lnbmVyXV0gbXVzdCBzaWduIHRvIGF1dGhvcml6ZVxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB1bnNpZ25lZEhhc2goKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy51bnNpZ25lZFNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRpbmcgYWRkcmVzcywgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBmcm9tKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHVibGljIGtleSBvZiB0aGUgc2VuZGVyLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGZyb21QdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgc2lnbmVkLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgcHJvcGVydGllcyByZXF1aXJpbmcgYSBzaWduZWRcbiAgICAgKiAgdHJhbnNhY3Rpb24gYXJlIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzU2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmUgIT0gbnVsbDtcbiAgICB9XG4gICAgI2dldFNlcmlhbGl6ZWQoc2lnbmVkLCBzaWRlY2FyKSB7XG4gICAgICAgIGFzc2VydCghc2lnbmVkIHx8IHRoaXMuc2lnbmF0dXJlICE9IG51bGwsIFwiY2Fubm90IHNlcmlhbGl6ZSB1bnNpZ25lZCB0cmFuc2FjdGlvbjsgbWF5YmUgeW91IG1lYW50IC51bnNpZ25lZFNlcmlhbGl6ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcbiAgICAgICAgY29uc3Qgc2lnID0gc2lnbmVkID8gdGhpcy5zaWduYXR1cmUgOiBudWxsO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5mZXJUeXBlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUxlZ2FjeSh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMjkzMCh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwNDg0NCh0aGlzLCBzaWcsIHNpZGVjYXIgPyB0aGlzLmJsb2JzIDogbnVsbCk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXA3NzAyKHRoaXMsIHNpZyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgdGhyb3dzIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyB1bnNpZ25lZC4gRm9yIHRoZSBwcmUtaW1hZ2UsXG4gICAgICogIHVzZSBbW3Vuc2lnbmVkU2VyaWFsaXplZF1dLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0U2VyaWFsaXplZCh0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UuXG4gICAgICpcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhpcyBpcyB0aGUgZGlnZXN0IHdoaWNoIG5lZWRzIHRvIGJlIHNpZ25lZCB0b1xuICAgICAqICBhdXRob3JpemUgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgdW5zaWduZWRTZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0U2VyaWFsaXplZChmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBtb3N0IFwibGlrZWx5XCIgdHlwZTsgY3VycmVudGx5IHRoZSBoaWdoZXN0XG4gICAgICogIHN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIGluZmVyVHlwZSgpIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSB0aGlzLmluZmVyVHlwZXMoKTtcbiAgICAgICAgLy8gUHJlZmVyIExvbmRvbiAoRUlQLTE1NTkpIG92ZXIgQ2FuY3VuIChCTE9iKVxuICAgICAgICBpZiAodHlwZXMuaW5kZXhPZigyKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIGhpZ2hlc3QgaW5mZXJyZWQgdHlwZVxuICAgICAgICByZXR1cm4gKHR5cGVzLnBvcCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFZhbGlkYXRlcyB0aGUgZXhwbGljaXQgcHJvcGVydGllcyBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgY29tcGF0aWJsZVxuICAgICAqICB0cmFuc2FjdGlvbiB0eXBlcy5cbiAgICAgKi9cbiAgICBpbmZlclR5cGVzKCkge1xuICAgICAgICAvLyBDaGVja3MgdGhhdCB0aGVyZSBhcmUgbm8gY29uZmxpY3RpbmcgcHJvcGVydGllcyBzZXRcbiAgICAgICAgY29uc3QgaGFzR2FzUHJpY2UgPSB0aGlzLmdhc1ByaWNlICE9IG51bGw7XG4gICAgICAgIGNvbnN0IGhhc0ZlZSA9ICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IGhhc0FjY2Vzc0xpc3QgPSAodGhpcy5hY2Nlc3NMaXN0ICE9IG51bGwpO1xuICAgICAgICBjb25zdCBoYXNCbG9iID0gKHRoaXMuI21heEZlZVBlckJsb2JHYXMgIT0gbnVsbCB8fCB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzKTtcbiAgICAgICAgLy9pZiAoaGFzR2FzUHJpY2UgJiYgaGFzRmVlKSB7XG4gICAgICAgIC8vICAgIHRocm93IG5ldyBFcnJvcihcInRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGdhc1ByaWNlIGFuZCBtYXhGZWVQZXJHYXNcIik7XG4gICAgICAgIC8vfVxuICAgICAgICBpZiAodGhpcy5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLm1heEZlZVBlckdhcyA+PSB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzLCBcInByaW9yaXR5RmVlIGNhbm5vdCBiZSBtb3JlIHRoYW4gbWF4RmVlXCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL2lmICh0aGlzLnR5cGUgPT09IDIgJiYgaGFzR2FzUHJpY2UpIHtcbiAgICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgZ2FzUHJpY2VcIik7XG4gICAgICAgIC8vfVxuICAgICAgICBhc3NlcnQoIWhhc0ZlZSB8fCAodGhpcy50eXBlICE9PSAwICYmIHRoaXMudHlwZSAhPT0gMSksIFwidHJhbnNhY3Rpb24gdHlwZSBjYW5ub3QgaGF2ZSBtYXhGZWVQZXJHYXMgb3IgbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICBhc3NlcnQodGhpcy50eXBlICE9PSAwIHx8ICFoYXNBY2Nlc3NMaXN0LCBcImxlZ2FjeSB0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBhY2Nlc3NMaXN0XCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgLy8gRXhwbGljaXQgdHlwZVxuICAgICAgICBpZiAodGhpcy50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR5cGVzLnB1c2godGhpcy50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dGhvcml6YXRpb25MaXN0ICYmIHRoaXMuYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCg0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0ZlZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNHYXNQcmljZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0Jsb2IgJiYgdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDApO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHR5cGVzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYSBsZWdhY3kgdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGJlcmxpbiBoYXJkZm9ybSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDFgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0JlcmxpbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgbG9uZG9uIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMmBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhbiBbW2xpbmstZWlwLTQ4NDRdXSBCTE9CXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNDYW5jdW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyB0cmFuc2FjaXRvbi5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20odGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBKU09OLWZyaWVuZGx5IG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHMgPSAodikgPT4ge1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBzKHRoaXMuZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHModGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcyh0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogcyh0aGlzLm1heEZlZVBlckdhcyksXG4gICAgICAgICAgICB2YWx1ZTogcyh0aGlzLnZhbHVlKSxcbiAgICAgICAgICAgIGNoYWluSWQ6IHModGhpcy5jaGFpbklkKSxcbiAgICAgICAgICAgIHNpZzogdGhpcy5zaWduYXR1cmUgPyB0aGlzLnNpZ25hdHVyZS50b0pTT04oKSA6IG51bGwsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiB0aGlzLmFjY2Vzc0xpc3RcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhICoqVHJhbnNhY3Rpb24qKiBmcm9tIGEgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBvciBhXG4gICAgICogIFRyYW5zYWN0aW9uLWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR4KSB7XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZ2V0Qnl0ZXModHgpO1xuICAgICAgICAgICAgaWYgKHBheWxvYWRbMF0gPj0gMHg3ZikgeyAvLyBAVE9ETzogPiB2cyA+PSA/P1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUxlZ2FjeShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDI5MzAocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMTU1OShwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXA0ODQ0KHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDc3MDIocGF5bG9hZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZnJvbVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAodHgudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IHR4LnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50byA9IHR4LnRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ub25jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubm9uY2UgPSB0eC5ub25jZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzTGltaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc0xpbWl0ID0gdHguZ2FzTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB0eC5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhGZWVQZXJHYXMgPSB0eC5tYXhGZWVQZXJHYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heEZlZVBlckJsb2JHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckJsb2JHYXMgPSB0eC5tYXhGZWVQZXJCbG9iR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gdHguZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gdHgudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSB0eC5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5zaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHR4LnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSB0eC5hY2Nlc3NMaXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hdXRob3JpemF0aW9uTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYXV0aG9yaXphdGlvbkxpc3QgPSB0eC5hdXRob3JpemF0aW9uTGlzdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHdpbGwgZ2V0IG92ZXJ3cml0dGVuIGJ5IGJsb2JzLCBpZiBwcmVzZW50XG4gICAgICAgIGlmICh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaGVzID0gdHguYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXNzaWduIHRoZSBremcgYmVmb3JlIGFzc2lnbmluZyBibG9icywgd2hpY2hcbiAgICAgICAgLy8gcmVxdWlyZSB0aGUgbGlicmFyeSBpbiB0aGUgZXZlbnQgcmF3IGJsb2IgZGF0YSBpcyBwcm92aWRlZC5cbiAgICAgICAgaWYgKHR4Lmt6ZyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQua3pnID0gdHgua3pnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ibG9icyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYmxvYnMgPSB0eC5ibG9icztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguaGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lICcuaGFzaCdcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaGFzaCA9PT0gdHguaGFzaCwgXCJoYXNoIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgJy5mcm9tJ1wiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5mcm9tLnRvTG93ZXJDYXNlKCkgPT09ICh0eC5mcm9tIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcCIsImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBjb25jYXQsIGVuY29kZVJscCwgdG9CZUFycmF5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBDb21wdXRlcyB0aGUgW1tsaW5rLWVpcC03NzAyXV0gYXV0aG9yaXphdGlvbiBkaWdlc3QgdG8gc2lnbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hBdXRob3JpemF0aW9uKGF1dGgpIHtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKGF1dGguYWRkcmVzcykgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBhZGRyZXNzIGZvciBoYXNoQXV0aG9yaXphdGlvblwiLCBcImF1dGguYWRkcmVzc1wiLCBhdXRoKTtcbiAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChbXG4gICAgICAgIFwiMHgwNVwiLCBlbmNvZGVSbHAoW1xuICAgICAgICAgICAgKGF1dGguY2hhaW5JZCAhPSBudWxsKSA/IHRvQmVBcnJheShhdXRoLmNoYWluSWQpIDogXCIweFwiLFxuICAgICAgICAgICAgZ2V0QWRkcmVzcyhhdXRoLmFkZHJlc3MpLFxuICAgICAgICAgICAgKGF1dGgubm9uY2UgIT0gbnVsbCkgPyB0b0JlQXJyYXkoYXV0aC5ub25jZSkgOiBcIjB4XCIsXG4gICAgICAgIF0pXG4gICAgXSkpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBhZGRyZXNzIG9mIHRoZSBwcml2YXRlIGtleSB0aGF0IHByb2R1Y2VkXG4gKiAgdGhlIHNpZ25hdHVyZSAlJXNpZyUlIGR1cmluZyBzaWduaW5nIGZvciAlJW1lc3NhZ2UlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeUF1dGhvcml6YXRpb24oYXV0aCwgc2lnKSB7XG4gICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKGhhc2hBdXRob3JpemF0aW9uKGF1dGgpLCBzaWcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aG9yaXphdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQSBzaW1wbGUgaGFzaGluZyBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiBVVEYtOCBzdHJpbmdzIHRvXG4gKiAgY29tcHV0ZSBhbiAzMi1ieXRlIGlkZW50aWZpZXIuXG4gKlxuICogIFRoaXMgc2ltcGx5IGNvbXB1dGVzIHRoZSBbVVRGLTggYnl0ZXNdKHRvVXRmOEJ5dGVzKSBhbmQgY29tcHV0ZXNcbiAqICB0aGUgW1trZWNjYWsyNTZdXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBpZChcImhlbGxvIHdvcmxkXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZCh2YWx1ZSkge1xuICAgIHJldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModmFsdWUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIi8vIGNyZWF0ZWQgMjAyMy0wOS0yNVQwMTowMTo1NS4xNDhaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtZW5zIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogMDU2NWVkMDQ5YjljZjE2MTRiYjllMTFiYTdkOGFjNmE2ZmI5NmM4OTMyNTNkODkwZjdlMmIyODg0YjlkZWQzMlxudmFyIENPTVBSRVNTRUQkMSA9ICdBRUVVZHdtZ0RTOEJ4UUtLQVA0Qk9nRGpBVEFBbmdEVUFJTUFvQUJvQU9BQWFnQ09BRVFBaEFCTUFISUFPd0E5QUNzQU5nQW1BR0lBSGdBdUFDZ0FKd0FYQUMwQUdnQWpBQjhBTHdBVUFDa0FFZ0FlQUFrQUd3QVJBQmtBRmdBNUFDZ0FMUUFyQURjQUZRQXBBQkFBSGdBaUFCQUFHZ0FlQUJNQUdBVWhCZThCRnhSRU44c0Yyd0M1QUs1SEFXOEFyUWtEelFDdWh6YzNOemNCUDY4TkVmTUFCUWRIQnV3NUJWOEZZQUE5TXprSTlyNFpCZzdReVFBV0E5Q2VPd0xOQ2pjQ2pxa0NodUEvbG0rUkFzWFRBb1A2QVNmbkVRRHl0UUZKQWpXVkNrZVhBT3NBNmdvZEFCL2N3ZEFVRTBXbEJDTi9BUVVDUVJqRkQvTVJCakh4RFFTSmJ3MGpCelVBc3dCeG1lK3RuSWNBWXdhYkF5c0c4UUFqQUVNTW14Y0RxZ1BLUXlEWENNTXhBN2tVUXdEM05YT3JBS21GSUFBZkJDMEQzeDRCSlFEQkdkVUZBaEVnVkQ4Sm53bVFKaU5XWVV6cmcwb0FHd0FVQUIwQUZuTmNBQ2tBRmdCUDloM2dQZnNET1dES25lWTJDaGdsWDFVRFlEMzBBQnNBRkFBZEFCWnpJR1JBbndERDh3QWpBRUVNelJiRHFnTUIyc0FGWXdYcUF0Q25Bc1M0QXdwVUpLUnRGSHNhZFV6OUFNTVZid0xwQUJNMU5KRVgwWmtDZ1lNQkV5TUF4UlZ2QXVrQUV6VUJVRkF0bVV3U0F5NERCVEVSMzNFZnRRSGZTd0I1TXhKL0Fqa1dLUUx6TDhFL2N3QkI2UUg5TFFEUER0TzlBU05yaVFDNURRQU5Bd0NLMjFFRkk5MXpId0NvTDlrQnFRY0hCd2NIS3pVRG93QnZBUW9oUHZVM2ZBUWdId0N5QWM4Q0tRTUE1ek1TZXpyN1VMZ0ZtRHAvTHpWUUJnRUdBaThGWVFWZ3Q4QUZjVHRsUWhwQ1dFbWZlNXRtWjZJQUV4c0R6UTh0K1g4ckJLdFRBbHRiQW4wanN5OEJsNnV0UFdNRFRSOEVpMmtSQU5rREJyTkhOeXNEQnpFQ1FXVUFjd0ZwSjNrQWl5VWhBSjBCVWI4QUwzRWZBYmZOQXo4MUtVc0ZXd0YzWVFadEFtMEErVkVmQXpFSkRRQlJTUUN6QVFCbEFIc0FNNzBHRC92M0laV0hCd0FSS1FBeEFMc2pUd0haQWVNUEV6bVhnSUh3QUJJQUdRQThBRVVBUUR0M2dkdklFR2NRWkFrR1RSRk1kRUlWRXdLMEQ2NEw3UkVkRE5rcTA5UGdBRFN4Qi9NRFd3ZnpBMXNEV3dmekIvTURXd2Z6QTFzRFd3TmJBMXNjRXZBaTI4Z1FadzlRQkhVRmxnV1RCTjRJaXlaUkVZa0hNQWphVkJWMEpoeFBBMDBCQkNNdFNTUTdtek1USlVwTUZFMExDQVEyU215dmZVQURUekd6VlAyUXFnUFRNbGM1ZEFrR0hua1NxQUF5RDNza05iMU9obnBQY2FnS1UwKzJ0WWRKYWs1dkFzWTZzRUFBQ2lrSm0yL0RkMVlHUlJBZko2a1Erd3czQWJrQlB3M3hTOXdFOVFZL0JNMGZnUmtkRDlHVm9BaXBMZUVNOFNibkxxV0FYaVA1S29jRjhVdjRQT0VMVVZGc0QxMExhUW5uT21lQlVnTWxBUkVpandyaERUMEljUkQzQ3MxdkRla1JTUWM5QTlsSm5nQ3BCd1VMRlIwNUZia21GR0t3Q3cwNWV3Yi9Hdm9Ma3lhekV5MTdBQVhYR2lVR1VRRXRHd01BMHk3cmhiUmFOVndnVDJNR0J3c3BJOHNVckZBa0RTbEF1M2hNR2g4SEdTV3RBcFZEZEVxTFVUb2VseUg2UEVFTmFpNFhVWUFIK1R3SkdWTUxoVHlpUnE5RkVoSFdQcEU5VENKTlREQUVPWU1zTXllUENkTVBpUXk5ZkhZQlhRa2xDYlVNZFJNMUVSczN5UWc5QngweGx5Z25HUWdsUnBsZ25nVDdvd1AzRTlVRER3VkRDVVVIRndPNUhERVRNaFV0QlJHQktOc0M5emJaTHJjQ2sxYUVBUnNGenc4cEgrTVFWRWZrRHUwSW53SnBBNGNsN3dBeEZTVUFHeUtmQ0VkbkFHT1AzRk1KTHM4SXkycHdJM2dEYXhUclpSRjNCNVVPV3dlckhEY1Z3eHpsY014ZUQ0WU1LS2V6Q1Y4QmVRbWRBV01FNXdnTk5WK01wQ0JGWjFlTFhCaWZJR1ZCUTE0QUFqVU1hUldqUk1HSGZBS1BEMjhTSHdFNUFYY0hQUTBGQW5zUjhSRnZFSmtJNzRZSU5ia3ovRG9wQkZNaGh5QVZDaXNEVTJ6U0N5c20vUXo4YlFHbkVtWURFRFJCZC9KbnIyQzZLQmdCQngweXlVRmtJZlVMbGsvUkRLQWF4UmhHVkRJWjZBZkRBL2NhOXlmdVFWc0dBd09uQnhjNlVUUHlCTUVMYlFpUENVTUFUUTZuR3dmYkdHNEtkWXpVQVRXUEFidWRBMXVWaHdKemt3WTdCdzhBYXcrTEJYM3BBQ0VDcXdpbkFBa0Ewd05iQUQwQ3NRZWhBQjBBaVVVQlFRTXJNd0VsNlFLVEE1Y0lOYzhCbVRNQjl5MEVIOGNNR1FEN08yNU9Bc08xQW9CdVpxWUY0VndDa2dKTk9RRlJLUVFKVWt0VkE3TjE1UURmQUU4R0YrTkxBUm12VHM4ZTUwY0I0M012QU1zQS93QUpPUWNKUlFIUkFmZHhBTHNCWXdzMUNhYTN1UUZSN1MwQWh3QVpid0hiQW8wQTRRQTVBSVAxQVZjQVVRVmQvUVhYQWxOTkFSVTFIQzliWlFHL0F5TUJOd0VSQUgwR3o1R3B6UXNqQkhFSDF3SVFIeFhsQXU4eUI3a0ZBeUxqRTlGQ3lRSzk0bGtBTWhvS1BBcXJDcXBnWDJRM0NqVjJQVlFBRWgrc1Bzcy9VZ1ZWTzFjN1hEdFhPMXc3Vnp0Y08xYzdYRHRYTzF3RG04UG13K1lLY0Y5SlllOE1xZzNZUk13NlRSUGZZRlZnTmhQTUxic1V4UlhTSlZvWlFSckFKd2tsNkZVTkR3Z3QxMlkwQ0RBMGVSZkFBRU1wYklORlk0b2VOQXBQSE90VGxWVDhMUjhBdFV1bU03TU5zQnNaUkVRRlMzWHhZaTRXRWdvbUFtU0ZBbUpHWDFHekFWODNKQUtoK3dKb25BSm1EUUtmaURnZkR3Sm1Qd0ptS2dSeUJJTURmeGNEZnBZNUNqbDdHem1HT2ljbkFtd2hBakk2T0E0Q2Jjc0NiYkx6amdNM2Ewa3ZBV3NBNGdEbEFFNEpCNXdNa1FFQ0Q4WUFFYmtDZHpNQ2RxWkRBbmxQUndKNHZpRmczMFd5UnZjQ2ZFTUNlc3dDZlEwQ2ZQUklCRWlCWnlnQUx4bEpYRXBmR1J0SzBBTFJCUUxRMEVzckE0aFRBNGZxUk1tUk5nTHlwVjBIQXdPeVM5Sk1NU2tIMDAxUVRiTUNpME1DaXR6Rkh3c2hSMnNKdXdLT093S09ZRVNiaFFLTzNRS09ZSHhSdUZNNUFRNVMyRlNKQXBQL0FwTVFBTzBBSUZVaVZiTlYxQW9zSHltWmlqTGxlR3BGUHowQ2w2TUM3N1pZSmF3QVhTa0NscE1DbG9DZ0FLMVpzRm9OaFZFQVB3S1d1UUtXVWx4SVhOVUNtYzhDbVdoY3psMExIUUtjbnpuR09xRUNuQm9DbjU4Q25yeU9BQ0VUTlM0VEFwMzFBcDZXQUxsQllUaGg4d0tlMXdLZ2NnR3RBcDZqSXdLZVVxbGp6R1FyS1M4Q0o3TUNKb0lDb1A4Q29GRGJBcVl6QXFYU0FxZ0RBSUVDcC9ab2dHaTFBQWROYWlCcTFRS3M1d0tzc2dLdGF3S3RCZ0pYSVFKVjRBS3g1ZHNESDFKc213S3l3UkVDc3V3YmJPUnRaMjFNWXdNbDBRSzJZRDlEYnBRREtVa0N1R0lDdVVzWkFya3VlM0E2Y09VQ3ZSMERMYllETWhVQ3ZveHlCZ016ZFFLK0huTW1jMU1Ddzg4Q3d3aHpoblJQT1VsMDVBTThxd0VEUEo0RFBjTUN4WUFDeGtzQ3hoU05Bc2h0VlFMSVNBTEpVd0xKTWdKa29RTGQxbmg5WlhpeWVTbEwxQU1ZcDJjR0FtSDRHZmVWS0hzUFhwWmV2eFVDejI4Q3ozQXpUMWZXOXhlakFNcXhBczkzQVMzdUEwNFdmazhKQXR3ckF0dU9BdEpUQTFKZ0ExTmpBUVVEVlpDQWpVTUV6eHJ4WkVsNUE0TFNnNUVDMnNzQzJlS0VGSVJOcDBBRGhxa0FNd05rRW9aMVhmMEFXUUxmYVFMZXZIZDdBdUl6N1JnQjh6UXJBZlNmQWZMV2l3THI5d0xwZEgwREF1cjlBdXJvQVAxTEFiMEM3bzBDNjZDV3JwY0hBdTVEQTRYa21IMXc1SEdsQXZNSEFHMERqaHFabHdMM0Z3T1JjZ09TaXdMM25BTDUzUUw0YXBvZ21xKy9PNXNpQTUySEF2NytBUjhBUFo4Z0FaKzNBd1dSQTZadUE2YmRBTlhKQXdadW9ZeWlDUTBEREUwQkV3RWpCM0VHWmIxckNRQy9CRy9ERlk4ZXR4RUFHM2s5QUNjRE54SlJBNDJEQVdjckpRQ004d0FsQU9hbkM2T1ZDTHNHSTZmSkJnQ3ZCUm5EQnZFbFJVWUZGb0FGY0Q5R1NETkNLVUs4WDNrWlg4UUFsczBGT2dDUVZDR2J3VHN1WURvWnV0Y09OeGpPR0pISi9nVmZCV0FGWHdWZ0JXc0ZZQVZmQldBRlh3VmdCVjhGWUFWZkJXQk9IUWpmalc4S0Nnb0tiRjd4TXdUUkE3a0dOOFBEQU1NRXI4TUE3MGd4RnJvRlRqNXhQbmhDUjBLK1gzMC9YL0FBV0JrenN3Q05Cc3h6ekFTbTcwYUNSUzRyRERNZUx6NDlmblhmY3NINUdjb3NjUUZ6MTNZNEh3Vm5CWExKeWNuQUNOZFJZd2dJQ0FxRVhvV1R4Z0E3UDRrQUN4YlpCdTIxS3cwQWpNc1RBd2tWQU9WdEpVVXNKMUpDdVVMRVNVQXJYeTlnUGk5QUt3bkpSUVlLVEQ5TFBvQStpVDU0UG5rQ2tVTEVVVXBEWDlOV1YzSlZFalFBYzF3M0EzSUJFM1luWCtnN1FpTUpiNk1LYWlzelJDVXVRck5DeERQTUNjd0VYOUVXSnpZUkVCRUVCd0lIS242bDMzSkNOVklmeWJQSnRBbHR5ZFBVQ21oQlp3L3RFS3NaQUpPVkpVMUNMUnV4YlVIT1FBbzdQMHMrZUVKSEhBOFNKVlJQZEdNME5WcnB2Qm9LaGZVbE0wSkhIR1VRVWhFV08xeExTajhNTzB1Y05BcUpJelZDUnh2OUVGc3FLeUE0T1FnTmoybndaZ3A1Wk5GZ0UyQTFLM1lIUzJBaFFRb2pKbUM3RGdwekdHMVdZRlVaQ1FZSFpPOWdIV0NkWUlWZ3UyQlRZSmx3Rmg4R3ZSYmNYYkc4WWd0REhyTUJ3elBWeVFvbkhRZ2tDeVlCZ1FKMEFqYzRuVnFJQXdHU0NzQlBJZ0RzSzNTV0V0SVZCYTVOOGdHakFvK2tWd1ZJWndEL0FFVVNDRHdlWDRJVHJSUXNKOEszVHdCWEZEd0VBQjBUdnpWY0F0b1RTMjBSSXdEZ1ZnWjlCQkltWWdBNUFMNENvaThMRm5lek9rQ25JUUZqQVk0S0JBUGg5UmNHc2daU0JzRUFKY3Rkc1dJUnUya1RrUXN0Unc3REFjTUJLZ3BQQkdJR01EQXdLQ1luS1RRYUxnNEFLUlNWQUZ3Q2RsK1lVWjBKZGljRkQzbFBBZHQxRjlaWktDR3h1RTN5QnhrRlZHY0Evd0JGRWdpQ0J3QU9MSFFTanhPdFFEZzF6N2RlRlJNQVo4UVRBR3RLYjFBcElpUEhBRGtBdmdLaUx5MURGdFlDbUJpREFsRERXTkIwZW83ZnBhTU8vYUVWUlJ2MEFURVFaQklPRHlNRUFjOEpRaENiRFJnekZENFRBRU1BdTlZQkNnQ3NBT2tBbTVJM0FCd0FZeHZPTm5SK01oWEpBeGdLUXl4TDIra2tKaE1iaFFLREJNa1NzdkYwQUQ5Qk5RNnVRQzdXcVNRSHd4RUFFRUl1MWhraEFIMno0aVFQd3lKUEhOV3BkeVlCUlNwbkpBTHpvQkFFVlBQc0gyME14QTBDQ0VRS1JnQUZ5QXRGQWxNTnd3akVEVVFKUkFyRUx0YXBNZzdERFpnSkl3K1RHdWtFSXd2REZrTUFxQXRERU1NTUJoaW9lK1FBTzNNTVJBQUNyZ25FQlNQWTlRMEZEbmJTQm9NQUI4TVNZeGtTeEFFSkFQSUpBQUI4RldNT0Z0TWMvSGNYd3hoREFDN0RBdk9vd3dBZXd3SmRLREtIQUFIREFBTHJGVVFWd3dBYnd5dnpwV01Xdjh3QS9BQnBBeSsrYmNZRFVLUEQwS2hEQ3dLbUoxTUFBbU1BNStVWnd4QWFnd2lwQlJML2VBRGZ3NmZER09NQ0dzT2prM2w2QndPcG80c0FFc01PR3hNQUE1c0FiY01PQUF2RHAwTUpHa01Ed2dpcG5OSVBBd2ZJcVVNR0FPR0RBQVB6QUJYREFBY0RBQW5EQUdtVEFCckRBQTdEQ2hqRGpuRVdBd0FCWXdBT2N3QXVVeVlBQnNNQUY4TUlLUUFOVWdDNnd5NEFBOE1BRHFNcTh3Q3lZZ0FjSXdBQjh3cXBBQVhPQ3gwVjR3QUhvd0JDd3dFS0FHbkRBQXVEQUIzREFBakRDYWtBQmRJQWJxY1ozUUNaQ0NrQUJkSUFBQUZEQUFmakFCMmpDQ2tBQnFJQUNZTUFHek1BYlNNQTVzT0lBQWhqQUFoREFCVERCQWtwQUFiU0FPT1RBQWxEQzZrT3pQdG5BQWREQUc2a1FGQUFUd0FLd3d3QUEwTUFDYlVEUHdBSEl3QVpnd0FDRTZjREFBb2pBQXBEQUFvRHAvTUd3d0FKSXdBREV3QVFRd2dBRkVNQUVYTUFENU1BRGZNQURjTUFHUk1PRmlNQUZVTUFicU1XdXdIREFNSUFFME1MQUdrekVnRGhVd0FDUXdBRVdnQVhnd1VqQUFiWUFCakRCU1lCZ3pCYUFFRk5BTGNRQnhVTWVnQXdNbmdCckEwSVpnSjBLeFFIQlJFUGQxTjBaektSSndhSUhBWnFOVDREcVFxOEJ3bmdBQjREQXd0MkFYNTZUMW9jS1FOWEFoMUdBVFFHQzN0T3hZTmFna2dBTVFBNUNRQURBUUVBV3hMakFJT1lOQUV6QUg3dEZSazZUZ2xTQUY4TkFBbFlBUStTMUFDQVF3UW9yUUJpQU40ZEFKMXdQeWVUQU5WenVRRFgzQUllRU1wOWV5TWdYaVVBRWRrQmtKaXpLbHRiVlZBYVJNcVJBQUVBaHlRL1NERXo2Qm1mVndCNkFURXNPQ2xLSVJjRE9GMEUvODMyQUZOdDVBQnlBbmtDUnhHQ09zOTROalhkQXdJTkdCb25EQndQQUxXMkF3SUNBZ0FBQUFBQUFBWURCUU1EQVJyVUF3QXRBQUFBQWdFR0JnWUdCZ1lGQlFVRkJRVUVCUVlIQ0FrRUJRVUZCUVFBQUFJQ0FBQUFJZ0NOQUpBQWxUMEE2Z0M3QU53QXBFUUF3Z0N5QUswQXFBRHVBS1lBMmdDakFPY0JDQUVEQU1jQWdRQmlBTklBMUFFREFONEE4Z0NRQUtrQk1RRHFBTjhBM0FzQkNROHlPOXJhMnRxOHh1TFQxdFJKT0IwQlVnRmNOVTBCV2dGcEFXZ0JXd0ZNVVVsTGJoTUJVeHNORUFzNlBoTU9BQ2NVS3kwdk1qNUFRRU5EUTBSRkZFWUdKRmRYVjFkWldWaFpMMXBiWFZ4Y0kyTm5aMlpvWnlwc2JuWjFlSGg0ZUhoNGVucDZlbnA2ZW5wNmVucDhmSDE4ZTJJQVJQSUFTUUNhQUhnQU1nQm0rQUNPQUZjQVZ3QTNBbmJ2QUlzQUJmajRBR1FBay9JQW53QlBBR0lBWlAvL3NBQ0ZBSVVBYVFCV0FMRUFKQUMyQUlNQ1FBSkRBUHdBNXdEK0FQNEE2QUQvQU9rQTZRRG9BT1lBTHdKN0FWRUJRQUUrQVZRQlBnRStBVDRCT1FFNEFUZ0JPQUVjQVZnWEFERVFDQUVBVXg4U0hnc2RIaFlBamdDV0FLWUFVUUJxSUFJeEFIWUFid0NYQXhVREp6SURJVWxHVHpFQWtRSlBBTWNDVndLa0FNQUNsZ0tXQXBZQ2xnS1dBcFlDaXdLV0FwWUNsZ0tXQXBZQ2xnS1ZBcFVDbUFLZ0FwY0NsZ0tXQXBRQ2xBS1VBcFFDa2dLVkFuVUIxQUtYQXA4Q2xnS1dBcFVlQUlFVEJRRCtEUU9mQW1FQ09oOEJWQmc5QXVJWkVqTWJBVTQvRzFXWkFYdXNSQUZwWVFFRkEwRlBBUVlBbVRFZUlKZHlBREZvQUhFQU5nQ1JBNXpNay9DMmpHSU53ak1XeWdJWkNhWGRmRElMQkNzNWRBRTdZblFCdWdEbGhvaUhob2lHaVlxS2hvdU9qSWFOa0k2SWo0cVFpcEdHa29hVGhwU1NsWWFXaHBlS21JYVpocHFHbTRhY2k1MlFub3FmaHVJQzRYVHBBdDkwQUlwMExIU29BSXNBZEhRRVF3UkFCRUlFUlFSREJFa0VSZ1JCQkVjRVNRUklCRVFFUmdSSkFKNXVkQUNyQTQ5MEFMeHVBUTEwQU5GWmRIUUExM1FDRkhRQS9tSjBBUDRCSVFEK0FQd0EvQUQ5QVB3RGhHWjAzQVNNSzIzSEFQNEEvQUQ4QVAwQS9DUjBkQUNSWW5RQS9nQ1JBU0VBL2dDUkF2UUEvZ0NSQTRSbWROd0VqQ3R0eHlSMEFQOWlkQUVoQVA0QS9nRDhBUHdBL1FEOEFQOEEvQUQ4QVAwQS9BT0VablRjQkl3cmJjY2tkSFFBa1dKMEFTRUEvZ0NSQVA0QWtRTDBBUDRBa1FPRVpuVGNCSXdyYmNja2RBSkxBVDUwQWxJQlFYUUNVOGwwZEFKZmRIUURwZ0wwQTZZRHBnT25BNmNEcHdPbkE0Um1kTndFakN0dHh5UjBkQUNSWW5RQklRT21BSkVEcGdDUkF2UURwZ0NSQTRSbWROd0VqQ3R0eHlSMEJEaDBBSkVFT1FDUkRwVTVkU2dDQURSMDNnVjJDd0FyZEFFRkFNNWlDblIwQUYxaUFBWWNPZ3AwZEFDUkNuUUFYQUVJd1daMENuUm1kSFFBa1daMENuUm1kRVhnQUZGMDNncDBkRVkwdGxUMnUzU09BUVR3c2N3aGpaWktyaFljQlNmRnA5WE5iS2lWRE9EMmIrY3BlNC9aMTdtUW5idHp6aGFlUXRFMkdHajBJRE5UalJVU3lUeHh3L1JQSFcvK3ZTN2QxTmZSdDl6OVFQWmc0WDdRRmZoQ25rdmdOUElJdE9zQzJlVjZoUGFublpOSGxaOXhyd1pYSU1PbHUzalNvUVNxNzhXRWp3TGp3MUVMU2xGMWFCdmZ6d2s1Wlg3QVV2UXpqUFFLYkR1UStzbTR3Tk9wNEE2QWRWdVJTMHQxeS9EWnBnNFI2bTdGTmpNOUhndlc3Qmk4OHphTWpPbzZsTTh3dEJCZGo4TFA0eWx2M3pDWFBoZWJNS0pjMDY2bzlzRjcxb0ZXLzhKWHU4NkhKYndESUQ1bHp3NUdXTFIvTGhUMFFxbnAySlF4TlpOZmNiTEl6UHkrWXlwcVJtL2xCbUdtZXgrODIrUGlzeFV1bVNlSmtBTElUNnJKZXp4TUgrQ1RKbVF0dDV1d1RWYkwzcHRtakRVUXpsU0l2V2k4VGw3bmcxTnB1Um4xTmc0bjE0UWMrM0lpbDdPd2t2TldvZ0xTUGtuM3BpaElGeXR5SUdtTWhPZTNuMXRXc3VNeTlCZEt5cUY0WjN2MlNnZ2dUTDlLVnZNWFBuQ2JSZStvT3VGRlAzSGVqQkcvdzlndm1mTll2ZzZKdVdpYTJsY1NTTjF1SWpCa3R6b0lhek9IUEpaN2tLSFB6OG1SV1ZkVzNsQThXR0Y5ZFFGNkJtNjczYm9vdjNCVVdEVTJKTmNhaFIyM0d0ZkhLTE96L3ZpWityWW5aRmFJem5YTzY3Q1lFSjFmWHVUUnBaaFlaa0tlNTR4ZW9hZ2tOR0xzK05UWkhFMHJYNDUvWHZRMlJHQURYNnZjQXZkeElVQlYyN3d4R20yempabzRYM0lMZ0Fsck9GaGV1WjZ3dHN2YUlqNHlMWTdxcWF3bGxpYUljcnoyRytjM3ZzY0FuQ2tDdU16TW1adk1mdTlsTHdUdmZYKzNjVlN5UGROOVp3Z0RaaGZqUmdOSmNMaUo2N2I5eHg4Skhzd3ByYmlFM3Y5VXBob3RBUElnblhWSU41S21NYzBwaVhoYzZjQ2hQbk4rTVJoRzlhZHRkdHRRVFR3U0lwbDhJNC9qLy9kM3N6MTMyNnFUQlRwUFJNL0hnaDNrenFFWHM4WkFrNEVyUWhOTzhoenJRMERMa1dNQS9OKzkxdG4yTWRPSm5XQzJGQ1plaGtRcnd6d2JLT2podlpzYk05NVFvZUw5c2tZeU1mNHNyVlBWSlNnZzdwT0xVdHIvbjllVDk5b2U5bkx0RlJwakE5b2tWMktqOGg5azVIYUMwb2l2UkQ4VnlYa0o4MXRjZDRmSE5YUENmbG9JUWFzeHN1TzE4LzQ2ZFIyamd1bC9VSWV0Mkcwa1J2bnlPTk1LaEhzNkoyNkZFb3FTcWQrcmZZamVFR3dIV1ZEcFgxZmgxakJCY0tHTXFSZXBqdTlZMDBtRFZIQytYZGlqL2o0NHJLZnZmakdpbk5zMWpPLzBGM2pCODNYQ0RJTk4vSEI4NGF4bFArM0Uva2xrdFJvK3ZsM1UvYWl5TUpiSW9kRTFYU3NEbjZVQXpJb010VU9iWTIray80Z1kvbCtBa1pKNVNqMnZRcmt5TG0zRm94amhEWCszMVVYQkZmOVhyQUgzMWZGcW9CbURFWnZodnZwblo4N04rb1pFdTdVOU8vbm5rK1FXajN4OHV5b1JiRW5mK081VU1yOWkwbkhQMzhJRjVBdnpyQlc4WVdCVVIwbUlBekl2bmRRcTlOM3YvSnRvM2FQalBYVVBsOEFTZFBQeUFwN2pFTmY4Yms3Vk1NOW9sOVhHbWxCbWVETXVHcXQrV3p1TDZDWEF4WGpJaENQTTV2QUNjaGdNSi84WEJHTE8vRDFpc1Z2R2h3d0hIcjFETGFJNW1uMkpyL2IxcFVEOTB1Y2lEYVM4Y1hORHpDV3ZObVQvUGhRZTVlOG5Ubm5ua3Q4RHMvU0lqaWJjdW0vZnFEaEtvcHhBWThBa1NyUG4rSUdERUtPTytVM1hPUDZkakZzMkg1Tjkrb3JoT2FoaVFrNUtuRVVXYStDemtWemhwOGJNSFJiZzgxcWhqalh1SUtiSGpTTFNJQktXcW9ja0d0S2luWSt6NC9SZEJVRjZwY2MzSm1ubHhWY05nckk0U0V6S1VaU3djRDJRQ3l4ekt2ZStnQW1nNlp1U1JrcFBGYTZtZlRodTdMSk51M0g1SzQydUNwTnZQQXNvZWRvbEtWL0xIZS9lSitCYmFHNU1HME5hU0dWUFJVbU5GTUZGU1NwWEVjWHdiVmg3VUVUT1padG9WTlJHT0liYmtpZzNNY0V0UjY4Y0cwUlpBb0pldldZbzdEZy9sWjFDUXpibFdlVXZWSG1yOGZZNE5xZDlKSmlIL3pFWDI0bUp2aUg2MGZBeUZyMEEzYzRiQzFqM3laVTYwVmdKeFhuOEpnSlhMVUlzaUJubUttTVl6Kzd5QlFGQnZxYjJlWW51VzU5am9aQmY1Ni93WHZXSVI0Ujh3VG1WODBpMW1aeStTNCtCVUVTK2h6amswdVhwQy8vL3ovSWxxSFoxbW9uemxYcDhhQ2ZoR0tNdGk3M0ZJMUtiTDFxNklLTzRmdUJ1WjU5Z2Fnam41eFU3OW11TXBIWGc2UytlK2dETS9VOUJLTEhibDlsNm84Y3pRS2w0UlVrSkppcWZ0UUcyaTNCTWcvVFFsVVlGa0pEWUJPT3ZBdWdZdXpZU0RuWmJERGQvYVNkOXgwT2U2RitiSmNIZmw5K2dwNkw1L1RnQStCZEZGb3ZiZkNyUTQwczV2TVB3ODg2NnBOWDh6eUZHZUZXZHhJcFBWcDlSZzFVUE9WRmJGWnJ2YUZxL1lBekhRZ3FNV3BhaE1ZZnFIcG13WGZITDEva3BZbUd1SEZ3VDU1bVF1MGR5bGZOdXEyT3EwaFRNQ1B3cWZ4bnVCSVBMWGZjaTRZMUFOeSsxQ1VpcFF4bGQvaXpWaDE2V3lHMlEwQ1FROU5xdEFueDFIQ0h3RGo3c1l4T1NCMHdvcFpTbk96eFFPY0V4bXhyVlRGMkJrT3RoVnBHZnVoYUdFQ2ZDSnBKS3BqbmloWSt4T1QyUUp4TjYxKzlLNlFTcXR2MlNocjgySTNqZ0pycUJnMHdFTEZaUGp2SHB2elR0YUpuTEs2VmI5N1luOTMza29PL3NhTjdmc2p3Tkt6cDRsMmxKVngyb3JqQ0d6Qy80Wkw0ekN2ZXI2YVFZdEM1c2RveWNodUZFNnVmT2lvZytWV2k1VURrYm12bXRhaC8zYUFyRUJJaTM5czVJTFVubEZMZ2lsY0d1ejlDUXNoRVk3Zncyb3VvSUxBWVBWVC9neUFJcTNURkFJd1ZzbCtrdGtSei9xR2ZuQ0RHcm01Z3NsL2w5UWR2Q1dHc2pQejNkVTdYdXFLZmRVcnIvNlhJZ2pwNHJleTZBSkJtQ21VSk1qSVRIVmRGYjVtMXArZExNQ0w4dDU1ekQ0MmNtZnRtTEVKQzBEYTA0WWlSQ1ZVQkxMYThEMDcxL041VUJOQlhEaDBMRnNtaFYvNUI1RXhPQjRqM1dWRy9TM2xmSzVvK1Y2RUxIdnk2UlI5bjRhYytWc0s0VkU0eXBoUHZWK2tHOUZlZ1RCSDRaUlhMMkh5dFVIQ2R1SmF6Qi9LeWtqZmV0WXhPWFRMd3MyNjdhR09kK0krSmhLUC8vK1ZuWG1TOTBPRC9qdkxjVnUwYXN5cWN1WU4xbVNiNlhUbENrcXYxdmlnWlBJWXdORi96cFdjVDFHUi82YUVJUmpraDB5aGc0TFhKZmFHb2JZSlRZNEpJNThLaUFLZ21tZ0FLV2RsNW5ZQ2VMcWF2UkpHUU51WXVadFpGR3grSWtJNHc0TlMyeHdiZXROTXVuT2pCdS9obUtDSS93N3RmaWl5VWQvLzRyYlRlV3Q0aXpCWThZdkdJTjZ2eUtZbVAvOFg4d0hLQ2VOK1dSY0tNNzArdFhLTkd5ZXZVOUgyRGc1QnNsam5UZjhZYnNKMVRtTXM3NENlMlhsSGlzbGVndWh5ZWc0NHJRT0hadXcvNkhUa2hubnVySzJkNjJxNnlTNzIxMFNzQUlhUitqWE1RQStzdmtyTHBzVVkrRjMwVXc4OXVPZEdBUjZ2bzRGSU1FMEVmVlZlSFR1NmVLaWNmaFNxT2VYSmhiZnRjZDA4c1dFbk5VTDFDOWZucHJUZ2Q4M0lNdXQ4b25WVUYwaHZxelpmSGR1UGpiandFWEljb1lteStQNnRjSlpIbWVPdjZWcnZFZGtIREplY2pIdUhlV0FOZTc5Vkc2NjJxVGpBL0hDdnVtVnYzcUwrTHJPY3BxR3BzMlpHd1FkRko3UFU0aXV5UmxCcndmTyt4blB5cjQ3czJjWFZiV3pBeXpuRGlCR2pDTTNrc3hqanFNNjJHRTlDOGY1VTM4a0IzVmp0YWJLcC9uUmR2TUVTUEdERzkwYldSTEF0MVFrNUR5THVhelJSMVl6ZEMxYytoWlh2QVdWOHhBNzJTNEE4QjY3dmpWaGJiYTNNTW9wMjkzRmVFWHBlN3pJdE1XckpHL0xPSDlCeU9YbVluTkpmam1mdVg5S2JycGdMT2JhNG5aK2ZsOEdiZHYvaWh2KzZ3RkdLSENZclZ3bWhGQzBKM1YyYm4ydElCMXdDYzFDU1QzZDNYMk95eGhndVhjczRzbTY3OVVuZ3pvZnVTZUJld01GSmJvSVFIYlVoL20ySmhXMmhHOURJdkcydDd5Wkl6S0JUejl3QnRuTkMrMnBDUlloU0l1UTFqOHhzejVWdnFueVVJdGh2dW95eXU3Zk5JcmcvS1FVVm1HUWFxa3Faay9WeDViMzMvZ3NFczh5WDdTQzFKK05WNGljejZidklFN0M1RzZNY0JhSThyVmc1NnE1UUJKV3huLzg3UTFzUEs0K3NRYThmTFU1Z1hvNHBhYXE0Y09jUTR3UjBWQkhQR2pLaCtVbFBDYkExbkxYeUVVWDQ1cVo4SjcvTG40RlBKRTJUZHpEMFo4TUxTTlFpeWtNTW1TeU9DaUZmeTg0UnE2MGVtWUIydkQwOUtqWXdzb0lwZURjQkRURWxCYlh4TkQ3MnloZDlwQy8xQ01pZC81SFVNdkFMMjdPdGNJSkR6TktwUlBOcVBPcHl0MmFQR3o5UVdJczloUTlMaVg1czhtOWhqVFV1L2Y3TXlJYXRqamQrdFNmUTN1Zlp4UHBtSmhUYUJ0WnRLTFVjZk9DVXFBRHVPK1FvSDhCOXY2VStQMEhWMUdMUW10b05GVGIzczc0aXZaZ2pFUzBxZksrOFJkR2dCYmNDTVN5OGVCdmg5OCtldDFLSUZxU2UxS1FQeVhVTEJNVHNJWW55c0l3aVpCSllkSTIwdnNlVit3dUprY3FHZW1laEtqYUFiOUw1N3habTNnMnpYMGJaMnhrL2ZVK2JDbzdUbG5iVzdKdUYxWWRVUm8vMkd3N1ZjbERHMVc3TE90YXMyTFg0dXBpZlovMjNyenBzblkvQUxmUmdyY1dQNWhZbVY5VnhWT1FBMWZadnA5RjJVTlUrN2Q3eFJ5Vm01d2lMcDMvMGRsVjd2ZHcxUE1pWnJiREFZeklWcUVqUlkyWVUwM3NKaFBubHdJUGNaVUc1bHRMNlM4WEN4VTFlWVM1Y2pyMzR2ZUJtWEF2eTd5TjRaakFySUcwZGZELzVVcEJObFgxWlBveEpPd3lxUmkzd1FXdE96ZDRvTktoMExrb1RtOGN3cWdJZktocXFHT2h3bzcxSSt6WG5NZW1UdjJCMkFVekFCV3lGenRHZ0dVTGpERHpXWXdKVVZCVGpLQ241SzJRR01LMUNRVDdTenppT2pvK0JoQW1xQmp6dWMzeFl5bTJlZWRHZU9JUkpWeVR3RHczN2lDTWU0ZzVWYm5zYjVaQmR4T0FuTVQ3SFU0REhweFdHdVE3R2VpWTMwQ3BidnpzczU1KzVLbTFZc2JENWVhM05JOVFOWUlYb2w1YXBnU3U5ZFo4Zjh4UzVkdEhwaWRvNUJjbER1TFdZNGxoaWswdGJKYTA3eUpoSDBCT3lFdXQvR1JiWVRTNlJmaVRZV0dNQ2tOcGZTSGk3SHZkaVRnbEVWSEtaWGFWaGV6SDRra1hpSXZLb3BZQWxQdXNmdHBFNGE1SVp3dncxeC9lTHZvREloL3pwbzlGaVFJbnNUYjJTQWtLSFY0MlhZQmpwSkRnNDM3NFhpVmIzd3M0cU0wczllU1E1SHpzTVU0T1pKS3VvcEZqQk0rZEFaRWw4UlVNeDV1VTJONDg2S3IxNDF0VnNHUWZHak9SWU1DSkFNc3hFTGVOVDRSbVdqUmNwZFRHQndjeDZYTjlkcldxUG1KemNyR3JINCtEUmM3K24xdzNrUFp3dTBCa05yNmhRcnFnbzdKVEI5QTVrZEovSDdQNGNXQk13c211aXhBekpCM3lyUXBuR0lxOTBseEFYTHpEQ2RuMUxQaWJzUnQ3ckhOamdRQmtsUmdQWjh2VGJqWGRnWHJUV1FzSzVNZHJYWFFWUHAwUmlucTNmcnpaS0owcUQ2UWhjNDBWekFyYVVYbG9iMWd2a2hLM3ZwbUhnSTZGUmxRWk54NmVScWtwMHp5NEFRbFg4MTNmQVB0TDNqTVJhaXRHRkZqbzB6bUVybG9DK2grWVlkVlE2azRGL2VweEFvRjBCbXFFb0tOVHQ2ajR2UVpOUTJCb3FGOVZqNTNUT0lvTm1EaXU5WHAxNVJrSWdRSUdjb0xwZm9JYmVuenBHVUF0cUZKcDVXK0xMbngzOGpIZUVDVEovbmF2S1kxTldmTjBzWTFUOC9wQjhrSUgzRFUzRFgrdTZXM1l3cHlwQk1ZT2hiU3hHanE4NFJaODRmV0pvdzhweUhxbjRTLzlKMTVFY0NNc1hxcmZ3eWQ5bWhpdTMrckVvOXBQcG9Ka2RacUhqcmE0TnZ6Rnd1VGhOS3k2aGFvL1NsTHczWkFEVWNVcDN3M1NSVmZXMnJobDgwek9nVFluS0UwSHMycXAxSjZIM3hxUHFJa3ZVRFJNRkRZeVJic0ZJM005TUV5b3ZQazhybHc3LzBhODFjRFZMbUJzUjJ6ZTJwQnVLYjIzZmJlWkMwdVhvSXZEcHBmVHdJRHhrMU9xMmRHZXNHYytvSlhXSkxHa09oYTNDWCtEVW56Z0FwOUhHSDlSc1BaTjYzSG40Uk1BNWVTVmhQSE8rOVJjUmIvSU9ndFczMVYxUTVJUEd0b3hQakMrTUVKYlZsSU1ZQURkOWFIWVdVSVFLb3B1UE9IbW9xU2t1Ym5BS256Z0tIcWdJT2ZXNVJkQWdvdE42Qk4rTzJaWUhrdWVtTG52UThVOVRIVnJTMVJ0TG1LYmNDN1BlZURzWXpudnF6ZWc2VkNOd21yMFl5eDF3bkxqeVQ4NEJaejNFSnlDcHREM3lldWVBeURXSXMwTDJxcy9WUTNIVXlxZnJqYTBWMUxkRHpxQWlrZVd1VjRzYzdSTElCNjlqRUlCakNreVplZG9VSHFDck92U2hWenlkNzNPZHJKVzBoUE91UXYycU9vSERjOXhWYjZZdTZ1cTNYcXAyWmFINDZBN2x6ZXZieFFFbWZyenZBWVNKdVo0V0RrMUh6M1FYMUxWZGlVSzBFdmxBR0FZbEczTWQzMHI3ZGNQTjYzeXFCQ0lqMjVwcnB2WlAwbkk0K0VnV29GRzk1VjU5NkN1clhwS1JCR1JqUWxIQ3Z5NUliL2lXOG5aSld3ckVUM21nZDZtRWhmUDRLQ3VhTGpvcFdzN2grTWRYRmRJdjhkSFFKZ2cxeGkxZVlxQjB1RFlqeHdWbXJpMFN2NVhLdXQvb25xYXBDK0ZRaUMyQzFsdllKOU1WY282eURZc1MzQUFOVWZNdHZ0YllJMmhmd1phdGlTc25vVWVNWmQzNEdWamtNTUtBK1huakpwWGdSVzJTSFRacGxWb3dQbUpzdlh5NnczY2ZPMUFLMmR2dFpFS1RrQy9UWTlMRmlLSENHMERuck1RZEdtMmx6bEJITTlpRVl5bkgyVWNWTWhVRWpzYzBvREJUZ28yWlNRMWd6a0FIZVdlQlhZRmpZTHV1Zjh5elRDeTcvUkZSODFXRGpYTWJxMkJPSDVkVVJueG82b2l2bXhMM2NLektJbmxaa0QzMW52cEhCOUtrN0dmY2ZFMXQrMVY2NGI5THRnZUpHbHBSRnhRQ0FxV0o1RG9ZNzdza2k4Z3NPRU9yMnV5d1phb08vTkdhMFgweTFwTlFIQmkzYjJTVUdOcGNaeERUN3JMYkJmMUZTblE4Z3V4R1czVyszNkJXMGdCamU0RE96NkJhNlNWazB4aUtndCtxMkpPRnlyNFNZZm51K0ljMVFaWUl1d0hCcmd6cjZVdk9jU0N6UFRPbzdENklDNElTZVM3emtsNGgrMlZvZUhwbkcvdVdSMyt5c05nUGNPSVhRYnYwbjRtcjNCd1FjZEtKeGdQU2V5dVAvejFKamc0ZTluVXZvWGVncVFWSUUzMEVIeDVHSHYrRkFWVU5Ub3dZREpneUZoZjVJdmxZbUVxUmlmNitXTjFNa0VKbURjUUlUeDlGWDIzYTRteHkxQVFSc09ITy8rZUltWDlsOEVNSkkzb1BXelZYeFNPZUhVMWRVV1lyMnVBQTdBTWIrdkFFWlNiVTNxb2I5aWJDeVhleXBFTXBaNjg2M282UVBxbHFHSFprdVdBQlNUVk5kNGNPaDlodjNxRXBTeDJaeS9ESk1QNmNJdEVtaUJKNVBGcVFuREVJdDNOckEzQ09sT1NnejQzRDdncE5GTko1TUJoNG9GemhEUGlnbEMyeXBzTlU0SVN5d1kyZXJreWIxTkMzUWgvSWZXajBlRGdaSTQvbG44V1BmQnNUM21lVGpxMVVxdDFFN1psL3FmdHFreDZhTTlLdWVNQ2VrU25NcmNIajFDcVRXV3pFelBzWkdjRGUzVWU0V3MrWEZZVnhOYk9GRjhlemt2UUdSNlpPdE9MVTJsUUVuTUJTdHg0N3ZFNlBiN0FZTUJSajJPT2ZaWGZpc2pKbnBUZlNOam82c1o2cVN2TnhaTm1EZVM3R2szeVl5Q2sxSHRLTjJVbmhNSWpPWFV6QXFEdjkwbHg5Ty9xL0FUMVpNbml0NVhRZTl3bVF4bkUvV1NIMENxWjkvMkh5K1NmbXBlZzhSd3NISTVaOGtDOEgyOTNtL0xIVlZNL0JBN0hhVEpZZzVFbms3TS94V3BxMDE5MkFDZkJhaTJMQS9xckNqQ3I2RGgxQklNek1YSU5CbVg5Nk1KNUhuMm54bG4vUlhQRmh3SHhVbVNWMEVWMlYwam04Ni9keHh1WVNVMVc3c1ZrRWJOOUV6a0cwUUZ3UGh5SEt5YjN0K0ZqNVdvVVVURXJjYXpFL042RVc2THZwMGQvL1NEUGo3RVY5VWRKTitBbW5mM1d3azNBMFNsSjlaMDB5dlhaN24zejcwRzQ3SGZzb3c4V3ExSlhjZnduQStZeGE1bUZzZ1Y0NjRLS1A0VDMxd3FJZ3pGUGQzZUNlM2o1b3J5NWZCRjJoZ0NGeVZGckx6STllZXROWHZNN29RcXlGZ0RvNENUcC9oRFY5Tk1YOUpESFEvbnlIVEx2WkxOTEY2ZnRuMk94akdtOCtQcU93aHhuUEhXaXBrRS84d2J0eXJpODBTcjdwTU5rUUdNZm80WllLOU9jQ0M0RVNWRkZiTE1Jdmx4U29ScVdpZTB3eHFuTGZjTFNYTVNwTU1RRUpZRFZPYllzWElRTnY0VEdOd2pxMWt2VDFVT2tpY1RyRzNJYUJaM1hkU2NTM3U4c2dlWlBWcE9Ma2JpRjk0MEZqYkNlTlJJTk52RGJkMDFFUEJyVENQcG0xMm00M3plMWJCQjU5SWE2T3ZobnVyL052eDNJeHdTV29sKzNIMnFmQ0pSOGRmNmFRZjR2NldpT054a0srSXFUNHBLUXJaSy9McGxnREkvUEpaYk9lcDhkdGJWN29DcjZDZ2ZwV2E4TmN6T2tQeDgxaVNIYnNOaFZTSkJPdHJMSU1yTDMxTEs5VHFIcUFiQUhlMFJMbW1WODA2a1JMRExORWhVRUpmbTl1MHN4cGtMOTNaZ2Q2cncrdHFCZlRNaTU5eHFYSExYU0h3U2JTQmwwRUswK2xvRUNPUHRybCsvbnNhRmUxOTdkaTR5VWdvZTRqS29BSkRYYzZER0RqclFPb0ZEV1pKOUhYd3Q4eERyUVArN2FSd1dLV0kxR0Y4czhPNEt6eFdCQmN3bmwzdm5sMU9lejNvaDZFYTF2alI3L3o3RERUckZ0cVUyVy9LQUV6QXVYRE5aN01ZNzNNRjIxNmR6ZFNiV21VcDRsY203a2VKZldhTUhndXQ5eDVDOW1qNjZaMGxKK3loc2pWdnlpV3JmazFselBPVGRoRzE1WTdnUWxYdGFjdkk3cXYvWE5Tc2NEd3FrZ3dIVC9nVXNENXlCN0xkUlJ2SnhRR1lJTm45aFRwb2RLRlZTVFBydEd2eVF3K0hsUkZYSWtvZEVyQUd1OUl5MVlwZlNQYzNqa0ZoNUNYM2xQeHY3YXFqRS9KQWZUSXBFakdiL0g3TU8wZTJ2c1ZpU1cxcWEvTG1pNC9uNERFSTNnN2xZcmNhbnNwRGZFcEtrZFYxT2pTTE95MEJDVXFWb0VDYUI1NXZzMDZyWGw0anFtTHNQc0ZNLzd2WUowdnJCaERDbS8wMEEvSDgxbDF1ZWtKLzZMbWwzSGI5K05LaUxxQVRKbURweXpmWVpGSHVtRWpDNjYyTDBCd2t4aTdFOVU0Y1FBMFhNVkR1TVlBSWVMTVBnUWFNVk9kOGZtdDVTZmxGSWZ1Qm9zemVBdzdvdzVnWFBFMlkveUJjLzdqRXhBUlVmL0J4SUhRQkY1U24zaTYxdzR6NXhKZEN5TzFGMVgzKzNheCtKU3ZNZVo3UzZRU0twMUZwL3NqWXo2WitWZ0NaemliR2VFb3VqcnlmTXVsSDdSYWk1a0FmdDllYmNXNTBEeUpyMnVvMno5N21UV0l1NDVZc1NuTlNNcnJOVXVHMVhzWUJ0RDlURFl6UWZmS0I4N3ZXYmtNNEViUEFGZ29CVjRHUVMrdnRGRFVxT0ZBb2kxblR0bUlPdmczOE40aFQyU244cjhjbG1CQ1hzcEJsTUJZVG5ycUZKR0JUM3daT3pBeUpEcmU5ZEhINyt4N3FhYUtET0I0VVFBTEQ1ZWNTMERFNG9idWJRRWl1SlowRXBCVnBMdVljY2U4QWE0UFlkL1Y0RExEQUpCWUtRUENXVGNyRWFaNUhZYkppMTFHZDZoakdvbTFpaTE4VkhZbkcyOE5LcGt6MlVLVlB4bGhZU3A4dVpyMzY3aU9tb3k3enN4ZWhXOXd6Y3kyekcwYTgwUEJNQ1JRTWIzMmhuYUhlT1I4Zm5ORHpaaGFOWWhrT2REc0JVWjNsb0RNYTFZUDB1UzBjalVQM2IvNkRCbHFtWk9lTkFCRHNMbDVCSTVRSnVwczh1eEF1V0pka1VCL3BPNlpheDZ0c2c3Zk41bWpqRGdNR25nTytEUGNLcWlISURiRklHdWR4dFBUSXlEaTlTRk1LQkRjZmRHUVJ2NDFxMUFxbXhna1ZmSk1uUDh3L0JjN045L1RSNkM3bUdPYkZxRmtJRW9tOHNLaTJ4WXFKTFRDSEs3Y3h6YVp2cU9EbzIyYzN3aXNCQ1A0SGVBZ2NSYk5QQXNCa05SaFNtRDQ4ZEh1cGRCUnc0bUl2dFM1b2VGNnplVDFLTUN5aE1ubWhwa0ZBR1duR3Njb05rd3ZROFpNNWxFL3ZnVEhGWUw5OU91TnhkRkJ4VEVEZDV2MnFMUjh5OVdrWHNXZ0c2a1pObmRGRytwTy9VQWtPQ2lwcUloTDNocTdjUlNkckNxN1loVXNUb2NFY25hRmE2blZraG5TZVJZVUExWU8wejVpdEY5U2x5M1ZseFlEdzIzOVRKSkg2ZjNFVWZZTzVsYjdiY0ZjejhCcDdPbzhRbW5zVUhPei9mYWdWVUJ0S0V3MWlUODhqK2FLa3Y4Y3NjS05rTXhqWXI4MzQ0RDFrRm9aNy90ZDFXNkxDTllONTk0MzAxdFVHUm1GakF6ZVJnNXZ5b00xRjYrYkpaL1E1NGpOL2s4U0ZkM0R4UFRZYUFVc2l2c0JmZ1RuN014OEgyU3BQdDRHT2RZUm5FSk9INmpITTJwNlNnQjBneklScTZmSHhHTW1TbXFhUENtbGZ3eGl1bG9hVklpdExHTjh3aWUyQ0RXaGt6TG9DSmNPRGg3S0lPQXFiSEV2WGRVeGFTNFRUVHMwN0NsemovNkdtVnM5a2laRGVyTXhFbmhVQjZRUVBsY2Zxa0c5ODgyUnFIb0xpSEdCb0hmUXVYSXNBRzhHVEF0YW8yS1Z3Um52dmFtOGpvMWUzMTJHUUFLV0VhNHNVVkVBTUc0RzZja2NPTkR3UmNnMWUyRDMrb2hYZ1k0VUFXRjh3SEtRTXJTbnpDZ2ZGcHN4aCthSFhNR3RQUXJvUWFzUlk0VTZVZEcwcnoxVmpia2EwTWVrT0dSWlFFdnFRRmx4c2VGb3I4eldGZ0hlazN2MjkrV3FONmdhSzVnWk9UT01aenBRSUMxMjAxTGtNQ1hpbGQzdldYU2M1VVg5eGNGWWZiUlB6R0ZhMUZEY1BmUEIvalVFcS9GZUd0NDE5Q0kzWW1CbFZvSHNhNEtkY3dRUDVaU3dISGhGSjcvUGgvUmFwLzR2bUc5MWVEd1BQMGxEZkNEUkNMc3pUcWZ6TTcxeHBtaUtpMkh3UzRXbHF2R053dHZ3RjVEcXBuNktUcThheDAwVU1Qa3hEY1pyRUVFc0l2SGlVWFhFcGhkYjRHQjRGeW1sUHdCejRHcGVycXE1cFc3VFE2L3lOUmhXOFZUNU5odVAwdWRseG80Z0lMcTVaeEFaazhaR2gzZzRDcXhKbFBLWTdBUXh1cGZVY1ZwV1Q1Vkl0cDErMzBVcW95UDR3V3NSbzNvbFJSZ2tXWloyWk42VkMzT1pGZVhCOE5iblVyU2Rpa05wdEQxUWlHdUtrcjhFbVNSL0FLOVJ3K0ZGM3M1dXd1UGJ2SEdpUGVGT1ZpbHRNSzdBVWFPc3E5K3g5Y25kazNpSkVFNUxLWlJsV0piS09ad2VST3ptUE5WUGtqRTNLL1R5QTU3UnM2OFRrWjNNUjhha0twbTdjRmpualBkL0Rka1dqZ1lvS0hTcjVXdTVzc29CWVU0YWNSczVnMkRIeFVtZHE4VlhPWFJidW5EOFFOMExoZ2tzc2dhaGNkb1lzTnZ1WEdVSy9LWEQvN29GYitWR2RocUluMDJ2ZXVNNWJMdWRKT2MyS3kwR01hRzRXL3hXQnhJSmNMN3lsaUpPWE9weDBBa0JxVWd6bERjem1MVDRpSUxYRHh4dFJSMW9aYTJKV0ZnaUFiNDNvYnJKbkcvVFpDMktTSzJ3cU96UlpUWGF2WlpGTWIxZjNiWHZWYU5hSzgyOHc5VE82MTBnazhKTmYzZ01mRVR6WFhzYmN2UkdDRzlKV1FaNitjRFBxYzQ0NjZZbzJSY0tIK1BJTGVLT3F0bmxiSW5SM01tQmVHRzNGSDEweXpreWJ1cUVDMkhTUXdwQTBBbjdkOSs3M0JrRFVUbTMwYlptb1AvUkdiZ0ZOK0dyQ09mQURncXIwV2JJMWExb2twRm1zOGlIWXc5aG0welV2bEVNaXZCUnhNb2RyYkpKKzkvcDNqVWRRUTlCQ3RRZHhuT0dyVDVkelJVbXcwNTkzL21iUlNkQmcwblJ2UlpNNS9FMTZtN1pIbURFdFdod3ZmZFpDWjhKOE0xMlcweVJNc3pYYW1XZlFUd0laNGF5WWt0cm5zY1F1V3I4aWRwM1BqVDJlRi9qbXRkaElmY3BNbmIrSWZaWTJGZWJXNlVZL0FLM2pQNHUzVHU0ekU0cWxuUWdMRmJNMTlFQklzTmY3S2hqZGJxUS9ENnlpRGIrTmxFaTJTS0QraXZYVlVLOGliMG9CbzM2NmdYa1I4WnhHanBKSURjRWdaUGE5VGNZZTBUSWJpUGwvclBVUUR1M1hCSjlYL0dOcTNGQVVzS3NsbDU3RHphR01yamNUK2djdHArOU1MWVhDcStzcVA4MWVWUTByOWx0K2djUWZaYkFDUmJFanZsTXNrenRaRzhnYkM4UW45dHQyNlE3eTduRHJiWnEvTEV6N2tSNkpjNnBnM045clZYOFk1TUpyR2xNTDlwOWxVNGpiVGtLcUN2ZWVaVUpqSEIwM20yS1JLUjJUeXRvRmtUWE9MZzdrZVUxczFsclBNUUpwb09LTHVBQUMreTFIbEp1Y1U2eXNCNWhzWGh2U1BQTHE1SjdKdG5xSEtaNHZZakM0Vnk4MTUzUVkrNjc4MHhEdUdBUnNHYk9zMVdxekgwUVM3NjVyblNLRWJiS2xrTzhvSS9WRHdVZDBpczEzdEtwcUlMdTFtREpGTnkvaUpBV2N2RGdqeHZ1c0lUK1BHejNTVC9KOXI5TXRmZDBqcGFHZWlMWUlxWGM3RGlIU1M4VGNqRlZrc2k2NlBFa3hXMXo2dWpiTExVR05OWW56T1dwSDhCWkdLNGJDSzdpUitNYkl2OG5jREF6MXU0U3ROM3ZUVHpld3I5SVFqazl3eEZ4bis2TjFkZEtzMHZmZkppUzA4TjNhNEcxU1ZybFo5N1EvTSs4RzlmZTVBUDZkOS9RcTRXUm5PUlZob2ZQSUtFZENyM2xsc3BVZkUwb0tJSVlvQnlCUlBoK2JYMUhMUzNKV0dKUmhJdkUxYVc0TlRkOGVQaTRaK2tYYitaOHNuWWZTTmNxaWpoQWdWc3g0UkNNNTRjWFVpWWtqZUJtbUM0YWpPSHJDaG9FTHNjSkpDNys5ampNanc1QmFnWktsZ1JNaVNOWXo3aDd2dlpJb1FxYnRRbXNwYzBjVWsxRy83M2lYdFNwUk9sNXd0TGdRaTBtVzJFeDhpM1dVTGhjZ2d4NkUxTE1WSFVzZGM5R0hJMVBIM1UyS28wUHlHZG45S2RWT0xtN0ZQQnVpMGk5YTBIcEE2ME1zZXdWRTR6OENBdDVkNDAxR3Y2elhsSVQ1WWJpdDFWSUEwRkNzN3d0dllyZXJ1MWZVeVczb0xBWi8rYVRuWnJPY1lSTlZBOHNwb1J0bFJvV2Zsc1JDbEZjZ3prcWlIT3JmMC9TVncrRXBWYUZsSjBnNEt4cTFNTU9taVFkcE1OcHRlOGxNTVFxbTZjSUZYbG5HYmZKbGx5c0tEaSswSkpNb3RrcWdJeE9TUWdVOWRuL2xXa2VWZjhuVW0zaXdYMk5sM1dEdzlpNkFVSzN2QkFiWlpyY0pwRFEvTjY0QVZ3alQwN0plZjMwR1NTbXROdTJXbFc3WW95VzJGbFdmWkZRVXdrODY3RWRMWUtrOVZHNkpnRW5CaUJ4a1k3TE1vNFlMUUpKbEFvOWwvb1R2SmtTQVJERi9YdHlBek04TzJ0M2VUL2lYYTZ3RE4zV2V3Tm1RSGRQZnN4Q2hVL0t0TEcyTW44aTRacUtkU2xJYUJaYWR4Sm1SelZTL280eUE2NVJUU1ZpcTYwb2EzOTVMcXcwcHpZNFNpcHdFMFNYWHNLVitHWnJhR1Nrci9SVzA4d1BSdnF2U1VrWUJNQTlsUHg0bTI0YXorSUhtQ2JYQSswZmF4VFJFOXd1R2VPMDZESVhhNlFsS0ozcHVJeWl1QVZmUHI3MzZ2em8ycEJpclMrVnhlbDNUTW0zSktoejlvMlpvUnZhRlZwSWt5a2IwSGNtNG9IRkJNY05TTmo3LzRHSnQ0M29nb25ZMlZnNG5zRFFJV3hBY29ycFhBQ3pnQnFRUGpZc0UvVlVwWHB3Tk1hbkVydTROd01DRlBrWHZNb3F2b2VMTjNxeXUvTjFlV0VIdHRNRDY1djE5bC8wa0gybVIzNWl2L0ZJK3lqb0hKOWdQTXo2N2FmM01xL0JvV1hxdTNycGhpV01YVmttblBTRWtwR3BVSTJoMU1UaGlkZUdGRU9LNllaSFB3WXpNQnZwTkM3K1pIeFBiN2VwZmVmR3lJQjRKek85RFRORVluRExWVkhkUXl2T0VWZWZyazZVdjVrVFFZVllXV2RxcmRjSWw3eWxqd3dJV2RmUS95KzJRQjNlUi9xeFlPYnVZeUI0Z1RibzJpbjRQemFyVTFzTzluRVRrbWo5L0FveERBK0pNM0dNcVF0SlI0anRkdUh0bm9DTHhkMWdRVXNjSFJCL01vUllJRXNQMnBEWjlLdkhndGxrMWlUYldXYkhob2h3RkVZWDd5NTFmVVYybnVVbW5vVWNxbldJUUFBZ2w5TFRWWCtCYzBRR05FaENoeEhSNFlqZkU1MVBVZEdmc1NGRTZjazdCTDMvaFRmOWpMcTRHMUlhZklOeE9MS2VBdE83cXV1bFl2SDVZT0JjK3pYN0NyTWdXblc0Ny9qZlJzV25KallZb0U3eE1mV1YySE4yaXlJcUxJJztcbmNvbnN0IEZFTkNFRCA9IG5ldyBNYXAoW1s4MjE3LFwiYXBvc3Ryb3BoZVwiXSxbODI2MCxcImZyYWN0aW9uIHNsYXNoXCJdLFsxMjUzOSxcIm1pZGRsZSBkb3RcIl1dKTtcbmNvbnN0IE5TTV9NQVggPSA0O1xuXG5mdW5jdGlvbiBkZWNvZGVfYXJpdGhtZXRpYyhieXRlcykge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdGZ1bmN0aW9uIHUxNigpIHsgcmV0dXJuIChieXRlc1twb3MrK10gPDwgOCkgfCBieXRlc1twb3MrK107IH1cclxuXHRcclxuXHQvLyBkZWNvZGUgdGhlIGZyZXF1ZW5jeSB0YWJsZVxyXG5cdGxldCBzeW1ib2xfY291bnQgPSB1MTYoKTtcclxuXHRsZXQgdG90YWwgPSAxO1xyXG5cdGxldCBhY2MgPSBbMCwgMV07IC8vIGZpcnN0IHN5bWJvbCBoYXMgZnJlcXVlbmN5IDFcclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IHN5bWJvbF9jb3VudDsgaSsrKSB7XHJcblx0XHRhY2MucHVzaCh0b3RhbCArPSB1MTYoKSk7XHJcblx0fVxyXG5cclxuXHQvLyBza2lwIHRoZSBzaXplZC1wYXlsb2FkIHRoYXQgdGhlIGxhc3QgMyBzeW1ib2xzIGluZGV4IGludG9cclxuXHRsZXQgc2tpcCA9IHUxNigpO1xyXG5cdGxldCBwb3NfcGF5bG9hZCA9IHBvcztcclxuXHRwb3MgKz0gc2tpcDtcclxuXHJcblx0bGV0IHJlYWRfd2lkdGggPSAwO1xyXG5cdGxldCByZWFkX2J1ZmZlciA9IDA7IFxyXG5cdGZ1bmN0aW9uIHJlYWRfYml0KCkge1xyXG5cdFx0aWYgKHJlYWRfd2lkdGggPT0gMCkge1xyXG5cdFx0XHQvLyB0aGlzIHdpbGwgcmVhZCBiZXlvbmQgZW5kIG9mIGJ1ZmZlclxyXG5cdFx0XHQvLyBidXQgKHVuZGVmaW5lZHwwKSA9PiB6ZXJvIHBhZFxyXG5cdFx0XHRyZWFkX2J1ZmZlciA9IChyZWFkX2J1ZmZlciA8PCA4KSB8IGJ5dGVzW3BvcysrXTtcclxuXHRcdFx0cmVhZF93aWR0aCA9IDg7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHJlYWRfYnVmZmVyID4+IC0tcmVhZF93aWR0aCkgJiAxO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgTiA9IDMxO1xyXG5cdGNvbnN0IEZVTEwgPSAyKipOO1xyXG5cdGNvbnN0IEhBTEYgPSBGVUxMID4+PiAxO1xyXG5cdGNvbnN0IFFSVFIgPSBIQUxGID4+IDE7XHJcblx0Y29uc3QgTUFTSyA9IEZVTEwgLSAxO1xyXG5cclxuXHQvLyBmaWxsIHJlZ2lzdGVyXHJcblx0bGV0IHJlZ2lzdGVyID0gMDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgfCByZWFkX2JpdCgpO1xyXG5cclxuXHRsZXQgc3ltYm9scyA9IFtdO1xyXG5cdGxldCBsb3cgPSAwO1xyXG5cdGxldCByYW5nZSA9IEZVTEw7IC8vIHRyZWF0IGxpa2UgYSBmbG9hdFxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdmFsdWUgPSBNYXRoLmZsb29yKCgoKHJlZ2lzdGVyIC0gbG93ICsgMSkgKiB0b3RhbCkgLSAxKSAvIHJhbmdlKTtcclxuXHRcdGxldCBzdGFydCA9IDA7XHJcblx0XHRsZXQgZW5kID0gc3ltYm9sX2NvdW50O1xyXG5cdFx0d2hpbGUgKGVuZCAtIHN0YXJ0ID4gMSkgeyAvLyBiaW5hcnkgc2VhcmNoXHJcblx0XHRcdGxldCBtaWQgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xyXG5cdFx0XHRpZiAodmFsdWUgPCBhY2NbbWlkXSkge1xyXG5cdFx0XHRcdGVuZCA9IG1pZDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFydCA9IG1pZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHN0YXJ0ID09IDApIGJyZWFrOyAvLyBmaXJzdCBzeW1ib2wgaXMgZW5kIG1hcmtcclxuXHRcdHN5bWJvbHMucHVzaChzdGFydCk7XHJcblx0XHRsZXQgYSA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnRdICAgLyB0b3RhbCk7XHJcblx0XHRsZXQgYiA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnQrMV0gLyB0b3RhbCkgLSAxO1xyXG5cdFx0d2hpbGUgKCgoYSBeIGIpICYgSEFMRikgPT0gMCkge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSAmIE1BU0sgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgJiBNQVNLO1xyXG5cdFx0XHRiID0gKGIgPDwgMSkgJiBNQVNLIHwgMTtcclxuXHRcdH1cclxuXHRcdHdoaWxlIChhICYgfmIgJiBRUlRSKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyICYgSEFMRikgfCAoKHJlZ2lzdGVyIDw8IDEpICYgKE1BU0sgPj4+IDEpKSB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSBeIEhBTEY7XHJcblx0XHRcdGIgPSAoKGIgXiBIQUxGKSA8PCAxKSB8IEhBTEYgfCAxO1xyXG5cdFx0fVxyXG5cdFx0bG93ID0gYTtcclxuXHRcdHJhbmdlID0gMSArIGIgLSBhO1xyXG5cdH1cclxuXHRsZXQgb2Zmc2V0ID0gc3ltYm9sX2NvdW50IC0gNDtcclxuXHRyZXR1cm4gc3ltYm9scy5tYXAoeCA9PiB7IC8vIGluZGV4IGludG8gcGF5bG9hZFxyXG5cdFx0c3dpdGNoICh4IC0gb2Zmc2V0KSB7XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIG9mZnNldCArIDB4MTAxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDE2KSB8IChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAyOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiBvZmZzZXQgKyBieXRlc1twb3NfcGF5bG9hZCsrXTtcclxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIHggLSAxO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHRcclxuXHJcbi8vIHJldHVybnMgYW4gaXRlcmF0b3Igd2hpY2ggcmV0dXJucyB0aGUgbmV4dCBzeW1ib2xcclxuZnVuY3Rpb24gcmVhZF9wYXlsb2FkKHYpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRyZXR1cm4gKCkgPT4gdltwb3MrK107XHJcbn1cclxuZnVuY3Rpb24gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQocykge1xyXG5cdHJldHVybiByZWFkX3BheWxvYWQoZGVjb2RlX2FyaXRobWV0aWModW5zYWZlX2F0b2IocykpKTtcclxufVxyXG5cclxuLy8gdW5zYWZlIGluIHRoZSBzZW5zZTpcclxuLy8gZXhwZWN0ZWQgd2VsbC1mb3JtZWQgQmFzZTY0IHcvbyBwYWRkaW5nIFxyXG4vLyAyMDIyMDkyMjogYWRkZWQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzRcclxuZnVuY3Rpb24gdW5zYWZlX2F0b2Iocykge1xyXG5cdGxldCBsb29rdXAgPSBbXTtcclxuXHRbLi4uJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXS5mb3JFYWNoKChjLCBpKSA9PiBsb29rdXBbYy5jaGFyQ29kZUF0KDApXSA9IGkpO1xyXG5cdGxldCBuID0gcy5sZW5ndGg7XHJcblx0bGV0IHJldCA9IG5ldyBVaW50OEFycmF5KCg2ICogbikgPj4gMyk7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIHdpZHRoID0gMCwgY2FycnkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjYXJyeSA9IChjYXJyeSA8PCA2KSB8IGxvb2t1cFtzLmNoYXJDb2RlQXQoaSldO1xyXG5cdFx0d2lkdGggKz0gNjtcclxuXHRcdGlmICh3aWR0aCA+PSA4KSB7XHJcblx0XHRcdHJldFtwb3MrK10gPSAoY2FycnkgPj4gKHdpZHRoIC09IDgpKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gZWcuIFswLDEsMiwzLi4uXSA9PiBbMCwtMSwxLC0yLC4uLl1cclxuZnVuY3Rpb24gc2lnbmVkKGkpIHsgXHJcblx0cmV0dXJuIChpICYgMSkgPyAofmkgPj4gMSkgOiAoaSA+PiAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9kZWx0YXMobiwgbmV4dCkge1xyXG5cdGxldCB2ID0gQXJyYXkobik7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHggPSAwOyBpIDwgbjsgaSsrKSB2W2ldID0geCArPSBzaWduZWQobmV4dCgpKTtcclxuXHRyZXR1cm4gdjtcclxufVxyXG5cclxuLy8gWzEyM11bNV0gPT4gWzAgM10gWzEgMV0gWzAgMF1cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWQobmV4dCwgcHJldiA9IDApIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB4ID0gbmV4dCgpO1xyXG5cdFx0bGV0IG4gPSBuZXh0KCk7XHJcblx0XHRpZiAoIW4pIGJyZWFrO1xyXG5cdFx0cHJldiArPSB4O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0cmV0LnB1c2gocHJldiArIGkpO1xyXG5cdFx0fVxyXG5cdFx0cHJldiArPSBuICsgMTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWRfYXJyYXlzKG5leHQpIHtcclxuXHRyZXR1cm4gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IFxyXG5cdFx0bGV0IHYgPSByZWFkX3NvcnRlZChuZXh0KTtcclxuXHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHY7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIHJldHVybnMgbWFwIG9mIHggPT4geXNcclxuZnVuY3Rpb24gcmVhZF9tYXBwZWQobmV4dCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCk7XHJcblx0XHRpZiAodyA9PSAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB3ID0gbmV4dCgpIC0gMTtcclxuXHRcdGlmICh3IDwgMCkgYnJlYWs7XHJcblx0XHRyZXQucHVzaChyZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldC5mbGF0KCk7XHJcbn1cclxuXHJcbi8vIHJlYWQgdW50aWwgbmV4dCBpcyBmYWxzeVxyXG4vLyByZXR1cm4gYXJyYXkgb2YgcmVhZCB2YWx1ZXNcclxuZnVuY3Rpb24gcmVhZF9hcnJheV93aGlsZShuZXh0KSB7XHJcblx0bGV0IHYgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KHYubGVuZ3RoKTtcclxuXHRcdGlmICgheCkgYnJlYWs7XHJcblx0XHR2LnB1c2goeCk7XHJcblx0fVxyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyByZWFkIHcgY29sdW1ucyBvZiBsZW5ndGggblxyXG4vLyByZXR1cm4gYXMgbiByb3dzIG9mIGxlbmd0aCB3XHJcbmZ1bmN0aW9uIHJlYWRfdHJhbnNwb3NlZChuLCB3LCBuZXh0KSB7XHJcblx0bGV0IG0gPSBBcnJheShuKS5maWxsKCkubWFwKCgpID0+IFtdKTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkrKykge1xyXG5cdFx0cmVhZF9kZWx0YXMobiwgbmV4dCkuZm9yRWFjaCgoeCwgaikgPT4gbVtqXS5wdXNoKHgpKTtcclxuXHR9XHJcblx0cmV0dXJuIG07XHJcbn1cclxuIFxyXG4vLyByZXR1cm5zIFtbeCwgeXNdLCBbeCtkeCwgeXMrZHldLCBbeCsyKmR4LCB5cysyKmR5XSwgLi4uXVxyXG4vLyB3aGVyZSBkeC9keSA9IHN0ZXBzLCBuID0gcnVuIHNpemUsIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSB7XHJcblx0bGV0IGR4ID0gMSArIG5leHQoKTtcclxuXHRsZXQgZHkgPSBuZXh0KCk7XHJcblx0bGV0IHZOID0gcmVhZF9hcnJheV93aGlsZShuZXh0KTtcclxuXHRsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZCh2Ti5sZW5ndGgsIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0uZmxhdE1hcCgodiwgaSkgPT4ge1xyXG5cdFx0bGV0IFt4LCAuLi55c10gPSB2O1xyXG5cdFx0cmV0dXJuIEFycmF5KHZOW2ldKS5maWxsKCkubWFwKChfLCBqKSA9PiB7XHJcblx0XHRcdGxldCBqX2R5ID0gaiAqIGR5O1xyXG5cdFx0XHRyZXR1cm4gW3ggKyBqICogZHgsIHlzLm1hcCh5ID0+IHkgKyBqX2R5KV07XHJcblx0XHR9KTtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJuIFtbeCwgeXMuLi5dLCAuLi5dXHJcbi8vIHdoZXJlIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpIHsgXHJcblx0bGV0IG4gPSAxICsgbmV4dCgpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKG4sIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0ubWFwKHYgPT4gW3ZbMF0sIHYuc2xpY2UoMSldKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlYWRfdHJpZShuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBzb3J0ZWQgPSByZWFkX3NvcnRlZChuZXh0KTsgXHJcblx0ZXhwYW5kKGRlY29kZShbXSksIFtdKTtcclxuXHRyZXR1cm4gcmV0OyAvLyBub3Qgc29ydGVkXHJcblx0ZnVuY3Rpb24gZGVjb2RlKFEpIHsgLy8gY2hhcmFjdGVycyB0aGF0IGxlYWQgaW50byB0aGlzIG5vZGVcclxuXHRcdGxldCBTID0gbmV4dCgpOyAvLyBzdGF0ZTogdmFsaWQsIHNhdmUsIGNoZWNrXHJcblx0XHRsZXQgQiA9IHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4geyAvLyBidWNrZXRzIGxlYWRpbmcgdG8gbmV3IG5vZGVzXHJcblx0XHRcdGxldCBjcHMgPSByZWFkX3NvcnRlZChuZXh0KS5tYXAoaSA9PiBzb3J0ZWRbaV0pO1xyXG5cdFx0XHRpZiAoY3BzLmxlbmd0aCkgcmV0dXJuIGRlY29kZShjcHMpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4ge1MsIEIsIFF9O1xyXG5cdH1cclxuXHRmdW5jdGlvbiBleHBhbmQoe1MsIEJ9LCBjcHMsIHNhdmVkKSB7XHJcblx0XHRpZiAoUyAmIDQgJiYgc2F2ZWQgPT09IGNwc1tjcHMubGVuZ3RoLTFdKSByZXR1cm47XHJcblx0XHRpZiAoUyAmIDIpIHNhdmVkID0gY3BzW2Nwcy5sZW5ndGgtMV07XHJcblx0XHRpZiAoUyAmIDEpIHJldC5wdXNoKGNwcyk7IFxyXG5cdFx0Zm9yIChsZXQgYnIgb2YgQikge1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBici5RKSB7XHJcblx0XHRcdFx0ZXhwYW5kKGJyLCBbLi4uY3BzLCBjcF0sIHNhdmVkKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxuXG5mdW5jdGlvbiBoZXhfY3AoY3ApIHtcclxuXHRyZXR1cm4gY3AudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoMiwgJzAnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVvdGVfY3AoY3ApIHtcclxuXHRyZXR1cm4gYHske2hleF9jcChjcCl9fWA7IC8vIHJhZmZ5IGNvbnZlbnRpb246IGxpa2UgXCJcXHV7WH1cIiB3L28gdGhlIFwiXFx1XCJcclxufVxyXG5cclxuLypcclxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxvZGVfY3Aocykge1xyXG5cdHJldHVybiBbLi4uc10ubWFwKGMgPT4gYy5jb2RlUG9pbnRBdCgwKSk7XHJcbn1cclxuKi9cclxuZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7IC8vIHRoaXMgaXMgYWJvdXQgMnggZmFzdGVyXHJcblx0bGV0IGNwcyA9IFtdO1xyXG5cdGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IHMubGVuZ3RoOyBwb3MgPCBsZW47ICkge1xyXG5cdFx0bGV0IGNwID0gcy5jb2RlUG9pbnRBdChwb3MpO1xyXG5cdFx0cG9zICs9IGNwIDwgMHgxMDAwMCA/IDEgOiAyO1xyXG5cdFx0Y3BzLnB1c2goY3ApO1xyXG5cdH1cclxuXHRyZXR1cm4gY3BzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJfZnJvbV9jcHMoY3BzKSB7XHJcblx0Y29uc3QgY2h1bmsgPSA0MDk2O1xyXG5cdGxldCBsZW4gPSBjcHMubGVuZ3RoO1xyXG5cdGlmIChsZW4gPCBjaHVuaykgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcyk7XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyApIHtcclxuXHRcdGJ1Zi5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcy5zbGljZShpLCBpICs9IGNodW5rKSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlX2FycmF5cyhhLCBiKSB7XHJcblx0bGV0IG4gPSBhLmxlbmd0aDtcclxuXHRsZXQgYyA9IG4gLSBiLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgYyA9PSAwICYmIGkgPCBuOyBpKyspIGMgPSBhW2ldIC0gYltpXTtcclxuXHRyZXR1cm4gYztcclxufVxuXG4vLyBjcmVhdGVkIDIwMjMtMDktMjVUMDE6MDE6NTUuMTQ4WlxuLy8gY29tcHJlc3NlZCBiYXNlNjQtZW5jb2RlZCBibG9iIGZvciBpbmNsdWRlLW5mIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogYTk3NGI2Zjg1NDFmYzI5ZDkxOWJjODUxMThhZjBhNDQwMTU4NTFmYWI1MzQzZjg2NzljYjMxYmUyYmRiMjA5ZVxudmFyIENPTVBSRVNTRUQgPSAnQUVVRFRBSEJDRlFBVFFEUkFEQUFjZ0FnQURRQUZBQXNBQlFBSHdBT0FDUUFEUUFSQUFvQUZ3QUhBQklBQ0FBUEFBVUFDd0FGQUF3QUJBQVFBQU1BQndBRUFBb0FCUUFJQUFJQUNnQUJBQVFBRkFBTEFBSUFDd0FCQUFJQUFRQUhBQU1BQXdBRUFBc0FEQUFNQUF3QUNnQU5BQTBBQXdBS0FBa0FCQUFkQUFZQVp3RFNBZHNESmdDMENrTUI4eGhaQXFmb0MxOTBVR2NUaGdCdXJ3ZjdQVDA5UGIwOUFqZ0p1bThPakRsbHhIWVVLWEFQeHpxNnRBQkF4Z0s4eXNVdldBZ01QVDA5UFQwOVBTczZMVDJIY2dXWFd3RkxvU01FRUVsNVJGVk1Ldk8wWFE4RXhEZEpNbklnc2oyNlBUUXl5OEZmRVE4QVk4SVBBR2NFYndSd0JIRUVjZ1J6QkhRRWRRUjJCSGNFZUFSNkJIc0VmQVIrQklBRWdmbmRCUW9CWWdVTEFXSUZEQUZpQk5jRTJBVFpCUkFGRVFVdkJkQUxGQXNWRFBjTkJ3MTNEWWNPTUE0eERqTUI0QmxsSEkwQjJncmJBTURwSExrUTdRSFZBUFJOUVFGbkdSVUVnMHlFQjJ1YUpGOEFKcElCcG9iNUFFUlNNQUtOb0FYcWFRTFVCTUN6RWlBQ253UlpFa2tWc1M3dEFOQXNCRzBSdUFRTEVQQUJ2OUhJQ1RVQlhpZ1Bad1JCQXBNRE93QWFtaHRhQUJxRUFZOEt2S3gzTFE0QXJBQjhVaHdFQkFWU2FnRDhBRUZaQURrQklhZFZqMlVNVWd4NUlsNEFOUUM5QXhJQjFCbGJFUE1BczMwQ0d4bFhBaHdaS1FJRUNCYzZFYnNDb3huZ3p2N1V6UlFBOE0wQmF3TDZad2tON3dBQkFEMzNPUVJjc2dMSkNqTUNqcVVDaHR3L2ttK05Bc1hQQW9QMkJUODRQd1VSQUswUkF2cHRiNmNBcFFTL09NTWV5NUhKUzg0VWR4cHhUUGtDb2dWRklUYVRPd0VSQUs1cEF2a05CT1Z5QTdxM0JLbE9KU0FMQWdVSUJSY0VkQVNwQlhxekFCWEZTV1pPYXdMQ09xdy8vQW9sQ1pkdnYzZFNCa0VRR3llbEVQY01Nd0cxQVRzTjdVdllCUEVHT3dUSkgzMFpHUS9ObFp3SXBTM2RETzBtNHk2aGdGb2o5U3FEQmUxTDlEemRDMDFSYUE5WkMyVUo0enBqZ1U0RElRRU5Jb3NLM1EwNUNHMFE4d3JKYXczbEVVVUhPUVBWU1pvQXBRY0JDeEVkTlJXMUpoQmlyQXNKT1hjRyt4cjJDNDhtcnhNcGV2d0YweG9oQmswQktSci9BTTh1NTRXd1dqRmNIRTlmQmdNTEpTUEhGS2hRSUEwbFFMZDRTQm9iQnhVbHFRS1JRM0JLaDFFMkhwTWg5anc5RFdZdUUxRjhCL1U4QlJsUEM0RThua2FyUlE0UjBqNk5QVWdpU1V3c0JEVi9MQzhuaXduUEQ0VU11WHh5QVZrSklRbXhESEVUTVJFWE44VUlPUWNaTFpja0p4VUlJVWFWWUpvRTk1OEQ4eFBSQXdzRlB3bEJCeE1EdFJ3dEV5NFZLUVVOZ1NUWEF2TTIxUzZ6QW85V2dBRVhCY3NQSlIvZkVGQkg0QTdwQ0pzQ1pRT0RKZXNBTFJVaEFCY2ltd2hEWXdCZmo5aFRCUzdMQ01kcWJDTjBBMmNVNTJFUmN3ZVJEbGNIcHh3ekZiOGM0WERJWGd1R0NDaWpyd2xiQVhVSm1RRmZCT01JQ1RWYmpLQWdRV2RUaTFnWW15QmhRVDlkL0FJeERHVVZuMFM5aDNnQ2l3OXJFaHNCTlFGekJ6a05BUUozRWUwUmF4Q1ZDT3VHQkRXMU0vZzZKUVJQSVlNZ0VRb25BMDlzemdzbkp2a00rR2tCb3hKaUF3dzBQWGZ1WjZ0Z3RpUVgvUWNaTXNWQllDSHhDNUpQelF5Y0dzRVlRbFF1R2VRSHZ3UHpHdk1uNmtGWEJmOERvd01UT2swejdnUzlDMmtJaXdrL0FFa09veGNIMXhocUNuR00wQUV4aXdHM21RTlhrWU1DYjQ4R053Y0xBR2NMaHdWNTVRQWRBcWNJb3dBRkFNOERWd0E1QXEwSG5RQVpBSVZCQVQwREp5OEJJZVVDandPVENESExBWlV2QWZNcEJCdkREQlVBOXpkdVNnTERzUUtBYW1haUJkMVlBbzRDU1RVQlRTVUVCVTVIVVFPdmNlRUEyd0JMQmhQZlJ3RVZxMHJMR3VOREFkOXZLd0RIQVBzQUJUVUhCVUVCelFIemJRQzNBVjhMTVFtaXM3VUJUZWtwQUlNQUZXc0Ixd0tKQU4wQU5RQi84UUZUQUUwRldma0Ywd0pQU1FFUk1SZ3JWMkVCdXdNZkFUTUJEUUI1QnN1TnBja0hId1J0QjlNQ0VCc1Y0UUx2TGdlMUFRTWkzeFBOUXNVQ3ZkNVZvV0FDWklFQ1lrSmJUYTliTnlBQ29mY0NhSmdDWmdrQ240UTRHd3NDWmpzQ1ppWUViZ1IvQTM4VEEzNlNPUVk1ZHhjNWdqb2pJd0pzSFFJeU5qZ0tBbTNIQW0ydTc0b3paMFVyQVdjQTNnRGhBRW9GQjVnTWpRRCtDOElBRGJVQ2R5OENkcUkvQW5sTFF3SjR1aDFjMjBXdVJ0Y0NmRDhDZXNnQ2ZRa0NmUEFGV1FVZ1NBQklmV01rQW9GdEFvQUFBb0FGQW4rdVNWaEtXeFVYU3N3QzBRRUMwTXhMSndPSVR3T0g1a1RGa1RJQzhxRmRBd01Ecmt2T1RDMGxBODlOVEUydkFvcy9Bb3JZd1JzSEhVTm5CYmNDampjQ2pseEFsNEVDanRrQ2pseDRVYlJUTlFwUzFGU0ZBcFA3QXBNTUFPa0FIRlVlVmE5VjBBWXNHeW1WaGpMaGVHWkZPemtDbDU4Qzc3SllJYWdBV1NVQ2xvOENsbnljQUtsWnJGb0pnVTBBT3dLV3RRS1dUbHhFWE5FQ21jc0NtV1JjeWwwSEdRS2Ntem5DT3AwQ25CWUNuNXNDbnJpS0FCMFBNU29QQXAzeEFwNlNBTFU5WVRSaDd3S2Uwd0tnYmdHcEFwNmZId0tlVHFWanlHUW5KU3NDSjY4Q0puNENvUHNDb0V3Q290MENvY1FDcGk4Q3BjNENwLzhBZlFLbjhtaDhhTEVBQTBscUhHclJBcXpqQXF5dUFxMW5BcTBDQWxjZEFsWGNBckhoMXdNZlRteVhBcks5RFFLeTZCZHM0RzFqYlVoZkF5WE5BclpjT3o5dWtBTXBSUUs0WGdLNVJ4VUN1U3AzY0RadzRRSzlHUUs3Mm5DV0F6SVJBcjZJY2dJRE0zRUN2aHB6SW5OUEFzUExBc01FYzRKMFN6VkZkT0FEUEtjRFBKb0RQYjhDeFh3Q3hrY0N4aENKQXNocFVRTElSQUxKVHdMSkxnSmtuUUxkMG5oNVlYaXVlU1ZMMEFNWW8yY0NBbUgwR2ZPVkpIc0xYcEpldXhFQ3oyc0N6Mnd2UzFQUzh4T2ZBTWF0QXM5ekFTbnFBMDRTZmtzRkF0d25BdHVLQXRKUEExSmNBMU5mQVFFRFZZeUFpVDhBeXhidFlFV0NISUxUZ3M2RGpRTGF4d0xaM29RUWhFbW5QQU9HcFFBdkEyUU9obkZaK1FCVkF0OWxBdDY0YzNjQzRpL3RGQUh6TUNjQjlKc0I4dEtIQXV2ekF1bHdlUUxxK1FMcTVBRDVSd0c1QXU2SkF1dWNscXFYQXdMdVB3T0Y0Smg1Y09CeG9RTHpBd0JwQTQ0V21aTUM5eE1Ea1c0RGtvY0M5NWdDK2RrQytHYWFISnFydXplYkhnT2Rnd0wrK2dFYkFEbWZISit6QXdXTkE2WnFBNmJaQU5IRkF3WnFvWWlpQlFrRERFa0N3QUEvQXdEaFFSZFRBUkh6QTJzSGwyY0ZBSk10SzdldnZkc0JpWmtVZnhFRU9RSDdLUVVoRHAwSm53Q1MvU2xYeFFMM0FaMEF0d1c1QUc4TGJVRXVGQ2FOTGdGREFZRDhBYlVtQUhVRERnUnRBQ3dDRmd5aEFBQUtBajBDYWdQZEEzNEVrUUVnUlFVaGZBb0FCUUJFQUJNQU5oSUNkd0VBQmRVRGErOEt4UUlBOXdxZko3K3h0K1VCa1NGQlFnSHBGSDhSTk1DSkFBUUFHd0JhQWtVQ2hJc0FCanBUT3BTTmJRQzRPbzg2MEFDTk9NRTYzQUNsQU9nQXl3RTZnVG83T2Z3NStUdDJpVHBiTzU2Sk9tODVHQUZXQVRNQmJBVXZOVjAxbmpXdE5XWTFkVFcyTmNVMWdqV1JOZEkxNFRXZU5hMDE3alg5TmJJMXdUWUNOaEUxeGpYVk5oWTJKelhlTmUwMkxqWTlOaTQxTFNFMk9qWTlOancyeVRjSUJKQThWelk0TnQwM0lEY1BOc29nTjRrM01Bb0VzRHhuTmlRM0dUZHNPbzAzSVVMVVF3ZEM0RU1MSEE4UENac29iU2hSVlFZQTZYOEE2YkFCRkNuWEF1a0Jvd0M5QmJjQWJ3TnpCTDhNREFNTUFRZ0RBQWtLQ3dzTENRb0dCQVZWQkkvRHZ3RHo5YjI5a2FVQ2IwUXRzUlROTHQ0ZUdCY1NIQU1aRmhZWkVoWUVBUkFFQlVFY1FSeEJIRUVjUVJ4QkhFRWFRUnhCSEVGQ1NUeEJQRWxJU1VoQk5rTTJRVFliTmtsSVNWbUJWSWdCRkxXWkF1MEJoUUNqQmNFQWJ5a0J2d0dKQWFRY0VaMGVQQ2tsTUFBaE12QUlNQUw1NGdDN0JtOEVlc2NqelFNcEFSUXBLZ0RVQUJhdkFqNjI2eFFBSlAwQTNldHp1ZjROTlJBN2VmeTJaOU5RckNuQzBPU3lBTno1QkJJYko1SUZEUjZtaUlhdllTNnRwcmpqbXVLZWJ4bTVDNzRRMjI1WDFwa2FZWVBiNmYxREs0azN4TUVCYjlTMldNakVpYlROV2hzUkpJQSt2d05WRWlYVEU1aVhzL3dlelY2Nm9GTGZwOU5aR1lXK0drMTlKMitiQ1Q2WWUydzZMRFlkZ3pLTVVhYms1OTVlTEJDWEFOejlIVXBXYkFUcTl2cVhWeDlYRGcrUGM5WHA0K2JzUzAwNVNWTS9CSkJNNDY4N1dVdWYrVWo5ZEVpOGFETmFQeHRwYkR4Y0cxVEhUSW1VTVpxNFVDYWFOWXBzVnFyYU55S0xKWERZc0ZaLzVqbDdiTFJ0Tzg4dDdQM3haYUF4aGI1T2RQTVhxc1NrcDFXQ2llRzhqWG0xVTk5K2JsdkxsWHpQQ1MrTTkzVm5KQ2lLKzA5TGZhU2FCQVZCb215RGdKdWE4ZGZVelI3Z2EzNEl2UjJOdmorQTloZUo2bHNsMUtHNE5rSTEwMzJDbmZmMW0xd29mMkI5b0hKSzRiaTZKa0VkU3FlTmVpdW82UW9aWmluY29jNzMvVEg5U1hGOHNDRTdYeXVZeVc4V1NnYkdGQ2pQVjBpaExLaGRQczA4VHg4MmZZQWtMTGM0STJ3ZGw0YXBZN0dVNWxIUkZ6UldKZXA3V3czd2JlQTNxbWQ1OS84NlA0eHVOYXFEcHlnWHQ2TTg1Z2xTQkhPQ0dnSkRudCtwTjliSzdIQXBNZ3VYNiswNlJaTmp6Vm1jWkord2NVcko5Ly9icFJOeE51S3BObDl1RmRzK1M5dGR4N0xhTTVaa0lyUGo2bklVOW1uYkZ0VmJzOXMvdUxnbDhNVmN6QXdldCtpT0V6ekJsWVc3UkNNZ0U2Z3lOTGVxNisxdEl4NGRwZ1puZDBEa3NKUzVmK0pORHB3d2NQTlhhYVZzcHExZmJRYWpPckpnSzBvZkt0SjFOZTkwTDZWTzRNT2w1Uzg4NnA3dTZ4bzdPTGpHOFRHTCtIVTFKWEdKZ3BwZzRuTmJOSjVubHpTcHVQWXkyMUpVRWNVQTk0UG9GaVpmalp1ZStRbnlRODBla091WlZreHg0ZytjdmhKZkhnTmw0aHkxL2E2K1JLY0tsYXIvSjI5eS8vRXp0bGJWUEhWVWVRMXpYODZlUVZBalIvTTNkQTl3NFc4TGZhWHA0RWdNODV3T1dhc2xpODM3UHpWTU9uc0x6UitrM283NS9sUlBBSlNFMXhBS1F6RWk1djEwa2UrVkJ2UnQxY3dRUk1kK1U1bUxDVEdWZDZYaVp0Z0JHNWNEaTB3MjJHS2NWTnZIaXU1TFFiWkVEVnR6MG9ubjdrNStoZXVLWFZzWnRTemlsa0xSQVVtak1YRU1CM0o5WUM1MFhCeFBpejUzU0MrRWhuUGw5V3NLQ3Y5MlNNL09GRklNSlpZZmwwV1c4dElPM1V4WWN3ZE1BajdGU21ncnNaMmFBWk8wM0JPaFAxYk5OWkl0eVhZUUZUcEMzU0cxVnVQRHFIOUdraUNEbUUrSnd4eUlWU081c2lERXJBT3BFWEZnank2UFF0T1ZEaitzNmUxcjhoZVdWdm1ablRjaXVmNEVpTlp6Q0FkN1NPTWhYRVJJT2xzSElNRzM5OWk5YUxUeTNtMmhSTFpqSlZETkxTNTNpR0lLMTFkUHFRdDB6QkR5ZzZxYzdZcWtEbTJNNVZlNmRDV0NhQ2JUWFgyclRvYUlnejYremg0bFlVaS8rNm5xY0ZNQWtRSktIWUxLMHdZazVOOXN6VjZ4aWhEYkRERnI0NWxOMUs0YUNYQnEvRml0UFN1ZDlnTHQ1WlZuK1pxR1g3Y3dtMno1RUdNZ2ZGcElGeWhHR3VEUG1zbzZUSXRUTXdueSs3dVBuTENmNFc2Z29GUUZWMG9RU3NjOVZmTW1WTGNMcjZaZXREWmJhU0ZUTHFuU08vYklQakEzL3pBVW9xZ0dGQUVRUzRJaHVNekVwMkkzakp6Ynpray9JRW15YXgrcmhaVHdkNmYrQ0d0d1BpeHU4SXZ6QUNxdVBXUFJFdTladkdrVXpwUnd2UlJ1YU5ONmNyMFcxd1dpdHM5SUNkWUo3bHRiZ01pU0wzc1RQZXVmZ05jVnFNVldGa0NQREg0akcyakEwWGNWZ1FqNjJDYjI5djlmL3ovKzJLYll2SXYvenpqcFFBUGtsaWFWRHpOclc1N1RaL1pPeVpEMG5sZk1tQUlCSUFHQUkwRDNrL21kTjR4cjl2ODVaYlpiYnFmSDJqR2Q1aFVxTlpXd2w1U1Bmb0dtZkVsbWF6VUllTkwxai9ta0Y3Vk5BelRxNGpOdDhKb1ExMU5RT2NtaHByWG94U3hmUkdKOUxERU9BUStkbXhBUUg5MGl0aTllMnUvTW9ldWFHY0RUSG9DK3hzbUVlV214RUtlZlF1SXpIYnB3NVRjNWNFb2Nib0FEMDlvaXBXUWh0VE8xd2l2Zi9PK0RSZTJycGwvRTl3bHJ6Qm9yakpzT2VHMUIvWFBXNEVhSkVGZE5sRUNFWmdhNVpvR1JIWGdZb3VHUnVWa204dERFU2lFeUZObyszczVNNXB1U2RUeVVMMmxsbklOVkhFdDkxWFVOVzRld2RNZ0o0Ym9KZkV5dC9pWTVXWHFiQStBMkZrdDVaMGx1dGlXaGU5blpJeUlVanlYREMzVXNhRzF0K2VOeDZ6NFcvT1lvVEI3QTZ4K2ROU1RPaTlBSW5jdGJFU3FtNWd2T0x3dzdPV1hQcm1Id1ZaYXNybDRlRDExM3BtK0p0VDdKVk92bkNYcWR6emRUUkhnSjBQaUdURllXNUd2dDlSOUxENkx6ZnMwdi9UWlpIU215Vk5xN3ZpSUhFNkRCSzdRcDA3SXo1NUVNOFNZdFF2WmYvb2JCbmlUV2k1QzIvb3ZIZnc0Vm5ka0U1WFlkak9oQ01SakRlT0VmWGVOL0N3ZkdkdWlVSWZzb0ZlVXhYZVFYYmE3Yzc5NzJYTnY4dytkVGpqVU0wUWVOQVJlVytKMDE0ZEtBRC9NY1FZWFQ3YzBHUVBJa24zTGw2UjdnR2p1aVFvWkQwVEVlRXFRcEtvWjE1Zy8wT1BRSTE3UWlTdjlBVVJPYS9WL1RRTjNkdkxBcmVjM1Jyc1lsdkJtMWI4TFd6bHRkdWdzQzUwbE5LWUxFcDJhK1paWXFQZWpVTFJsT0poNXpqL0xWTXlURHZ3S2hNeHh3dURreEoxUXBvTkkwT1RXTG9tNFo3MVNOekk5VFYxaVhKckl1OVdjbmQrTUNhQXc4bzFqU1hkOTRZVS8xZ25rckM5QlVFT3RRdkVJUTdnMGk2aCtLTDJKS2s4WWRsN0hydXZnV01TQW1OZStMc2hHaFY0cW5XSGhPOS9SSVBRelkxdEhSajJWcU95TnNEcEswY3d3KzU2QWREQzRnc1d3WTBYeG91Y0lXSXFzL0djd25XcWxhVDBLUHI4bWJLNVU5NC8zMDFpMVdMdDRZSU5UVnZDRkJyRlpiSWJZOGV5Y09kZUoydGVENUlmUExDUmc3ampjRlR3bE1GTmw5emRoL28zRS9oSFB3ajdCV2cwTVUwOXBQckJMYnJDZ201NEE2SCtJNnYyNytqTDVna2pXZy9pWWRrczlqYmZWUDV5L24wZGxnV0VNbEthc2w3SnZGWmQ1NkxmeWJXMWVlYVZPMGd4VGZYWndEOEc0U0kxMTZ5eDdVS1ZSZ3VpNllhMVlwaXhxWGVOTGM4SXh0QXdDVTVJaHdRZ24rTnFIblJhRHY2MUN4S2hPcTRwT1g3TTZwa0ErUG1wZDRqMXZuNkFDVUFMb0xMYzR2cFhjaThWaWRMeHptN3FGQmU3cytxdXVKczZFVFltbnBnUzNMd1NaeFBJbHRnQkRYejhNMWsvVzJ5U052MmY5L05QaHhMR0syRDIxZGtIZVNHbWVuUlQzWXFjZGwwbS9oM09ZcjhWK2xYTllHZjhhQ0NwZDRiV2pFNFFJUGo3dlVLTjROcmZzN01MNlkyT3lTODMwSkNub2ZnL2s3bHBGcHQ0U3FaYzVIR2cxSENPckh2T2RDOGJQNkZHRGJFL1ZWMG1YNElha3piZFMvb3ArS3QzRzI0LzhRYkJWN3k4NnNHU1Evdlp6VThGWHM3dTZqSXZ3Y2hzRVAyQnBJaFczRzh1V053YTNIbWpmSC9aamhoQ1d2bHVBY0Yrbk1mMTRDbEtnNWhHZ3RQTEo5OHVlTkFrYzVIczJXWmxrMlFIdmZyZUNLMUNDR082bk1aVlNiOTlWTS9hanI4V0hUdGU5SlNta1hxL2kvVTk0M0hFYmR6VzZSZS9TODhkS2dnOHBHT0xsQWVOaXFyY0xrVVIzL2FDbEZwTVhjT1VQM3JtRVRjV1NmTVhaRTNUVU9pOGkrZnFSblRZTGZsVngvVmIvNkdKN2VJUlpVQTZrM1JZUjNpRlNLOWM0aURkTndKdVpMMkZLei9JSzVWaW1jTldFcWRYalNveFNnbUYwVVBsRG9VbE5yUGNNN2Z0bUE4WTlnS2lxS0VIdVdOK0FaUkl3dFZTeHllMktmOHJNM2xoSjVYY0JYVTluNHYwT3kxUlUyTSs0cU04QVFQVndzZThFck5Tb2I1b0ZQV3h1cVpuVnpvMXFCL0lCeGtNM0VWVUtGVVVsTzNlNTEyNTlHZ05jSmJDbWx2cmRqdG9UVzdyQ2htMXd5Q0t6cENUd296VVVFT0ljV0xuZVJMZ01YaCtTakdTRmtBbGx6YkdTNUhLN0xsZkNNUk5SRFN2YlFQamNYYWVuTll4Q3Z1MlF5em56NlN0dXhWajY2U2dJMFQ4QjYvc2ZIQUpZWmFaNzh0aGpPU0lGdW1OV0xRYmVaaXhEQ0NDK3YwWUJ0a3hpQkIzamVmSHFaL2RGSFUrY3JiajZPdlMxeC9KREQ3dmxtN3pPVlB3cFVDMDFuaHhadVkvNjNFN2cnO1xuXG4vLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIxNS9cclxuLy8gZm9yIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvblxyXG4vLyBzZWU6IC9kZXJpdmUvbmYuanNcclxuXHJcblxyXG4vLyBhbGdvcml0aG1pYyBoYW5ndWxcclxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvdmVyc2lvbnMvVW5pY29kZTE1LjAuMC9jaDAzLnBkZiAocGFnZSAxNDQpXHJcbmNvbnN0IFMwID0gMHhBQzAwO1xyXG5jb25zdCBMMCA9IDB4MTEwMDtcclxuY29uc3QgVjAgPSAweDExNjE7XHJcbmNvbnN0IFQwID0gMHgxMUE3O1xyXG5jb25zdCBMX0NPVU5UID0gMTk7XHJcbmNvbnN0IFZfQ09VTlQgPSAyMTtcclxuY29uc3QgVF9DT1VOVCA9IDI4O1xyXG5jb25zdCBOX0NPVU5UID0gVl9DT1VOVCAqIFRfQ09VTlQ7XHJcbmNvbnN0IFNfQ09VTlQgPSBMX0NPVU5UICogTl9DT1VOVDtcclxuY29uc3QgUzEgPSBTMCArIFNfQ09VTlQ7XHJcbmNvbnN0IEwxID0gTDAgKyBMX0NPVU5UO1xyXG5jb25zdCBWMSA9IFYwICsgVl9DT1VOVDtcclxuY29uc3QgVDEgPSBUMCArIFRfQ09VTlQ7XHJcblxyXG5mdW5jdGlvbiB1bnBhY2tfY2MocGFja2VkKSB7XHJcblx0cmV0dXJuIChwYWNrZWQgPj4gMjQpICYgMHhGRjtcclxufVxyXG5mdW5jdGlvbiB1bnBhY2tfY3AocGFja2VkKSB7XHJcblx0cmV0dXJuIHBhY2tlZCAmIDB4RkZGRkZGO1xyXG59XHJcblxyXG5sZXQgU0hJRlRFRF9SQU5LLCBFWENMVVNJT05TLCBERUNPTVAsIFJFQ09NUDtcclxuXHJcbmZ1bmN0aW9uIGluaXQkMSgpIHtcclxuXHQvL2NvbnNvbGUudGltZSgnbmYnKTtcclxuXHRsZXQgciA9IHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKENPTVBSRVNTRUQpO1xyXG5cdFNISUZURURfUkFOSyA9IG5ldyBNYXAocmVhZF9zb3J0ZWRfYXJyYXlzKHIpLmZsYXRNYXAoKHYsIGkpID0+IHYubWFwKHggPT4gW3gsIChpKzEpIDw8IDI0XSkpKTsgLy8gcHJlLXNoaWZ0ZWRcclxuXHRFWENMVVNJT05TID0gbmV3IFNldChyZWFkX3NvcnRlZChyKSk7XHJcblx0REVDT01QID0gbmV3IE1hcCgpO1xyXG5cdFJFQ09NUCA9IG5ldyBNYXAoKTtcclxuXHRmb3IgKGxldCBbY3AsIGNwc10gb2YgcmVhZF9tYXBwZWQocikpIHtcclxuXHRcdGlmICghRVhDTFVTSU9OUy5oYXMoY3ApICYmIGNwcy5sZW5ndGggPT0gMikge1xyXG5cdFx0XHRsZXQgW2EsIGJdID0gY3BzO1xyXG5cdFx0XHRsZXQgYnVja2V0ID0gUkVDT01QLmdldChhKTtcclxuXHRcdFx0aWYgKCFidWNrZXQpIHtcclxuXHRcdFx0XHRidWNrZXQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0UkVDT01QLnNldChhLCBidWNrZXQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJ1Y2tldC5zZXQoYiwgY3ApO1xyXG5cdFx0fVxyXG5cdFx0REVDT01QLnNldChjcCwgY3BzLnJldmVyc2UoKSk7IC8vIHN0b3JlZCByZXZlcnNlZFxyXG5cdH1cclxuXHQvL2NvbnNvbGUudGltZUVuZCgnbmYnKTtcclxuXHQvLyAyMDIzMDkwNTogMTFtc1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc19oYW5ndWwoY3ApIHtcclxuXHRyZXR1cm4gY3AgPj0gUzAgJiYgY3AgPCBTMTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZV9wYWlyKGEsIGIpIHtcclxuXHRpZiAoYSA+PSBMMCAmJiBhIDwgTDEgJiYgYiA+PSBWMCAmJiBiIDwgVjEpIHtcclxuXHRcdHJldHVybiBTMCArIChhIC0gTDApICogTl9DT1VOVCArIChiIC0gVjApICogVF9DT1VOVDtcclxuXHR9IGVsc2UgaWYgKGlzX2hhbmd1bChhKSAmJiBiID4gVDAgJiYgYiA8IFQxICYmIChhIC0gUzApICUgVF9DT1VOVCA9PSAwKSB7XHJcblx0XHRyZXR1cm4gYSArIChiIC0gVDApO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRsZXQgcmVjb21wID0gUkVDT01QLmdldChhKTtcclxuXHRcdGlmIChyZWNvbXApIHtcclxuXHRcdFx0cmVjb21wID0gcmVjb21wLmdldChiKTtcclxuXHRcdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRcdHJldHVybiByZWNvbXA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlY29tcG9zZWQoY3BzKSB7XHJcblx0aWYgKCFTSElGVEVEX1JBTkspIGluaXQkMSgpO1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0bGV0IGNoZWNrX29yZGVyID0gZmFsc2U7XHJcblx0ZnVuY3Rpb24gYWRkKGNwKSB7XHJcblx0XHRsZXQgY2MgPSBTSElGVEVEX1JBTksuZ2V0KGNwKTtcclxuXHRcdGlmIChjYykge1xyXG5cdFx0XHRjaGVja19vcmRlciA9IHRydWU7XHJcblx0XHRcdGNwIHw9IGNjO1xyXG5cdFx0fVxyXG5cdFx0cmV0LnB1c2goY3ApO1xyXG5cdH1cclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGlmIChjcCA8IDB4ODApIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGNwKSkge1xyXG5cdFx0XHRcdGxldCBzX2luZGV4ID0gY3AgLSBTMDtcclxuXHRcdFx0XHRsZXQgbF9pbmRleCA9IHNfaW5kZXggLyBOX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdl9pbmRleCA9IChzX2luZGV4ICUgTl9DT1VOVCkgLyBUX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdF9pbmRleCA9IHNfaW5kZXggJSBUX0NPVU5UO1xyXG5cdFx0XHRcdGFkZChMMCArIGxfaW5kZXgpO1xyXG5cdFx0XHRcdGFkZChWMCArIHZfaW5kZXgpO1xyXG5cdFx0XHRcdGlmICh0X2luZGV4ID4gMCkgYWRkKFQwICsgdF9pbmRleCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IG1hcHBlZCA9IERFQ09NUC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChtYXBwZWQpIHtcclxuXHRcdFx0XHRcdGJ1Zi5wdXNoKC4uLm1hcHBlZCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGFkZChjcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghYnVmLmxlbmd0aCkgYnJlYWs7XHJcblx0XHRcdGNwID0gYnVmLnBvcCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hlY2tfb3JkZXIgJiYgcmV0Lmxlbmd0aCA+IDEpIHtcclxuXHRcdGxldCBwcmV2X2NjID0gdW5wYWNrX2NjKHJldFswXSk7XHJcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdFx0aWYgKGNjID09IDAgfHwgcHJldl9jYyA8PSBjYykge1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgaiA9IGktMTtcclxuXHRcdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0XHRsZXQgdG1wID0gcmV0W2orMV07XHJcblx0XHRcdFx0cmV0W2orMV0gPSByZXRbal07XHJcblx0XHRcdFx0cmV0W2pdID0gdG1wO1xyXG5cdFx0XHRcdGlmICghaikgYnJlYWs7XHJcblx0XHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbLS1qXSk7XHJcblx0XHRcdFx0aWYgKHByZXZfY2MgPD0gY2MpIGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkKHYpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHN0YWNrID0gW107XHJcblx0bGV0IHByZXZfY3AgPSAtMTtcclxuXHRsZXQgcHJldl9jYyA9IDA7XHJcblx0Zm9yIChsZXQgcGFja2VkIG9mIHYpIHtcclxuXHRcdGxldCBjYyA9IHVucGFja19jYyhwYWNrZWQpO1xyXG5cdFx0bGV0IGNwID0gdW5wYWNrX2NwKHBhY2tlZCk7XHJcblx0XHRpZiAocHJldl9jcCA9PSAtMSkge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAocHJldl9jYyA+IDAgJiYgcHJldl9jYyA+PSBjYykge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3AsIC4uLnN0YWNrKTtcclxuXHRcdFx0XHRzdGFjay5sZW5ndGggPSAwO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY29tcG9zZWQgPSBjb21wb3NlX3BhaXIocHJldl9jcCwgY3ApO1xyXG5cdFx0XHRpZiAoY29tcG9zZWQgPj0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjb21wb3NlZDtcclxuXHRcdFx0fSBlbHNlIGlmIChwcmV2X2NjID09IDAgJiYgY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3ApO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXZfY3AgPj0gMCkge1xyXG5cdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1x0XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vIG5vdGU6IGNwcyBjYW4gYmUgaXRlcmFibGVcclxuZnVuY3Rpb24gbmZkKGNwcykge1xyXG5cdHJldHVybiBkZWNvbXBvc2VkKGNwcykubWFwKHVucGFja19jcCk7XHJcbn1cclxuZnVuY3Rpb24gbmZjKGNwcykge1xyXG5cdHJldHVybiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQoZGVjb21wb3NlZChjcHMpKTtcclxufVxuXG5jb25zdCBIWVBIRU4gPSAweDJEO1xyXG5jb25zdCBTVE9QID0gMHgyRTtcclxuY29uc3QgU1RPUF9DSCA9ICcuJztcclxuY29uc3QgRkUwRiA9IDB4RkUwRjtcclxuY29uc3QgVU5JUVVFX1BIID0gMTtcclxuXHJcbi8vIDIwMjMwOTEzOiByZXBsYWNlIFsuLi52XSB3aXRoIEFycmF5X2Zyb20odikgdG8gYXZvaWQgbGFyZ2Ugc3ByZWFkc1xyXG5jb25zdCBBcnJheV9mcm9tID0geCA9PiBBcnJheS5mcm9tKHgpOyAvLyBBcnJheS5mcm9tLmJpbmQoQXJyYXkpO1xyXG5cclxuZnVuY3Rpb24gZ3JvdXBfaGFzX2NwKGcsIGNwKSB7XHJcblx0Ly8gMjAyMzA5MTM6IGtlZXAgcHJpbWFyeSBhbmQgc2Vjb25kYXJ5IGRpc3RpbmN0IGluc3RlYWQgb2YgY3JlYXRpbmcgdmFsaWQgdW5pb25cclxuXHRyZXR1cm4gZy5QLmhhcyhjcCkgfHwgZy5RLmhhcyhjcCk7XHJcbn1cclxuXHJcbmNsYXNzIEVtb2ppIGV4dGVuZHMgQXJyYXkge1xyXG5cdGdldCBpc19lbW9qaSgpIHsgcmV0dXJuIHRydWU7IH0gLy8gZnJlZSB0YWdnaW5nIHN5c3RlbVxyXG59XHJcblxyXG5sZXQgTUFQUEVELCBJR05PUkVELCBDTSwgTlNNLCBFU0NBUEUsIE5GQ19DSEVDSywgR1JPVVBTLCBXSE9MRV9WQUxJRCwgV0hPTEVfTUFQLCBWQUxJRCwgRU1PSklfTElTVCwgRU1PSklfUk9PVDtcclxuXHJcbmZ1bmN0aW9uIGluaXQoKSB7XHJcblx0aWYgKE1BUFBFRCkgcmV0dXJuO1xyXG5cdFxyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCQxKTtcclxuXHRjb25zdCByZWFkX3NvcnRlZF9hcnJheSA9ICgpID0+IHJlYWRfc29ydGVkKHIpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX3NldCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKSk7XHJcblx0Y29uc3Qgc2V0X2FkZF9tYW55ID0gKHNldCwgdikgPT4gdi5mb3JFYWNoKHggPT4gc2V0LmFkZCh4KSk7XHJcblxyXG5cdE1BUFBFRCA9IG5ldyBNYXAocmVhZF9tYXBwZWQocikpOyBcclxuXHRJR05PUkVEID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGlnbm9yZWQgY2hhcmFjdGVycyBhcmUgbm90IHZhbGlkLCBzbyBqdXN0IHJlYWQgcmF3IGNvZGVwb2ludHNcclxuXHJcblx0LypcclxuXHQvLyBkaXJlY3QgaW5jbHVkZSBmcm9tIHBheWxvYWQgaXMgc21hbGxlciB0aGFuIHRoZSBkZWNvbXByZXNzaW9uIGNvZGVcclxuXHRjb25zdCBGRU5DRUQgPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0bGV0IGNwID0gcigpO1xyXG5cdFx0aWYgKGNwKSByZXR1cm4gW2NwLCByZWFkX3N0cihyKCkpXTtcclxuXHR9KSk7XHJcblx0Ki9cclxuXHQvLyAyMDIzMDIxNzogd2Ugc3RpbGwgbmVlZCBhbGwgQ00gZm9yIHByb3BlciBlcnJvciBmb3JtYXR0aW5nXHJcblx0Ly8gYnV0IG5vcm0gb25seSBuZWVkcyBOU00gc3Vic2V0IHRoYXQgYXJlIHBvdGVudGlhbGx5LXZhbGlkXHJcblx0Q00gPSByZWFkX3NvcnRlZF9hcnJheSgpO1xyXG5cdE5TTSA9IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5tYXAoaSA9PiBDTVtpXSkpO1xyXG5cdENNID0gbmV3IFNldChDTSk7XHJcblx0XHJcblx0RVNDQVBFID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByaW50ZWRcclxuXHRORkNfQ0hFQ0sgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gb25seSBuZWVkZWQgdG8gaWxsdXN0cmF0ZSBlbnNfdG9rZW5pemUoKSB0cmFuc2Zvcm1hdGlvbnNcclxuXHJcblx0bGV0IGNodW5rcyA9IHJlYWRfc29ydGVkX2FycmF5cyhyKTtcclxuXHRsZXQgdW5yZXN0cmljdGVkID0gcigpO1xyXG5cdC8vY29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLmZsYXRNYXAoaSA9PiBjaHVua3NbaV0pLmNvbmNhdChyZWFkX3NvcnRlZF9hcnJheSgpKSk7XHJcblx0Y29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4ge1xyXG5cdFx0Ly8gMjAyMzA5MjE6IGJ1aWxkIHNldCBpbiBwYXJ0cywgMnggZmFzdGVyXHJcblx0XHRsZXQgc2V0ID0gbmV3IFNldCgpO1xyXG5cdFx0cmVhZF9zb3J0ZWRfYXJyYXkoKS5mb3JFYWNoKGkgPT4gc2V0X2FkZF9tYW55KHNldCwgY2h1bmtzW2ldKSk7XHJcblx0XHRzZXRfYWRkX21hbnkoc2V0LCByZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHRcdHJldHVybiBzZXQ7IFxyXG5cdH07XHJcblx0R1JPVVBTID0gcmVhZF9hcnJheV93aGlsZShpID0+IHtcclxuXHRcdC8vIG1pbmlmaWVyIHByb3BlcnR5IG1hbmdsaW5nIHNlZW1zIHVuc2FmZVxyXG5cdFx0Ly8gc28gdGhlc2UgYXJlIG1hbnVhbGx5IHJlbmFtZWQgdG8gc2luZ2xlIGNoYXJzXHJcblx0XHRsZXQgTiA9IHJlYWRfYXJyYXlfd2hpbGUocikubWFwKHggPT4geCsweDYwKTtcclxuXHRcdGlmIChOLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgUiA9IGkgPj0gdW5yZXN0cmljdGVkOyAvLyB1bnJlc3RyaWN0ZWQgdGhlbiByZXN0cmljdGVkXHJcblx0XHRcdE5bMF0gLT0gMzI7IC8vIGNhcGl0YWxpemVcclxuXHRcdFx0TiA9IHN0cl9mcm9tX2NwcyhOKTtcclxuXHRcdFx0aWYgKFIpIE49YFJlc3RyaWN0ZWRbJHtOfV1gO1xyXG5cdFx0XHRsZXQgUCA9IHJlYWRfY2h1bmtlZCgpOyAvLyBwcmltYXJ5XHJcblx0XHRcdGxldCBRID0gcmVhZF9jaHVua2VkKCk7IC8vIHNlY29uZGFyeVxyXG5cdFx0XHRsZXQgTSA9ICFyKCk7IC8vIG5vdC13aGl0ZWxpc3RlZCwgY2hlY2sgZm9yIE5TTVxyXG5cdFx0XHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0XHRcdC8qXHJcblx0XHRcdGxldCBWID0gWy4uLlAsIC4uLlFdLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIGRlcml2ZTogc29ydGVkIHZhbGlkXHJcblx0XHRcdGxldCBNID0gcigpLTE7IC8vIG51bWJlciBvZiBjb21iaW5pbmcgbWFya1xyXG5cdFx0XHRpZiAoTSA8IDApIHsgLy8gd2hpdGVsaXN0ZWRcclxuXHRcdFx0XHRNID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdGxldCBpID0gcigpO1xyXG5cdFx0XHRcdFx0aWYgKGkpIHJldHVybiBbVltpLTFdLCByZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0bGV0IHYgPSByZWFkX2FycmF5X3doaWxlKHIpO1xyXG5cdFx0XHRcdFx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2Lm1hcCh4ID0+IHgtMSk7XHJcblx0XHRcdFx0XHR9KV07XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHR9Ki9cclxuXHRcdFx0cmV0dXJuIHtOLCBQLCBRLCBNLCBSfTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gZGVjb2RlIGNvbXByZXNzZWQgd2hvbGVzXHJcblx0V0hPTEVfVkFMSUQgPSByZWFkX3NvcnRlZF9zZXQoKTtcclxuXHRXSE9MRV9NQVAgPSBuZXcgTWFwKCk7XHJcblx0bGV0IHdob2xlcyA9IHJlYWRfc29ydGVkX2FycmF5KCkuY29uY2F0KEFycmF5X2Zyb20oV0hPTEVfVkFMSUQpKS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBtdXN0IGJlIHNvcnRlZFxyXG5cdHdob2xlcy5mb3JFYWNoKChjcCwgaSkgPT4ge1xyXG5cdFx0bGV0IGQgPSByKCk7IFxyXG5cdFx0bGV0IHcgPSB3aG9sZXNbaV0gPSBkID8gd2hvbGVzW2ktZF0gOiB7VjogW10sIE06IG5ldyBNYXAoKX07XHJcblx0XHR3LlYucHVzaChjcCk7IC8vIGFkZCB0byBtZW1iZXIgc2V0XHJcblx0XHRpZiAoIVdIT0xFX1ZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgdyk7ICAvLyByZWdpc3RlciB3aXRoIHdob2xlIG1hcFxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBjb21wdXRlIGNvbmZ1c2FibGUtZXh0ZW50IGNvbXBsZW1lbnRzXHJcblx0Ly8gdXNhZ2U6IFdIT0xFX01BUC5nZXQoY3ApLk0uZ2V0KGNwKSA9IGNvbXBsZW1lbnQgc2V0XHJcblx0Zm9yIChsZXQge1YsIE19IG9mIG5ldyBTZXQoV0hPTEVfTUFQLnZhbHVlcygpKSkge1xyXG5cdFx0Ly8gY29ubmVjdCBhbGwgZ3JvdXBzIHRoYXQgaGF2ZSBlYWNoIHdob2xlIGNoYXJhY3RlclxyXG5cdFx0bGV0IHJlY3MgPSBbXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0bGV0IGdzID0gR1JPVVBTLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0XHRsZXQgcmVjID0gcmVjcy5maW5kKCh7R30pID0+IGdzLnNvbWUoZyA9PiBHLmhhcyhnKSkpO1xyXG5cdFx0XHRpZiAoIXJlYykge1xyXG5cdFx0XHRcdHJlYyA9IHtHOiBuZXcgU2V0KCksIFY6IFtdfTtcclxuXHRcdFx0XHRyZWNzLnB1c2gocmVjKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZWMuVi5wdXNoKGNwKTtcclxuXHRcdFx0c2V0X2FkZF9tYW55KHJlYy5HLCBncyk7XHJcblx0XHR9XHJcblx0XHQvLyBwZXIgY2hhcmFjdGVyIGNhY2hlIGdyb3VwcyB3aGljaCBhcmUgbm90IGEgbWVtYmVyIG9mIHRoZSBleHRlbnRcclxuXHRcdGxldCB1bmlvbiA9IHJlY3MuZmxhdE1hcCh4ID0+IEFycmF5X2Zyb20oeC5HKSk7IC8vIGFsbCBvZiB0aGUgZ3JvdXBzIHVzZWQgYnkgdGhpcyB3aG9sZVxyXG5cdFx0Zm9yIChsZXQge0csIFZ9IG9mIHJlY3MpIHtcclxuXHRcdFx0bGV0IGNvbXBsZW1lbnQgPSBuZXcgU2V0KHVuaW9uLmZpbHRlcihnID0+ICFHLmhhcyhnKSkpOyAvLyBncm91cHMgbm90IGNvdmVyZWQgYnkgdGhlIGV4dGVudFxyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdFx0TS5zZXQoY3AsIGNvbXBsZW1lbnQpOyAvLyB0aGlzIGlzIHRoZSBzYW1lIHJlZmVyZW5jZVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBjb21wdXRlIHZhbGlkIHNldFxyXG5cdC8vIDIwMjMwOTI0OiBWQUxJRCB3YXMgdW5pb24gYnV0IGNhbiBiZSByZS11c2VkXHJcblx0VkFMSUQgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAxKyBncm91cHNcclxuXHRsZXQgbXVsdGkgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAyKyBncm91cHNcclxuXHRjb25zdCBhZGRfdG9fdW5pb24gPSBjcCA9PiBWQUxJRC5oYXMoY3ApID8gbXVsdGkuYWRkKGNwKSA6IFZBTElELmFkZChjcCk7XHJcblx0Zm9yIChsZXQgZyBvZiBHUk9VUFMpIHtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUCkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUSkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHR9XHJcblx0Ly8gZHVhbCBwdXJwb3NlIFdIT0xFX01BUDogcmV0dXJuIHBsYWNlaG9sZGVyIGlmIHVuaXF1ZSBub24tY29uZnVzYWJsZVxyXG5cdGZvciAobGV0IGNwIG9mIFZBTElEKSB7XHJcblx0XHRpZiAoIVdIT0xFX01BUC5oYXMoY3ApICYmICFtdWx0aS5oYXMoY3ApKSB7XHJcblx0XHRcdFdIT0xFX01BUC5zZXQoY3AsIFVOSVFVRV9QSCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIGFkZCBhbGwgZGVjb21wb3NlZCBwYXJ0c1xyXG5cdC8vIHNlZSBkZXJpdmU6IFwiVmFsaWQgaXMgQ2xvc2VkICh2aWEgQnJ1dGUtZm9yY2UpXCJcclxuXHRzZXRfYWRkX21hbnkoVkFMSUQsIG5mZChWQUxJRCkpO1xyXG5cdFxyXG5cdC8vIGRlY29kZSBlbW9qaVxyXG5cdC8vIDIwMjMwNzE5OiBlbW9qaSBhcmUgbm93IGZ1bGx5LWV4cGFuZGVkIHRvIGF2b2lkIHF1aXJrIGxvZ2ljIFxyXG5cdEVNT0pJX0xJU1QgPSByZWFkX3RyaWUocikubWFwKHYgPT4gRW1vamkuZnJvbSh2KSkuc29ydChjb21wYXJlX2FycmF5cyk7XHJcblx0RU1PSklfUk9PVCA9IG5ldyBNYXAoKTsgLy8gdGhpcyBoYXMgYXBwcm94IDdLIG5vZGVzICgyKyBwZXIgZW1vamkpXHJcblx0Zm9yIChsZXQgY3BzIG9mIEVNT0pJX0xJU1QpIHtcclxuXHRcdC8vIDIwMjMwNzE5OiBjaGFuZ2UgdG8gKnNsaWdodGx5KiBzdHJpY3RlciBhbGdvcml0aG0gd2hpY2ggZGlzYWxsb3dzIFxyXG5cdFx0Ly8gaW5zZXJ0aW9uIG9mIG1pc3BsYWNlZCBGRTBGIGluIGVtb2ppIHNlcXVlbmNlcyAobWF0Y2hpbmcgRU5TSVAtMTUpXHJcblx0XHQvLyBleGFtcGxlOiBiZWF1dGlmaWVkIFtBIEJdIChlZy4gZmxhZyBlbW9qaSkgXHJcblx0XHQvLyAgYmVmb3JlOiBhbGxvdzogW0EgRkUwRiBCXSwgZXJyb3I6IFtBIEZFMEYgRkUwRiBCXSBcclxuXHRcdC8vICAgYWZ0ZXI6IGVycm9yOiBib3RoXHJcblx0XHQvLyBub3RlOiB0aGlzIGNvZGUgbm93IG1hdGNoZXMgRU5TTm9ybWFsaXplLntjcyxqYXZhfSBsb2dpY1xyXG5cdFx0bGV0IHByZXYgPSBbRU1PSklfUk9PVF07XHJcblx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0bGV0IG5leHQgPSBwcmV2Lm1hcChub2RlID0+IHtcclxuXHRcdFx0XHRsZXQgY2hpbGQgPSBub2RlLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKCFjaGlsZCkge1xyXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHRoaXMgYmUgb2JqZWN0PyBcclxuXHRcdFx0XHRcdC8vIChtb3N0IGhhdmUgMS0yIGl0ZW1zLCBmZXcgaGF2ZSBtYW55KVxyXG5cdFx0XHRcdFx0Ly8gMjAyMzA3MTk6IG5vLCB2OCBkZWZhdWx0IG1hcCBpcyA0P1xyXG5cdFx0XHRcdFx0Y2hpbGQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0XHRub2RlLnNldChjcCwgY2hpbGQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoY3AgPT09IEZFMEYpIHtcclxuXHRcdFx0XHRwcmV2LnB1c2goLi4ubmV4dCk7IC8vIGxlc3MgdGhhbiAyMCBlbGVtZW50c1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHByZXYgPSBuZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCB4IG9mIHByZXYpIHtcclxuXHRcdFx0eC5WID0gY3BzO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gaWYgZXNjYXBlZDoge0hFWH1cclxuLy8gICAgICAgZWxzZTogXCJ4XCIge0hFWH1cclxuZnVuY3Rpb24gcXVvdGVkX2NwKGNwKSB7XHJcblx0cmV0dXJuIChzaG91bGRfZXNjYXBlKGNwKSA/ICcnIDogYCR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhbY3BdKSl9IGApICsgcXVvdGVfY3AoY3ApO1xyXG59XHJcblxyXG4vLyAyMDIzMDIxMTogc29tZSBtZXNzYWdlcyBjYW4gYmUgbWl4ZWQtZGlyZWN0aW9uYWwgYW5kIHJlc3VsdCBpbiBzcGlsbG92ZXJcclxuLy8gdXNlIDIwMEUgYWZ0ZXIgYSBxdW90ZWQgc3RyaW5nIHRvIGZvcmNlIHRoZSByZW1haW5kZXIgb2YgYSBzdHJpbmcgZnJvbSBcclxuLy8gYWNxdXJpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcXVvdGVcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWJpZGktdW5pY29kZS1jb250cm9scyNleGNlcHRpb25zXHJcbmZ1bmN0aW9uIGJpZGlfcXEocykge1xyXG5cdHJldHVybiBgXCIke3N9XCJcXHUyMDBFYDsgLy8gc3Ryb25nIExUUlxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja19sYWJlbF9leHRlbnNpb24oY3BzKSB7XHJcblx0aWYgKGNwcy5sZW5ndGggPj0gNCAmJiBjcHNbMl0gPT0gSFlQSEVOICYmIGNwc1szXSA9PSBIWVBIRU4pIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBsYWJlbCBleHRlbnNpb246IFwiJHtzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKDAsIDQpKX1cImApOyAvLyB0aGlzIGNhbiBvbmx5IGJlIGFzY2lpIHNvIGNhbnQgYmUgYmlkaVxyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUoY3BzKSB7XHJcblx0Y29uc3QgVU5ERVJTQ09SRSA9IDB4NUY7XHJcblx0Zm9yIChsZXQgaSA9IGNwcy5sYXN0SW5kZXhPZihVTkRFUlNDT1JFKTsgaSA+IDA7ICkge1xyXG5cdFx0aWYgKGNwc1stLWldICE9PSBVTkRFUlNDT1JFKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigndW5kZXJzY29yZSBhbGxvd2VkIG9ubHkgYXQgc3RhcnQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuLy8gY2hlY2sgdGhhdCBhIGZlbmNlZCBjcCBpcyBub3QgbGVhZGluZywgdHJhaWxpbmcsIG9yIHRvdWNoaW5nIGFub3RoZXIgZmVuY2VkIGNwXHJcbmZ1bmN0aW9uIGNoZWNrX2ZlbmNlZChjcHMpIHtcclxuXHRsZXQgY3AgPSBjcHNbMF07XHJcblx0bGV0IHByZXYgPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRpZiAocHJldikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGBsZWFkaW5nICR7cHJldn1gKTtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0bGV0IGxhc3QgPSAtMTsgLy8gcHJldmVudHMgdHJhaWxpbmcgZnJvbSB0aHJvd2luZ1xyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjcCA9IGNwc1tpXTtcclxuXHRcdGxldCBtYXRjaCA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdFx0aWYgKG1hdGNoKSB7XHJcblx0XHRcdC8vIHNpbmNlIGNwc1swXSBpc24ndCBmZW5jZWQsIGNwc1sxXSBjYW5ub3QgdGhyb3dcclxuXHRcdFx0aWYgKGxhc3QgPT0gaSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGAke3ByZXZ9ICsgJHttYXRjaH1gKTtcclxuXHRcdFx0bGFzdCA9IGkgKyAxO1xyXG5cdFx0XHRwcmV2ID0gbWF0Y2g7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChsYXN0ID09IG4pIHRocm93IGVycm9yX3BsYWNlbWVudChgdHJhaWxpbmcgJHtwcmV2fWApO1xyXG59XHJcblxyXG4vLyBjcmVhdGUgYSBzYWZlIHRvIHByaW50IHN0cmluZyBcclxuLy8gaW52aXNpYmxlcyBhcmUgZXNjYXBlZFxyXG4vLyBsZWFkaW5nIGNtIHVzZXMgcGxhY2Vob2xkZXJcclxuLy8gaWYgY3BzIGV4Y2VlZCBtYXgsIG1pZGRsZSB0cnVuY2F0ZSB3aXRoIGVsbGlwc2lzXHJcbi8vIHF1b3RlcihjcCkgPT4gc3RyaW5nLCBlZy4gMzAwMCA9PiBcInszMDAwfVwiXHJcbi8vIG5vdGU6IGluIGh0bWwsIHlvdSdkIGNhbGwgdGhpcyBmdW5jdGlvbiB0aGVuIHJlcGxhY2UgWzw+Jl0gd2l0aCBlbnRpdGllc1xyXG5mdW5jdGlvbiBzYWZlX3N0cl9mcm9tX2NwcyhjcHMsIG1heCA9IEluZmluaXR5LCBxdW90ZXIgPSBxdW90ZV9jcCkge1xyXG5cdC8vaWYgKE51bWJlci5pc0ludGVnZXIoY3BzKSkgY3BzID0gW2Nwc107XHJcblx0Ly9pZiAoIUFycmF5LmlzQXJyYXkoY3BzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgY29kZXBvaW50c2ApO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRpZiAoaXNfY29tYmluaW5nX21hcmsoY3BzWzBdKSkgYnVmLnB1c2goJ+KXjCcpO1xyXG5cdGlmIChjcHMubGVuZ3RoID4gbWF4KSB7XHJcblx0XHRtYXggPj49IDE7XHJcblx0XHRjcHMgPSBbLi4uY3BzLnNsaWNlKDAsIG1heCksIDB4MjAyNiwgLi4uY3BzLnNsaWNlKC1tYXgpXTtcclxuXHR9XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0bGV0IGNwID0gY3BzW2ldO1xyXG5cdFx0aWYgKHNob3VsZF9lc2NhcGUoY3ApKSB7XHJcblx0XHRcdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgaSkpKTtcclxuXHRcdFx0YnVmLnB1c2gocXVvdGVyKGNwKSk7XHJcblx0XHRcdHByZXYgPSBpICsgMTtcclxuXHRcdH1cclxuXHR9XHJcblx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBuKSkpO1xyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbi8vIG5vdGU6IHNldChzKSBjYW5ub3QgYmUgZXhwb3NlZCBiZWNhdXNlIHRoZXkgY2FuIGJlIG1vZGlmaWVkXHJcbi8vIG5vdGU6IE9iamVjdC5mcmVlemUoKSBkb2Vzbid0IHdvcmtcclxuZnVuY3Rpb24gaXNfY29tYmluaW5nX21hcmsoY3ApIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIENNLmhhcyhjcCk7XHJcbn1cclxuZnVuY3Rpb24gc2hvdWxkX2VzY2FwZShjcCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRVNDQVBFLmhhcyhjcCk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBhbGwgc3VwcG9ydGVkIGVtb2ppIGFzIGZ1bGx5LXF1YWxpZmllZCBlbW9qaSBcclxuLy8gb3JkZXJlZCBieSBsZW5ndGggdGhlbiBsZXhpY29ncmFwaGljIFxyXG5mdW5jdGlvbiBlbnNfZW1vamkoKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBFTU9KSV9MSVNULm1hcCh4ID0+IHguc2xpY2UoKSk7IC8vIGVtb2ppIGFyZSBleHBvc2VkIHNvIGNvcHlcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZV9mcmFnbWVudChmcmFnLCBkZWNvbXBvc2UpIHtcclxuXHRpbml0KCk7XHJcblx0bGV0IG5mID0gZGVjb21wb3NlID8gbmZkIDogbmZjO1xyXG5cdHJldHVybiBmcmFnLnNwbGl0KFNUT1BfQ0gpLm1hcChsYWJlbCA9PiBzdHJfZnJvbV9jcHModG9rZW5zX2Zyb21fc3RyKGV4cGxvZGVfY3AobGFiZWwpLCBuZiwgZmlsdGVyX2ZlMGYpLmZsYXQoKSkpLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemUobmFtZSkge1xyXG5cdHJldHVybiBmbGF0dGVuKHNwbGl0KG5hbWUsIG5mYywgZmlsdGVyX2ZlMGYpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX2JlYXV0aWZ5KG5hbWUpIHtcclxuXHRsZXQgbGFiZWxzID0gc3BsaXQobmFtZSwgbmZjLCB4ID0+IHgpOyAvLyBlbW9qaSBub3QgZXhwb3NlZFxyXG5cdGZvciAobGV0IHt0eXBlLCBvdXRwdXQsIGVycm9yfSBvZiBsYWJlbHMpIHtcclxuXHRcdGlmIChlcnJvcikgYnJlYWs7IC8vIGZsYXR0ZW4gd2lsbCB0aHJvd1xyXG5cclxuXHRcdC8vIHJlcGxhY2UgbGVhZGluZy90cmFpbGluZyBoeXBoZW5cclxuXHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBiZWF1dGlmaW5nIGFsbCBvciBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlbiB0byB1bmljb2RlIHZhcmlhbnRcclxuXHRcdC8vIG5vdCBleGFjdGx5IHRoZSBzYW1lIGluIGV2ZXJ5IGZvbnQsIGJ1dCB2ZXJ5IHNpbWlsYXI6IFwiLVwiIHZzIFwi4oCQXCJcclxuXHRcdC8qXHJcblx0XHRjb25zdCBVTklDT0RFX0hZUEhFTiA9IDB4MjAxMDtcclxuXHRcdC8vIG1heWJlIHRoaXMgc2hvdWxkIHJlcGxhY2UgYWxsIGZvciB2aXN1YWwgY29uc2lzdGFuY3k/XHJcblx0XHQvLyBgbm9kZSB0b29scy9yZWctY291bnQuanMgcmVnZXggXi1cXHsyLFxcfWAgPT4gNTkyXHJcblx0XHQvL2ZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSsrKSBpZiAob3V0cHV0W2ldID09IDB4MkQpIG91dHB1dFtpXSA9IDB4MjAxMDtcclxuXHRcdGlmIChvdXRwdXRbMF0gPT0gSFlQSEVOKSBvdXRwdXRbMF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdGxldCBlbmQgPSBvdXRwdXQubGVuZ3RoLTE7XHJcblx0XHRpZiAob3V0cHV0W2VuZF0gPT0gSFlQSEVOKSBvdXRwdXRbZW5kXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0Ki9cclxuXHRcdC8vIDIwMjMwMTIzOiBXSEFUV0cgVVJMIHVzZXMgXCJDaGVja0h5cGhlbnNcIiBmYWxzZVxyXG5cdFx0Ly8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpZG5hXHJcblxyXG5cdFx0Ly8gdXBkYXRlIGV0aGVyZXVtIHN5bWJvbFxyXG5cdFx0Ly8gzr4gPT4gzp4gaWYgbm90IGdyZWVrXHJcblx0XHRpZiAodHlwZSAhPT0gJ0dyZWVrJykgYXJyYXlfcmVwbGFjZShvdXRwdXQsIDB4M0JFLCAweDM5RSk7XHJcblxyXG5cdFx0Ly8gMjAyMjEyMTM6IGZpeGVzIGJpZGkgc3ViZG9tYWluIGlzc3VlLCBidXQgYnJlYWtzIGludmFyaWFudCAoMjAwRSBpcyBkaXNhbGxvd2VkKVxyXG5cdFx0Ly8gY291bGQgYmUgZml4ZWQgd2l0aCBzcGVjaWFsIGNhc2UgZm9yOiAyRCAoLikgKyAyMDBFIChMVFIpXHJcblx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9iaWRpLWxhYmVsLW9yZGVyaW5nLXNwb29mLzE1ODI0XHJcblx0XHQvL291dHB1dC5zcGxpY2UoMCwgMCwgMHgyMDBFKTtcclxuXHR9XHJcblx0cmV0dXJuIGZsYXR0ZW4obGFiZWxzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlfcmVwbGFjZSh2LCBhLCBiKSB7XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgbmV4dCA9IHYuaW5kZXhPZihhLCBwcmV2KTtcclxuXHRcdGlmIChuZXh0IDwgMCkgYnJlYWs7XHJcblx0XHR2W25leHRdID0gYjsgXHJcblx0XHRwcmV2ID0gbmV4dCArIDE7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfc3BsaXQobmFtZSwgcHJlc2VydmVfZW1vamkpIHtcclxuXHRyZXR1cm4gc3BsaXQobmFtZSwgbmZjLCBwcmVzZXJ2ZV9lbW9qaSA/IHggPT4geC5zbGljZSgpIDogZmlsdGVyX2ZlMGYpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwbGl0KG5hbWUsIG5mLCBlZikge1xyXG5cdGlmICghbmFtZSkgcmV0dXJuIFtdOyAvLyAyMDIzMDcxOTogZW1wdHkgbmFtZSBhbGxvd2FuY2VcclxuXHRpbml0KCk7XHJcblx0bGV0IG9mZnNldCA9IDA7XHJcblx0Ly8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYvI1ZhbGlkaXR5X0NyaXRlcmlhXHJcblx0Ly8gNC4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGNvbnRhaW4gYSBVKzAwMkUgKCAuICkgRlVMTCBTVE9QLlwiXHJcblx0cmV0dXJuIG5hbWUuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHtcclxuXHRcdGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobGFiZWwpO1xyXG5cdFx0bGV0IGluZm8gPSB7XHJcblx0XHRcdGlucHV0LFxyXG5cdFx0XHRvZmZzZXQsIC8vIGNvZGVwb2ludCwgbm90IHN1YnN0cmluZyFcclxuXHRcdH07XHJcblx0XHRvZmZzZXQgKz0gaW5wdXQubGVuZ3RoICsgMTsgLy8gKyBzdG9wXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyAxLikgXCJUaGUgbGFiZWwgbXVzdCBiZSBpbiBVbmljb2RlIE5vcm1hbGl6YXRpb24gRm9ybSBORkNcIlxyXG5cdFx0XHRsZXQgdG9rZW5zID0gaW5mby50b2tlbnMgPSB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZik7XHJcblx0XHRcdGxldCB0b2tlbl9jb3VudCA9IHRva2Vucy5sZW5ndGg7XHJcblx0XHRcdGxldCB0eXBlO1xyXG5cdFx0XHRpZiAoIXRva2VuX2NvdW50KSB7IC8vIHRoZSBsYWJlbCB3YXMgZWZmZWN0aXZlbHkgZW1wdHkgKGNvdWxkIG9mIGhhZCBpZ25vcmVkIGNoYXJhY3RlcnMpXHJcblx0XHRcdFx0Ly9ub3JtID0gW107XHJcblx0XHRcdFx0Ly90eXBlID0gJ05vbmUnOyAvLyB1c2UgdGhpcyBpbnN0ZWFkIG9mIG5leHQgbWF0Y2gsIFwiQVNDSUlcIlxyXG5cdFx0XHRcdC8vIDIwMjMwMTIwOiBjaGFuZ2UgdG8gc3RyaWN0XHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvZW5zLW5hbWUtbm9ybWFsaXphdGlvbi0ybmQvMTQ1NjQvNTlcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGVtcHR5IGxhYmVsYCk7XHJcblx0XHRcdH0gXHJcblx0XHRcdGxldCBub3JtID0gaW5mby5vdXRwdXQgPSB0b2tlbnMuZmxhdCgpO1xyXG5cdFx0XHRjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUobm9ybSk7XHJcblx0XHRcdGxldCBlbW9qaSA9IGluZm8uZW1vamkgPSB0b2tlbl9jb3VudCA+IDEgfHwgdG9rZW5zWzBdLmlzX2Vtb2ppOyAvLyBzYW1lIGFzOiB0b2tlbnMuc29tZSh4ID0+IHguaXNfZW1vamkpO1xyXG5cdFx0XHRpZiAoIWVtb2ppICYmIG5vcm0uZXZlcnkoY3AgPT4gY3AgPCAweDgwKSkgeyAvLyBzcGVjaWFsIGNhc2UgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjM6IG1hdGNoZXMgbWF0Y2hlcyBXSEFUV0csIHNlZSBub3RlIDMuM1xyXG5cdFx0XHRcdGNoZWNrX2xhYmVsX2V4dGVuc2lvbihub3JtKTsgLy8gb25seSBuZWVkZWQgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGZlbmNlZFxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSBjbVxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSB3aG9sZXNcclxuXHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIkZhc3RwYXRoIEFTQ0lJXCJcclxuXHRcdFx0XHR0eXBlID0gJ0FTQ0lJJztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY2hhcnMgPSB0b2tlbnMuZmxhdE1hcCh4ID0+IHguaXNfZW1vamkgPyBbXSA6IHgpOyAvLyBhbGwgb2YgdGhlIG5mYyB0b2tlbnMgY29uY2F0IHRvZ2V0aGVyXHJcblx0XHRcdFx0aWYgKCFjaGFycy5sZW5ndGgpIHsgLy8gdGhlcmVzIG5vIHRleHQsIGp1c3QgZW1vamlcclxuXHRcdFx0XHRcdHR5cGUgPSAnRW1vamknO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyA1LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgYmVnaW4gd2l0aCBhIGNvbWJpbmluZyBtYXJrLCB0aGF0IGlzOiBHZW5lcmFsX0NhdGVnb3J5PU1hcmsuXCJcclxuXHRcdFx0XHRcdGlmIChDTS5oYXMobm9ybVswXSkpIHRocm93IGVycm9yX3BsYWNlbWVudCgnbGVhZGluZyBjb21iaW5pbmcgbWFyaycpO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0b2tlbl9jb3VudDsgaSsrKSB7IC8vIHdlJ3ZlIGFscmVhZHkgY2hlY2tlZCB0aGUgZmlyc3QgdG9rZW5cclxuXHRcdFx0XHRcdFx0bGV0IGNwcyA9IHRva2Vuc1tpXTtcclxuXHRcdFx0XHRcdFx0aWYgKCFjcHMuaXNfZW1vamkgJiYgQ00uaGFzKGNwc1swXSkpIHsgLy8gZXZlcnkgdGV4dCB0b2tlbiBoYXMgZW1vamkgbmVpZ2hib3JzLCBlZy4gRXRFRUV0RXQuLi5cclxuXHRcdFx0XHRcdFx0XHQvLyBiaWRpX3FxKCkgbm90IG5lZWRlZCBzaW5jZSBlbW9qaSBpcyBMVFIgYW5kIGNwcyBpcyBhIENNXHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgZXJyb3JfcGxhY2VtZW50KGBlbW9qaSArIGNvbWJpbmluZyBtYXJrOiBcIiR7c3RyX2Zyb21fY3BzKHRva2Vuc1tpLTFdKX0gKyAke3NhZmVfc3RyX2Zyb21fY3BzKFtjcHNbMF1dKX1cImApOyBcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2hlY2tfZmVuY2VkKG5vcm0pO1xyXG5cdFx0XHRcdFx0bGV0IHVuaXF1ZSA9IEFycmF5X2Zyb20obmV3IFNldChjaGFycykpO1xyXG5cdFx0XHRcdFx0bGV0IFtnXSA9IGRldGVybWluZV9ncm91cCh1bmlxdWUpOyAvLyB0YWtlIHRoZSBmaXJzdCBtYXRjaFxyXG5cdFx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJNYXRjaGluZyBHcm91cHMgaGF2ZSBTYW1lIENNIFN0eWxlXCJcclxuXHRcdFx0XHRcdC8vIGFsdGVybmF0aXZlOiBjb3VsZCBmb3JtIGEgaHlicmlkIHR5cGU6IExhdGluL0phcGFuZXNlLy4uLlx0XHJcblx0XHRcdFx0XHRjaGVja19ncm91cChnLCBjaGFycyk7IC8vIG5lZWQgdGV4dCBpbiBvcmRlclxyXG5cdFx0XHRcdFx0Y2hlY2tfd2hvbGUoZywgdW5pcXVlKTsgLy8gb25seSBuZWVkIHVuaXF1ZSB0ZXh0IChvcmRlciB3b3VsZCBiZSByZXF1aXJlZCBmb3IgbXVsdGlwbGUtY2hhciBjb25mdXNhYmxlcylcclxuXHRcdFx0XHRcdHR5cGUgPSBnLk47XHJcblx0XHRcdFx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgZXhwb3NpbmcgcmVzdHJpY3RlZCBmbGFnXHJcblx0XHRcdFx0XHQvLyBpdCdzIHNpbXBsZXIgdG8ganVzdCBjaGVjayBmb3IgJ1Jlc3RyaWN0ZWQnXHJcblx0XHRcdFx0XHQvLyBvciBldmVuIGJldHRlcjogdHlwZS5lbmRzV2l0aCgnXScpXHJcblx0XHRcdFx0XHQvL2lmIChnLlIpIGluZm8ucmVzdHJpY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGluZm8udHlwZSA9IHR5cGU7XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0aW5mby5lcnJvciA9IGVycjsgLy8gdXNlIGZ1bGwgZXJyb3Igb2JqZWN0XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaW5mbztcclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tfd2hvbGUoZ3JvdXAsIHVuaXF1ZSkge1xyXG5cdGxldCBtYWtlcjtcclxuXHRsZXQgc2hhcmVkID0gW107XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHRsZXQgd2hvbGUgPSBXSE9MRV9NQVAuZ2V0KGNwKTtcclxuXHRcdGlmICh3aG9sZSA9PT0gVU5JUVVFX1BIKSByZXR1cm47IC8vIHVuaXF1ZSwgbm9uLWNvbmZ1c2FibGVcclxuXHRcdGlmICh3aG9sZSkge1xyXG5cdFx0XHRsZXQgc2V0ID0gd2hvbGUuTS5nZXQoY3ApOyAvLyBncm91cHMgd2hpY2ggaGF2ZSBhIGNoYXJhY3RlciB0aGF0IGxvb2stbGlrZSB0aGlzIGNoYXJhY3RlclxyXG5cdFx0XHRtYWtlciA9IG1ha2VyID8gbWFrZXIuZmlsdGVyKGcgPT4gc2V0LmhhcyhnKSkgOiBBcnJheV9mcm9tKHNldCk7XHJcblx0XHRcdGlmICghbWFrZXIubGVuZ3RoKSByZXR1cm47IC8vIGNvbmZ1c2FibGUgaW50ZXJzZWN0aW9uIGlzIGVtcHR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzaGFyZWQucHVzaChjcCk7IFxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobWFrZXIpIHtcclxuXHRcdC8vIHdlIGhhdmUgMSsgY29uZnVzYWJsZVxyXG5cdFx0Ly8gY2hlY2sgaWYgYW55IG9mIHRoZSByZW1haW5pbmcgZ3JvdXBzXHJcblx0XHQvLyBjb250YWluIHRoZSBzaGFyZWQgY2hhcmFjdGVycyB0b29cclxuXHRcdGZvciAobGV0IGcgb2YgbWFrZXIpIHtcclxuXHRcdFx0aWYgKHNoYXJlZC5ldmVyeShjcCA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgd2hvbGUtc2NyaXB0IGNvbmZ1c2FibGU6ICR7Z3JvdXAuTn0vJHtnLk59YCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIGFzc3VtcHRpb246IHVuaXF1ZS5zaXplID4gMFxyXG4vLyByZXR1cm5zIGxpc3Qgb2YgbWF0Y2hpbmcgZ3JvdXBzXHJcbmZ1bmN0aW9uIGRldGVybWluZV9ncm91cCh1bmlxdWUpIHtcclxuXHRsZXQgZ3JvdXBzID0gR1JPVVBTO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0Ly8gbm90ZTogd2UgbmVlZCB0byBkb2RnZSBDTSB0aGF0IGFyZSB3aGl0ZWxpc3RlZFxyXG5cdFx0Ly8gYnV0IHRoYXQgY29kZSBpc24ndCBjdXJyZW50bHkgbmVjZXNzYXJ5XHJcblx0XHRsZXQgZ3MgPSBncm91cHMuZmlsdGVyKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSk7XHJcblx0XHRpZiAoIWdzLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAoIUdST1VQUy5zb21lKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSkpIHsgXHJcblx0XHRcdFx0Ly8gdGhlIGNoYXJhY3RlciB3YXMgY29tcG9zZWQgb2YgdmFsaWQgcGFydHNcclxuXHRcdFx0XHQvLyBidXQgaXQncyBORkMgZm9ybSBpcyBpbnZhbGlkXHJcblx0XHRcdFx0Ly8gMjAyMzA3MTY6IGNoYW5nZSB0byBtb3JlIGV4YWN0IHN0YXRlbWVudCwgc2VlOiBFTlNOb3JtYWxpemUue2NzLGphdmF9XHJcblx0XHRcdFx0Ly8gbm90ZTogdGhpcyBkb2Vzbid0IGhhdmUgdG8gYmUgYSBjb21wb3NpdGlvblxyXG5cdFx0XHRcdC8vIDIwMjMwNzIwOiBjaGFuZ2UgdG8gZnVsbCBjaGVja1xyXG5cdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApOyAvLyB0aGlzIHNob3VsZCBiZSByYXJlXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gdGhlcmUgaXMgbm8gZ3JvdXAgdGhhdCBjb250YWlucyBhbGwgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdFx0XHRcdC8vIHRocm93IHVzaW5nIHRoZSBoaWdoZXN0IHByaW9yaXR5IGdyb3VwIHRoYXQgbWF0Y2hlZFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jbWl4ZWRfc2NyaXB0X2NvbmZ1c2FibGVzXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGdyb3Vwc1swXSwgY3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRncm91cHMgPSBncztcclxuXHRcdGlmIChncy5sZW5ndGggPT0gMSkgYnJlYWs7IC8vIHRoZXJlIGlzIG9ubHkgb25lIGdyb3VwIGxlZnRcclxuXHR9XHJcblx0Ly8gdGhlcmUgYXJlIGF0IGxlYXN0IDEgZ3JvdXAocykgd2l0aCBhbGwgb2YgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdHJldHVybiBncm91cHM7XHJcbn1cclxuXHJcbi8vIHRocm93IG9uIGZpcnN0IGVycm9yXHJcbmZ1bmN0aW9uIGZsYXR0ZW4oc3BsaXQpIHtcclxuXHRyZXR1cm4gc3BsaXQubWFwKCh7aW5wdXQsIGVycm9yLCBvdXRwdXR9KSA9PiB7XHJcblx0XHRpZiAoZXJyb3IpIHtcclxuXHRcdFx0Ly8gZG9uJ3QgcHJpbnQgbGFiZWwgYWdhaW4gaWYganVzdCBhIHNpbmdsZSBsYWJlbFxyXG5cdFx0XHRsZXQgbXNnID0gZXJyb3IubWVzc2FnZTtcclxuXHRcdFx0Ly8gYmlkaV9xcSgpIG9ubHkgbmVjZXNzYXJ5IGlmIG1zZyBpcyBkaWdpdHNcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKHNwbGl0Lmxlbmd0aCA9PSAxID8gbXNnIDogYEludmFsaWQgbGFiZWwgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKGlucHV0LCA2MykpfTogJHttc2d9YCk7IFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cl9mcm9tX2NwcyhvdXRwdXQpO1xyXG5cdH0pLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVycm9yX2Rpc2FsbG93ZWQoY3ApIHtcclxuXHQvLyBUT0RPOiBhZGQgY3AgdG8gZXJyb3I/XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkX2NwKGNwKX1gKTsgXHJcbn1cclxuZnVuY3Rpb24gZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKSB7XHJcblx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0bGV0IGdnID0gR1JPVVBTLmZpbmQoZyA9PiBnLlAuaGFzKGNwKSk7IC8vIG9ubHkgY2hlY2sgcHJpbWFyeVxyXG5cdGlmIChnZykge1xyXG5cdFx0cXVvdGVkID0gYCR7Z2cuTn0gJHtxdW90ZWR9YDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgaWxsZWdhbCBtaXh0dXJlOiAke2cuTn0gKyAke3F1b3RlZH1gKTtcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9wbGFjZW1lbnQod2hlcmUpIHtcclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIHBsYWNlbWVudDogJHt3aGVyZX1gKTtcclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogY3BzLmxlbmd0aCA+IDBcclxuLy8gYXNzdW1wdGlvbjogY3BzWzBdIGlzbid0IGEgQ01cclxuLy8gYXNzdW1wdGlvbjogdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpc24ndCBhbiBlbW9qaVxyXG5mdW5jdGlvbiBjaGVja19ncm91cChnLCBjcHMpIHtcclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdGlmICghZ3JvdXBfaGFzX2NwKGcsIGNwKSkge1xyXG5cdFx0XHQvLyBmb3Igd2hpdGVsaXN0ZWQgc2NyaXB0cywgdGhpcyB3aWxsIHRocm93IGlsbGVnYWwgbWl4dHVyZSBvbiBpbnZhbGlkIGNtLCBlZy4gXCJlezMwMH17MzAwfVwiXHJcblx0XHRcdC8vIGF0IHRoZSBtb21lbnQsIGl0J3MgdW5uZWNlc3NhcnkgdG8gaW50cm9kdWNlIGFuIGV4dHJhIGVycm9yIHR5cGVcclxuXHRcdFx0Ly8gdW50aWwgdGhlcmUgZXhpc3RzIGEgd2hpdGVsaXN0ZWQgbXVsdGktY2hhcmFjdGVyXHJcblx0XHRcdC8vICAgZWcuIGlmIChNIDwgMCAmJiBpc19jb21iaW5pbmdfbWFyayhjcCkpIHsgLi4uIH1cclxuXHRcdFx0Ly8gdGhlcmUgYXJlIDMgY2FzZXM6XHJcblx0XHRcdC8vICAgMS4gaWxsZWdhbCBjbSBmb3Igd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHQvLyAgIDIuIGlsbGVnYWwgY20gZm9yIHNhbWUgZ3JvdXAgPT4gY20gZXJyb3JcclxuXHRcdFx0Ly8gICAgICAgcmVxdWlyZXMgc2V0IG9mIHdoaXRlbGlzdCBjbSBwZXIgZ3JvdXA6IFxyXG5cdFx0XHQvLyAgICAgICAgZWcuIG5ldyBTZXQoWy4uLmcuUCwgLi4uZy5RXS5mbGF0TWFwKG5mYykuZmlsdGVyKGNwID0+IENNLmhhcyhjcCkpKVxyXG5cdFx0XHQvLyAgIDMuIHdyb25nIGdyb3VwID0+IG1peHR1cmUgZXJyb3JcclxuXHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly9pZiAoTSA+PSAwKSB7IC8vIHdlIGhhdmUgYSBrbm93biBmaXhlZCBjbSBjb3VudFxyXG5cdGlmIChnLk0pIHsgLy8gd2UgbmVlZCB0byBjaGVjayBmb3IgTlNNXHJcblx0XHRsZXQgZGVjb21wb3NlZCA9IG5mZChjcHMpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDEsIGUgPSBkZWNvbXBvc2VkLmxlbmd0aDsgaSA8IGU7IGkrKykgeyAvLyBzZWU6IGFzc3VtcHRpb25cclxuXHRcdFx0Ly8gMjAyMzAyMTA6IGJ1Z2ZpeDogdXNpbmcgY3BzIGluc3RlYWQgb2YgZGVjb21wb3NlZCBoL3QgQ2FyYm9uMjI1XHJcblx0XHRcdC8qXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogJHtnLk59ICR7YmlkaV9xcShzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdFx0Ki9cclxuXHRcdFx0Ly8gMjAyMzAyMTc6IHN3aXRjaCB0byBOU00gY291bnRpbmdcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNPcHRpb25hbF9EZXRlY3Rpb25cclxuXHRcdFx0aWYgKE5TTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdGZvciAobGV0IGNwOyBqIDwgZSAmJiBOU00uaGFzKGNwID0gZGVjb21wb3NlZFtqXSk7IGorKykge1xyXG5cdFx0XHRcdFx0Ly8gYS4gRm9yYmlkIHNlcXVlbmNlcyBvZiB0aGUgc2FtZSBub25zcGFjaW5nIG1hcmsuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBrID0gaTsgayA8IGo7IGsrKykgeyAvLyBPKG5eMikgYnV0IG4gPCAxMDBcclxuXHRcdFx0XHRcdFx0aWYgKGRlY29tcG9zZWRba10gPT0gY3ApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBub24tc3BhY2luZyBtYXJrczogJHtxdW90ZWRfY3AoY3ApfWApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHBhcnNlIHRvIGVuZCBzbyB3ZSBoYXZlIGZ1bGwgbnNtIGNvdW50XHJcblx0XHRcdFx0Ly8gYi4gRm9yYmlkIHNlcXVlbmNlcyBvZiBtb3JlIHRoYW4gNCBub25zcGFjaW5nIG1hcmtzIChnYz1NbiBvciBnYz1NZSkuXHJcblx0XHRcdFx0aWYgKGogLSBpID4gTlNNX01BWCkge1xyXG5cdFx0XHRcdFx0Ly8gbm90ZTogdGhpcyBzbGljZSBzdGFydHMgd2l0aCBhIGJhc2UgY2hhciBvciBzcGFjaW5nLW1hcmsgY21cclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZXhjZXNzaXZlIG5vbi1zcGFjaW5nIG1hcmtzOiAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtOU01fTUFYfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdC8qXHJcblx0bGV0IGNtX3doaXRlbGlzdCA9IE0gaW5zdGFuY2VvZiBNYXA7XHJcblx0Zm9yIChsZXQgaSA9IDAsIGUgPSBjcHMubGVuZ3RoOyBpIDwgZTsgKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaSsrXTtcclxuXHRcdGxldCBzZXFzID0gY21fd2hpdGVsaXN0ICYmIE0uZ2V0KGNwKTtcclxuXHRcdGlmIChzZXFzKSB7IFxyXG5cdFx0XHQvLyBsaXN0IG9mIGNvZGVwb2ludHMgdGhhdCBjYW4gZm9sbG93XHJcblx0XHRcdC8vIGlmIHRoaXMgZXhpc3RzLCB0aGlzIHdpbGwgYWx3YXlzIGJlIDErXHJcblx0XHRcdGxldCBqID0gaTtcclxuXHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhjcHNbal0pKSBqKys7XHJcblx0XHRcdGxldCBjbXMgPSBjcHMuc2xpY2UoaSwgaik7XHJcblx0XHRcdGxldCBtYXRjaCA9IHNlcXMuZmluZChzZXEgPT4gIWNvbXBhcmVfYXJyYXlzKHNlcSwgY21zKSk7XHJcblx0XHRcdGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjb21iaW5pbmcgbWFyayBzZXF1ZW5jZTogXCIke3NhZmVfc3RyX2Zyb21fY3BzKFtjcCwgLi4uY21zXSl9XCJgKTtcclxuXHRcdFx0aSA9IGo7XHJcblx0XHR9IGVsc2UgaWYgKCFWLmhhcyhjcCkpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRcdGxldCB1ID0gVU5JUVVFLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKHUgJiYgdSAhPT0gZykge1xyXG5cdFx0XHRcdFx0Ly8gaWYgYm90aCBzY3JpcHRzIGFyZSByZXN0cmljdGVkIHRoaXMgZXJyb3IgaXMgY29uZnVzaW5nXHJcblx0XHRcdFx0XHQvLyBiZWNhdXNlIHdlIGRvbid0IGRpZmZlcmVudGlhdGUgUmVzdHJpY3RlZEEgZnJvbSBSZXN0cmljdGVkQiBcclxuXHRcdFx0XHRcdGlmICghdS5SKSBxdW90ZWQgPSBgJHtxdW90ZWR9IGlzICR7dS5OfWA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkICR7Zy5OfSBjaGFyYWN0ZXI6ICR7cXVvdGVkfWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkfSAoZXhwZWN0ZWQgJHtnLk59KWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgJHtnLk59IGRvZXMgbm90IGFsbG93OiAke3F1b3RlZH1gKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKCFjbV93aGl0ZWxpc3QpIHtcclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHdlIGtub3cgaXQgY2FuJ3QgYmUgY20gbGVhZGluZ1xyXG5cdFx0XHRpZiAoQ00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGRlY29tcG9zZWRbal0pKSBqKys7XHJcblx0XHRcdFx0aWYgKGogLSBpID4gTSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB0b28gbWFueSBjb21iaW5pbmcgbWFya3M6IFwiJHtzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKX1cIiAoJHtqLWl9LyR7TX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdCovXHJcbn1cclxuXHJcbi8vIGdpdmVuIGEgbGlzdCBvZiBjb2RlcG9pbnRzXHJcbi8vIHJldHVybnMgYSBsaXN0IG9mIGxpc3RzLCB3aGVyZSBlbW9qaSBhcmUgYSBmdWxseS1xdWFsaWZpZWQgKGFzIEFycmF5IHN1YmNsYXNzKVxyXG4vLyBlZy4gZXhwbG9kZV9jcChcImFiY/CfkqlkXCIpID0+IFtbNjEsIDYyLCA2M10sIEVtb2ppWzFGNEE5LCBGRTBGXSwgWzY0XV1cclxuLy8gMjAyMzA4MTg6IHJlbmFtZSBmb3IgJ3Byb2Nlc3MnIG5hbWUgY29sbGlzaW9uIGgvdCBKYXZhcm9tZVxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2lzc3Vlcy8yM1xyXG5mdW5jdGlvbiB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgY2hhcnMgPSBbXTtcclxuXHRpbnB1dCA9IGlucHV0LnNsaWNlKCkucmV2ZXJzZSgpOyAvLyBmbGlwIHNvIHdlIGNhbiBwb3BcclxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XHJcblx0XHRsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0KTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHRcdFx0XHRjaGFycyA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldC5wdXNoKGVmKGVtb2ppKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKFZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRjaGFycy5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0Y2hhcnMucHVzaCguLi5jcHMpOyAvLyBsZXNzIHRoYW4gMTAgZWxlbWVudHNcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCFJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRcdC8vIDIwMjMwOTEyOiB1bmljb2RlIDE1LjEgY2hhbmdlZCB0aGUgb3JkZXIgb2YgcHJvY2Vzc2luZyBzdWNoIHRoYXRcclxuXHRcdFx0XHRcdC8vIGRpc2FsbG93ZWQgcGFydHMgYXJlIG9ubHkgcmVqZWN0ZWQgYWZ0ZXIgTkZDXHJcblx0XHRcdFx0XHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHRcdFx0XHRcdC8vIHRoaXMgZG9lc24ndCBpbXBhY3Qgbm9ybWFsaXphdGlvbiBhcyBvZiB0b2RheVxyXG5cdFx0XHRcdFx0Ly8gdGVjaG5pY2FsbHksIHRoaXMgZXJyb3IgY2FuIGJlIHJlbW92ZWQgYXMgdGhlIGdyb3VwIGxvZ2ljIHdpbGwgYXBwbHkgc2ltaWxhciBsb2dpY1xyXG5cdFx0XHRcdFx0Ly8gaG93ZXZlciB0aGUgZXJyb3IgdHlwZSBtaWdodCBiZSBsZXNzIGNsZWFyXHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNoYXJzLmxlbmd0aCkge1xyXG5cdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyX2ZlMGYoY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5maWx0ZXIoY3AgPT4gY3AgIT0gRkUwRik7XHJcbn1cclxuXHJcbi8vIGdpdmVuIGFycmF5IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyB0aGUgbG9uZ2VzdCB2YWxpZCBlbW9qaSBzZXF1ZW5jZSAob3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoKVxyXG4vLyAqTVVUQVRFUyogdGhlIHN1cHBsaWVkIGFycmF5XHJcbi8vIGRpc2FsbG93cyBpbnRlcmxlYXZlZCBpZ25vcmVkIGNoYXJhY3RlcnNcclxuLy8gZmlsbHMgKG9wdGlvbmFsKSBlYXRlbiBhcnJheSB3aXRoIG1hdGNoZWQgY29kZXBvaW50c1xyXG5mdW5jdGlvbiBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGNwcywgZWF0ZW4pIHtcclxuXHRsZXQgbm9kZSA9IEVNT0pJX1JPT1Q7XHJcblx0bGV0IGVtb2ppO1xyXG5cdGxldCBwb3MgPSBjcHMubGVuZ3RoO1xyXG5cdHdoaWxlIChwb3MpIHtcclxuXHRcdG5vZGUgPSBub2RlLmdldChjcHNbLS1wb3NdKTtcclxuXHRcdGlmICghbm9kZSkgYnJlYWs7XHJcblx0XHRsZXQge1Z9ID0gbm9kZTtcclxuXHRcdGlmIChWKSB7IC8vIHRoaXMgaXMgYSB2YWxpZCBlbW9qaSAoc28gZmFyKVxyXG5cdFx0XHRlbW9qaSA9IFY7XHJcblx0XHRcdGlmIChlYXRlbikgZWF0ZW4ucHVzaCguLi5jcHMuc2xpY2UocG9zKS5yZXZlcnNlKCkpOyAvLyAob3B0aW9uYWwpIGNvcHkgaW5wdXQsIHVzZWQgZm9yIGVuc190b2tlbml6ZSgpXHJcblx0XHRcdGNwcy5sZW5ndGggPSBwb3M7IC8vIHRydW5jYXRlXHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBlbW9qaTtcclxufVxyXG5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vIHRva2VuaXplciBcclxuXHJcbmNvbnN0IFRZX1ZBTElEID0gJ3ZhbGlkJztcclxuY29uc3QgVFlfTUFQUEVEID0gJ21hcHBlZCc7XHJcbmNvbnN0IFRZX0lHTk9SRUQgPSAnaWdub3JlZCc7XHJcbmNvbnN0IFRZX0RJU0FMTE9XRUQgPSAnZGlzYWxsb3dlZCc7XHJcbmNvbnN0IFRZX0VNT0pJID0gJ2Vtb2ppJztcclxuY29uc3QgVFlfTkZDID0gJ25mYyc7XHJcbmNvbnN0IFRZX1NUT1AgPSAnc3RvcCc7XHJcblxyXG5mdW5jdGlvbiBlbnNfdG9rZW5pemUobmFtZSwge1xyXG5cdG5mID0gdHJ1ZSwgLy8gY29sbGFwc2UgdW5ub3JtYWxpemVkIHJ1bnMgaW50byBhIHNpbmdsZSB0b2tlblxyXG59ID0ge30pIHtcclxuXHRpbml0KCk7XHJcblx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChuYW1lKS5yZXZlcnNlKCk7XHJcblx0bGV0IGVhdGVuID0gW107XHJcblx0bGV0IHRva2VucyA9IFtdO1xyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQsIGVhdGVuKTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHR0b2tlbnMucHVzaCh7XHJcblx0XHRcdFx0dHlwZTogVFlfRU1PSkksXHJcblx0XHRcdFx0ZW1vamk6IGVtb2ppLnNsaWNlKCksIC8vIGNvcHkgZW1vamlcclxuXHRcdFx0XHRpbnB1dDogZWF0ZW4sXHJcblx0XHRcdFx0Y3BzOiBmaWx0ZXJfZmUwZihlbW9qaSlcclxuXHRcdFx0fSk7XHJcblx0XHRcdGVhdGVuID0gW107IC8vIHJlc2V0IGJ1ZmZlclxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNwID0gaW5wdXQucG9wKCk7XHJcblx0XHRcdGlmIChjcCA9PSBTVE9QKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1NUT1AsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9WQUxJRCwgY3BzOiBbY3BdfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoSUdOT1JFRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0lHTk9SRUQsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNwcyA9IE1BUFBFRC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChjcHMpIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9NQVBQRUQsIGNwLCBjcHM6IGNwcy5zbGljZSgpfSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9ESVNBTExPV0VELCBjcH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobmYpIHtcclxuXHRcdGZvciAobGV0IGkgPSAwLCBzdGFydCA9IC0xOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCB0b2tlbiA9IHRva2Vuc1tpXTtcclxuXHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0b2tlbi50eXBlKSkge1xyXG5cdFx0XHRcdGlmIChyZXF1aXJlc19jaGVjayh0b2tlbi5jcHMpKSB7IC8vIG5vcm1hbGl6YXRpb24gbWlnaHQgYmUgbmVlZGVkXHJcblx0XHRcdFx0XHRsZXQgZW5kID0gaSArIDE7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBwb3MgPSBlbmQ7IHBvcyA8IHRva2Vucy5sZW5ndGg7IHBvcysrKSB7IC8vIGZpbmQgYWRqYWNlbnQgdGV4dFxyXG5cdFx0XHRcdFx0XHRsZXQge3R5cGUsIGNwc30gPSB0b2tlbnNbcG9zXTtcclxuXHRcdFx0XHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0eXBlKSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICghcmVxdWlyZXNfY2hlY2soY3BzKSkgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0ZW5kID0gcG9zICsgMTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlICE9PSBUWV9JR05PUkVEKSB7IC8vIHx8IHR5cGUgIT09IFRZX0RJU0FMTE9XRUQpIHsgXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChzdGFydCA8IDApIHN0YXJ0ID0gaTtcclxuXHRcdFx0XHRcdGxldCBzbGljZSA9IHRva2Vucy5zbGljZShzdGFydCwgZW5kKTtcclxuXHRcdFx0XHRcdGxldCBjcHMwID0gc2xpY2UuZmxhdE1hcCh4ID0+IGlzX3ZhbGlkX29yX21hcHBlZCh4LnR5cGUpID8geC5jcHMgOiBbXSk7IC8vIHN0cmlwIGp1bmsgdG9rZW5zXHJcblx0XHRcdFx0XHRsZXQgY3BzID0gbmZjKGNwczApO1xyXG5cdFx0XHRcdFx0aWYgKGNvbXBhcmVfYXJyYXlzKGNwcywgY3BzMCkpIHsgLy8gYnVuZGxlIGludG8gYW4gbmZjIHRva2VuXHJcblx0XHRcdFx0XHRcdHRva2Vucy5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0LCB7XHJcblx0XHRcdFx0XHRcdFx0dHlwZTogVFlfTkZDLCBcclxuXHRcdFx0XHRcdFx0XHRpbnB1dDogY3BzMCwgLy8gdGhlcmUgYXJlIDMgc3RhdGVzOiB0b2tlbnMwID09KHByb2Nlc3MpPT4gaW5wdXQgPT0obmZjKT0+IHRva2Vucy9jcHNcclxuXHRcdFx0XHRcdFx0XHRjcHMsIFxyXG5cdFx0XHRcdFx0XHRcdHRva2VuczA6IGNvbGxhcHNlX3ZhbGlkX3Rva2VucyhzbGljZSksXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zOiBlbnNfdG9rZW5pemUoc3RyX2Zyb21fY3BzKGNwcyksIHtuZjogZmFsc2V9KVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0aSA9IHN0YXJ0O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHsgXHJcblx0XHRcdFx0XHRcdGkgPSBlbmQgLSAxOyAvLyBza2lwIHRvIGVuZCBvZiBzbGljZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3RhcnQgPSAtMTsgLy8gcmVzZXRcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBpOyAvLyByZW1lbWJlciBsYXN0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gMjAyMjEwMjQ6IGlzIHRoaXMgY29ycmVjdD9cclxuXHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpIHtcclxuXHRyZXR1cm4gdHlwZSA9PSBUWV9WQUxJRCB8fCB0eXBlID09IFRZX01BUFBFRDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWlyZXNfY2hlY2soY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5zb21lKGNwID0+IE5GQ19DSEVDSy5oYXMoY3ApKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29sbGFwc2VfdmFsaWRfdG9rZW5zKHRva2Vucykge1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAodG9rZW5zW2ldLnR5cGUgPT0gVFlfVkFMSUQpIHtcclxuXHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0d2hpbGUgKGogPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tqXS50eXBlID09IFRZX1ZBTElEKSBqKys7XHJcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwgaiAtIGksIHt0eXBlOiBUWV9WQUxJRCwgY3BzOiB0b2tlbnMuc2xpY2UoaSwgaikuZmxhdE1hcCh4ID0+IHguY3BzKX0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdG9rZW5zO1xyXG59XG5cbmV4cG9ydCB7IGVuc19iZWF1dGlmeSwgZW5zX2Vtb2ppLCBlbnNfbm9ybWFsaXplLCBlbnNfbm9ybWFsaXplX2ZyYWdtZW50LCBlbnNfc3BsaXQsIGVuc190b2tlbml6ZSwgaXNfY29tYmluaW5nX21hcmssIG5mYywgbmZkLCBzYWZlX3N0cl9mcm9tX2Nwcywgc2hvdWxkX2VzY2FwZSB9O1xuIiwiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBoZXhsaWZ5LCBhc3NlcnRBcmd1bWVudCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tIFwiQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZVwiO1xuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5aZXJvcy5maWxsKDApO1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoY29tcCkge1xuICAgIGFzc2VydEFyZ3VtZW50KGNvbXAubGVuZ3RoICE9PSAwLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcImNvbXBcIiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXA7XG59XG5mdW5jdGlvbiBlbnNOYW1lU3BsaXQobmFtZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gdG9VdGY4Qnl0ZXMoZW5zTm9ybWFsaXplKG5hbWUpKTtcbiAgICBjb25zdCBjb21wcyA9IFtdO1xuICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29tcHM7XG4gICAgfVxuICAgIGxldCBsYXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSBieXRlc1tpXTtcbiAgICAgICAgLy8gQSBzZXBhcmF0b3IgKGkuZS4gXCIuXCIpOyBjb3B5IHRoaXMgY29tcG9uZW50XG4gICAgICAgIGlmIChkID09PSAweDJlKSB7XG4gICAgICAgICAgICBjb21wcy5wdXNoKGNoZWNrQ29tcG9uZW50KGJ5dGVzLnNsaWNlKGxhc3QsIGkpKSk7XG4gICAgICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlcmUgd2FzIGEgc3RyYXkgc2VwYXJhdG9yIGF0IHRoZSBlbmQgb2YgdGhlIG5hbWVcbiAgICBhc3NlcnRBcmd1bWVudChsYXN0IDwgYnl0ZXMubGVuZ3RoLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0KSkpO1xuICAgIHJldHVybiBjb21wcztcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIEVOUyAlJW5hbWUlJSBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zTm9ybWFsaXplKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IGxhYmVsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnNfbm9ybWFsaXplKG5hbWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIEVOUyBuYW1lICgke2Vycm9yLm1lc3NhZ2V9KWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlbmFtZSUlIGlzIGEgdmFsaWQgRU5TIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstbmFtZWhhc2hdXSBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuYW1laGFzaChuYW1lKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGFzc2VydEFyZ3VtZW50KG5hbWUubGVuZ3RoLCBgaW52YWxpZCBFTlMgbmFtZSAoZW1wdHkgbGFiZWwpYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGxldCByZXN1bHQgPSBaZXJvcztcbiAgICBjb25zdCBjb21wcyA9IGVuc05hbWVTcGxpdChuYW1lKTtcbiAgICB3aGlsZSAoY29tcHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGtlY2NhazI1Nihjb25jYXQoW3Jlc3VsdCwga2VjY2FrMjU2KChjb21wcy5wb3AoKSkpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgRE5TIGVuY29kZWQgJSVuYW1lJSUuXG4gKlxuICogIFRoaXMgaXMgdXNlZCBmb3IgdmFyaW91cyBwYXJ0cyBvZiBFTlMgbmFtZSByZXNvbHV0aW9uLCBzdWNoXG4gKiAgYXMgdGhlIHdpbGRjYXJkIHJlc29sdXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkbnNFbmNvZGUobmFtZSwgX21heExlbmd0aCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IChfbWF4TGVuZ3RoICE9IG51bGwpID8gX21heExlbmd0aCA6IDYzO1xuICAgIGFzc2VydEFyZ3VtZW50KGxlbmd0aCA8PSAyNTUsIFwiRE5TIGVuY29kZWQgbGFiZWwgY2Fubm90IGV4Y2VlZCAyNTVcIiwgXCJsZW5ndGhcIiwgbGVuZ3RoKTtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4ge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChjb21wLmxlbmd0aCA8PSBsZW5ndGgsIGBsYWJlbCAke0pTT04uc3RyaW5naWZ5KG5hbWUpfSBleGNlZWRzICR7bGVuZ3RofSBieXRlc2AsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjb21wLmxlbmd0aCArIDEpO1xuICAgICAgICBieXRlcy5zZXQoY29tcCwgMSk7XG4gICAgICAgIGJ5dGVzWzBdID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0pKSkgKyBcIjAwXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1laGFzaC5qcy5tYXAiLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBNZXNzYWdlUHJlZml4IH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8qKlxuICogIENvbXB1dGVzIHRoZSBbW2xpbmstZWlwLTE5MV1dIHBlcnNvbmFsLXNpZ24gbWVzc2FnZSBkaWdlc3QgdG8gc2lnbi5cbiAqXG4gKiAgVGhpcyBwcmVmaXhlcyB0aGUgbWVzc2FnZSB3aXRoIFtbTWVzc2FnZVByZWZpeF1dIGFuZCB0aGUgZGVjaW1hbCBsZW5ndGhcbiAqICBvZiAlJW1lc3NhZ2UlJSBhbmQgY29tcHV0ZXMgdGhlIFtba2VjY2FrMjU2XV0gZGlnZXN0LlxuICpcbiAqICBJZiAlJW1lc3NhZ2UlJSBpcyBhIHN0cmluZywgaXQgaXMgY29udmVydGVkIHRvIGl0cyBVVEYtOCBieXRlc1xuICogIGZpcnN0LiBUbyBjb21wdXRlIHRoZSBkaWdlc3Qgb2YgYSBbW0RhdGFIZXhTdHJpbmddXSwgaXQgbXVzdCBiZSBjb252ZXJ0ZWRcbiAqICB0byBbYnl0ZXNdKGdldEJ5dGVzKS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBoYXNoTWVzc2FnZShcIkhlbGxvIFdvcmxkXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSGFzaGVzIHRoZSBTSVggKDYpIHN0cmluZyBjaGFyYWN0ZXJzLCBpLmUuXG4gKiAgICAvLyBbIFwiMFwiLCBcInhcIiwgXCI0XCIsIFwiMlwiLCBcIjRcIiwgXCIzXCIgXVxuICogICAgaGFzaE1lc3NhZ2UoXCIweDQyNDNcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBIYXNoZXMgdGhlIFRXTyAoMikgYnl0ZXMgWyAweDQyLCAweDQzIF0uLi5cbiAqICAgIGhhc2hNZXNzYWdlKGdldEJ5dGVzKFwiMHg0MjQzXCIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIC4uLndoaWNoIGlzIGVxdWFsIHRvIHVzaW5nIGRhdGFcbiAqICAgIGhhc2hNZXNzYWdlKG5ldyBVaW50OEFycmF5KFsgMHg0MiwgMHg0MyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IHRvVXRmOEJ5dGVzKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChbXG4gICAgICAgIHRvVXRmOEJ5dGVzKE1lc3NhZ2VQcmVmaXgpLFxuICAgICAgICB0b1V0ZjhCeXRlcyhTdHJpbmcobWVzc2FnZS5sZW5ndGgpKSxcbiAgICAgICAgbWVzc2FnZVxuICAgIF0pKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgYWRkcmVzcyBvZiB0aGUgcHJpdmF0ZSBrZXkgdGhhdCBwcm9kdWNlZFxuICogIHRoZSBzaWduYXR1cmUgJSVzaWclJSBkdXJpbmcgc2lnbmluZyBmb3IgJSVtZXNzYWdlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlNZXNzYWdlKG1lc3NhZ2UsIHNpZykge1xuICAgIGNvbnN0IGRpZ2VzdCA9IGhhc2hNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlLmpzLm1hcCIsIi8vaW1wb3J0IHsgVHlwZWREYXRhRG9tYWluLCBUeXBlZERhdGFGaWVsZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm92aWRlcmFic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyByZWNvdmVyQWRkcmVzcyB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgbWFzaywgdG9CZUhleCwgdG9RdWFudGl0eSwgdG9Ud29zLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuL2lkLmpzXCI7XG5jb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xucGFkZGluZy5maWxsKDApO1xuY29uc3QgQk5fXzEgPSBCaWdJbnQoLTEpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbjtcbjtcbmZ1bmN0aW9uIGhleFBhZFJpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XG4gICAgY29uc3QgcGFkT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgMzI7XG4gICAgaWYgKHBhZE9mZnNldCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFtieXRlcywgcGFkZGluZy5zbGljZShwYWRPZmZzZXQpXSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbn1cbmNvbnN0IGhleFRydWUgPSB0b0JlSGV4KEJOXzEsIDMyKTtcbmNvbnN0IGhleEZhbHNlID0gdG9CZUhleChCTl8wLCAzMik7XG5jb25zdCBkb21haW5GaWVsZFR5cGVzID0ge1xuICAgIG5hbWU6IFwic3RyaW5nXCIsXG4gICAgdmVyc2lvbjogXCJzdHJpbmdcIixcbiAgICBjaGFpbklkOiBcInVpbnQyNTZcIixcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogXCJhZGRyZXNzXCIsXG4gICAgc2FsdDogXCJieXRlczMyXCJcbn07XG5jb25zdCBkb21haW5GaWVsZE5hbWVzID0gW1xuICAgIFwibmFtZVwiLCBcInZlcnNpb25cIiwgXCJjaGFpbklkXCIsIFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgXCJzYWx0XCJcbl07XG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gLCBgZG9tYWluLiR7a2V5fWAsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG5jb25zdCBkb21haW5DaGVja3MgPSB7XG4gICAgbmFtZTogY2hlY2tTdHJpbmcoXCJuYW1lXCIpLFxuICAgIHZlcnNpb246IGNoZWNrU3RyaW5nKFwidmVyc2lvblwiKSxcbiAgICBjaGFpbklkOiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJkb21haW4uY2hhaW5JZFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gMCwgXCJpbnZhbGlkIGNoYWluIElEXCIsIFwiZG9tYWluLmNoYWluSWRcIiwgX3ZhbHVlKTtcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkodmFsdWUpO1xuICAgIH0sXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInZlcmlmeWluZ0NvbnRyYWN0XCJgLCBcImRvbWFpbi52ZXJpZnlpbmdDb250cmFjdFwiLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSwgXCJkb21haW4uc2FsdFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnl0ZXMubGVuZ3RoID09PSAzMiwgYGludmFsaWQgZG9tYWluIHZhbHVlIFwic2FsdFwiYCwgXCJkb21haW4uc2FsdFwiLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0QmFzZUVuY29kZXIodHlwZSkge1xuICAgIC8vIGludFhYIGFuZCB1aW50WFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXih1PylpbnQoXFxkKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQod2lkdGggJSA4ID09PSAwICYmIHdpZHRoICE9PSAwICYmIHdpZHRoIDw9IDI1NiAmJiBtYXRjaFsyXSA9PT0gU3RyaW5nKHdpZHRoKSwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzVXBwZXIgPSBtYXNrKEJOX01BWF9VSU5UMjU2LCBzaWduZWQgPyAod2lkdGggLSAxKSA6IHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc0xvd2VyID0gc2lnbmVkID8gKChib3VuZHNVcHBlciArIEJOXzEpICogQk5fXzEpIDogQk5fMDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IGJvdW5kc0xvd2VyICYmIHZhbHVlIDw9IGJvdW5kc1VwcGVyLCBgdmFsdWUgb3V0LW9mLWJvdW5kcyBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0JlSGV4KHNpZ25lZCA/IHRvVHdvcyh2YWx1ZSwgMjU2KSA6IHZhbHVlLCAzMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJ5dGVzWFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCspJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQod2lkdGggIT09IDAgJiYgd2lkdGggPD0gMzIgJiYgbWF0Y2hbMV0gPT09IFN0cmluZyh3aWR0aCksIFwiaW52YWxpZCBieXRlcyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnl0ZXMubGVuZ3RoID09PSB3aWR0aCwgYGludmFsaWQgbGVuZ3RoIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFBhZFJpZ2h0KHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvUGFkVmFsdWUoZ2V0QWRkcmVzcyh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgoIXZhbHVlKSA/IGhleEZhbHNlIDogaGV4VHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUobmFtZSwgZmllbGRzKSB7XG4gICAgcmV0dXJuIGAke25hbWV9KCR7ZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+ICh0eXBlICsgXCIgXCIgKyBuYW1lKSkuam9pbihcIixcIil9KWA7XG59XG4vLyBmb29bXVszXSA9PiB7IGJhc2U6IFwiZm9vXCIsIGluZGV4OiBcIltdWzNdXCIsIGFycmF5OiB7XG4vLyAgICAgYmFzZTogXCJmb29cIiwgcHJlZml4OiBcImZvb1tdXCIsIGNvdW50OiAzIH0gfVxuZnVuY3Rpb24gc3BsaXRBcnJheSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKFteXFx4NWJdKikoKFxceDViXFxkKlxceDVkKSopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFzZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICBpbmRleDogKG1hdGNoWzJdICsgbWF0Y2hbNF0pLFxuICAgICAgICAgICAgYXJyYXk6IHtcbiAgICAgICAgICAgICAgICBiYXNlOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IChtYXRjaFsxXSArIG1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBjb3VudDogKG1hdGNoWzVdID8gcGFyc2VJbnQobWF0Y2hbNV0pIDogLTEpLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBiYXNlOiB0eXBlIH07XG59XG4vKipcbiAqICBBICoqVHlwZWREYXRhRW5jb2RlKiogcHJlcGFyZXMgYW5kIGVuY29kZXMgW1tsaW5rLWVpcC03MTJdXSBwYXlsb2Fkc1xuICogIGZvciBzaWduZWQgdHlwZWQgZGF0YS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHRob3NlIHRoYXQgd2lzaCB0byBjb21wdXRlIHZhcmlvdXMgY29tcG9uZW50cyBvZiBhXG4gKiAgdHlwZWQgZGF0YSBoYXNoLCBwcmltYXJ5IHR5cGVzLCBvciBzdWItY29tcG9uZW50cywgYnV0IGdlbmVyYWxseSB0aGVcbiAqICBoaWdoZXIgbGV2ZWwgW1tTaWduZXItc2lnblR5cGVkRGF0YV1dIGlzIG1vcmUgdXNlZnVsLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZWREYXRhRW5jb2RlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmltYXJ5IHR5cGUgZm9yIHRoZSBzdHJ1Y3R1cmVkIFtbdHlwZXNdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGRlcml2ZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBbW3R5cGVzXV0sIHNpbmNlIG5vXG4gICAgICogIHJlY3Vyc2lvbiBpcyBwb3NzaWJsZSwgb25jZSB0aGUgREFHIGZvciB0aGUgdHlwZXMgaXMgY29uc3R1cmN0ZWRcbiAgICAgKiAgaW50ZXJuYWxseSwgdGhlIHByaW1hcnkgdHlwZSBtdXN0IGJlIHRoZSBvbmx5IHJlbWFpbmluZyB0eXBlIHdpdGhcbiAgICAgKiAgbm8gcGFyZW50IG5vZGVzLlxuICAgICAqL1xuICAgIHByaW1hcnlUeXBlO1xuICAgICN0eXBlcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGVzLlxuICAgICAqL1xuICAgIGdldCB0eXBlcygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy4jdHlwZXMpO1xuICAgIH1cbiAgICAjZnVsbFR5cGVzO1xuICAgICNlbmNvZGVyQ2FjaGU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgcGVyZm9ybXMgYWxsIG5lY2Vzc2FyeSBjaGVja2luZyB0aGF0IHR5cGVzIGFyZSB2YWxpZCBhbmRcbiAgICAgKiAgZG8gbm90IHZpb2xhdGUgdGhlIFtbbGluay1laXAtNzEyXV0gc3RydWN0dXJhbCBjb25zdHJhaW50cyBhc1xuICAgICAqICB3ZWxsIGFzIGNvbXB1dGVzIHRoZSBbW3ByaW1hcnlUeXBlXV0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX3R5cGVzKSB7XG4gICAgICAgIHRoaXMuI2Z1bGxUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdCB0eXBlcyB0byB0aGVpciBkaXJlY3QgY2hpbGQgc3RydWN0c1xuICAgICAgICBjb25zdCBsaW5rcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3RzIHRvIHN0cnVjdHMgd2hpY2ggY29udGFpbiB0aGVtIGFzIGEgY2hpbGRcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBhbGwgc3VidHlwZXMgd2l0aGluIGEgZ2l2ZW4gc3RydWN0XG4gICAgICAgIGNvbnN0IHN1YnR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCB0eXBlcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhfdHlwZXMpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gX3R5cGVzW3R5cGVdLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGJhc2UgdHlwZSAodW5sZXNzIG5hbWUgY29uZmxpY3QpXG4gICAgICAgICAgICAgICAgbGV0IHsgYmFzZSwgaW5kZXggfSA9IHNwbGl0QXJyYXkodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwiaW50XCIgJiYgIV90eXBlc1tcImludFwiXSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gXCJpbnQyNTZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwidWludFwiICYmICFfdHlwZXNbXCJ1aW50XCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBcInVpbnQyNTZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgdHlwZTogKGJhc2UgKyAoaW5kZXggfHwgXCJcIikpIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpbmtzLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgcGFyZW50cy5zZXQodHlwZSwgW10pO1xuICAgICAgICAgICAgc3VidHlwZXMuc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiN0eXBlcyA9IEpTT04uc3RyaW5naWZ5KHR5cGVzKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlYWNoIGZpZWxkIGhhcyBhIHVuaXF1ZSBuYW1lXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXVuaXF1ZU5hbWVzLmhhcyhmaWVsZC5uYW1lKSwgYGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lICR7SlNPTi5zdHJpbmdpZnkoZmllbGQubmFtZSl9IGluICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJhc2UgdHlwZSAoZHJvcCBhbnkgYXJyYXkgc3BlY2lmaWVycylcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IHNwbGl0QXJyYXkoZmllbGQudHlwZSkuYmFzZTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChiYXNlVHlwZSAhPT0gbmFtZSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGEgYmFzZSBlbmNvZGluZyB0eXBlP1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2RlcihiYXNlVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHBhcmVudHMuaGFzKGJhc2VUeXBlKSwgYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGxpbmthZ2VcbiAgICAgICAgICAgICAgICBwYXJlbnRzLmdldChiYXNlVHlwZSkucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICBsaW5rcy5nZXQobmFtZSkuYWRkKGJhc2VUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWR1Y2UgdGhlIHByaW1hcnkgdHlwZVxuICAgICAgICBjb25zdCBwcmltYXJ5VHlwZXMgPSBBcnJheS5mcm9tKHBhcmVudHMua2V5cygpKS5maWx0ZXIoKG4pID0+IChwYXJlbnRzLmdldChuKS5sZW5ndGggPT09IDApKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHJpbWFyeVR5cGVzLmxlbmd0aCAhPT0gMCwgXCJtaXNzaW5nIHByaW1hcnkgdHlwZVwiLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggPT09IDEsIGBhbWJpZ3VvdXMgcHJpbWFyeSB0eXBlcyBvciB1bnVzZWQgdHlwZXM6ICR7cHJpbWFyeVR5cGVzLm1hcCgodCkgPT4gKEpTT04uc3RyaW5naWZ5KHQpKSkuam9pbihcIiwgXCIpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByaW1hcnlUeXBlOiBwcmltYXJ5VHlwZXNbMF0gfSk7XG4gICAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZXNcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLCBmb3VuZCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZvdW5kLmhhcyh0eXBlKSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgZm91bmQuYWRkKHR5cGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBsaW5rcy5nZXQodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHMuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY2hlY2sgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBjaGVja0NpcmN1bGFyKGNoaWxkLCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgLy8gTWFyayBhbGwgYW5jZXN0b3JzIGFzIGhhdmluZyB0aGlzIGRlY2VuZGFudFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3VidHlwZSBvZiBmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlcy5nZXQoc3VidHlwZSkuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZC5kZWxldGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDaXJjdWxhcih0aGlzLnByaW1hcnlUeXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAvLyBDb21wdXRlIGVhY2ggZnVsbHkgZGVzY3JpYmUgdHlwZVxuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBzZXRdIG9mIHN1YnR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzdCA9IEFycmF5LmZyb20oc2V0KTtcbiAgICAgICAgICAgIHN0LnNvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuI2Z1bGxUeXBlcy5zZXQobmFtZSwgZW5jb2RlVHlwZShuYW1lLCB0eXBlc1tuYW1lXSkgKyBzdC5tYXAoKHQpID0+IGVuY29kZVR5cGUodCwgdHlwZXNbdF0pKS5qb2luKFwiXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJudGhlIGVuY29kZXIgZm9yIHRoZSBzcGVjaWZpYyAlJXR5cGUlJS5cbiAgICAgKi9cbiAgICBnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgbGV0IGVuY29kZXIgPSB0aGlzLiNlbmNvZGVyQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIWVuY29kZXIpIHtcbiAgICAgICAgICAgIGVuY29kZXIgPSB0aGlzLiNnZXRFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlLnNldCh0eXBlLCBlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICB9XG4gICAgI2dldEVuY29kZXIodHlwZSkge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBhcnJheSA9IHNwbGl0QXJyYXkodHlwZSkuYXJyYXk7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHlwZSA9IGFycmF5LnByZWZpeDtcbiAgICAgICAgICAgIGNvbnN0IHN1YkVuY29kZXIgPSB0aGlzLmdldEVuY29kZXIoc3VidHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYXJyYXkuY291bnQgPT09IC0xIHx8IGFycmF5LmNvdW50ID09PSB2YWx1ZS5sZW5ndGgsIGBhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAke2FycmF5LmNvdW50fWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB2YWx1ZS5tYXAoc3ViRW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXMoc3VidHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChrZWNjYWsyNTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChyZXN1bHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gaWQodGhpcy4jZnVsbFR5cGVzLmdldCh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy51bnNoaWZ0KGVuY29kZWRUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0KHZhbHVlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsIHR5cGUgZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGVuY29kZVR5cGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdWxsVHlwZXMuZ2V0KG5hbWUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQsIGB1bmtub3duIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlICUldHlwZSUlLlxuICAgICAqL1xuICAgIGVuY29kZURhdGEodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBoYXNoIG9mICUldmFsdWUlJSBmb3IgdGhlIHR5cGUgb2YgJSVuYW1lJSUuXG4gICAgICovXG4gICAgaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuZW5jb2RlRGF0YShuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsZWQgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXG4gICAgICovXG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZURhdGEodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cbiAgICAgKi9cbiAgICBoYXNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3Zpc2l0KHR5cGUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IGFycmF5ID0gc3BsaXRBcnJheSh0eXBlKS5hcnJheTtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhcnJheS5jb3VudCA9PT0gLTEgfHwgYXJyYXkuY291bnQgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7YXJyYXkuY291bnR9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLl92aXNpdChhcnJheS5wcmVmaXgsIHYsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZHMucmVkdWNlKChhY2N1bSwgeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHRoaXMuX3Zpc2l0KHR5cGUsIHZhbHVlW25hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbCAlJWNhbGJhY2slJSBmb3IgZWFjaCB2YWx1ZSBpbiAlJXZhbHVlJSUsIHBhc3NpbmcgdGhlIHR5cGUgYW5kXG4gICAgICogIGNvbXBvbmVudCB3aXRoaW4gJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciByZXBsYWNpbmcgYWRkcmVzc2VzIG9yIG90aGVyIHRyYW5zZm9ybWF0aW9uIHRoYXRcbiAgICAgKiAgbWF5IGJlIGRlc2lyZWQgb24gZWFjaCBjb21wb25lbnQsIGJhc2VkIG9uIGl0cyB0eXBlLlxuICAgICAqL1xuICAgIHZpc2l0KHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXQodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWREYXRhRW5jb2Rlcih0eXBlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHByaW1hcnkgdHlwZSBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcykge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5wcmltYXJ5VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaGVkIHN0cnVjdCBmb3IgJSV2YWx1ZSUlIHVzaW5nICUldHlwZXMlJSBhbmQgJSVuYW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hTdHJ1Y3QobmFtZSwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBkb21haW4gaGFzaCBmb3IgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaERvbWFpbihkb21haW4pIHtcbiAgICAgICAgY29uc3QgZG9tYWluRmllbGRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5bbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV07XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlLCBgaW52YWxpZCB0eXBlZC1kYXRhIGRvbWFpbiBrZXk6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJkb21haW5cIiwgZG9tYWluKTtcbiAgICAgICAgICAgIGRvbWFpbkZpZWxkcy5wdXNoKHsgbmFtZSwgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBkb21haW5GaWVsZHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihhLm5hbWUpIC0gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0KFwiRUlQNzEyRG9tYWluXCIsIHsgRUlQNzEyRG9tYWluOiBkb21haW5GaWVsZHMgfSwgZG9tYWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgXCIweDE5MDFcIixcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoKHZhbHVlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaCBvZiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KFR5cGVkRGF0YUVuY29kZXIuZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2VzIGFsbCBhZGRyZXNzIHR5cGVzIHdpdGggRU5TIG5hbWVzIHdpdGggdGhlaXIgbG9va2VkIHVwIGFkZHJlc3NcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0byB0aGUgdmFsdWUgZnJvbSByZXNvbHZpbmcgYWxsIGFkZHJlc3NlcyBpbiAlJXZhbHVlJSUgZm9yXG4gICAgICogJSV0eXBlcyUlIGFuZCB0aGUgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xuICAgICAgICAvLyBNYWtlIGEgY29weSB0byBpc29sYXRlIGl0IGZyb20gdGhlIG9iamVjdCBwYXNzZWQgaW5cbiAgICAgICAgZG9tYWluID0gT2JqZWN0LmFzc2lnbih7fSwgZG9tYWluKTtcbiAgICAgICAgLy8gQWxsb3cgcGFzc2luZyBudWxsIHRvIGlnbm9yZSB2YWx1ZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgdXAgYWxsIEVOUyBuYW1lc1xuICAgICAgICBjb25zdCBlbnNDYWNoZSA9IHt9O1xuICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIGxvb2sgdXAgdGhlIGRvbWFpbidzIHZlcmlmeWluZ0NvbnRyYWN0P1xuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICFpc0hleFN0cmluZyhkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsIDIwKSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSA9IFwiMHhcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBlbmNvZGVyIHRvIHZpc2l0IGFsbCB0aGUgYmFzZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIC8vIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBhZGRyZXNzZXNcbiAgICAgICAgZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgIWlzSGV4U3RyaW5nKHZhbHVlLCAyMCkpIHtcbiAgICAgICAgICAgICAgICBlbnNDYWNoZVt2YWx1ZV0gPSBcIjB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBMb29rdXAgZWFjaCBuYW1lXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBlbnNDYWNoZSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbbmFtZV0gPSBhd2FpdCByZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBkb21haW4gdmVyaWZ5aW5nQ29udHJhY3QgaWYgbmVlZGVkXG4gICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSkge1xuICAgICAgICAgICAgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ID0gZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIGFsbCBFTlMgbmFtZXMgd2l0aCB0aGVpciBhZGRyZXNzXG4gICAgICAgIHZhbHVlID0gZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgZW5zQ2FjaGVbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuc0NhY2hlW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGRvbWFpbiwgdmFsdWUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIEpTT04tZW5jb2RlZCBwYXlsb2FkIGV4cGVjdGVkIGJ5IG5vZGVzIHdoaWNoIGltcGxlbWVudFxuICAgICAqICB0aGUgSlNPTi1SUEMgW1tsaW5rLWVpcC03MTJdXSBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljIGdldFBheWxvYWQoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRvbWFpbiBmaWVsZHNcbiAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIERlcml2ZSB0aGUgRUlQNzEyRG9tYWluIFN0cnVjdCByZWZlcmVuY2UgdHlwZVxuICAgICAgICBjb25zdCBkb21haW5WYWx1ZXMgPSB7fTtcbiAgICAgICAgY29uc3QgZG9tYWluVHlwZXMgPSBbXTtcbiAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvbWFpbltuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluVmFsdWVzW25hbWVdID0gZG9tYWluQ2hlY2tzW25hbWVdKHZhbHVlKTtcbiAgICAgICAgICAgIGRvbWFpblR5cGVzLnB1c2goeyBuYW1lLCB0eXBlOiBkb21haW5GaWVsZFR5cGVzW25hbWVdIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIC8vIEdldCB0aGUgbm9ybWFsaXplZCB0eXBlc1xuICAgICAgICB0eXBlcyA9IGVuY29kZXIudHlwZXM7XG4gICAgICAgIGNvbnN0IHR5cGVzV2l0aERvbWFpbiA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGVzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9PSBudWxsLCBcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIiwgXCJ0eXBlcy5FSVA3MTJEb21haW5cIiwgdHlwZXMpO1xuICAgICAgICB0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID0gZG9tYWluVHlwZXM7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZXMgYW5kIHR5cGVzXG4gICAgICAgIGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiB0eXBlc1dpdGhEb21haW4sXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblZhbHVlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBlbmNvZGVyLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCopLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoZ2V0Qnl0ZXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCBvciBpbnRcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogIENvbXB1dGUgdGhlIGFkZHJlc3MgdXNlZCB0byBzaWduIHRoZSB0eXBlZCBkYXRhIGZvciB0aGUgJSVzaWduYXR1cmUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKFR5cGVkRGF0YUVuY29kZXIuaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSksIHNpZ25hdHVyZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC1kYXRhLmpzLm1hcCIsIi8qKlxuICogIEEgZnJhZ21lbnQgaXMgYSBzaW5nbGUgaXRlbSBmcm9tIGFuIEFCSSwgd2hpY2ggbWF5IHJlcHJlc2VudCBhbnkgb2Y6XG4gKlxuICogIC0gW0Z1bmN0aW9uc10oRnVuY3Rpb25GcmFnbWVudClcbiAqICAtIFtFdmVudHNdKEV2ZW50RnJhZ21lbnQpXG4gKiAgLSBbQ29uc3RydWN0b3JzXShDb25zdHJ1Y3RvckZyYWdtZW50KVxuICogIC0gQ3VzdG9tIFtFcnJvcnNdKEVycm9yRnJhZ21lbnQpXG4gKiAgLSBbRmFsbGJhY2sgb3IgUmVjZWl2ZV0oRmFsbGJhY2tGcmFnbWVudCkgZnVuY3Rpb25zXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpGcmFnbWVudHMgIFthYm91dC1mcmFnbWVudHNdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBhc3NlcnQsIGFzc2VydFByaXZhdGUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG47XG4vLyBbIFwiYVwiLCBcImJcIiBdID0+IHsgXCJhXCI6IDEsIFwiYlwiOiAxIH1cbmZ1bmN0aW9uIHNldGlmeShpdGVtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICBpdGVtcy5mb3JFYWNoKChrKSA9PiByZXN1bHQuYWRkKGspKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xufVxuY29uc3QgX2t3VmlzaWJEZXBsb3kgPSBcImV4dGVybmFsIHB1YmxpYyBwYXlhYmxlIG92ZXJyaWRlXCI7XG5jb25zdCBLd1Zpc2liRGVwbG95ID0gc2V0aWZ5KF9rd1Zpc2liRGVwbG95LnNwbGl0KFwiIFwiKSk7XG4vLyBWaXNpYmlsaXR5IEtleXdvcmRzXG5jb25zdCBfa3dWaXNpYiA9IFwiY29uc3RhbnQgZXh0ZXJuYWwgaW50ZXJuYWwgcGF5YWJsZSBwcml2YXRlIHB1YmxpYyBwdXJlIHZpZXcgb3ZlcnJpZGVcIjtcbmNvbnN0IEt3VmlzaWIgPSBzZXRpZnkoX2t3VmlzaWIuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd1R5cGVzID0gXCJjb25zdHJ1Y3RvciBlcnJvciBldmVudCBmYWxsYmFjayBmdW5jdGlvbiByZWNlaXZlIHN0cnVjdFwiO1xuY29uc3QgS3dUeXBlcyA9IHNldGlmeShfa3dUeXBlcy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3TW9kaWZpZXJzID0gXCJjYWxsZGF0YSBtZW1vcnkgc3RvcmFnZSBwYXlhYmxlIGluZGV4ZWRcIjtcbmNvbnN0IEt3TW9kaWZpZXJzID0gc2V0aWZ5KF9rd01vZGlmaWVycy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3T3RoZXIgPSBcInR1cGxlIHJldHVybnNcIjtcbi8vIEFsbCBLZXl3b3Jkc1xuY29uc3QgX2tleXdvcmRzID0gW19rd1R5cGVzLCBfa3dNb2RpZmllcnMsIF9rd090aGVyLCBfa3dWaXNpYl0uam9pbihcIiBcIik7XG5jb25zdCBLZXl3b3JkcyA9IHNldGlmeShfa2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcbi8vIFNpbmdsZSBjaGFyYWN0ZXIgdG9rZW5zXG5jb25zdCBTaW1wbGVUb2tlbnMgPSB7XG4gICAgXCIoXCI6IFwiT1BFTl9QQVJFTlwiLCBcIilcIjogXCJDTE9TRV9QQVJFTlwiLFxuICAgIFwiW1wiOiBcIk9QRU5fQlJBQ0tFVFwiLCBcIl1cIjogXCJDTE9TRV9CUkFDS0VUXCIsXG4gICAgXCIsXCI6IFwiQ09NTUFcIiwgXCJAXCI6IFwiQVRcIlxufTtcbi8vIFBhcnNlciByZWdleGVzIHRvIGNvbnN1bWUgdGhlIG5leHQgdG9rZW5cbmNvbnN0IHJlZ2V4V2hpdGVzcGFjZVByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKilcIik7XG5jb25zdCByZWdleE51bWJlclByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFswLTldKylcIik7XG5jb25zdCByZWdleElkUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oW2EtekEtWiRfXVthLXpBLVowLTkkX10qKVwiKTtcbi8vIFBhcnNlciByZWdleHMgdG8gY2hlY2sgdmFsaWRpdHlcbmNvbnN0IHJlZ2V4SWQgPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopJFwiKTtcbmNvbnN0IHJlZ2V4VHlwZSA9IG5ldyBSZWdFeHAoXCJeKGFkZHJlc3N8Ym9vbHxieXRlcyhbMC05XSopfHN0cmluZ3x1P2ludChbMC05XSopKSRcIik7XG5jbGFzcyBUb2tlblN0cmluZyB7XG4gICAgI29mZnNldDtcbiAgICAjdG9rZW5zO1xuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdG9rZW5zLmxlbmd0aCAtIHRoaXMuI29mZnNldDsgfVxuICAgIGNvbnN0cnVjdG9yKHRva2Vucykge1xuICAgICAgICB0aGlzLiNvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLiN0b2tlbnMgPSB0b2tlbnMuc2xpY2UoKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7IHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zKTsgfVxuICAgIHJlc2V0KCkgeyB0aGlzLiNvZmZzZXQgPSAwOyB9XG4gICAgI3N1YlRva2VuU3RyaW5nKGZyb20gPSAwLCB0byA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0aGlzLiN0b2tlbnMuc2xpY2UoZnJvbSwgdG8pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdCwge1xuICAgICAgICAgICAgICAgIG1hdGNoOiAodC5tYXRjaCAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtCYWNrOiAodC5saW5rQmFjayAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtOZXh0OiAodC5saW5rTmV4dCAtIGZyb20pLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuLCBpZiBpdCBpcyBhIGtleXdvcmQgaW4gYWxsb3dlZDsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3BLZXl3b3JkKGFsbG93ZWQpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJLRVlXT1JEXCIgfHwgIWFsbG93ZWQuaGFzKHRvcC50ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBrZXl3b3JkICR7dG9wLnRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wKCkudGV4dDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcFR5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX07IGdvdCAke3RvcC50eXBlfSAke0pTT04uc3RyaW5naWZ5KHRvcC50ZXh0KX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIGEgXCIoXCIgVE9LRU5TIFwiKVwiXG4gICAgcG9wUGFyZW4oKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgdG9wLm1hdGNoICsgMSk7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIGl0ZW1zIHdpdGhpbiBcIihcIiBJVEVNMSBcIixcIiBJVEVNMiBcIixcIiAuLi4gXCIpXCJcbiAgICBwb3BQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLiNvZmZzZXQgPCB0b3AubWF0Y2ggLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5wZWVrKCkubGlua05leHQ7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCBsaW5rKSk7XG4gICAgICAgICAgICB0aGlzLiNvZmZzZXQgPSBsaW5rO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHRvcCBUb2tlbiwgdGhyb3dpbmcgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgPj0gdGhpcy4jdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0LW9mLWJvdW5kc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jdG9rZW5zW3RoaXMuI29mZnNldF07XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdmFsdWUsIGlmIGl0IGlzIGEga2V5d29yZCBpbiBgYWxsb3dlZGBcbiAgICBwZWVrS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xuICAgICAgICByZXR1cm4gKHRvcCAhPSBudWxsICYmIGFsbG93ZWQuaGFzKHRvcCkpID8gdG9wIDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgXG4gICAgcGVla1R5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICByZXR1cm4gKHRvcC50eXBlID09PSB0eXBlKSA/IHRvcC50ZXh0IDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB0b2tlbjsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3AoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGVlaygpO1xuICAgICAgICB0aGlzLiNvZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4jb2Zmc2V0OyBpIDwgdGhpcy4jdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuI3Rva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKGAke3Rva2VuLnR5cGV9OiR7dG9rZW4udGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYDxUb2tlblN0cmluZyAke3Rva2Vucy5qb2luKFwiIFwiKX0+YDtcbiAgICB9XG59XG5mdW5jdGlvbiBsZXgodGV4dCkge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGNvbnN0IHRocm93RXJyb3IgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zdCB0b2tlbiA9IChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkgPyBKU09OLnN0cmluZ2lmeSh0ZXh0W29mZnNldF0pIDogXCIkRU9JXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0b2tlbiAke3Rva2VufSBhdCAke29mZnNldH06ICR7bWVzc2FnZX1gKTtcbiAgICB9O1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIGxldCBjb21tYXMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIGFueSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgbGV0IGN1ciA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIGxldCBtYXRjaCA9IGN1ci5tYXRjaChyZWdleFdoaXRlc3BhY2VQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgICAgICBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0geyBkZXB0aDogYnJhY2tldHMubGVuZ3RoLCBsaW5rQmFjazogLTEsIGxpbmtOZXh0OiAtMSwgbWF0Y2g6IC0xLCB0eXBlOiBcIlwiLCB0ZXh0OiBcIlwiLCBvZmZzZXQsIHZhbHVlOiAtMSB9O1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGxldCB0eXBlID0gKFNpbXBsZVRva2Vuc1tjdXJbMF1dIHx8IFwiXCIpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gY3VyWzBdO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiQ0xPU0VfUEFSRU5cIikge1xuICAgICAgICAgICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcIm5vIG1hdGNoaW5nIG9wZW4gYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2ggPSBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLm1hdGNoXSkubWF0Y2ggPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB0b2tlbi5kZXB0aC0tO1xuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDT01NQVwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPUEVOX0JSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIkJSQUNLRVRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ0xPU0VfQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBDTE9TRV9CUkFDS0VUXG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwiTlVNQkVSXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdmFsdWUgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS52YWx1ZSA9IGdldE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJCUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBvcGVuaW5nIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS50ZXh0ICs9IHN1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4SWRQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChLZXl3b3Jkcy5oYXModG9rZW4udGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJLRVlXT1JEXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udGV4dC5tYXRjaChyZWdleFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiVFlQRVwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiSURcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4TnVtYmVyUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJOVU1CRVJcIjtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0b2tlbiAke0pTT04uc3RyaW5naWZ5KGN1clswXSl9IGF0IHBvc2l0aW9uICR7b2Zmc2V0fWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRva2Vucy5tYXAoKHQpID0+IE9iamVjdC5mcmVlemUodCkpKTtcbn1cbi8vIENoZWNrIG9ubHkgb25lIG9mIGBhbGxvd2VkYCBpcyBpbiBgc2V0YFxuZnVuY3Rpb24gYWxsb3dTaW5nbGUoc2V0LCBhbGxvd2VkKSB7XG4gICAgbGV0IGluY2x1ZGVkID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dlZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKHNldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgaW5jbHVkZWQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbmNsdWRlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uZmxpY3RpbmcgdHlwZXM6ICR7aW5jbHVkZWQuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbn1cbi8vIEZ1bmN0aW9ucyB0byBwcm9jZXNzIGEgU29saWRpdHkgU2lnbmF0dXJlIFRva2VuU3RyaW5nIGZyb20gbGVmdC10by1yaWdodCBmb3IuLi5cbi8vIC4uLnRoZSBuYW1lIHdpdGggYW4gb3B0aW9uYWwgdHlwZSwgcmV0dXJuaW5nIHRoZSBuYW1lXG5mdW5jdGlvbiBjb25zdW1lTmFtZSh0eXBlLCB0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLnBlZWtLZXl3b3JkKEt3VHlwZXMpKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgaWYgKGtleXdvcmQgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfSwgZ290ICR7a2V5d29yZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zLnBvcFR5cGUoXCJJRFwiKTtcbn1cbi8vIC4uLmFsbCBrZXl3b3JkcyBtYXRjaGluZyBhbGxvd2VkLCByZXR1cm5pbmcgdGhlIGtleXdvcmRzXG5mdW5jdGlvbiBjb25zdW1lS2V5d29yZHModG9rZW5zLCBhbGxvd2VkKSB7XG4gICAgY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wZWVrVHlwZShcIktFWVdPUkRcIik7XG4gICAgICAgIGlmIChrZXl3b3JkID09IG51bGwgfHwgKGFsbG93ZWQgJiYgIWFsbG93ZWQuaGFzKGtleXdvcmQpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAoa2V5d29yZHMuaGFzKGtleXdvcmQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBrZXl3b3JkczogJHtKU09OLnN0cmluZ2lmeShrZXl3b3JkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBrZXl3b3Jkcy5hZGQoa2V5d29yZCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGtleXdvcmRzKTtcbn1cbi8vIC4uLmFsbCB2aXNpYmlsaXR5IGtleXdvcmRzLCByZXR1cm5pbmcgdGhlIGNvYWxlc2NlZCBtdXRhYmlsaXR5XG5mdW5jdGlvbiBjb25zdW1lTXV0YWJpbGl0eSh0b2tlbnMpIHtcbiAgICBsZXQgbW9kaWZpZXJzID0gY29uc3VtZUtleXdvcmRzKHRva2VucywgS3dWaXNpYik7XG4gICAgLy8gRGV0ZWN0IGNvbmZsaWN0aW5nIG1vZGlmaWVyc1xuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwiY29uc3RhbnQgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJwdXJlIHZpZXcgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgLy8gUHJvY2VzcyBtdXRhYmlsaXR5IHN0YXRlc1xuICAgIGlmIChtb2RpZmllcnMuaGFzKFwidmlld1wiKSkge1xuICAgICAgICByZXR1cm4gXCJ2aWV3XCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicHVyZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwdXJlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwYXlhYmxlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwibm9ucGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgbGVnYWN5IGBjb25zdGFudGAgbGFzdFxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwiY29uc3RhbnRcIikpIHtcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG59XG4vLyAuLi5hIHBhcmFtZXRlciBsaXN0LCByZXR1cm5pbmcgdGhlIFBhcmFtVHlwZSBsaXN0XG5mdW5jdGlvbiBjb25zdW1lUGFyYW1zKHRva2VucywgYWxsb3dJbmRleGVkKSB7XG4gICAgcmV0dXJuIHRva2Vucy5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQsIGFsbG93SW5kZXhlZCkpO1xufVxuLy8gLi4uYSBnYXMgbGltaXQsIHJldHVybmluZyBhIEJpZ051bWJlciBvciBudWxsIGlmIG5vbmVcbmZ1bmN0aW9uIGNvbnN1bWVHYXModG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIkFUXCIpKSB7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIk5VTUJFUlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh0b2tlbnMucG9wKCkudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBnYXNcIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3VtZUVvaSh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW5zIGF0IG9mZnNldCAke3Rva2Vucy5vZmZzZXR9OiAke3Rva2Vucy50b1N0cmluZygpfWApO1xuICAgIH1cbn1cbmNvbnN0IHJlZ2V4QXJyYXlUeXBlID0gbmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtcbmZ1bmN0aW9uIHZlcmlmeUJhc2ljVHlwZSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4VHlwZSk7XG4gICAgYXNzZXJ0QXJndW1lbnQobWF0Y2gsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDI1NlwiO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJpbnRcIikge1xuICAgICAgICByZXR1cm4gXCJpbnQyNTZcIjtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgIC8vIGJ5dGVzWFhcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgLy8gaW50WFggb3IgdWludFhYXG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8vIE1ha2UgdGhlIEZyYWdtZW50IGNvbnN0cnVjdG9ycyBlZmZlY3RpdmVseSBwcml2YXRlXG5jb25zdCBfZ3VhcmQgPSB7fTtcbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfaW50ZXJuYWxcIik7XG5jb25zdCBQYXJhbVR5cGVJbnRlcm5hbCA9IFwiX1BhcmFtVHlwZUludGVybmFsXCI7XG5jb25zdCBFcnJvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9FcnJvckludGVybmFsXCI7XG5jb25zdCBFdmVudEZyYWdtZW50SW50ZXJuYWwgPSBcIl9FdmVudEludGVybmFsXCI7XG5jb25zdCBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9Db25zdHJ1Y3RvckludGVybmFsXCI7XG5jb25zdCBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgPSBcIl9GYWxsYmFja0ludGVybmFsXCI7XG5jb25zdCBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgPSBcIl9GdW5jdGlvbkludGVybmFsXCI7XG5jb25zdCBTdHJ1Y3RGcmFnbWVudEludGVybmFsID0gXCJfU3RydWN0SW50ZXJuYWxcIjtcbi8qKlxuICogIEVhY2ggaW5wdXQgYW5kIG91dHB1dCBvZiBhIFtbRnJhZ21lbnRdXSBpcyBhbiBBcnJheSBvZiAqKlBhcmFtVHlwZSoqLlxuICovXG5leHBvcnQgY2xhc3MgUGFyYW1UeXBlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvY2FsIG5hbWUgb2YgdGhlIHBhcmFtZXRlciAob3IgYGBcIlwiYGAgaWYgdW5ib3VuZClcbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbHkgcXVhbGlmaWVkIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGUoYWRkcmVzcylcImBgLFxuICAgICAqICBgYFwidWludDI1NlszXVtdXCJgYClcbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmFzZSB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlXCJgYCwgYGBcImFycmF5XCJgYClcbiAgICAgKi9cbiAgICBiYXNlVHlwZTtcbiAgICAvKipcbiAgICAgKiAgVHJ1ZSBpZiB0aGUgcGFyYW1ldGVycyBpcyBpbmRleGVkLlxuICAgICAqXG4gICAgICogIEZvciBub24taW5kZXhhYmxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgaW5kZXhlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXBvbmVudHMgZm9yIHRoZSB0dXBsZS5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLXR1cGxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgY29tcG9uZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFycmF5IGxlbmd0aCwgb3IgYGAtMWBgIGZvciBkeW5hbWljLWxlbmd0aGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgYXJyYXlMZW5ndGg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlIG9mIGVhY2ggY2hpbGQgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhcnJheUNoaWxkcmVuO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIlBhcmFtVHlwZVwiKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBQYXJhbVR5cGVJbnRlcm5hbCB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBPYmplY3QuZnJlZXplKGNvbXBvbmVudHMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCA9PSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcnJheUxlbmd0aCAhPSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSxcbiAgICAgKlxuICAgICAqICBgYHNpZ2hhc2hcIiA9PiBcIih1aW50MjU2LGFkZHJlc3MpXCJgYFxuICAgICAqXG4gICAgICogIGBgXCJtaW5pbWFsXCIgPT4gXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcImBgXG4gICAgICpcbiAgICAgKiAgYGBcImZ1bGxcIiA9PiBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXNzIGJhcikgaW5kZXhlZCBiYXpcImBgXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICgodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSksXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGMpID0+IEpTT04ucGFyc2UoYy5mb3JtYXQoZm9ybWF0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBjb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImZ1bGxcIiAmJiB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBBcnJheSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1thcnJheUNoaWxkcmVuXV1cbiAgICAgKiAgYW5kIFtbYXJyYXlMZW5ndGhdXSBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcImFycmF5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGEgVHVwbGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbY29tcG9uZW50c11dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzVHVwbGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBJbmRleGFibGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbaW5kZXhlZF1dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzSW5kZXhhYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXhlZCAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBjYWxsaW5nICUlcHJvY2VzcyUlXG4gICAgICogIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKi9cbiAgICB3YWxrKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheUxlbmd0aCAhPT0gLTEgJiYgdmFsdWUubGVuZ3RoICE9PSB0aGlzLmFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gKF90aGlzLmFycmF5Q2hpbGRyZW4ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gKF90aGlzLmNvbXBvbmVudHNbaV0ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAjd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2Vzcywgc2V0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhcnJheSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSB0aGlzLmFycmF5Q2hpbGRyZW47XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkVHlwZS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBvYmplY3QgaW50byBhbiBhcnJheVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wb25lbnRzLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIG9iamVjdCB2YWx1ZSB3aXRoIHVubmFtZWQgY29tcG9uZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbS5uYW1lIGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHZhbHVlIGZvciBjb21wb25lbnQgJHtwYXJhbS5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtwYXJhbS5uYW1lXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaW5kZXhdLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQudGhlbikge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyBzZXRWYWx1ZShhd2FpdCByZXN1bHQpOyB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBhc3luY2hyb25vdXNseSBjYWxsaW5nXG4gICAgICogICUlcHJvY2VzcyUlIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgRU5TIG5hbWVzIGJ5IHdhbGtpbmcgYW5kIHJlc29sdmluZyBlYWNoXG4gICAgICogIGBgXCJhZGRyZXNzXCJgYCB0eXBlLlxuICAgICAqL1xuICAgIGFzeW5jIHdhbGtBc3luYyh2YWx1ZSwgcHJvY2Vzcykge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbdmFsdWVdO1xuICAgICAgICB0aGlzLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqUGFyYW1UeXBlKiogZm9yICUlb2JqJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVhbGxvd0luZGV4ZWQlJSB0aGVuIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIGlzIHBlcm1pdHRlZCxcbiAgICAgKiAgb3RoZXJ3aXNlIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqLCBhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgaWYgKFBhcmFtVHlwZS5pc1BhcmFtVHlwZShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tKGxleChvYmopLCBhbGxvd0luZGV4ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBwYXJhbSB0eXBlXCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gXCJcIiwgYmFzZVR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgbGV0IGNvbXBzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1widHVwbGVcIl0pKS5oYXMoXCJ0dXBsZVwiKSB8fCBvYmoucGVla1R5cGUoXCJPUEVOX1BBUkVOXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHVwbGVcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwidHVwbGVcIjtcbiAgICAgICAgICAgICAgICBjb21wcyA9IG9iai5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQpKTtcbiAgICAgICAgICAgICAgICB0eXBlID0gYHR1cGxlKCR7Y29tcHMubWFwKChjKSA9PiBjLmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbFxuICAgICAgICAgICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnBvcFR5cGUoXCJUWVBFXCIpKTtcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgQXJyYXlcbiAgICAgICAgICAgIGxldCBhcnJheUNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJheUxlbmd0aCA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAob2JqLmxlbmd0aCAmJiBvYmoucGVla1R5cGUoXCJCUkFDS0VUXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldCA9IG9iai5wb3AoKTsgLy9hcnJheXNbaV07XG4gICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbiA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBcIlwiLCB0eXBlLCBiYXNlVHlwZSwgbnVsbCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBhcnJheUxlbmd0aCA9IGJyYWNrZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgdHlwZSArPSBicmFja2V0LnRleHQ7XG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgICAgICAgY29tcHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGluZGV4ZWQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qga2V5d29yZHMgPSBjb25zdW1lS2V5d29yZHMob2JqLCBLd01vZGlmaWVycyk7XG4gICAgICAgICAgICBpZiAoa2V5d29yZHMuaGFzKFwiaW5kZXhlZFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gKG9iai5wZWVrVHlwZShcIklEXCIpID8gb2JqLnBvcCgpLnRleHQgOiBcIlwiKTtcbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVmdG92ZXIgdG9rZW5zXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gb2JqLm5hbWU7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFuYW1lIHx8ICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCkpLCBcImludmFsaWQgbmFtZVwiLCBcIm9iai5uYW1lXCIsIG5hbWUpO1xuICAgICAgICBsZXQgaW5kZXhlZCA9IG9iai5pbmRleGVkO1xuICAgICAgICBpZiAoaW5kZXhlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhbGxvd0luZGV4ZWQsIFwicGFyYW1ldGVyIGNhbm5vdCBiZSBpbmRleGVkXCIsIFwib2JqLmluZGV4ZWRcIiwgb2JqLmluZGV4ZWQpO1xuICAgICAgICAgICAgaW5kZXhlZCA9ICEhaW5kZXhlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IG9iai50eXBlO1xuICAgICAgICBsZXQgYXJyYXlNYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhBcnJheVR5cGUpO1xuICAgICAgICBpZiAoYXJyYXlNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSBwYXJzZUludChhcnJheU1hdGNoWzJdIHx8IFwiLTFcIik7XG4gICAgICAgICAgICBjb25zdCBhcnJheUNoaWxkcmVuID0gUGFyYW1UeXBlLmZyb20oe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFycmF5TWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogb2JqLmNvbXBvbmVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwiYXJyYXlcIiwgaW5kZXhlZCwgbnVsbCwgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcInR1cGxlXCIgfHwgdHlwZS5zdGFydHNXaXRoKFwidHVwbGUoXCIgLyogZml4OiApICovKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCIoXCIgLyogZml4OiApICovKSkge1xuICAgICAgICAgICAgY29uc3QgY29tcHMgPSAob2JqLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBvYmouY29tcG9uZW50cy5tYXAoKGMpID0+IFBhcmFtVHlwZS5mcm9tKGMpKSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB0dXBsZSA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwidHVwbGVcIiwgaW5kZXhlZCwgY29tcHMsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHVzZSBsZXhlciB0byB2YWxpZGF0ZSBhbmQgbm9ybWFsaXplIHR5cGVcbiAgICAgICAgICAgIHJldHVybiB0dXBsZTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID0gdmVyaWZ5QmFzaWNUeXBlKG9iai50eXBlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIHR5cGUsIGluZGV4ZWQsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhICoqUGFyYW1UeXBlKiouXG4gICAgICovXG4gICAgc3RhdGljIGlzUGFyYW1UeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBQYXJhbVR5cGVJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnQgZnJvbSBhIHBhcnNlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbnB1dHMgZm9yIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBpbnB1dHM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cykge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRnJhZ21lbnRcIik7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgdHlwZSwgaW5wdXRzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZyYWdtZW50KiogZm9yICUlb2JqJSUsIHdpY2ggY2FuIGJlIGFueSBzdXBwb3J0ZWRcbiAgICAgKiAgQUJJIGZyZ2FtZW50IHR5cGUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIFRyeSBwYXJzaW5nIEpTT04uLi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRnJhZ21lbnQuZnJvbShKU09OLnBhcnNlKG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlLCB1c2UgdGhlIGh1bWFuLXJlYWRhYmxlIGxleGVyXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBIdW1hbi1yZWFkYWJsZSBBQkkgKGFscmVhZHkgbGV4ZWQpXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBlZWtLZXl3b3JkKEt3VHlwZXMpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6IHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjogcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gSlNPTiBBQklcbiAgICAgICAgICAgIHN3aXRjaCAob2JqLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bnN1cHBvcnRlZCB0eXBlOiAke29iai50eXBlfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiRnJhZ21lbnQuZnJvbVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBmcmdhbWVudCBvYmplY3RcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW0NvbnN0cnVjdG9yRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNDb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFcnJvckZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIFtbRXZlbnRGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0V2ZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbRnVuY3Rpb25GcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbU3RydWN0RnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTdHJ1Y3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuIGFic3RyYWN0IGNsYXNzIHRvIHJlcHJlc2VudCBBbiBpbmRpdmlkdWFsIGZyYWdtZW50XG4gKiAgd2hpY2ggaGFzIGEgbmFtZSBmcm9tIGEgcGFyc2UgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgTmFtZWRGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lLm1hdGNoKHJlZ2V4SWQpLCBcImludmFsaWQgaWRlbnRpZmllclwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBqb2luUGFyYW1zKGZvcm1hdCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIFwiKFwiICsgcGFyYW1zLm1hcCgocCkgPT4gcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBcImZ1bGxcIikgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIC8vQ3VzdG9tIEVycm9yLy8uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJlcnJvclwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEVycm9yRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBDdXN0b20gRXJyb3Igc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRXJyb3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImVycm9yXCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkVycm9yRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXJyb3JGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYW4gRXZlbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhpcyBldmVudCBpcyBhbm9ueW1vdXMuXG4gICAgICovXG4gICAgYW5vbnltb3VzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMsIGFub255bW91cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJldmVudFwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFub255bW91cyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBFdmVudCB0b3BpYyBoYXNoLlxuICAgICAqL1xuICAgIGdldCB0b3BpY0hhc2goKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV2ZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJldmVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIgJiYgdGhpcy5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRvcGljIGhhc2ggZm9yIGFuIGV2ZW50IHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFRvcGljSGFzaChuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBwYXJhbXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFdmVudEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBldmVudCBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJldmVudFwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmosIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgYW5vbnltb3VzID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiYW5vbnltb3VzXCJdKSkuaGFzKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHAsIHRydWUpKSA6IFtdLCAhIW9iai5hbm9ueW1vdXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkV2ZW50RnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXZlbnRGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnN0cnVjdG9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhlIGNvbnN0cnVjdG9yIGNhbiByZWNlaXZlIGFuIGVuZG93bWVudC5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcmVjb21tZW5kZWQgZ2FzIGxpbWl0IGZvciBkZXBsb3ltZW50IG9yIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdhcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzLCBwYXlhYmxlLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGF5YWJsZSwgZ2FzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbnN0cnVjdG9yIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBhc3NlcnQoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiwgXCJjYW5ub3QgZm9ybWF0IGEgY29uc3RydWN0b3IgZm9yIHNpZ2hhc2hcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZm9ybWF0KHNpZ2hhc2gpXCIgfSk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwidW5kZWZpbmVkXCIpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICgodGhpcy5nYXMgIT0gbnVsbCkgPyB0aGlzLmdhcyA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbYGNvbnN0cnVjdG9yJHtqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpfWBdO1xuICAgICAgICBpZiAodGhpcy5wYXlhYmxlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcInBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqQ29uc3RydWN0b3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgY29uc3R1Y3RvciBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiY29uc3RydWN0b3JcIl0pKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIEt3VmlzaWJEZXBsb3kpLmhhcyhcInBheWFibGVcIik7XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIGlucHV0cywgcGF5YWJsZSwgZ2FzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgISFvYmoucGF5YWJsZSwgKG9iai5nYXMgIT0gbnVsbCkgPyBvYmouZ2FzIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipDb25zdHJ1Y3RvckZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRmFsbGJhY2tGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGlucHV0cywgcGF5YWJsZSkge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJmYWxsYmFja1wiLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBheWFibGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZmFsbGJhY2sgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoKHRoaXMuaW5wdXRzLmxlbmd0aCA9PT0gMCkgPyBcInJlY2VpdmVcIiA6IFwiZmFsbGJhY2tcIik7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZU11dGFiaWxpdHkgPSAodGhpcy5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcIm5vbnBheWFibGVcIik7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyB0eXBlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3R5cGV9KCkke3RoaXMucGF5YWJsZSA/IFwiIHBheWFibGVcIiA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGYWxsYmFja0ZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChGYWxsYmFja0ZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG9iai50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdG9wSXNWYWxpZCA9IG9iai5wZWVrS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0b3BJc1ZhbGlkLCBcInR5cGUgbXVzdCBiZSBmYWxsYmFjayBvciByZWNlaXZlXCIsIFwib2JqXCIsIGVycm9yT2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucG9wS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICAvLyByZWNlaXZlKClcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJlY2VpdmVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbnB1dHMubGVuZ3RoID09PSAwLCBgcmVjZWl2ZSBjYW5ub3QgaGF2ZSBhcmd1bWVudHNgLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicGF5YWJsZVwiXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmYWxsYmFjaygpIFtwYXlhYmxlXVxuICAgICAgICAgICAgLy8gZmFsbGJhY2soYnl0ZXMpIFtwYXlhYmxlXSByZXR1cm5zIChieXRlcylcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlucHV0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIGlucHV0c1wiLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtdXRhYmlsaXR5ID09PSBcIm5vbnBheWFibGVcIiB8fCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIiwgXCJmYWxsYmFjayBjYW5ub3QgYmUgY29uc3RhbnRzXCIsIFwib2JqLnN0YXRlTXV0YWJpbGl0eVwiLCBtdXRhYmlsaXR5KTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG91dHB1dHMubGVuZ3RoID09PSAxICYmIG91dHB1dHNbMF0udHlwZSA9PT0gXCJieXRlc1wiLCBcImludmFsaWQgZmFsbGJhY2sgb3V0cHV0c1wiLCBcIm9iai5vdXRwdXRzXCIsIG91dHB1dHMubWFwKChpKSA9PiBpLmZvcm1hdChcIm1pbmltYWxcIikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIG11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwicmVjZWl2ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai50eXBlID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IFtQYXJhbVR5cGUuZnJvbShcImJ5dGVzXCIpXTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAob2JqLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgaW5wdXRzLCBwYXlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGRlc2NyaXB0aW9uXCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipGYWxsYmFja0ZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gaXMgY29uc3RhbnQgKGUuZy4gYGBwdXJlYGAgb3IgYGB2aWV3YGAgZnVuY3Rpb25zKS5cbiAgICAgKi9cbiAgICBjb25zdGFudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJldHVybmVkIHR5cGVzIGZvciB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBvdXRwdXRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdGUgbXV0YWJpbGl0eSAoZS5nLiBgYHBheWFibGVgYCwgYGBub25wYXlhYmxlYGAsIGBgdmlld2BgXG4gICAgICogIG9yIGBgcHVyZWBgKVxuICAgICAqL1xuICAgIHN0YXRlTXV0YWJpbGl0eTtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgdG8gc2VuZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZnVuY3Rpb25cIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIG91dHB1dHMgPSBPYmplY3QuZnJlZXplKG91dHB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50ID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XG4gICAgICAgIGNvbnN0IHBheWFibGUgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb25zdGFudCwgZ2FzLCBvdXRwdXRzLCBwYXlhYmxlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRnVuY3Rpb24gc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uc3RhbnQ6IHRoaXMuY29uc3RhbnQsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLm1hcCgobykgPT4gSlNPTi5wYXJzZShvLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zdGF0ZU11dGFiaWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJyZXR1cm5zXCIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLm91dHB1dHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYEAke3RoaXMuZ2FzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2VsZWN0b3IgZm9yIGEgZnVuY3Rpb24gd2l0aCAlJW5hbWUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3IobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCkpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgXCJ2aWV3XCIsIHBhcmFtcywgW10sIG51bGwpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQuc2VsZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRnVuY3Rpb25GcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZnVuY3Rpb24gZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZnVuY3Rpb25cIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgbXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZU11dGFiaWxpdHkgPSBvYmouc3RhdGVNdXRhYmlsaXR5O1xuICAgICAgICAvLyBVc2UgbGVnYWN5IFNvbGlkaXR5IEFCSSBsb2dpYyBpZiBzdGF0ZU11dGFiaWxpdHkgaXMgbWlzc2luZ1xuICAgICAgICBpZiAoc3RhdGVNdXRhYmlsaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLmNvbnN0YW50KSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLnBheWFibGUpID09PSBcImJvb2xlYW5cIiAmJiAhb2JqLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiB2ZXJpZnlTdGF0ZSBmb3Igc3RhdGVNdXRhYmlsaXR5IChlLmcuIHRocm93IGlmXG4gICAgICAgIC8vICAgICAgICBwYXlhYmxlOiBmYWxzZSBidXQgc3RhdGVNdXRhYmlsaXR5IGlzIFwibm9ucGF5YWJsZVwiKVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIG9iai5vdXRwdXRzID8gb2JqLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZ1bmN0aW9uRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRnVuY3Rpb25GcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwic3RydWN0XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogU3RydWN0RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzdHJ1Y3QgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlN0cnVjdEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBzdHJ1Y3QgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwic3RydWN0XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBmaXggdGhpcyByZXR1cm4gdHlwZVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipTdHJ1Y3RGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBTdHJ1Y3RGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudHMuanMubWFwIiwiLyoqXG4gKiAgV2hlbiBzZW5kaW5nIHZhbHVlcyB0byBvciByZWNlaXZpbmcgdmFsdWVzIGZyb20gYSBbW0NvbnRyYWN0XV0sIHRoZVxuICogIGRhdGEgaXMgZ2VuZXJhbGx5IGVuY29kZWQgdXNpbmcgdGhlIFtBQkkgc3RhbmRhcmRdKGxpbmstc29sYy1hYmkpLlxuICpcbiAqICBUaGUgQWJpQ29kZXIgcHJvdmlkZXMgYSB1dGlsaXR5IHRvIGVuY29kZSB2YWx1ZXMgdG8gQUJJIGRhdGEgYW5kXG4gKiAgZGVjb2RlIHZhbHVlcyBmcm9tIEFCSSBkYXRhLlxuICpcbiAqICBNb3N0IG9mIHRoZSB0aW1lLCBkZXZlbG9wZXJzIHNob3VsZCBmYXZvdXIgdGhlIFtbQ29udHJhY3RdXSBjbGFzcyxcbiAqICB3aGljaCBmdXJ0aGVyIGFic3RyYWN0cyBhIGxvdCBvZiB0aGUgZmluZXIgZGV0YWlscyBvZiBBQkkgZGF0YS5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS9hYmkvYWJpLWNvZGVyOkFCSSBFbmNvZGluZ1xuICovXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvRXRoZXJldW0tQ29udHJhY3QtQUJJXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudENvdW50LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUmVhZGVyLCBXcml0ZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IEFkZHJlc3NDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hZGRyZXNzLmpzXCI7XG5pbXBvcnQgeyBBcnJheUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2FycmF5LmpzXCI7XG5pbXBvcnQgeyBCb29sZWFuQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYm9vbGVhbi5qc1wiO1xuaW1wb3J0IHsgQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9ieXRlcy5qc1wiO1xuaW1wb3J0IHsgRml4ZWRCeXRlc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2ZpeGVkLWJ5dGVzLmpzXCI7XG5pbXBvcnQgeyBOdWxsQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVsbC5qc1wiO1xuaW1wb3J0IHsgTnVtYmVyQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVtYmVyLmpzXCI7XG5pbXBvcnQgeyBTdHJpbmdDb2RlciB9IGZyb20gXCIuL2NvZGVycy9zdHJpbmcuanNcIjtcbmltcG9ydCB7IFR1cGxlQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvdHVwbGUuanNcIjtcbmltcG9ydCB7IFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSwgbWFrZUVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjE3L2NvbnRyb2wtc3RydWN0dXJlcy5odG1sXG5jb25zdCBQYW5pY1JlYXNvbnMgPSBuZXcgTWFwKCk7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDAsIFwiR0VORVJJQ19QQU5JQ1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgwMSwgXCJBU1NFUlRfRkFMU0VcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MTEsIFwiT1ZFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MTIsIFwiRElWSURFX0JZX1pFUk9cIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjEsIFwiRU5VTV9SQU5HRV9FUlJPUlwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgyMiwgXCJCQURfU1RPUkFHRV9EQVRBXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDMxLCBcIlNUQUNLX1VOREVSRkxPV1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMiwgXCJBUlJBWV9SQU5HRV9FUlJPUlwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg0MSwgXCJPVVRfT0ZfTUVNT1JZXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDUxLCBcIlVOSU5JVElBTElaRURfRlVOQ1RJT05fQ0FMTFwiKTtcbmNvbnN0IHBhcmFtVHlwZUJ5dGVzID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7XG5jb25zdCBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xubGV0IGRlZmF1bHRDb2RlciA9IG51bGw7XG5sZXQgZGVmYXVsdE1heEluZmxhdGlvbiA9IDEwMjQ7XG5mdW5jdGlvbiBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhLCBhYmlDb2Rlcikge1xuICAgIGxldCBtZXNzYWdlID0gXCJtaXNzaW5nIHJldmVydCBkYXRhXCI7XG4gICAgbGV0IHJlYXNvbiA9IG51bGw7XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IG51bGw7XG4gICAgbGV0IHJldmVydCA9IG51bGw7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiZXhlY3V0aW9uIHJldmVydGVkXCI7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChubyBkYXRhIHByZXNlbnQ7IGxpa2VseSByZXF1aXJlKGZhbHNlKSBvY2N1cnJlZFwiO1xuICAgICAgICAgICAgcmVhc29uID0gXCJyZXF1aXJlKGZhbHNlKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCAlIDMyICE9PSA0KSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBkYXRhIGxlbmd0aClcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDA4YzM3OWEwXCIpIHtcbiAgICAgICAgICAgIC8vIEVycm9yKHN0cmluZylcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gYWJpQ29kZXIuZGVjb2RlKFtcInN0cmluZ1wiXSwgYnl0ZXMuc2xpY2UoNCkpWzBdO1xuICAgICAgICAgICAgICAgIHJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJFcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVhc29uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke0pTT04uc3RyaW5naWZ5KHJlYXNvbil9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcmVhc29uOyBpbnZhbGlkIHN0cmluZyBkYXRhKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpID09PSBcIjB4NGU0ODdiNzFcIikge1xuICAgICAgICAgICAgLy8gUGFuaWModWludDI1NilcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IE51bWJlcihhYmlDb2Rlci5kZWNvZGUoW1widWludDI1NlwiXSwgYnl0ZXMuc2xpY2UoNCkpWzBdKTtcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJQYW5pYyh1aW50MjU2KVwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlBhbmljXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtjb2RlXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhc29uID0gYFBhbmljIGR1ZSB0byAke1BhbmljUmVhc29ucy5nZXQoY29kZSkgfHwgXCJVTktOT1dOXCJ9KCR7Y29kZX0pYDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA6ICR7cmVhc29ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHBhbmljIGNvZGUpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiICh1bmtub3duIGN1c3RvbSBlcnJvcilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgdG86ICh0eC50byA/IGdldEFkZHJlc3ModHgudG8pIDogbnVsbCksXG4gICAgICAgIGRhdGE6ICh0eC5kYXRhIHx8IFwiMHhcIilcbiAgICB9O1xuICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmZyb20gPSBnZXRBZGRyZXNzKHR4LmZyb20pO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZUVycm9yKG1lc3NhZ2UsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICBhY3Rpb24sIGRhdGEsIHJlYXNvbiwgdHJhbnNhY3Rpb24sIGludm9jYXRpb24sIHJldmVydFxuICAgIH0pO1xufVxuLyoqXG4gKiAgVGhlICoqQWJpQ29kZXIqKiBpcyBhIGxvdy1sZXZlbCBjbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jb2RpbmcgSmF2YVNjcmlwdFxuICogIHZhbHVlcyBpbnRvIGJpbmFyeSBkYXRhIGFuZCBkZWNvZGluZyBiaW5hcnkgZGF0YSBpbnRvIEphdmFTY3JpcHQgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgQWJpQ29kZXIge1xuICAgICNnZXRDb2RlcihwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0uaXNBcnJheSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29kZXIodGhpcy4jZ2V0Q29kZXIocGFyYW0uYXJyYXlDaGlsZHJlbiksIHBhcmFtLmFycmF5TGVuZ3RoLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0uaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlQ29kZXIocGFyYW0uY29tcG9uZW50cy5tYXAoKGMpID0+IHRoaXMuI2dldENvZGVyKGMpKSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwYXJhbS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3NDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZXNDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE51bGxDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1P2ludFswLTldKlxuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIFwiICsgbWF0Y2hbMV0gKyBcIiBiaXQgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb2RlcihzaXplIC8gOCwgKG1hdGNoWzFdID09PSBcImludFwiKSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnl0ZXNbMC05XStcbiAgICAgICAgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZUJ5dGVzKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAzMiwgXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRml4ZWRCeXRlc0NvZGVyKHNpemUsIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgcGFyYW0udHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGRlZmF1bHQgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gJSV0eXBlcyUlLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBhIGBgdWludGBgIGlzIGJ5IGRlZmF1bHQgYGAwYGAgYW5kIGBgYm9vbGBgXG4gICAgICogIGlzIGJ5IGRlZmF1bHQgYGBmYWxzZWBgLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRWYWx1ZSh0eXBlcykge1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZSB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gQUJJIGRhdGEuXG4gICAgICpcbiAgICAgKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICAgICAqL1xuICAgIGVuY29kZSh0eXBlcywgdmFsdWVzKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50Q291bnQodmFsdWVzLmxlbmd0aCwgdHlwZXMubGVuZ3RoLCBcInR5cGVzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2hcIik7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSAobmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIikpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgICAgIGNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlcyk7XG4gICAgICAgIHJldHVybiB3cml0ZXIuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZSB0aGUgQUJJICUlZGF0YSUlIGFzIHRoZSAlJXR5cGVzJSUgaW50byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAgSWYgJSVsb29zZSUlIGRlY29kaW5nIGlzIGVuYWJsZWQsIHRoZW4gc3RyaWN0IHBhZGRpbmcgaXNcbiAgICAgKiAgbm90IGVuZm9yY2VkLiBTb21lIG9sZGVyIHZlcnNpb25zIG9mIFNvbGlkaXR5IGluY29ycmVjdGx5XG4gICAgICogIHBhZGRlZCBldmVudCBkYXRhIGVtaXR0ZWQgZnJvbSBgYGV4dGVybmFsYGAgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIGRlY29kZSh0eXBlcywgZGF0YSwgbG9vc2UpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVjb2RlKG5ldyBSZWFkZXIoZGF0YSwgbG9vc2UsIGRlZmF1bHRNYXhJbmZsYXRpb24pKTtcbiAgICB9XG4gICAgc3RhdGljIF9zZXREZWZhdWx0TWF4SW5mbGF0aW9uKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcImludmFsaWQgZGVmYXVsdE1heEluZmxhdGlvbiBmYWN0b3JcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIGRlZmF1bHRNYXhJbmZsYXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHNoYXJlZCBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBkZWZhdWx0IFtbQWJpQ29kZXJdXS5cbiAgICAgKlxuICAgICAqICBPbiB0aGUgZmlyc3QgY2FsbCwgdGhlIGluc3RhbmNlIGlzIGNyZWF0ZWQgaW50ZXJuYWxseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVmYXVsdEFiaUNvZGVyKCkge1xuICAgICAgICBpZiAoZGVmYXVsdENvZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRDb2RlciA9IG5ldyBBYmlDb2RlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Q29kZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFuIGV0aGVycy1jb21wYXRpYmxlIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXV0gRXJyb3IgZm9yIHRoZSBnaXZlblxuICAgICAqICByZXN1bHQgJSVkYXRhJSUgZm9yIHRoZSBbW0NhbGxFeGNlcHRpb25BY3Rpb25dXSAlJWFjdGlvbiUlIGFnYWluc3RcbiAgICAgKiAgdGhlIFRyYW5zYWN0aW9uICUldHglJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaS1jb2Rlci5qcy5tYXAiLCIvKipcbiAqICBUaGUgSW50ZXJmYWNlIGNsYXNzIGlzIGEgbG93LWxldmVsIGNsYXNzIHRoYXQgYWNjZXB0cyBhblxuICogIEFCSSBhbmQgcHJvdmlkZXMgYWxsIHRoZSBuZWNlc3NhcnkgZnVuY3Rpb25hbGl0eSB0byBlbmNvZGVcbiAqICBhbmQgZGVjb2RlIHBhcmFtYXRlcnMgdG8gYW5kIHJlc3VsdHMgZnJvbSBtZXRob2RzLCBldmVudHNcbiAqICBhbmQgZXJyb3JzLlxuICpcbiAqICBJdCBhbHNvIHByb3ZpZGVzIHNldmVyYWwgY29udmVuaWVuY2UgbWV0aG9kcyB0byBhdXRvbWF0aWNhbGx5XG4gKiAgc2VhcmNoIGFuZCBmaW5kIG1hdGNoaW5nIHRyYW5zYWN0aW9ucyBhbmQgZXZlbnRzIHRvIHBhcnNlIHRoZW0uXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpOkludGVyZmFjZXMgIFtpbnRlcmZhY2VzXVxuICovXG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFTbGljZSwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5LCB6ZXJvUGFkQnl0ZXMsIHplcm9QYWRWYWx1ZSwgaXNIZXhTdHJpbmcsIGRlZmluZVByb3BlcnRpZXMsIGFzc2VydEFyZ3VtZW50LCB0b0JlSGV4LCBhc3NlcnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFiaUNvZGVyIH0gZnJvbSBcIi4vYWJpLWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBjaGVja1Jlc3VsdEVycm9ycywgUmVzdWx0IH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBDb25zdHJ1Y3RvckZyYWdtZW50LCBFcnJvckZyYWdtZW50LCBFdmVudEZyYWdtZW50LCBGcmFnbWVudCwgRnVuY3Rpb25GcmFnbWVudCwgUGFyYW1UeXBlIH0gZnJvbSBcIi4vZnJhZ21lbnRzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuL3R5cGVkLmpzXCI7XG5leHBvcnQgeyBjaGVja1Jlc3VsdEVycm9ycywgUmVzdWx0IH07XG4vKipcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZUxvZ11dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYSBMb2cgdG8gaXRzIGV2ZW50XG4gKiAgZm9yIHBhcnNpbmcsIGEgKipMb2dEZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgY2xhc3MgTG9nRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQgZm9yIHRoZSBgYHRvcGljMGBgLlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXZlbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRXZlbnQgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvcGljIGhhc2ggZm9yIHRoZSBFdmVudC5cbiAgICAgKi9cbiAgICB0b3BpYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgRXZlbnQgd2l0aCBgYGVtaXRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgdG9waWMsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBzaWduYXR1cmUsIHRvcGljLCBhcmdzXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlVHJhbnNhY3Rpb25dXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoXG4gKiAgYSB0cmFuc2FjdGlvbiBkYXRhIHRvIGl0cyBmdW5jdGlvbiBmb3IgcGFyc2luZyxcbiAqICBhICoqVHJhbnNhY3Rpb25EZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBGdW5jdGlvbiBzaWduYXR1cmUgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdmFsdWVgYCAoaW4gd2VpKSBmcm9tIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIGFyZ3MsIHNpZ25hdHVyZSwgc2VsZWN0b3IsIHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlRXJyb3JdXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIGFuXG4gKiAgZXJyb3IgZm9yIGEgY2FsbCByZXN1bHQgZm9yIHBhcnNpbmcsIGFuICoqRXJyb3JEZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JEZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEVycm9yLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBFcnJvciB3aXRoIGBgcmV2ZXJ0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRXJyb3Igc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbGVjdG9yIGZvciB0aGUgRXJyb3IuXG4gICAgICovXG4gICAgc2VsZWN0b3I7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCBzZWxlY3RvciwgYXJncykge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIGFyZ3MsIHNpZ25hdHVyZSwgc2VsZWN0b3JcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gKipJbmRleGVkKiogaXMgdXNlZCBhcyBhIHZhbHVlIHdoZW4gYSB2YWx1ZSB0aGF0IGRvZXMgbm90XG4gKiAgZml0IHdpdGhpbiBhIHRvcGljIChpLmUuIG5vdCBhIGZpeGVkLWxlbmd0aCwgMzItYnl0ZSB0eXBlKS4gSXRcbiAqICBpcyB0aGUgYGBrZWNjYWsyNTZgYCBvZiB0aGUgdmFsdWUsIGFuZCB1c2VkIGZvciB0eXBlcyBzdWNoIGFzXG4gKiAgYXJyYXlzLCB0dXBsZXMsIGJ5dGVzIGFuZCBzdHJpbmdzLlxuICovXG5leHBvcnQgY2xhc3MgSW5kZXhlZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSBsb2dnZWQuXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX2lzSW5kZXhlZDtcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJXZhbHVlJSUgaXMgYW4gKipJbmRleGVkKiouXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgZm9yIHByb3BlcnR5IGFjY2Vzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNJbmRleGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbmRleGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGhhc2gpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGhhc2gsIF9pc0luZGV4ZWQ6IHRydWUgfSk7XG4gICAgfVxufVxuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xMy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbD9oaWdobGlnaHQ9cGFuaWMjcGFuaWMtdmlhLWFzc2VydC1hbmQtZXJyb3ItdmlhLXJlcXVpcmVcbmNvbnN0IFBhbmljUmVhc29ucyA9IHtcbiAgICBcIjBcIjogXCJnZW5lcmljIHBhbmljXCIsXG4gICAgXCIxXCI6IFwiYXNzZXJ0KGZhbHNlKVwiLFxuICAgIFwiMTdcIjogXCJhcml0aG1ldGljIG92ZXJmbG93XCIsXG4gICAgXCIxOFwiOiBcImRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXCIsXG4gICAgXCIzM1wiOiBcImVudW0gb3ZlcmZsb3dcIixcbiAgICBcIjM0XCI6IFwiaW52YWxpZCBlbmNvZGVkIHN0b3JhZ2UgYnl0ZSBhcnJheSBhY2Nlc3NlZFwiLFxuICAgIFwiNDlcIjogXCJvdXQtb2YtYm91bmRzIGFycmF5IGFjY2VzczsgcG9wcGluZyBvbiBhbiBlbXB0eSBhcnJheVwiLFxuICAgIFwiNTBcIjogXCJvdXQtb2YtYm91bmRzIGFjY2VzcyBvZiBhbiBhcnJheSBvciBieXRlc05cIixcbiAgICBcIjY1XCI6IFwib3V0IG9mIG1lbW9yeVwiLFxuICAgIFwiODFcIjogXCJ1bmluaXRpYWxpemVkIGZ1bmN0aW9uXCIsXG59O1xuY29uc3QgQnVpbHRpbkVycm9ycyA9IHtcbiAgICBcIjB4MDhjMzc5YTBcIjoge1xuICAgICAgICBzaWduYXR1cmU6IFwiRXJyb3Ioc3RyaW5nKVwiLFxuICAgICAgICBuYW1lOiBcIkVycm9yXCIsXG4gICAgICAgIGlucHV0czogW1wic3RyaW5nXCJdLFxuICAgICAgICByZWFzb246IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYHJldmVydGVkIHdpdGggcmVhc29uIHN0cmluZyAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UpfWA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiMHg0ZTQ4N2I3MVwiOiB7XG4gICAgICAgIHNpZ25hdHVyZTogXCJQYW5pYyh1aW50MjU2KVwiLFxuICAgICAgICBuYW1lOiBcIlBhbmljXCIsXG4gICAgICAgIGlucHV0czogW1widWludDI1NlwiXSxcbiAgICAgICAgcmVhc29uOiAoY29kZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwidW5rbm93biBwYW5pYyBjb2RlXCI7XG4gICAgICAgICAgICBpZiAoY29kZSA+PSAwICYmIGNvZGUgPD0gMHhmZiAmJiBQYW5pY1JlYXNvbnNbY29kZS50b1N0cmluZygpXSkge1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGByZXZlcnRlZCB3aXRoIHBhbmljIGNvZGUgMHgke2NvZGUudG9TdHJpbmcoMTYpfSAoJHtyZWFzb259KWA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiAgQW4gSW50ZXJmYWNlIGFic3RyYWN0cyBtYW55IG9mIHRoZSBsb3ctbGV2ZWwgZGV0YWlscyBmb3JcbiAqICBlbmNvZGluZyBhbmQgZGVjb2RpbmcgdGhlIGRhdGEgb24gdGhlIGJsb2NrY2hhaW4uXG4gKlxuICogIEFuIEFCSSBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZW5jb2RlIGRhdGEgdG8gc2VuZCB0b1xuICogIGEgQ29udHJhY3QsIGhvdyB0byBkZWNvZGUgdGhlIHJlc3VsdHMgYW5kIGV2ZW50cyBhbmQgaG93IHRvXG4gKiAgaW50ZXJwcmV0IHJldmVydCBlcnJvcnMuXG4gKlxuICogIFRoZSBBQkkgY2FuIGJlIHNwZWNpZmllZCBieSBbYW55IHN1cHBvcnRlZCBmb3JtYXRdKEludGVyZmFjZUFiaSkuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIENvbnRyYWN0IEFCSSBtZW1iZXJzIChpLmUuIG1ldGhvZHMsIGV2ZW50cywgZXJyb3JzLCBldGMpLlxuICAgICAqL1xuICAgIGZyYWdtZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGRlcGxveTtcbiAgICAvKipcbiAgICAgKiAgVGhlIEZhbGxiYWNrIG1ldGhvZCwgaWYgYW55LlxuICAgICAqL1xuICAgIGZhbGxiYWNrO1xuICAgIC8qKlxuICAgICAqICBJZiByZWNlaXZpbmcgZXRoZXIgaXMgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHJlY2VpdmU7XG4gICAgI2Vycm9ycztcbiAgICAjZXZlbnRzO1xuICAgICNmdW5jdGlvbnM7XG4gICAgLy8gICAgI3N0cnVjdHM6IE1hcDxzdHJpbmcsIFN0cnVjdEZyYWdtZW50PjtcbiAgICAjYWJpQ29kZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBJbnRlcmZhY2UgZm9yIHRoZSAlJWZyYWdtZW50cyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICBsZXQgYWJpID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50cykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFiaSA9IEpTT04ucGFyc2UoZnJhZ21lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFiaSA9IGZyYWdtZW50cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmdW5jdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2Vycm9ycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyAgICAgICAgdGhpcy4jc3RydWN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZnJhZ3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhIG9mIGFiaSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcmFncy5wdXNoKEZyYWdtZW50LmZyb20oYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtXYXJuaW5nXSBJbnZhbGlkIEZyYWdtZW50ICR7SlNPTi5zdHJpbmdpZnkoYSl9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnRzOiBPYmplY3QuZnJlZXplKGZyYWdzKVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY2VpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jYWJpQ29kZXIgPSB0aGlzLmdldEFiaUNvZGVyKCk7XG4gICAgICAgIC8vIEFkZCBhbGwgZnJhZ21lbnRzIGJ5IHRoZWlyIHNpZ25hdHVyZVxuICAgICAgICB0aGlzLmZyYWdtZW50cy5mb3JFYWNoKChmcmFnbWVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBidWNrZXQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGZyYWdtZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwbG95KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImR1cGxpY2F0ZSBkZWZpbml0aW9uIC0gY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBkZXBsb3k6IGZyYWdtZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFmYWxsYmFjayB8fCBmcmFnbWVudC5wYXlhYmxlICE9PSBmYWxsYmFjay5wYXlhYmxlLCBcImNvbmZsaWN0aW5nIGZhbGxiYWNrIGZyYWdtZW50c1wiLCBgZnJhZ21lbnRzWyR7aW5kZXh9XWAsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlID0gZmFsbGJhY2sucGF5YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwib3V0cHV0XCIsICg8RnVuY3Rpb25GcmFnbWVudD5mcmFnbWVudCkub3V0cHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Z1bmN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLiNlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFR3byBpZGVudGljYWwgZW50cmllczsgaWdub3JlIGl0XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgICAgIGlmIChidWNrZXQuaGFzKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWNrZXQuc2V0KHNpZ25hdHVyZSwgZnJhZ21lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgYSBjb25zdHJ1Y3RvciBhZGQgYSBkZWZhdWx0XG4gICAgICAgIGlmICghdGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgICAgIGRlcGxveTogQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKFwiY29uc3RydWN0b3IoKVwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZhbGxiYWNrLCByZWNlaXZlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgZW50aXJlIEh1bWFuLVJlYWRhYmxlIEFCSSwgYXMgYW4gYXJyYXkgb2ZcbiAgICAgKiAgc2lnbmF0dXJlcywgb3B0aW9uYWxseSBhcyAlJW1pbmltYWwlJSBzdHJpbmdzLCB3aGljaFxuICAgICAqICByZW1vdmVzIHBhcmFtZXRlciBuYW1lcyBhbmQgdW5uZWNlZXNhcnkgc3BhY2VzLlxuICAgICAqL1xuICAgIGZvcm1hdChtaW5pbWFsKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IChtaW5pbWFsID8gXCJtaW5pbWFsXCIgOiBcImZ1bGxcIik7XG4gICAgICAgIGNvbnN0IGFiaSA9IHRoaXMuZnJhZ21lbnRzLm1hcCgoZikgPT4gZi5mb3JtYXQoZm9ybWF0KSk7XG4gICAgICAgIHJldHVybiBhYmk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIEpTT04tZW5jb2RlZCBBQkkuIFRoaXMgaXMgdGhlIGZvcm1hdCBTb2xpZGl5XG4gICAgICogIHJldHVybnMuXG4gICAgICovXG4gICAgZm9ybWF0SnNvbigpIHtcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlLWJ1bmRsZSB0aGUgSlNPTiBmcmFnbWVudHMgYSBiaXRcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFiaS5tYXAoKGopID0+IEpTT04ucGFyc2UoaikpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBBQkkgY29kZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZW5jb2RlIGFuZCBkZWNvZGUgYmluYXJ5XG4gICAgICogIGRhdGEuXG4gICAgICovXG4gICAgZ2V0QWJpQ29kZXIoKSB7XG4gICAgICAgIHJldHVybiBBYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKTtcbiAgICB9XG4gICAgLy8gRmluZCBhIGZ1bmN0aW9uIGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcbiAgICAjZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMsIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgIC8vIFNlbGVjdG9yXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiB0aGlzLiNmdW5jdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IGZyYWdtZW50LnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNmdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gKHZhbHVlcy5sZW5ndGggPiAwKSA/IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZUxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGFsbG93T3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKFR5cGVkLmlzVHlwZWQobGFzdFZhbHVlKSAmJiBsYXN0VmFsdWUudHlwZSA9PT0gXCJvdmVycmlkZXNcIikge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd09wdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVMZW5ndGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNvbXBhdGlibGUgbGVuZ3RoLiBUaGUgYXJnc1xuICAgICAgICAgICAgICAgIC8vIG1heSBjb250YWluIGFuIG92ZXJyaWRlcywgc28gdGhlIG1hdGNoIG1heSBoYXZlIG4gb3IgbiAtIDEgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzICE9PSB2YWx1ZUxlbmd0aCAmJiAoIWFsbG93T3B0aW9ucyB8fCBpbnB1dHMgIT09IHZhbHVlTGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgVHlwZWQgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHR5cGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVR5cGVkLmlzVHlwZWQodmFsdWVzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHBhc3QgdGhlIGlucHV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPj0gaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSA9PT0gXCJvdmVycmlkZXNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2YWx1ZSB0eXBlIG1hdGNoZXMgdGhlIGlucHV0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSAhPT0gaW5wdXRzW2pdLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBzaW5nbGUgbWF0Y2hpbmcgc2lnbmF0dXJlIHdpdGggYW4gb3ZlcnJpZGVzLCBidXQgdGhlXG4gICAgICAgICAgICAvLyBsYXN0IHZhbHVlIGlzIHNvbWV0aGluZyB0aGF0IGNhbm5vdCBwb3NzaWJseSBiZSBhbiBvcHRpb25zXG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAxICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoICE9PSBtYXRjaGluZ1swXS5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEFyZyA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RBcmcgPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGxhc3RBcmcpIHx8IHR5cGVvZiAobGFzdEFyZykgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKDAsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPiAxICYmIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZnVuY3Rpb24gZGVzY3JpcHRpb24gKGkuZS4gbWF0Y2hlcyAke21hdGNoU3RyfSlgLCBcImtleVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Z1bmN0aW9ucy5nZXQoRnVuY3Rpb25GcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBmdW5jdGlvbiBuYW1lIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSBmdW5jdGlvbiBzZWxlY3RvcixcbiAgICAgKiAgZnVuY3Rpb24gbmFtZSBvciBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb25OYW1lKGtleSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcImtleVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhIGZ1bmN0aW9uIHNlbGVjdG9yLCBmdW5jdGlvbiBuYW1lIG9yXG4gICAgICogIGZ1bmN0aW9uIHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGEgZnVuY3Rpb24gbmFtZSwgdGhlIG5hbWUgbWF5IGJlIGFtYmlndW91cywgc29cbiAgICAgKiAgYWNjZXNzaW5nIHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBtYXkgcmVxdWlyZSByZWZpbmVtZW50LlxuICAgICAqL1xuICAgIGhhc0Z1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNnZXRGdW5jdGlvbihrZXksIG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgW1tGdW5jdGlvbkZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uXG4gICAgICogIHNlbGVjdG9yLCBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZnVuY3Rpb25zIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBmdW5jdGlvbiBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEZ1bmN0aW9uKGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBmdW5jdGlvbnMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2Z1bmN0aW9ucy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZnVuY3Rpb25zLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZpbmQgYW4gZXZlbnQgZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgICNnZXRFdmVudChrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgLy8gRXZlbnRUb3BpY1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiB0aGlzLiNldmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUb3BpYyA9PT0gZnJhZ21lbnQudG9waWNIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNvbXBhdGlibGUgbGVuZ3RoLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdbaV0uaW5wdXRzLmxlbmd0aCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgVHlwZWQgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHR5cGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVR5cGVkLmlzVHlwZWQodmFsdWVzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2YWx1ZSB0eXBlIG1hdGNoZXMgdGhlIGlucHV0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSAhPT0gaW5wdXRzW2pdLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBldmVudCBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZXZlbnRzLmdldChFdmVudEZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGV2ZW50IG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIHRvcGljIGhhc2gsXG4gICAgICogIGV2ZW50IG5hbWUgb3IgZXZlbnQgc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqL1xuICAgIGdldEV2ZW50TmFtZShrZXkpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLiNnZXRFdmVudChrZXksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50Lm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVrZXklJSAoYW4gZXZlbnQgdG9waWMgaGFzaCwgZXZlbnQgbmFtZSBvclxuICAgICAqICBldmVudCBzaWduYXR1cmUpIGlzIHByZXNlbnQgaW4gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJbiB0aGUgY2FzZSBvZiBhbiBldmVudCBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRXZlbnRGcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgaGFzRXZlbnQoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0V2ZW50RnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGV2ZW50cyBtYXRjaCBieSBuYW1lLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZXZlbnQgaW5cbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldEV2ZW50KGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRFdmVudChrZXksIHZhbHVlcyB8fCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEl0ZXJhdGUgb3ZlciBhbGwgZXZlbnRzLCBjYWxsaW5nICUlY2FsbGJhY2slJSwgc29ydGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG4gICAgZm9yRWFjaEV2ZW50KGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbSh0aGlzLiNldmVudHMua2V5cygpKTtcbiAgICAgICAgbmFtZXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgY2FsbGJhY2soKHRoaXMuI2V2ZW50cy5nZXQobmFtZSkpLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0Vycm9yRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGFuIGVycm9yXG4gICAgICogIHNlbGVjdG9yLCBlcnJvciBuYW1lIG9yIGVycm9yIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXJyb3JzIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBlcnJvciBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RXJyb3Ioa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKEJ1aWx0aW5FcnJvcnNbc2VsZWN0b3JdLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Vycm9ycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Vycm9ycykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIkVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIEVycm9yKHN0cmluZylcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiUGFuaWNcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgUGFuaWModWludDI1NilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGVycm9yIGRlc2NyaXB0aW9uIChpLmUuICR7bWF0Y2hTdHJ9KWAsIFwibmFtZVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGtleSA9IEVycm9yRnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpO1xuICAgICAgICBpZiAoa2V5ID09PSBcIkVycm9yKHN0cmluZylcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIEVycm9yKHN0cmluZylcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pYyh1aW50MjU2KVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgUGFuaWModWludDI1NilcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZXJyb3JzLmdldChrZXkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBlcnJvcnMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRXJyb3IoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2Vycm9ycy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZXJyb3JzLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdldCB0aGUgNC1ieXRlIHNlbGVjdG9yIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYSBmdW5jdGlvblxuICAgIC8qXG5nZXRTZWxlY3RvcihmcmFnbWVudDogRXJyb3JGcmFnbWVudCB8IEZ1bmN0aW9uRnJhZ21lbnQpOiBzdHJpbmcge1xuICAgIGlmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXM6IEFycmF5PEZyYWdtZW50PiA9IFsgXTtcblxuICAgICAgICB0cnkgeyBtYXRjaGVzLnB1c2godGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCkpOyB9IGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEVycm9yKDxzdHJpbmc+ZnJhZ21lbnQpKTsgfSBjYXRjaCAoXykgeyB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5rbm93biBmcmFnbWVudFwiLCBcImtleVwiLCBmcmFnbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYW1iaWd1b3VzIGZyYWdtZW50IG1hdGNoZXMgZnVuY3Rpb24gYW5kIGVycm9yXCIsIFwia2V5XCIsIGZyYWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYWdtZW50ID0gbWF0Y2hlc1swXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVNsaWNlKGlkKGZyYWdtZW50LmZvcm1hdCgpKSwgMCwgNCk7XG59XG4gICAgKi9cbiAgICAvLyBHZXQgdGhlIDMyLWJ5dGUgdG9waWMgaGFzaCB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGFuIGV2ZW50XG4gICAgLypcbiAgICBnZXRFdmVudFRvcGljKGZyYWdtZW50OiBFdmVudEZyYWdtZW50KTogc3RyaW5nIHtcbiAgICAgICAgLy9pZiAodHlwZW9mKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikgeyBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7IH1cbiAgICAgICAgcmV0dXJuIGlkKGZyYWdtZW50LmZvcm1hdCgpKTtcbiAgICB9XG4gICAgKi9cbiAgICBfZGVjb2RlUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKHBhcmFtcywgZGF0YSk7XG4gICAgfVxuICAgIF9lbmNvZGVQYXJhbXMocGFyYW1zLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmVuY29kZShwYXJhbXMsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIGEgYGB0eC5kYXRhYGAgb2JqZWN0IGZvciBkZXBsb3lpbmcgdGhlIENvbnRyYWN0IHdpdGhcbiAgICAgKiAgdGhlICUldmFsdWVzJSUgYXMgdGhlIGNvbnN0cnVjdG9yIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBlbmNvZGVEZXBsb3kodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVQYXJhbXModGhpcy5kZXBsb3kuaW5wdXRzLCB2YWx1ZXMgfHwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlcyB0aGUgcmVzdWx0ICUlZGF0YSUlIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBlcnJvciAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvclxuICAgICAqICAlJWtleSUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZUNhbGxSZXN1bHRdXSBtZXRob2QgaW5zdGVhZCxcbiAgICAgKiAgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCBhIGBgQ0FMTF9FWENFUFRJT05gYCBhbmQgdGhyb3cgdGhlXG4gICAgICogIGNvcnJlc3BvbmRpbmcgZXJyb3IuXG4gICAgICovXG4gICAgZGVjb2RlRXJyb3JSZXN1bHQoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YVNsaWNlKGRhdGEsIDAsIDQpID09PSBmcmFnbWVudC5zZWxlY3RvciwgYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGVycm9yICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgZGF0YVNsaWNlKGRhdGEsIDQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIHRyYW5zYWN0aW9uIHJldmVydCBkYXRhIGZvciBhIGNhbGwgcmVzdWx0IHRoYXRcbiAgICAgKiAgcmV2ZXJ0ZWQgZnJvbSB0aGUgdGhlIENvbnRyYWN0IHdpdGggdGhlIHNlcGNpZmllZCAlJWVycm9yJSVcbiAgICAgKiAgKHNlZSBbW2dldEVycm9yXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3IgJSVmcmFnbWVudCUlKSB3aXRoIHRoZSAlJXZhbHVlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VkIGJ5IG1vc3QgZGV2ZWxvcGVycywgdW5sZXNzIHRyeWluZyB0byBtb2NrXG4gICAgICogIGEgcmVzdWx0IGZyb20gYSBDb250cmFjdC5cbiAgICAgKi9cbiAgICBlbmNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGVycm9yXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgZnJhZ21lbnQuc2VsZWN0b3IsXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCB2YWx1ZXMgfHwgW10pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlcyB0aGUgJSVkYXRhJSUgZnJvbSBhIHRyYW5zYWN0aW9uIGBgdHguZGF0YWBgIGZvclxuICAgICAqICB0aGUgZnVuY3Rpb24gc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXNcbiAgICAgKiAgZm9yICUlZnJhZ21lbnQlJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VUcmFuc2FjdGlvbl1dIG1ldGhvZFxuICAgICAqICBpbnN0ZWFkLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBkZWNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YVNsaWNlKGRhdGEsIDAsIDQpID09PSBmcmFnbWVudC5zZWxlY3RvciwgYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGZ1bmN0aW9uICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgZGF0YVNsaWNlKGRhdGEsIDQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIGBgdHguZGF0YWBgIGZvciBhIHRyYW5zYWN0aW9uIHRoYXQgY2FsbHMgdGhlIGZ1bmN0aW9uXG4gICAgICogIHNwZWNpZmllZCAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGhcbiAgICAgKiAgdGhlICUldmFsdWVzJSUuXG4gICAgICovXG4gICAgZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGZ1bmN0aW9uIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgICogICUla2V5JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBkZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiaW52YWxpZCBsZW5ndGggZm9yIHJlc3VsdCBkYXRhXCI7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGRhdGEpO1xuICAgICAgICBpZiAoKGJ5dGVzLmxlbmd0aCAlIDMyKSA9PT0gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50Lm91dHB1dHMsIGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcImNvdWxkIG5vdCBkZWNvZGUgcmVzdWx0IGRhdGFcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHJldHVybmVkIGRhdGEgd2l0aCBubyBlcnJvciwgYnV0IHRoZSBkYXRhIGlzIGp1bmtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBtZXNzYWdlLCBcIkJBRF9EQVRBXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBoZXhsaWZ5KGJ5dGVzKSxcbiAgICAgICAgICAgIGluZm86IHsgbWV0aG9kOiBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1ha2VFcnJvcihfZGF0YSwgdHgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgICAgIGNvbnN0IGVycm9yID0gQWJpQ29kZXIuZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oXCJjYWxsXCIsIHR4LCBkYXRhKTtcbiAgICAgICAgLy8gTm90IGEgYnVpbHQtaW4gZXJyb3I7IHRyeSBmaW5kaW5nIGEgY3VzdG9tIGVycm9yXG4gICAgICAgIGNvbnN0IGN1c3RvbVByZWZpeCA9IFwiZXhlY3V0aW9uIHJldmVydGVkICh1bmtub3duIGN1c3RvbSBlcnJvcilcIjtcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChjdXN0b21QcmVmaXgpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGhleGxpZnkoZGF0YS5zbGljZSgwLCA0KSk7XG4gICAgICAgICAgICBjb25zdCBlZiA9IHRoaXMuZ2V0RXJyb3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKGVmKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShlZi5pbnB1dHMsIGRhdGEuc2xpY2UoNCkpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5yZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlZi5uYW1lLCBzaWduYXR1cmU6IGVmLmZvcm1hdCgpLCBhcmdzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJlYXNvbiA9IGVycm9yLnJldmVydC5zaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkOiAke2Vycm9yLnJlYXNvbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYGV4ZWN1dGlvbiByZXZlcnRlZCAoY291bHQgbm90IGRlY29kZSBjdXN0b20gZXJyb3IpYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBpbnZvY2F0aW9uLCBpZiBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZVRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgZXJyb3IuaW52b2NhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHBhcnNlZC5uYW1lLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogcGFyc2VkLnNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBwYXJzZWQuYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIHRoZSByZXN1bHQgZGF0YSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKSB3aXRoICUldmFsdWVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgYnkgbW9zdCBkZXZlbG9wZXJzLCB1bmxlc3MgdHJ5aW5nIHRvIG1vY2tcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGVuY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkodGhpcy4jYWJpQ29kZXIuZW5jb2RlKGZyYWdtZW50Lm91dHB1dHMsIHZhbHVlcyB8fCBbXSkpO1xuICAgIH1cbiAgICAvKlxuICAgICAgICBzcGVsdW5rKGlucHV0czogQXJyYXk8UGFyYW1UeXBlPiwgdmFsdWVzOiBSZWFkb25seUFycmF5PGFueT4sIHByb2Nlc3NmdW5jOiAodHlwZTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBQcm9taXNlPGFueT4pOiBQcm9taXNlPEFycmF5PGFueT4+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzOiBBcnJheTxQcm9taXNlPD4+ID0gWyBdO1xuICAgICAgICAgICAgY29uc3QgcHJvY2VzcyA9IGZ1bmN0aW9uKHR5cGU6IFBhcmFtVHlwZSwgdmFsdWU6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY2VuZCh0eXBlLmNoaWxkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlLiA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgY29uc3QgZGVzY2VuZCA9IGZ1bmN0aW9uIChpbnB1dHM6IEFycmF5PFBhcmFtVHlwZT4sIHZhbHVlczogUmVhZG9ubHlBcnJheTxhbnk+KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHsgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG1pc21hdGNoXCIpOyB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxhbnk+ID0gWyBdO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgKi9cbiAgICAvLyBDcmVhdGUgdGhlIGZpbHRlciBmb3IgdGhlIGV2ZW50IHdpdGggc2VhcmNoIGNyaXRlcmlhIChlLmcuIGZvciBldGhfZmlsdGVyTG9nKVxuICAgIGVuY29kZUZpbHRlclRvcGljcyhmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGV2ZW50XCIsIFwiZXZlbnRGcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KHZhbHVlcy5sZW5ndGggPD0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgYHRvbyBtYW55IGFyZ3VtZW50cyBmb3IgJHtmcmFnbWVudC5mb3JtYXQoKX1gLCBcIlVORVhQRUNURURfQVJHVU1FTlRcIiwgeyBjb3VudDogdmFsdWVzLmxlbmd0aCwgZXhwZWN0ZWRDb3VudDogZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCB9KTtcbiAgICAgICAgY29uc3QgdG9waWNzID0gW107XG4gICAgICAgIGlmICghZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICB0b3BpY3MucHVzaChmcmFnbWVudC50b3BpY0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBVc2UgdGhlIGNvZGVycyBmb3IgdGhpczsgdG8gcHJvcGVybHkgc3VwcG9ydCB0dXBsZXMsIGV0Yy5cbiAgICAgICAgY29uc3QgZW5jb2RlVG9waWMgPSAocGFyYW0sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGhleGxpZnkodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImJvb2xcIiAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFwiMHgwMVwiIDogXCIweDAwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvQmVIZXgodmFsdWUpOyAvLyBAVE9ETzogU2hvdWxkIHRoaXMgdG9Ud29zPz9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUubWF0Y2goL15ieXRlcy8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB6ZXJvUGFkQnl0ZXModmFsdWUsIDMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWRkcmVzc2VzIGFyZSB2YWxpZFxuICAgICAgICAgICAgICAgIHRoaXMuI2FiaUNvZGVyLmVuY29kZShbXCJhZGRyZXNzXCJdLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB6ZXJvUGFkVmFsdWUoaGV4bGlmeSh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBmcmFnbWVudC5pbnB1dHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPT0gbnVsbCwgXCJjYW5ub3QgZmlsdGVyIG5vbi1pbmRleGVkIHBhcmFtZXRlcnM7IG11c3QgYmUgbnVsbFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHZhbHVlLm1hcCgodmFsdWUpID0+IGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHJpbSBvZmYgdHJhaWxpbmcgbnVsbHNcbiAgICAgICAgd2hpbGUgKHRvcGljcy5sZW5ndGggJiYgdG9waWNzW3RvcGljcy5sZW5ndGggLSAxXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdG9waWNzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3BpY3M7XG4gICAgfVxuICAgIGVuY29kZUV2ZW50TG9nKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVR5cGVzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWVzLmxlbmd0aCA9PT0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgXCJldmVudCBhcmd1bWVudHMvdmFsdWVzIG1pc21hdGNoXCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XG4gICAgICAgIGZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goaWQodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGtlY2NhazI1Nih2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE9cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtwYXJhbS50eXBlXSwgW3ZhbHVlXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICBkYXRhVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuI2FiaUNvZGVyLmVuY29kZShkYXRhVHlwZXMsIGRhdGFWYWx1ZXMpLFxuICAgICAgICAgICAgdG9waWNzOiB0b3BpY3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gRGVjb2RlIGEgZmlsdGVyIGZvciB0aGUgZXZlbnQgYW5kIHRoZSBzZWFyY2ggY3JpdGVyaWFcbiAgICBkZWNvZGVFdmVudExvZyhmcmFnbWVudCwgZGF0YSwgdG9waWNzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGV2ZW50XCIsIFwiZXZlbnRGcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcGljcyAhPSBudWxsICYmICFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VG9waWMgPSBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh0b3BpY3NbMF0sIDMyKSAmJiB0b3BpY3NbMF0udG9Mb3dlckNhc2UoKSA9PT0gZXZlbnRUb3BpYywgXCJmcmFnbWVudC90b3BpYyBtaXNtYXRjaFwiLCBcInRvcGljc1swXVwiLCB0b3BpY3NbMF0pO1xuICAgICAgICAgICAgdG9waWNzID0gdG9waWNzLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ZWQgPSBbXTtcbiAgICAgICAgY29uc3Qgbm9uSW5kZXhlZCA9IFtdO1xuICAgICAgICBjb25zdCBkeW5hbWljID0gW107XG4gICAgICAgIGZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgcGFyYW0udHlwZSA9PT0gXCJieXRlc1wiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2goUGFyYW1UeXBlLmZyb20oeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogcGFyYW0ubmFtZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9uSW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0SW5kZXhlZCA9ICh0b3BpY3MgIT0gbnVsbCkgPyB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoaW5kZXhlZCwgY29uY2F0KHRvcGljcykpIDogbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0Tm9uSW5kZXhlZCA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShub25JbmRleGVkLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgLy9jb25zdCByZXN1bHQ6IChBcnJheTxhbnk+ICYgeyBbIGtleTogc3RyaW5nIF06IGFueSB9KSA9IFsgXTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgbGV0IG5vbkluZGV4ZWRJbmRleCA9IDAsIGluZGV4ZWRJbmRleCA9IDA7XG4gICAgICAgIGZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRJbmRleGVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgSW5kZXhlZChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgSW5kZXhlZChyZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdE5vbkluZGV4ZWRbbm9uSW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBrZXlzLnB1c2gocGFyYW0ubmFtZSB8fCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBSZXN1bHQuZnJvbUl0ZW1zKHZhbHVlcywga2V5cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSB0cmFuc2FjdGlvbiwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGZ1bmN0aW9uIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJuIG51bGwuXG4gICAgICovXG4gICAgcGFyc2VUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXModHguZGF0YSwgXCJ0eC5kYXRhXCIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludCgodHgudmFsdWUgIT0gbnVsbCkgPyB0eC52YWx1ZSA6IDAsIFwidHgudmFsdWVcIik7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihoZXhsaWZ5KGRhdGEuc2xpY2UoMCwgNCkpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIGRhdGEuc2xpY2UoNCkpO1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzLCB2YWx1ZSk7XG4gICAgfVxuICAgIHBhcnNlQ2FsbFJlc3VsdChkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGFyc2VzIGEgcmVjZWlwdCBsb2csIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGV2ZW50IGFuZCBleHRyYWN0c1xuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBldmVudCBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBldmVudCBjYW5ub3QgYmUgZm91bmQsIHJldHVybnMgbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZUxvZyhsb2cpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICBpZiAoIWZyYWdtZW50IHx8IGZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IElmIGFub255bW91cywgYW5kIHRoZSBvbmx5IG1ldGhvZCwgYW5kIHRoZSBpbnB1dCBjb3VudCBtYXRjaGVzLCBzaG91bGQgd2UgcGFyc2U/XG4gICAgICAgIC8vICAgICAgICBQcm9iYWJseSBub3QsIGJlY2F1c2UganVzdCBiZWNhdXNlIGl0IGlzIHRoZSBvbmx5IGV2ZW50IGluIHRoZSBBQkkgZG9lc1xuICAgICAgICAvLyAgICAgICAgbm90IG1lYW4gd2UgaGF2ZSB0aGUgZnVsbCBBQkk7IG1heWJlIGp1c3QgYSBmcmFnbWVudD9cbiAgICAgICAgcmV0dXJuIG5ldyBMb2dEZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQudG9waWNIYXNoLCB0aGlzLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGFyc2VzIGEgcmV2ZXJ0IGRhdGEsIGZpbmRpbmcgdGhlIG1hdGNoaW5nIGVycm9yIGFuZCBleHRyYWN0c1xuICAgICAqICB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhbG9uZyB3aXRoIG90aGVyIHVzZWZ1bCBlcnJvciBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIElmIHRoZSBtYXRjaGluZyBlcnJvciBjYW5ub3QgYmUgZm91bmQsIHJldHVybnMgbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZUVycm9yKGRhdGEpIHtcbiAgICAgICAgY29uc3QgaGV4RGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRFcnJvcihkYXRhU2xpY2UoaGV4RGF0YSwgMCwgNCkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YVNsaWNlKGhleERhdGEsIDQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckRlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC5zZWxlY3RvciwgYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbSW50ZXJmYWNlXV0gZnJvbSB0aGUgQUJJICUldmFsdWUlJS5cbiAgICAgKlxuICAgICAqICBUaGUgJSV2YWx1ZSUlIG1heSBiZSBwcm92aWRlZCBhcyBhbiBleGlzdGluZyBbW0ludGVyZmFjZV1dIG9iamVjdCxcbiAgICAgKiAgYSBKU09OLWVuY29kZWQgQUJJIG9yIGFueSBIdW1hbi1SZWFkYWJsZSBBQkkgZm9ybWF0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYW4gSW50ZXJmYWNlLCB3aGljaCBpcyBpbW11dGFibGVcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJmYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlNPTlxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbiBJbnRlcmZhY2U7IHBvc3NpYmx5IGZyb20gYW5vdGhlciB2NiBpbnN0YW5jZVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZS5mb3JtYXRKc29uKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZS5mb3JtYXRKc29uKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgbGVnYWN5IEludGVyZmFjZTsgZnJvbSBhbiBvbGRlciB2ZXJzaW9uXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlLmZvcm1hdCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2YgZnJhZ21lbnRzXG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIiwiLy9pbXBvcnQgeyByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgaXNCeXRlc0xpa2UsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0Vycm9yLCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdG9Kc29uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufVxuLy8gQFRPRE8/IDxUIGV4dGVuZHMgRmVlRGF0YSA9IHsgfT4gaW1wbGVtZW50cyBSZXF1aXJlZDxUPlxuLyoqXG4gKiAgQSAqKkZlZURhdGEqKiB3cmFwcyBhbGwgdGhlIGZlZS1yZWxhdGVkIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGhcbiAqICB0aGUgbmV0d29yay5cbiAqL1xuZXhwb3J0IGNsYXNzIEZlZURhdGEge1xuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIHByaWNlIGZvciBsZWdhY3kgbmV0d29ya3MuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIGZlZSB0byBwYXkgcGVyIGdhcy5cbiAgICAgKlxuICAgICAqICBUaGUgYmFzZSBmZWUgcGVyIGdhcyBpcyBkZWZpbmVkIGJ5IHRoZSBuZXR3b3JrIGFuZCBiYXNlZCBvblxuICAgICAqICBjb25nZXN0aW9uLCBpbmNyZWFzaW5nIHRoZSBjb3N0IGR1cmluZyB0aW1lcyBvZiBoZWF2eSBsb2FkXG4gICAgICogIGFuZCBsb3dlcmluZyB3aGVuIGxlc3MgYnVzeS5cbiAgICAgKlxuICAgICAqICBUaGUgYWN0dWFsIGZlZSBwZXIgZ2FzIHdpbGwgYmUgdGhlIGJhc2UgZmVlIGZvciB0aGUgYmxvY2tcbiAgICAgKiAgYW5kIHRoZSBwcmlvcml0eSBmZWUsIHVwIHRvIHRoZSBtYXggZmVlIHBlciBnYXMuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcbiAgICAgKi9cbiAgICBtYXhGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRpdGlvbmFsIGFtb3V0IHRvIHBheSBwZXIgZ2FzIHRvIGVuY291cmFnZSBhIHZhbGlkYXRvclxuICAgICAqICB0byBpbmNsdWRlIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGUgcHVycG9zZSBvZiB0aGlzIGlzIHRvIGNvbXBlbnNhdGUgdGhlIHZhbGlkYXRvciBmb3IgdGhlXG4gICAgICogIGFkanVzdGVkIHJpc2sgZm9yIGluY2x1ZGluZyBhIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBiZSBgYG51bGxgYCBvbiBsZWdhY3kgbmV0d29ya3MgKGkuZS4gW3ByZS1FSVAtMTU1OV0obGluay1laXAtMTU1OSkpXG4gICAgICovXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgRmVlRGF0YSBmb3IgJSVnYXNQcmljZSUlLCAlJW1heEZlZVBlckdhcyUlIGFuZFxuICAgICAqICAlJW1heFByaW9yaXR5RmVlUGVyR2FzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBnYXNQcmljZTogZ2V0VmFsdWUoZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBnZXRWYWx1ZShtYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGdldFZhbHVlKG1heFByaW9yaXR5RmVlUGVyR2FzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIkZlZURhdGFcIixcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24oZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24obWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24obWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbjtcbi8qKlxuICogIFJldHVybnMgYSBjb3B5IG9mICUlcmVxJSUgd2l0aCBhbGwgcHJvcGVydGllcyBjb2VyY2VkIHRvIHRoZWlyIHN0cmljdFxuICogIHR5cGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weVJlcXVlc3QocmVxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLy8gVGhlc2UgY291bGQgYmUgYWRkcmVzc2VzLCBFTlMgbmFtZXMgb3IgQWRkcmVzc2FibGVzXG4gICAgaWYgKHJlcS50bykge1xuICAgICAgICByZXN1bHQudG8gPSByZXEudG87XG4gICAgfVxuICAgIGlmIChyZXEuZnJvbSkge1xuICAgICAgICByZXN1bHQuZnJvbSA9IHJlcS5mcm9tO1xuICAgIH1cbiAgICBpZiAocmVxLmRhdGEpIHtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBoZXhsaWZ5KHJlcS5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgYmlnSW50S2V5cyA9IFwiY2hhaW5JZCxnYXNMaW1pdCxnYXNQcmljZSxtYXhGZWVQZXJCbG9iR2FzLG1heEZlZVBlckdhcyxtYXhQcmlvcml0eUZlZVBlckdhcyx2YWx1ZVwiLnNwbGl0KC8sLyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYmlnSW50S2V5cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcmVxKSB8fCByZXFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9IGdldEJpZ0ludChyZXFba2V5XSwgYHJlcXVlc3QuJHtrZXl9YCk7XG4gICAgfVxuICAgIGNvbnN0IG51bWJlcktleXMgPSBcInR5cGUsbm9uY2VcIi5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG51bWJlcktleXMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXROdW1iZXIocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xuICAgIH1cbiAgICBpZiAocmVxLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHJlcS5hY2Nlc3NMaXN0KTtcbiAgICB9XG4gICAgaWYgKHJlcS5hdXRob3JpemF0aW9uTGlzdCkge1xuICAgICAgICByZXN1bHQuYXV0aG9yaXphdGlvbkxpc3QgPSByZXEuYXV0aG9yaXphdGlvbkxpc3Quc2xpY2UoKTtcbiAgICB9XG4gICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmJsb2NrVGFnID0gcmVxLmJsb2NrVGFnO1xuICAgIH1cbiAgICBpZiAoXCJlbmFibGVDY2lwUmVhZFwiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuZW5hYmxlQ2NpcFJlYWQgPSAhIXJlcS5lbmFibGVDY2lwUmVhZDtcbiAgICB9XG4gICAgaWYgKFwiY3VzdG9tRGF0YVwiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuY3VzdG9tRGF0YSA9IHJlcS5jdXN0b21EYXRhO1xuICAgIH1cbiAgICBpZiAoXCJibG9iVmVyc2lvbmVkSGFzaGVzXCIgaW4gcmVxICYmIHJlcS5ibG9iVmVyc2lvbmVkSGFzaGVzKSB7XG4gICAgICAgIHJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaGVzID0gcmVxLmJsb2JWZXJzaW9uZWRIYXNoZXMuc2xpY2UoKTtcbiAgICB9XG4gICAgaWYgKFwia3pnXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5remcgPSByZXEua3pnO1xuICAgIH1cbiAgICBpZiAoXCJibG9ic1wiIGluIHJlcSAmJiByZXEuYmxvYnMpIHtcbiAgICAgICAgcmVzdWx0LmJsb2JzID0gcmVxLmJsb2JzLm1hcCgoYikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQnl0ZXNMaWtlKGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgQSAqKkJsb2NrKiogcmVwcmVzZW50cyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggYSBmdWxsIGJsb2NrIG9uXG4gKiAgRXRoZXJldW0uXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9jayB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGJsb2NrIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciwgc29tZXRpbWVzIGNhbGxlZCB0aGUgYmxvY2sgaGVpZ2h0LiBUaGlzIGlzIGFcbiAgICAgKiAgc2VxdWVudGlhbCBudW1iZXIgdGhhdCBpcyBvbmUgaGlnaGVyIHRoYW4gdGhlIHBhcmVudCBibG9jay5cbiAgICAgKi9cbiAgICBudW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoLlxuICAgICAqXG4gICAgICogIFRoaXMgaGFzaCBpbmNsdWRlcyBhbGwgcHJvcGVydGllcywgc28gY2FuIGJlIHNhZmVseSB1c2VkIHRvIGlkZW50aWZ5XG4gICAgICogIGFuIGV4YWN0IHNldCBvZiBibG9jayBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSB0aW1lc3RhbXAgZm9yIHRoaXMgYmxvY2ssIHdoaWNoIGlzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZVxuICAgICAqICBlcG9jaCB0aGF0IHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkLlxuICAgICAqL1xuICAgIHRpbWVzdGFtcDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIHBhcmVudCBibG9jay5cbiAgICAgKi9cbiAgICBwYXJlbnRIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaGFzaCB0cmVlIHJvb3Qgb2YgdGhlIHBhcmVudCBiZWFjb24gYmxvY2sgZm9yIHRoZSBnaXZlblxuICAgICAqICBleGVjdXRpb24gYmxvY2suIFNlZSBbW2xpbmstZWlwLTQ3ODhdXS5cbiAgICAgKi9cbiAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSBub25jZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHJhbmRvbSBudW1iZXIgaW5zZXJ0ZWQgd2hpY2hcbiAgICAgKiAgcGVybWl0dGVkIHRoZSBkaWZmaWN1bHR5IHRhcmdldCB0byBiZSByZWFjaGVkLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGlmZmljdWx0eSB0YXJnZXQuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSBwcm9vZi1vZi13b3JrIHRhcmdldCByZXF1aXJlZFxuICAgICAqICBmb3IgYSBibG9jayB0byBtZWV0IHRoZSBwcm90b2NvbCBydWxlcyB0byBiZSBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqICBPbiBtb2Rlcm4gbmV0d29ya3MsIHRoaXMgaXMgYSByYW5kb20gbnVtYmVyIGFycml2ZWQgYXQgdXNpbmdcbiAgICAgKiAgcmFuZGFvLiAgQFRPRE86IEZpbmQgbGlua3M/XG4gICAgICovXG4gICAgZGlmZmljdWx0eTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyBsaW1pdCBmb3IgdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnYXNMaW1pdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyB1c2VkIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJvb3QgaGFzaCBmb3IgdGhlIGdsb2JhbCBzdGF0ZSBhZnRlciBhcHBseWluZyBjaGFuZ2VzXG4gICAgICogIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgc3RhdGVSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdHMgdHJpZS5cbiAgICAgKi9cbiAgICByZWNlaXB0c1Jvb3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBhbW91bnQgb2YgYmxvYiBnYXMgY29uc3VtZWQgYnkgdGhlIHRyYW5zYWN0aW9uc1xuICAgICAqICB3aXRoaW4gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXG4gICAgICovXG4gICAgYmxvYkdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBydW5uaW5nIHRvdGFsIG9mIGJsb2IgZ2FzIGNvbnN1bWVkIGluIGV4Y2VzcyBvZiB0aGVcbiAgICAgKiAgdGFyZ2V0LCBwcmlvciB0byB0aGUgYmxvY2suIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBleGNlc3NCbG9iR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWluZXIgY29pbmJhc2UgYWRkcmVzcywgd2loY2ggcmVjZWl2ZXMgYW55IHN1YnNpZGllcyBmb3JcbiAgICAgKiAgaW5jbHVkaW5nIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgbWluZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBsYXRlc3QgUkFOREFPIG1peCBvZiB0aGUgcG9zdCBiZWFjb24gc3RhdGUgb2ZcbiAgICAgKiAgdGhlIHByZXZpb3VzIGJsb2NrLlxuICAgICAqL1xuICAgIHByZXZSYW5kYW87XG4gICAgLyoqXG4gICAgICogIEFueSBleHRyYSBkYXRhIHRoZSB2YWxpZGF0b3Igd2lzaGVkIHRvIGluY2x1ZGUuXG4gICAgICovXG4gICAgZXh0cmFEYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmFzZSBmZWUgcGVyIGdhcyB0aGF0IGFsbCB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jayB3ZXJlXG4gICAgICogIGNoYXJnZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBhZGp1c3RzIGFmdGVyIGVhY2ggYmxvY2ssIGRlcGVuZGluZyBvbiBob3cgY29uZ2VzdGVkIHRoZSBuZXR3b3JrXG4gICAgICogIGlzLlxuICAgICAqL1xuICAgIGJhc2VGZWVQZXJHYXM7XG4gICAgI3RyYW5zYWN0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQmxvY2sqKiBvYmplY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSBuZWNlc3NhcnkgYXMgdGhlIHVubGVzcyBpbXBsZW1lbnRpbmcgYVxuICAgICAqICBsb3ctbGV2ZWwgbGlicmFyeS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihibG9jaywgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jdHJhbnNhY3Rpb25zID0gYmxvY2sudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIGhhc2g6IGdldFZhbHVlKGJsb2NrLmhhc2gpLFxuICAgICAgICAgICAgbnVtYmVyOiBibG9jay5udW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGJsb2NrLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEhhc2g6IGJsb2NrLnBhcmVudEhhc2gsXG4gICAgICAgICAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q6IGJsb2NrLnBhcmVudEJlYWNvbkJsb2NrUm9vdCxcbiAgICAgICAgICAgIG5vbmNlOiBibG9jay5ub25jZSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IGJsb2NrLmRpZmZpY3VsdHksXG4gICAgICAgICAgICBnYXNMaW1pdDogYmxvY2suZ2FzTGltaXQsXG4gICAgICAgICAgICBnYXNVc2VkOiBibG9jay5nYXNVc2VkLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IGJsb2NrLmJsb2JHYXNVc2VkLFxuICAgICAgICAgICAgZXhjZXNzQmxvYkdhczogYmxvY2suZXhjZXNzQmxvYkdhcyxcbiAgICAgICAgICAgIG1pbmVyOiBibG9jay5taW5lcixcbiAgICAgICAgICAgIHByZXZSYW5kYW86IGdldFZhbHVlKGJsb2NrLnByZXZSYW5kYW8pLFxuICAgICAgICAgICAgZXh0cmFEYXRhOiBibG9jay5leHRyYURhdGEsXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBnZXRWYWx1ZShibG9jay5iYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIHN0YXRlUm9vdDogYmxvY2suc3RhdGVSb290LFxuICAgICAgICAgICAgcmVjZWlwdHNSb290OiBibG9jay5yZWNlaXB0c1Jvb3QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbiBoYXNoZXMsIGluIHRoZSBvcmRlclxuICAgICAqICB0aGV5IHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eC5oYXNoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGNvbXBsZXRlIHRyYW5zYWN0aW9ucywgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgKiAgd2VyZSBleGVjdXRlZCB3aXRoaW4gdGhlIGJsb2NrLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGJsb2NrcyB3aGljaCBwcmVmZXRjaGVkXG4gICAgICogIHRyYW5zYWN0aW9ucywgYnkgcGFzc2luZyBgYHRydWVgYCB0byAlJXByZWZldGNoVHhzJSVcbiAgICAgKiAgaW50byBbW1Byb3ZpZGVyLWdldEJsb2NrXV0uXG4gICAgICovXG4gICAgZ2V0IHByZWZldGNoZWRUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMuI3RyYW5zYWN0aW9ucy5zbGljZSgpO1xuICAgICAgICAvLyBEb2Vzbid0IG1hdHRlci4uLlxuICAgICAgICBpZiAodHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBwcmVmZXRjaGVkIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiAodHhzWzBdKSA9PT0gXCJvYmplY3RcIiwgXCJ0cmFuc2FjdGlvbnMgd2VyZSBub3QgcHJlZmV0Y2hlZCB3aXRoIGJsb2NrIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRyYW5zYWN0aW9uUmVzcG9uc2VzKClcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR4cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBiYXNlRmVlUGVyR2FzLCBkaWZmaWN1bHR5LCBleHRyYURhdGEsIGdhc0xpbWl0LCBnYXNVc2VkLCBoYXNoLCBtaW5lciwgcHJldlJhbmRhbywgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgcGFyZW50QmVhY29uQmxvY2tSb290LCBzdGF0ZVJvb3QsIHJlY2VpcHRzUm9vdCwgdGltZXN0YW1wLCB0cmFuc2FjdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJCbG9ja1wiLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogdG9Kc29uKGJhc2VGZWVQZXJHYXMpLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogdG9Kc29uKGRpZmZpY3VsdHkpLFxuICAgICAgICAgICAgZXh0cmFEYXRhLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbihnYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNVc2VkOiB0b0pzb24oZ2FzVXNlZCksXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdG9Kc29uKHRoaXMuYmxvYkdhc1VzZWQpLFxuICAgICAgICAgICAgZXhjZXNzQmxvYkdhczogdG9Kc29uKHRoaXMuZXhjZXNzQmxvYkdhcyksXG4gICAgICAgICAgICBoYXNoLCBtaW5lciwgcHJldlJhbmRhbywgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLFxuICAgICAgICAgICAgcGFyZW50QmVhY29uQmxvY2tSb290LCBzdGF0ZVJvb3QsIHJlY2VpcHRzUm9vdCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMudHJhbnNhY3Rpb25zO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHhzW2luZGV4KytdLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLiN0cmFuc2FjdGlvbnMubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstanMtZGF0ZV1dIHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkIGF0LlxuICAgICAqL1xuICAgIGdldCBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lc3RhbXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudGltZXN0YW1wICogMTAwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIHRyYW5zYWN0aW9uIGF0ICUlaW5kZXhlJSUgd2l0aGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oaW5kZXhPckhhc2gpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgaW50ZXJuYWwgdmFsdWUgYnkgaXRzIGluZGV4IG9yIGhhc2hcbiAgICAgICAgbGV0IHR4ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIChpbmRleE9ySGFzaCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHR4ID0gdGhpcy4jdHJhbnNhY3Rpb25zW2luZGV4T3JIYXNoXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRoaXMuI3RyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYuaGFzaCAhPT0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHggPSB2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHN1Y2ggdHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odHgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgYSAqKkJsb2NrKiogd2FzIGZldGNoZWQgd2l0aCBhIHJlcXVlc3QgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb25zXG4gICAgICogIHRoaXMgd2lsbCBhbGxvdyBzeW5jaHJvbm91cyBhY2Nlc3MgdG8gdGhvc2UgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogIElmIHRoZSB0cmFuc2FjdGlvbnMgd2VyZSBub3QgcHJlZmV0Y2hlZCwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldFByZWZldGNoZWRUcmFuc2FjdGlvbihpbmRleE9ySGFzaCkge1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLnByZWZldGNoZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgKGluZGV4T3JIYXNoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHR4c1tpbmRleE9ySGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhPckhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHR4IG9mIHR4cykge1xuICAgICAgICAgICAgaWYgKHR4Lmhhc2ggPT09IGluZGV4T3JIYXNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcIm5vIG1hdGNoaW5nIHRyYW5zYWN0aW9uXCIsIFwiaW5kZXhPckhhc2hcIiwgaW5kZXhPckhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgYmVlbiBtaW5lZC4gVGhpcyBwcm92aWRlcyBhIHR5cGUgZ3VhcmRcbiAgICAgKiAgZm9yIGFsbCBwcm9wZXJ0aWVzIG9uIGEgW1tNaW5lZEJsb2NrXV0uXG4gICAgICovXG4gICAgaXNNaW5lZCgpIHsgcmV0dXJuICEhdGhpcy5oYXNoOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGJsb2NrIGlzIGFuIFtbbGluay1laXAtMjkzMF1dIGJsb2NrLlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmJhc2VGZWVQZXJHYXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBvcnBoYW5lZEV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNaW5lZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIodGhpcyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTG9nXG4vKipcbiAqICBBICoqTG9nKiogaW4gRXRoZXJldW0gcmVwcmVzZW50cyBhbiBldmVudCB0aGF0IGhhcyBiZWVuIGluY2x1ZGVkIGluIGFcbiAqICB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYGBMT0cqYGAgb3Bjb2Rlcywgd2hpY2ggYXJlIG1vc3QgY29tbW9ubHkgdXNlZCBieVxuICogIFNvbGlkaXR5J3MgZW1pdCBmb3IgYW5ub3VuY2luZyBldmVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2cge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBsb2cgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdGhpcyBsb2cgb2NjdXJyZWQgaW4uIFVzZSB0aGVcbiAgICAgKiAgW1tMb2ctZ2V0VHJhbnNhY3Rpb25dXSB0byBnZXQgdGhlIFtbVHJhbnNhY3Rpb25SZXNwb25zZV1dLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXG4gICAgICogIFtbTG9nLWdldEJsb2NrXV0gdG8gZ2V0IHRoZSBbW0Jsb2NrXV0uXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gSXQgaXMgcHJlZmVycmVkXG4gICAgICogIHRvIHVzZSB0aGUgW1tCbG9jay1oYXNoXV0gd2hlbiBmZXRjaGluZyB0aGUgcmVsYXRlZCBbW0Jsb2NrXV0sXG4gICAgICogIHNpbmNlIGluIHRoZSBjYXNlIG9mIGFuIG9ycGhhbmVkIGJsb2NrLCB0aGUgYmxvY2sgYXQgdGhhdCBoZWlnaHQgbWF5XG4gICAgICogIGhhdmUgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlICoqTG9nKiogcmVwcmVzZW50cyBhIGJsb2NrIHRoYXQgd2FzIHJlbW92ZWQgZHVlIHRvIGFuIG9ycGhhbmVkXG4gICAgICogIGJsb2NrLCB0aGlzIHdpbGwgYmUgdHJ1ZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBvbmx5IGhhcHBlbiB3aXRoaW4gYW4gb3JwaGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHJlbW92ZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCB0aGF0IGVtaXR0ZWQgdGhpcyBsb2cuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhpcyBsb2cgd2hlbiBpdCB3YXMgZW1pdHRlZC5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXhlZCB0b3BpY3MgaW5jbHVkZWQgaW4gdGhpcyBsb2cgd2hlbiBpdCB3YXMgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqICBBbGwgdG9waWNzIGFyZSBpbmNsdWRlZCBpbiB0aGUgYmxvb20gZmlsdGVycywgc28gdGhleSBjYW4gYmVcbiAgICAgKiAgZWZmaWNpZW50bHkgZmlsdGVyZWQgdXNpbmcgdGhlIFtbUHJvdmlkZXItZ2V0TG9nc11dIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0b3BpY3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGF0LiBUaGlzIGlzIGdlbmVyYWxseVxuICAgICAqICBub3QgdXNlZnVsIHRvIGRldmVsb3BlcnMsIGJ1dCBjYW4gYmUgdXNlZCB3aXRoIHRoZSB2YXJpb3VzIHJvb3RzXG4gICAgICogIHRvIHByb29mIGluY2x1c2lvbiB3aXRoaW4gYSBibG9jay5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gb2YgdGhpcyBsb2cuXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25JbmRleDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IE9iamVjdC5mcmVlemUobG9nLnRvcGljcy5zbGljZSgpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgcmVtb3ZlZDogbG9nLnJlbW92ZWQsXG4gICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgdG9waWNzLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGxvZy50cmFuc2FjdGlvbkluZGV4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBhZGRyZXNzLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBkYXRhLCBpbmRleCwgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJsb2dcIixcbiAgICAgICAgICAgIGFkZHJlc3MsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGRhdGEsIGluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGJsb2NrIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayh0aGlzLmJsb2NrSGFzaCk7XG4gICAgICAgIGFzc2VydCghIWJsb2NrLCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGFzc2VydCghIXR4LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQgZm90IHRoZSB0cmFuc2FjdGlvbiB0aGF0IHRoaXNcbiAgICAgKiAgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCgpIHtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhcmVjZWlwdCwgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvbiByZWNlaXB0XCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcih0aGlzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUcmFuc2FjdGlvbiBSZWNlaXB0XG4vKlxuZXhwb3J0IGludGVyZmFjZSBMZWdhY3lUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIGJ5emFudGl1bTogZmFsc2U7XG4gICAgc3RhdHVzOiBudWxsO1xuICAgIHJvb3Q6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCeXphbnRpdW1UcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIGJ5emFudGl1bTogdHJ1ZTtcbiAgICBzdGF0dXM6IG51bWJlcjtcbiAgICByb290OiBudWxsO1xufVxuKi9cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IGFcbiAqICB0cmFuc2FjdGlvbiB0aGF0IGlzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIGl0IGhhcyBiZWVuIG1pbmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3MgdGhlIHRyYW5zYWN0aW9uIHdhcyBzZW50IHRvLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBkaXJlY3RseVxuICAgICAqICByZXNwb25zaWJsZSBmb3IgZGVwbG95aW5nIG9uZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vbi1udWxsICoqb25seSoqIGlmIHRoZSBgYHRvYGAgaXMgZW1wdHkgYW5kIHRoZSBgYGRhdGFgYFxuICAgICAqICB3YXMgc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkIGFzIGluaXRjb2RlLlxuICAgICAqL1xuICAgIGNvbnRyYWN0QWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IG9mIHRoaXMgdHJhbnNhY3Rpb24gd2l0aGluIHRoZSBibG9jayB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9vbSBmaWx0ZXIgYnl0ZXMgdGhhdCByZXByZXNlbnQgYWxsIGxvZ3MgdGhhdCBvY2N1cnJlZCB3aXRoaW5cbiAgICAgKiAgdGhpcyB0cmFuc2FjdGlvbi4gVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCBmb3IgbW9zdCBkZXZlbG9wZXJzLFxuICAgICAqICBidXQgY2FuIGJlIHVzZWQgdG8gdmFsaWRhdGUgdGhlIGluY2x1ZGVkIGxvZ3MuXG4gICAgICovXG4gICAgbG9nc0Jsb29tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIGFtb3VudCBvZiBnYXMgdXNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFdoZW4gY3JlYXRpbmcgYSB0cmFuc2FjdGlvbiwgdGhlIGFtb3VudCBvZiBnYXMgdGhhdCB3aWxsIGJlIHVzZWQgY2FuXG4gICAgICogIG9ubHkgYmUgYXBwcm94aW1hdGVkLCBidXQgdGhlIHNlbmRlciBtdXN0IHBheSB0aGUgZ2FzIGZlZSBmb3IgdGhlXG4gICAgICogIGVudGlyZSBnYXMgbGltaXQuIEFmdGVyIHRoZSB0cmFuc2FjdGlvbiwgdGhlIGRpZmZlcmVuY2UgaXMgcmVmdW5kZWQuXG4gICAgICovXG4gICAgZ2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyB1c2VkIGZvciBCTE9icy4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IGFsbCB0cmFuc2FjdGlvbnMgd2l0aGluIHRoZSBibG9jayBmb3IgdGhpc1xuICAgICAqICBhbmQgYWxsIHRyYW5zYWN0aW9ucyB3aXRoIGEgbG93ZXIgYGBpbmRleGBgLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIGRldmVsb3BlcnMgYnV0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHZhbGlkYXRlIGNlcnRhaW4gYXNwZWN0cyBvZiBleGVjdXRpb24uXG4gICAgICovXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgZ2FzIHByaWNlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gdGhlIGNvbXBsZXhpdHkgb2YgW1tsaW5rLWVpcC0xNTU5XV0gdGhpcyB2YWx1ZSBjYW4gb25seVxuICAgICAqICBiZSBjYWx1Y2xhdGVkIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCwgc25jZSB0aGUgYmFzZVxuICAgICAqICBmZWUgaXMgcHJvdG9jb2wtZW5mb3JjZWQuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmljZSBwYWlkIHBlciBCTE9CIGluIGdhcy4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvL3JlYWRvbmx5IGJ5emFudGl1bSE6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogIFRoZSBzdGF0dXMgb2YgdGhpcyB0cmFuc2FjdGlvbiwgaW5kaWNhdGluZyBzdWNjZXNzIChpLmUuIGBgMWBgKSBvclxuICAgICAqICBhIHJldmVydCAoaS5lLiBgYDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBhdmFpbGFibGUgaW4gcG9zdC1ieXphbnRpdW0gYmxvY2tzLCBidXQgc29tZSBiYWNrZW5kcyBtYXlcbiAgICAgKiAgYmFja2ZpbGwgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0dXM7XG4gICAgLyoqXG4gICAgICogIFRoZSByb290IGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vIHByZXNlbnQgYW5kIHdhcyBvbmx5IGluY2x1ZGVkIGluIHByZS1ieXphbnRpdW0gYmxvY2tzLCBidXRcbiAgICAgKiAgY291bGQgYmUgdXNlZCB0byB2YWxpZGF0ZSBjZXJ0YWluIHBhcnRzIG9mIHRoZSByZWNlaXB0LlxuICAgICAqL1xuICAgIHJvb3Q7XG4gICAgI2xvZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNsb2dzID0gT2JqZWN0LmZyZWV6ZSh0eC5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgZ2FzUHJpY2UgPSBCTl8wO1xuICAgICAgICBpZiAodHguZWZmZWN0aXZlR2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5lZmZlY3RpdmVHYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBnYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICB0bzogdHgudG8sXG4gICAgICAgICAgICBmcm9tOiB0eC5mcm9tLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0eC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgaW5kZXg6IHR4LmluZGV4LFxuICAgICAgICAgICAgYmxvY2tIYXNoOiB0eC5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogdHguYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICBsb2dzQmxvb206IHR4LmxvZ3NCbG9vbSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHR4Lmdhc1VzZWQsXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogdHguY3VtdWxhdGl2ZUdhc1VzZWQsXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdHguYmxvYkdhc1VzZWQsXG4gICAgICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgICAgIGJsb2JHYXNQcmljZTogdHguYmxvYkdhc1ByaWNlLFxuICAgICAgICAgICAgdHlwZTogdHgudHlwZSxcbiAgICAgICAgICAgIC8vYnl6YW50aXVtOiB0eC5ieXphbnRpdW0sXG4gICAgICAgICAgICBzdGF0dXM6IHR4LnN0YXR1cyxcbiAgICAgICAgICAgIHJvb3Q6IHR4LnJvb3RcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbG9ncyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgbG9ncygpIHsgcmV0dXJuIHRoaXMuI2xvZ3M7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgdG8sIGZyb20sIGNvbnRyYWN0QWRkcmVzcywgaGFzaCwgaW5kZXgsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGxvZ3NCbG9vbSwgbG9ncywgLy9ieXphbnRpdW0sIFxuICAgICAgICBzdGF0dXMsIHJvb3QgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAvL2J5emFudGl1bSwgXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogdG9Kc29uKHRoaXMuY3VtdWxhdGl2ZUdhc1VzZWQpLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24odGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdG9Kc29uKHRoaXMuYmxvYkdhc1VzZWQpLFxuICAgICAgICAgICAgYmxvYkdhc1ByaWNlOiB0b0pzb24odGhpcy5ibG9iR2FzUHJpY2UpLFxuICAgICAgICAgICAgZ2FzVXNlZDogdG9Kc29uKHRoaXMuZ2FzVXNlZCksXG4gICAgICAgICAgICBoYXNoLCBpbmRleCwgbG9ncywgbG9nc0Jsb29tLCByb290LCBzdGF0dXMsIHRvXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5sb2dzLmxlbmd0aDsgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLmxvZ3NbaW5kZXgrK10sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBmZWUgZm9yIHRoaXMgdHJhbnNhY3Rpb24sIGluIHdlaS5cbiAgICAgKi9cbiAgICBnZXQgZmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYXNVc2VkICogdGhpcy5nYXNQcmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBibG9jayB0aGlzIHRyYW5zYWN0aW9uIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sodGhpcy5ibG9ja0hhc2gpO1xuICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRoaXMuaGFzaCk7XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGV4ZWN1dGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFN1cHBvcnQgZm9yIHRoaXMgZmVhdHVyZSBpcyBsaW1pdGVkLCBhcyBpdCByZXF1aXJlcyBhbiBhcmNoaXZlIG5vZGVcbiAgICAgKiAgd2l0aCB0aGUgYGBkZWJ1Z19gYCBvciBgYHRyYWNlX2BgIEFQSSBlbmFibGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlc3VsdCgpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVzdWx0KHRoaXMuaGFzaCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBjb25maXJtYXRpb25zIHRoaXMgdHJhbnNhY3Rpb24gaGFzLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbmZpcm1hdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpKSAtIHRoaXMuYmxvY2tOdW1iZXIgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgcmVvcmRlcmVkRXZlbnQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zY3Rpb24gY2Fubm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlb3JkZXJlZEV2ZW50KG90aGVyKVwiIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcywgb3RoZXIpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvblJlc3BvbnNlKiogaW5jbHVkZXMgYWxsIHByb3BlcnRpZXMgYWJvdXQgYSB0cmFuc2FjdGlvblxuICogIHRoYXQgd2FzIHNlbnQgdG8gdGhlIG5ldHdvcmssIHdoaWNoIG1heSBvciBtYXkgbm90IGJlIGluY2x1ZGVkIGluIGFcbiAqICBibG9jay5cbiAqXG4gKiAgVGhlIFtbVHJhbnNhY3Rpb25SZXNwb25zZS1pc01pbmVkXV0gY2FuIGJlIHVzZWQgdG8gY2hlY2sgaWYgdGhlXG4gKiAgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYXMgd2VsbCBhcyB0eXBlIGd1YXJkIHRoYXQgdGhlIG90aGVyd2lzZVxuICogIHBvc3NpYmx5IGBgbnVsbGBgIHByb3BlcnRpZXMgYXJlIGRlZmluZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgaXMgY29ubmVjdGVkIHRvLCB3aGljaCB3aWxsIGluZmx1ZW5jZSBob3cgaXRzXG4gICAgICogIG1ldGhvZHMgd2lsbCByZXNvbHZlIGl0cyBhc3luYyBpbnNwZWN0aW9uIG1ldGhvZHMuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9ja0hhc2ggb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gcmVzaWRlcyBhdC5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIGVudmVsb3BlIHR5cGUuIFRoaXMgaXNcbiAgICAgKiAgYGAwYGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMgdHlwZXMuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY2VpdmVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgSWYgYGBudWxsYGAsIHRoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIGFuIGluaXRjb2RlIHRyYW5zYWN0aW9uLlxuICAgICAqICBUaGlzIG1lYW5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSBbW2RhdGFdXSB3aWxsIGJlIGRlcGxveWVkXG4gICAgICogIGFzIGEgbmV3IGNvbnRyYWN0IG9uIGNoYWluIChhc3N1bWluZyBpdCBkb2VzIG5vdCByZXZlcnQpIGFuZCB0aGVcbiAgICAgKiAgYWRkcmVzcyBtYXkgYmUgY29tcHV0ZWQgdXNpbmcgW1tnZXRDcmVhdGVBZGRyZXNzXV0uXG4gICAgICovXG4gICAgdG87XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi4gSXQgaXMgaW1wbGljaXRseSBjb21wdXRlZFxuICAgICAqICBmcm9tIHRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UgaGFzaCAoYXMgdGhlIGRpZ2VzdCkgYW5kIHRoZVxuICAgICAqICBbW3NpZ25hdHVyZV1dIHVzaW5nIGVjcmVjb3Zlci5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UsIHdoaWNoIGlzIHVzZWQgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcyBhbmQgb2ZmZXJcbiAgICAgKiAgYSBtZXRob2QgdG8gZW5zdXJlIHRyYW5zYWN0aW9ucyBmcm9tIGEgZ2l2ZW4gc2VuZGVyIGFyZSBleHBsaWNpdGx5XG4gICAgICogIG9yZGVyZWQuXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZW5kaW5nIGEgdHJhbnNhY3Rpb24sIHRoaXMgbXVzdCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICogIHRyYW5zYWN0aW9ucyBldmVyIHNlbnQgYnkgW1tmcm9tXV0uXG4gICAgICovXG4gICAgbm9uY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHVuaXRzIG9mIGdhcyB0aGlzIHRyYW5zYWN0aW9uIGNhbiBjb25zdW1lLiBJZiBleGVjdXRpb25cbiAgICAgKiAgZXhjZWVkcyB0aGlzLCB0aGUgZW50cmllcyB0cmFuc2FjdGlvbiBpcyByZXZlcnRlZCBhbmQgdGhlIHNlbmRlclxuICAgICAqICBpcyBjaGFyZ2VkIGZvciB0aGUgZnVsbCBhbW91bnQsIGRlc3BpdGUgbm90IHN0YXRlIGNoYW5nZXMgYmVpbmcgbWFkZS5cbiAgICAgKi9cbiAgICBnYXNMaW1pdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBjYW4gaGF2ZSB2YXJpb3VzIHZhbHVlcywgZGVwZW5kaW5nIG9uIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogIEluIG1vZGVybiBuZXR3b3JrcywgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBpbmNsdWRlZCB0aGlzIGlzXG4gICAgICogIHRoZSAvL2VmZmVjdGl2ZSBnYXMgcHJpY2UvLyAodGhlIGZlZSBwZXIgZ2FzIHRoYXQgd2FzIGFjdHVhbGx5XG4gICAgICogIGNoYXJnZWQpLCB3aGlsZSBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgaGF2ZSBub3QgYmVlbiBpbmNsdWRlZCB5ZXRcbiAgICAgKiAgaXMgdGhlIFtbbWF4RmVlUGVyR2FzXV0uXG4gICAgICpcbiAgICAgKiAgRm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIG9yIHRyYW5zYWN0aW9ucyBvbiBsZWdhY3kgbmV0d29ya3MsIHRoaXNcbiAgICAgKiAgaXMgdGhlIGZlZSB0aGF0IHdpbGwgYmUgY2hhcmdlZCBwZXIgdW5pdCBvZiBnYXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogIGNvbnN1bWVzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBwcmlvcml0eSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgYVxuICAgICAqICB2YWxpZGF0b3IgdG8gY2hhcmdlIHRoZSBzZW5kZXIuIFRoaXMgaXMgaW5jbHVzaXZlIG9mIHRoZVxuICAgICAqICBbW21heEZlZUZlZVBlckdhc11dLlxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgdGhpcyB0cmFuc2FjdGlvblxuICAgICAqICB0byBjaGFyZ2UgdGhlIHNlbmRlci5cbiAgICAgKi9cbiAgICBtYXhGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBtYXggZmVlIHBlciBCTE9iIGdhcy5cbiAgICAgKi9cbiAgICBtYXhGZWVQZXJCbG9iR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUsIGluIHdlaS4gVXNlIFtbZm9ybWF0RXRoZXJdXSB0byBmb3JtYXQgdGhpcyB2YWx1ZVxuICAgICAqICBhcyBldGhlci5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElELlxuICAgICAqL1xuICAgIGNoYWluSWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QgZm9yIHRyYW5zYWN0aW9uIHR5cGVzIHRoYXRcbiAgICAgKiAgc3VwcG9ydCBpdCwgb3RoZXJ3aXNlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFjY2Vzc0xpc3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBCTE9iIHZlcnNpb25lZCBoYXNoZXMuXG4gICAgICovXG4gICAgYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtNzcwMl1dIGF1dGhvcml6YXRpb25zIChpZiBhbnkpLlxuICAgICAqL1xuICAgIGF1dGhvcml6YXRpb25MaXN0O1xuICAgICNzdGFydEJsb2NrO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLmJsb2NrTnVtYmVyID0gKHR4LmJsb2NrTnVtYmVyICE9IG51bGwpID8gdHguYmxvY2tOdW1iZXIgOiBudWxsO1xuICAgICAgICB0aGlzLmJsb2NrSGFzaCA9ICh0eC5ibG9ja0hhc2ggIT0gbnVsbCkgPyB0eC5ibG9ja0hhc2ggOiBudWxsO1xuICAgICAgICB0aGlzLmhhc2ggPSB0eC5oYXNoO1xuICAgICAgICB0aGlzLmluZGV4ID0gdHguaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IHR4LnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IHR4LmZyb207XG4gICAgICAgIHRoaXMudG8gPSB0eC50byB8fCBudWxsO1xuICAgICAgICB0aGlzLmdhc0xpbWl0ID0gdHguZ2FzTGltaXQ7XG4gICAgICAgIHRoaXMubm9uY2UgPSB0eC5ub25jZTtcbiAgICAgICAgdGhpcy5kYXRhID0gdHguZGF0YTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHR4LnZhbHVlO1xuICAgICAgICB0aGlzLmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA6IG51bGw7XG4gICAgICAgIHRoaXMubWF4RmVlUGVyR2FzID0gKHR4Lm1heEZlZVBlckdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckdhcyA6IG51bGw7XG4gICAgICAgIHRoaXMubWF4RmVlUGVyQmxvYkdhcyA9ICh0eC5tYXhGZWVQZXJCbG9iR2FzICE9IG51bGwpID8gdHgubWF4RmVlUGVyQmxvYkdhcyA6IG51bGw7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlID0gdHguc2lnbmF0dXJlO1xuICAgICAgICB0aGlzLmFjY2Vzc0xpc3QgPSAodHguYWNjZXNzTGlzdCAhPSBudWxsKSA/IHR4LmFjY2Vzc0xpc3QgOiBudWxsO1xuICAgICAgICB0aGlzLmJsb2JWZXJzaW9uZWRIYXNoZXMgPSAodHguYmxvYlZlcnNpb25lZEhhc2hlcyAhPSBudWxsKSA/IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgOiBudWxsO1xuICAgICAgICB0aGlzLmF1dGhvcml6YXRpb25MaXN0ID0gKHR4LmF1dGhvcml6YXRpb25MaXN0ICE9IG51bGwpID8gdHguYXV0aG9yaXphdGlvbkxpc3QgOiBudWxsO1xuICAgICAgICB0aGlzLiNzdGFydEJsb2NrID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBibG9ja0hhc2gsIGluZGV4LCBoYXNoLCB0eXBlLCB0bywgZnJvbSwgbm9uY2UsIGRhdGEsIHNpZ25hdHVyZSwgYWNjZXNzTGlzdCwgYmxvYlZlcnNpb25lZEhhc2hlcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIlRyYW5zYWN0aW9uUmVzcG9uc2VcIixcbiAgICAgICAgICAgIGFjY2Vzc0xpc3QsIGJsb2NrTnVtYmVyLCBibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzLFxuICAgICAgICAgICAgY2hhaW5JZDogdG9Kc29uKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBkYXRhLCBmcm9tLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbih0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24odGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRvSnNvbih0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heEZlZVBlckJsb2JHYXM6IHRvSnNvbih0aGlzLm1heEZlZVBlckJsb2JHYXMpLFxuICAgICAgICAgICAgbm9uY2UsIHNpZ25hdHVyZSwgdG8sIGluZGV4LCB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHRvSnNvbih0aGlzLnZhbHVlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBCbG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIGluY2x1ZGVkIHlldC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gdGhpcy5ibG9ja051bWJlcjtcbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHR4KSB7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB0eC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhpcyB0cmFuc2FjdGlvbiBiZWluZyByZS1yZXF1ZXN0ZWQgZnJvbSB0aGVcbiAgICAgKiAgcHJvdmlkZXIuIFRoaXMgY2FuIGJlIHVzZWQgaWYgeW91IGhhdmUgYW4gdW5taW5lZCB0cmFuc2FjdGlvblxuICAgICAqICBhbmQgd2lzaCB0byBnZXQgYW4gdXAtdG8tZGF0ZSBwb3B1bGF0ZWQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRoaXMuaGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR4LCBibG9ja051bWJlciB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIHR4OiB0aGlzLmdldFRyYW5zYWN0aW9uKCksXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBOb3QgbWluZWQgeWV0Li4uXG4gICAgICAgICAgICBpZiAodHggPT0gbnVsbCB8fCB0eC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0eC5ibG9ja051bWJlciArIDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBibG9ja051bWJlciAtIHRoaXMuYmxvY2tOdW1iZXIgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgb25jZSB0aGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFuZCBoYXNcbiAgICAgKiAgJSVjb25maXJtcyUlIGJsb2NrcyBpbmNsdWRpbmcgaXQgKGRlZmF1bHQ6IGBgMWBgKSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUldGltZW91dCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIHJlc29sdmUgdG8gYGBudWxsYGAgb25seSBpZiAlJWNvbmZpcm1zJSUgaXMgYGAwYGBcbiAgICAgKiAgYW5kIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQsIG90aGVyd2lzZSB0aGlzIHdpbGxcbiAgICAgKiAgd2FpdCB1bnRpbCBlbm91Z2ggY29uZmlybWF0aW9ucyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KF9jb25maXJtcywgX3RpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgY29uZmlybXMgPSAoX2NvbmZpcm1zID09IG51bGwpID8gMSA6IF9jb25maXJtcztcbiAgICAgICAgY29uc3QgdGltZW91dCA9IChfdGltZW91dCA9PSBudWxsKSA/IDAgOiBfdGltZW91dDtcbiAgICAgICAgbGV0IHN0YXJ0QmxvY2sgPSB0aGlzLiNzdGFydEJsb2NrO1xuICAgICAgICBsZXQgbmV4dFNjYW4gPSAtMTtcbiAgICAgICAgbGV0IHN0b3BTY2FubmluZyA9IChzdGFydEJsb2NrID09PSAtMSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGNoZWNrUmVwbGFjZW1lbnQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gY291bnQgZm9yIHRoaXMgc2VuZGVyXG4gICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBub25jZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgbm9uY2U6IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLmZyb20pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5vIHRyYW5zYWN0aW9uIG9yIG91ciBub25jZSBoYXMgbm90IGJlZW4gbWluZWQgeWV0OyBidXQgd2VcbiAgICAgICAgICAgIC8vIGNhbiBzdGFydCBzY2FubmluZyBsYXRlciB3aGVuIHdlIGRvIHN0YXJ0XG4gICAgICAgICAgICBpZiAobm9uY2UgPCB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRCbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtaW5lZCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChtaW5lZCAmJiBtaW5lZC5ibG9ja051bWJlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugd2VyZSByZXBsYWNlZDsgc3RhcnQgc2Nhbm5pbmcgZm9yIHRoYXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFN0YXJ0aW5nIHRvIHNjYW47IGxvb2sgYmFjayBhIGZldyBleHRyYSBibG9ja3MgZm9yIHNhZmV0eVxuICAgICAgICAgICAgaWYgKG5leHRTY2FuID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG5leHRTY2FuID0gc3RhcnRCbG9jayAtIDM7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTY2FuIDwgdGhpcy4jc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHRoaXMuI3N0YXJ0QmxvY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG5leHRTY2FuIDw9IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGJsb2NrIHRvIHNjYW5cbiAgICAgICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sobmV4dFNjYW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhhc2ggb2YgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2ggPT09IHRoaXMuaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRoYXQgcmVwbGFjZWQgdXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgYmxvY2suZ2V0VHJhbnNhY3Rpb24oaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5mcm9tID09PSB0aGlzLmZyb20gJiYgdHgubm9uY2UgPT09IHRoaXMubm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4Lmhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbjsgYnV0IHdlJ2xsIHRyeSBhZ2FpbiBzaG9ydGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCByZXRyeSB0aGlzIG9uIHRoZSBuZXh0IGJsb2NrICh0aGlzIGNhc2UgY291bGQgYmUgb3B0aW1pemVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxKSA8IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiB3ZSB3ZXJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhc29uID0gXCJyZXBsYWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEgPT09IHRoaXMuZGF0YSAmJiB0eC50byA9PT0gdGhpcy50byAmJiB0eC52YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwicmVwcmljZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmRhdGEgPT09IFwiMHhcIiAmJiB0eC5mcm9tID09PSB0eC50byAmJiB0eC52YWx1ZSA9PT0gQk5fMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkXCIsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZDogKHJlYXNvbiA9PT0gXCJyZXBsYWNlZFwiIHx8IHJlYXNvbiA9PT0gXCJjYW5jZWxsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50OiB0eC5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKHN0YXJ0QmxvY2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFNjYW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hlY2tSZWNlaXB0ID0gKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgfHwgcmVjZWlwdC5zdGF0dXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJ0cmFuc2FjdGlvbiBleGVjdXRpb24gcmV2ZXJ0ZWRcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsIHJlYXNvbjogbnVsbCwgaW52b2NhdGlvbjogbnVsbCwgcmV2ZXJ0OiBudWxsLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiByZWNlaXB0LnRvLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiByZWNlaXB0LmZyb20sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIgLy8gQFRPRE86IGluIHY3LCBzcGxpdCBvdXQgc2VuZFRyYW5zYWN0aW9uIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICB9LCByZWNlaXB0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuaGFzaCk7XG4gICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjZWlwdCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09PSAxIHx8IChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tSZWNlaXB0KHJlY2VpcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRocm93cyBpZiBhIHJlcGxhY2VtZW50IHdhcyBmb3VuZFxuICAgICAgICAgICAgYXdhaXQgY2hlY2tSZXBsYWNlbWVudCgpO1xuICAgICAgICAgICAgLy8gQWxsb3cgbnVsbCBvbmx5IHdoZW4gdGhlIGNvbmZpcm1zIGlzIDBcbiAgICAgICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhaXRlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIExpc3Qgb2YgdGhpbmdzIHRvIGNhbmNlbCB3aGVuIHdlIGhhdmUgYSByZXN1bHQgKG9uZSB3YXkgb3IgdGhlIG90aGVyKVxuICAgICAgICAgICAgY29uc3QgY2FuY2VsbGVycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4geyBjYW5jZWxsZXJzLmZvckVhY2goKGMpID0+IGMoKSk7IH07XG4gICAgICAgICAgICAvLyBPbiBjYW5jZWwsIHN0b3Agc2Nhbm5pbmcgZm9yIHJlcGxhY2VtZW50c1xuICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgc3RvcFNjYW5uaW5nID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgYW55IHRpbWVvdXQgcmVxdWVzdGVkXG4gICAgICAgICAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcIndhaXQgZm9yIHRyYW5zYWN0aW9uIHRpbWVvdXRcIiwgXCJUSU1FT1VUXCIpKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyBjbGVhclRpbWVvdXQodGltZXIpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4TGlzdGVuZXIgPSBhc3luYyAocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIERvbmU7IHJldHVybiBpdCFcbiAgICAgICAgICAgICAgICBpZiAoKGF3YWl0IHJlY2VpcHQuY29uZmlybWF0aW9ucygpKSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY2hlY2tSZWNlaXB0KHJlY2VpcHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgdGhpcy5wcm92aWRlci5vZmYodGhpcy5oYXNoLCB0eExpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBXZSBzdXBwb3J0IHJlcGxhY2VtZW50IGRldGVjdGlvbjsgc3RhcnQgY2hlY2tpbmdcbiAgICAgICAgICAgIGlmIChzdGFydEJsb2NrID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTGlzdGVuZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSByZXBsYWNlbWVudDsgdGhpcyB0aHJvd3Mgb25seSBpZiBvbmUgaXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQgKHdpdGggZW5vdWdoIGNvbmZpcm1zKTsgcmUtdGhyb3cgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2NoZXVkbGUgYSBjaGVjayBvbiB0aGUgbmV4dCBibG9ja1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgdGhpcy5wcm92aWRlci5vZmYoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHdhaXRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGVmZmVjdGl2ZSBvbmx5IGFzIG9mIHRoZSB0aW1lIHRoZSBUcmFuc2FjdGlvblJlc3BvbnNlXG4gICAgICogIHdhcyBpbnN0YW50aWF0ZWQuIFRvIGdldCB1cC10by1kYXRlIGluZm9ybWF0aW9uLCB1c2VcbiAgICAgKiAgW1tnZXRUcmFuc2FjdGlvbl1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgbm9uLW51bGwgcHJvcGVydHkgdmFsdWVzIGZvciBwcm9wZXJ0aWVzIHRoYXQgYXJlIG51bGwgZm9yXG4gICAgICogIHVubWluZWQgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGlzTWluZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ibG9ja0hhc2ggIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgbGVnYWN5IChpLmUuIGBgdHlwZSA9PSAwYGApXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0xlZ2FjeSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIEJlcmxpbiAoaS5lLiBgYHR5cGUgPT0gMWBgKVxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtMjA3MF1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0JlcmxpbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIExvbmRvbiAoaS5lLiBgYHR5cGUgPT0gMmBgKVxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtMTU1OV1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0xvbmRvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIGh0ZSB0cmFuc2FjdGlvbiBpcyBhIENhbmN1biAoaS5lLiBgYHR5cGUgPT0gM2BgKVxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGlzQ2FuY3VuKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmlsdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3Igb3JwaGFuIGV2ZW50c1xuICAgICAqICB0aGF0IGV2aWN0IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICBhc3NlcnQodGhpcy5pc01pbmVkKCksIFwidW5taW5lZCB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmlsdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3Igb3JwaGFuIGV2ZW50c1xuICAgICAqICB0aGF0IHJlLW9yZGVyIHRoaXMgZXZlbnQgYWdhaW5zdCAlJW90aGVyJSUuXG4gICAgICovXG4gICAgcmVvcmRlcmVkRXZlbnQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICBhc3NlcnQoIW90aGVyIHx8IG90aGVyLmlzTWluZWQoKSwgXCJ1bm1pbmVkICdvdGhlcicgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcywgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlIGluc3RhbmNlIHdoaWNoIGhhcyB0aGUgYWJpbGl0eSB0b1xuICAgICAqICBkZXRlY3QgKGFuZCB0aHJvdyBhbiBlcnJvcikgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIHJlcGxhY2VkLCB3aGljaFxuICAgICAqICB3aWxsIGJlZ2luIHNjYW5uaW5nIGF0ICUlc3RhcnRCbG9jayUlLlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgdXNlZCBieSBkZXZlbG9wZXJzIGFuZCBpcyBpbnRlbmRlZFxuICAgICAqICBwcmltYXJpbHkgZm9yIGludGVybmFsIHVzZS4gU2V0dGluZyBhbiBpbmNvcnJlY3QgJSVzdGFydEJsb2NrJSUgY2FuXG4gICAgICogIGhhdmUgZGV2YXN0YXRpbmcgcGVyZm9ybWFuY2UgY29uc2VxdWVuY2VzIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICovXG4gICAgcmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIoc3RhcnRCbG9jaykgJiYgc3RhcnRCbG9jayA+PSAwLCBcImludmFsaWQgc3RhcnRCbG9ja1wiLCBcInN0YXJ0QmxvY2tcIiwgc3RhcnRCbG9jayk7XG4gICAgICAgIGNvbnN0IHR4ID0gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UodGhpcywgdGhpcy5wcm92aWRlcik7XG4gICAgICAgIHR4LiNzdGFydEJsb2NrID0gc3RhcnRCbG9jaztcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIoYmxvY2spIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1ibG9ja1wiLCBoYXNoOiBibG9jay5oYXNoLCBudW1iZXI6IGJsb2NrLm51bWJlciB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgsIG90aGVyKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcInJlb3JkZXItdHJhbnNhY3Rpb25cIiwgdHgsIG90aGVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC10cmFuc2FjdGlvblwiLCB0eCB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcihsb2cpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIHRvcGljczogT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleFxuICAgICAgICB9IH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci5qcy5tYXAiLCIvLyBpbXBvcnQgZnJvbSBwcm92aWRlci50cyBpbnN0ZWFkIG9mIGluZGV4LnRzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXG5pbXBvcnQgeyBMb2csIFRyYW5zYWN0aW9uUmVjZWlwdCwgVHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIEV2ZW50UGF5bG9hZCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50TG9nIGV4dGVuZHMgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBldmVudC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcnNlZCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBldmVudCBieSBgYGVtaXRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgaWZhY2UsIGZyYWdtZW50KSB7XG4gICAgICAgIHN1cGVyKGxvZywgbG9nLnByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGlmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhcmdzLCBmcmFnbWVudCwgaW50ZXJmYWNlOiBpZmFjZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBldmVudFNpZ25hdHVyZSgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7IH1cbn1cbi8qKlxuICogIEFuICoqRXZlbnRMb2cqKiBjb250YWlucyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgcGFyc2VkIGZyb20gdGhlIFtbTG9nXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBVbmRlY29kZWRFdmVudExvZyBleHRlbmRzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBlcnJvciBlbmNvdW50ZWQgd2hlbiB0cnlpbmcgdG8gZGVjb2RlIHRoZSBsb2cuXG4gICAgICovXG4gICAgZXJyb3I7XG4gICAgLyoqXG4gICAgICogQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBlcnJvcikge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBlcnJvciB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyB0aGUgcGFyc2VkIGxvZ3MgZnJvbSBhXG4gKiAgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0IGV4dGVuZHMgVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgbG9ncyBmb3IgYW55IFtbTG9nXV0gd2hpY2ggaGFzIGEgbWF0Y2hpbmcgZXZlbnQgaW4gdGhlXG4gICAgICogIENvbnRyYWN0IEFCSS5cbiAgICAgKi9cbiAgICBnZXQgbG9ncygpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxvZ3MubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbG9nLnRvcGljcy5sZW5ndGggPyB0aGlzLiNpZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50TG9nKGxvZywgdGhpcy4jaWZhY2UsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSoqIHdpbGwgcmV0dXJuIGFcbiAqICBbW0NvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0XV0gd2hlbiB3YWl0ZWQgb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgZXh0ZW5kcyBUcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChjb25maXJtcywgdGltZW91dCkge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgc3VwZXIud2FpdChjb25maXJtcywgdGltZW91dCk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaWZhY2UsIHRoaXMucHJvdmlkZXIsIHJlY2VpcHQpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFVua25vd25FdmVudFBheWxvYWQqKiBpcyBpbmNsdWRlZCBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG9cbiAqICBDb250cmFjdCBFdmVudHMgd2hlbiB0aGUgZXZlbnQgZG9lcyBub3QgbWF0Y2ggYW55IGV2ZW50cyBpbiB0aGUgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIGV4dGVuZHMgRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZyB3aXRoIG5vIG1hdGNoaW5nIGV2ZW50cy5cbiAgICAgKi9cbiAgICBsb2c7XG4gICAgLyoqXG4gICAgICogIEBfZXZlbnQ6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGxvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBsb2cgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhlIGV2ZW50IG9jY3VyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRCbG9jaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uUmVjZWlwdCgpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdEV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xuICogIENvbnRyYWN0IEV2ZW50cyB3aGVuIHRoZSBldmVudCBpcyBrbm93bi5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0RXZlbnRQYXlsb2FkIGV4dGVuZHMgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGZyYWdtZW50LCBfbG9nKSB7XG4gICAgICAgIHN1cGVyKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBuZXcgRXZlbnRMb2coX2xvZywgY29udHJhY3QuaW50ZXJmYWNlLCBmcmFnbWVudCkpO1xuICAgICAgICBjb25zdCBhcmdzID0gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCB0aGlzLmxvZy5kYXRhLCB0aGlzLmxvZy50b3BpY3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXJncywgZnJhZ21lbnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXBwZXJzLmpzLm1hcCIsImltcG9ydCB7IEludGVyZmFjZSwgVHlwZWQgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpc0FkZHJlc3NhYmxlLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG4vLyBpbXBvcnQgZnJvbSBwcm92aWRlci50cyBpbnN0ZWFkIG9mIGluZGV4LnRzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXG5pbXBvcnQgeyBjb3B5UmVxdWVzdCwgTG9nIH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBpc0NhbGxFeGNlcHRpb24sIGlzSGV4U3RyaW5nLCByZXNvbHZlUHJvcGVydGllcywgaXNFcnJvciwgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdEV2ZW50UGF5bG9hZCwgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkLCBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UsIEV2ZW50TG9nLCBVbmRlY29kZWRFdmVudExvZyB9IGZyb20gXCIuL3dyYXBwZXJzLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuZnVuY3Rpb24gY2FuQ2FsbCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5jYWxsKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhbkVzdGltYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmVzdGltYXRlR2FzKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhblJlc29sdmUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUucmVzb2x2ZU5hbWUpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuU2VuZCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5zZW5kVHJhbnNhY3Rpb24pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY2FuUmVzb2x2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wcm92aWRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY2xhc3MgUHJlcGFyZWRUb3BpY0ZpbHRlciB7XG4gICAgI2ZpbHRlcjtcbiAgICBmcmFnbWVudDtcbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZyYWdtZW50IH0pO1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChmcmFnbWVudC5pbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS53YWxrQXN5bmMoYXJnc1tpbmRleF0sICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh2YWx1ZS5tYXAoKHYpID0+IHJlc29sdmVBZGRyZXNzKHYsIHJlc29sdmVyKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKHZhbHVlLCByZXNvbHZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGaWx0ZXJUb3BpY3MoZnJhZ21lbnQsIHJlc29sdmVkQXJncyk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGdldFRvcGljRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmlsdGVyO1xuICAgIH1cbn1cbi8vIEEgPSBBcmd1bWVudHMgcGFzc2VkIGluIGFzIGEgdHVwbGVcbi8vIFIgPSBUaGUgcmVzdWx0IHR5cGUgb2YgdGhlIGNhbGwgKGkuZS4gaWYgb25seSBvbmUgcmV0dXJuIHR5cGUsXG4vLyAgICAgdGhlIHF1YWxpZmllZCB0eXBlLCBvdGhlcndpc2UgUmVzdWx0KVxuLy8gRCA9IFRoZSB0eXBlIHRoZSBkZWZhdWx0IGNhbGwgd2lsbCByZXR1cm4gKGkuZS4gUiBmb3Igdmlldy9wdXJlLFxuLy8gICAgIFRyYW5zYWN0aW9uUmVzcG9uc2Ugb3RoZXJ3aXNlKVxuLy9leHBvcnQgaW50ZXJmYWNlIENvbnRyYWN0TWV0aG9kPEEgZXh0ZW5kcyBBcnJheTxhbnk+ID0gQXJyYXk8YW55PiwgUiA9IGFueSwgRCBleHRlbmRzIFIgfCBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2U+IHtcbmZ1bmN0aW9uIGdldFJ1bm5lcih2YWx1ZSwgZmVhdHVyZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZVtmZWF0dXJlXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5wcm92aWRlciAmJiB0eXBlb2YgKHZhbHVlLnByb3ZpZGVyW2ZlYXR1cmVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm92aWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRQcm92aWRlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucHJvdmlkZXIgfHwgbnVsbDtcbn1cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29weU92ZXJyaWRlcyhhcmcsIGFsbG93ZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG92ZXJyaWRlcyBwYXNzZWQgaW4gYXJlIGEgdmFsaWQgb3ZlcnJpZGVzIG9iamVjdFxuICAgIGNvbnN0IF9vdmVycmlkZXMgPSBUeXBlZC5kZXJlZmVyZW5jZShhcmcsIFwib3ZlcnJpZGVzXCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoX292ZXJyaWRlcykgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBvdmVycmlkZXMgcGFyYW1ldGVyXCIsIFwib3ZlcnJpZGVzXCIsIGFyZyk7XG4gICAgLy8gQ3JlYXRlIGEgc2hhbGxvdyBjb3B5ICh3ZSdsbCBkZWVwLWlmeSBhbnl0aGluZyBuZWVkZWQgZHVyaW5nIG5vcm1hbGl6aW5nKVxuICAgIGNvbnN0IG92ZXJyaWRlcyA9IGNvcHlSZXF1ZXN0KF9vdmVycmlkZXMpO1xuICAgIGFzc2VydEFyZ3VtZW50KG92ZXJyaWRlcy50byA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwidG9cIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgdG9cIiwgXCJvdmVycmlkZXMudG9cIiwgb3ZlcnJpZGVzLnRvKTtcbiAgICBhc3NlcnRBcmd1bWVudChvdmVycmlkZXMuZGF0YSA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwiZGF0YVwiKSA+PSAwLCBcImNhbm5vdCBvdmVycmlkZSBkYXRhXCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgb3ZlcnJpZGVzLmRhdGEpO1xuICAgIC8vIFJlc29sdmUgYW55IGZyb21cbiAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSBvdmVycmlkZXMuZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJyaWRlcztcbn1cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUFyZ3MoX3J1bm5lciwgaW5wdXRzLCBhcmdzKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xuICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihfcnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgIGNvbnN0IHJlc29sdmVyID0gY2FuUmVzb2x2ZShydW5uZXIpID8gcnVubmVyIDogbnVsbDtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBwYXJhbS53YWxrQXN5bmMoYXJnc1tpbmRleF0sICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3ModmFsdWUsIHJlc29sdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRmFsbGJhY2soY29udHJhY3QpIHtcbiAgICBjb25zdCBwb3B1bGF0ZVRyYW5zYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICAvLyBJZiBhbiBvdmVycmlkZXMgd2FzIHBhc3NlZCBpbiwgY29weSBpdCBhbmQgbm9ybWFsaXplIHRoZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgdHggPSAoYXdhaXQgY29weU92ZXJyaWRlcyhvdmVycmlkZXMsIFtcImRhdGFcIl0pKTtcbiAgICAgICAgdHgudG8gPSBhd2FpdCBjb250cmFjdC5nZXRBZGRyZXNzKCk7XG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHguZnJvbSwgZ2V0UmVzb2x2ZXIoY29udHJhY3QucnVubmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWZhY2UgPSBjb250cmFjdC5pbnRlcmZhY2U7XG4gICAgICAgIGNvbnN0IG5vVmFsdWUgPSAoZ2V0QmlnSW50KCh0eC52YWx1ZSB8fCBCTl8wKSwgXCJvdmVycmlkZXMudmFsdWVcIikgPT09IEJOXzApO1xuICAgICAgICBjb25zdCBub0RhdGEgPSAoKHR4LmRhdGEgfHwgXCIweFwiKSA9PT0gXCIweFwiKTtcbiAgICAgICAgaWYgKGlmYWNlLmZhbGxiYWNrICYmICFpZmFjZS5mYWxsYmFjay5wYXlhYmxlICYmIGlmYWNlLnJlY2VpdmUgJiYgIW5vRGF0YSAmJiAhbm9WYWx1ZSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlIG9yIHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXNcIiwgb3ZlcnJpZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChpZmFjZS5mYWxsYmFjayB8fCBub0RhdGEsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlLW9ubHkgY29udHJhY3RcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCB0eC5kYXRhKTtcbiAgICAgICAgLy8gT25seSBhbGxvdyBwYXlhYmxlIGNvbnRyYWN0cyB0byBzZXQgbm9uLXplcm8gdmFsdWVcbiAgICAgICAgY29uc3QgcGF5YWJsZSA9IGlmYWNlLnJlY2VpdmUgfHwgKGlmYWNlLmZhbGxiYWNrICYmIGlmYWNlLmZhbGxiYWNrLnBheWFibGUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwYXlhYmxlIHx8IG5vVmFsdWUsIFwiY2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXMudmFsdWVcIiwgdHgudmFsdWUpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IGZhbGxiYWNrIGNvbnRyYWN0cyB0byBzZXQgbm9uLWVtcHR5IGRhdGFcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkNhbGwocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImNhbGxcIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmNhbGwodHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgYXNzZXJ0KGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcbiAgICB9O1xuICAgIGNvbnN0IGVzdGltYXRlR2FzID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICBhc3NlcnQoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmVzdGltYXRlR2FzKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAob3ZlcnJpZGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kKG92ZXJyaWRlcyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LFxuICAgICAgICBlc3RpbWF0ZUdhcyxcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbFxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRNZXRob2QoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb24oa2V5LCBhcmdzKTtcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSA9PT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IGF3YWl0IGNvcHlPdmVycmlkZXMoYXJncy5wb3AoKSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKG92ZXJyaWRlcy5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsIGVycm9yOiBmcmFnbWVudCBpbnB1dHMgZG9lc24ndCBtYXRjaCBhcmd1bWVudHM7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0IHJlc29sdmVBcmdzKGNvbnRyYWN0LnJ1bm5lciwgZnJhZ21lbnQuaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcywgYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdG86IGNvbnRyYWN0LmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgIGRhdGE6IGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHJlc29sdmVkQXJncylcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQ2FsbCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0YXRpY0NhbGxSZXN1bHQoLi4uYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBjb25zdCBzZW5kID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gY29udHJhY3QucnVubmVyO1xuICAgICAgICBhc3NlcnQoY2FuU2VuZChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHJ1bm5lci5zZW5kVHJhbnNhY3Rpb24oYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcbiAgICB9O1xuICAgIGNvbnN0IGVzdGltYXRlR2FzID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJlc3RpbWF0ZUdhc1wiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGxSZXN1bHQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgIGFzc2VydChjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250cmFjdC5pbnRlcmZhY2UubWFrZUVycm9yKGVycm9yLmRhdGEsIHR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZnJhZ21lbnQuY29uc3RhbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBzdGF0aWNDYWxsKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kKC4uLmFyZ3MpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcbiAgICAgICAgbmFtZTogY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uTmFtZShrZXkpLFxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXG4gICAgICAgIGdldEZyYWdtZW50LFxuICAgICAgICBlc3RpbWF0ZUdhcyxcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbCwgc3RhdGljQ2FsbFJlc3VsdCxcbiAgICB9KTtcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXkpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRFdmVudChjb250cmFjdCwga2V5KSB7XG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChrZXksIGFyZ3MpO1xuICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICBpbmZvOiB7IGtleSwgYXJncyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByZXBhcmVkVG9waWNGaWx0ZXIoY29udHJhY3QsIGdldEZyYWdtZW50KC4uLmFyZ3MpLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudE5hbWUoa2V5KSxcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxuICAgICAgICBnZXRGcmFnbWVudFxuICAgIH0pO1xuICAgIC8vIE9ubHkgd29ya3Mgb24gbm9uLWFtYmlndW91cyBrZXlzIChyZWZpbmVkIGZyYWdtZW50IGlzIGFsd2F5cyBub24tYW1iaWd1b3VzKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGtleSk7XG4gICAgICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsga2V5IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbi8vIFRoZSBjb21iaW5hdGlvbiBvZiBUeXBlU2NyeXBlLCBQcml2YXRlIEZpZWxkcyBhbmQgUHJveGllcyBtYWtlc1xuLy8gdGhlIHdvcmxkIGdvIGJvb207IHNvIHdlIGhpZGUgdmFyaWFibGVzIHdpdGggc29tZSB0cmlja2VyeSBrZWVwaW5nXG4vLyBhIHN5bWJvbCBhdHRhY2hlZCB0byBlYWNoIEJhc2VDb250cmFjdCB3aGljaCBpdHMgc3ViLWNsYXNzIChldmVuXG4vLyB2aWEgYSBQcm94eSkgY2FuIHJlYWNoIGFuZCB1c2UgdG8gbG9vayB1cCBpdHMgaW50ZXJuYWwgdmFsdWVzLlxuY29uc3QgaW50ZXJuYWwgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc0ludGVybmFsX2NvbnRyYWN0XCIpO1xuY29uc3QgaW50ZXJuYWxWYWx1ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0SW50ZXJuYWwoY29udHJhY3QsIHZhbHVlcykge1xuICAgIGludGVybmFsVmFsdWVzLnNldChjb250cmFjdFtpbnRlcm5hbF0sIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbChjb250cmFjdCkge1xuICAgIHJldHVybiBpbnRlcm5hbFZhbHVlcy5nZXQoY29udHJhY3RbaW50ZXJuYWxdKTtcbn1cbmZ1bmN0aW9uIGlzRGVmZXJyZWQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIChcImdldFRvcGljRmlsdGVyXCIgaW4gdmFsdWUpICYmXG4gICAgICAgICh0eXBlb2YgKHZhbHVlLmdldFRvcGljRmlsdGVyKSA9PT0gXCJmdW5jdGlvblwiKSAmJiB2YWx1ZS5mcmFnbWVudCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCkge1xuICAgIGxldCB0b3BpY3M7XG4gICAgbGV0IGZyYWdtZW50ID0gbnVsbDtcbiAgICAvLyBDb252ZXJ0IG5hbWVkIGV2ZW50cyB0byB0b3BpY0hhc2ggYW5kIGdldCB0aGUgZnJhZ21lbnQgZm9yXG4gICAgLy8gZXZlbnRzIHdoaWNoIG5lZWQgZGVjb25zdHJ1Y3RpbmcuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGNvbnN0IHRvcGljSGFzaGlmeSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZSwgMzIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChuYW1lKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcInVua25vd24gZnJhZ21lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXJyYXkgb2YgVG9waWNzIGFuZCBOYW1lczsgZS5nLiBgWyBcIjB4MTIzNC4uLjg5YWJcIiwgXCJUcmFuc2ZlcihhZGRyZXNzKVwiIF1gXG4gICAgICAgIHRvcGljcyA9IGV2ZW50Lm1hcCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5tYXAodG9waWNIYXNoaWZ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3BpY0hhc2hpZnkoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgdG9waWNzID0gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGV2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZXZlbnQsIDMyKSkge1xuICAgICAgICAgICAgLy8gVG9waWMgSGFzaFxuICAgICAgICAgICAgdG9waWNzID0gW2V2ZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5hbWUgb3IgU2lnbmF0dXJlOyBlLmcuIGBcIlRyYW5zZmVyXCIsIGBcIlRyYW5zZmVyKGFkZHJlc3MpXCJgXG4gICAgICAgICAgICBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChldmVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJ1bmtub3duIGZyYWdtZW50XCIsIFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgICAgICAgICAgdG9waWNzID0gW2ZyYWdtZW50LnRvcGljSGFzaF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZWZlcnJlZChldmVudCkpIHtcbiAgICAgICAgLy8gRGVmZXJyZWQgVG9waWMgRmlsdGVyOyBlLmcuIGBjb250cmFjdC5maWx0ZXIuVHJhbnNmZXIoZnJvbSlgXG4gICAgICAgIHRvcGljcyA9IGF3YWl0IGV2ZW50LmdldFRvcGljRmlsdGVyKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwiZnJhZ21lbnRcIiBpbiBldmVudCkge1xuICAgICAgICAvLyBDb250cmFjdEV2ZW50OyBlLmcuIGBjb250cmFjdC5maWx0ZXIuVHJhbnNmZXJgXG4gICAgICAgIGZyYWdtZW50ID0gZXZlbnQuZnJhZ21lbnQ7XG4gICAgICAgIHRvcGljcyA9IFtmcmFnbWVudC50b3BpY0hhc2hdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBldmVudCBuYW1lXCIsIFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgdG9waWNzIGFuZCBzb3J0IFRvcGljU2V0c1xuICAgIHRvcGljcyA9IHRvcGljcy5tYXAoKHQpID0+IHtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShuZXcgU2V0KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKS52YWx1ZXMoKSk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgY29uc3QgdGFnID0gdG9waWNzLm1hcCgodCkgPT4ge1xuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmpvaW4oXCJ8XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pLmpvaW4oXCImXCIpO1xuICAgIHJldHVybiB7IGZyYWdtZW50LCB0YWcsIHRvcGljcyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaGFzU3ViKGNvbnRyYWN0LCBldmVudCkge1xuICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwoY29udHJhY3QpO1xuICAgIHJldHVybiBzdWJzLmdldCgoYXdhaXQgZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpKS50YWcpIHx8IG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWIoY29udHJhY3QsIG9wZXJhdGlvbiwgZXZlbnQpIHtcbiAgICAvLyBNYWtlIHN1cmUgb3VyIHJ1bm5lciBjYW4gYWN0dWFsbHkgc3Vic2NyaWJlIHRvIGV2ZW50c1xuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc3Vic2NyaWJpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgdGFnLCB0b3BpY3MgfSA9IGF3YWl0IGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KTtcbiAgICBjb25zdCB7IGFkZHIsIHN1YnMgfSA9IGdldEludGVybmFsKGNvbnRyYWN0KTtcbiAgICBsZXQgc3ViID0gc3Vicy5nZXQodGFnKTtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogY29udHJhY3QpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGFkZHJlc3MsIHRvcGljcyB9O1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChsb2cpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGZyYWdtZW50IGlzIG51bGwsIHdlIGRvIG5vdCBkZWNvbnN0cnVjdCB0aGUgYXJncyB0byBlbWl0XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9mb3VuZEZyYWdtZW50ID0gZm91bmRGcmFnbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gZnJhZ21lbnQgPyBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSA6IFtdO1xuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdEV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBfZm91bmRGcmFnbWVudCwgbG9nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBbXSwgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkKGNvbnRyYWN0LCBsaXN0ZW5lciwgZXZlbnQsIGxvZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdGFydGluZyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydGluZy5wdXNoKHByb3ZpZGVyLm9uKGZpbHRlciwgbGlzdGVuZXIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RvcCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydGluZy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydGVkID0gc3RhcnRpbmc7XG4gICAgICAgICAgICBzdGFydGluZyA9IFtdO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc3RhcnRlZCk7XG4gICAgICAgICAgICBwcm92aWRlci5vZmYoZmlsdGVyLCBsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICAgIHN1YiA9IHsgdGFnLCBsaXN0ZW5lcnM6IFtdLCBzdGFydCwgc3RvcCB9O1xuICAgICAgICBzdWJzLnNldCh0YWcsIHN1Yik7XG4gICAgfVxuICAgIHJldHVybiBzdWI7XG59XG4vLyBXZSB1c2UgdGhpcyB0byBlbnN1cmUgb25lIGVtaXQgcmVzb2x2ZXMgYmVmb3JlIGZpcmluZyB0aGUgbmV4dCB0b1xuLy8gZW5zdXJlIGNvcnJlY3Qgb3JkZXJpbmcgKG5vdGUgdGhpcyBjYW5ub3QgdGhyb3cgYW5kIGp1c3QgYWRkcyB0aGVcbi8vIG5vdGljZSB0byB0aGUgZXZlbnQgcXVldSB1c2luZyBzZXRUaW1lb3V0KS5cbmxldCBsYXN0RW1pdCA9IFByb21pc2UucmVzb2x2ZSgpO1xuYXN5bmMgZnVuY3Rpb24gX2VtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYykge1xuICAgIGF3YWl0IGxhc3RFbWl0O1xuICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yihjb250cmFjdCwgZXZlbnQpO1xuICAgIGlmICghc3ViKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICBzdWIubGlzdGVuZXJzID0gc3ViLmxpc3RlbmVycy5maWx0ZXIoKHsgbGlzdGVuZXIsIG9uY2UgfSkgPT4ge1xuICAgICAgICBjb25zdCBwYXNzQXJncyA9IEFycmF5LmZyb20oYXJncyk7XG4gICAgICAgIGlmIChwYXlsb2FkRnVuYykge1xuICAgICAgICAgICAgcGFzc0FyZ3MucHVzaChwYXlsb2FkRnVuYyhvbmNlID8gbnVsbCA6IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoY29udHJhY3QsIC4uLnBhc3NBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gIW9uY2U7XG4gICAgfSk7XG4gICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgIGdldEludGVybmFsKGNvbnRyYWN0KS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIChjb3VudCA+IDApO1xufVxuYXN5bmMgZnVuY3Rpb24gZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbGFzdEVtaXQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgY29uc3QgcmVzdWx0UHJvbWlzZSA9IF9lbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpO1xuICAgIGxhc3RFbWl0ID0gcmVzdWx0UHJvbWlzZTtcbiAgICByZXR1cm4gYXdhaXQgcmVzdWx0UHJvbWlzZTtcbn1cbmNvbnN0IHBhc3NQcm9wZXJ0aWVzID0gW1widGhlblwiXTtcbmV4cG9ydCBjbGFzcyBCYXNlQ29udHJhY3Qge1xuICAgIC8qKlxuICAgICAqICBUaGUgdGFyZ2V0IHRvIGNvbm5lY3QgdG8uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gYmUgYW4gYWRkcmVzcywgRU5TIG5hbWUgb3IgYW55IFtbQWRkcmVzc2FibGVdXSwgc3VjaCBhc1xuICAgICAqICBhbm90aGVyIGNvbnRyYWN0LiBUbyBnZXQgdGhlIHJlc292bGVkIGFkZHJlc3MsIHVzZSB0aGUgYGBnZXRBZGRyZXNzYGBcbiAgICAgKiAgbWV0aG9kLlxuICAgICAqL1xuICAgIHRhcmdldDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcnVubmVyLiBUaGlzIGlzIGdlbmVyYWxseSBhIFtbUHJvdmlkZXJdXSBvciBhXG4gICAgICogIFtbU2lnbmVyXV0sIHdoaWNoIGRpY3RhdGVzIHdoYXQgb3BlcmF0aW9ucyBhcmUgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBhICoqQ29udHJhY3QqKiBjb25uZWN0ZWQgdG8gYSBbW1Byb3ZpZGVyXV0gbWF5XG4gICAgICogIG9ubHkgZXhlY3V0ZSByZWFkLW9ubHkgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBydW5uZXI7XG4gICAgLyoqXG4gICAgICogIEFsbCB0aGUgRXZlbnRzIGF2YWlsYWJsZSBvbiB0aGlzIGNvbnRyYWN0LlxuICAgICAqL1xuICAgIGZpbHRlcnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIFtpbnRlcm5hbF07XG4gICAgLyoqXG4gICAgICogIFRoZSBmYWxsYmFjayBvciByZWNlaXZlIGZ1bmN0aW9uIGlmIGFueS5cbiAgICAgKi9cbiAgICBmYWxsYmFjaztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBjb250cmFjdCBjb25uZWN0ZWQgdG8gJSV0YXJnZXQlJSB3aXRoIHRoZSAlJWFiaSUlIGFuZFxuICAgICAqICBvcHRpb25hbGx5IGNvbm5lY3RlZCB0byBhICUlcnVubmVyJSUgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGJlaGFsZlxuICAgICAqICBvZi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGFiaSwgcnVubmVyLCBfZGVwbG95VHgpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiIHx8IGlzQWRkcmVzc2FibGUodGFyZ2V0KSwgXCJpbnZhbGlkIHZhbHVlIGZvciBDb250cmFjdCB0YXJnZXRcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmYWNlID0gSW50ZXJmYWNlLmZyb20oYWJpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHRhcmdldCwgcnVubmVyLCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IHt9IH0pO1xuICAgICAgICBsZXQgYWRkclByb21pc2U7XG4gICAgICAgIGxldCBhZGRyID0gbnVsbDtcbiAgICAgICAgbGV0IGRlcGxveVR4ID0gbnVsbDtcbiAgICAgICAgaWYgKF9kZXBsb3lUeCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihydW5uZXIpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICAgICAgZGVwbG95VHggPSBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKHRoaXMuaW50ZXJmYWNlLCBwcm92aWRlciwgX2RlcGxveVR4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3VicyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdGFyZ2V0IGFzIHRoZSBhZGRyZXNzXG4gICAgICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgYWRkciA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBhZGRyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBnZXRSdW5uZXIocnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuUmVzb2x2ZShyZXNvbHZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgbmFtZSByZXNvbHV0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHJlc29sdmVyLnJlc29sdmVOYW1lKHRhcmdldCkudGhlbigoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3IoXCJhbiBFTlMgbmFtZSB1c2VkIGZvciBhIGNvbnRyYWN0IHRhcmdldCBtdXN0IGJlIGNvcnJlY3RseSBjb25maWd1cmVkXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLmFkZHIgPSBhZGRyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZHJQcm9taXNlID0gdGFyZ2V0LmdldEFkZHJlc3MoKS50aGVuKChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBvdXIgcHJpdmF0ZSB2YWx1ZXNcbiAgICAgICAgc2V0SW50ZXJuYWwodGhpcywgeyBhZGRyUHJvbWlzZSwgYWRkciwgZGVwbG95VHgsIHN1YnMgfSk7XG4gICAgICAgIC8vIEFkZCB0aGUgZXZlbnQgZmlsdGVyc1xuICAgICAgICBjb25zdCBmaWx0ZXJzID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEV2ZW50KHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmIChwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApIHx8IHRoaXMuaW50ZXJmYWNlLmhhc0V2ZW50KFN0cmluZyhwcm9wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmlsdGVycyB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmYWxsYmFjazogKChpZmFjZS5yZWNlaXZlIHx8IGlmYWNlLmZhbGxiYWNrKSA/IChidWlsZFdyYXBwZWRGYWxsYmFjayh0aGlzKSkgOiBudWxsKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV0dXJuIGEgUHJveHkgdGhhdCB3aWxsIHJlc3BvbmQgdG8gZnVuY3Rpb25zXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gdGFyZ2V0IHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVuZGVmaW5lZCBwcm9wZXJ0aWVzIHNob3VsZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRGdW5jdGlvbihwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gdGFyZ2V0IHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5pbnRlcmZhY2UuaGFzRnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgdGFyZ2V0IGFuZCBBQkksIGJ1dFxuICAgICAqICBhIGRpZmZlcmVudCAlJXJ1bm5lciUlLlxuICAgICAqL1xuICAgIGNvbm5lY3QocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRoaXMudGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgcnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBDb250cmFjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIEFCSSBhbmQgcnVubmVyLCBidXRcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSV0YXJnZXQlJS5cbiAgICAgKi9cbiAgICBhdHRhY2godGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHRoaXMucnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcmVzb2x2ZWQgYWRkcmVzcyBvZiB0aGlzIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiBhd2FpdCBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyUHJvbWlzZTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGRlcGxveWVkIGJ5dGVjb2RlIG9yIG51bGwgaWYgbm8gYnl0ZWNvZGUgaXMgZm91bmQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95ZWRDb2RlKCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcInJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IC5wcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJnZXREZXBsb3llZENvZGVcIiB9KTtcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHByb3ZpZGVyLmdldENvZGUoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhpcyBDb250cmFjdCBvbmNlIHRoZSBieXRlY29kZSBoYXMgYmVlbiBkZXBsb3llZCwgb3JcbiAgICAgKiAgcmVzb2x2ZSBpbW1lZGlhdGVseSBpZiBhbHJlYWR5IGRlcGxveWVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JEZXBsb3ltZW50KCkge1xuICAgICAgICAvLyBXZSBoYXZlIHRoZSBkZXBsb3llbWVudCB0cmFuc2FjdGlvbjsganVzdCB1c2UgdGhhdCAodGhyb3dzIGlmIGRlcGxveWVtZW50IGZhaWxzKVxuICAgICAgICBjb25zdCBkZXBsb3lUeCA9IHRoaXMuZGVwbG95bWVudFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmIChkZXBsb3lUeCkge1xuICAgICAgICAgICAgYXdhaXQgZGVwbG95VHgud2FpdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNvZGVcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRDb2RlKCk7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjYW4gc3Vic2NyaWJlIHRvIGEgcHJvdmlkZXIgZXZlbnRcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciAhPSBudWxsLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IC5wcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJ3YWl0Rm9yRGVwbG95bWVudFwiIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tDb2RlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgY2hlY2tDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoZWNrQ29kZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgdHJhbnNhY3Rpb24gdXNlZCB0byBkZXBsb3kgdGhpcyBjb250cmFjdC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGlmIHRoaXMgaW5zdGFuY2Ugd2FzIHJldHVybmVkIGZyb20gYVxuICAgICAqICBbW0NvbnRyYWN0RmFjdG9yeV1dLlxuICAgICAqL1xuICAgIGRlcGxveW1lbnRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsKHRoaXMpLmRlcGxveVR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBuYW1lLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgY29udHJhY3RcbiAgICAgKiAgbWV0aG9kIG5hbWUgY29uZmxpY3RzIHdpdGggYSBKYXZhU2NyaXB0IG5hbWUgc3VjaCBhcyBgYHByb3RvdHlwZWBgIG9yXG4gICAgICogIHdoZW4gdXNpbmcgYSBDb250cmFjdCBwcm9ncmFtYXRpY2FsbHkuXG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGtleSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5mb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jID0gYnVpbGRXcmFwcGVkTWV0aG9kKHRoaXMsIGtleSk7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBldmVudCBmb3IgYSBnaXZlbiBuYW1lLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgY29udHJhY3RcbiAgICAgKiAgZXZlbnQgbmFtZSBjb25mbGljdHMgd2l0aCBhIEphdmFTY3JpcHQgbmFtZSBzdWNoIGFzIGBgcHJvdG90eXBlYGAgb3JcbiAgICAgKiAgd2hlbiB1c2luZyBhIENvbnRyYWN0IHByb2dyYW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBnZXRFdmVudChrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5ID0ga2V5LmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZFdyYXBwZWRFdmVudCh0aGlzLCBrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlUcmFuc2FjdGlvbihoYXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKlxuICAgIC8vIEBUT0RPOiB0aGlzIGlzIGEgbm9uLWJhY2t3YXJkcyBjb21wYXRpYmxlIGNoYW5nZSwgYnV0IHdpbGwgYmUgYWRkZWRcbiAgICAvLyAgICAgICAgaW4gdjcgYW5kIGluIGEgcG90ZW50aWFsIFNtYXJ0Q29udHJhY3QgY2xhc3MgaW4gYW4gdXBjb21pbmdcbiAgICAvLyAgICAgICAgdjYgcmVsZWFzZVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoOiBzdHJpbmcpOiBQcm9taXNlPG51bGwgfCBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdD4ge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBoYXZlIGEgcHJvdmlkZXJcIixcbiAgICAgICAgICAgIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInF1ZXJ5VHJhbnNhY3Rpb25cIiB9KTtcblxuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmludGVyZmFjZSwgcHJvdmlkZXIsIHJlY2VpcHQpO1xuICAgIH1cbiAgICAqL1xuICAgIC8qKlxuICAgICAqICBQcm92aWRlIGhpc3RvcmljIGFjY2VzcyB0byBldmVudCBkYXRhIGZvciAlJWV2ZW50JSUgaW4gdGhlIHJhbmdlXG4gICAgICogICUlZnJvbUJsb2NrJSUgKGRlZmF1bHQ6IGBgMGBgKSB0byAlJXRvQmxvY2slJSAoZGVmYXVsdDogYGBcImxhdGVzdFwiYGApXG4gICAgICogIGluY2x1c2l2ZS5cbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeUZpbHRlcihldmVudCwgZnJvbUJsb2NrLCB0b0Jsb2NrKSB7XG4gICAgICAgIGlmIChmcm9tQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgZnJvbUJsb2NrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9CbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0b0Jsb2NrID0gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFkZHIsIGFkZHJQcm9taXNlIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IChhd2FpdCBhZGRyUHJvbWlzZSkpO1xuICAgICAgICBjb25zdCB7IGZyYWdtZW50LCB0b3BpY3MgfSA9IGF3YWl0IGdldFN1YkluZm8odGhpcywgZXZlbnQpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGFkZHJlc3MsIHRvcGljcywgZnJvbUJsb2NrLCB0b0Jsb2NrIH07XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeUZpbHRlclwiIH0pO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKSkubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50TG9nKGxvZywgdGhpcy5pbnRlcmZhY2UsIGZvdW5kRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmRlY29kZWRFdmVudExvZyhsb2csIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBZGQgYW4gZXZlbnQgJSVsaXN0ZW5lciUlIGZvciB0aGUgJSVldmVudCUlLlxuICAgICAqL1xuICAgIGFzeW5jIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvblwiLCBldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJSwgYnV0IHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgKiAgYWZ0ZXIgaXQgaXMgZmlyZWQgb25jZS5cbiAgICAgKi9cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvbmNlXCIsIGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIHN1Yi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVtaXQgYW4gJSVldmVudCUlIGNhbGxpbmcgYWxsIGxpc3RlbmVycyB3aXRoICUlYXJncyUlLlxuICAgICAqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIGFueSBsaXN0ZW5lcnMgd2VyZSBjYWxsZWQuXG4gICAgICovXG4gICAgYXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZW1pdCh0aGlzLCBldmVudCwgYXJncywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvZiAlJWV2ZW50JSUgb3IgdGhlIHRvdGFsIG51bWJlclxuICAgICAqICBvZiBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBsaXN0ZW5lcnMgc3Vic2NyaWJlZCB0byAlJWV2ZW50JSUgb3IgYWxsIGxpc3RlbmVyc1xuICAgICAqICBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQobGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZW1vdmUgdGhlICUlbGlzdGVuZXIlJSBmcm9tIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmVcbiAgICAgKiAgYWxsIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBmb3IgJSVldmVudCUlIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGlmXG4gICAgICogIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YWcsIHN0b3AgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHN1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGlhcyBmb3IgW29uXS5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFsaWFzIGZvciBbb2ZmXS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQ2xhc3MgZm9yIHRoZSAlJWFiaSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZENsYXNzKGFiaSkge1xuICAgICAgICBjbGFzcyBDdXN0b21Db250cmFjdCBleHRlbmRzIEJhc2VDb250cmFjdCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBydW5uZXIgPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoYWRkcmVzcywgYWJpLCBydW5uZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDdXN0b21Db250cmFjdDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQmFzZUNvbnRyYWN0IHdpdGggYSBzcGVjaWZpZWQgSW50ZXJmYWNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHRhcmdldCwgYWJpLCBydW5uZXIpIHtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IHRoaXModGFyZ2V0LCBhYmksIHJ1bm5lcik7XG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfQ29udHJhY3RCYXNlKCkge1xuICAgIHJldHVybiBCYXNlQ29udHJhY3Q7XG59XG4vKipcbiAqICBBIFtbQmFzZUNvbnRyYWN0XV0gd2l0aCBubyB0eXBlIGd1YXJkcyBvbiBpdHMgbWV0aG9kcyBvciBldmVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdCBleHRlbmRzIF9Db250cmFjdEJhc2UoKSB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cmFjdC5qcy5tYXAiLCIvKipcbiAqICBFTlMgaXMgYSBzZXJ2aWNlIHdoaWNoIGFsbG93cyBlYXN5LXRvLXJlbWVtYmVyIG5hbWVzIHRvIG1hcCB0b1xuICogIG5ldHdvcmsgYWRkcmVzc2VzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvZW5zLXJlc29sdmVyOkVOUyBSZXNvbHZlciAgW2Fib3V0LWVucy1yc29sdmVyXVxuICovXG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3QgfSBmcm9tIFwiLi4vY29udHJhY3QvaW5kZXguanNcIjtcbmltcG9ydCB7IGRuc0VuY29kZSwgbmFtZWhhc2ggfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvQmVIZXgsIGRlZmluZVByb3BlcnRpZXMsIGVuY29kZUJhc2U1OCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNFcnJvciwgRmV0Y2hSZXF1ZXN0IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vLyBAVE9ETzogVGhpcyBzaG91bGQgdXNlIHRoZSBmZXRjaC1kYXRhOmlwZnMgZ2F0ZXdheVxuLy8gVHJpbSBvZmYgdGhlIGlwZnM6Ly8gcHJlZml4IGFuZCByZXR1cm4gdGhlIGRlZmF1bHQgZ2F0ZXdheSBVUkxcbmZ1bmN0aW9uIGdldElwZnNMaW5rKGxpbmspIHtcbiAgICBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvaXBmc1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoMTIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgSVBGUyBmb3JtYXRcIiwgXCJsaW5rXCIsIGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gYGh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy8ke2xpbmt9YDtcbn1cbjtcbjtcbi8qKlxuICogIEEgcHJvdmlkZXIgcGx1Z2luIHN1cGVyLWNsYXNzIGZvciBwcm9jZXNzaW5nIG11bHRpY29pbiBhZGRyZXNzIHR5cGVzLlxuICovXG5leHBvcnQgY2xhc3MgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZS5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTXVsdGljb2luUHJvdmlkZXJQbHVpbmcqKiBmb3IgJSVuYW1lJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm9pdmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSVjb2luVHlwZSUlIGlzIHN1cHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgKi9cbiAgICBzdXBwb3J0c0NvaW5UeXBlKGNvaW5UeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBlbmNvZGVkICUlYWRkcmVzcyUlIGZvciAlJWNvaW5UeXBlJSUuXG4gICAgICovXG4gICAgYXN5bmMgZW5jb2RlQWRkcmVzcyhjb2luVHlwZSwgYWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGRlY29kZWQgJSVkYXRhJSUgZm9yICUlY29pblR5cGUlJS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWNvZGVBZGRyZXNzKGNvaW5UeXBlLCBkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGNvaW5cIik7XG4gICAgfVxufVxuY29uc3QgQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCA9IFwib3JnLmV0aGVycy5wbHVnaW5zLnByb3ZpZGVyLkJhc2ljTXVsdGljb2luXCI7XG4vKipcbiAqICBBICoqQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbioqIHByb3ZpZGVzIHNlcnZpY2UgZm9yIGNvbW1vblxuICogIGNvaW4gdHlwZXMsIHdoaWNoIGRvIG5vdCByZXF1aXJlIGFkZGl0aW9uYWwgbGlicmFyaWVzIHRvIGVuY29kZSBvclxuICogIGRlY29kZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4gZXh0ZW5kcyBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKEJhc2ljTXVsdGljb2luUGx1Z2luSWQpO1xuICAgIH1cbn1cbmNvbnN0IG1hdGNoZXJJcGZzID0gbmV3IFJlZ0V4cChcIl4oaXBmcyk6L1xcLyguKikkXCIsIFwiaVwiKTtcbmNvbnN0IG1hdGNoZXJzID0gW1xuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcbiAgICBtYXRjaGVySXBmcyxcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxuXTtcbi8qKlxuICogIEEgY29ubmVjdGVkIG9iamVjdCB0byBhIHJlc29sdmVkIEVOUyBuYW1lIHJlc29sdmVyLCB3aGljaCBjYW4gYmVcbiAqICB1c2VkIHRvIHF1ZXJ5IGFkZGl0aW9uYWwgZGV0YWlscy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuc1Jlc29sdmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBwcm92aWRlci5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIHJlc29sdmVyLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIHRoaXMgcmVzb2x2ZXIgd2FzIHJlc29sdmVkIGFnYWluc3QuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvLyBGb3IgRUlQLTI1NDQgbmFtZXMsIHRoZSBhbmNlc3RvciB0aGF0IHByb3ZpZGVkIHRoZSByZXNvbHZlclxuICAgICNzdXBwb3J0czI1NDQ7XG4gICAgI3Jlc29sdmVyO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBhZGRyZXNzLCBuYW1lKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwcm92aWRlciwgYWRkcmVzcywgbmFtZSB9KTtcbiAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZXIgPSBuZXcgQ29udHJhY3QoYWRkcmVzcywgW1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBzdXBwb3J0c0ludGVyZmFjZShieXRlczQpIHZpZXcgcmV0dXJucyAoYm9vbClcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZShieXRlcywgYnl0ZXMpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGFkZHIoYnl0ZXMzMikgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBhZGRyKGJ5dGVzMzIsIHVpbnQpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHRleHQoYnl0ZXMzMiwgc3RyaW5nKSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gY29udGVudGhhc2goYnl0ZXMzMikgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgXSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgcmVzb2x2ZXIgc3VwcG9ydHMgd2lsZGNhcmQgcmVzb2x1dGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBzdXBwb3J0c1dpbGRjYXJkKCkge1xuICAgICAgICBpZiAodGhpcy4jc3VwcG9ydHMyNTQ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3Jlc29sdmVyLnN1cHBvcnRzSW50ZXJmYWNlKFwiMHg5MDYxYjkyM1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdpbGRjYXJkIHJlc29sdmVycyBtdXN0IHVuZGVyc3RhbmQgc3VwcG9ydHNJbnRlcmZhY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0cnVlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIExldCBmdXR1cmUgYXR0ZW1wdHMgdHJ5IGFnYWluLi4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3N1cHBvcnRzMjU0NDtcbiAgICB9XG4gICAgYXN5bmMgI2ZldGNoKGZ1bmNOYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgY29uc3QgaWZhY2UgPSB0aGlzLiNyZXNvbHZlci5pbnRlcmZhY2U7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXJzIGlzIGFsd2F5cyB0aGUgbm9kZWhhc2hcbiAgICAgICAgcGFyYW1zLnVuc2hpZnQobmFtZWhhc2godGhpcy5uYW1lKSk7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IG51bGw7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnN1cHBvcnRzV2lsZGNhcmQoKSkge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBpZmFjZS5nZXRGdW5jdGlvbihmdW5jTmFtZSk7XG4gICAgICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibWlzc2luZyBmcmFnbWVudFwiLCBcIlVOS05PV05fRVJST1JcIiwge1xuICAgICAgICAgICAgICAgIGluZm86IHsgZnVuY05hbWUgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMgPSBbXG4gICAgICAgICAgICAgICAgZG5zRW5jb2RlKHRoaXMubmFtZSwgMjU1KSxcbiAgICAgICAgICAgICAgICBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHBhcmFtcylcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmdW5jTmFtZSA9IFwicmVzb2x2ZShieXRlcyxieXRlcylcIjtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMucHVzaCh7XG4gICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Jlc29sdmVyW2Z1bmNOYW1lXSguLi5wYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGFkZHJlc3MgZm9yICUlY29pblR5cGUlJSBvciBudWxsIGlmIHRoZVxuICAgICAqICBwcm92aWRlZCAlJWNvaW5UeXBlJSUgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWRkcmVzcyhjb2luVHlwZSkge1xuICAgICAgICBpZiAoY29pblR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29pblR5cGUgPSA2MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pblR5cGUgPT09IDYwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiYWRkcihieXRlczMyKVwiKTtcbiAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsIHx8IHJlc3VsdCA9PT0gWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IGRlY29kaW5nIGl0cyBFVk0gY2Fub25pY2FsIGNoYWluIGFzIGFuIEVWTSBjaGFpbiBhZGRyZXNzIGZpcnN0XG4gICAgICAgIGlmIChjb2luVHlwZSA+PSAwICYmIGNvaW5UeXBlIDwgMHg4MDAwMDAwMCkge1xuICAgICAgICAgICAgbGV0IGV0aENvaW5UeXBlID0gY29pblR5cGUgKyAweDgwMDAwMDAwO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiYWRkcihieXRlczMyLHVpbnQpXCIsIFtldGhDb2luVHlwZV0pO1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGRhdGEsIDIwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb2luUGx1Z2luID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wcm92aWRlci5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAoIShwbHVnaW4gaW5zdGFuY2VvZiBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbHVnaW4uc3VwcG9ydHNDb2luVHlwZShjb2luVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb2luUGx1Z2luID0gcGx1Z2luO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luUGx1Z2luID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMix1aW50MjU2XCIpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMix1aW50KVwiLCBbY29pblR5cGVdKTtcbiAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYWRkcmVzc1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgY29pblBsdWdpbi5kZWNvZGVBZGRyZXNzKGNvaW5UeXBlLCBkYXRhKTtcbiAgICAgICAgaWYgKGFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCBjb2luIGRhdGFgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IGBnZXRBZGRyZXNzKCR7Y29pblR5cGV9KWAsXG4gICAgICAgICAgICBpbmZvOiB7IGNvaW5UeXBlLCBkYXRhIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgRUlQLTYzNCB0ZXh0IHJlY29yZCBmb3IgJSVrZXklJSwgb3IgYGBudWxsYGBcbiAgICAgKiAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRleHQoa2V5KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcInRleHQoYnl0ZXMzMixzdHJpbmcpXCIsIFtrZXldKTtcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUnNvbHZlcyB0byB0aGUgY29udGVudC1oYXNoIG9yIGBgbnVsbGBgIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb250ZW50SGFzaCgpIHtcbiAgICAgICAgLy8ga2VjY2FrMjU2KFwiY29udGVudGhhc2goKVwiKVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJjb250ZW50aGFzaChieXRlczMyKVwiKTtcbiAgICAgICAgLy8gTm8gY29udGVudGhhc2hcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIElQRlMgKENJRDogMSwgVHlwZTogNzA9REFHLVBCLCA3Mj1saWJwMnAta2V5KVxuICAgICAgICBjb25zdCBpcGZzID0gZGF0YS5tYXRjaCgvXjB4KGUzMDEwMTcwfGU1MDEwMTcyKSgoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XG4gICAgICAgIGlmIChpcGZzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWUgPSAoaXBmc1sxXSA9PT0gXCJlMzAxMDE3MFwiKSA/IFwiaXBmc1wiIDogXCJpcG5zXCI7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChpcGZzWzRdLCAxNik7XG4gICAgICAgICAgICBpZiAoaXBmc1s1XS5sZW5ndGggPT09IGxlbmd0aCAqIDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c2NoZW1lfTovXFwvJHtlbmNvZGVCYXNlNTgoXCIweFwiICsgaXBmc1syXSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTd2FybSAoQ0lEOiAxLCBUeXBlOiBzd2FybS1tYW5pZmVzdDsgaGFzaC9sZW5ndGggaGFyZC1jb2RlZCB0byBrZWNjYWsyNTYvMzIpXG4gICAgICAgIGNvbnN0IHN3YXJtID0gZGF0YS5tYXRjaCgvXjB4ZTQwMTAxZmEwMTFiMjAoWzAtOWEtZl0qKSQvKTtcbiAgICAgICAgaWYgKHN3YXJtICYmIHN3YXJtWzFdLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgIHJldHVybiBgYnp6Oi9cXC8ke3N3YXJtWzFdfWA7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb250ZW50IGhhc2ggZGF0YWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRDb250ZW50SGFzaCgpXCIsXG4gICAgICAgICAgICBpbmZvOiB7IGRhdGEgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhdmF0YXIgdXJsIG9yIGBgbnVsbGBgIGlmIHRoZSBhdmF0YXIgaXMgZWl0aGVyXG4gICAgICogIHVuY29uZmlndXJlZCBvciBpbmNvcnJlY3RseSBjb25maWd1cmVkIChlLmcuIHJlZmVyZW5jZXMgYW4gTkZUXG4gICAgICogIG5vdCBvd25lZCBieSB0aGUgYWRkcmVzcykuXG4gICAgICpcbiAgICAgKiAgSWYgZGlhZ25vc2luZyBpc3N1ZXMgd2l0aCBjb25maWd1cmF0aW9ucywgdGhlIFtbX2dldEF2YXRhcl1dXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZnVsLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEF2YXRhcigpIHtcbiAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5fZ2V0QXZhdGFyKCk7XG4gICAgICAgIHJldHVybiBhdmF0YXIudXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2hlbiByZXNvbHZpbmcgYW4gYXZhdGFyLCB0aGVyZSBhcmUgbWFueSBzdGVwcyBpbnZvbHZlZCwgc3VjaFxuICAgICAqICBmZXRjaGluZyBtZXRhZGF0YSBhbmQgcG9zc2libHkgdmFsaWRhdGluZyBvd25lcnNoaXAgb2YgYW5cbiAgICAgKiAgTkZULlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGV4YW1pbmUgZWFjaCBzdGVwIGFuZCB0aGUgdmFsdWUgaXRcbiAgICAgKiAgd2FzIHdvcmtpbmcgZnJvbS5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QXZhdGFyKCkge1xuICAgICAgICBjb25zdCBsaW5rYWdlID0gW3sgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0aGlzLm5hbWUgfV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB0ZXN0IGRhdGEgZm9yIHJpY21vby5ldGhcbiAgICAgICAgICAgIC8vY29uc3QgYXZhdGFyID0gXCJlaXAxNTU6MS9lcmM3MjE6MHgyNjUzODVjN2Y0MTMyMjI4QTBkNTRFQjFBOWU3NDYwYjkxYzBjQzY4LzI5MjMzXCI7XG4gICAgICAgICAgICBjb25zdCBhdmF0YXIgPSBhd2FpdCB0aGlzLmdldFRleHQoXCJhdmF0YXJcIik7XG4gICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFhdmF0YXJcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImF2YXRhclwiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYXZhdGFyLm1hdGNoKG1hdGNoZXJzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHNcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXBmc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBnZXRJcGZzTGluayhhdmF0YXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpcGZzXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogdXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjMTE1NVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIEVSQyB0eXBlLCB1c2UgdG9rZW5VUkkodWludDI1Nikgb3IgdXJsKHVpbnQyNTYpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IChzY2hlbWUgPT09IFwiZXJjNzIxXCIpID8gXCJ0b2tlblVSSSh1aW50MjU2KVwiIDogXCJ1cmkodWludDI1NilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IHNjaGVtZSwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvd25lciBvZiB0aGlzIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW93bmVyXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcHMgPSAobWF0Y2hbMl0gfHwgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IGAhJHtzY2hlbWV9Y2FpcGAsIHZhbHVlOiAobWF0Y2hbMl0gfHwgXCJcIikgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbklkID0gY29tcHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBDb250cmFjdChjb21wc1swXSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy03MjFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHRva2VuVVJJKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gb3duZXJPZih1aW50KSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHVyaSh1aW50KSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIGJhbGFuY2VPZihhZGRyZXNzLCB1aW50MjU2KSB2aWV3IHJldHVybnMgKHVpbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGlzIGFjY291bnQgb3ducyB0aGUgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjNzIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbk93bmVyID0gYXdhaXQgY29udHJhY3Qub3duZXJPZih0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIgIT09IHRva2VuT3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhb3duZXJcIiwgdmFsdWU6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm93bmVyXCIsIHZhbHVlOiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb250cmFjdC5iYWxhbmNlT2Yob3duZXIsIHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFiYWxhbmNlXCIsIHZhbHVlOiBcIjBcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYmFsYW5jZVwiLCB2YWx1ZTogYmFsYW5jZS50b1N0cmluZygpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdG9rZW4gY29udHJhY3QgZm9yIHRoZSBtZXRhZGF0YSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YVVybCA9IGF3YWl0IGNvbnRyYWN0W3NlbGVjdG9yXSh0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybCA9PSBudWxsIHx8IG1ldGFkYXRhVXJsID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YS11cmxcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1iYXNlXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy0xMTU1IGFsbG93cyBhIGdlbmVyaWMge2lkfSBpbiB0aGUgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gbWV0YWRhdGFVcmwucmVwbGFjZShcIntpZH1cIiwgdG9CZUhleCh0b2tlbklkLCAzMikuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1leHBhbmRlZFwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBtZXRhZGF0YSBsaW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsLm1hdGNoKC9eaXBmczovaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IGdldElwZnNMaW5rKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdG9rZW4gbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAobmV3IEZldGNoUmVxdWVzdChtZXRhZGF0YVVybCkpLnNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gcmVzcG9uc2UuYm9keUpzb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogcmVzcG9uc2UuYm9keVRleHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IGhleGxpZnkoYnl0ZXMpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGFcIiwgdmFsdWU6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhlIGltYWdlIFVSTCBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZVVybCA9IG1ldGFkYXRhLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaW1hZ2VVcmwpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmxcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VVcmwubWF0Y2goL14oaHR0cHM6XFwvXFwvfGRhdGE6KS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSVBGUyBsaW5rIHRvIGdhdGV3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpcGZzID0gaW1hZ2VVcmwubWF0Y2gobWF0Y2hlcklwZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhaW1hZ2VVcmwtaXBmc1wiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImltYWdlVXJsLWlwZnNcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsID0gZ2V0SXBmc0xpbmsoaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBpbWFnZVVybCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogbnVsbCB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZ2V0RW5zQWRkcmVzcyhwcm92aWRlcikge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBlbnNQbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcbiAgICAgICAgLy8gTm8gRU5TLi4uXG4gICAgICAgIGFzc2VydChlbnNQbHVnaW4sIFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVOU1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0RW5zQWRkcmVzc1wiLCBpbmZvOiB7IG5ldHdvcmsgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVuc1BsdWdpbi5hZGRyZXNzO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgI2dldFJlc29sdmVyKHByb3ZpZGVyLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGVuc0FkZHIgPSBhd2FpdCBFbnNSZXNvbHZlci5nZXRFbnNBZGRyZXNzKHByb3ZpZGVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGVuc0FkZHIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICAgICAgICAgICAgXSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgY29uc3QgYWRkciA9IGF3YWl0IGNvbnRyYWN0LnJlc29sdmVyKG5hbWVoYXNoKG5hbWUpLCB7XG4gICAgICAgICAgICAgICAgZW5hYmxlQ2NpcFJlYWQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGFkZHIgPT09IFplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEVOUyByZWdpc3RyeSBjYW5ub3QgdGhyb3cgZXJyb3JzIG9uIHJlc29sdmVyKGJ5dGVzMzIpLFxuICAgICAgICAgICAgLy8gc28gcHJvYmFibHkgYSBsaW5rIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhlIEVOUyByZXNvbHZlciBmb3IgJSVuYW1lJSUgdXNpbmcgJSVwcm92aWRlciUlIG9yXG4gICAgICogIGBgbnVsbGBgIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbU5hbWUocHJvdmlkZXIsIG5hbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnROYW1lID0gbmFtZTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gXCJcIiB8fCBjdXJyZW50TmFtZSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbiBzaW5jZSB0aGUgZXRoIG5vZGUgY2Fubm90IGNoYW5nZSBhbmQgZG9lc1xuICAgICAgICAgICAgLy8gbm90IGhhdmUgYSB3aWxkY2FyZCByZXNvbHZlclxuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiZXRoXCIgJiYgY3VycmVudE5hbWUgPT09IFwiZXRoXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBjdXJyZW50IG5vZGUgZm9yIGEgcmVzb2x2ZXJcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSBhd2FpdCBFbnNSZXNvbHZlci4jZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIGN1cnJlbnROYW1lKTtcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgcmVzb2x2ZXIhXG4gICAgICAgICAgICBpZiAoYWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgRW5zUmVzb2x2ZXIocHJvdmlkZXIsIGFkZHIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSByZXNvbHZlciBmb3VuZCwgdXNpbmcgRUlQLTI1NDQgc28gaXQgaXNuJ3Qgc2FmZSB0byB1c2VcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgIT09IG5hbWUgJiYgIShhd2FpdCByZXNvbHZlci5zdXBwb3J0c1dpbGRjYXJkKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICBjdXJyZW50TmFtZSA9IGN1cnJlbnROYW1lLnNwbGl0KFwiLlwiKS5zbGljZSgxKS5qb2luKFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVucy1yZXNvbHZlci5qcy5tYXAiLCIvKipcbiAqICBAX2lnbm9yZVxuICovXG5pbXBvcnQgeyBnZXRBZGRyZXNzLCBnZXRDcmVhdGVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgemVyb1BhZFZhbHVlLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuZXhwb3J0IGZ1bmN0aW9uIGFsbG93TnVsbChmb3JtYXQsIG51bGxWYWx1ZSkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXQodmFsdWUpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5T2YoZm9ybWF0LCBhbGxvd051bGwpIHtcbiAgICByZXR1cm4gKChhcnJheSkgPT4ge1xuICAgICAgICBpZiAoYWxsb3dOdWxsICYmIGFycmF5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXkubWFwKChpKSA9PiBmb3JtYXQoaSkpO1xuICAgIH0pO1xufVxuLy8gUmVxdWlyZXMgYW4gb2JqZWN0IHdoaWNoIG1hdGNoZXMgYSBmbGVldCBvZiBvdGhlciBmb3JtYXR0ZXJzXG4vLyBBbnkgRm9ybWF0RnVuYyBtYXkgcmV0dXJuIGB1bmRlZmluZWRgIHRvIGhhdmUgdGhlIHZhbHVlIG9taXR0ZWRcbi8vIGZyb20gdGhlIHJlc3VsdCBvYmplY3QuIENhbGxzIHByZXNlcnZlIGB0aGlzYC5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3QoZm9ybWF0LCBhbHROYW1lcykge1xuICAgIHJldHVybiAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcbiAgICAgICAgICAgIGxldCBzcmNLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAoYWx0TmFtZXMgJiYga2V5IGluIGFsdE5hbWVzICYmICEoc3JjS2V5IGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWx0S2V5IG9mIGFsdE5hbWVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsdEtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjS2V5ID0gYWx0S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG52ID0gZm9ybWF0W2tleV0odmFsdWVbc3JjS2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKG52ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBudjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpID8gZXJyb3IubWVzc2FnZSA6IFwibm90LWFuLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCB2YWx1ZSBmb3IgdmFsdWUuJHtrZXl9ICgke21lc3NhZ2V9KWAsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJvb2xlYW4odmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICBjYXNlIFwiZmFsc2VcIjpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGJvb2xlYW47ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGEodmFsdWUpIHtcbiAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZSwgdHJ1ZSksIFwiaW52YWxpZCBkYXRhXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRIYXNoKHZhbHVlKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWUsIDMyKSwgXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVpbnQyNTYodmFsdWUpIHtcbiAgICBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQyNTZcIik7XG4gICAgfVxuICAgIHJldHVybiB6ZXJvUGFkVmFsdWUodmFsdWUsIDMyKTtcbn1cbmNvbnN0IF9mb3JtYXRMb2cgPSBvYmplY3Qoe1xuICAgIGFkZHJlc3M6IGdldEFkZHJlc3MsXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXG4gICAgZGF0YTogZm9ybWF0RGF0YSxcbiAgICBpbmRleDogZ2V0TnVtYmVyLFxuICAgIHJlbW92ZWQ6IGFsbG93TnVsbChmb3JtYXRCb29sZWFuLCBmYWxzZSksXG4gICAgdG9waWNzOiBhcnJheU9mKGZvcm1hdEhhc2gpLFxuICAgIHRyYW5zYWN0aW9uSGFzaDogZm9ybWF0SGFzaCxcbiAgICB0cmFuc2FjdGlvbkluZGV4OiBnZXROdW1iZXIsXG59LCB7XG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRMb2codmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdExvZyh2YWx1ZSk7XG59XG5jb25zdCBfZm9ybWF0QmxvY2sgPSBvYmplY3Qoe1xuICAgIGhhc2g6IGFsbG93TnVsbChmb3JtYXRIYXNoKSxcbiAgICBwYXJlbnRIYXNoOiBmb3JtYXRIYXNoLFxuICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgIG51bWJlcjogZ2V0TnVtYmVyLFxuICAgIHRpbWVzdGFtcDogZ2V0TnVtYmVyLFxuICAgIG5vbmNlOiBhbGxvd051bGwoZm9ybWF0RGF0YSksXG4gICAgZGlmZmljdWx0eTogZ2V0QmlnSW50LFxuICAgIGdhc0xpbWl0OiBnZXRCaWdJbnQsXG4gICAgZ2FzVXNlZDogZ2V0QmlnSW50LFxuICAgIHN0YXRlUm9vdDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgIHJlY2VpcHRzUm9vdDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgIGJsb2JHYXNVc2VkOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICBleGNlc3NCbG9iR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICBtaW5lcjogYWxsb3dOdWxsKGdldEFkZHJlc3MpLFxuICAgIHByZXZSYW5kYW86IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICBleHRyYURhdGE6IGZvcm1hdERhdGEsXG4gICAgYmFzZUZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludClcbn0sIHtcbiAgICBwcmV2UmFuZGFvOiBbXCJtaXhIYXNoXCJdXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCbG9jayh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IF9mb3JtYXRCbG9jayh2YWx1ZSk7XG4gICAgcmVzdWx0LnRyYW5zYWN0aW9ucyA9IHZhbHVlLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHR4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgX2Zvcm1hdFJlY2VpcHRMb2cgPSBvYmplY3Qoe1xuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGdldE51bWJlcixcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxuICAgIHRyYW5zYWN0aW9uSGFzaDogZm9ybWF0SGFzaCxcbiAgICBhZGRyZXNzOiBnZXRBZGRyZXNzLFxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgIGluZGV4OiBnZXROdW1iZXIsXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxufSwge1xuICAgIGluZGV4OiBbXCJsb2dJbmRleFwiXVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmVjZWlwdExvZyh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0UmVjZWlwdExvZyh2YWx1ZSk7XG59XG5jb25zdCBfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0ID0gb2JqZWN0KHtcbiAgICB0bzogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgIGZyb206IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICBjb250cmFjdEFkZHJlc3M6IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICAvLyBzaG91bGQgYmUgYWxsb3dOdWxsKGhhc2gpLCBidXQgYnJva2VuLUVJUC02NTggc3VwcG9ydCBpcyBoYW5kbGVkIGluIHJlY2VpcHRcbiAgICBpbmRleDogZ2V0TnVtYmVyLFxuICAgIHJvb3Q6IGFsbG93TnVsbChoZXhsaWZ5KSxcbiAgICBnYXNVc2VkOiBnZXRCaWdJbnQsXG4gICAgYmxvYkdhc1VzZWQ6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgIGxvZ3NCbG9vbTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbiAgICBoYXNoOiBmb3JtYXRIYXNoLFxuICAgIGxvZ3M6IGFycmF5T2YoZm9ybWF0UmVjZWlwdExvZyksXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICAvL2NvbmZpcm1hdGlvbnM6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgIGN1bXVsYXRpdmVHYXNVc2VkOiBnZXRCaWdJbnQsXG4gICAgZWZmZWN0aXZlR2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgIGJsb2JHYXNQcmljZTogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXG4gICAgc3RhdHVzOiBhbGxvd051bGwoZ2V0TnVtYmVyKSxcbiAgICB0eXBlOiBhbGxvd051bGwoZ2V0TnVtYmVyLCAwKVxufSwge1xuICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBbXCJnYXNQcmljZVwiXSxcbiAgICBoYXNoOiBbXCJ0cmFuc2FjdGlvbkhhc2hcIl0sXG4gICAgaW5kZXg6IFtcInRyYW5zYWN0aW9uSW5kZXhcIl0sXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh2YWx1ZSkge1xuICAgIC8vIFNvbWUgY2xpZW50cyAoVGVzdFJQQykgZG8gc3RyYW5nZSB0aGluZ3MgbGlrZSByZXR1cm4gMHgwIGZvciB0aGVcbiAgICAvLyAwIGFkZHJlc3M7IGNvcnJlY3QgdGhpcyB0byBiZSBhIHJlYWwgYWRkcmVzc1xuICAgIGlmICh2YWx1ZS50byAmJiBnZXRCaWdJbnQodmFsdWUudG8pID09PSBCTl8wKSB7XG4gICAgICAgIHZhbHVlLnRvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gb2JqZWN0KHtcbiAgICAgICAgaGFzaDogZm9ybWF0SGFzaCxcbiAgICAgICAgLy8gU29tZSBub2RlcyBkbyBub3QgcmV0dXJuIHRoaXMsIHVzdWFsbHkgdGVzdCBub2RlcyAobGlrZSBHYW5hY2hlKVxuICAgICAgICBpbmRleDogYWxsb3dOdWxsKGdldE51bWJlciwgdW5kZWZpbmVkKSxcbiAgICAgICAgdHlwZTogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiMHhcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWNjZXNzTGlzdDogYWxsb3dOdWxsKGFjY2Vzc0xpc3RpZnksIG51bGwpLFxuICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzOiBhbGxvd051bGwoYXJyYXlPZihmb3JtYXRIYXNoLCB0cnVlKSwgbnVsbCksXG4gICAgICAgIGF1dGhvcml6YXRpb25MaXN0OiBhbGxvd051bGwoYXJyYXlPZigodikgPT4ge1xuICAgICAgICAgICAgbGV0IHNpZztcbiAgICAgICAgICAgIGlmICh2LnNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgIHNpZyA9IHYuc2lnbmF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHlQYXJpdHkgPSB2LnlQYXJpdHk7XG4gICAgICAgICAgICAgICAgaWYgKHlQYXJpdHkgPT09IFwiMHgxYlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHlQYXJpdHkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5UGFyaXR5ID09PSBcIjB4MWNcIikge1xuICAgICAgICAgICAgICAgICAgICB5UGFyaXR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnID0gT2JqZWN0LmFzc2lnbih7fSwgdiwgeyB5UGFyaXR5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKHYuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogZ2V0QmlnSW50KHYuY2hhaW5JZCksXG4gICAgICAgICAgICAgICAgbm9uY2U6IGdldEJpZ0ludCh2Lm5vbmNlKSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tKHNpZylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIGZhbHNlKSwgbnVsbCksXG4gICAgICAgIGJsb2NrSGFzaDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgICAgICBibG9ja051bWJlcjogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgICAgICBmcm9tOiBnZXRBZGRyZXNzLFxuICAgICAgICAvLyBlaXRoZXIgKGdhc1ByaWNlKSBvciAobWF4UHJpb3JpdHlGZWVQZXJHYXMgKyBtYXhGZWVQZXJHYXMpIG11c3QgYmUgc2V0XG4gICAgICAgIGdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICAgICAgZ2FzTGltaXQ6IGdldEJpZ0ludCxcbiAgICAgICAgdG86IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICAgICAgdmFsdWU6IGdldEJpZ0ludCxcbiAgICAgICAgbm9uY2U6IGdldE51bWJlcixcbiAgICAgICAgZGF0YTogZm9ybWF0RGF0YSxcbiAgICAgICAgY3JlYXRlczogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgICAgICBjaGFpbklkOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKVxuICAgIH0sIHtcbiAgICAgICAgZGF0YTogW1wiaW5wdXRcIl0sXG4gICAgICAgIGdhc0xpbWl0OiBbXCJnYXNcIl0sXG4gICAgICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdXG4gICAgfSkodmFsdWUpO1xuICAgIC8vIElmIHRvIGFuZCBjcmVhdGVzIGFyZSBlbXB0eSwgcG9wdWxhdGUgdGhlIGNyZWF0ZXMgZnJvbSB0aGUgdmFsdWVcbiAgICBpZiAocmVzdWx0LnRvID09IG51bGwgJiYgcmVzdWx0LmNyZWF0ZXMgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuY3JlYXRlcyA9IGdldENyZWF0ZUFkZHJlc3MocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQFRPRE86IENoZWNrIGZlZSBkYXRhXG4gICAgLy8gQWRkIGFuIGFjY2VzcyBsaXN0IHRvIHN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlc1xuICAgIGlmICgodmFsdWUudHlwZSA9PT0gMSB8fCB2YWx1ZS50eXBlID09PSAyKSAmJiB2YWx1ZS5hY2Nlc3NMaXN0ID09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBbXTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgc2lnbmF0dXJlXG4gICAgaWYgKHZhbHVlLnNpZ25hdHVyZSkge1xuICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odmFsdWUuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFNvbWUgYmFja2VuZHMgb21pdCBDaGFpbklkIG9uIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIGJ1dCB3ZSBjYW4gY29tcHV0ZSBpdFxuICAgIGlmIChyZXN1bHQuY2hhaW5JZCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSByZXN1bHQuc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChjaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAVE9ETzogY2hlY2sgY2hhaW5JRFxuICAgIC8qXG4gICAgaWYgKHZhbHVlLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICBsZXQgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XG5cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUubmV0d29ya0lkO1xuXG4gICAgICAgIC8vIGdldGgtZXRjIHJldHVybnMgY2hhaW5JZFxuICAgICAgICBpZiAoY2hhaW5JZCA9PSBudWxsICYmIHJlc3VsdC52ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSB2YWx1ZS5jaGFpbklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIgJiYgcmVzdWx0LnYgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IChyZXN1bHQudiAtIDM1KSAvIDI7XG4gICAgICAgICAgICBpZiAoY2hhaW5JZCA8IDApIHsgY2hhaW5JZCA9IDA7IH1cbiAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHsgY2hhaW5JZCA9IDA7IH1cblxuICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgfVxuICAgICovXG4gICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG4gICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgZ2V0QmlnSW50KHJlc3VsdC5ibG9ja0hhc2gpID09PSBCTl8wKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcCIsImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvcHJvcGVydGllcy5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IEVuc0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiO1xuLyoqXG4gKiAgQSAqKk5ldHdvcmtQbHVnaW4qKiBwcm92aWRlcyBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHkgb24gYSBbW05ldHdvcmtdXS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICAgICAqXG4gICAgICogIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSByZXZlcnNlLWRvbWFpbi1ub3RhdGlvbiwgd2hpY2ggcGVybWl0c1xuICAgICAqICB1bmlxdWUgbmFtZXMgd2l0aCBhIGtub3duIGF1dGhvcml0eSBhcyB3ZWxsIGFzIGhpZXJhcmNoYWwgZW50cmllcy5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTmV0d29ya1BsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHBsdWdpbi5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrUGx1Z2luKHRoaXMubmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkdhc0Nvc3RQbHVnaW4qKiBhbGxvd3MgYSBuZXR3b3JrIHRvIHByb3ZpZGUgYWx0ZXJuYXRpdmUgdmFsdWVzIHdoZW5cbiAqICBjb21wdXRpbmcgdGhlIGludHJpbnNpYyBnYXMgcmVxdWlyZWQgZm9yIGEgdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBHYXNDb3N0UGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgdG8gdHJlYXQgdGhlc2UgdmFsdWVzIGFzIHZhbGlkIGZyb20uXG4gICAgICpcbiAgICAgKiAgVGhpcyBhbGxvd3MgYSBoYXJkZm9yayB0byBoYXZlIHVwZGF0ZWQgdmFsdWVzIGluY2x1ZGVkIGFzIHdlbGwgYXNcbiAgICAgKiAgbXVsdXRpcGxlIGhhcmRmb3JrcyB0byBiZSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgZWZmZWN0aXZlQmxvY2s7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbnMgYmFzZSBmZWUuXG4gICAgICovXG4gICAgdHhCYXNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIGZvciBjcmVhdGluZyBhIG5ldyBhY2NvdW50LlxuICAgICAqL1xuICAgIHR4Q3JlYXRlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciB6ZXJvLWJ5dGUgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgdHhEYXRhWmVybztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgbm9uLXplcm8tYnl0ZSBpbiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICB0eERhdGFOb256ZXJvO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBzdG9yYWdlIGtleSBpbiB0aGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QuXG4gICAgICovXG4gICAgdHhBY2Nlc3NMaXN0U3RvcmFnZUtleTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgYWRkcmVzcyBpbiB0aGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QuXG4gICAgICovXG4gICAgdHhBY2Nlc3NMaXN0QWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBHYXNDb3N0UGx1Z2luIGZyb20gJSVlZmZlY3RpdmVCbG9jayUlIHVudGlsIHRoZVxuICAgICAqICBsYXRlc3QgYmxvY2sgb3IgYW5vdGhlciBHYXNDb3N0UGx1Z2luIHN1cGVyY2VkZXMgdGhhdCBibG9jayBudW1iZXIsXG4gICAgICogIHdpdGggdGhlIGFzc29jaWF0ZWQgJSVjb3N0cyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVmZmVjdGl2ZUJsb2NrLCBjb3N0cykge1xuICAgICAgICBpZiAoZWZmZWN0aXZlQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWZmZWN0aXZlQmxvY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGBvcmcuZXRoZXJzLm5ldHdvcmsucGx1Z2lucy5HYXNDb3N0IyR7KGVmZmVjdGl2ZUJsb2NrIHx8IDApfWApO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHsgZWZmZWN0aXZlQmxvY2sgfTtcbiAgICAgICAgZnVuY3Rpb24gc2V0KG5hbWUsIG51bGxpc2gpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IChjb3N0cyB8fCB7fSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbGlzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiLCBgaW52YWx1ZCB2YWx1ZSBmb3IgJHtuYW1lfWAsIFwiY29zdHNcIiwgY29zdHMpO1xuICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQoXCJ0eEJhc2VcIiwgMjEwMDApO1xuICAgICAgICBzZXQoXCJ0eENyZWF0ZVwiLCAzMjAwMCk7XG4gICAgICAgIHNldChcInR4RGF0YVplcm9cIiwgNCk7XG4gICAgICAgIHNldChcInR4RGF0YU5vbnplcm9cIiwgMTYpO1xuICAgICAgICBzZXQoXCJ0eEFjY2Vzc0xpc3RTdG9yYWdlS2V5XCIsIDE5MDApO1xuICAgICAgICBzZXQoXCJ0eEFjY2Vzc0xpc3RBZGRyZXNzXCIsIDI0MDApO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHByb3BzKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2FzQ29zdFBsdWdpbih0aGlzLmVmZmVjdGl2ZUJsb2NrLCB0aGlzKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiAqKkVuc1BsdWdpbioqIGFsbG93cyBhIFtbTmV0d29ya11dIHRvIHNwZWNpZnkgdGhlIEVOUyBSZWdpc3RyeVxuICogIENvbnRyYWN0IGFkZHJlc3MgYW5kIHRoZSB0YXJnZXQgbmV0d29yayB0byB1c2Ugd2hlbiB1c2luZyB0aGF0XG4gKiAgY29udHJhY3QuXG4gKlxuICogIFZhcmlvdXMgdGVzdG5ldHMgaGF2ZSB0aGVpciBvd24gaW5zdGFuY2Ugb2YgdGhlIGNvbnRyYWN0IHRvIHVzZSwgYnV0XG4gKiAgaW4gZ2VuZXJhbCwgdGhlIG1haW5uZXQgaW5zdGFuY2Ugc3VwcG9ydHMgbXVsdGktY2hhaW4gYWRkcmVzc2VzIGFuZFxuICogIHNob3VsZCBiZSB1c2VkLlxuICovXG5leHBvcnQgY2xhc3MgRW5zUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBFTlMgUmVnaXN0cnR5IENvbnRyYWN0IGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoYXQgdGhlIEVOUyBjb250cmFjdCBsaXZlcyBvbi5cbiAgICAgKi9cbiAgICB0YXJnZXROZXR3b3JrO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRW5zUGx1Z2luKiogY29ubmVjdGVkIHRvICUlYWRkcmVzcyUlIG9uIHRoZVxuICAgICAqICAlJXRhcmdldE5ldHdvcmslJS4gVGhlIGRlZmF1bHQgRU5TIGFkZHJlc3MgYW5kIG1haW5uZXQgaXMgdXNlZFxuICAgICAqICBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCB0YXJnZXROZXR3b3JrKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRW5zXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IChhZGRyZXNzIHx8IEVuc0FkZHJlc3MpLFxuICAgICAgICAgICAgdGFyZ2V0TmV0d29yazogKCh0YXJnZXROZXR3b3JrID09IG51bGwpID8gMSA6IHRhcmdldE5ldHdvcmspXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbnNQbHVnaW4odGhpcy5hZGRyZXNzLCB0aGlzLnRhcmdldE5ldHdvcmspO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqIGFsbG93cyBhIG5ldHdvcmsgdG8gcHJvdmlkZSBhbmQgYWx0ZXJuYXRlXG4gKiAgbWVhbnMgdG8gc3BlY2lmeSBpdHMgZmVlIGRhdGEuXG4gKlxuICogIEZvciBleGFtcGxlLCBhIG5ldHdvcmsgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBbW2xpbmstZWlwLTE1NTldXSBtYXlcbiAqICBjaG9vc2UgdG8gdXNlIGEgR2FzIFN0YXRpb24gc2l0ZSB0byBhcHByb3hpbWF0ZSB0aGUgZ2FzIHByaWNlLlxuICovXG5leHBvcnQgY2xhc3MgRmVlRGF0YU5ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAjZmVlRGF0YUZ1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgZGF0YSBmdW5jdGlvbiBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZ2V0IGZlZURhdGFGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmVlRGF0YUZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmVlRGF0YU5ldHdvcmtQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmZWVEYXRhRnVuYykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZlZURhdGFcIik7XG4gICAgICAgIHRoaXMuI2ZlZURhdGFGdW5jID0gZmVlRGF0YUZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZmVlIGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmVlRGF0YShwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmVlRGF0YUZ1bmMocHJvdmlkZXIpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGZWVEYXRhTmV0d29ya1BsdWdpbih0aGlzLiNmZWVEYXRhRnVuYyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAjdXJsO1xuICAgICNwcm9jZXNzRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIFVSTCB0byBpbml0aWFsaXplIHRoZSBGZXRjaFJlcXVlc3Qgd2l0aCBpbiAlJXByb2Nlc3NGdW5jJSUuXG4gICAgICovXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2FsbGJhY2sgdG8gdXNlIHdoZW4gY29tcHV0aW5nIHRoZSBGZWVEYXRhLlxuICAgICAqL1xuICAgIGdldCBwcm9jZXNzRnVuYygpIHsgcmV0dXJuIHRoaXMuI3Byb2Nlc3NGdW5jOyB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKiogd2hpY2ggd2lsbFxuICAgICAqICBiZSB1c2VkIHdoZW4gY29tcHV0aW5nIHRoZSBmZWUgZGF0YSBmb3IgdGhlIG5ldHdvcmsuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsLCBwcm9jZXNzRnVuYykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcbiAgICAgICAgdGhpcy4jdXJsID0gdXJsO1xuICAgICAgICB0aGlzLiNwcm9jZXNzRnVuYyA9IHByb2Nlc3NGdW5jO1xuICAgIH1cbiAgICAvLyBXZSBhcmUgaW1tdXRhYmxlLCBzbyB3ZSBjYW4gc2VydmUgYXMgb3VyIG93biBjbG9uZVxuICAgIGNsb25lKCkgeyByZXR1cm4gdGhpczsgfVxufVxuLypcbmV4cG9ydCBjbGFzcyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICByZWFkb25seSAjYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPjtcbiAgICByZWFkb25seSAjYmxvY2tXaXRoVHhzRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KSA9PiBCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPjtcblxuICAgIGNvbnN0cnVjdG9yKGJsb2NrRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pID0+IEJsb2NrPHN0cmluZz4sIGJsb2NrV2l0aFR4c0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPikgPT4gQmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT4pIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLm5ldHdvcmstcGx1Z2lucy5jdXN0b20tYmxvY2tcIik7XG4gICAgICAgIHRoaXMuI2Jsb2NrRnVuYyA9IGJsb2NrRnVuYztcbiAgICAgICAgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyA9IGJsb2NrV2l0aFR4c0Z1bmM7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QmxvY2socHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPik6IFByb21pc2U8QmxvY2s8c3RyaW5nPj4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYmxvY2tGdW5jKHByb3ZpZGVyLCBibG9jayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QmxvY2tpb25zKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KTogUHJvbWlzZTxCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPj4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyhwcm92aWRlciwgYmxvY2spO1xuICAgIH1cblxuICAgIGNsb25lKCk6IEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbiB7XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luKHRoaXMuI2Jsb2NrRnVuYywgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyk7XG4gICAgfVxufVxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbnMtbmV0d29yay5qcy5tYXAiLCIvKipcbiAqICBBICoqTmV0d29yayoqIGVuY2Fwc3VsYXRlcyB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvXG4gKiAgaW50ZXJhY3Qgd2l0aCBhIHNwZWNpZmljIGNoYWluLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnM6TmV0d29ya3MgIFtuZXR3b3Jrc11cbiAqL1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBFbnNQbHVnaW4sIEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4sIEdhc0Nvc3RQbHVnaW4gfSBmcm9tIFwiLi9wbHVnaW5zLW5ldHdvcmsuanNcIjtcbi8qICogKiAqXG4vLyBOZXR3b3JrcyB3aGljaCBvcGVyYXRpb24gYWdhaW5zdCBhbiBMMiBjYW4gdXNlIHRoaXMgcGx1Z2luIHRvXG4vLyBzcGVjaWZ5IGhvdyB0byBhY2Nlc3MgTDEsIGZvciB0aGUgcHVycG9zZSBvZiByZXNvbHZpbmcgRU5TLFxuLy8gZm9yIGV4YW1wbGUuXG5leHBvcnQgY2xhc3MgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgcmVhZG9ubHkgcHJvdmlkZXIhOiBQcm92aWRlcjtcbi8vIEBUT0RPOiBSZW5hbWUgdG8gQ2hhaW5BY2Nlc3MgYW5kIGFsbG93IGZvciBjb25uZWN0aW5nIHRvIGFueSBjaGFpblxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyOiBQcm92aWRlcikge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5sYXllci1vbmUtY29ubmVjdGlvblwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllczxMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4+KHRoaXMsIHsgcHJvdmlkZXIgfSk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4odGhpcy5wcm92aWRlcik7XG4gICAgfVxufVxuKi9cbmNvbnN0IE5ldHdvcmtzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiAgQSAqKk5ldHdvcmsqKiBwcm92aWRlcyBhY2Nlc3MgdG8gYSBjaGFpbidzIHByb3BlcnRpZXMgYW5kIGFsbG93c1xuICogIGZvciBwbHVnLWlucyB0byBleHRlbmQgZnVuY3Rpb25hbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmsge1xuICAgICNuYW1lO1xuICAgICNjaGFpbklkO1xuICAgICNwbHVnaW5zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTmV0d29yayoqIGZvciAlJW5hbWUlJSBhbmQgJSVjaGFpbklkJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgY2hhaW5JZCkge1xuICAgICAgICB0aGlzLiNuYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludChjaGFpbklkKTtcbiAgICAgICAgdGhpcy4jcGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24gb2YgYSBOZXR3b3JrLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogdGhpcy5uYW1lLCBjaGFpbklkOiBTdHJpbmcodGhpcy5jaGFpbklkKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5ldHdvcmsgY29tbW9uIG5hbWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB0aGUgY2Fub25pY2FsIG5hbWUsIGFzIG5ldHdvcmtzIG1pZ2ggaGF2ZSBtdWx0aXBsZVxuICAgICAqICBuYW1lcy5cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuI25hbWU7IH1cbiAgICBzZXQgbmFtZSh2YWx1ZSkgeyB0aGlzLiNuYW1lID0gdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5ldHdvcmsgY2hhaW4gSUQuXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludCh2YWx1ZSwgXCJjaGFpbklkXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgbWF0Y2hlcyB0aGlzIG5ldHdvcmsuIEFueSBjaGFpbiBJRFxuICAgICAqICBtdXN0IG1hdGNoLCBhbmQgaWYgbm8gY2hhaW4gSUQgaXMgcHJlc2VudCwgdGhlIG5hbWUgbXVzdCBtYXRjaC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjdXJyZW50bHkgY2hlY2sgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllcyxcbiAgICAgKiAgc3VjaCBhcyBFTlMgYWRkcmVzcyBvciBwbHVnLWluIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gICAgbWF0Y2hlcyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIChvdGhlcikgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlci5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxpc3Qgb2YgcGx1Z2lucyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBOZXR3b3JrLlxuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEF0dGFjaCBhIG5ldyAlJXBsdWdpbiUlIHRvIHRoaXMgTmV0d29yay4gVGhlIG5ldHdvcmsgbmFtZVxuICAgICAqICBtdXN0IGJlIHVuaXF1ZSwgZXhjbHVkaW5nIGFueSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNsb25lKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcGx1Z2luLCBpZiBhbnksIG1hdGNoaW5nICUlbmFtZSUlIGV4YWN0bHkuIFBsdWdpbnNcbiAgICAgKiAgd2l0aCBmcmFnbWVudHMgd2lsbCBub3QgYmUgcmV0dXJuZWQgdW5sZXNzICUlbmFtZSUlIGluY2x1ZGVzXG4gICAgICogIGEgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldHMgYSBsaXN0IG9mIGFsbCBwbHVnaW5zIHRoYXQgbWF0Y2ggJSVuYW1lJSUsIHdpdGggb3RyIHdpdGhvdXRcbiAgICAgKiAgYSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW5zKGJhc2VuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wbHVnaW5zLmZpbHRlcigocCkgPT4gKHAubmFtZS5zcGxpdChcIiNcIilbMF0gPT09IGJhc2VuYW1lKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIE5ldHdvcmsuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IE5ldHdvcmsodGhpcy5uYW1lLCB0aGlzLmNoYWluSWQpO1xuICAgICAgICB0aGlzLnBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICBjbG9uZS5hdHRhY2hQbHVnaW4ocGx1Z2luLmNsb25lKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBBIEdhc0Nvc3RQbHVnaW4gY2FuIGJlIGF0dGFjaGVkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0XG4gICAgICogIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjb21wdXRlSW50cmluc2ljR2FzKHR4KSB7XG4gICAgICAgIGNvbnN0IGNvc3RzID0gdGhpcy5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5HYXNDb3N0XCIpIHx8IChuZXcgR2FzQ29zdFBsdWdpbigpKTtcbiAgICAgICAgbGV0IGdhcyA9IGNvc3RzLnR4QmFzZTtcbiAgICAgICAgaWYgKHR4LnRvID09IG51bGwpIHtcbiAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eENyZWF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZGF0YSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0eC5kYXRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEuc3Vic3RyaW5nKGksIGkgKyAyKSA9PT0gXCIwMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFaZXJvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4RGF0YU5vbnplcm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeSh0eC5hY2Nlc3NMaXN0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWRkciBpbiBhY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4QWNjZXNzTGlzdEFkZHJlc3MgKyBjb3N0cy50eEFjY2Vzc0xpc3RTdG9yYWdlS2V5ICogYWNjZXNzTGlzdFthZGRyXS5zdG9yYWdlS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgTmV0d29yayBmb3IgdGhlICUlbmV0d29yayUlIG5hbWUgb3IgY2hhaW5JZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShuZXR3b3JrKSB7XG4gICAgICAgIGluamVjdENvbW1vbk5ldHdvcmtzKCk7XG4gICAgICAgIC8vIERlZmF1bHQgbmV0d29ya1xuICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKFwibWFpbm5ldFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW5vbmljYWwgbmFtZSBvciBjaGFpbiBJRFxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbmV0d29yayA9IEJpZ0ludChuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKG5ldHdvcmspID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrRnVuYyA9IE5ldHdvcmtzLmdldChuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrRnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrRnVuYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5ldHdvcmsoXCJ1bmtub3duXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbG9uYWJsZSB3aXRoIG5ldHdvcmstbGlrZSBhYmlsaXRpZXNcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jbG9uZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBuZXR3b3JrLmNsb25lKCk7XG4gICAgICAgICAgICAvL2lmICh0eXBlb2YobmV0d29yay5uYW1lKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV0d29ya2lzaFxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuZXR3b3JrLm5hbWUpID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiAobmV0d29yay5jaGFpbklkKSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIG5ldHdvcmsgb2JqZWN0IG5hbWUgb3IgY2hhaW5JZFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICBjb25zdCBjdXN0b20gPSBuZXcgTmV0d29yaygobmV0d29yay5uYW1lKSwgKG5ldHdvcmsuY2hhaW5JZCkpO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBuZXR3b3JrLmVuc05ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbS5hdHRhY2hQbHVnaW4obmV3IEVuc1BsdWdpbihuZXR3b3JrLmVuc0FkZHJlc3MsIG5ldHdvcmsuZW5zTmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pZiAoKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4oKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSk7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlZ2lzdGVyICUlbmFtZU9yQ2hhaW5JZCUlIHdpdGggYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zXG4gICAgICogIGFuIGluc3RhbmNlIG9mIGEgTmV0d29yayByZXByZXNlbnRpbmcgdGhhdCBjaGFpbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXIobmFtZU9yQ2hhaW5JZCwgbmV0d29ya0Z1bmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAobmFtZU9yQ2hhaW5JZCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5hbWVPckNoYWluSWQgPSBCaWdJbnQobmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBOZXR3b3Jrcy5nZXQobmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBjb25mbGljdGluZyBuZXR3b3JrIGZvciAke0pTT04uc3RyaW5naWZ5KGV4aXN0aW5nLm5hbWUpfWAsIFwibmFtZU9yQ2hhaW5JZFwiLCBuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBOZXR3b3Jrcy5zZXQobmFtZU9yQ2hhaW5JZCwgbmV0d29ya0Z1bmMpO1xuICAgIH1cbn1cbi8vIFdlIGRvbid0IHdhbnQgdG8gYnJpbmcgaW4gZm9ybWF0VW5pdHMgYmVjYXVzZSBpdCBpcyBiYWNrZWQgYnlcbi8vIEZpeGVkTnVtYmVyIGFuZCB3ZSB3YW50IHRvIGtlZXAgTmV0d29ya3MgdGlueS4gVGhlIHZhbHVlc1xuLy8gaW5jbHVkZWQgYnkgdGhlIEdhcyBTdGF0aW9ucyBhcmUgYWxzbyBJRUVFIDc1NCB3aXRoIGxvdHMgb2Zcbi8vIHJvdW5kaW5nIGlzc3VlcyBhbmQgZXhjZWVkIHRoZSBzdHJpY3QgY2hlY2tzIGZvcm1hdFVuaXRzIGhhcy5cbmZ1bmN0aW9uIHBhcnNlVW5pdHMoX3ZhbHVlLCBkZWNpbWFscykge1xuICAgIGNvbnN0IHZhbHVlID0gU3RyaW5nKF92YWx1ZSk7XG4gICAgaWYgKCF2YWx1ZS5tYXRjaCgvXlswLTkuXSskLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGd3ZWkgdmFsdWU6ICR7X3ZhbHVlfWApO1xuICAgIH1cbiAgICAvLyBCcmVhayBpbnRvIFsgd2hvbGUsIGZyYWN0aW9uIF1cbiAgICBjb25zdCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbXBzLnB1c2goXCJcIik7XG4gICAgfVxuICAgIC8vIE1vcmUgdGhhbiAxIGRlY2ltYWwgcG9pbnQgb3IgdG9vIG1hbnkgZnJhY3Rpb25hbCBwb3NpdGlvbnNcbiAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gUGFkIHRoZSBmcmFjdGlvbiB0byA5IGRlY2ltYWxwbGFjZXNcbiAgICB3aGlsZSAoY29tcHNbMV0ubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgY29tcHNbMV0gKz0gXCIwXCI7XG4gICAgfVxuICAgIC8vIFRvbyBtYW55IGRlY2ltYWxzIGFuZCBzb21lIG5vbi16ZXJvIGVuZGluZywgdGFrZSB0aGUgY2VpbGluZ1xuICAgIGlmIChjb21wc1sxXS5sZW5ndGggPiA5KSB7XG4gICAgICAgIGxldCBmcmFjID0gQmlnSW50KGNvbXBzWzFdLnN1YnN0cmluZygwLCA5KSk7XG4gICAgICAgIGlmICghY29tcHNbMV0uc3Vic3RyaW5nKDkpLm1hdGNoKC9eMCskLykpIHtcbiAgICAgICAgICAgIGZyYWMrKztcbiAgICAgICAgfVxuICAgICAgICBjb21wc1sxXSA9IGZyYWMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChjb21wc1swXSArIGNvbXBzWzFdKTtcbn1cbi8vIFVzZWQgYnkgUG9seWdvbiB0byB1c2UgYSBnYXMgc3RhdGlvbiBmb3IgZmVlIGRhdGFcbmZ1bmN0aW9uIGdldEdhc1N0YXRpb25QbHVnaW4odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKHVybCwgYXN5bmMgKGZldGNoRmVlRGF0YSwgcHJvdmlkZXIsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgLy8gUHJldmVudCBDbG91ZGZsYXJlIGZyb20gYmxvY2tpbmcgb3VyIHJlcXVlc3QgaW4gbm9kZS5qc1xuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcIlVzZXItQWdlbnRcIiwgXCJldGhlcnNcIik7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtfcmVzcG9uc2UsIF9mZWVEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKSwgZmV0Y2hGZWVEYXRhKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBfcmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzcG9uc2UuYm9keUpzb24uc3RhbmRhcmQ7XG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0ge1xuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBfZmVlRGF0YS5nYXNQcmljZSxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHBhcnNlVW5pdHMocGF5bG9hZC5tYXhGZWUsIDkpLFxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBwYXJzZVVuaXRzKHBheWxvYWQubWF4UHJpb3JpdHlGZWUsIDkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmZWVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgZXJyb3IgZW5jb3VudGVyZWQgd2l0aCBwb2x5Z29uIGdhcyBzdGF0aW9uICgke0pTT04uc3RyaW5naWZ5KHJlcXVlc3QudXJsKX0pYCwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIFNlZTogaHR0cHM6Ly9jaGFpbmxpc3Qub3JnXG5sZXQgaW5qZWN0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluamVjdENvbW1vbk5ldHdvcmtzKCkge1xuICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICAvLy8gUmVnaXN0ZXIgcG9wdWxhciBFdGhlcmV1bSBuZXR3b3Jrc1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRXRoKG5hbWUsIGNoYWluSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXcgTmV0d29yayhuYW1lLCBjaGFpbklkKTtcbiAgICAgICAgICAgIC8vIFdlIHVzZSAwIHRvIGRpc2FibGUgRU5TXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbnNOZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihuZXcgRW5zUGx1Z2luKG51bGwsIG9wdGlvbnMuZW5zTmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4obmV3IEdhc0Nvc3RQbHVnaW4oKSk7XG4gICAgICAgICAgICAob3B0aW9ucy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKChwbHVnaW4pID0+IHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIG5ldHdvcmsgYnkgbmFtZSBhbmQgY2hhaW4gSURcbiAgICAgICAgTmV0d29yay5yZWdpc3RlcihuYW1lLCBmdW5jKTtcbiAgICAgICAgTmV0d29yay5yZWdpc3RlcihjaGFpbklkLCBmdW5jKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWx0TmFtZXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYWx0TmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlckV0aChcIm1haW5uZXRcIiwgMSwgeyBlbnNOZXR3b3JrOiAxLCBhbHROYW1lczogW1wiaG9tZXN0ZWFkXCJdIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwicm9wc3RlblwiLCAzLCB7IGVuc05ldHdvcms6IDMgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJyaW5rZWJ5XCIsIDQsIHsgZW5zTmV0d29yazogNCB9KTtcbiAgICByZWdpc3RlckV0aChcImdvZXJsaVwiLCA1LCB7IGVuc05ldHdvcms6IDUgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJrb3ZhblwiLCA0MiwgeyBlbnNOZXR3b3JrOiA0MiB9KTtcbiAgICByZWdpc3RlckV0aChcInNlcG9saWFcIiwgMTExNTUxMTEsIHsgZW5zTmV0d29yazogMTExNTUxMTEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJob2xlc2t5XCIsIDE3MDAwLCB7IGVuc05ldHdvcms6IDE3MDAwIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY1wiLCA2MSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY0tvdHRpXCIsIDYsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImFyYml0cnVtXCIsIDQyMTYxLCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bS1nb2VybGlcIiwgNDIxNjEzLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bS1zZXBvbGlhXCIsIDQyMTYxNCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZVwiLCA4NDUzLCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJiYXNlLWdvZXJsaVwiLCA4NDUzMSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1zZXBvbGlhXCIsIDg0NTMyLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJibmJcIiwgNTYsIHsgZW5zTmV0d29yazogMSB9KTtcbiAgICByZWdpc3RlckV0aChcImJuYnRcIiwgOTcsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhXCIsIDU5MTQ0LCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1nb2VybGlcIiwgNTkxNDAsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhLXNlcG9saWFcIiwgNTkxNDEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljXCIsIDEzNywge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICBnZXRHYXNTdGF0aW9uUGx1Z2luKFwiaHR0cHM6L1xcL2dhc3N0YXRpb24ucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljLWFtb3lcIiwgODAwMDIsIHt9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljLW11bWJhaVwiLCA4MDAwMSwge1xuICAgICAgICBhbHROYW1lczogW1wibWF0aWNNdW1iYWlcIiwgXCJtYXRpY211bVwiXSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLXRlc3RuZXQucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm9wdGltaXNtXCIsIDEwLCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgICAgIHBsdWdpbnM6IFtdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbS1nb2VybGlcIiwgNDIwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbS1zZXBvbGlhXCIsIDExMTU1NDIwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJ4ZGFpXCIsIDEwMCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29yay5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBwb2xsaW5nIHN1YnNjcmliZXIgZm9yIGNvbW1vbiBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2xsaW5nU3Vic2NyaWJlcihwcm92aWRlciwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgPT09IFwiYmxvY2tcIikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIocHJvdmlkZXIpO1xuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcoZXZlbnQsIDMyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIocHJvdmlkZXIsIGV2ZW50KTtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHBvbGxpbmcgZXZlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZ2V0UG9sbGluZ1N1YnNjcmliZXJcIiwgaW5mbzogeyBldmVudCB9XG4gICAgfSk7XG59XG4vLyBAVE9ETzogcmVmYWN0b3IgdGhpc1xuLyoqXG4gKiAgQSAqKlBvbGxpbmdCbG9ja1N1YnNjcmliZXIqKiBwb2xscyBhdCBhIHJlZ3VsYXIgaW50ZXJ2YWwgZm9yIGEgY2hhbmdlXG4gKiAgaW4gdGhlIGJsb2NrIG51bWJlci5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdCbG9ja1N1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjcG9sbGVyO1xuICAgICNpbnRlcnZhbDtcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgd2UgaGF2ZSBzY2FubmVkIGZvciBldmVudHMuIFRoZSB2YWx1ZSAtMlxuICAgIC8vIGluZGljYXRlcyB3ZSBzdGlsbCBuZWVkIHRvIGZldGNoIGFuIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgI2Jsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuI2ludGVydmFsID0gNDAwMDtcbiAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwb2xsaW5nIGludGVydmFsLlxuICAgICAqL1xuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNpbnRlcnZhbDsgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHsgdGhpcy4jaW50ZXJ2YWwgPSB2YWx1ZTsgfVxuICAgIGFzeW5jICNwb2xsKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAgICAgLy8gQm9vdHN0cmFwIHBvbGwgdG8gc2V0dXAgb3VyIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAVE9ETzogUHV0IGEgY2FwIG9uIHRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgcGVyIGxvb3A/XG4gICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgIT09IHRoaXMuI2Jsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiA9IHRoaXMuI2Jsb2NrTnVtYmVyICsgMTsgYiA8PSBibG9ja051bWJlcjsgYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYmVlbiBzdG9wcGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwb2xsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmVtaXQoXCJibG9ja1wiLCBiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBNaW5vciBidW1wLCBhZGQgYW4gXCJlcnJvclwiIGV2ZW50IHRvIGxldCBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgLy8gICAgICAgIGtub3cgdGhpbmdzIHdlbnQgYXdyeS5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgYmVlbiBzdG9wcGVkXG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3Byb3ZpZGVyLl9zZXRUaW1lb3V0KHRoaXMuI3BvbGwuYmluZCh0aGlzKSwgdGhpcy4jaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3Byb3ZpZGVyLl9zZXRUaW1lb3V0KHRoaXMuI3BvbGwuYmluZCh0aGlzKSwgdGhpcy4jaW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLiNwb2xsKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcG9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIuX2NsZWFyVGltZW91dCh0aGlzLiNwb2xsZXIpO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gKipPbkJsb2NrU3Vic2NyaWJlcioqIGNhbiBiZSBzdWItY2xhc3NlZCwgd2l0aCBhIFtbX3BvbGxdXVxuICogIGltcGxtZW50YXRpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjcG9sbDtcbiAgICAjcnVubmluZztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqT25CbG9ja1N1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwb2xsID0gKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wb2xsKGJsb2NrTnVtYmVyLCB0aGlzLiNwcm92aWRlcik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxuICAgICAqL1xuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwb2xsKC0yKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub24oXCJibG9ja1wiLCB0aGlzLiNwb2xsKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7IHRoaXMuc3RvcCgpOyB9XG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cbn1cbmV4cG9ydCBjbGFzcyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICN0YWc7XG4gICAgI2xhc3RCbG9jaztcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgdGFnKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jdGFnID0gdGFnO1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSAtMjtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCk7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrKHRoaXMuI3RhZyk7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9jayA9PT0gLTIpIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IGJsb2NrLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9jay5udW1iZXIgPiB0aGlzLiNsYXN0QmxvY2spIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jdGFnLCBibG9jay5udW1iZXIpO1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gYmxvY2subnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjZmlsdGVyO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBjb3B5KGZpbHRlcik7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy4jZmlsdGVyKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvblxuICogIGhhc2ggZm9yIGl0cyByZWNlaXB0LlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjaGFzaDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJSwgbGlzdGVuaW5nIGZvciAlJWhhc2glJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgaGFzaCkge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2hhc2ggPSBoYXNoO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaGFzaCk7XG4gICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiNoYXNoLCB0eCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBBICoqUG9sbGluZ0V2ZW50U3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiBmaWx0ZXIgZm9yIGl0cyBsb2dzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXI7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgd2UgaGF2ZSBzY2FubmVkIGZvciBldmVudHMuIFRoZSB2YWx1ZSAtMlxuICAgIC8vIGluZGljYXRlcyB3ZSBzdGlsbCBuZWVkIHRvIGZldGNoIGFuIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgI2Jsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLCBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBjb3B5KGZpbHRlcik7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgIH1cbiAgICBhc3luYyAjcG9sbChibG9ja051bWJlcikge1xuICAgICAgICAvLyBUaGUgaW5pdGlhbCBibG9jayBoYXNuJ3QgYmVlbiBkZXRlcm1pbmVkIHlldFxuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyID0gY29weSh0aGlzLiNmaWx0ZXIpO1xuICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gdGhpcy4jYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICBmaWx0ZXIudG9CbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICAvLyBObyBsb2dzIGNvdWxkIGp1c3QgbWVhbiB0aGUgbm9kZSBoYXMgbm90IGluZGV4ZWQgdGhlbSB5ZXQsXG4gICAgICAgIC8vIHNvIHdlIGtlZXAgYSBzbGlkaW5nIHdpbmRvdyBvZiA2MCBibG9ja3MgdG8ga2VlcCBzY2FubmluZ1xuICAgICAgICBpZiAobG9ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA8IGJsb2NrTnVtYmVyIC0gNjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuZW1pdCh0aGlzLiNmaWx0ZXIsIGxvZyk7XG4gICAgICAgICAgICAvLyBPbmx5IGFkdmFuY2UgdGhlIGJsb2NrIG51bWJlciB3aGVuIGxvZ3Mgd2VyZSBmb3VuZCB0b1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgbmV0d29ya3MgKGxpa2UgQk5CIGFuZCBQb2x5Z29uKSB3aGljaCBtYXlcbiAgICAgICAgICAgIC8vIHNhY3JpZmljZSBldmVudCBjb25zaXN0ZW5jeSBmb3IgYmxvY2sgZXZlbnQgc3BlZWRcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5nZXRCbG9ja051bWJlcigpLnRoZW4oKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1wb2xsaW5nLmpzLm1hcCIsIi8qKlxuICogIFRoZSBhdmFpbGFibGUgcHJvdmlkZXJzIHNob3VsZCBzdWZmaWNlIGZvciBtb3N0IGRldmVsb3BlcnMgcHVycG9zZXMsXG4gKiAgYnV0IHRoZSBbW0Fic3RyYWN0UHJvdmlkZXJdXSBjbGFzcyBoYXMgbWFueSBmZWF0dXJlcyB3aGljaCBlbmFibGVcbiAqICBzdWItY2xhc3NpbmcgaXQgZm9yIHNwZWNpZmljIHB1cnBvc2VzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXI6IFN1YmNsYXNzaW5nIFByb3ZpZGVyICBbYWJzdHJhY3QtcHJvdmlkZXJdXG4gKi9cbi8vIEBUT0RPXG4vLyBFdmVudCBjb2FsZXNjZW5jZVxuLy8gICBXaGVuIHdlIHJlZ2lzdGVyIGFuIGV2ZW50IHdpdGggYW4gYXN5bmMgdmFsdWUgKGUuZy4gYWRkcmVzcyBpcyBhIFNpZ25lclxuLy8gICBvciBFTlMgbmFtZSksIHdlIG5lZWQgdG8gYWRkIGl0IGltbWVpZGF0ZWx5IGZvciB0aGUgRXZlbnQgQVBJLCBidXQgYWxzb1xuLy8gICBuZWVkIHRpbWUgdG8gcmVzb2x2ZSB0aGUgYWRkcmVzcy4gVXBvbiByZXNvbHZpbmcgdGhlIGFkZHJlc3MsIHdlIG5lZWQgdG9cbi8vICAgbWlncmF0ZSB0aGUgbGlzdGVuZXIgdG8gdGhlIHN0YXRpYyBldmVudC4gV2UgYWxzbyBuZWVkIHRvIG1haW50YWluIGEgbWFwXG4vLyAgIG9mIFNpZ25lci9FTlMgbmFtZSB0byBhZGRyZXNzIHNvIHdlIGNhbiBzeW5jIHJlc3BvbmQgdG8gbGlzdGVuZXJDb3VudC5cbmltcG9ydCB7IGdldEFkZHJlc3MsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3QgfSBmcm9tIFwiLi4vY29udHJhY3QvaW5kZXguanNcIjtcbmltcG9ydCB7IG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFMZW5ndGgsIGRhdGFTbGljZSwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGdldE51bWJlciwgaXNDYWxsRXhjZXB0aW9uLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCwgdG9CZUFycmF5LCB0b1F1YW50aXR5LCBkZWZpbmVQcm9wZXJ0aWVzLCBFdmVudFBheWxvYWQsIHJlc29sdmVQcm9wZXJ0aWVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEVuc1Jlc29sdmVyIH0gZnJvbSBcIi4vZW5zLXJlc29sdmVyLmpzXCI7XG5pbXBvcnQgeyBmb3JtYXRCbG9jaywgZm9ybWF0TG9nLCBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQsIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi9mb3JtYXQuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBjb3B5UmVxdWVzdCwgQmxvY2ssIEZlZURhdGEsIExvZywgVHJhbnNhY3Rpb25SZWNlaXB0LCBUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIsIFBvbGxpbmdCbG9ja1RhZ1N1YnNjcmliZXIsIFBvbGxpbmdFdmVudFN1YnNjcmliZXIsIFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyLCBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XG4vLyBDb25zdGFudHNcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBNQVhfQ0NJUF9SRURJUkVDVFMgPSAxMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS50aGVuKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGdldFRhZyhwcmVmaXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHByZWZpeCArIFwiOlwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrLCB2KSA9PiB7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGBiaWdpbnQ6JHt2LnRvU3RyaW5nKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHYudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0IG9iamVjdCBrZXlzXG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModik7XG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBrZXlzLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtW2tleV0gPSB2W2tleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0pO1xufVxuLyoqXG4gKiAgQW4gKipVbm1hbmFnZWRTdWJzY3JpYmVyKiogaXMgdXNlZnVsIGZvciBldmVudHMgd2hpY2ggZG8gbm90IHJlcXVpcmVcbiAqICBhbnkgYWRkaXRpb25hbCBtYW5hZ2VtZW50LCBzdWNoIGFzIGBgXCJkZWJ1Z1wiYGAgd2hpY2ggb25seSByZXF1aXJlc1xuICogIGVtaXQgaW4gc3luY2hyb25vdXMgZXZlbnQgbG9vcCB0cmlnZ2VyZWQgY2FsbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBVbm1hbmFnZWRTdWJzY3JpYmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgZm9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlciB3aXRoICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHsgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7IH1cbiAgICBzdGFydCgpIHsgfVxuICAgIHN0b3AoKSB7IH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHsgfVxuICAgIHJlc3VtZSgpIHsgfVxufVxuZnVuY3Rpb24gY29weSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBjb25jaXNpZnkoaXRlbXMpIHtcbiAgICBpdGVtcyA9IEFycmF5LmZyb20oKG5ldyBTZXQoaXRlbXMpKS52YWx1ZXMoKSk7XG4gICAgaXRlbXMuc29ydCgpO1xuICAgIHJldHVybiBpdGVtcztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbihfZXZlbnQsIHByb3ZpZGVyKSB7XG4gICAgaWYgKF9ldmVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnRcIik7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSB0b3BpYyBhcnJheSBpbmZvIGFuIEV2ZW50RmlsdGVyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2V2ZW50KSkge1xuICAgICAgICBfZXZlbnQgPSB7IHRvcGljczogX2V2ZW50IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKF9ldmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3dpdGNoIChfZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IF9ldmVudCwgdGFnOiBfZXZlbnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcoX2V2ZW50LCAzMikpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IF9ldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRyYW5zYWN0aW9uXCIsIHRhZzogZ2V0VGFnKFwidHhcIiwgeyBoYXNoIH0pLCBoYXNoIH07XG4gICAgfVxuICAgIGlmIChfZXZlbnQub3JwaGFuKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICAvLyBAVE9ETzogU2hvdWxkIGxvd2VyY2FzZSBhbmQgd2hhdG5vdCB0aGluZ3MgaGVyZSBpbnN0ZWFkIG9mIGNvcHkuLi5cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJvcnBoYW5cIiwgdGFnOiBnZXRUYWcoXCJvcnBoYW5cIiwgZXZlbnQpLCBmaWx0ZXI6IGNvcHkoZXZlbnQpIH07XG4gICAgfVxuICAgIGlmICgoX2V2ZW50LmFkZHJlc3MgfHwgX2V2ZW50LnRvcGljcykpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZXZlbnQ7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgIHRvcGljczogKChldmVudC50b3BpY3MgfHwgW10pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25jaXNpZnkodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChldmVudC5hZGRyZXNzKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBhZGRBZGRyZXNzID0gKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYWRkcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYWRkcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhd2FpdCByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICBldmVudC5hZGRyZXNzLmZvckVhY2goYWRkQWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRBZGRyZXNzKGV2ZW50LmFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gY29uY2lzaWZ5KGFkZHJlc3Nlcy5tYXAoKGEpID0+IGEudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZpbHRlciwgdGFnOiBnZXRUYWcoXCJldmVudFwiLCBmaWx0ZXIpLCB0eXBlOiBcImV2ZW50XCIgfTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBQcm92aWRlckV2ZW50XCIsIFwiZXZlbnRcIiwgX2V2ZW50KTtcbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBjYWNoZVRpbWVvdXQ6IDI1MCxcbiAgICBwb2xsaW5nSW50ZXJ2YWw6IDQwMDBcbn07XG4vKipcbiAqICBBbiAqKkFic3RyYWN0UHJvdmlkZXIqKiBwcm92aWRlcyBhIGJhc2UgY2xhc3MgZm9yIG90aGVyIHN1Yi1jbGFzc2VzIHRvXG4gKiAgaW1wbGVtZW50IHRoZSBbW1Byb3ZpZGVyXV0gQVBJIGJ5IG5vcm1hbGl6aW5nIGlucHV0IGFyZ3VtZW50cyBhbmRcbiAqICBmb3JtYXR0aW5nIG91dHB1dCByZXN1bHRzIGFzIHdlbGwgYXMgdHJhY2tpbmcgZXZlbnRzIGZvciBjb25zaXN0ZW50XG4gKiAgYmVoYXZpb3VyIG9uIGFuIGV2ZW50dWFsbHktY29uc2lzdGVudCBuZXR3b3JrLlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI3N1YnM7XG4gICAgI3BsdWdpbnM7XG4gICAgLy8gbnVsbD11bnBhdXNlZCwgdHJ1ZT1wYXVzZWQrZHJvcFdoaWxlUGF1c2VkLCBmYWxzZT1wYXVzZWRcbiAgICAjcGF1c2VkU3RhdGU7XG4gICAgI2Rlc3Ryb3llZDtcbiAgICAjbmV0d29ya1Byb21pc2U7XG4gICAgI2FueU5ldHdvcms7XG4gICAgI3BlcmZvcm1DYWNoZTtcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgbnVtYmVyIGlmIHJ1bm5pbmcgYW4gZXZlbnQgb3IgLTEgaWYgbm8gXCJibG9ja1wiIGV2ZW50XG4gICAgI2xhc3RCbG9ja051bWJlcjtcbiAgICAjbmV4dFRpbWVyO1xuICAgICN0aW1lcnM7XG4gICAgI2Rpc2FibGVDY2lwUmVhZDtcbiAgICAjb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQWJzdHJhY3RQcm92aWRlcioqIGNvbm5lY3RlZCB0byAlJW5ldHdvcmslJSwgb3JcbiAgICAgKiAgdXNlIHRoZSB2YXJpb3VzIG5ldHdvcmsgZGV0ZWN0aW9uIGNhcGFiaWxpdGllcyB0byBkaXNjb3ZlciB0aGVcbiAgICAgKiAgW1tOZXR3b3JrXV0gaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGlmIChfbmV0d29yayA9PT0gXCJhbnlcIikge1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX25ldHdvcmspIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBOZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUobmV0d29yayk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTsgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFzdEJsb2NrTnVtYmVyID0gLTE7XG4gICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jc3VicyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLiNkZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV4dFRpbWVyID0gMTtcbiAgICAgICAgdGhpcy4jdGltZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI29wdGlvbnMucG9sbGluZ0ludGVydmFsOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0aGlzYGAsIHRvIGFsbG93IGFuICoqQWJzdHJhY3RQcm92aWRlcioqIHRvIGltcGxlbWVudFxuICAgICAqICB0aGUgW1tDb250cmFjdFJ1bm5lcl1dIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBnZXQgcHJvdmlkZXIoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYWxsIHRoZSByZWdpc3RlcmVkIHBsdWctaW5zLlxuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEF0dGFjaCBhIG5ldyBwbHVnLWluLlxuICAgICAqL1xuICAgIGF0dGFjaFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbnMuZ2V0KHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVwbGFjZSBleGlzdGluZyBwbHVnaW46ICR7cGx1Z2luLm5hbWV9IGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BsdWdpbnMuc2V0KHBsdWdpbi5uYW1lLCBwbHVnaW4uY29ubmVjdCh0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IGEgcGx1Z2luIGJ5IG5hbWUuXG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByZXZlbnQgYW55IENDSVAtcmVhZCBvcGVyYXRpb24sIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciByZXF1ZXN0ZWRcbiAgICAgKiAgaW4gYSBbW2NhbGxdXSB1c2luZyBgYGVuYWJsZUNjaXBSZWFkYGAuXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVDY2lwUmVhZCgpIHsgcmV0dXJuIHRoaXMuI2Rpc2FibGVDY2lwUmVhZDsgfVxuICAgIHNldCBkaXNhYmxlQ2NpcFJlYWQodmFsdWUpIHsgdGhpcy4jZGlzYWJsZUNjaXBSZWFkID0gISF2YWx1ZTsgfVxuICAgIC8vIFNoYXJlcyBtdWx0aXBsZSBpZGVudGljYWwgcmVxdWVzdHMgbWFkZSBkdXJpbmcgdGhlIHNhbWUgMjUwbXNcbiAgICBhc3luYyAjcGVyZm9ybShyZXEpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuI29wdGlvbnMuY2FjaGVUaW1lb3V0O1xuICAgICAgICAvLyBDYWNoaW5nIGRpc2FibGVkXG4gICAgICAgIGlmICh0aW1lb3V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3BlcmZvcm0ocmVxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSB0YWdcbiAgICAgICAgY29uc3QgdGFnID0gZ2V0VGFnKHJlcS5tZXRob2QsIHJlcSk7XG4gICAgICAgIGxldCBwZXJmb3JtID0gdGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpO1xuICAgICAgICBpZiAoIXBlcmZvcm0pIHtcbiAgICAgICAgICAgIHBlcmZvcm0gPSB0aGlzLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUuc2V0KHRhZywgcGVyZm9ybSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpID09PSBwZXJmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZS5kZWxldGUodGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBkYXRhIGZvciBleGVjdXRpbmcgdGhlIENDSVAtcmVhZCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGNjaXBSZWFkRmV0Y2godHgsIGNhbGxkYXRhLCB1cmxzKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVDY2lwUmVhZCB8fCB1cmxzLmxlbmd0aCA9PT0gMCB8fCB0eC50byA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kZXIgPSB0eC50by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0gY2FsbGRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHVybHNbaV07XG4gICAgICAgICAgICAvLyBVUkwgZXhwYW5zaW9uXG4gICAgICAgICAgICBjb25zdCBocmVmID0gdXJsLnJlcGxhY2UoXCJ7c2VuZGVyfVwiLCBzZW5kZXIpLnJlcGxhY2UoXCJ7ZGF0YX1cIiwgZGF0YSk7XG4gICAgICAgICAgICAvLyBJZiBubyB7ZGF0YX0gaXMgcHJlc2VudCwgdXNlIFBPU1Q7IG90aGVyd2lzZSBHRVRcbiAgICAgICAgICAgIC8vY29uc3QganNvbjogc3RyaW5nIHwgbnVsbCA9ICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA+PSAwKSA/IG51bGw6IEpTT04uc3RyaW5naWZ5KHsgZGF0YSwgc2VuZGVyIH0pO1xuICAgICAgICAgICAgLy9jb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaEpzb24oeyB1cmw6IGhyZWYsIGVycm9yUGFzc1Rocm91Z2g6IHRydWUgfSwganNvbiwgKHZhbHVlLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgdmFsdWUuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgICAgIC8vICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIC8vfSk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdChocmVmKTtcbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJvZHkgPSB7IGRhdGEsIHNlbmRlciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZENjaXBSZWFkRmV0Y2hSZXF1ZXN0XCIsIHJlcXVlc3QsIGluZGV4OiBpLCB1cmxzIH0pO1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IFwidW5rbm93biBlcnJvclwiO1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHJlc291cmNlLi4uXG4gICAgICAgICAgICBsZXQgcmVzcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcCA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4ubG93LWxldmVsIGZldGNoIGVycm9yIChtaXNzaW5nIGhvc3QsIGJhZCBTU0wsIGV0Yy4pLFxuICAgICAgICAgICAgICAgIC8vIHNvIHRyeSBuZXh0IFVSTFxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZXMucHVzaChlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaEVycm9yXCIsIHJlcXVlc3QsIHJlc3VsdDogeyBlcnJvciB9IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwLmJvZHlKc29uO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaFJlc3VsdFwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaEVycm9yXCIsIHJlcXVlc3QsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAvLyA0eHggaW5kaWNhdGVzIHRoZSByZXN1bHQgaXMgbm90IHByZXNlbnQ7IHN0b3BcbiAgICAgICAgICAgIGFzc2VydChyZXNwLnN0YXR1c0NvZGUgPCA0MDAgfHwgcmVzcC5zdGF0dXNDb2RlID49IDUwMCwgYHJlc3BvbnNlIG5vdCBmb3VuZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2V9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7IHJlYXNvbjogXCI0MDRfTUlTU0lOR19SRVNPVVJDRVwiLCB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJsLCBlcnJvck1lc3NhZ2UgfSB9KTtcbiAgICAgICAgICAgIC8vIDV4eCBpbmRpY2F0ZXMgc2VydmVyIGlzc3VlOyB0cnkgdGhlIG5leHQgdXJsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2VzLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobSkpLmpvaW4oXCIsIFwiKX1gLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCI1MDBfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJscywgZXJyb3JNZXNzYWdlcyB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgYmxvY2sgYmVmb3JlXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbQmxvY2tdXS5cbiAgICAgKi9cbiAgICBfd3JhcEJsb2NrKHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2soZm9ybWF0QmxvY2sodmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGxvZyBiZWZvcmVcbiAgICAgKiAgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuIGFsdGVybmF0ZVxuICAgICAqICBzdWItY2xhc3Mgb2YgW1tMb2ddXS5cbiAgICAgKi9cbiAgICBfd3JhcExvZyh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IExvZyhmb3JtYXRMb2codmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIHRyYW5zYWN0aW9uXG4gICAgICogIHJlY2VpcHQgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxuICAgICAqICBhbHRlcm5hdGUgc3ViLWNsYXNzIG9mIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gICAgICovXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlY2VpcHQoZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSB0cmFuc2FjdGlvblxuICAgICAqICByZXNwb25zZSBiZWZvcmUgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuXG4gICAgICogIGFsdGVybmF0ZSBzdWItY2xhc3Mgb2YgW1tUcmFuc2FjdGlvblJlc3BvbnNlXV0uXG4gICAgICovXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZShmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHR4KSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgTmV0d29yaywgZm9yY2luZyBhIG5ldHdvcmsgZGV0ZWN0aW9uIHVzaW5nIHdoYXRldmVyXG4gICAgICogIHRlY2huaXF1ZSB0aGUgc3ViLWNsYXNzIHJlcXVpcmVzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXG4gICAgICovXG4gICAgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJzdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJfZGV0ZWN0TmV0d29ya1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgc2hvdWxkIHVzZSB0aGlzIHRvIHBlcmZvcm0gYWxsIGJ1aWx0LWluIG9wZXJhdGlvbnMuIEFsbFxuICAgICAqICBtZXRob2RzIHNhbml0aXplcyBhbmQgbm9ybWFsaXplcyB0aGUgdmFsdWVzIHBhc3NlZCBpbnRvIHRoaXMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcy5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5zdXBwb3J0ZWQgbWV0aG9kOiAke3JlcS5tZXRob2R9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiByZXEubWV0aG9kLFxuICAgICAgICAgICAgaW5mbzogcmVxXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTdGF0ZVxuICAgIGFzeW5jIGdldEJsb2NrTnVtYmVyKCkge1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGdldE51bWJlcihhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldEJsb2NrTnVtYmVyXCIgfSksIFwiJXJlc3BvbnNlXCIpO1xuICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9ja051bWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gdGhlIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLCByZXNvbHZpbmcgRU5TXG4gICAgICogIG5hbWVzIGFuZCBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0cyBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYW5cbiAgICAgKiAgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBfZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyhhZGRyZXNzLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSB2YWxpZCBibG9jayB0YWcgZm9yICUlYmxvY2tUYWclJSwgcmVzb2x2aW5nXG4gICAgICogIG5lZ2F0aXZlIHZhbHVlcyBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZCBibG9jayB0YWcuXG4gICAgICovXG4gICAgX2dldEJsb2NrVGFnKGJsb2NrVGFnKSB7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGJsb2NrVGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwiZWFybGllc3RcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIweDBcIjtcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJsYXRlc3RcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tUYWcsIDMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KGJsb2NrVGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gZ2V0TnVtYmVyKGJsb2NrVGFnLCBcImJsb2NrVGFnXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKGJsb2NrVGFnID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eShibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eSh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgKyBibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCbG9ja051bWJlcigpLnRoZW4oKGIpID0+IHRvUXVhbnRpdHkoYiArIGJsb2NrVGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBibG9ja1RhZ1wiLCBcImJsb2NrVGFnXCIsIGJsb2NrVGFnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSBmaWx0ZXIgZm9yICUlZmlsdGVyJSUsIHJlc29sdmluZyBhbnkgRU5TXG4gICAgICogIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBvYmplY3QgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWRcbiAgICAgKiAgZmlsdGVyLlxuICAgICAqL1xuICAgIF9nZXRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9waWNzXG4gICAgICAgIGNvbnN0IHRvcGljcyA9IChmaWx0ZXIudG9waWNzIHx8IFtdKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNpc2lmeSh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gKFwiYmxvY2tIYXNoXCIgaW4gZmlsdGVyKSA/IGZpbHRlci5ibG9ja0hhc2ggOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSAoX2FkZHJlc3MsIGZyb21CbG9jaywgdG9CbG9jaykgPT4ge1xuICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2FkZHJlc3NbMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF9hZGRyZXNzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQmxvY2sgIT0gbnVsbCB8fCB0b0Jsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaWx0ZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0ge307XG4gICAgICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3BpY3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gZnJvbUJsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvQmxvY2spIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9IHRvQmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmJsb2NrSGFzaCA9IGJsb2NrSGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFkZHJlc3NlcyBjb3VsZCBiZSBhc3luYyAoRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlcylcbiAgICAgICAgbGV0IGFkZHJlc3MgPSBbXTtcbiAgICAgICAgaWYgKGZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHIgb2YgZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRoaXMuX2dldEFkZHJlc3MoYWRkcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGZpbHRlci5hZGRyZXNzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZyb21CbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwiZnJvbUJsb2NrXCIgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICBmcm9tQmxvY2sgPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXIuZnJvbUJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9CbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwidG9CbG9ja1wiIGluIGZpbHRlcikge1xuICAgICAgICAgICAgdG9CbG9jayA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlci50b0Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzcy5maWx0ZXIoKGEpID0+ICh0eXBlb2YgKGEpICE9PSBcInN0cmluZ1wiKSkubGVuZ3RoIHx8XG4gICAgICAgICAgICAoZnJvbUJsb2NrICE9IG51bGwgJiYgdHlwZW9mIChmcm9tQmxvY2spICE9PSBcInN0cmluZ1wiKSB8fFxuICAgICAgICAgICAgKHRvQmxvY2sgIT0gbnVsbCAmJiB0eXBlb2YgKHRvQmxvY2spICE9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtQcm9taXNlLmFsbChhZGRyZXNzKSwgZnJvbUJsb2NrLCB0b0Jsb2NrXSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0WzBdLCByZXN1bHRbMV0sIHJlc3VsdFsyXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShhZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIHRyYW5zYWN0aW9uIGZvciAlJXJlcXVlc3QlJSwgcmVzb2x2aW5nXG4gICAgICogIGFueSBFTlMgbmFtZXMgb3IgW1tBZGRyZXNzYWJsZV1dIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIF9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3JlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNvcHlSZXF1ZXN0KF9yZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgW1widG9cIiwgXCJmcm9tXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Rba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkciA9IHJlc29sdmVBZGRyZXNzKHJlcXVlc3Rba2V5XSwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGFkZHIpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyByZXF1ZXN0W2tleV0gPSBhd2FpdCBhZGRyOyB9KSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Rba2V5XSA9IGFkZHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVxdWVzdC5ibG9ja1RhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKHJlcXVlc3QuYmxvY2tUYWcpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHJlcXVlc3QuYmxvY2tUYWcgPSBhd2FpdCBibG9ja1RhZzsgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJsb2NrVGFnID0gYmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgLy8gTm8gZXhwbGljaXQgbmV0d29yayB3YXMgc2V0IGFuZCB0aGlzIGlzIG91ciBmaXJzdCB0aW1lXG4gICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZXRlY3QgdGhlIGN1cnJlbnQgbmV0d29yayAoc2hhcmVkIHdpdGggYWxsIGNhbGxzKVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0TmV0d29yayA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuX2RldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IGRldGVjdE5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBkZXRlY3ROZXR3b3JrO1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBkZXRlY3ROZXR3b3JrKS5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmtQcm9taXNlID0gdGhpcy4jbmV0d29ya1Byb21pc2U7XG4gICAgICAgIGNvbnN0IFtleHBlY3RlZCwgYWN0dWFsXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIG5ldHdvcmtQcm9taXNlLFxuICAgICAgICAgICAgdGhpcy5fZGV0ZWN0TmV0d29yaygpIC8vIFRoZSBhY3R1YWwgY29ubmVjdGVkIG5ldHdvcmtcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChleHBlY3RlZC5jaGFpbklkICE9PSBhY3R1YWwuY2hhaW5JZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FueU5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgXCJhbnlcIiBuZXR3b3JrIGNhbiBjaGFuZ2UsIHNvIG5vdGlmeSBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGFjdHVhbCwgZXhwZWN0ZWQpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbmV0d29yayBpZiBzb21ldGhpbmcgZWxzZSBoYXNuJ3QgYWxyZWFkeSBjaGFuZ2VkIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09PSBuZXR3b3JrUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhY3R1YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgZG8gbm90IGFsbG93IGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgbmV0d29ya1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYG5ldHdvcmsgY2hhbmdlZDogJHtleHBlY3RlZC5jaGFpbklkfSA9PiAke2FjdHVhbC5jaGFpbklkfSBgLCBcIk5FVFdPUktfRVJST1JcIiwge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwZWN0ZWQuY2xvbmUoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBnZXRGZWVEYXRhRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgX2Jsb2NrLCBnYXNQcmljZSwgcHJpb3JpdHlGZWUgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBfYmxvY2s6IHRoaXMuI2dldEJsb2NrKFwibGF0ZXN0XCIsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0R2FzUHJpY2VcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUsIFwiJXJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pKCkpLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5RmVlOiAoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRQcmlvcml0eUZlZVwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkoKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IG1heEZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSByZWNvbW1lbmRlZCBFSVAtMTU1OSBoZXVyaXN0aWNzIGZvciBmZWUgZGF0YVxuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLl93cmFwQmxvY2soX2Jsb2NrLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSB7XG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAocHJpb3JpdHlGZWUgIT0gbnVsbCkgPyBwcmlvcml0eUZlZSA6IEJpZ0ludChcIjEwMDAwMDAwMDBcIik7XG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzID0gKGJsb2NrLmJhc2VGZWVQZXJHYXMgKiBCTl8yKSArIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZWVEYXRhKGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgRmVlRGF0YU5ldFdvcmtQbHVnaW5cbiAgICAgICAgY29uc3QgcGx1Z2luID0gbmV0d29yay5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZXRjaFVybEZlZURhdGFQbHVnaW5cIik7XG4gICAgICAgIGlmIChwbHVnaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QocGx1Z2luLnVybCk7XG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgcGx1Z2luLnByb2Nlc3NGdW5jKGdldEZlZURhdGFGdW5jLCB0aGlzLCByZXEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZWVEYXRhKGZlZURhdGEuZ2FzUHJpY2UsIGZlZURhdGEubWF4RmVlUGVyR2FzLCBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RmVlRGF0YUZ1bmMoKTtcbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVHYXMoX3R4KSB7XG4gICAgICAgIGxldCB0eCA9IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfdHgpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKHR4KSkge1xuICAgICAgICAgICAgdHggPSBhd2FpdCB0eDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0QmlnSW50KGF3YWl0IHRoaXMuI3BlcmZvcm0oe1xuICAgICAgICAgICAgbWV0aG9kOiBcImVzdGltYXRlR2FzXCIsIHRyYW5zYWN0aW9uOiB0eFxuICAgICAgICB9KSwgXCIlcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIGFzeW5jICNjYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCkge1xuICAgICAgICBhc3NlcnQoYXR0ZW1wdCA8IE1BWF9DQ0lQX1JFRElSRUNUUywgXCJDQ0lQIHJlYWQgZXhjZWVkZWQgbWF4aW11bSByZWRpcmVjdGlvbnNcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiVE9PX01BTllfUkVESVJFQ1RTXCIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgsIHsgYmxvY2tUYWcsIGVuYWJsZUNjaXBSZWFkOiB0cnVlIH0pXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGlzIGNhbWUgaW4gYXMgYSBQZXJmb3JtQWN0aW9uVHJhbnNhY3Rpb24sIHNvIHRvL2Zyb20gYXJlIHNhZmU7IHdlIGNhbiBjYXN0XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY29weVJlcXVlc3QodHgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYXdhaXQgdGhpcy5fcGVyZm9ybSh7IG1ldGhvZDogXCJjYWxsXCIsIHRyYW5zYWN0aW9uLCBibG9ja1RhZyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBDQ0lQIFJlYWQgT2ZmY2hhaW5Mb29rdXBcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlQ2NpcFJlYWQgJiYgaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhICYmIGF0dGVtcHQgPj0gMCAmJiBibG9ja1RhZyA9PT0gXCJsYXRlc3RcIiAmJiB0cmFuc2FjdGlvbi50byAhPSBudWxsICYmIGRhdGFTbGljZShlcnJvci5kYXRhLCAwLCA0KSA9PT0gXCIweDU1NmYxODMwXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZXJyb3IuZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eFNlbmRlciA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHRyYW5zYWN0aW9uLnRvLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgQ0NJUCBSZWFkIEFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGxldCBjY2lwQXJncztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjY2lwQXJncyA9IHBhcnNlT2ZmY2hhaW5Mb29rdXAoZGF0YVNsaWNlKGVycm9yLmRhdGEsIDQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgZXJyb3IubWVzc2FnZSwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiQkFEX0RBVEFcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgc2VuZGVyIG9mIHRoZSBPZmZjaGFpbkxvb2t1cCBtYXRjaGVzIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIGFzc2VydChjY2lwQXJncy5zZW5kZXIudG9Mb3dlckNhc2UoKSA9PT0gdHhTZW5kZXIudG9Mb3dlckNhc2UoKSwgXCJDQ0lQIFJlYWQgc2VuZGVyIG1pc21hdGNoXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiT2ZmY2hhaW5Mb29rdXBcIixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiT2ZmY2hhaW5Mb29rdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGNjaXBBcmdzLmVycm9yQXJnc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2NpcFJlc3VsdCA9IGF3YWl0IHRoaXMuY2NpcFJlYWRGZXRjaCh0cmFuc2FjdGlvbiwgY2NpcEFyZ3MuY2FsbGRhdGEsIGNjaXBBcmdzLnVybHMpO1xuICAgICAgICAgICAgICAgIGFzc2VydChjY2lwUmVzdWx0ICE9IG51bGwsIFwiQ0NJUCBSZWFkIGZhaWxlZCB0byBmZXRjaCBkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiRkVUQ0hfRkFJTEVEXCIsIHRyYW5zYWN0aW9uLCBpbmZvOiB7IGRhdGE6IGVycm9yLmRhdGEsIGVycm9yQXJnczogY2NpcEFyZ3MuZXJyb3JBcmdzIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG86IHR4U2VuZGVyLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjb25jYXQoW2NjaXBBcmdzLnNlbGVjdG9yLCBlbmNvZGVCeXRlcyhbY2NpcFJlc3VsdCwgY2NpcEFyZ3MuZXh0cmFEYXRhXSldKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZENjaXBSZWFkQ2FsbFwiLCB0cmFuc2FjdGlvbjogdHggfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkQ2FsbFJlc3VsdFwiLCB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgpLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsRXJyb3JcIiwgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4KSwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNjaGVja05ldHdvcmsocHJvbWlzZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHZhbHVlOiBwcm9taXNlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGFzeW5jIGNhbGwoX3R4KSB7XG4gICAgICAgIGNvbnN0IHsgdHgsIGJsb2NrVGFnIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICB0eDogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF90eCksXG4gICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoX3R4LmJsb2NrVGFnKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NoZWNrTmV0d29yayh0aGlzLiNjYWxsKHR4LCBibG9ja1RhZywgX3R4LmVuYWJsZUNjaXBSZWFkID8gMCA6IC0xKSk7XG4gICAgfVxuICAgIC8vIEFjY291bnRcbiAgICBhc3luYyAjZ2V0QWNjb3VudFZhbHVlKHJlcXVlc3QsIF9hZGRyZXNzLCBfYmxvY2tUYWcpIHtcbiAgICAgICAgbGV0IGFkZHJlc3MgPSB0aGlzLl9nZXRBZGRyZXNzKF9hZGRyZXNzKTtcbiAgICAgICAgbGV0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcoX2Jsb2NrVGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIChibG9ja1RhZykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIFthZGRyZXNzLCBibG9ja1RhZ10gPSBhd2FpdCBQcm9taXNlLmFsbChbYWRkcmVzcywgYmxvY2tUYWddKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2hlY2tOZXR3b3JrKHRoaXMuI3BlcmZvcm0oT2JqZWN0LmFzc2lnbihyZXF1ZXN0LCB7IGFkZHJlc3MsIGJsb2NrVGFnIH0pKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEJhbGFuY2UoYWRkcmVzcywgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpZ0ludChhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0QmFsYW5jZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSwgXCIlcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uQ291bnQoYWRkcmVzcywgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIGdldE51bWJlcihhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSwgXCIlcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIGFzeW5jIGdldENvZGUoYWRkcmVzcywgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldENvZGVcIiB9LCBhZGRyZXNzLCBibG9ja1RhZykpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTdG9yYWdlKGFkZHJlc3MsIF9wb3NpdGlvbiwgYmxvY2tUYWcpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRCaWdJbnQoX3Bvc2l0aW9uLCBcInBvc2l0aW9uXCIpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0U3RvcmFnZVwiLCBwb3NpdGlvbiB9LCBhZGRyZXNzLCBibG9ja1RhZykpO1xuICAgIH1cbiAgICAvLyBXcml0ZVxuICAgIGFzeW5jIGJyb2FkY2FzdFRyYW5zYWN0aW9uKHNpZ25lZFR4KSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIGhhc2gsIG5ldHdvcmsgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLmdldEJsb2NrTnVtYmVyKCksXG4gICAgICAgICAgICBoYXNoOiB0aGlzLl9wZXJmb3JtKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBzaWduZWRUcmFuc2FjdGlvbjogc2lnbmVkVHhcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKClcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gVHJhbnNhY3Rpb24uZnJvbShzaWduZWRUeCk7XG4gICAgICAgIGlmICh0eC5oYXNoICE9PSBoYXNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ETzogdGhlIHJldHVybmVkIGhhc2ggZGlkIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIG5ldHdvcmspLnJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oYmxvY2tOdW1iZXIpO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0QmxvY2soYmxvY2ssIGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgLy8gQFRPRE86IEFkZCBDdXN0b21CbG9ja1BsdWdpbiBjaGVja1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2ssIDMyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlcmZvcm0oe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCbG9ja1wiLCBibG9ja0hhc2g6IGJsb2NrLCBpbmNsdWRlVHJhbnNhY3Rpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhibG9jayk7XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYmxvY2tUYWcgPSBhd2FpdCBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0QmxvY2tcIiwgYmxvY2tUYWcsIGluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFF1ZXJpZXNcbiAgICBhc3luYyBnZXRCbG9jayhibG9jaywgcHJlZmV0Y2hUeHMpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNnZXRCbG9jayhibG9jaywgISFwcmVmZXRjaFR4cylcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBCbG9jayhwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbihoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZXNwb25zZShwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIGhhc2ggfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBiYWNrZW5kcyBkaWQgbm90IGJhY2tmaWxsIHRoZSBlZmZlY3RpdmVHYXNQcmljZSBpbnRvIG9sZCB0cmFuc2FjdGlvbnNcbiAgICAgICAgLy8gaW4gdGhlIHJlY2VpcHQsIHNvIHdlIGxvb2sgaXQgdXAgbWFudWFsbHkgYW5kIGluamVjdCBpdC5cbiAgICAgICAgaWYgKHBhcmFtcy5nYXNQcmljZSA9PSBudWxsICYmIHBhcmFtcy5lZmZlY3RpdmVHYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25cIiwgaGFzaCB9KTtcbiAgICAgICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVwb3J0IHRoaXM7IGNvdWxkIG5vdCBmaW5kIHR4IG9yIGVmZmVjdGl2ZUdhc1ByaWNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1zLmVmZmVjdGl2ZUdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQocGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZXN1bHQoaGFzaCkge1xuICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICByZXN1bHQ6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25SZXN1bHRcIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xuICAgIH1cbiAgICAvLyBCbG9vbS1maWx0ZXIgUXVlcmllc1xuICAgIGFzeW5jIGdldExvZ3MoX2ZpbHRlcikge1xuICAgICAgICBsZXQgZmlsdGVyID0gdGhpcy5fZ2V0RmlsdGVyKF9maWx0ZXIpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKGZpbHRlcikpIHtcbiAgICAgICAgICAgIGZpbHRlciA9IGF3YWl0IGZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0TG9nc1wiLCBmaWx0ZXIgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbXMubWFwKChwKSA9PiB0aGlzLl93cmFwTG9nKHAsIG5ldHdvcmspKTtcbiAgICB9XG4gICAgLy8gRU5TXG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInByb3ZpZGVyIGNhbm5vdCBjb25uZWN0IHRvIHRhcmdldCBuZXR3b3JrXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJfZ2V0UHJvdmlkZXIoKVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXNvbHZlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBFbnNSZXNvbHZlci5mcm9tTmFtZSh0aGlzLCBuYW1lKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QXZhdGFyKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlci5nZXRBdmF0YXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgbG9va3VwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCBub2RlID0gbmFtZWhhc2goYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSArIFwiLmFkZHIucmV2ZXJzZVwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuc0FkZHIgPSBhd2FpdCBFbnNSZXNvbHZlci5nZXRFbnNBZGRyZXNzKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgZW5zQ29udHJhY3QgPSBuZXcgQ29udHJhY3QoZW5zQWRkciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZXIoYnl0ZXMzMikgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiXG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgZW5zQ29udHJhY3QucmVzb2x2ZXIobm9kZSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIgPT0gbnVsbCB8fCByZXNvbHZlciA9PT0gWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQ29udHJhY3QgPSBuZXcgQ29udHJhY3QocmVzb2x2ZXIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIG5hbWUoYnl0ZXMzMikgdmlldyByZXR1cm5zIChzdHJpbmcpXCJcbiAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGF3YWl0IHJlc29sdmVyQ29udHJhY3QubmFtZShub2RlKTtcbiAgICAgICAgICAgIC8vIEZhaWxlZCBmb3J3YXJkIHJlc29sdXRpb25cbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gYXdhaXQgdGhpcy5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGVjayAhPT0gYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBObyBkYXRhIHdhcyByZXR1cm5lZCBmcm9tIHRoZSByZXNvbHZlclxuICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQkFEX0RBVEFcIikgJiYgZXJyb3IudmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHJlZXJ0ZWRcbiAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKGhhc2gsIF9jb25maXJtcywgdGltZW91dCkge1xuICAgICAgICBjb25zdCBjb25maXJtcyA9IChfY29uZmlybXMgIT0gbnVsbCkgPyBfY29uZmlybXMgOiAxO1xuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGFzeW5jIChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIC0gcmVjZWlwdC5ibG9ja051bWJlciArIDEgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5vZmYoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVFRVwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZihcImJsb2NrXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInRpbWVvdXRcIiwgXCJUSU1FT1VUXCIsIHsgcmVhc29uOiBcInRpbWVvdXRcIiB9KSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ZW5lcihhd2FpdCB0aGlzLmdldEJsb2NrTnVtYmVyKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvckJsb2NrKGJsb2NrVGFnKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIsIFwiTk9UX0lNUExFTUVOVEVEXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ3YWl0Rm9yQmxvY2tcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENsZWFyIGEgdGltZXIgY3JlYXRlZCB1c2luZyB0aGUgW1tfc2V0VGltZW91dF1dIG1ldGhvZC5cbiAgICAgKi9cbiAgICBfY2xlYXJUaW1lb3V0KHRpbWVySWQpIHtcbiAgICAgICAgY29uc3QgdGltZXIgPSB0aGlzLiN0aW1lcnMuZ2V0KHRpbWVySWQpO1xuICAgICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVyLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3RpbWVycy5kZWxldGUodGltZXJJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSB0aW1lciB0aGF0IHdpbGwgZXhlY3V0ZSAlJWZ1bmMlJSBhZnRlciBhdCBsZWFzdCAlJXRpbWVvdXQlJVxuICAgICAqICAoaW4gbXMpLiBJZiAlJXRpbWVvdXQlJSBpcyB1bnNwZWNpZmllZCwgdGhlbiAlJWZ1bmMlJSB3aWxsIGV4ZWN1dGVcbiAgICAgKiAgaW4gdGhlIG5leHQgZXZlbnQgbG9vcC5cbiAgICAgKlxuICAgICAqICBbUGF1c2luZ10oQWJzdHJhY3RQcm92aWRlci1wYXVzZWQpIHRoZSBwcm92aWRlciB3aWxsIHBhdXNlIGFueVxuICAgICAqICBhc3NvY2lhdGVkIHRpbWVycy5cbiAgICAgKi9cbiAgICBfc2V0VGltZW91dChfZnVuYywgdGltZW91dCkge1xuICAgICAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lcklkID0gdGhpcy4jbmV4dFRpbWVyKys7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuZGVsZXRlKHRpbWVySWQpO1xuICAgICAgICAgICAgX2Z1bmMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuc2V0KHRpbWVySWQsIHsgdGltZXI6IG51bGwsIGZ1bmMsIHRpbWU6IHRpbWVvdXQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoZnVuYywgdGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuc2V0KHRpbWVySWQsIHsgdGltZXIsIGZ1bmMsIHRpbWU6IGdldFRpbWUoKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZXJJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBlcmZvcm0gJSVmdW5jJSUgb24gZWFjaCBzdWJzY3JpYmVyLlxuICAgICAqL1xuICAgIF9mb3JFYWNoU3Vic2NyaWJlcihmdW5jKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZ1bmMoc3ViLnN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBjdXN0b21pemUgc3Vic2NyaXB0aW9uXG4gICAgICogIGltcGxlbWVudGF0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgc3dpdGNoIChzdWIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyKHN1Yi50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIucG9sbGluZ0ludGVydmFsID0gdGhpcy5wb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOlxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlcih0aGlzLCBzdWIudHlwZSk7XG4gICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgICAgICBjYXNlIFwidHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIodGhpcywgc3ViLmhhc2gpO1xuICAgICAgICAgICAgY2FzZSBcIm9ycGhhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ09ycGhhblN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBldmVudDogJHtzdWIudHlwZX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGEgW1tTdWJzY3JpYmVyXV0gZmFpbHMgYW5kIG5lZWRzIHRvIHJlcGxhY2UgaXRzZWxmLCB0aGlzXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgdGhpcyBpcyB1c2VkIGZvciBwcm92aWRlcnMgd2hlbiB1c2luZyB0aGVcbiAgICAgKiAgYGBldGhfZ2V0RmlsdGVyQ2hhbmdlc2BgIG1ldGhvZCwgd2hpY2ggY2FuIHJldHVybiBudWxsIGlmIHN0YXRlXG4gICAgICogIGZpbHRlcnMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJhY2tlbmQsIGFsbG93aW5nIHRoZSBTdWJzY3JpYmVyXG4gICAgICogIHRvIHN3YXAgaW4gYSBbW1BvbGxpbmdFdmVudFN1YnNjcmliZXJdXS5cbiAgICAgKi9cbiAgICBfcmVjb3ZlclN1YnNjcmliZXIob2xkU3ViLCBuZXdTdWIpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHN1Yi5zdWJzY3JpYmVyID09PSBvbGRTdWIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlciA9IG5ld1N1YjtcbiAgICAgICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1Yi5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNoYXNTdWIoZXZlbnQsIGVtaXRBcmdzKSB7XG4gICAgICAgIGxldCBzdWIgPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oZXZlbnQsIHRoaXMpO1xuICAgICAgICAvLyBUaGlzIGlzIGEgbG9nIHRoYXQgaXMgcmVtb3ZpbmcgYW4gZXhpc3RpbmcgbG9nOyB3ZSBhY3R1YWxseSB3YW50XG4gICAgICAgIC8vIHRvIGVtaXQgYW4gb3JwaGFuIGV2ZW50IGZvciB0aGUgcmVtb3ZlZCBsb2dcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcImV2ZW50XCIgJiYgZW1pdEFyZ3MgJiYgZW1pdEFyZ3MubGVuZ3RoID4gMCAmJiBlbWl0QXJnc1swXS5yZW1vdmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdWIgPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oeyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiBlbWl0QXJnc1swXSB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jc3Vicy5nZXQoc3ViLnRhZykgfHwgbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgI2dldFN1YihldmVudCkge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oZXZlbnQsIHRoaXMpO1xuICAgICAgICAvLyBQcmV2ZW50IHRhbXBlcmluZyB3aXRoIG91ciB0YWcgaW4gYW55IHN1YmNsYXNzJyBfZ2V0U3Vic2NyaWJlclxuICAgICAgICBjb25zdCB0YWcgPSBzdWJzY3JpcHRpb24udGFnO1xuICAgICAgICBsZXQgc3ViID0gdGhpcy4jc3Vicy5nZXQodGFnKTtcbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSB0aGlzLl9nZXRTdWJzY3JpYmVyKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzYWJsZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBuYW1lTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgc3ViID0geyBzdWJzY3JpYmVyLCB0YWcsIGFkZHJlc3NhYmxlTWFwLCBuYW1lTWFwLCBzdGFydGVkOiBmYWxzZSwgbGlzdGVuZXJzOiBbXSB9O1xuICAgICAgICAgICAgdGhpcy4jc3Vicy5zZXQodGFnLCBzdWIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfVxuICAgIGFzeW5jIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogZmFsc2UgfSk7XG4gICAgICAgIGlmICghc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICBzdWIuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIGlmICghc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICBzdWIuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQsIGFyZ3MpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3Qgc3Vic2NyaXB0aW9uIG9yIGlmIGEgcmVjZW50IGVtaXQgcmVtb3ZlZFxuICAgICAgICAvLyB0aGUgbGFzdCBvZiB0aGVtICh3aGljaCBhbHNvIGRlbGV0ZWQgdGhlIHN1YikgZG8gbm90aGluZ1xuICAgICAgICBpZiAoIXN1YiB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgY29uc3QgY291bnQgPSBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBuZXcgRXZlbnRQYXlsb2FkKHRoaXMsIChvbmNlID8gbnVsbCA6IGxpc3RlbmVyKSwgZXZlbnQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIC4uLmFyZ3MsIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiAhb25jZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjb3VudCA+IDApO1xuICAgIH1cbiAgICBhc3luYyBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHRvdGFsICs9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICBhc3luYyBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQobGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHN1Yi5saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpc3RlbmVyIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyB0YWcsIHN0YXJ0ZWQsIHN1YnNjcmliZXIgfSA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUodGFnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3RhZywgeyBzdGFydGVkLCBzdWJzY3JpYmVyIH1dIG9mIHRoaXMuI3N1YnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUodGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWxpYXMgZm9yIFwib25cIlxuICAgIGFzeW5jIGFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvZmZcIlxuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIHRoaXMgcHJvdmlkZXIgaGFzIGJlZW4gZGVzdHJveWVkIHVzaW5nIHRoZSBbW2Rlc3Ryb3ldXSBtZXRob2QuXG4gICAgICpcbiAgICAgKiAgT25jZSBkZXN0cm95ZWQsIGFsbCByZXNvdXJjZXMgYXJlIHJlY2xhaW1lZCwgaW50ZXJuYWwgZXZlbnQgbG9vcHNcbiAgICAgKiAgYW5kIHRpbWVycyBhcmUgY2xlYW5lZCB1cCBhbmQgbm8gZnVydGhlciByZXF1ZXN0cyBtYXkgYmUgc2VudCB0b1xuICAgICAqICB0aGUgcHJvdmlkZXIuXG4gICAgICovXG4gICAgZ2V0IGRlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Rlc3Ryb3llZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSB1c2UgdGhpcyB0byBzaHV0ZG93biBhbnkgc29ja2V0cyBvciByZWxlYXNlIHRoZWlyXG4gICAgICogIHJlc291cmNlcyBhbmQgcmVqZWN0IGFueSBwZW5kaW5nIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIGNhbGwgYGBzdXBlci5kZXN0cm95KClgYC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBTdG9wIGFsbCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgLy8gU2h1dCBkb3duIGFsbCB0aWVtcnNcbiAgICAgICAgZm9yIChjb25zdCB0aW1lcklkIG9mIHRoaXMuI3RpbWVycy5rZXlzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNkZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGUgcHJvdmlkZXIgaXMgY3VycmVudGx5IHBhdXNlZC5cbiAgICAgKlxuICAgICAqICBBIHBhdXNlZCBwcm92aWRlciB3aWxsIG5vdCBlbWl0IGFueSBldmVudHMsIGFuZCBnZW5lcmFsbHkgc2hvdWxkXG4gICAgICogIG5vdCBtYWtlIGFueSByZXF1ZXN0cyB0byB0aGUgbmV0d29yaywgYnV0IHRoYXQgaXMgdXAgdG8gc3ViLWNsYXNzZXNcbiAgICAgKiAgdG8gbWFuYWdlLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgYGBwYXVzZWQgPSB0cnVlYGAgaXMgaWRlbnRpY2FsIHRvIGNhbGxpbmcgYGAucGF1c2UoZmFsc2UpYGAsXG4gICAgICogIHdoaWNoIHdpbGwgYnVmZmVyIGFueSBldmVudHMgdGhhdCBvY2N1ciB3aGlsZSBwYXVzZWQgdW50aWwgdGhlXG4gICAgICogIHByb3ZpZGVyIGlzIHVucGF1c2VkLlxuICAgICAqL1xuICAgIGdldCBwYXVzZWQoKSB7IHJldHVybiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCk7IH1cbiAgICBzZXQgcGF1c2VkKHBhdXNlKSB7XG4gICAgICAgIGlmICghIXBhdXNlID09PSB0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXVzZSB0aGUgcHJvdmlkZXIuIElmICUlZHJvcFdoaWxlUGF1c2VkJSUsIGFueSBldmVudHMgdGhhdCBvY2N1clxuICAgICAqICB3aGlsZSBwYXVzZWQgYXJlIGRyb3BwZWQsIG90aGVyd2lzZSBhbGwgZXZlbnRzIHdpbGwgYmUgZW1pdHRlZCBvbmNlXG4gICAgICogIHRoZSBwcm92aWRlciBpcyB1bnBhdXNlZC5cbiAgICAgKi9cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgdGhpcy4jbGFzdEJsb2NrTnVtYmVyID0gLTE7XG4gICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgPT0gISFkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IGNoYW5nZSBwYXVzZSB0eXBlOyByZXN1bWUgZmlyc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwYXVzZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigocykgPT4gcy5wYXVzZShkcm9wV2hpbGVQYXVzZWQpKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSAhIWRyb3BXaGlsZVBhdXNlZDtcbiAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLiN0aW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSB0aW1lclxuICAgICAgICAgICAgaWYgKHRpbWVyLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyLnRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyB0aW1lIG5lZWRlZCBmb3Igd2hlbiB3ZSBiZWNvbWUgdW5wYXVzZWRcbiAgICAgICAgICAgIHRpbWVyLnRpbWUgPSBnZXRUaW1lKCkgLSB0aW1lci50aW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXN1bWUgdGhlIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigocykgPT4gcy5yZXN1bWUoKSk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLiN0aW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyB0aW1lIHdoZW4gd2Ugd2VyZSBwYXVzZWRcbiAgICAgICAgICAgIGxldCB0aW1lb3V0ID0gdGltZXIudGltZTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgdGltZSAoaW4gY2F1c2UgcGF1c2VkLCBzbyB3ZSBjb24gY29tcHV0ZSByZW1haW5pbmYgdGltZSlcbiAgICAgICAgICAgIHRpbWVyLnRpbWUgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdGltZXJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZXIuZnVuYywgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBfcGFyc2VTdHJpbmcocmVzdWx0LCBzdGFydCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCk7XG4gICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhieXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpIHtcbiAgICBpZiAocmVzdWx0ID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGdldE51bWJlcihkYXRhU2xpY2UocmVzdWx0LCBzdGFydCwgc3RhcnQgKyAzMikpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBnZXROdW1iZXIoZGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0LCBvZmZzZXQgKyAzMikpO1xuICAgICAgICByZXR1cm4gZGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0ICsgMzIsIG9mZnNldCArIDMyICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG51bVBhZCh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRvQmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgfVxuICAgIGNvbnN0IHBhZGRlZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICBwYWRkZWQuc2V0KHJlc3VsdCwgMzIgLSByZXN1bHQubGVuZ3RoKTtcbiAgICByZXR1cm4gcGFkZGVkO1xufVxuZnVuY3Rpb24gYnl0ZXNQYWQodmFsdWUpIHtcbiAgICBpZiAoKHZhbHVlLmxlbmd0aCAlIDMyKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbCh2YWx1ZS5sZW5ndGggLyAzMikgKiAzMik7XG4gICAgcmVzdWx0LnNldCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkoW10pO1xuLy8gQUJJIEVuY29kZXMgYSBzZXJpZXMgb2YgKGJ5dGVzLCBieXRlcywgLi4uKVxuZnVuY3Rpb24gZW5jb2RlQnl0ZXMoZGF0YXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgYnl0ZUNvdW50ID0gMDtcbiAgICAvLyBBZGQgcGxhY2UtaG9sZGVycyBmb3IgcG9pbnRlcnMgYXMgd2UgYWRkIGl0ZW1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChlbXB0eSk7XG4gICAgICAgIGJ5dGVDb3VudCArPSAzMjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoZGF0YXNbaV0pO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGJ5dGVzIG9mZnNldFxuICAgICAgICByZXN1bHRbaV0gPSBudW1QYWQoYnl0ZUNvdW50KTtcbiAgICAgICAgLy8gVGhlIGxlbmd0aCBhbmQgcGFkZGVkIHZhbHVlIG9mIGRhdGFcbiAgICAgICAgcmVzdWx0LnB1c2gobnVtUGFkKGRhdGEubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGJ5dGVzUGFkKGRhdGEpKTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyICsgTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gMzIpICogMzI7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQocmVzdWx0KTtcbn1cbmNvbnN0IHplcm9zID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbmZ1bmN0aW9uIHBhcnNlT2ZmY2hhaW5Mb29rdXAoZGF0YSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgc2VuZGVyOiBcIlwiLCB1cmxzOiBbXSwgY2FsbGRhdGE6IFwiXCIsIHNlbGVjdG9yOiBcIlwiLCBleHRyYURhdGE6IFwiXCIsIGVycm9yQXJnczogW11cbiAgICB9O1xuICAgIGFzc2VydChkYXRhTGVuZ3RoKGRhdGEpID49IDUgKiAzMiwgXCJpbnN1ZmZpY2llbnQgT2ZmY2hhaW5Mb29rdXAgZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImluc3VmZmljaWVudCBPZmZjaGFpbkxvb2t1cCBkYXRhXCJcbiAgICB9KTtcbiAgICBjb25zdCBzZW5kZXIgPSBkYXRhU2xpY2UoZGF0YSwgMCwgMzIpO1xuICAgIGFzc2VydChkYXRhU2xpY2Uoc2VuZGVyLCAwLCAxMikgPT09IGRhdGFTbGljZSh6ZXJvcywgMCwgMTIpLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgc2VuZGVyXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBzZW5kZXJcIlxuICAgIH0pO1xuICAgIHJlc3VsdC5zZW5kZXIgPSBkYXRhU2xpY2Uoc2VuZGVyLCAxMik7XG4gICAgLy8gUmVhZCB0aGUgVVJMcyBmcm9tIHRoZSByZXNwb25zZVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybHMgPSBbXTtcbiAgICAgICAgY29uc3QgdXJsc09mZnNldCA9IGdldE51bWJlcihkYXRhU2xpY2UoZGF0YSwgMzIsIDY0KSk7XG4gICAgICAgIGNvbnN0IHVybHNMZW5ndGggPSBnZXROdW1iZXIoZGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQsIHVybHNPZmZzZXQgKyAzMikpO1xuICAgICAgICBjb25zdCB1cmxzRGF0YSA9IGRhdGFTbGljZShkYXRhLCB1cmxzT2Zmc2V0ICsgMzIpO1xuICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHVybHNMZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gX3BhcnNlU3RyaW5nKHVybHNEYXRhLCB1ICogMzIpO1xuICAgICAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmxzLnB1c2godXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudXJscyA9IHVybHM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCB1cmxzXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgdXJsc1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIENDSVAgY2FsbGRhdGEgdG8gZm9yd2FyZFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbGxkYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgNjQpO1xuICAgICAgICBpZiAoY2FsbGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmNhbGxkYXRhID0gY2FsbGRhdGE7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgY2FsbGJhY2tTZWxlY3RvciAoYnl0ZXM0KVxuICAgIGFzc2VydChkYXRhU2xpY2UoZGF0YSwgMTAwLCAxMjgpID09PSBkYXRhU2xpY2UoemVyb3MsIDAsIDI4KSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsYmFhY2tTZWxlY3RvclwiXG4gICAgfSk7XG4gICAgcmVzdWx0LnNlbGVjdG9yID0gZGF0YVNsaWNlKGRhdGEsIDk2LCAxMDApO1xuICAgIC8vIEdldCB0aGUgZXh0cmEgZGF0YSB0byBzZW5kIGJhY2sgdG8gdGhlIGNvbnRyYWN0IGFzIGNvbnRleHRcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBleHRyYURhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCAxMjgpO1xuICAgICAgICBpZiAoZXh0cmFEYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5leHRyYURhdGEgPSBleHRyYURhdGE7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBleHRyYURhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBleHRyYURhdGFcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzdWx0LmVycm9yQXJncyA9IFwic2VuZGVyLHVybHMsY2FsbGRhdGEsc2VsZWN0b3IsZXh0cmFEYXRhXCIuc3BsaXQoLywvKS5tYXAoKGspID0+IHJlc3VsdFtrXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0LXByb3ZpZGVyLmpzLm1hcCIsIi8qKlxuICogIEdlbmVyYWxseSB0aGUgW1tXYWxsZXRdXSBhbmQgW1tKc29uUnBjU2lnbmVyXV0gYW5kIHRoZWlyIHN1Yi1jbGFzc2VzXG4gKiAgYXJlIHN1ZmZpY2VudCBmb3IgbW9zdCBkZXZlbG9wZXJzLCBidXQgdGhpcyBpcyBwcm92aWRlZCB0b1xuICogIGZhc2NpbGl0YXRlIG1vcmUgY29tcGxleCBTaWduZXJzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyOiBTdWJjbGFzc2luZyBTaWduZXIgW2Fic3RyYWN0LXNpZ25lcl1cbiAqL1xuaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvcHlSZXF1ZXN0IH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcbmZ1bmN0aW9uIGNoZWNrUHJvdmlkZXIoc2lnbmVyLCBvcGVyYXRpb24pIHtcbiAgICBpZiAoc2lnbmVyLnByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBzaWduZXIucHJvdmlkZXI7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJtaXNzaW5nIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGUoc2lnbmVyLCB0eCkge1xuICAgIGxldCBwb3AgPSBjb3B5UmVxdWVzdCh0eCk7XG4gICAgaWYgKHBvcC50byAhPSBudWxsKSB7XG4gICAgICAgIHBvcC50byA9IHJlc29sdmVBZGRyZXNzKHBvcC50bywgc2lnbmVyKTtcbiAgICB9XG4gICAgaWYgKHBvcC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBvcC5mcm9tO1xuICAgICAgICBwb3AuZnJvbSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHNpZ25lci5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICByZXNvbHZlQWRkcmVzcyhmcm9tLCBzaWduZXIpXG4gICAgICAgIF0pLnRoZW4oKFthZGRyZXNzLCBmcm9tXSkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBmcm9tLnRvTG93ZXJDYXNlKCksIFwidHJhbnNhY3Rpb24gZnJvbSBtaXNtYXRjaFwiLCBcInR4LmZyb21cIiwgZnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb3AuZnJvbSA9IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNvbHZlUHJvcGVydGllcyhwb3ApO1xufVxuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFNpZ25lcioqIGluY2x1ZGVzIG1vc3Qgb2YgdGVoIGZ1bmN0aW9uYWxpdHkgcmVxdWlyZWRcbiAqICB0byBnZXQgYSBbW1NpZ25lcl1dIHdvcmtpbmcgYXMgZXhwZWN0ZWQsIGJ1dCByZXF1aXJlcyBhIGZld1xuICogIFNpZ25lci1zcGVjaWZpYyBtZXRob2RzIGJlIG92ZXJyaWRkZW4uXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgdGhpcyBzaWduZXIgaXMgY29ubmVjdGVkIHRvLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFNpZ25lciBjb25uZWN0ZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwcm92aWRlcjogKHByb3ZpZGVyIHx8IG51bGwpIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXROb25jZShibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImdldFRyYW5zYWN0aW9uQ291bnRcIikuZ2V0VHJhbnNhY3Rpb25Db3VudChhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZUNhbGwodHgpIHtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgcG9wdWxhdGUodGhpcywgdHgpO1xuICAgICAgICByZXR1cm4gcG9wO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcbiAgICAgICAgaWYgKHBvcC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3Aubm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlKFwicGVuZGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMuZXN0aW1hdGVHYXMocG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgY2hhaW4gSURcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0ICh0aGlzLnByb3ZpZGVyKS5nZXROZXR3b3JrKCk7XG4gICAgICAgIGlmIChwb3AuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gZ2V0QmlnSW50KHBvcC5jaGFpbklkKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGNoYWluSWQgPT09IG5ldHdvcmsuY2hhaW5JZCwgXCJ0cmFuc2FjdGlvbiBjaGFpbklkIG1pc21hdGNoXCIsIFwidHguY2hhaW5JZFwiLCB0eC5jaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcC5jaGFpbklkID0gbmV0d29yay5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBtaXhpbmcgcHJlLWVpcC0xNTU5IGFuZCBlaXAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGhhc0VpcDE1NTkgPSAocG9wLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsICYmIChwb3AudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJwcmUtZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgbWF4RmVlUGVyR2FzL21heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT0gbnVsbCkgJiYgKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIC8vIEZ1bGx5LWZvcm1lZCBFSVAtMTU1OSB0cmFuc2FjdGlvbiAoc2tpcCBnZXRGZWVEYXRhKVxuICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBMZWdhY3kgb3IgRUlQLTI5MzAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBhc3NlcnQoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEdhc1ByaWNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNQcmljZVxuICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9wLmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBpZiAocG9wLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYXV0by1kZXRlY3QgdGhlIGludGVuZGVkIHR5cGUgb2YgdGhpcyB0cmFuc2FjdGlvbi4uLlxuICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OSFcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBncmFkZSB0cmFuc2FjdGlvbiBmcm9tIG51bGwgdG8gZWlwLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5hdXRob3JpemF0aW9uTGlzdCAmJiBwb3AuYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyBsZWdhY3kgZ2FzUHJpY2UgcHJvcGVydHkgb24gYW4gZWlwLTE1NTkgbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHBvcC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwb3AuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBFSVAtMTU1OS4uLlxuICAgICAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhleSBhcmUgdHJ5aW5nIHRvIHVzZSBFSVAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCghaGFzRWlwMTU1OSwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRUlQLTE1NTlcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgdW50eXBlZCB0cmFuc2FjdGlvbiB0byBsZWdhY3lcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IE1heWJlIHRoaXMgc2hvbGQgYWxsb3cgdHlwZSAxP1xuICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXRGZWVEYXRhIGhhcyBmYWlsZWQgdXMuXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJmYWlsZWQgdG8gZ2V0IGNvbnNpc3RlbnQgZmVlIGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5nZXRGZWVEYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT09IDMgfHwgcG9wLnR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzaW5nIEVJUC0xNTU5IG9yIEVJUC00ODQ0XG4gICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9AVE9PRDogRG9uJ3QgYXdhaXQgYWxsIG92ZXIgdGhlIHBsYWNlOyBzYXZlIHRoZW0gdXAgZm9yXG4gICAgICAgIC8vIHRoZSBlbmQgZm9yIGJldHRlciBiYXRjaGluZ1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMocG9wKTtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVBdXRob3JpemF0aW9uKF9hdXRoKSB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBPYmplY3QuYXNzaWduKHt9LCBfYXV0aCk7XG4gICAgICAgIC8vIEFkZCBhIGNoYWluIElEIGlmIG5vdCBleHBsaWNpdGx5IHNldCB0byAwXG4gICAgICAgIGlmIChhdXRoLmNoYWluSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXV0aC5jaGFpbklkID0gKGF3YWl0IGNoZWNrUHJvdmlkZXIodGhpcywgXCJnZXROZXR3b3JrXCIpLmdldE5ldHdvcmsoKSkuY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogVGFrZSBjaGFpbiBJRCBpbnRvIGFjY291bnQgd2hlbiBwb3B1bGF0aW5nIG5vY2U/XG4gICAgICAgIGlmIChhdXRoLm5vbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGF1dGgubm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dGg7XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlR2FzKHR4KSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZXN0aW1hdGVHYXNcIikuZXN0aW1hdGVHYXMoYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbCh0eCkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImNhbGxcIikuY2FsbChhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCkpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGRlbGV0ZSBwb3AuZnJvbTtcbiAgICAgICAgY29uc3QgdHhPYmogPSBUcmFuc2FjdGlvbi5mcm9tKHBvcCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5icm9hZGNhc3RUcmFuc2FjdGlvbihhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0eE9iaikpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogaW4gdjcgbW92ZSB0aGlzIHRvIGJlIGFic3RyYWN0XG4gICAgYXV0aG9yaXplKGF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImF1dGhvcml6YXRpb24gbm90IGltcGxlbWVudGVkIGZvciB0aGlzIHNpZ25lclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJhdXRob3JpemVcIiB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVm9pZFNpZ25lcioqIGlzIGEgY2xhc3MgZGVpc2duZWQgdG8gYWxsb3cgYW4gYWRkcmVzcyB0byBiZSB1c2VkXG4gKiAgaW4gYW55IEFQSSB3aGljaCBhY2NlcHRzIGEgU2lnbmVyLCBidXQgZm9yIHdoaWNoIHRoZXJlIGFyZSBub1xuICogIGNyZWRlbnRpYWxzIGF2YWlsYWJsZSB0byBwZXJmb3JtIGFueSBhY3R1YWwgc2lnbmluZy5cbiAqXG4gKiAgVGhpcyBmb3IgZXhhbXBsZSBhbGxvdyBpbXBlcnNvbmF0aW5nIGFuIGFjY291bnQgZm9yIHRoZSBwdXJwb3NlIG9mXG4gKiAgc3RhdGljIGNhbGxzIG9yIGVzdGltYXRpbmcgZ2FzLCBidXQgZG9lcyBub3QgYWxsb3cgc2VuZGluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWb2lkU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmVyIGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlZvaWRTaWduZXIqKiB3aXRoICUlYWRkcmVzcyUlIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhZGRyZXNzIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gdGhpcy5hZGRyZXNzOyB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XG4gICAgfVxuICAgICN0aHJvd1Vuc3VwcG9ydGVkKHN1ZmZpeCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgYFZvaWRTaWduZXIgY2Fubm90IHNpZ24gJHtzdWZmaXh9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0eXBlZC1kYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1zaWduZXIuanMubWFwIiwiaW1wb3J0IHsgaXNFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiO1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8qKlxuICogIFNvbWUgYmFja2VuZHMgc3VwcG9ydCBzdWJzY3JpYmluZyB0byBldmVudHMgdXNpbmcgYSBGaWx0ZXIgSUQuXG4gKlxuICogIFdoZW4gc3Vic2NyaWJpbmcgd2l0aCB0aGlzIHRlY2huaXF1ZSwgdGhlIG5vZGUgaXNzdWVzIGEgdW5pcXVlXG4gKiAgLy9GaWx0ZXIgSUQvLy4gQXQgdGhpcyBwb2ludCB0aGUgbm9kZSBkZWRpY2F0ZXMgcmVzb3VyY2VzIHRvXG4gKiAgdGhlIGZpbHRlciwgc28gdGhhdCBwZXJpb2RpYyBjYWxscyB0byBmb2xsb3cgdXAgb24gdGhlIC8vRmlsdGVyIElELy9cbiAqICB3aWxsIHJlY2VpdmUgYW55IGV2ZW50cyBzaW5jZSB0aGUgbGFzdCBjYWxsLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAjcG9sbGVyO1xuICAgICNydW5uaW5nO1xuICAgICNuZXR3b3JrO1xuICAgICNoYXVsdDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZpbHRlcklkU3Vic2NyaWJlcioqIHdoaWNoIHdpbGwgdXNlZCBbW19zdWJzY3JpYmVdXVxuICAgICAqICBhbmQgW1tfZW1pdFJlc3VsdHNdXSB0byBzZXR1cCB0aGUgc3Vic2NyaXB0aW9uIGFuZCBwcm92aWRlIHRoZSBldmVudFxuICAgICAqICB0byB0aGUgJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgdGhpcy4jaGF1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgdG8gYmVnaW4gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyBoYW5kbGUgdGhlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHJlY292ZXJ5IG9uIGVycm9ycy5cbiAgICAgKi9cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgYXN5bmMgI3BvbGwoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIGlmICh0aGlzLiNmaWx0ZXJJZFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IHRoaXMuX3N1YnNjcmliZSh0aGlzLiNwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIEZpbHRlciBJRFxuICAgICAgICAgICAgbGV0IGZpbHRlcklkID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmlsdGVySWQgPSBhd2FpdCB0aGlzLiNmaWx0ZXJJZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIpIHx8IGVycm9yLm9wZXJhdGlvbiAhPT0gXCJldGhfbmV3RmlsdGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBGaWx0ZXIgSUQ7IGRvd25ncmFkZSB0b1xuICAgICAgICAgICAgLy8gcG9sbGluZ1xuICAgICAgICAgICAgaWYgKGZpbHRlcklkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLl9yZWNvdmVyU3Vic2NyaWJlcih0aGlzLCB0aGlzLl9yZWNvdmVyKHRoaXMuI3Byb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy4jbmV0d29yaykge1xuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmsuY2hhaW5JZCAhPT0gbmV0d29yay5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhaWQgY2hhbmdlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2VtaXRSZXN1bHRzKHRoaXMuI3Byb3ZpZGVyLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJAVE9ET1wiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub25jZShcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgICN0ZWFyZG93bigpIHtcbiAgICAgICAgY29uc3QgZmlsdGVySWRQcm9taXNlID0gdGhpcy4jZmlsdGVySWRQcm9taXNlO1xuICAgICAgICBpZiAoZmlsdGVySWRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgZmlsdGVySWRQcm9taXNlLnRoZW4oKGZpbHRlcklkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3Byb3ZpZGVyLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jdGVhcmRvd24oKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cbn1cbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIGNvbnRyYWN0IGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjZXZlbnQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJVxuICAgICAqICBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2V2ZW50ID0gY29weShmaWx0ZXIpO1xuICAgIH1cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIocHJvdmlkZXIsIHRoaXMuI2V2ZW50KTtcbiAgICB9XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICBjb25zdCBmaWx0ZXJJZCA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfbmV3RmlsdGVyXCIsIFt0aGlzLiNldmVudF0pO1xuICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2V2ZW50LCBwcm92aWRlci5fd3JhcExvZyhyZXN1bHQsIHByb3ZpZGVyLl9uZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KFwicGVuZGluZ1wiLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1maWx0ZXJpZC5qcy5tYXAiLCIvKipcbiAqICBPbmUgb2YgdGhlIG1vc3QgY29tbW9uIHdheXMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgYmxvY2tjaGFpbiBpc1xuICogIGJ5IGEgbm9kZSBydW5uaW5nIGEgSlNPTi1SUEMgaW50ZXJmYWNlIHdoaWNoIGNhbiBiZSBjb25uZWN0ZWQgdG8sXG4gKiAgYmFzZWQgb24gdGhlIHRyYW5zcG9ydCwgdXNpbmc6XG4gKlxuICogIC0gSFRUUCBvciBIVFRQUyAtIFtbSnNvblJwY1Byb3ZpZGVyXV1cbiAqICAtIFdlYlNvY2tldCAtIFtbV2ViU29ja2V0UHJvdmlkZXJdXVxuICogIC0gSVBDIC0gW1tJcGNTb2NrZXRQcm92aWRlcl1dXG4gKlxuICogQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2pzb25ycGM6SlNPTi1SUEMgUHJvdmlkZXIgIFthYm91dC1qc29ucnBjUHJvdmlkZXJdXG4gKi9cbi8vIEBUT0RPOlxuLy8gLSBBZGQgdGhlIGJhdGNoaW5nIEFQSVxuLy8gaHR0cHM6Ly9wbGF5Z3JvdW5kLm9wZW4tcnBjLm9yZy8/c2NoZW1hVXJsPWh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ldGhlcmV1bS9ldGgxLjAtYXBpcy9hc3NlbWJsZWQtc3BlYy9vcGVucnBjLmpzb24mdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpzcGxpdFZpZXclNUQ9dHJ1ZSZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOmlucHV0JTVEPWZhbHNlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6ZXhhbXBsZXNEcm9wZG93biU1RD1mYWxzZVxuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnksIGF1dGhvcml6YXRpb25pZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvUXVhbnRpdHksIHRvVXRmOEJ5dGVzLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCwgcmVzb2x2ZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFic3RyYWN0UHJvdmlkZXIsIFVubWFuYWdlZFN1YnNjcmliZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RTaWduZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1zaWduZXIuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciwgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItZmlsdGVyaWQuanNcIjtcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbmNvbnN0IFByaW1pdGl2ZSA9IFwiYmlnaW50LGJvb2xlYW4sZnVuY3Rpb24sbnVtYmVyLHN0cmluZyxzeW1ib2xcIi5zcGxpdCgvLC9nKTtcbi8vY29uc3QgTWV0aG9kcyA9IFwiZ2V0QWRkcmVzcyx0aGVuXCIuc3BsaXQoLywvZyk7XG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IFByaW1pdGl2ZS5pbmRleE9mKHR5cGVvZiAodmFsdWUpKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gS2VlcCBhbnkgQWRkcmVzc2FibGVcbiAgICBpZiAodHlwZW9mICh2YWx1ZS5nZXRBZGRyZXNzKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUubWFwKGRlZXBDb3B5KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzaG91bGQgbm90IGhhcHBlbjogJHt2YWx1ZX0gKCR7dHlwZW9mICh2YWx1ZSl9KWApO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7IH0pO1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpc1BvbGxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnBvbGxpbmdJbnRlcnZhbCkgPT09IFwibnVtYmVyXCIpO1xufVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcG9sbGluZzogZmFsc2UsXG4gICAgc3RhdGljTmV0d29yazogbnVsbCxcbiAgICBiYXRjaFN0YWxsVGltZTogMTAsXG4gICAgYmF0Y2hNYXhTaXplOiAoMSA8PCAyMCksXG4gICAgYmF0Y2hNYXhDb3VudDogMTAwLFxuICAgIGNhY2hlVGltZW91dDogMjUwLFxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxufTtcbi8vIEBUT0RPOiBVbmNoZWNrZWQgU2lnbmVyc1xuZXhwb3J0IGNsYXNzIEpzb25ScGNTaWduZXIgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgYWRkcmVzcztcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcykge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IHJlY29ubmVjdCBKc29uUnBjU2lnbmVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRyZXNzO1xuICAgIH1cbiAgICAvLyBKU09OLVJQQyB3aWxsIGF1dG9tYXRpYWxseSBmaWxsIGluIG5vbmNlLCBldGMuIHNvIHdlIGp1c3QgY2hlY2sgZnJvbVxuICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBqdXN0IHRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBhZnRlciBzZW50LCB3aGljaCBpcyB3aGF0XG4gICAgLy8gdGhlIGJhcmUgSlNPTi1SUEMgQVBJIGRvZXM7XG4gICAgYXN5bmMgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKF90eCkge1xuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IF9mcm9tID0gdHguZnJvbTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3MoX2Zyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoeyAuLi50eCwgZnJvbTogdGhpcy5hZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGFkZHJlc3MgbWF5IGJlIGFuIEVOUyBuYW1lIG9yIEFkZHJlc3NhYmxlXG4gICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBfdG8gPSB0eC50bztcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC50byA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKF90bywgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IHVudGlsIGFsbCBvZiBvdXIgcHJvcGVydGllcyBhcmUgZmlsbGVkIGluXG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgLy8gU2VuZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgLy8gZm9yIGEgcmVzcG9uc2UsIGFuZCB3ZSBuZWVkIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb24sIHNvIHdlIHBvbGxcbiAgICAgICAgLy8gZm9yIGl0OyBpdCBzaG91bGQgc2hvdyB1cCB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgcmV0dXJuIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0cyA9IFsxMDAwLCAxMDBdO1xuICAgICAgICAgICAgbGV0IGludmFsaWRzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrVHggPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGNhbmNlbGxlZDogc3RvcCBwb2xsaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGF0YSBpcyBiYWQ6IHRoZSBub2RlIHJldHVybnMgYmFkIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBjaGFuZ2VkOiBjYWxsaW5nIGFnYWluIHdpbGwgYWxzbyBmYWlsXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHVuc3VwcG9ydGVkOiBsaWtlbHkgZGVzdHJveWVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTkNFTExFRFwiKSB8fCBpc0Vycm9yKGVycm9yLCBcIkJBRF9EQVRBXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Vycm9yKGVycm9yLCBcIk5FVFdPUktfRVJST1JcIikgfHwgaXNFcnJvcihlcnJvciwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5pbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvLnNlbmRUcmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wLWdhcCBmb3IgbWlzYmVoYXZpbmcgYmFja2VuZHM7IHNlZSAjNDUxM1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8uc2VuZFRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZHMgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbnlvbmUgdGhhdCBjYXJlczsgYnV0IHdlIHdpbGwgdHJ5IGFnYWluLCBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBsaWtlbHkgYW4gaW50ZXJtaXR0ZW50IHNlcnZpY2UgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5lbWl0KFwiZXJyb3JcIiwgbWFrZUVycm9yKFwiZmFpbGVkIHRvIGZldGNoIHRyYW5zYXRpb24gYWZ0ZXIgc2VuZGluZyAod2lsbCB0cnkgYWdhaW4pXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IGVycm9yIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBhbm90aGVyIDQgc2Vjb25kc1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuX3NldFRpbWVvdXQoKCkgPT4geyBjaGVja1R4KCk7IH0sIHRpbWVvdXRzLnBvcCgpIHx8IDQwMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoZWNrVHgoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24oX3R4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gZGVlcENvcHkoX3R4KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmcm9tIG1hdGNoZXMgdGhlIHNlbmRlclxuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJvbSAhPSBudWxsICYmIGZyb20udG9Mb3dlckNhc2UoKSA9PT0gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgX3R4KTtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbXG4gICAgICAgICAgICBoZXhsaWZ5KG1lc3NhZ2UpLCB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkZWVwQ29weShfdmFsdWUpO1xuICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzIChpbi1wbGFjZSlcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFkZHJlc3MgIT0gbnVsbCwgXCJUeXBlZERhdGEgZG9lcyBub3Qgc3VwcG9ydCBudWxsIGFkZHJlc3NcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFR5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfdW5sb2NrQWNjb3VudFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgcGFzc3dvcmQsIG51bGxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cbiAgICBhc3luYyBfbGVnYWN5U2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIGhleGxpZnkobWVzc2FnZSlcbiAgICAgICAgXSk7XG4gICAgfVxufVxuLyoqXG4gKiAgVGhlIEpzb25ScGNBcGlQcm92aWRlciBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgKipNVVNUKiogYmVcbiAqICBzdWItY2xhc3NlZC5cbiAqXG4gKiAgSXQgcHJvdmlkZXMgdGhlIGJhc2UgZm9yIGFsbCBKU09OLVJQQy1iYXNlZCBQcm92aWRlciBpbnRlcmFjdGlvbi5cbiAqXG4gKiAgU3ViLWNsYXNzaW5nIE5vdGVzOlxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBvdmVycmlkZSBfc2VuZFxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIHRoZSBgX3N0YXJ0KClgIG1ldGhvZCBvbmNlIGNvbm5lY3RlZFxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0FwaVByb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI29wdGlvbnM7XG4gICAgLy8gVGhlIG5leHQgSUQgdG8gdXNlIGZvciB0aGUgSlNPTi1SUEMgSUQgZmllbGRcbiAgICAjbmV4dElkO1xuICAgIC8vIFBheWxvYWRzIGFyZSBxdWV1ZWQgYW5kIHRyaWdnZXJlZCBpbiBiYXRjaGVzIHVzaW5nIHRoZSBkcmFpblRpbWVyXG4gICAgI3BheWxvYWRzO1xuICAgICNkcmFpblRpbWVyO1xuICAgICNub3RSZWFkeTtcbiAgICAjbmV0d29yaztcbiAgICAjcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgI3NjaGVkdWxlRHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIGJhdGNoaW5nLCBubyBoYXJtIGluIHNlbmRpbmcgaXQgaW1tZWRpYXRlbHlcbiAgICAgICAgY29uc3Qgc3RhbGxUaW1lID0gKHRoaXMuX2dldE9wdGlvbihcImJhdGNoTWF4Q291bnRcIikgPT09IDEpID8gMCA6IHRoaXMuX2dldE9wdGlvbihcImJhdGNoU3RhbGxUaW1lXCIpO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWRzID0gdGhpcy4jcGF5bG9hZHM7XG4gICAgICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwYXlsb2FkIGJhdGNoZXMgdGhhdCBzYXRpc2Z5IG91ciBiYXRjaCBjb25zdHJhaW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gWyhwYXlsb2Fkcy5zaGlmdCgpKV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID09PSB0aGlzLiNvcHRpb25zLmJhdGNoTWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goKHBheWxvYWRzLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBKU09OLnN0cmluZ2lmeShiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gdGhpcy4jb3B0aW9ucy5iYXRjaE1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzLnVuc2hpZnQoKGJhdGNoLnBvcCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSByZXN1bHQgdG8gZWFjaCBwYXlsb2FkXG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICgoYmF0Y2gubGVuZ3RoID09PSAxKSA/IGJhdGNoWzBdLnBheWxvYWQgOiBiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyByZXN1bHRzIGluIGJhdGNoIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0LCBwYXlsb2FkIH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSByZXN1bHQuZmlsdGVyKChyKSA9PiAoci5pZCA9PT0gcGF5bG9hZC5pZCkpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdDsgdGhlIG5vZGUgZmFpbGVkIHVzIGluIHVuZXhwZWN0ZWQgd2F5c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBtYWtlRXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlIGZvciByZXF1ZXN0XCIsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdCwgaW5mbzogeyBwYXlsb2FkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZSBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCByZXNwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZ29vZDsgc2VuZCB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVqZWN0IH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogYXVnbWVudCB0aGUgZXJyb3Igd2l0aCB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFsbFRpbWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNuZXh0SWQgPSAxO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jbm90UmVhZHkgPSB7IHByb21pc2UsIHJlc29sdmUgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0aWNOZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc3RhdGljTmV0d29yaykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghc3RhdGljTmV0d29yayB8fCBuZXR3b3JrICE9PSBcImFueVwiLCBcInN0YXRpY05ldHdvcmsgY2Fubm90IGJlIHVzZWQgb24gc3BlY2lhbCBuZXR3b3JrICdhbnknXCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdGF0aWNOZXR3b3JrICYmIG5ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBOZXR3b3JrLmZyb20obmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGljTmV0d29yaykge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBzdGF0aWMgbmV0d29yayBpcyBjb21wYXRiaWxlIHdpdGggdGhlIHByb3ZpZGVkIG5ldHdyb2tcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG5ldHdvcmsgPT0gbnVsbCB8fCBzdGF0aWNOZXR3b3JrLm1hdGNoZXMobmV0d29yayksIFwic3RhdGljTmV0d29yayBNVVNUIG1hdGNoIG5ldHdvcmsgb2JqZWN0XCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBzdGF0aWNOZXR3b3JrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG9wdGlvbiAlJWtleSUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIGNhbiB1c2UgdGhpcyB0byBpbnF1aXJlIGFib3V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0T3B0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9uc1trZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0cyB0aGUgW1tOZXR3b3JrXV0gdGhpcyBwcm92aWRlciBoYXMgY29tbWl0dGVkIHRvLiBPbiBlYWNoIGNhbGwsIHRoZSBuZXR3b3JrXG4gICAgICogIGlzIGRldGVjdGVkLCBhbmQgaWYgaXQgaGFzIGNoYW5nZWQsIHRoZSBjYWxsIHdpbGwgcmVqZWN0LlxuICAgICAqL1xuICAgIGdldCBfbmV0d29yaygpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI25ldHdvcmssIFwibmV0d29yayBpcyBub3QgYXZhaWxhYmxlIHlldFwiLCBcIk5FVFdPUktfRVJST1JcIik7XG4gICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG5vbi1ub3JtYWxpemVkIHZhbHVlIGJ5IHBlcmZvcm1pbmcgJSVyZXElJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBtb2RpZnkgYmVoYXZpb3Igb2YgYWN0aW9ucyxcbiAgICAgKiAgYW5kIHNob3VsZCBnZW5lcmFsbHkgY2FsbCBgYHN1cGVyLl9wZXJmb3JtYGAgYXMgYSBmYWxsYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgLy8gTGVnYWN5IG5ldHdvcmtzIGRvIG5vdCBsaWtlIHRoZSB0eXBlIGZpZWxkIGJlaW5nIHBhc3NlZCBhbG9uZyAod2hpY2hcbiAgICAgICAgLy8gaXMgZmFpciksIHNvIHdlIGRlbGV0ZSB0eXBlIGlmIGl0IGlzIDAgYW5kIGEgbm9uLUVJUC0xNTU5IG5ldHdvcmtcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiY2FsbFwiIHx8IHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgbGV0IHR4ID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgaWYgKHR4ICYmIHR4LnR5cGUgIT0gbnVsbCAmJiBnZXRCaWdJbnQodHgudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gRUlQLTE1NTkgb3IgbmV3ZXIgcHJvcGVydGllcywgaXQgbWlnaHQgYmUgcHJlLUVJUC0xNTU5XG4gICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IE9iamVjdC5hc3NpZ24oe30sIHJlcSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyB0eXBlOiB1bmRlZmluZWQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmdldFJwY1JlcXVlc3QocmVxKTtcbiAgICAgICAgaWYgKHJlcXVlc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX3BlcmZvcm0ocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzOyBpdCBkZXRlY3RzIHRoZSAqYWN0dWFsKiBuZXR3b3JrIHRoYXRcbiAgICAgKiAgd2UgYXJlICoqY3VycmVudGx5KiogY29ubmVjdGVkIHRvLlxuICAgICAqXG4gICAgICogIEtlZXAgaW4gbWluZCB0aGF0IFtbc2VuZF1dIG1heSBvbmx5IGJlIHVzZWQgb25jZSBbW3JlYWR5XV0sIG90aGVyd2lzZSB0aGVcbiAgICAgKiAgX3NlbmQgcHJpbWl0aXZlIG11c3QgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKG5ldHdvcmspIHtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI25ldHdvcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlIHJlYWR5LCB1c2UgYGBzZW5kYGAsIHdoaWNoIGVuYWJsZWQgcmVxdWVzdHMgdG8gYmUgYmF0Y2hlZFxuICAgICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IE5ldHdvcmsuZnJvbShnZXRCaWdJbnQoYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIiwgW10pKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgbm90IHJlYWR5IHlldDsgdXNlIHRoZSBwcmltaXRpdmUgX3NlbmRcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy4jbmV4dElkKyssIG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBwYXJhbXM6IFtdLCBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJwY1BheWxvYWRcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpKVswXTtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICBpZiAoXCJyZXN1bHRcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKGdldEJpZ0ludChyZXN1bHQucmVzdWx0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHJlc3VsdCk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqTVVTVCoqIGNhbGwgdGhpcy4gVW50aWwgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNhbGxzXG4gICAgICogIHdpbGwgYmUgcGFzc2VkIHRvIFtbX3NlbmRdXSBmcm9tIFtbc2VuZF1dLiBJZiBpdCBpcyBvdmVycmlkZGVuLCB0aGVuXG4gICAgICogIGBgc3VwZXIuX3N0YXJ0KClgYCAqKk1VU1QqKiBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAgQ2FsbGluZyBpdCBtdWx0aXBsZSB0aW1lcyBpcyBzYWZlIGFuZCBoYXMgbm8gZWZmZWN0LlxuICAgICAqL1xuICAgIF9zdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwgfHwgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLiNub3RSZWFkeSA9IG51bGw7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgdGhlIG5ldHdvcmtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiNuZXR3b3JrID09IG51bGwgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IGF3YWl0IHRoaXMuX2RldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJKc29uUnBjUHJvdmlkZXIgZmFpbGVkIHRvIGRldGVjdCBuZXR3b3JrIGFuZCBjYW5ub3Qgc3RhcnQgdXA7IHJldHJ5IGluIDFzIChwZXJoYXBzIHRoZSBVUkwgaXMgd3Jvbmcgb3IgdGhlIG5vZGUgaXMgbm90IHN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBtYWtlRXJyb3IoXCJmYWlsZWQgdG8gYm9vdHN0cmFwIG5ldHdvcmsgZGV0ZWN0aW9uXCIsIFwiTkVUV09SS19FUlJPUlwiLCB7IGV2ZW50OiBcImluaXRpYWwtbmV0d29yay1kaXNjb3ZlcnlcIiwgaW5mbzogeyBlcnJvciB9IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgZGlzcGF0Y2hpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLiBUaGlzIGNhbiBiZSB1c2VkIGluXG4gICAgICogIHN1Yi1jbGFzc2VzIHRvIGRlZmVyIHNlbmRpbmcgZGF0YSB1bnRpbCB0aGUgY29ubmVjdGlvbiBoYXMgYmVlblxuICAgICAqICBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBhc3luYyBfd2FpdFVudGlsUmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLiNub3RSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI25vdFJlYWR5LnByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBTdWJzY3JpYmVyIHRoYXQgd2lsbCBtYW5hZ2UgdGhlICUlc3ViJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IHRoZSBiZWhhdmlvciBvZlxuICAgICAqICBzdWJzY3JpcHRpb24gbWFuYWdlbWVudC5cbiAgICAgKi9cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgLy8gUGVuZGluZyBGaWx0ZXJzIGFyZW4ndCBhdmFpbGJsZSB2aWEgcG9sbGluZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRPcHRpb24oXCJwb2xsaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcnBoYW5lZCBMb2dzIGFyZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHksIGJ5IHRoZSBmaWx0ZXIsIHNpbmNlXG4gICAgICAgIC8vIGxvZ3Mgd2l0aCByZW1vdmVkIGFyZSBlbWl0dGVkIGJ5IGl0XG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJvcnBoYW5cIiAmJiBzdWIuZmlsdGVyLm9ycGhhbiA9PT0gXCJkcm9wLWxvZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoXCJvcnBoYW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICovXG4gICAgZ2V0IHJlYWR5KCkgeyByZXR1cm4gdGhpcy4jbm90UmVhZHkgPT0gbnVsbDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zICUldHglJSBhcyBhIG5vcm1hbGl6ZWQgSlNPTi1SUEMgdHJhbnNhY3Rpb24gcmVxdWVzdCxcbiAgICAgKiAgd2hpY2ggaGFzIGFsbCB2YWx1ZXMgaGV4bGlmaWVkIGFuZCBhbnkgbnVtZXJpYyB2YWx1ZXMgY29udmVydGVkXG4gICAgICogIHRvIFF1YW50aXR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXRScGNUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gSlNPTi1SUEMgbm93IHJlcXVpcmVzIG51bWVyaWMgdmFsdWVzIHRvIGJlIFwicXVhbnRpdHlcIiB2YWx1ZXNcbiAgICAgICAgW1wiY2hhaW5JZFwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ0eXBlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJub25jZVwiLCBcInZhbHVlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkc3RLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcbiAgICAgICAgICAgICAgICBkc3RLZXkgPSBcImdhc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2RzdEtleV0gPSB0b1F1YW50aXR5KGdldEJpZ0ludCh0eFtrZXldLCBgdHguJHtrZXl9YCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFkZHJlc3NlcyBhbmQgZGF0YSBhcmUgbG93ZXJjYXNlXG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiLCBcImRhdGFcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZXhsaWZ5KHR4W2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBhY2Nlc3MgbGlzdCBvYmplY3RcbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtcImFjY2Vzc0xpc3RcIl0gPSBhY2Nlc3NMaXN0aWZ5KHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgPGFueT4gY2FzZSBvbmNlIEVJUC00ODQ0IGFkZGVkIHRvIHByZXBhcmVkIHR4XG4gICAgICAgICAgICByZXN1bHRbXCJibG9iVmVyc2lvbmVkSGFzaGVzXCJdID0gdHguYmxvYlZlcnNpb25lZEhhc2hlcy5tYXAoaCA9PiBoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hdXRob3JpemF0aW9uTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYXV0aG9yaXphdGlvbkxpc3RcIl0gPSB0eC5hdXRob3JpemF0aW9uTGlzdC5tYXAoKF9hKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGF1dGhvcml6YXRpb25pZnkoX2EpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGEuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHRvUXVhbnRpdHkoYS5ub25jZSksXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRvUXVhbnRpdHkoYS5jaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eTogdG9RdWFudGl0eShhLnNpZ25hdHVyZS55UGFyaXR5KSxcbiAgICAgICAgICAgICAgICAgICAgcjogdG9RdWFudGl0eShhLnNpZ25hdHVyZS5yKSxcbiAgICAgICAgICAgICAgICAgICAgczogdG9RdWFudGl0eShhLnNpZ25hdHVyZS5zKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IGJsb2JzIHNob3VsZCBwcm9iYWJseSBhbHNvIGJlIGNvcGllZCBvdmVyLCBvcHRpb25hbGx5XG4gICAgICAgIC8vIGFjY291bnRpbmcgZm9yIHRoZSBremcgcHJvcGVydHkgdG8gYmFja2ZpbGwgYmxvYlZlcnNpb25lZEhhc2hlc1xuICAgICAgICAvLyB1c2luZyB0aGUgY29tbWl0bWVudC4gT3Igc2hvdWxkIHRoYXQgYmUgbGVmdCBhcyBhbiBleGVyY2lzZSB0b1xuICAgICAgICAvLyB0aGUgY2FsbGVyP1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcmVxdWVzdCBtZXRob2QgYW5kIGFyZ3VtZW50cyByZXF1aXJlZCB0byBwZXJmb3JtXG4gICAgICogICUlcmVxJSUuXG4gICAgICovXG4gICAgZ2V0UnBjUmVxdWVzdChyZXEpIHtcbiAgICAgICAgc3dpdGNoIChyZXEubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9ibG9ja051bWJlclwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9nYXNQcmljZVwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFByaW9yaXR5RmVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJhbGFuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiMHhcIiArIHJlcS5wb3NpdGlvbi50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5zaWduZWRUcmFuc2FjdGlvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja1RhZywgISFyZXEuaW5jbHVkZVRyYW5zYWN0aW9uc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJibG9ja0hhc2hcIiBpbiByZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuYmxvY2tIYXNoLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5oYXNoXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5oYXNoXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9lc3RpbWF0ZUdhc1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgICAgIGlmIChyZXEuZmlsdGVyICYmIHJlcS5maWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcS5maWx0ZXIuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IHJlcS5maWx0ZXIuYWRkcmVzcy5tYXAoZ2V0TG93ZXJDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShyZXEuZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfZ2V0TG9nc1wiLCBhcmdzOiBbcmVxLmZpbHRlcl0gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYW4gZXRoZXJzLXN0eWxlIEVycm9yIGZvciB0aGUgZ2l2ZW4gSlNPTi1SUEMgZXJyb3JcbiAgICAgKiAgJSVwYXlsb2FkJSUsIGNvYWxlc2NpbmcgdGhlIHZhcmlvdXMgc3RyaW5ncyBhbmQgZXJyb3Igc2hhcGVzXG4gICAgICogIHRoYXQgZGlmZmVyZW50IG5vZGVzIHJldHVybiwgY29lcmNpbmcgdGhlbSBpbnRvIGEgbWFjaGluZS1yZWFkYWJsZVxuICAgICAqICBzdGFuZGFyZGl6ZWQgZXJyb3IuXG4gICAgICovXG4gICAgZ2V0UnBjRXJyb3IocGF5bG9hZCwgX2Vycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0aG9kIH0gPSBwYXlsb2FkO1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBfZXJyb3I7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIgJiYgZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghbXNnLm1hdGNoKC9yZXZlcnQvaSkgJiYgbXNnLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IChwYXlsb2FkLnBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobXNnLm1hdGNoKC9ub25jZS9pKSAmJiBtc2cubWF0Y2goL3RvbyBsb3cvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIFwiTk9OQ0VfRVhQSVJFRFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAocGF5bG9hZC5wYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9jYWxsXCIgfHwgbWV0aG9kID09PSBcImV0aF9lc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rRGF0YShlcnJvcik7XG4gICAgICAgICAgICBjb25zdCBlID0gQWJpQ29kZXIuZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oKG1ldGhvZCA9PT0gXCJldGhfY2FsbFwiKSA/IFwiY2FsbFwiIDogXCJlc3RpbWF0ZUdhc1wiLCAocGF5bG9hZC5wYXJhbXNbMF0pLCAocmVzdWx0ID8gcmVzdWx0LmRhdGEgOiBudWxsKSk7XG4gICAgICAgICAgICBlLmluZm8gPSB7IGVycm9yLCBwYXlsb2FkIH07XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGVzdGltYXRlR2FzIGFuZCBjYWxsIGNhbiByZXR1cm4gYXJiaXRyYXJ5IGNvbnRyYWN0LWRlZmluZWQgdGV4dCwgc28gbm93IHdlXG4gICAgICAgIC8vIHdlIGNhbiBwcm9jZXNzIHRleHQgc2FmZWx5LlxuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoc3BlbHVua01lc3NhZ2UoZXJyb3IpKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWR8ZXRoZXJzLXVzZXItZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25NYXAgPSB7XG4gICAgICAgICAgICAgICAgZXRoX3NpZ246IFwic2lnbk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBwZXJzb25hbF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjQ6IFwic2lnblR5cGVkRGF0YVwiLFxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHJhbnNhY3Rpb246IFwic2lnblRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NlbmRUcmFuc2FjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBldGhfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgICAgICB3YWxsZXRfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKGB1c2VyIHJlamVjdGVkIGFjdGlvbmAsIFwiQUNUSU9OX1JFSkVDVEVEXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IChhY3Rpb25NYXBbbWV0aG9kXSB8fCBcInVua25vd25cIiksXG4gICAgICAgICAgICAgICAgcmVhc29uOiBcInJlamVjdGVkXCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiB8fCBtZXRob2QgPT09IFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IChwYXlsb2FkLnBhcmFtc1swXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzfGJhc2UgZmVlIGV4Y2VlZHMgZ2FzIGxpbWl0L2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UvaSkgJiYgbWVzc2FnZS5tYXRjaCgvdG9vIGxvdy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uL2kpICYmIG1lc3NhZ2UubWF0Y2goL3VuZGVycHJpY2VkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIiwgeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL29ubHkgcmVwbGF5LXByb3RlY3RlZC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IG1ldGhvZCwgaW5mbzogeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdW5zdXBwb3J0ZWQgPSAhIW1lc3NhZ2UubWF0Y2goL3RoZSBtZXRob2QgLiogZG9lcyBub3QgZXhpc3QvaSk7XG4gICAgICAgIGlmICghdW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5kZXRhaWxzICYmIGVycm9yLmRldGFpbHMuc3RhcnRzV2l0aChcIlVuYXV0aG9yaXplZCBtZXRob2Q6XCIpKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcInVuc3VwcG9ydGVkIG9wZXJhdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCwgaW5mbzogeyBlcnJvciwgcGF5bG9hZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiY291bGQgbm90IGNvYWxlc2NlIGVycm9yXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IGVycm9yLCBwYXlsb2FkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVxdWVzdHMgdGhlICUlbWV0aG9kJSUgd2l0aCAlJXBhcmFtcyUlIHZpYSB0aGUgSlNPTi1SUEMgcHJvdG9jb2xcbiAgICAgKiAgb3ZlciB0aGUgdW5kZXJseWluZyBjaGFubmVsLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhbGwgbWV0aG9kc1xuICAgICAqICBvbiB0aGUgYmFja2VuZCB0aGF0IGRvIG5vdCBoYXZlIGEgaGlnaC1sZXZlbCBBUEkgd2l0aGluIHRoZSBQcm92aWRlclxuICAgICAqICBBUEkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgcXVldWVzIHJlcXVlc3RzIGFjY29yZGluZyB0byB0aGUgYmF0Y2ggY29uc3RyYWludHNcbiAgICAgKiAgaW4gdGhlIG9wdGlvbnMsIGFzc2lnbnMgdGhlIHJlcXVlc3QgYSB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiAgKipEbyBOT1Qgb3ZlcnJpZGUqKiB0aGlzIG1ldGhvZCBpbiBzdWItY2xhc3NlczsgaW5zdGVhZFxuICAgICAqICBvdmVycmlkZSBbW19zZW5kXV0gb3IgZm9yY2UgdGhlIG9wdGlvbnMgdmFsdWVzIGluIHRoZVxuICAgICAqICBjYWxsIHRvIHRoZSBjb25zdHJ1Y3RvciB0byBtb2RpZnkgdGhpcyBtZXRob2QncyBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEBUT0RPOiBjYWNoZSBjaGFpbklkPz8gcHVyZ2Ugb24gc3dpdGNoX25ldHdvcmtzXG4gICAgICAgIC8vIFdlIGhhdmUgYmVlbiBkZXN0cm95ZWQ7IG5vIG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZCBhbnltb3JlXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IG1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLiNuZXh0SWQrKztcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsIHJlamVjdCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IG1ldGhvZCwgcGFyYW1zLCBpZCwganNvbnJwYzogXCIyLjBcIiB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBhIHBlbmRpbmcgZHJhaW5UaW1lciwgc2V0IG9uZVxuICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIFtbU2lnbmVyXV0gYWNjb3VudCBmb3IgICUlYWRkcmVzcyUlIG1hbmFnZWQgYnlcbiAgICAgKiAgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVhZGRyZXNzJSUgaXMgYSBudW1iZXIsIGl0IGlzIHVzZWQgYXMgYW4gaW5kZXggaW4gdGhlXG4gICAgICogIHRoZSBhY2NvdW50cyBmcm9tIFtbbGlzdEFjY291bnRzXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBiZSB1c2VkIG9uIGNsaWVudHMgd2hpY2ggbWFuYWdlIGFjY291bnRzIChzdWNoIGFzXG4gICAgICogIEdldGggd2l0aCBpbXBvcnRlZCBhY2NvdW50IG9yIE1ldGFNYXNrKS5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIGFjY291bnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50c1Byb21pc2UgPSB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICAvLyBBY2NvdW50IGluZGV4XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IChhd2FpdCBhY2NvdW50c1Byb21pc2UpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPj0gYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCBhY2NvdW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFjY291bnRzW2FkZHJlc3NdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50c1Byb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFjY291bnQgYWRkcmVzc1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgZm9yIChjb25zdCBhY2NvdW50IG9mIGFjY291bnRzKSB7XG4gICAgICAgICAgICBpZiAoZ2V0QWRkcmVzcyhhY2NvdW50KSA9PT0gYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFjY291bnRcIik7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RBY2NvdW50cygpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgcHJvY2Vzc2luZyByZXF1ZXN0c1xuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RyYWluVGltZXIpO1xuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgIGZvciAoY29uc3QgeyBwYXlsb2FkLCByZWplY3QgfSBvZiB0aGlzLiNwYXlsb2Fkcykge1xuICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAvLyBQYXJlbnQgY2xlYW4tdXBcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbi8vIEBUT0RPOiByZW1vdmUgdGhpcyBpbiB2NywgaXQgaXMgbm90IGV4cG9ydGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbmFsaXR5XG4vLyBpcyBleHBvc2VkIGluIHRoZSBKc29uUnBjQXBpUHJvdmlkZXIgYnkgc2V0dGluZyBwb2xsaW5nIHRvIHRydWUuIEl0IHNob3VsZFxuLy8gYmUgc2FmZSB0byByZW1vdmUgcmVnYXJkbGVzcywgYmVjYXVzZSBpdCBpc24ndCByZWFjaGFibGUsIGJ1dCBqdXN0IGluIGNhc2UuXG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUHJvdmlkZXIge1xuICAgICNwb2xsaW5nSW50ZXJ2YWw7XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgbGV0IHBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuX2dldE9wdGlvbihcInBvbGxpbmdJbnRlcnZhbFwiKTtcbiAgICAgICAgaWYgKHBvbGxpbmdJbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb2xsaW5nSW50ZXJ2YWwgPSBkZWZhdWx0T3B0aW9ucy5wb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gcG9sbGluZ0ludGVydmFsO1xuICAgIH1cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YnNjcmliZXIpKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwb2xsaW5nIGludGVydmFsIChkZWZhdWx0OiA0MDAwIG1zKVxuICAgICAqL1xuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludGVydmFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxpbmdJbnRlcnZhbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigoc3ViKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNQb2xsYWJsZShzdWIpKSB7XG4gICAgICAgICAgICAgICAgc3ViLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgVGhlIEpzb25ScGNQcm92aWRlciBpcyBvbmUgb2YgdGhlIG1vc3QgY29tbW9uIFByb3ZpZGVycyxcbiAqICB3aGljaCBwZXJmb3JtcyBhbGwgb3BlcmF0aW9ucyBvdmVyIEhUVFAgKG9yIEhUVFBTKSByZXF1ZXN0cy5cbiAqXG4gKiAgRXZlbnRzIGFyZSBwcm9jZXNzZWQgYnkgcG9sbGluZyB0aGUgYmFja2VuZCBmb3IgdGhlIGN1cnJlbnQgYmxvY2tcbiAqICBudW1iZXI7IHdoZW4gaXQgYWR2YW5jZXMsIGFsbCBibG9jay1iYXNlIGV2ZW50cyBhcmUgdGhlbiBjaGVja2VkXG4gKiAgZm9yIHVwZGF0ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIHtcbiAgICAjY29ubmVjdDtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICB1cmwgPSBcImh0dHA6L1xcL2xvY2FsaG9zdDo4NTQ1XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gdXJsLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjb25uZWN0LmNsb25lKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQWxsIHJlcXVlc3RzIGFyZSBvdmVyIEhUVFAsIHNvIHdlIGNhbiBqdXN0IHN0YXJ0IGhhbmRsaW5nIHJlcXVlc3RzXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgaGVyZSByYXRoZXIgdGhhbiB0aGUgY29uc3RydWN0b3Igc28gdGhhdCB3ZSBkb24ndCBzZW5kIGFueVxuICAgICAgICAvLyByZXF1ZXN0cyB0byB0aGUgbmV0d29yayAoaS5lLiBldGhfY2hhaW5JZCkgdW50aWwgd2UgYWJzb2x1dGVseSBoYXZlIHRvLlxuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kKHBheWxvYWQpIHtcbiAgICAgICAgLy8gQ29uZmlndXJlIGEgUE9TVCBjb25uZWN0aW9uIGZvciB0aGUgcmVxdWVzdGVkIG1ldGhvZFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICByZXF1ZXN0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xuICAgICAgICBsZXQgcmVzcCA9IHJlc3BvbnNlLmJvZHlKc29uO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcCkpIHtcbiAgICAgICAgICAgIHJlc3AgPSBbcmVzcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfVxufVxuZnVuY3Rpb24gc3BlbHVua0RhdGEodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tZXNzYWdlLm1hdGNoKC9yZXZlcnQvaSkgJiYgaXNIZXhTdHJpbmcodmFsdWUuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogdmFsdWUubWVzc2FnZSwgZGF0YTogdmFsdWUuZGF0YSB9O1xuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmtEYXRhKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWx1bmtEYXRhKEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZSwgcmVzdWx0KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZVtrZXldLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIF9zcGVsdW5rTWVzc2FnZShKU09OLnBhcnNlKHZhbHVlKSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNwZWx1bmtNZXNzYWdlKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1qc29ucnBjLmpzLm1hcCIsImltcG9ydCB7IGdldEFkZHJlc3MsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGhhc2hBdXRob3JpemF0aW9uLCBoYXNoTWVzc2FnZSwgVHlwZWREYXRhRW5jb2RlciB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBBYnN0cmFjdFNpZ25lciwgY29weVJlcXVlc3QgfSBmcm9tIFwiLi4vcHJvdmlkZXJzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb21wdXRlQWRkcmVzcywgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8qKlxuICogIFRoZSAqKkJhc2VXYWxsZXQqKiBpcyBhIHN0cmVhbS1saW5lZCBpbXBsZW1lbnRhdGlvbiBvZiBhXG4gKiAgW1tTaWduZXJdXSB0aGF0IG9wZXJhdGVzIHdpdGggYSBwcml2YXRlIGtleS5cbiAqXG4gKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW1tXYWxsZXRdXSBjbGFzcywgYXMgaXQgb2ZmZXJzXG4gKiAgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IGFuZCBzaW1wbGlmaWVzIGxvYWRpbmcgYSB2YXJpZXR5XG4gKiAgb2YgSlNPTiBmb3JtYXRzLCBNbmVtb25pYyBQaHJhc2VzLCBldGMuXG4gKlxuICogIFRoaXMgY2xhc3MgbWF5IGJlIG9mIHVzZSBmb3IgdGhvc2UgYXR0ZW1wdGluZyB0byBpbXBsZW1lbnRcbiAqICBhIG1pbmltYWwgU2lnbmVyLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZVdhbGxldCBleHRlbmRzIEFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHdhbGxldCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgI3NpZ25pbmdLZXk7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgQmFzZVdhbGxldCBmb3IgJSVwcml2YXRlS2V5JSUsIG9wdGlvbmFsbHlcbiAgICAgKiAgY29ubmVjdGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKlxuICAgICAqICBJZiAlJXByb3ZpZGVyJSUgaXMgbm90IHNwZWNpZmllZCwgb25seSBvZmZsaW5lIG1ldGhvZHMgY2FuXG4gICAgICogIGJlIHVzZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZUtleSwgcHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwcml2YXRlS2V5ICYmIHR5cGVvZiAocHJpdmF0ZUtleS5zaWduKSA9PT0gXCJmdW5jdGlvblwiLCBcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICB0aGlzLiNzaWduaW5nS2V5ID0gcHJpdmF0ZUtleTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzKHRoaXMuc2lnbmluZ0tleS5wdWJsaWNLZXkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgLy8gU3RvcmUgcHJpdmF0ZSB2YWx1ZXMgYmVoaW5kIGdldHRlcnMgdG8gcmVkdWNlIHZpc2liaWxpdHlcbiAgICAvLyBpbiBjb25zb2xlLmxvZ1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tTaWduaW5nS2V5XV0gdXNlZCBmb3Igc2lnbmluZyBwYXlsb2Fkcy5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmluZ0tleSgpIHsgcmV0dXJuIHRoaXMuI3NpZ25pbmdLZXk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHByaXZhdGUga2V5IGZvciB0aGlzIHdhbGxldC5cbiAgICAgKi9cbiAgICBnZXQgcHJpdmF0ZUtleSgpIHsgcmV0dXJuIHRoaXMuc2lnbmluZ0tleS5wcml2YXRlS2V5OyB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIHRoaXMuYWRkcmVzczsgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlV2FsbGV0KHRoaXMuI3NpZ25pbmdLZXksIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIHR4ID0gY29weVJlcXVlc3QodHgpO1xuICAgICAgICAvLyBSZXBsYWNlIGFueSBBZGRyZXNzYWJsZSBvciBFTlMgbmFtZSB3aXRoIGFuIGFkZHJlc3NcbiAgICAgICAgY29uc3QgeyB0bywgZnJvbSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdG86ICh0eC50byA/IHJlc29sdmVBZGRyZXNzKHR4LnRvLCB0aGlzKSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICBmcm9tOiAodHguZnJvbSA/IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIHRoaXMpIDogdW5kZWZpbmVkKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LnRvID0gdG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZ2V0QWRkcmVzcygodHguZnJvbSkpID09PSB0aGlzLmFkZHJlc3MsIFwidHJhbnNhY3Rpb24gZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHguZnJvbVwiLCB0eC5mcm9tKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0eC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBjb25zdCBidHggPSBUcmFuc2FjdGlvbi5mcm9tKHR4KTtcbiAgICAgICAgYnR4LnNpZ25hdHVyZSA9IHRoaXMuc2lnbmluZ0tleS5zaWduKGJ0eC51bnNpZ25lZEhhc2gpO1xuICAgICAgICByZXR1cm4gYnR4LnNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbk1lc3NhZ2VTeW5jKG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQWRkIGEgc2VjaWFsaXplZCBzaWduVHggYW5kIHNpZ25UeXBlZCBzeW5jIHRoYXQgZW5mb3JjZXNcbiAgICAvLyBhbGwgcGFyYW1ldGVycyBhcmUga25vd24/XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHNpZ25hdHVyZSBmb3IgJSVtZXNzYWdlJSUgc2lnbmVkIHdpdGggdGhpcyB3YWxsZXQuXG4gICAgICovXG4gICAgc2lnbk1lc3NhZ2VTeW5jKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmluZ0tleS5zaWduKGhhc2hNZXNzYWdlKG1lc3NhZ2UpKS5zZXJpYWxpemVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgQXV0aG9yaXphdGlvbiBmb3IgJSVhdXRoJSUuXG4gICAgICovXG4gICAgYXV0aG9yaXplU3luYyhhdXRoKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoYXV0aC5hZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3MgZm9yIGF1dGhvcml6ZVN5bmNcIiwgXCJhdXRoLmFkZHJlc3NcIiwgYXV0aCk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuc2lnbmluZ0tleS5zaWduKGhhc2hBdXRob3JpemF0aW9uKGF1dGgpKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYXV0aC5hZGRyZXNzKSxcbiAgICAgICAgICAgIG5vbmNlOiBnZXRCaWdJbnQoYXV0aC5ub25jZSB8fCAwKSxcbiAgICAgICAgICAgIGNoYWluSWQ6IGdldEJpZ0ludChhdXRoLmNoYWluSWQgfHwgMCksXG4gICAgICAgIH0sIHsgc2lnbmF0dXJlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIEF1dGhvcml6YXRpb24gZm9yICUlYXV0aCUlLlxuICAgICAqL1xuICAgIGFzeW5jIGF1dGhvcml6ZShhdXRoKSB7XG4gICAgICAgIGF1dGggPSBPYmplY3QuYXNzaWduKHt9LCBhdXRoLCB7XG4gICAgICAgICAgICBhZGRyZXNzOiBhd2FpdCByZXNvbHZlQWRkcmVzcyhhdXRoLmFkZHJlc3MsIHRoaXMpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRob3JpemVTeW5jKGF3YWl0IHRoaXMucG9wdWxhdGVBdXRob3JpemF0aW9uKGF1dGgpKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzXG4gICAgICAgIGNvbnN0IHBvcHVsYXRlZCA9IGF3YWl0IFR5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBhc3luYyAobmFtZSkgPT4ge1xuICAgICAgICAgICAgLy8gQFRPRE86IHRoaXMgc2hvdWxkIHVzZSByZXNvbHZlTmFtZTsgYWRkcmVzc2VzIGRvbid0XG4gICAgICAgICAgICAvLyAgICAgICAgbmVlZCBhIHByb3ZpZGVyXG4gICAgICAgICAgICBhc3NlcnQodGhpcy5wcm92aWRlciAhPSBudWxsLCBcImNhbm5vdCByZXNvbHZlIEVOUyBuYW1lcyB3aXRob3V0IGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsgbmFtZSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0KGFkZHJlc3MgIT0gbnVsbCwgXCJ1bmNvbmZpZ3VyZWQgRU5TIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduaW5nS2V5LnNpZ24oVHlwZWREYXRhRW5jb2Rlci5oYXNoKHBvcHVsYXRlZC5kb21haW4sIHR5cGVzLCBwb3B1bGF0ZWQudmFsdWUpKS5zZXJpYWxpemVkO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2Utd2FsbGV0LmpzLm1hcCIsImltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBzdWJzQ2hycyA9IFwiICEjJCUmJygpKissLS4vPD0+P0BbXV5fYHt8fX5cIjtcbmNvbnN0IFdvcmQgPSAvXlthLXpdKiQvaTtcbmZ1bmN0aW9uIHVuZm9sZCh3b3Jkcywgc2VwKSB7XG4gICAgbGV0IGluaXRpYWwgPSA5NztcbiAgICByZXR1cm4gd29yZHMucmVkdWNlKChhY2N1bSwgd29yZCkgPT4ge1xuICAgICAgICBpZiAod29yZCA9PT0gc2VwKSB7XG4gICAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod29yZC5tYXRjaChXb3JkKSkge1xuICAgICAgICAgICAgYWNjdW0ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGluaXRpYWwpICsgd29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsID0gOTc7XG4gICAgICAgICAgICBhY2N1bS5wdXNoKHdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCBbXSk7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGRhdGEsIHN1YnMpIHtcbiAgICAvLyBSZXBsYWNlIGFsbCB0aGUgc3Vic3RpdHV0aW9ucyB3aXRoIHRoZWlyIGV4cGFuZGVkIGZvcm1cbiAgICBmb3IgKGxldCBpID0gc3Vic0NocnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoc3Vic0NocnNbaV0pLmpvaW4oc3Vicy5zdWJzdHJpbmcoMiAqIGksIDIgKiBpICsgMikpO1xuICAgIH1cbiAgICAvLyBHZXQgYWxsIHRsZSBjbHVtcHM7IGVhY2ggc3VmZml4LCBmaXJzdC1pbmNyZW1lbnQgYW5kIHNlY29uZC1pbmNyZW1lbnRcbiAgICBjb25zdCBjbHVtcHMgPSBbXTtcbiAgICBjb25zdCBsZWZ0b3ZlciA9IGRhdGEucmVwbGFjZSgvKDp8KFswLTldKXwoW0EtWl1bYS16XSopKS9nLCAoYWxsLCBpdGVtLCBzZW1pLCB3b3JkKSA9PiB7XG4gICAgICAgIGlmIChzZW1pKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VJbnQoc2VtaSk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY2x1bXBzLnB1c2goXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2x1bXBzLnB1c2goaXRlbS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9KTtcbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAobGVmdG92ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBsZWZ0b3ZlcnM6ICR7SlNPTi5zdHJpbmdpZnkobGVmdG92ZXIpfWApO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIHJldHVybiB1bmZvbGQodW5mb2xkKGNsdW1wcywgXCI7XCIpLCBcIjpcIik7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlT3dsKGRhdGEpIHtcbiAgICBhc3NlcnRBcmd1bWVudChkYXRhWzBdID09PSBcIjBcIiwgXCJ1bnN1cHBvcnRlZCBhdXdsIGRhdGFcIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIHJldHVybiBkZWNvZGUoZGF0YS5zdWJzdHJpbmcoMSArIDIgKiBzdWJzQ2hycy5sZW5ndGgpLCBkYXRhLnN1YnN0cmluZygxLCAxICsgMiAqIHN1YnNDaHJzLmxlbmd0aCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2RlLW93bC5qcy5tYXAiLCJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBBIFdvcmRsaXN0IHJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIGxhbmd1YWdlLXNwZWNpZmljXG4gKiAgd29yZHMgdXNlZCB0byBlbmNvZGUgYW5kIGRldm9jZSBbW2xpbmstYmlwLTM5XV0gZW5jb2RlZCBkYXRhXG4gKiAgYnkgbWFwcGluZyB3b3JkcyB0byAxMS1iaXQgdmFsdWVzIGFuZCB2aWNlIHZlcnNhLlxuICovXG5leHBvcnQgY2xhc3MgV29yZGxpc3Qge1xuICAgIGxvY2FsZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBXb3JkbGlzdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBNVVNUIGNhbGwgdGhpcyBpZiB0aGV5IHByb3ZpZGUgdGhlaXIgb3duIGNvbnN0cnVjdG9yLFxuICAgICAqICBwYXNzaW5nIGluIHRoZSBsb2NhbGUgc3RyaW5nIG9mIHRoZSBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqICBHZW5lcmFsbHkgdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGEgV29yZGxpc3QsXG4gICAgICogIHNpbmNlIGVhY2ggbGFuZ3VhZ2Utc3BlY2lmaWMgV29yZGxpc3QgY3JlYXRlcyBhbiBpbnN0YW5jZSBhbmRcbiAgICAgKiAgdGhlcmUgaXMgbm8gc3RhdGUga2VwdCBpbnRlcm5hbGx5LCBzbyB0aGV5IGFyZSBzYWZlIHRvIHNoYXJlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbG9jYWxlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gcHJvdmlkZSBhIGxhbmd1YWdlLXNwZWNpZmljXG4gICAgICogIG1ldGhvZCBmb3Igc3BsaXRpbmcgJSVwaHJhc2UlJSBpbnRvIGluZGl2aWR1YWwgd29yZHMuXG4gICAgICpcbiAgICAgKiAgQnkgZGVmYXVsdCwgJSVwaHJhc2UlJSBpcyBzcGxpdCB1c2luZyBhbnkgc2VxdWVuY2VzIG9mXG4gICAgICogIHdoaXRlLXNwYWNlIGFzIGRlZmluZWQgYnkgcmVndWxhciBleHByZXNzaW9ucyAoaS5lLiBgYC9cXHMrL2BgKS5cbiAgICAgKi9cbiAgICBzcGxpdChwaHJhc2UpIHtcbiAgICAgICAgcmV0dXJuIHBocmFzZS50b0xvd2VyQ2FzZSgpLnNwbGl0KC9cXHMrL2cpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gcHJvdmlkZXIgYSBsYW5ndWFnZS1zcGVjaWZpY1xuICAgICAqICBtZXRob2QgZm9yIGpvaW5pbmcgJSV3b3JkcyUlIGludG8gYSBwaHJhc2UuXG4gICAgICpcbiAgICAgKiAgQnkgZGVmYXVsdCwgJSV3b3JkcyUlIGFyZSBqb2luZWQgYnkgYSBzaW5nbGUgc3BhY2UuXG4gICAgICovXG4gICAgam9pbih3b3Jkcykge1xuICAgICAgICByZXR1cm4gd29yZHMuam9pbihcIiBcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29yZGxpc3QuanMubWFwIiwiLy8gVXNlIHRoZSBlbmNvZGUtbGF0aW4uanMgc2NyaXB0IHRvIGNyZWF0ZSB0aGUgbmVjZXNzYXJ5XG4vLyBkYXRhIGZpbGVzIHRvIGJlIGNvbnN1bWVkIGJ5IHRoaXMgY2xhc3NcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVPd2wgfSBmcm9tIFwiLi9kZWNvZGUtb3dsLmpzXCI7XG5pbXBvcnQgeyBXb3JkbGlzdCB9IGZyb20gXCIuL3dvcmRsaXN0LmpzXCI7XG4vKipcbiAqICBBbiBPV0wgZm9ybWF0IFdvcmRsaXN0IGlzIGFuIGVuY29kaW5nIG1ldGhvZCB0aGF0IGV4cGxvaXRzXG4gKiAgdGhlIGdlbmVyYWwgbG9jYWxpdHkgb2YgYWxwaGFiZXRpY2FsbHkgc29ydGVkIHdvcmRzIHRvXG4gKiAgYWNoaWV2ZSBhIHNpbXBsZSBidXQgZWZmZWN0aXZlIG1lYW5zIG9mIGNvbXByZXNzaW9uLlxuICpcbiAqICBUaGlzIGNsYXNzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIHRvIG1vc3QgZGV2ZWxvcGVycyBhc1xuICogIGl0IGlzIHVzZWQgbWFpbmx5IGludGVybmFsbHkgdG8ga2VlcCBXb3JkbGlzdHMgZm9yIGxhbmd1YWdlc1xuICogIGJhc2VkIG9uIEFTQ0lJLTcgc21hbGwuXG4gKlxuICogIElmIG5lY2Vzc2FyeSwgdGhlcmUgYXJlIHRvb2xzIHdpdGhpbiB0aGUgYGBnZW5lcmF0aW9uL2BgIGZvbGRlclxuICogIHRvIGNyZWF0ZSB0aGUgbmVjZXNzYXJ5IGRhdGEuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JkbGlzdE93bCBleHRlbmRzIFdvcmRsaXN0IHtcbiAgICAjZGF0YTtcbiAgICAjY2hlY2tzdW07XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgV29yZGxpc3QgZm9yICUlbG9jYWxlJSUgdXNpbmcgdGhlIE9XTCAlJWRhdGElJVxuICAgICAqICBhbmQgdmFsaWRhdGVkIGFnYWluc3QgdGhlICUlY2hlY2tzdW0lJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGRhdGEsIGNoZWNrc3VtKSB7XG4gICAgICAgIHN1cGVyKGxvY2FsZSk7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLiNjaGVja3N1bSA9IGNoZWNrc3VtO1xuICAgICAgICB0aGlzLiN3b3JkcyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgT1dMLWVuY29kZWQgZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgX2RhdGEoKSB7IHJldHVybiB0aGlzLiNkYXRhOyB9XG4gICAgLyoqXG4gICAgICogIERlY29kZSBhbGwgdGhlIHdvcmRzIGZvciB0aGUgd29yZGxpc3QuXG4gICAgICovXG4gICAgX2RlY29kZVdvcmRzKCkge1xuICAgICAgICByZXR1cm4gZGVjb2RlT3dsKHRoaXMuI2RhdGEpO1xuICAgIH1cbiAgICAjd29yZHM7XG4gICAgI2xvYWRXb3JkcygpIHtcbiAgICAgICAgaWYgKHRoaXMuI3dvcmRzID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gdGhpcy5fZGVjb2RlV29yZHMoKTtcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgY29tcHV0ZWQgbGlzdCBtYXRjaGVzIHRoZSBvZmZpY2lhbCBsaXN0XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGlkKHdvcmRzLmpvaW4oXCJcXG5cIikgKyBcIlxcblwiKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKGNoZWNrc3VtICE9PSB0aGlzLiNjaGVja3N1bSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQklQMzkgV29yZGxpc3QgZm9yICR7dGhpcy5sb2NhbGV9IEZBSUxFRGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHRoaXMuI3dvcmRzID0gd29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3dvcmRzO1xuICAgIH1cbiAgICBnZXRXb3JkKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gdGhpcy4jbG9hZFdvcmRzKCk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAgJiYgaW5kZXggPCB3b3Jkcy5sZW5ndGgsIGBpbnZhbGlkIHdvcmQgaW5kZXg6ICR7aW5kZXh9YCwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIHJldHVybiB3b3Jkc1tpbmRleF07XG4gICAgfVxuICAgIGdldFdvcmRJbmRleCh3b3JkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNsb2FkV29yZHMoKS5pbmRleE9mKHdvcmQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmRsaXN0LW93bC5qcy5tYXAiLCJpbXBvcnQgeyBXb3JkbGlzdE93bCB9IGZyb20gXCIuL3dvcmRsaXN0LW93bC5qc1wiO1xuY29uc3Qgd29yZHMgPSBcIjBlcmxlb25hbG9yZW5zZWluY2VyZWdlc3RpY2l0U3RhbnZldGVhcmN0c3NpI2NoMkF0aGNrJnRuZUxsMEFuZCNJbC55TGVPdXRPPVN8UyViL3JhQFN1cmRVJzBDZVtDaWR8Q291bnRDdSdIaWU9SWRPdSwtUXVpKlJvW1RUXVQlVCpbVHUkMEFwdERELXREKltKdSxNLlVsdFY8KVZpKTBSb2ItMEZhaXJGJWRSYWlkMEEoRUVudFJlZTBFYWQwTVJScCV0UyFfcm1CdW1Db2hvbEVydEkmTExleUxvd01vLE99UGhhUmVhZHlTb1QgV2F5czBBPnVyQXooZ09uZ091bnRVJ2QwQWx5LENoJUNpfEcgRyFHcnlJbSRLIU5vdW4pTnUkT2AgU3cgVCZuYVRpcXVlWGlldHlZMUFydE9sb2d5UGU/UCFQcm89UmlsMUNoQ3QtRWFFbmFHdWVNTWVkTSVNeU91bmRSPCtSZSxSaT1Sb3dUVGVmYUBUaSxUdyVrMEtQZUBTYXVsdFNldFNpLFN1bWVUaG1hMEghPk9tVGF7VCZkVC51ZGVUcmFAMEN0XUQuR3UsTnRUaCVUb1R1bW4wRXJhK09jYWRvT2lkMEFrZUEqQXlFc29tZUZ1bEt3P2QwSXM6QnlDaGVsJUMjRCtHTDwpTGMjeX5NYm9vTjxhTm4gUlJlbHlSZ2EoUipsU2VTLVNrZXRUdCEzQV5BbkF1dHlDYXUnQ29tZUVmRiVlRyhIYT1IKGRMaWU9TG93THROXk5lZi4vVHJheVR0IFR3ZSZZI2QzQ3ljIURLZU5kT2xvZ3lSZFJgVHQgX3tBZGVBbWVBbmtldEEsRWFrRVtJbmRPb2RPW29tT3UnVWVVclVzaF9yZEF0RHlJbE1iTmVOdXNPa08sUmQgUihnUnJvd1NzVHRvbVVuKVhZX3tldEEoQW5kQVtBPUVhZEVlemVJe0lkK0llZklnaHRJbmdJc2tPY2NvbGlPayZPbnplT29tT2AgT3duVXNoMkJiIURkeUQrdEZmJG9JbGRMYkxrTCF0TmQhTmsgUmQmUmcgUixTUyhlW1N5VHQgWSBaejpCYmErQihCIUN0dXNHZUtlfkxtTSBhTXBOTiROKWxOZHlObiNOb2VOdmFzTnkjUGFiIVAuJFB0YShSUmIjUmRSZ29ScGV0UnJ5UnRTZVNoUyhvLyFTdSRUVCRvZ1ReVGVnJXlUdCFVZ2h0VSdVdF1WZTNJbChnTCB5TXxOc3VzTnR1cnlSZSRSdGEoX2lyQWxrQW1wXUFuK0Fvc0FwdCBBcitBJ0F0RWFwRXtFZSdFZkVycnlFLEl7JkllZklsZEltfXlPaSlPbydSIy1VeyFVbmtVcm4wRz9ObmFtI1JjIVRpeiZUeVZpbF9pbUFwQXJpZnlBd0F5RTxFcmtFdiBJe0l8SWZmSW1iSW4tSXBPe09nTydPYE91ZE93blViVW1wVSwgVXReX15BLEMjdXREZUZmZWVJbEluTCFATCVMdW1uTWIoZU1lTWYldE0tTW0jTXA8eU5jIHROZHVATmZpcm1OZypbTn1ATnNpZCBOdHJvbE52KClPa09sUHAgUHlSJFJlUm5SKkAvVHQjVV5VbnRyeVVwIVVyJ1VzKFYgWW8+X3tBZCFBZnRBbUF9QXNoQXQgQXdsQXp5RWFtRWQuRWVrRXdJe2V0SW1lSXNwSXQtT3BPW091Xk93ZFVjaSRVZWxVaSdVbWIhVW5eVXNoWVksJDJCZUx0dSpQUGJvP2RSaW91c1JyfFJ0YShSPVNoXS9vbVRlM0MhOkRNYStNcE4pTmcgUihnU2hVZ2h0IFduWTNBbEJhPkJyaXNDYWRlQ2VtYiBDaWRlQ2woZUMlYT5DKmEnRXJGJidGKGVGeUcqZUxheUxpdiBNPGRNaSdOaSROdGksTnlQP3RQJmRQb3MuUGBQdXR5Umk9U2NyaWJlUyB0U2lnblNrU3BhaXIvcm95VGFpbFRlQFZlbG9wVmkpVm8+M0FncmFtQWxBbSNkQXJ5Q2VFJ2xFdEZmIEcuJEduLnlMZW1tYU5uIE5vc2F1clJlQFJ0U2FnKmVTY292IFNlYSdTaFNtaVtTJWQgU3BsYXkvPClWIHRWaWRlViUpWnp5NUN0JUN1bXxHfkxwaChNYShOYT5Oa2V5TiVPclNlVWIhVmVfZnRBZyNBbWFBLC1Bd0VhbUVbSWZ0SWxsSW5rSXBJPU9wVW1ZMkNrTWJOZVIoZy9UXlR5MUFyZjFOYW0tOkcgRyFSbHlSblJgU2lseS9TeTFIb09sb2d5T25vbXkwR2VJdFVjYT4xRiV0MEcxR2h0VGggMkJvd0QgRUByLUVnPHRFbXxFcGg8dEV2YXQlST5TZTBCP2tCb2R5QnJhKUVyK090XVBsb3lQb3cgUHR5MEFiIUFAREQhW0QlJ0VteUVyZ3lGJSlHYStHKGVIPClKb3lMaSxPdWdoUi1oUm9sbFN1KlQgVGkqVHJ5VmVsb3BlMUlzb2RlMFUkVWlwMEFBJ09kZU9zXVIlVXB0MENhcGVTYXlTJilUYT4wRXJuJEgtczFJZCYpSWxPa2VPbD0xQUBBbXAhQ2VbQ2g8K0MuZUNsdWRlQ3UnRWN1PkVyY2knSGF1LEhpYi5JIUksSXRPdC1QPGRQZUBQaSpQbGEoUG8nUCpbVCZkVHJhMEVFYnJvdzpCci1DZUN1bHR5RGVJbnRJYH5MJ01lTWlseU1vdXNOTmN5TnRhc3lSbVNoXVRUJFRoIFRpZ3VlVWx0ViUuZTNBdHUqQnJ1P3lEICRFRWRFbE1hIU4pL2l2JFReViBXM0IgQ3RdRWxkR3UqTGVMbUx0IE4kTmROZU5nIE5pc2hSZVJtUixTYyRTaFRUfVtYX2dBbWVBc2hBdEF2JUVlSWdodElwT2F0T3tPJU93IFVpZFVzaFlfbUN1c0dJbExkfm93T2RPdFIpUmUsUit0UmtSdHV9UnVtUnc/ZFNzaWwvIFVuZFhfZ2khQW1lRXF1fEVzaEkmZEluK09nT250TyxPd25PeiZVLjJFbE5ObnlSbmEpUnlUdSo6RCt0SW5MYXh5fiB5TWVQUmErUmJhK1JkJlJsLVJtfFNTcFRlVGggVStaZTNOICROaXVzTipOdCFOdShlL3UqMk8sMEFudEZ0R2chTmcgUmFmZmVSbFZlX2RBbilBKkFbSWRlSW1wJ09iZU9vbU9yeU89T3dVZV90RGRlW0xkT2RPJ1JpbGxhU3BlbFNzaXBWIG5Xbl9iQSlBKEFudEFwZUFbQXYueUVhdEUmSWRJZWZJdE9jIHlPdXBPd1VudF9yZEVbSWRlSWx0SXQ/TjNNOkIuSXJMZk1tIE0sIE5kUHB5UmIlUmRSc2hSPSxUVmVXa1o/ZDNBZEFsYEFydEF2eUQraG9nSWdodH5vTG1ldExwTlJvM0RkJkdofk50UFJlLyV5NUJieUNrZXlMZExlTGlkYXl+b3dNZU5leU9kUGVSblJyJVInU3AuJC9UZWxVclYgNUJHZU08TWIhTSVOZCpkTmdyeU50UmQhUnJ5UnRTYjxkM0JyaWQ6MUVPbjBFYUVudGlmeUxlMk4lZTRMTGVnJEx9WzBBK0l0YT5NJidNdX1QYUBQbydQcm89UHVsJzBDaENsdWRlQ29tZUMqYSdEZXhELWE+RG8lRHUscnlGPHRGbC10RiVtSGEhSCAuSXRpJEplQEp1cnlNYT5OIE5vY3xQdXRRdWlyeVM8ZVNlQFNpZGVTcGkqLyRsVGFAVCBlLFRvVmUsVi5lVm9sPTNPbjBMPGRPbGE+U3VlMEVtMU9yeTpDa2V0R3U/Ulp6M0Fsb3VzQW5zfnlXZWw5QkluS2VVcn15WTVEK0kpTXBOZyFOaSVOay86Tmc/b28zRW5FcFRedXBZM0NrRER9eU5kTmdkb21Tc1RUXiZUZVR0JldpNEVlSWZlT3tPdzpCQmVsQiVEZCBEeUtlTXBOZ3VhK1B0b3BSK1QgVChVZ2hVbmRyeVZhV1duV3N1LlkgWnkzQWQgQWZBcm5BPUN0dSpGdEdHJEcmZElzdSpNI05kTmdgTnNPcD9kU3MjVHQgVmVsM0FyQiB0eUJyP3lDJidGZUZ0R2h0S2VNYk0uTmtPblF1aWQvVHQhVmVaP2Q1QWRBbkIsIEMkQ2tHLU5lbHlOZ09wVHQgeVVkVW4rVmVZJDVDa3lHZ2ErTWIgTj9OXlh1cnkzUi1zOkNoKGVERy1HfXRJZElsSW5KJUtlTW0kTk5hK05kYT5OZ29Oc11OdSRQIVJiIVJeUmcoUihlUmtldFJyaWErU2tTcy8gVF5UIGkkVGhUcml4VHQgWGltdW1aZTNBZG93QW5Bc3UqQXRDaDwtRCREaWFMb2R5THRNYiBNJXlOdF1OdVJjeVIrUi5ScnlTaFNzYStUJFRob2QzRGQhRG5pZ2h0TGt+XU0tTmROaW11bU4lTnU+UmFjIVJyJVMgeVNzL2FrZVhYZWRYdHUqNUJpIURlbERpZnlNTXxOLiVOa2V5TiwgTmBPblIkUmVSbihnU3F1Lm9UaCBUXVQlVW50YShVJ1ZlVmllNUNoRmYoTGVMdGlwbHlTYyFTZXVtU2hyb29tUy0vVHUkM1NlbGYvIHlUaDpJPU1lUGsoUnJvdy95VF1UdSozQXJDa0VkR2F0aT1HIUBJYCBQaGV3Uj0vVFR3JWtVdHIkViBXc1h0M0NlR2h0NUIhSSdNKGVlT2QhUm0kUmBTZVRhYiFUZVRoKGdUaSlWZWxXNUMhP01iIFInVDpLMEV5SmVATGkrU2N1KlMgPVRhKFZpb3VzMEN1ckU8VG9iIDBPcjFGRiBGaSlUJjJMMUF5MERJPVltcC0wSXQwQ2VFSSNMKGVMeTFFbkVyYUluXVBvJ1RdMUFuK0IuQ2g/ZEQgRCg/eUc8SXxJZygkUGg8MFRyLWgwSCAwVGRvJVQgVHB1dFRzaWRlMEFsRW5FcjBOTiAwWWcmMC8gME99OkN0RGQhR2VJckxhKUxtTmRhTmVsTi1OYCBQIFJhZGVSfFJrUnJvdFJ0eVNzVF5UaFRpfFRyb2xUdCBuVSdWZVltfDNBKUFudXRBckFzPHRMLTxOTiR0eU5jaWxPcCFQcCBSZmVAUm0uUnMjVDJPfU90b1JhJ1lzLSQwQW5vQ24tQ3R1KkUpR0dlI35Mb3ROa099IFBlL29sVF5aemFfKUF9dEEsLUE+QXlFYSdFZCtVe1VnVW4rMkVtRXRJbnRMP0xlTGkpTmROeU9sUHVsP1J0XVMuXVNzaWIhL1RhdG9UdCB5ViB0eVdkIFcgX0BpKUFpJ0VkLXRFZiBFcGEqRXN8RXR0eUV2fEkpSWRlSW0/eUludEklLnlJcyNJdmE+SXplT2IhbU8pW09kdSlPZi5PZ3JhbU9qZUBPbW8+T29mT3AgdHlPc3AgTz5AT3VkT3ZpZGUyQmwtRGQoZ35McEwnTXBrKE5eUGlsUHB5Ul5hJ1IueVJwbydSJ1NoVFp6ITNSYW1pZDo5OUFsLnlBbnR1bUFydCBFLF1Je0l0SXpPPjpCYi5DY28jQ2VDa0Q/RGlvSWxJbkknfnlNcE5eTmRvbU4rUGlkUmVUZVRoIFYmV1olM0FkeUFsQXMjQmVsQnVpbGRDJGxDZWk9Q2lwZUMlZEN5YyFEdSlGIUBGJW1GdSdHXUcqdEd1bD9KZUBMYXhMZWEnTGllZkx5TWEoTWVtYiBNKGRNbz1OZCBOZXdOdE9wJlBhaXJQZWF0UGxhKVAldFF1aSpTY3VlU2VtYiFTaSxTb3VyKVNwIydTdWx0VGkqVCphdFR1cm5Vbl1WZSRWaWV3Vz9kMllgbTBCQmIjQ2VDaERlRCtGIUdodEdpZE5nT3RQcCFTa1R1JFYkViA1QWRBLEJvdEJ1LENrZXRNPClPZk9raWVPbVNlVGE+VWdoVW5kVT5ZJDVCYiBEZUdMZU5Od2F5UiQ6RERkIUR9W0ZlSWxMYWRMbSNMI0x0THU+TWVNcCFOZFRpc2Z5VG9zaGlVKVVzYStWZVkxQSFBbkEqQXR0IEV9SGVtZUhvb2xJJilJWyVzT3JwXU91dFJhcFJlJlJpcHRSdWIxQUFyXkFzI0F0QyNkQyp0Q3RdQ3VyLnlFZEVrR218TGVAfk0oP05pJU4nTnQmKVJpZXNSdmkpU3NdVHQhVHVwViZfZG93QWZ0QWxsb3dBKkVkRWxsRXJpZmZJZWxkSWZ0SX1JcEl2IE97T2VPb3RPcE9ydE91bGQgTz1SaW1wUnVnVWZmIVkwQmwoZ0NrRGVFK0dodEduTHxMa355THYgTWlsP01wIU4pTmdSJi8gVHVhPlhaZTFBPkV0XklJbGxJbklydFVsbDBBYkFtRWVwRW5kIEkpSWRlSWdodEltT2c8T3RPd1VzaDBBbGxBcnRJIU9rZU9vYDBBe0FrZUFwSWZmT3cwQXBDYyBDaSRDa0RhRnRMP0xkaSBMaWRMdXRdTD1NZSNlTmdPblJyeVJ0VWxVbmRVcFVyKVVgMEEpQSpBdGkkQXduRWFrRWNpJEVlZEVsbEVuZEggZUkpSWQgSWtlSW5Jci5MLk9pbE9ucyVPI09ydE90UmF5UmVhZFIoZ1kwVWEqVWVlemVVaXIqbF9iIUFkaXVtQWZmQStBaXJzQW1wQW5kQXJ0QT5BeUVha0VlbEVtRXBFKm9Je0lsbEluZ097T21hXk99T29sT3J5Tz1SYT5neVJlZXRSaWtlUiNnUnVnZyFVZHxVZmZVbWIhWSEwQmplQEJtLkJ3YXlDKVtDaERkJkZmIEc/RyssSXRNbSBOTm55Tid0UCBQcGx5UCptZVJlUmZhKVIrUnByaSdScm91bmRSPXlTcGVAL2EoMUFsbG93QW1wQXBBcm1FP0VldElmdEltSW5nSXReT3JkMU1ib2xNcHRvbVJ1cC9lbTpCIUNrIUdJbEx8TGtOa1BlUit0U2svZVR0b29YaTNBXkFtfk5OPHRObmlzTnRSbS9YdF9ua0F0RW1lRW5FJXlFKkV5SW5nSXNPdWdodFJlZVJpPVJvd1VtYlVuZCAwQ2tldERlRyBMdE1iIE1lTnlQUmVkU3N1ZVQhNUEsQmFjY29EYXlEZGwgRUdlYCBJIXRLJk1hdG9NJXJvd05lTmd1ZU5pZ2h0T2xPYFBQLVBwIVJeUm5hZG9SdG9pJ1NzVCRVcmksVz9kVyBXbllfe0FkZUFmZi1BZy1BKEFuc2YgQXBBc2hBPWxBeUVhdEVlRW5kSSRJYmVJe0lnZyBJbUlwT3BoeU91YiFVe1VlVWx5VW1wZXRVLFVgWTJCZUl0XU1iIU5hTn1sUmtleVJuUnQhMUVsPUVudHlJKUluSSxPMVBlUC0kOjVMeTVCKmxsYTBBYiFBd2EqQyFDb3YgRCBEb0ZhaXJGb2xkSGFwcHlJZiVtSXF1ZUl0SXYgJ0tub3duTG97VGlsVXN1JFZlaWwxRGE+R3JhZGVIb2xkT25QIFNldDFCPEdlMEErRUVkRWZ1bEUhW1UkMElsLnk6Qzx0Q3V1bUd1ZUxpZEwheUw9Tk5pc2hQJVJpb3VzL1VsdDNILSFMPXROZCVOdHUqTnVlUmJSaWZ5UnNdUnlTJ2xUIDwzQWIhQnI8dENpb3VzQ3QleURlb0V3fmErTnRhK09sKFJ0dSRSdXNTYVMuU3UkVCRWaWQ1QyRJKUlkTGM8b0x1bWVUZVlhKzpHZUcjSXRMa35MbnV0TnRSZmEqUm1ScmklU2hTcC9lVCBWZVkzQWxgQXAjQXJBJ2xBYCBCRGQoZ0VrJmRJcmRMY29tZS9UXyFBdEVhdEVlbEVuRSpJcElzcCAwRGVEYEZlTGR+Tk5kb3dOZU5nTmtObiBOdCBSZVNkb21TZVNoVH1bNUxmTTxOZCBPZE9sUmRSa1JsZFJyeVJgX3BFe0UsIUksST5Pbmc6OlJkM0Fyfm93OVVVbmdVYDozQnJhUm85TmVPXCI7XG5jb25zdCBjaGVja3N1bSA9IFwiMHgzYzhhY2MxZTdiMDhkOGU3NmY5ZmRhMDE1ZWY0OGRjOGM3MTBhNzNjYjdlMGY3N2IyYzE4YTliNWE3YWRkZTYwXCI7XG5sZXQgd29yZGxpc3QgPSBudWxsO1xuLyoqXG4gKiAgVGhlIFtbbGluay1iaXAzOS1lbl1dIGZvciBbbW5lbW9uaWMgcGhyYXNlc10obGluay1iaXAtMzkpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xuICovXG5leHBvcnQgY2xhc3MgTGFuZ0VuIGV4dGVuZHMgV29yZGxpc3RPd2wge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBFbmdsaXNoIGxhbmd1YWdlIFdvcmRsaXN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGJlIHVubmVjZXNzYXJ5IG1vc3Qgb2YgdGhlIHRpbWUgYXMgdGhlIGV4cG9ydGVkXG4gICAgICogIFtbbGFuZ0VuXV0gc2hvdWxkIHN1ZmZpY2UuXG4gICAgICpcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IHN1cGVyKFwiZW5cIiwgd29yZHMsIGNoZWNrc3VtKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgYGBMYW5nRW5gYCwgY3JlYXRpbmcgaXRcbiAgICAgKiAgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgc3RhdGljIHdvcmRsaXN0KCkge1xuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBuZXcgTGFuZ0VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmctZW4uanMubWFwIiwiaW1wb3J0IHsgcGJrZGYyLCBzaGEyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCeXRlcywgaGV4bGlmeSwgYXNzZXJ0Tm9ybWFsaXplLCBhc3NlcnRQcml2YXRlLCBhc3NlcnRBcmd1bWVudCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IExhbmdFbiB9IGZyb20gXCIuLi93b3JkbGlzdHMvbGFuZy1lbi5qc1wiO1xuLy8gUmV0dXJucyBhIGJ5dGUgd2l0aCB0aGUgTVNCIGJpdHMgc2V0XG5mdW5jdGlvbiBnZXRVcHBlck1hc2soYml0cykge1xuICAgIHJldHVybiAoKDEgPDwgYml0cykgLSAxKSA8PCAoOCAtIGJpdHMpICYgMHhmZjtcbn1cbi8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIExTQiBiaXRzIHNldFxuZnVuY3Rpb24gZ2V0TG93ZXJNYXNrKGJpdHMpIHtcbiAgICByZXR1cm4gKCgxIDw8IGJpdHMpIC0gMSkgJiAweGZmO1xufVxuZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgYXNzZXJ0Tm9ybWFsaXplKFwiTkZLRFwiKTtcbiAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICB3b3JkbGlzdCA9IExhbmdFbi53b3JkbGlzdCgpO1xuICAgIH1cbiAgICBjb25zdCB3b3JkcyA9IHdvcmRsaXN0LnNwbGl0KG1uZW1vbmljKTtcbiAgICBhc3NlcnRBcmd1bWVudCgod29yZHMubGVuZ3RoICUgMykgPT09IDAgJiYgd29yZHMubGVuZ3RoID49IDEyICYmIHdvcmRzLmxlbmd0aCA8PSAyNCwgXCJpbnZhbGlkIG1uZW1vbmljIGxlbmd0aFwiLCBcIm1uZW1vbmljXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIGNvbnN0IGVudHJvcHkgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoMTEgKiB3b3Jkcy5sZW5ndGggLyA4KSk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgaW5kZXggPSB3b3JkbGlzdC5nZXRXb3JkSW5kZXgod29yZHNbaV0ubm9ybWFsaXplKFwiTkZLRFwiKSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAsIGBpbnZhbGlkIG1uZW1vbmljIHdvcmQgYXQgaW5kZXggJHtpfWAsIFwibW5lbW9uaWNcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIGZvciAobGV0IGJpdCA9IDA7IGJpdCA8IDExOyBiaXQrKykge1xuICAgICAgICAgICAgaWYgKGluZGV4ICYgKDEgPDwgKDEwIC0gYml0KSkpIHtcbiAgICAgICAgICAgICAgICBlbnRyb3B5W29mZnNldCA+PiAzXSB8PSAoMSA8PCAoNyAtIChvZmZzZXQgJSA4KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZW50cm9weUJpdHMgPSAzMiAqIHdvcmRzLmxlbmd0aCAvIDM7XG4gICAgY29uc3QgY2hlY2tzdW1CaXRzID0gd29yZHMubGVuZ3RoIC8gMztcbiAgICBjb25zdCBjaGVja3N1bU1hc2sgPSBnZXRVcHBlck1hc2soY2hlY2tzdW1CaXRzKTtcbiAgICBjb25zdCBjaGVja3N1bSA9IGdldEJ5dGVzKHNoYTI1NihlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpKVswXSAmIGNoZWNrc3VtTWFzaztcbiAgICBhc3NlcnRBcmd1bWVudChjaGVja3N1bSA9PT0gKGVudHJvcHlbZW50cm9weS5sZW5ndGggLSAxXSAmIGNoZWNrc3VtTWFzayksIFwiaW52YWxpZCBtbmVtb25pYyBjaGVja3N1bVwiLCBcIm1uZW1vbmljXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KGVudHJvcHkuc2xpY2UoMCwgZW50cm9weUJpdHMgLyA4KSk7XG59XG5mdW5jdGlvbiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCkge1xuICAgIGFzc2VydEFyZ3VtZW50KChlbnRyb3B5Lmxlbmd0aCAlIDQpID09PSAwICYmIGVudHJvcHkubGVuZ3RoID49IDE2ICYmIGVudHJvcHkubGVuZ3RoIDw9IDMyLCBcImludmFsaWQgZW50cm9weSBzaXplXCIsIFwiZW50cm9weVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICB3b3JkbGlzdCA9IExhbmdFbi53b3JkbGlzdCgpO1xuICAgIH1cbiAgICBjb25zdCBpbmRpY2VzID0gWzBdO1xuICAgIGxldCByZW1haW5pbmdCaXRzID0gMTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyb3B5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIENvbnN1bWUgdGhlIHdob2xlIGJ5dGUgKHdpdGggc3RpbGwgbW9yZSB0byBnbylcbiAgICAgICAgaWYgKHJlbWFpbmluZ0JpdHMgPiA4KSB7XG4gICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IDg7XG4gICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gfD0gZW50cm9weVtpXTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgLT0gODtcbiAgICAgICAgICAgIC8vIFRoaXMgYnl0ZSB3aWxsIGNvbXBsZXRlIGFuIDExLWJpdCBpbmRleFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSByZW1haW5pbmdCaXRzO1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IGVudHJvcHlbaV0gPj4gKDggLSByZW1haW5pbmdCaXRzKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IHdvcmRcbiAgICAgICAgICAgIGluZGljZXMucHVzaChlbnRyb3B5W2ldICYgZ2V0TG93ZXJNYXNrKDggLSByZW1haW5pbmdCaXRzKSk7XG4gICAgICAgICAgICByZW1haW5pbmdCaXRzICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgY2hlY2tzdW0gYml0c1xuICAgIGNvbnN0IGNoZWNrc3VtQml0cyA9IGVudHJvcHkubGVuZ3RoIC8gNDtcbiAgICBjb25zdCBjaGVja3N1bSA9IHBhcnNlSW50KHNoYTI1NihlbnRyb3B5KS5zdWJzdHJpbmcoMiwgNCksIDE2KSAmIGdldFVwcGVyTWFzayhjaGVja3N1bUJpdHMpO1xuICAgIC8vIFNoaWZ0IHRoZSBjaGVja3N1bSBpbnRvIHRoZSB3b3JkIGluZGljZXNcbiAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IGNoZWNrc3VtQml0cztcbiAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gfD0gKGNoZWNrc3VtID4+ICg4IC0gY2hlY2tzdW1CaXRzKSk7XG4gICAgcmV0dXJuIHdvcmRsaXN0LmpvaW4oaW5kaWNlcy5tYXAoKGluZGV4KSA9PiB3b3JkbGlzdC5nZXRXb3JkKGluZGV4KSkpO1xufVxuY29uc3QgX2d1YXJkID0ge307XG4vKipcbiAqICBBICoqTW5lbW9uaWMqKiB3cmFwcyBhbGwgcHJvcGVydGllcyByZXF1aXJlZCB0byBjb21wdXRlIFtbbGluay1iaXAtMzldXVxuICogIHNlZWRzIGFuZCBjb252ZXJ0IGJldHdlZW4gcGhyYXNlcyBhbmQgZW50cm9weS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1uZW1vbmljIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1uZW1vbmljIHBocmFzZSBvZiAxMiwgMTUsIDE4LCAyMSBvciAyNCB3b3Jkcy5cbiAgICAgKlxuICAgICAqICBVc2UgdGhlIFtbd29yZGxpc3RdXSBgYHNwbGl0YGAgbWV0aG9kIHRvIGdldCB0aGUgaW5kaXZpZHVhbCB3b3Jkcy5cbiAgICAgKi9cbiAgICBwaHJhc2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXNzd29yZCB1c2VkIGZvciB0aGlzIG1uZW1vbmljLiBJZiBubyBwYXNzd29yZCBpcyB1c2VkIHRoaXNcbiAgICAgKiAgaXMgdGhlIGVtcHR5IHN0cmluZyAoaS5lLiBgYFwiXCJgYCkgYXMgcGVyIHRoZSBzcGVjaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIHBhc3N3b3JkO1xuICAgIC8qKlxuICAgICAqICBUaGUgd29yZGxpc3QgZm9yIHRoaXMgbW5lbW9uaWMuXG4gICAgICovXG4gICAgd29yZGxpc3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSB1bmRlcmx5aW5nIGVudHJvcHkgd2hpY2ggdGhlIG1uZW1vbmljIGVuY29kZXMuXG4gICAgICovXG4gICAgZW50cm9weTtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgZW50cm9weSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpIHtcbiAgICAgICAgaWYgKHBhc3N3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhc3N3b3JkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBMYW5nRW4ud29yZGxpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiTW5lbW9uaWNcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCwgZW50cm9weSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHNlZWQgZm9yIHRoZSBtbmVtb25pYy5cbiAgICAgKi9cbiAgICBjb21wdXRlU2VlZCgpIHtcbiAgICAgICAgY29uc3Qgc2FsdCA9IHRvVXRmOEJ5dGVzKFwibW5lbW9uaWNcIiArIHRoaXMucGFzc3dvcmQsIFwiTkZLRFwiKTtcbiAgICAgICAgcmV0dXJuIHBia2RmMih0b1V0ZjhCeXRlcyh0aGlzLnBocmFzZSwgXCJORktEXCIpLCBzYWx0LCAyMDQ4LCA2NCwgXCJzaGE1MTJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IE1uZW1vbmljIGZvciB0aGUgJSVwaHJhc2UlJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVmYXVsdCAlJXBhc3N3b3JkJSUgaXMgdGhlIGVtcHR5IHN0cmluZyBhbmQgdGhlIGRlZmF1bHRcbiAgICAgKiAgd29yZGxpc3QgaXMgdGhlIFtFbmdsaXNoIHdvcmRsaXN0c10oTGFuZ0VuKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBocmFzZShwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCkge1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGNhc2UgYW5kIHNwYWNlOyB0aHJvd3MgaWYgaW52YWxpZFxuICAgICAgICBjb25zdCBlbnRyb3B5ID0gbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCk7XG4gICAgICAgIHBocmFzZSA9IGVudHJvcHlUb01uZW1vbmljKGdldEJ5dGVzKGVudHJvcHkpLCB3b3JkbGlzdCk7XG4gICAgICAgIHJldHVybiBuZXcgTW5lbW9uaWMoX2d1YXJkLCBlbnRyb3B5LCBwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipNbmVtb25pYyoqIGZyb20gdGhlICUlZW50cm9weSUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWZhdWx0ICUlcGFzc3dvcmQlJSBpcyB0aGUgZW1wdHkgc3RyaW5nIGFuZCB0aGUgZGVmYXVsdFxuICAgICAqICB3b3JkbGlzdCBpcyB0aGUgW0VuZ2xpc2ggd29yZGxpc3RzXShMYW5nRW4pLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRW50cm9weShfZW50cm9weSwgcGFzc3dvcmQsIHdvcmRsaXN0KSB7XG4gICAgICAgIGNvbnN0IGVudHJvcHkgPSBnZXRCeXRlcyhfZW50cm9weSwgXCJlbnRyb3B5XCIpO1xuICAgICAgICBjb25zdCBwaHJhc2UgPSBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCk7XG4gICAgICAgIHJldHVybiBuZXcgTW5lbW9uaWMoX2d1YXJkLCBoZXhsaWZ5KGVudHJvcHkpLCBwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwaHJhc2UgZm9yICUlbW5lbW9uaWMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZW50cm9weVRvUGhyYXNlKF9lbnRyb3B5LCB3b3JkbGlzdCkge1xuICAgICAgICBjb25zdCBlbnRyb3B5ID0gZ2V0Qnl0ZXMoX2VudHJvcHksIFwiZW50cm9weVwiKTtcbiAgICAgICAgcmV0dXJuIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGVudHJvcHkgZm9yICUlcGhyYXNlJSUuXG4gICAgICovXG4gICAgc3RhdGljIHBocmFzZVRvRW50cm9weShwaHJhc2UsIHdvcmRsaXN0KSB7XG4gICAgICAgIHJldHVybiBtbmVtb25pY1RvRW50cm9weShwaHJhc2UsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXBocmFzZSUlIGlzIGEgdmFsaWQgW1tsaW5rLWJpcC0zOV1dIHBocmFzZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNoZWNrcyBhbGwgdGhlIHByb3ZpZGVkIHdvcmRzIGJlbG9uZyB0byB0aGUgJSV3b3JkbGlzdCUlLFxuICAgICAqICB0aGF0IHRoZSBsZW5ndGggaXMgdmFsaWQgYW5kIHRoZSBjaGVja3N1bSBpcyBjb3JyZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1ZhbGlkTW5lbW9uaWMocGhyYXNlLCB3b3JkbGlzdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW5lbW9uaWMuanMubWFwIiwiLyohIE1JVCBMaWNlbnNlLiBDb3B5cmlnaHQgMjAxNS0yMDIyIFJpY2hhcmQgTW9vcmUgPG1lQHJpY21vby5jb20+LiBTZWUgTElDRU5TRS50eHQuICovXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX0FFU19rZXksIF9BRVNfS2QsIF9BRVNfS2U7XG4vLyBOdW1iZXIgb2Ygcm91bmRzIGJ5IGtleXNpemVcbmNvbnN0IG51bWJlck9mUm91bmRzID0geyAxNjogMTAsIDI0OiAxMiwgMzI6IDE0IH07XG4vLyBSb3VuZCBjb25zdGFudCB3b3Jkc1xuY29uc3QgcmNvbiA9IFsweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2LCAweDZjLCAweGQ4LCAweGFiLCAweDRkLCAweDlhLCAweDJmLCAweDVlLCAweGJjLCAweDYzLCAweGM2LCAweDk3LCAweDM1LCAweDZhLCAweGQ0LCAweGIzLCAweDdkLCAweGZhLCAweGVmLCAweGM1LCAweDkxXTtcbi8vIFMtYm94IGFuZCBJbnZlcnNlIFMtYm94IChTIGlzIGZvciBTdWJzdGl0dXRpb24pXG5jb25zdCBTID0gWzB4NjMsIDB4N2MsIDB4NzcsIDB4N2IsIDB4ZjIsIDB4NmIsIDB4NmYsIDB4YzUsIDB4MzAsIDB4MDEsIDB4NjcsIDB4MmIsIDB4ZmUsIDB4ZDcsIDB4YWIsIDB4NzYsIDB4Y2EsIDB4ODIsIDB4YzksIDB4N2QsIDB4ZmEsIDB4NTksIDB4NDcsIDB4ZjAsIDB4YWQsIDB4ZDQsIDB4YTIsIDB4YWYsIDB4OWMsIDB4YTQsIDB4NzIsIDB4YzAsIDB4YjcsIDB4ZmQsIDB4OTMsIDB4MjYsIDB4MzYsIDB4M2YsIDB4ZjcsIDB4Y2MsIDB4MzQsIDB4YTUsIDB4ZTUsIDB4ZjEsIDB4NzEsIDB4ZDgsIDB4MzEsIDB4MTUsIDB4MDQsIDB4YzcsIDB4MjMsIDB4YzMsIDB4MTgsIDB4OTYsIDB4MDUsIDB4OWEsIDB4MDcsIDB4MTIsIDB4ODAsIDB4ZTIsIDB4ZWIsIDB4MjcsIDB4YjIsIDB4NzUsIDB4MDksIDB4ODMsIDB4MmMsIDB4MWEsIDB4MWIsIDB4NmUsIDB4NWEsIDB4YTAsIDB4NTIsIDB4M2IsIDB4ZDYsIDB4YjMsIDB4MjksIDB4ZTMsIDB4MmYsIDB4ODQsIDB4NTMsIDB4ZDEsIDB4MDAsIDB4ZWQsIDB4MjAsIDB4ZmMsIDB4YjEsIDB4NWIsIDB4NmEsIDB4Y2IsIDB4YmUsIDB4MzksIDB4NGEsIDB4NGMsIDB4NTgsIDB4Y2YsIDB4ZDAsIDB4ZWYsIDB4YWEsIDB4ZmIsIDB4NDMsIDB4NGQsIDB4MzMsIDB4ODUsIDB4NDUsIDB4ZjksIDB4MDIsIDB4N2YsIDB4NTAsIDB4M2MsIDB4OWYsIDB4YTgsIDB4NTEsIDB4YTMsIDB4NDAsIDB4OGYsIDB4OTIsIDB4OWQsIDB4MzgsIDB4ZjUsIDB4YmMsIDB4YjYsIDB4ZGEsIDB4MjEsIDB4MTAsIDB4ZmYsIDB4ZjMsIDB4ZDIsIDB4Y2QsIDB4MGMsIDB4MTMsIDB4ZWMsIDB4NWYsIDB4OTcsIDB4NDQsIDB4MTcsIDB4YzQsIDB4YTcsIDB4N2UsIDB4M2QsIDB4NjQsIDB4NWQsIDB4MTksIDB4NzMsIDB4NjAsIDB4ODEsIDB4NGYsIDB4ZGMsIDB4MjIsIDB4MmEsIDB4OTAsIDB4ODgsIDB4NDYsIDB4ZWUsIDB4YjgsIDB4MTQsIDB4ZGUsIDB4NWUsIDB4MGIsIDB4ZGIsIDB4ZTAsIDB4MzIsIDB4M2EsIDB4MGEsIDB4NDksIDB4MDYsIDB4MjQsIDB4NWMsIDB4YzIsIDB4ZDMsIDB4YWMsIDB4NjIsIDB4OTEsIDB4OTUsIDB4ZTQsIDB4NzksIDB4ZTcsIDB4YzgsIDB4MzcsIDB4NmQsIDB4OGQsIDB4ZDUsIDB4NGUsIDB4YTksIDB4NmMsIDB4NTYsIDB4ZjQsIDB4ZWEsIDB4NjUsIDB4N2EsIDB4YWUsIDB4MDgsIDB4YmEsIDB4NzgsIDB4MjUsIDB4MmUsIDB4MWMsIDB4YTYsIDB4YjQsIDB4YzYsIDB4ZTgsIDB4ZGQsIDB4NzQsIDB4MWYsIDB4NGIsIDB4YmQsIDB4OGIsIDB4OGEsIDB4NzAsIDB4M2UsIDB4YjUsIDB4NjYsIDB4NDgsIDB4MDMsIDB4ZjYsIDB4MGUsIDB4NjEsIDB4MzUsIDB4NTcsIDB4YjksIDB4ODYsIDB4YzEsIDB4MWQsIDB4OWUsIDB4ZTEsIDB4ZjgsIDB4OTgsIDB4MTEsIDB4NjksIDB4ZDksIDB4OGUsIDB4OTQsIDB4OWIsIDB4MWUsIDB4ODcsIDB4ZTksIDB4Y2UsIDB4NTUsIDB4MjgsIDB4ZGYsIDB4OGMsIDB4YTEsIDB4ODksIDB4MGQsIDB4YmYsIDB4ZTYsIDB4NDIsIDB4NjgsIDB4NDEsIDB4OTksIDB4MmQsIDB4MGYsIDB4YjAsIDB4NTQsIDB4YmIsIDB4MTZdO1xuY29uc3QgU2kgPSBbMHg1MiwgMHgwOSwgMHg2YSwgMHhkNSwgMHgzMCwgMHgzNiwgMHhhNSwgMHgzOCwgMHhiZiwgMHg0MCwgMHhhMywgMHg5ZSwgMHg4MSwgMHhmMywgMHhkNywgMHhmYiwgMHg3YywgMHhlMywgMHgzOSwgMHg4MiwgMHg5YiwgMHgyZiwgMHhmZiwgMHg4NywgMHgzNCwgMHg4ZSwgMHg0MywgMHg0NCwgMHhjNCwgMHhkZSwgMHhlOSwgMHhjYiwgMHg1NCwgMHg3YiwgMHg5NCwgMHgzMiwgMHhhNiwgMHhjMiwgMHgyMywgMHgzZCwgMHhlZSwgMHg0YywgMHg5NSwgMHgwYiwgMHg0MiwgMHhmYSwgMHhjMywgMHg0ZSwgMHgwOCwgMHgyZSwgMHhhMSwgMHg2NiwgMHgyOCwgMHhkOSwgMHgyNCwgMHhiMiwgMHg3NiwgMHg1YiwgMHhhMiwgMHg0OSwgMHg2ZCwgMHg4YiwgMHhkMSwgMHgyNSwgMHg3MiwgMHhmOCwgMHhmNiwgMHg2NCwgMHg4NiwgMHg2OCwgMHg5OCwgMHgxNiwgMHhkNCwgMHhhNCwgMHg1YywgMHhjYywgMHg1ZCwgMHg2NSwgMHhiNiwgMHg5MiwgMHg2YywgMHg3MCwgMHg0OCwgMHg1MCwgMHhmZCwgMHhlZCwgMHhiOSwgMHhkYSwgMHg1ZSwgMHgxNSwgMHg0NiwgMHg1NywgMHhhNywgMHg4ZCwgMHg5ZCwgMHg4NCwgMHg5MCwgMHhkOCwgMHhhYiwgMHgwMCwgMHg4YywgMHhiYywgMHhkMywgMHgwYSwgMHhmNywgMHhlNCwgMHg1OCwgMHgwNSwgMHhiOCwgMHhiMywgMHg0NSwgMHgwNiwgMHhkMCwgMHgyYywgMHgxZSwgMHg4ZiwgMHhjYSwgMHgzZiwgMHgwZiwgMHgwMiwgMHhjMSwgMHhhZiwgMHhiZCwgMHgwMywgMHgwMSwgMHgxMywgMHg4YSwgMHg2YiwgMHgzYSwgMHg5MSwgMHgxMSwgMHg0MSwgMHg0ZiwgMHg2NywgMHhkYywgMHhlYSwgMHg5NywgMHhmMiwgMHhjZiwgMHhjZSwgMHhmMCwgMHhiNCwgMHhlNiwgMHg3MywgMHg5NiwgMHhhYywgMHg3NCwgMHgyMiwgMHhlNywgMHhhZCwgMHgzNSwgMHg4NSwgMHhlMiwgMHhmOSwgMHgzNywgMHhlOCwgMHgxYywgMHg3NSwgMHhkZiwgMHg2ZSwgMHg0NywgMHhmMSwgMHgxYSwgMHg3MSwgMHgxZCwgMHgyOSwgMHhjNSwgMHg4OSwgMHg2ZiwgMHhiNywgMHg2MiwgMHgwZSwgMHhhYSwgMHgxOCwgMHhiZSwgMHgxYiwgMHhmYywgMHg1NiwgMHgzZSwgMHg0YiwgMHhjNiwgMHhkMiwgMHg3OSwgMHgyMCwgMHg5YSwgMHhkYiwgMHhjMCwgMHhmZSwgMHg3OCwgMHhjZCwgMHg1YSwgMHhmNCwgMHgxZiwgMHhkZCwgMHhhOCwgMHgzMywgMHg4OCwgMHgwNywgMHhjNywgMHgzMSwgMHhiMSwgMHgxMiwgMHgxMCwgMHg1OSwgMHgyNywgMHg4MCwgMHhlYywgMHg1ZiwgMHg2MCwgMHg1MSwgMHg3ZiwgMHhhOSwgMHgxOSwgMHhiNSwgMHg0YSwgMHgwZCwgMHgyZCwgMHhlNSwgMHg3YSwgMHg5ZiwgMHg5MywgMHhjOSwgMHg5YywgMHhlZiwgMHhhMCwgMHhlMCwgMHgzYiwgMHg0ZCwgMHhhZSwgMHgyYSwgMHhmNSwgMHhiMCwgMHhjOCwgMHhlYiwgMHhiYiwgMHgzYywgMHg4MywgMHg1MywgMHg5OSwgMHg2MSwgMHgxNywgMHgyYiwgMHgwNCwgMHg3ZSwgMHhiYSwgMHg3NywgMHhkNiwgMHgyNiwgMHhlMSwgMHg2OSwgMHgxNCwgMHg2MywgMHg1NSwgMHgyMSwgMHgwYywgMHg3ZF07XG4vLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGVuY3J5cHRpb25cbmNvbnN0IFQxID0gWzB4YzY2MzYzYTUsIDB4Zjg3YzdjODQsIDB4ZWU3Nzc3OTksIDB4ZjY3YjdiOGQsIDB4ZmZmMmYyMGQsIDB4ZDY2YjZiYmQsIDB4ZGU2ZjZmYjEsIDB4OTFjNWM1NTQsIDB4NjAzMDMwNTAsIDB4MDIwMTAxMDMsIDB4Y2U2NzY3YTksIDB4NTYyYjJiN2QsIDB4ZTdmZWZlMTksIDB4YjVkN2Q3NjIsIDB4NGRhYmFiZTYsIDB4ZWM3Njc2OWEsIDB4OGZjYWNhNDUsIDB4MWY4MjgyOWQsIDB4ODljOWM5NDAsIDB4ZmE3ZDdkODcsIDB4ZWZmYWZhMTUsIDB4YjI1OTU5ZWIsIDB4OGU0NzQ3YzksIDB4ZmJmMGYwMGIsIDB4NDFhZGFkZWMsIDB4YjNkNGQ0NjcsIDB4NWZhMmEyZmQsIDB4NDVhZmFmZWEsIDB4MjM5YzljYmYsIDB4NTNhNGE0ZjcsIDB4ZTQ3MjcyOTYsIDB4OWJjMGMwNWIsIDB4NzViN2I3YzIsIDB4ZTFmZGZkMWMsIDB4M2Q5MzkzYWUsIDB4NGMyNjI2NmEsIDB4NmMzNjM2NWEsIDB4N2UzZjNmNDEsIDB4ZjVmN2Y3MDIsIDB4ODNjY2NjNGYsIDB4NjgzNDM0NWMsIDB4NTFhNWE1ZjQsIDB4ZDFlNWU1MzQsIDB4ZjlmMWYxMDgsIDB4ZTI3MTcxOTMsIDB4YWJkOGQ4NzMsIDB4NjIzMTMxNTMsIDB4MmExNTE1M2YsIDB4MDgwNDA0MGMsIDB4OTVjN2M3NTIsIDB4NDYyMzIzNjUsIDB4OWRjM2MzNWUsIDB4MzAxODE4MjgsIDB4Mzc5Njk2YTEsIDB4MGEwNTA1MGYsIDB4MmY5YTlhYjUsIDB4MGUwNzA3MDksIDB4MjQxMjEyMzYsIDB4MWI4MDgwOWIsIDB4ZGZlMmUyM2QsIDB4Y2RlYmViMjYsIDB4NGUyNzI3NjksIDB4N2ZiMmIyY2QsIDB4ZWE3NTc1OWYsIDB4MTIwOTA5MWIsIDB4MWQ4MzgzOWUsIDB4NTgyYzJjNzQsIDB4MzQxYTFhMmUsIDB4MzYxYjFiMmQsIDB4ZGM2ZTZlYjIsIDB4YjQ1YTVhZWUsIDB4NWJhMGEwZmIsIDB4YTQ1MjUyZjYsIDB4NzYzYjNiNGQsIDB4YjdkNmQ2NjEsIDB4N2RiM2IzY2UsIDB4NTIyOTI5N2IsIDB4ZGRlM2UzM2UsIDB4NWUyZjJmNzEsIDB4MTM4NDg0OTcsIDB4YTY1MzUzZjUsIDB4YjlkMWQxNjgsIDB4MDAwMDAwMDAsIDB4YzFlZGVkMmMsIDB4NDAyMDIwNjAsIDB4ZTNmY2ZjMWYsIDB4NzliMWIxYzgsIDB4YjY1YjViZWQsIDB4ZDQ2YTZhYmUsIDB4OGRjYmNiNDYsIDB4NjdiZWJlZDksIDB4NzIzOTM5NGIsIDB4OTQ0YTRhZGUsIDB4OTg0YzRjZDQsIDB4YjA1ODU4ZTgsIDB4ODVjZmNmNGEsIDB4YmJkMGQwNmIsIDB4YzVlZmVmMmEsIDB4NGZhYWFhZTUsIDB4ZWRmYmZiMTYsIDB4ODY0MzQzYzUsIDB4OWE0ZDRkZDcsIDB4NjYzMzMzNTUsIDB4MTE4NTg1OTQsIDB4OGE0NTQ1Y2YsIDB4ZTlmOWY5MTAsIDB4MDQwMjAyMDYsIDB4ZmU3ZjdmODEsIDB4YTA1MDUwZjAsIDB4NzgzYzNjNDQsIDB4MjU5ZjlmYmEsIDB4NGJhOGE4ZTMsIDB4YTI1MTUxZjMsIDB4NWRhM2EzZmUsIDB4ODA0MDQwYzAsIDB4MDU4ZjhmOGEsIDB4M2Y5MjkyYWQsIDB4MjE5ZDlkYmMsIDB4NzAzODM4NDgsIDB4ZjFmNWY1MDQsIDB4NjNiY2JjZGYsIDB4NzdiNmI2YzEsIDB4YWZkYWRhNzUsIDB4NDIyMTIxNjMsIDB4MjAxMDEwMzAsIDB4ZTVmZmZmMWEsIDB4ZmRmM2YzMGUsIDB4YmZkMmQyNmQsIDB4ODFjZGNkNGMsIDB4MTgwYzBjMTQsIDB4MjYxMzEzMzUsIDB4YzNlY2VjMmYsIDB4YmU1ZjVmZTEsIDB4MzU5Nzk3YTIsIDB4ODg0NDQ0Y2MsIDB4MmUxNzE3MzksIDB4OTNjNGM0NTcsIDB4NTVhN2E3ZjIsIDB4ZmM3ZTdlODIsIDB4N2EzZDNkNDcsIDB4Yzg2NDY0YWMsIDB4YmE1ZDVkZTcsIDB4MzIxOTE5MmIsIDB4ZTY3MzczOTUsIDB4YzA2MDYwYTAsIDB4MTk4MTgxOTgsIDB4OWU0ZjRmZDEsIDB4YTNkY2RjN2YsIDB4NDQyMjIyNjYsIDB4NTQyYTJhN2UsIDB4M2I5MDkwYWIsIDB4MGI4ODg4ODMsIDB4OGM0NjQ2Y2EsIDB4YzdlZWVlMjksIDB4NmJiOGI4ZDMsIDB4MjgxNDE0M2MsIDB4YTdkZWRlNzksIDB4YmM1ZTVlZTIsIDB4MTYwYjBiMWQsIDB4YWRkYmRiNzYsIDB4ZGJlMGUwM2IsIDB4NjQzMjMyNTYsIDB4NzQzYTNhNGUsIDB4MTQwYTBhMWUsIDB4OTI0OTQ5ZGIsIDB4MGMwNjA2MGEsIDB4NDgyNDI0NmMsIDB4Yjg1YzVjZTQsIDB4OWZjMmMyNWQsIDB4YmRkM2QzNmUsIDB4NDNhY2FjZWYsIDB4YzQ2MjYyYTYsIDB4Mzk5MTkxYTgsIDB4MzE5NTk1YTQsIDB4ZDNlNGU0MzcsIDB4ZjI3OTc5OGIsIDB4ZDVlN2U3MzIsIDB4OGJjOGM4NDMsIDB4NmUzNzM3NTksIDB4ZGE2ZDZkYjcsIDB4MDE4ZDhkOGMsIDB4YjFkNWQ1NjQsIDB4OWM0ZTRlZDIsIDB4NDlhOWE5ZTAsIDB4ZDg2YzZjYjQsIDB4YWM1NjU2ZmEsIDB4ZjNmNGY0MDcsIDB4Y2ZlYWVhMjUsIDB4Y2E2NTY1YWYsIDB4ZjQ3YTdhOGUsIDB4NDdhZWFlZTksIDB4MTAwODA4MTgsIDB4NmZiYWJhZDUsIDB4ZjA3ODc4ODgsIDB4NGEyNTI1NmYsIDB4NWMyZTJlNzIsIDB4MzgxYzFjMjQsIDB4NTdhNmE2ZjEsIDB4NzNiNGI0YzcsIDB4OTdjNmM2NTEsIDB4Y2JlOGU4MjMsIDB4YTFkZGRkN2MsIDB4ZTg3NDc0OWMsIDB4M2UxZjFmMjEsIDB4OTY0YjRiZGQsIDB4NjFiZGJkZGMsIDB4MGQ4YjhiODYsIDB4MGY4YThhODUsIDB4ZTA3MDcwOTAsIDB4N2MzZTNlNDIsIDB4NzFiNWI1YzQsIDB4Y2M2NjY2YWEsIDB4OTA0ODQ4ZDgsIDB4MDYwMzAzMDUsIDB4ZjdmNmY2MDEsIDB4MWMwZTBlMTIsIDB4YzI2MTYxYTMsIDB4NmEzNTM1NWYsIDB4YWU1NzU3ZjksIDB4NjliOWI5ZDAsIDB4MTc4Njg2OTEsIDB4OTljMWMxNTgsIDB4M2ExZDFkMjcsIDB4Mjc5ZTllYjksIDB4ZDllMWUxMzgsIDB4ZWJmOGY4MTMsIDB4MmI5ODk4YjMsIDB4MjIxMTExMzMsIDB4ZDI2OTY5YmIsIDB4YTlkOWQ5NzAsIDB4MDc4ZThlODksIDB4MzM5NDk0YTcsIDB4MmQ5YjliYjYsIDB4M2MxZTFlMjIsIDB4MTU4Nzg3OTIsIDB4YzllOWU5MjAsIDB4ODdjZWNlNDksIDB4YWE1NTU1ZmYsIDB4NTAyODI4NzgsIDB4YTVkZmRmN2EsIDB4MDM4YzhjOGYsIDB4NTlhMWExZjgsIDB4MDk4OTg5ODAsIDB4MWEwZDBkMTcsIDB4NjViZmJmZGEsIDB4ZDdlNmU2MzEsIDB4ODQ0MjQyYzYsIDB4ZDA2ODY4YjgsIDB4ODI0MTQxYzMsIDB4Mjk5OTk5YjAsIDB4NWEyZDJkNzcsIDB4MWUwZjBmMTEsIDB4N2JiMGIwY2IsIDB4YTg1NDU0ZmMsIDB4NmRiYmJiZDYsIDB4MmMxNjE2M2FdO1xuY29uc3QgVDIgPSBbMHhhNWM2NjM2MywgMHg4NGY4N2M3YywgMHg5OWVlNzc3NywgMHg4ZGY2N2I3YiwgMHgwZGZmZjJmMiwgMHhiZGQ2NmI2YiwgMHhiMWRlNmY2ZiwgMHg1NDkxYzVjNSwgMHg1MDYwMzAzMCwgMHgwMzAyMDEwMSwgMHhhOWNlNjc2NywgMHg3ZDU2MmIyYiwgMHgxOWU3ZmVmZSwgMHg2MmI1ZDdkNywgMHhlNjRkYWJhYiwgMHg5YWVjNzY3NiwgMHg0NThmY2FjYSwgMHg5ZDFmODI4MiwgMHg0MDg5YzljOSwgMHg4N2ZhN2Q3ZCwgMHgxNWVmZmFmYSwgMHhlYmIyNTk1OSwgMHhjOThlNDc0NywgMHgwYmZiZjBmMCwgMHhlYzQxYWRhZCwgMHg2N2IzZDRkNCwgMHhmZDVmYTJhMiwgMHhlYTQ1YWZhZiwgMHhiZjIzOWM5YywgMHhmNzUzYTRhNCwgMHg5NmU0NzI3MiwgMHg1YjliYzBjMCwgMHhjMjc1YjdiNywgMHgxY2UxZmRmZCwgMHhhZTNkOTM5MywgMHg2YTRjMjYyNiwgMHg1YTZjMzYzNiwgMHg0MTdlM2YzZiwgMHgwMmY1ZjdmNywgMHg0ZjgzY2NjYywgMHg1YzY4MzQzNCwgMHhmNDUxYTVhNSwgMHgzNGQxZTVlNSwgMHgwOGY5ZjFmMSwgMHg5M2UyNzE3MSwgMHg3M2FiZDhkOCwgMHg1MzYyMzEzMSwgMHgzZjJhMTUxNSwgMHgwYzA4MDQwNCwgMHg1Mjk1YzdjNywgMHg2NTQ2MjMyMywgMHg1ZTlkYzNjMywgMHgyODMwMTgxOCwgMHhhMTM3OTY5NiwgMHgwZjBhMDUwNSwgMHhiNTJmOWE5YSwgMHgwOTBlMDcwNywgMHgzNjI0MTIxMiwgMHg5YjFiODA4MCwgMHgzZGRmZTJlMiwgMHgyNmNkZWJlYiwgMHg2OTRlMjcyNywgMHhjZDdmYjJiMiwgMHg5ZmVhNzU3NSwgMHgxYjEyMDkwOSwgMHg5ZTFkODM4MywgMHg3NDU4MmMyYywgMHgyZTM0MWExYSwgMHgyZDM2MWIxYiwgMHhiMmRjNmU2ZSwgMHhlZWI0NWE1YSwgMHhmYjViYTBhMCwgMHhmNmE0NTI1MiwgMHg0ZDc2M2IzYiwgMHg2MWI3ZDZkNiwgMHhjZTdkYjNiMywgMHg3YjUyMjkyOSwgMHgzZWRkZTNlMywgMHg3MTVlMmYyZiwgMHg5NzEzODQ4NCwgMHhmNWE2NTM1MywgMHg2OGI5ZDFkMSwgMHgwMDAwMDAwMCwgMHgyY2MxZWRlZCwgMHg2MDQwMjAyMCwgMHgxZmUzZmNmYywgMHhjODc5YjFiMSwgMHhlZGI2NWI1YiwgMHhiZWQ0NmE2YSwgMHg0NjhkY2JjYiwgMHhkOTY3YmViZSwgMHg0YjcyMzkzOSwgMHhkZTk0NGE0YSwgMHhkNDk4NGM0YywgMHhlOGIwNTg1OCwgMHg0YTg1Y2ZjZiwgMHg2YmJiZDBkMCwgMHgyYWM1ZWZlZiwgMHhlNTRmYWFhYSwgMHgxNmVkZmJmYiwgMHhjNTg2NDM0MywgMHhkNzlhNGQ0ZCwgMHg1NTY2MzMzMywgMHg5NDExODU4NSwgMHhjZjhhNDU0NSwgMHgxMGU5ZjlmOSwgMHgwNjA0MDIwMiwgMHg4MWZlN2Y3ZiwgMHhmMGEwNTA1MCwgMHg0NDc4M2MzYywgMHhiYTI1OWY5ZiwgMHhlMzRiYThhOCwgMHhmM2EyNTE1MSwgMHhmZTVkYTNhMywgMHhjMDgwNDA0MCwgMHg4YTA1OGY4ZiwgMHhhZDNmOTI5MiwgMHhiYzIxOWQ5ZCwgMHg0ODcwMzgzOCwgMHgwNGYxZjVmNSwgMHhkZjYzYmNiYywgMHhjMTc3YjZiNiwgMHg3NWFmZGFkYSwgMHg2MzQyMjEyMSwgMHgzMDIwMTAxMCwgMHgxYWU1ZmZmZiwgMHgwZWZkZjNmMywgMHg2ZGJmZDJkMiwgMHg0YzgxY2RjZCwgMHgxNDE4MGMwYywgMHgzNTI2MTMxMywgMHgyZmMzZWNlYywgMHhlMWJlNWY1ZiwgMHhhMjM1OTc5NywgMHhjYzg4NDQ0NCwgMHgzOTJlMTcxNywgMHg1NzkzYzRjNCwgMHhmMjU1YTdhNywgMHg4MmZjN2U3ZSwgMHg0NzdhM2QzZCwgMHhhY2M4NjQ2NCwgMHhlN2JhNWQ1ZCwgMHgyYjMyMTkxOSwgMHg5NWU2NzM3MywgMHhhMGMwNjA2MCwgMHg5ODE5ODE4MSwgMHhkMTllNGY0ZiwgMHg3ZmEzZGNkYywgMHg2NjQ0MjIyMiwgMHg3ZTU0MmEyYSwgMHhhYjNiOTA5MCwgMHg4MzBiODg4OCwgMHhjYThjNDY0NiwgMHgyOWM3ZWVlZSwgMHhkMzZiYjhiOCwgMHgzYzI4MTQxNCwgMHg3OWE3ZGVkZSwgMHhlMmJjNWU1ZSwgMHgxZDE2MGIwYiwgMHg3NmFkZGJkYiwgMHgzYmRiZTBlMCwgMHg1NjY0MzIzMiwgMHg0ZTc0M2EzYSwgMHgxZTE0MGEwYSwgMHhkYjkyNDk0OSwgMHgwYTBjMDYwNiwgMHg2YzQ4MjQyNCwgMHhlNGI4NWM1YywgMHg1ZDlmYzJjMiwgMHg2ZWJkZDNkMywgMHhlZjQzYWNhYywgMHhhNmM0NjI2MiwgMHhhODM5OTE5MSwgMHhhNDMxOTU5NSwgMHgzN2QzZTRlNCwgMHg4YmYyNzk3OSwgMHgzMmQ1ZTdlNywgMHg0MzhiYzhjOCwgMHg1OTZlMzczNywgMHhiN2RhNmQ2ZCwgMHg4YzAxOGQ4ZCwgMHg2NGIxZDVkNSwgMHhkMjljNGU0ZSwgMHhlMDQ5YTlhOSwgMHhiNGQ4NmM2YywgMHhmYWFjNTY1NiwgMHgwN2YzZjRmNCwgMHgyNWNmZWFlYSwgMHhhZmNhNjU2NSwgMHg4ZWY0N2E3YSwgMHhlOTQ3YWVhZSwgMHgxODEwMDgwOCwgMHhkNTZmYmFiYSwgMHg4OGYwNzg3OCwgMHg2ZjRhMjUyNSwgMHg3MjVjMmUyZSwgMHgyNDM4MWMxYywgMHhmMTU3YTZhNiwgMHhjNzczYjRiNCwgMHg1MTk3YzZjNiwgMHgyM2NiZThlOCwgMHg3Y2ExZGRkZCwgMHg5Y2U4NzQ3NCwgMHgyMTNlMWYxZiwgMHhkZDk2NGI0YiwgMHhkYzYxYmRiZCwgMHg4NjBkOGI4YiwgMHg4NTBmOGE4YSwgMHg5MGUwNzA3MCwgMHg0MjdjM2UzZSwgMHhjNDcxYjViNSwgMHhhYWNjNjY2NiwgMHhkODkwNDg0OCwgMHgwNTA2MDMwMywgMHgwMWY3ZjZmNiwgMHgxMjFjMGUwZSwgMHhhM2MyNjE2MSwgMHg1ZjZhMzUzNSwgMHhmOWFlNTc1NywgMHhkMDY5YjliOSwgMHg5MTE3ODY4NiwgMHg1ODk5YzFjMSwgMHgyNzNhMWQxZCwgMHhiOTI3OWU5ZSwgMHgzOGQ5ZTFlMSwgMHgxM2ViZjhmOCwgMHhiMzJiOTg5OCwgMHgzMzIyMTExMSwgMHhiYmQyNjk2OSwgMHg3MGE5ZDlkOSwgMHg4OTA3OGU4ZSwgMHhhNzMzOTQ5NCwgMHhiNjJkOWI5YiwgMHgyMjNjMWUxZSwgMHg5MjE1ODc4NywgMHgyMGM5ZTllOSwgMHg0OTg3Y2VjZSwgMHhmZmFhNTU1NSwgMHg3ODUwMjgyOCwgMHg3YWE1ZGZkZiwgMHg4ZjAzOGM4YywgMHhmODU5YTFhMSwgMHg4MDA5ODk4OSwgMHgxNzFhMGQwZCwgMHhkYTY1YmZiZiwgMHgzMWQ3ZTZlNiwgMHhjNjg0NDI0MiwgMHhiOGQwNjg2OCwgMHhjMzgyNDE0MSwgMHhiMDI5OTk5OSwgMHg3NzVhMmQyZCwgMHgxMTFlMGYwZiwgMHhjYjdiYjBiMCwgMHhmY2E4NTQ1NCwgMHhkNjZkYmJiYiwgMHgzYTJjMTYxNl07XG5jb25zdCBUMyA9IFsweDYzYTVjNjYzLCAweDdjODRmODdjLCAweDc3OTllZTc3LCAweDdiOGRmNjdiLCAweGYyMGRmZmYyLCAweDZiYmRkNjZiLCAweDZmYjFkZTZmLCAweGM1NTQ5MWM1LCAweDMwNTA2MDMwLCAweDAxMDMwMjAxLCAweDY3YTljZTY3LCAweDJiN2Q1NjJiLCAweGZlMTllN2ZlLCAweGQ3NjJiNWQ3LCAweGFiZTY0ZGFiLCAweDc2OWFlYzc2LCAweGNhNDU4ZmNhLCAweDgyOWQxZjgyLCAweGM5NDA4OWM5LCAweDdkODdmYTdkLCAweGZhMTVlZmZhLCAweDU5ZWJiMjU5LCAweDQ3Yzk4ZTQ3LCAweGYwMGJmYmYwLCAweGFkZWM0MWFkLCAweGQ0NjdiM2Q0LCAweGEyZmQ1ZmEyLCAweGFmZWE0NWFmLCAweDljYmYyMzljLCAweGE0Zjc1M2E0LCAweDcyOTZlNDcyLCAweGMwNWI5YmMwLCAweGI3YzI3NWI3LCAweGZkMWNlMWZkLCAweDkzYWUzZDkzLCAweDI2NmE0YzI2LCAweDM2NWE2YzM2LCAweDNmNDE3ZTNmLCAweGY3MDJmNWY3LCAweGNjNGY4M2NjLCAweDM0NWM2ODM0LCAweGE1ZjQ1MWE1LCAweGU1MzRkMWU1LCAweGYxMDhmOWYxLCAweDcxOTNlMjcxLCAweGQ4NzNhYmQ4LCAweDMxNTM2MjMxLCAweDE1M2YyYTE1LCAweDA0MGMwODA0LCAweGM3NTI5NWM3LCAweDIzNjU0NjIzLCAweGMzNWU5ZGMzLCAweDE4MjgzMDE4LCAweDk2YTEzNzk2LCAweDA1MGYwYTA1LCAweDlhYjUyZjlhLCAweDA3MDkwZTA3LCAweDEyMzYyNDEyLCAweDgwOWIxYjgwLCAweGUyM2RkZmUyLCAweGViMjZjZGViLCAweDI3Njk0ZTI3LCAweGIyY2Q3ZmIyLCAweDc1OWZlYTc1LCAweDA5MWIxMjA5LCAweDgzOWUxZDgzLCAweDJjNzQ1ODJjLCAweDFhMmUzNDFhLCAweDFiMmQzNjFiLCAweDZlYjJkYzZlLCAweDVhZWViNDVhLCAweGEwZmI1YmEwLCAweDUyZjZhNDUyLCAweDNiNGQ3NjNiLCAweGQ2NjFiN2Q2LCAweGIzY2U3ZGIzLCAweDI5N2I1MjI5LCAweGUzM2VkZGUzLCAweDJmNzE1ZTJmLCAweDg0OTcxMzg0LCAweDUzZjVhNjUzLCAweGQxNjhiOWQxLCAweDAwMDAwMDAwLCAweGVkMmNjMWVkLCAweDIwNjA0MDIwLCAweGZjMWZlM2ZjLCAweGIxYzg3OWIxLCAweDViZWRiNjViLCAweDZhYmVkNDZhLCAweGNiNDY4ZGNiLCAweGJlZDk2N2JlLCAweDM5NGI3MjM5LCAweDRhZGU5NDRhLCAweDRjZDQ5ODRjLCAweDU4ZThiMDU4LCAweGNmNGE4NWNmLCAweGQwNmJiYmQwLCAweGVmMmFjNWVmLCAweGFhZTU0ZmFhLCAweGZiMTZlZGZiLCAweDQzYzU4NjQzLCAweDRkZDc5YTRkLCAweDMzNTU2NjMzLCAweDg1OTQxMTg1LCAweDQ1Y2Y4YTQ1LCAweGY5MTBlOWY5LCAweDAyMDYwNDAyLCAweDdmODFmZTdmLCAweDUwZjBhMDUwLCAweDNjNDQ3ODNjLCAweDlmYmEyNTlmLCAweGE4ZTM0YmE4LCAweDUxZjNhMjUxLCAweGEzZmU1ZGEzLCAweDQwYzA4MDQwLCAweDhmOGEwNThmLCAweDkyYWQzZjkyLCAweDlkYmMyMTlkLCAweDM4NDg3MDM4LCAweGY1MDRmMWY1LCAweGJjZGY2M2JjLCAweGI2YzE3N2I2LCAweGRhNzVhZmRhLCAweDIxNjM0MjIxLCAweDEwMzAyMDEwLCAweGZmMWFlNWZmLCAweGYzMGVmZGYzLCAweGQyNmRiZmQyLCAweGNkNGM4MWNkLCAweDBjMTQxODBjLCAweDEzMzUyNjEzLCAweGVjMmZjM2VjLCAweDVmZTFiZTVmLCAweDk3YTIzNTk3LCAweDQ0Y2M4ODQ0LCAweDE3MzkyZTE3LCAweGM0NTc5M2M0LCAweGE3ZjI1NWE3LCAweDdlODJmYzdlLCAweDNkNDc3YTNkLCAweDY0YWNjODY0LCAweDVkZTdiYTVkLCAweDE5MmIzMjE5LCAweDczOTVlNjczLCAweDYwYTBjMDYwLCAweDgxOTgxOTgxLCAweDRmZDE5ZTRmLCAweGRjN2ZhM2RjLCAweDIyNjY0NDIyLCAweDJhN2U1NDJhLCAweDkwYWIzYjkwLCAweDg4ODMwYjg4LCAweDQ2Y2E4YzQ2LCAweGVlMjljN2VlLCAweGI4ZDM2YmI4LCAweDE0M2MyODE0LCAweGRlNzlhN2RlLCAweDVlZTJiYzVlLCAweDBiMWQxNjBiLCAweGRiNzZhZGRiLCAweGUwM2JkYmUwLCAweDMyNTY2NDMyLCAweDNhNGU3NDNhLCAweDBhMWUxNDBhLCAweDQ5ZGI5MjQ5LCAweDA2MGEwYzA2LCAweDI0NmM0ODI0LCAweDVjZTRiODVjLCAweGMyNWQ5ZmMyLCAweGQzNmViZGQzLCAweGFjZWY0M2FjLCAweDYyYTZjNDYyLCAweDkxYTgzOTkxLCAweDk1YTQzMTk1LCAweGU0MzdkM2U0LCAweDc5OGJmMjc5LCAweGU3MzJkNWU3LCAweGM4NDM4YmM4LCAweDM3NTk2ZTM3LCAweDZkYjdkYTZkLCAweDhkOGMwMThkLCAweGQ1NjRiMWQ1LCAweDRlZDI5YzRlLCAweGE5ZTA0OWE5LCAweDZjYjRkODZjLCAweDU2ZmFhYzU2LCAweGY0MDdmM2Y0LCAweGVhMjVjZmVhLCAweDY1YWZjYTY1LCAweDdhOGVmNDdhLCAweGFlZTk0N2FlLCAweDA4MTgxMDA4LCAweGJhZDU2ZmJhLCAweDc4ODhmMDc4LCAweDI1NmY0YTI1LCAweDJlNzI1YzJlLCAweDFjMjQzODFjLCAweGE2ZjE1N2E2LCAweGI0Yzc3M2I0LCAweGM2NTE5N2M2LCAweGU4MjNjYmU4LCAweGRkN2NhMWRkLCAweDc0OWNlODc0LCAweDFmMjEzZTFmLCAweDRiZGQ5NjRiLCAweGJkZGM2MWJkLCAweDhiODYwZDhiLCAweDhhODUwZjhhLCAweDcwOTBlMDcwLCAweDNlNDI3YzNlLCAweGI1YzQ3MWI1LCAweDY2YWFjYzY2LCAweDQ4ZDg5MDQ4LCAweDAzMDUwNjAzLCAweGY2MDFmN2Y2LCAweDBlMTIxYzBlLCAweDYxYTNjMjYxLCAweDM1NWY2YTM1LCAweDU3ZjlhZTU3LCAweGI5ZDA2OWI5LCAweDg2OTExNzg2LCAweGMxNTg5OWMxLCAweDFkMjczYTFkLCAweDllYjkyNzllLCAweGUxMzhkOWUxLCAweGY4MTNlYmY4LCAweDk4YjMyYjk4LCAweDExMzMyMjExLCAweDY5YmJkMjY5LCAweGQ5NzBhOWQ5LCAweDhlODkwNzhlLCAweDk0YTczMzk0LCAweDliYjYyZDliLCAweDFlMjIzYzFlLCAweDg3OTIxNTg3LCAweGU5MjBjOWU5LCAweGNlNDk4N2NlLCAweDU1ZmZhYTU1LCAweDI4Nzg1MDI4LCAweGRmN2FhNWRmLCAweDhjOGYwMzhjLCAweGExZjg1OWExLCAweDg5ODAwOTg5LCAweDBkMTcxYTBkLCAweGJmZGE2NWJmLCAweGU2MzFkN2U2LCAweDQyYzY4NDQyLCAweDY4YjhkMDY4LCAweDQxYzM4MjQxLCAweDk5YjAyOTk5LCAweDJkNzc1YTJkLCAweDBmMTExZTBmLCAweGIwY2I3YmIwLCAweDU0ZmNhODU0LCAweGJiZDY2ZGJiLCAweDE2M2EyYzE2XTtcbmNvbnN0IFQ0ID0gWzB4NjM2M2E1YzYsIDB4N2M3Yzg0ZjgsIDB4Nzc3Nzk5ZWUsIDB4N2I3YjhkZjYsIDB4ZjJmMjBkZmYsIDB4NmI2YmJkZDYsIDB4NmY2ZmIxZGUsIDB4YzVjNTU0OTEsIDB4MzAzMDUwNjAsIDB4MDEwMTAzMDIsIDB4Njc2N2E5Y2UsIDB4MmIyYjdkNTYsIDB4ZmVmZTE5ZTcsIDB4ZDdkNzYyYjUsIDB4YWJhYmU2NGQsIDB4NzY3NjlhZWMsIDB4Y2FjYTQ1OGYsIDB4ODI4MjlkMWYsIDB4YzljOTQwODksIDB4N2Q3ZDg3ZmEsIDB4ZmFmYTE1ZWYsIDB4NTk1OWViYjIsIDB4NDc0N2M5OGUsIDB4ZjBmMDBiZmIsIDB4YWRhZGVjNDEsIDB4ZDRkNDY3YjMsIDB4YTJhMmZkNWYsIDB4YWZhZmVhNDUsIDB4OWM5Y2JmMjMsIDB4YTRhNGY3NTMsIDB4NzI3Mjk2ZTQsIDB4YzBjMDViOWIsIDB4YjdiN2MyNzUsIDB4ZmRmZDFjZTEsIDB4OTM5M2FlM2QsIDB4MjYyNjZhNGMsIDB4MzYzNjVhNmMsIDB4M2YzZjQxN2UsIDB4ZjdmNzAyZjUsIDB4Y2NjYzRmODMsIDB4MzQzNDVjNjgsIDB4YTVhNWY0NTEsIDB4ZTVlNTM0ZDEsIDB4ZjFmMTA4ZjksIDB4NzE3MTkzZTIsIDB4ZDhkODczYWIsIDB4MzEzMTUzNjIsIDB4MTUxNTNmMmEsIDB4MDQwNDBjMDgsIDB4YzdjNzUyOTUsIDB4MjMyMzY1NDYsIDB4YzNjMzVlOWQsIDB4MTgxODI4MzAsIDB4OTY5NmExMzcsIDB4MDUwNTBmMGEsIDB4OWE5YWI1MmYsIDB4MDcwNzA5MGUsIDB4MTIxMjM2MjQsIDB4ODA4MDliMWIsIDB4ZTJlMjNkZGYsIDB4ZWJlYjI2Y2QsIDB4MjcyNzY5NGUsIDB4YjJiMmNkN2YsIDB4NzU3NTlmZWEsIDB4MDkwOTFiMTIsIDB4ODM4MzllMWQsIDB4MmMyYzc0NTgsIDB4MWExYTJlMzQsIDB4MWIxYjJkMzYsIDB4NmU2ZWIyZGMsIDB4NWE1YWVlYjQsIDB4YTBhMGZiNWIsIDB4NTI1MmY2YTQsIDB4M2IzYjRkNzYsIDB4ZDZkNjYxYjcsIDB4YjNiM2NlN2QsIDB4MjkyOTdiNTIsIDB4ZTNlMzNlZGQsIDB4MmYyZjcxNWUsIDB4ODQ4NDk3MTMsIDB4NTM1M2Y1YTYsIDB4ZDFkMTY4YjksIDB4MDAwMDAwMDAsIDB4ZWRlZDJjYzEsIDB4MjAyMDYwNDAsIDB4ZmNmYzFmZTMsIDB4YjFiMWM4NzksIDB4NWI1YmVkYjYsIDB4NmE2YWJlZDQsIDB4Y2JjYjQ2OGQsIDB4YmViZWQ5NjcsIDB4MzkzOTRiNzIsIDB4NGE0YWRlOTQsIDB4NGM0Y2Q0OTgsIDB4NTg1OGU4YjAsIDB4Y2ZjZjRhODUsIDB4ZDBkMDZiYmIsIDB4ZWZlZjJhYzUsIDB4YWFhYWU1NGYsIDB4ZmJmYjE2ZWQsIDB4NDM0M2M1ODYsIDB4NGQ0ZGQ3OWEsIDB4MzMzMzU1NjYsIDB4ODU4NTk0MTEsIDB4NDU0NWNmOGEsIDB4ZjlmOTEwZTksIDB4MDIwMjA2MDQsIDB4N2Y3ZjgxZmUsIDB4NTA1MGYwYTAsIDB4M2MzYzQ0NzgsIDB4OWY5ZmJhMjUsIDB4YThhOGUzNGIsIDB4NTE1MWYzYTIsIDB4YTNhM2ZlNWQsIDB4NDA0MGMwODAsIDB4OGY4ZjhhMDUsIDB4OTI5MmFkM2YsIDB4OWQ5ZGJjMjEsIDB4MzgzODQ4NzAsIDB4ZjVmNTA0ZjEsIDB4YmNiY2RmNjMsIDB4YjZiNmMxNzcsIDB4ZGFkYTc1YWYsIDB4MjEyMTYzNDIsIDB4MTAxMDMwMjAsIDB4ZmZmZjFhZTUsIDB4ZjNmMzBlZmQsIDB4ZDJkMjZkYmYsIDB4Y2RjZDRjODEsIDB4MGMwYzE0MTgsIDB4MTMxMzM1MjYsIDB4ZWNlYzJmYzMsIDB4NWY1ZmUxYmUsIDB4OTc5N2EyMzUsIDB4NDQ0NGNjODgsIDB4MTcxNzM5MmUsIDB4YzRjNDU3OTMsIDB4YTdhN2YyNTUsIDB4N2U3ZTgyZmMsIDB4M2QzZDQ3N2EsIDB4NjQ2NGFjYzgsIDB4NWQ1ZGU3YmEsIDB4MTkxOTJiMzIsIDB4NzM3Mzk1ZTYsIDB4NjA2MGEwYzAsIDB4ODE4MTk4MTksIDB4NGY0ZmQxOWUsIDB4ZGNkYzdmYTMsIDB4MjIyMjY2NDQsIDB4MmEyYTdlNTQsIDB4OTA5MGFiM2IsIDB4ODg4ODgzMGIsIDB4NDY0NmNhOGMsIDB4ZWVlZTI5YzcsIDB4YjhiOGQzNmIsIDB4MTQxNDNjMjgsIDB4ZGVkZTc5YTcsIDB4NWU1ZWUyYmMsIDB4MGIwYjFkMTYsIDB4ZGJkYjc2YWQsIDB4ZTBlMDNiZGIsIDB4MzIzMjU2NjQsIDB4M2EzYTRlNzQsIDB4MGEwYTFlMTQsIDB4NDk0OWRiOTIsIDB4MDYwNjBhMGMsIDB4MjQyNDZjNDgsIDB4NWM1Y2U0YjgsIDB4YzJjMjVkOWYsIDB4ZDNkMzZlYmQsIDB4YWNhY2VmNDMsIDB4NjI2MmE2YzQsIDB4OTE5MWE4MzksIDB4OTU5NWE0MzEsIDB4ZTRlNDM3ZDMsIDB4Nzk3OThiZjIsIDB4ZTdlNzMyZDUsIDB4YzhjODQzOGIsIDB4MzczNzU5NmUsIDB4NmQ2ZGI3ZGEsIDB4OGQ4ZDhjMDEsIDB4ZDVkNTY0YjEsIDB4NGU0ZWQyOWMsIDB4YTlhOWUwNDksIDB4NmM2Y2I0ZDgsIDB4NTY1NmZhYWMsIDB4ZjRmNDA3ZjMsIDB4ZWFlYTI1Y2YsIDB4NjU2NWFmY2EsIDB4N2E3YThlZjQsIDB4YWVhZWU5NDcsIDB4MDgwODE4MTAsIDB4YmFiYWQ1NmYsIDB4Nzg3ODg4ZjAsIDB4MjUyNTZmNGEsIDB4MmUyZTcyNWMsIDB4MWMxYzI0MzgsIDB4YTZhNmYxNTcsIDB4YjRiNGM3NzMsIDB4YzZjNjUxOTcsIDB4ZThlODIzY2IsIDB4ZGRkZDdjYTEsIDB4NzQ3NDljZTgsIDB4MWYxZjIxM2UsIDB4NGI0YmRkOTYsIDB4YmRiZGRjNjEsIDB4OGI4Yjg2MGQsIDB4OGE4YTg1MGYsIDB4NzA3MDkwZTAsIDB4M2UzZTQyN2MsIDB4YjViNWM0NzEsIDB4NjY2NmFhY2MsIDB4NDg0OGQ4OTAsIDB4MDMwMzA1MDYsIDB4ZjZmNjAxZjcsIDB4MGUwZTEyMWMsIDB4NjE2MWEzYzIsIDB4MzUzNTVmNmEsIDB4NTc1N2Y5YWUsIDB4YjliOWQwNjksIDB4ODY4NjkxMTcsIDB4YzFjMTU4OTksIDB4MWQxZDI3M2EsIDB4OWU5ZWI5MjcsIDB4ZTFlMTM4ZDksIDB4ZjhmODEzZWIsIDB4OTg5OGIzMmIsIDB4MTExMTMzMjIsIDB4Njk2OWJiZDIsIDB4ZDlkOTcwYTksIDB4OGU4ZTg5MDcsIDB4OTQ5NGE3MzMsIDB4OWI5YmI2MmQsIDB4MWUxZTIyM2MsIDB4ODc4NzkyMTUsIDB4ZTllOTIwYzksIDB4Y2VjZTQ5ODcsIDB4NTU1NWZmYWEsIDB4MjgyODc4NTAsIDB4ZGZkZjdhYTUsIDB4OGM4YzhmMDMsIDB4YTFhMWY4NTksIDB4ODk4OTgwMDksIDB4MGQwZDE3MWEsIDB4YmZiZmRhNjUsIDB4ZTZlNjMxZDcsIDB4NDI0MmM2ODQsIDB4Njg2OGI4ZDAsIDB4NDE0MWMzODIsIDB4OTk5OWIwMjksIDB4MmQyZDc3NWEsIDB4MGYwZjExMWUsIDB4YjBiMGNiN2IsIDB4NTQ1NGZjYTgsIDB4YmJiYmQ2NmQsIDB4MTYxNjNhMmNdO1xuLy8gVHJhbnNmb3JtYXRpb25zIGZvciBkZWNyeXB0aW9uXG5jb25zdCBUNSA9IFsweDUxZjRhNzUwLCAweDdlNDE2NTUzLCAweDFhMTdhNGMzLCAweDNhMjc1ZTk2LCAweDNiYWI2YmNiLCAweDFmOWQ0NWYxLCAweGFjZmE1OGFiLCAweDRiZTMwMzkzLCAweDIwMzBmYTU1LCAweGFkNzY2ZGY2LCAweDg4Y2M3NjkxLCAweGY1MDI0YzI1LCAweDRmZTVkN2ZjLCAweGM1MmFjYmQ3LCAweDI2MzU0NDgwLCAweGI1NjJhMzhmLCAweGRlYjE1YTQ5LCAweDI1YmExYjY3LCAweDQ1ZWEwZTk4LCAweDVkZmVjMGUxLCAweGMzMmY3NTAyLCAweDgxNGNmMDEyLCAweDhkNDY5N2EzLCAweDZiZDNmOWM2LCAweDAzOGY1ZmU3LCAweDE1OTI5Yzk1LCAweGJmNmQ3YWViLCAweDk1NTI1OWRhLCAweGQ0YmU4MzJkLCAweDU4NzQyMWQzLCAweDQ5ZTA2OTI5LCAweDhlYzljODQ0LCAweDc1YzI4OTZhLCAweGY0OGU3OTc4LCAweDk5NTgzZTZiLCAweDI3Yjk3MWRkLCAweGJlZTE0ZmI2LCAweGYwODhhZDE3LCAweGM5MjBhYzY2LCAweDdkY2UzYWI0LCAweDYzZGY0YTE4LCAweGU1MWEzMTgyLCAweDk3NTEzMzYwLCAweDYyNTM3ZjQ1LCAweGIxNjQ3N2UwLCAweGJiNmJhZTg0LCAweGZlODFhMDFjLCAweGY5MDgyYjk0LCAweDcwNDg2ODU4LCAweDhmNDVmZDE5LCAweDk0ZGU2Yzg3LCAweDUyN2JmOGI3LCAweGFiNzNkMzIzLCAweDcyNGIwMmUyLCAweGUzMWY4ZjU3LCAweDY2NTVhYjJhLCAweGIyZWIyODA3LCAweDJmYjVjMjAzLCAweDg2YzU3YjlhLCAweGQzMzcwOGE1LCAweDMwMjg4N2YyLCAweDIzYmZhNWIyLCAweDAyMDM2YWJhLCAweGVkMTY4MjVjLCAweDhhY2YxYzJiLCAweGE3NzliNDkyLCAweGYzMDdmMmYwLCAweDRlNjllMmExLCAweDY1ZGFmNGNkLCAweDA2MDViZWQ1LCAweGQxMzQ2MjFmLCAweGM0YTZmZThhLCAweDM0MmU1MzlkLCAweGEyZjM1NWEwLCAweDA1OGFlMTMyLCAweGE0ZjZlYjc1LCAweDBiODNlYzM5LCAweDQwNjBlZmFhLCAweDVlNzE5ZjA2LCAweGJkNmUxMDUxLCAweDNlMjE4YWY5LCAweDk2ZGQwNjNkLCAweGRkM2UwNWFlLCAweDRkZTZiZDQ2LCAweDkxNTQ4ZGI1LCAweDcxYzQ1ZDA1LCAweDA0MDZkNDZmLCAweDYwNTAxNWZmLCAweDE5OThmYjI0LCAweGQ2YmRlOTk3LCAweDg5NDA0M2NjLCAweDY3ZDk5ZTc3LCAweGIwZTg0MmJkLCAweDA3ODk4Yjg4LCAweGU3MTk1YjM4LCAweDc5YzhlZWRiLCAweGExN2MwYTQ3LCAweDdjNDIwZmU5LCAweGY4ODQxZWM5LCAweDAwMDAwMDAwLCAweDA5ODA4NjgzLCAweDMyMmJlZDQ4LCAweDFlMTE3MGFjLCAweDZjNWE3MjRlLCAweGZkMGVmZmZiLCAweDBmODUzODU2LCAweDNkYWVkNTFlLCAweDM2MmQzOTI3LCAweDBhMGZkOTY0LCAweDY4NWNhNjIxLCAweDliNWI1NGQxLCAweDI0MzYyZTNhLCAweDBjMGE2N2IxLCAweDkzNTdlNzBmLCAweGI0ZWU5NmQyLCAweDFiOWI5MTllLCAweDgwYzBjNTRmLCAweDYxZGMyMGEyLCAweDVhNzc0YjY5LCAweDFjMTIxYTE2LCAweGUyOTNiYTBhLCAweGMwYTAyYWU1LCAweDNjMjJlMDQzLCAweDEyMWIxNzFkLCAweDBlMDkwZDBiLCAweGYyOGJjN2FkLCAweDJkYjZhOGI5LCAweDE0MWVhOWM4LCAweDU3ZjExOTg1LCAweGFmNzUwNzRjLCAweGVlOTlkZGJiLCAweGEzN2Y2MGZkLCAweGY3MDEyNjlmLCAweDVjNzJmNWJjLCAweDQ0NjYzYmM1LCAweDViZmI3ZTM0LCAweDhiNDMyOTc2LCAweGNiMjNjNmRjLCAweGI2ZWRmYzY4LCAweGI4ZTRmMTYzLCAweGQ3MzFkY2NhLCAweDQyNjM4NTEwLCAweDEzOTcyMjQwLCAweDg0YzYxMTIwLCAweDg1NGEyNDdkLCAweGQyYmIzZGY4LCAweGFlZjkzMjExLCAweGM3MjlhMTZkLCAweDFkOWUyZjRiLCAweGRjYjIzMGYzLCAweDBkODY1MmVjLCAweDc3YzFlM2QwLCAweDJiYjMxNjZjLCAweGE5NzBiOTk5LCAweDExOTQ0OGZhLCAweDQ3ZTk2NDIyLCAweGE4ZmM4Y2M0LCAweGEwZjAzZjFhLCAweDU2N2QyY2Q4LCAweDIyMzM5MGVmLCAweDg3NDk0ZWM3LCAweGQ5MzhkMWMxLCAweDhjY2FhMmZlLCAweDk4ZDQwYjM2LCAweGE2ZjU4MWNmLCAweGE1N2FkZTI4LCAweGRhYjc4ZTI2LCAweDNmYWRiZmE0LCAweDJjM2E5ZGU0LCAweDUwNzg5MjBkLCAweDZhNWZjYzliLCAweDU0N2U0NjYyLCAweGY2OGQxM2MyLCAweDkwZDhiOGU4LCAweDJlMzlmNzVlLCAweDgyYzNhZmY1LCAweDlmNWQ4MGJlLCAweDY5ZDA5MzdjLCAweDZmZDUyZGE5LCAweGNmMjUxMmIzLCAweGM4YWM5OTNiLCAweDEwMTg3ZGE3LCAweGU4OWM2MzZlLCAweGRiM2JiYjdiLCAweGNkMjY3ODA5LCAweDZlNTkxOGY0LCAweGVjOWFiNzAxLCAweDgzNGY5YWE4LCAweGU2OTU2ZTY1LCAweGFhZmZlNjdlLCAweDIxYmNjZjA4LCAweGVmMTVlOGU2LCAweGJhZTc5YmQ5LCAweDRhNmYzNmNlLCAweGVhOWYwOWQ0LCAweDI5YjA3Y2Q2LCAweDMxYTRiMmFmLCAweDJhM2YyMzMxLCAweGM2YTU5NDMwLCAweDM1YTI2NmMwLCAweDc0NGViYzM3LCAweGZjODJjYWE2LCAweGUwOTBkMGIwLCAweDMzYTdkODE1LCAweGYxMDQ5ODRhLCAweDQxZWNkYWY3LCAweDdmY2Q1MDBlLCAweDE3OTFmNjJmLCAweDc2NGRkNjhkLCAweDQzZWZiMDRkLCAweGNjYWE0ZDU0LCAweGU0OTYwNGRmLCAweDllZDFiNWUzLCAweDRjNmE4ODFiLCAweGMxMmMxZmI4LCAweDQ2NjU1MTdmLCAweDlkNWVlYTA0LCAweDAxOGMzNTVkLCAweGZhODc3NDczLCAweGZiMGI0MTJlLCAweGIzNjcxZDVhLCAweDkyZGJkMjUyLCAweGU5MTA1NjMzLCAweDZkZDY0NzEzLCAweDlhZDc2MThjLCAweDM3YTEwYzdhLCAweDU5ZjgxNDhlLCAweGViMTMzYzg5LCAweGNlYTkyN2VlLCAweGI3NjFjOTM1LCAweGUxMWNlNWVkLCAweDdhNDdiMTNjLCAweDljZDJkZjU5LCAweDU1ZjI3MzNmLCAweDE4MTRjZTc5LCAweDczYzczN2JmLCAweDUzZjdjZGVhLCAweDVmZmRhYTViLCAweGRmM2Q2ZjE0LCAweDc4NDRkYjg2LCAweGNhYWZmMzgxLCAweGI5NjhjNDNlLCAweDM4MjQzNDJjLCAweGMyYTM0MDVmLCAweDE2MWRjMzcyLCAweGJjZTIyNTBjLCAweDI4M2M0OThiLCAweGZmMGQ5NTQxLCAweDM5YTgwMTcxLCAweDA4MGNiM2RlLCAweGQ4YjRlNDljLCAweDY0NTZjMTkwLCAweDdiY2I4NDYxLCAweGQ1MzJiNjcwLCAweDQ4NmM1Yzc0LCAweGQwYjg1NzQyXTtcbmNvbnN0IFQ2ID0gWzB4NTA1MWY0YTcsIDB4NTM3ZTQxNjUsIDB4YzMxYTE3YTQsIDB4OTYzYTI3NWUsIDB4Y2IzYmFiNmIsIDB4ZjExZjlkNDUsIDB4YWJhY2ZhNTgsIDB4OTM0YmUzMDMsIDB4NTUyMDMwZmEsIDB4ZjZhZDc2NmQsIDB4OTE4OGNjNzYsIDB4MjVmNTAyNGMsIDB4ZmM0ZmU1ZDcsIDB4ZDdjNTJhY2IsIDB4ODAyNjM1NDQsIDB4OGZiNTYyYTMsIDB4NDlkZWIxNWEsIDB4NjcyNWJhMWIsIDB4OTg0NWVhMGUsIDB4ZTE1ZGZlYzAsIDB4MDJjMzJmNzUsIDB4MTI4MTRjZjAsIDB4YTM4ZDQ2OTcsIDB4YzY2YmQzZjksIDB4ZTcwMzhmNWYsIDB4OTUxNTkyOWMsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4MmRkNGJlODMsIDB4ZDM1ODc0MjEsIDB4Mjk0OWUwNjksIDB4NDQ4ZWM5YzgsIDB4NmE3NWMyODksIDB4NzhmNDhlNzksIDB4NmI5OTU4M2UsIDB4ZGQyN2I5NzEsIDB4YjZiZWUxNGYsIDB4MTdmMDg4YWQsIDB4NjZjOTIwYWMsIDB4YjQ3ZGNlM2EsIDB4MTg2M2RmNGEsIDB4ODJlNTFhMzEsIDB4NjA5NzUxMzMsIDB4NDU2MjUzN2YsIDB4ZTBiMTY0NzcsIDB4ODRiYjZiYWUsIDB4MWNmZTgxYTAsIDB4OTRmOTA4MmIsIDB4NTg3MDQ4NjgsIDB4MTk4ZjQ1ZmQsIDB4ODc5NGRlNmMsIDB4Yjc1MjdiZjgsIDB4MjNhYjczZDMsIDB4ZTI3MjRiMDIsIDB4NTdlMzFmOGYsIDB4MmE2NjU1YWIsIDB4MDdiMmViMjgsIDB4MDMyZmI1YzIsIDB4OWE4NmM1N2IsIDB4YTVkMzM3MDgsIDB4ZjIzMDI4ODcsIDB4YjIyM2JmYTUsIDB4YmEwMjAzNmEsIDB4NWNlZDE2ODIsIDB4MmI4YWNmMWMsIDB4OTJhNzc5YjQsIDB4ZjBmMzA3ZjIsIDB4YTE0ZTY5ZTIsIDB4Y2Q2NWRhZjQsIDB4ZDUwNjA1YmUsIDB4MWZkMTM0NjIsIDB4OGFjNGE2ZmUsIDB4OWQzNDJlNTMsIDB4YTBhMmYzNTUsIDB4MzIwNThhZTEsIDB4NzVhNGY2ZWIsIDB4MzkwYjgzZWMsIDB4YWE0MDYwZWYsIDB4MDY1ZTcxOWYsIDB4NTFiZDZlMTAsIDB4ZjkzZTIxOGEsIDB4M2Q5NmRkMDYsIDB4YWVkZDNlMDUsIDB4NDY0ZGU2YmQsIDB4YjU5MTU0OGQsIDB4MDU3MWM0NWQsIDB4NmYwNDA2ZDQsIDB4ZmY2MDUwMTUsIDB4MjQxOTk4ZmIsIDB4OTdkNmJkZTksIDB4Y2M4OTQwNDMsIDB4Nzc2N2Q5OWUsIDB4YmRiMGU4NDIsIDB4ODgwNzg5OGIsIDB4MzhlNzE5NWIsIDB4ZGI3OWM4ZWUsIDB4NDdhMTdjMGEsIDB4ZTk3YzQyMGYsIDB4YzlmODg0MWUsIDB4MDAwMDAwMDAsIDB4ODMwOTgwODYsIDB4NDgzMjJiZWQsIDB4YWMxZTExNzAsIDB4NGU2YzVhNzIsIDB4ZmJmZDBlZmYsIDB4NTYwZjg1MzgsIDB4MWUzZGFlZDUsIDB4MjczNjJkMzksIDB4NjQwYTBmZDksIDB4MjE2ODVjYTYsIDB4ZDE5YjViNTQsIDB4M2EyNDM2MmUsIDB4YjEwYzBhNjcsIDB4MGY5MzU3ZTcsIDB4ZDJiNGVlOTYsIDB4OWUxYjliOTEsIDB4NGY4MGMwYzUsIDB4YTI2MWRjMjAsIDB4Njk1YTc3NGIsIDB4MTYxYzEyMWEsIDB4MGFlMjkzYmEsIDB4ZTVjMGEwMmEsIDB4NDMzYzIyZTAsIDB4MWQxMjFiMTcsIDB4MGIwZTA5MGQsIDB4YWRmMjhiYzcsIDB4YjkyZGI2YTgsIDB4YzgxNDFlYTksIDB4ODU1N2YxMTksIDB4NGNhZjc1MDcsIDB4YmJlZTk5ZGQsIDB4ZmRhMzdmNjAsIDB4OWZmNzAxMjYsIDB4YmM1YzcyZjUsIDB4YzU0NDY2M2IsIDB4MzQ1YmZiN2UsIDB4NzY4YjQzMjksIDB4ZGNjYjIzYzYsIDB4NjhiNmVkZmMsIDB4NjNiOGU0ZjEsIDB4Y2FkNzMxZGMsIDB4MTA0MjYzODUsIDB4NDAxMzk3MjIsIDB4MjA4NGM2MTEsIDB4N2Q4NTRhMjQsIDB4ZjhkMmJiM2QsIDB4MTFhZWY5MzIsIDB4NmRjNzI5YTEsIDB4NGIxZDllMmYsIDB4ZjNkY2IyMzAsIDB4ZWMwZDg2NTIsIDB4ZDA3N2MxZTMsIDB4NmMyYmIzMTYsIDB4OTlhOTcwYjksIDB4ZmExMTk0NDgsIDB4MjI0N2U5NjQsIDB4YzRhOGZjOGMsIDB4MWFhMGYwM2YsIDB4ZDg1NjdkMmMsIDB4ZWYyMjMzOTAsIDB4Yzc4NzQ5NGUsIDB4YzFkOTM4ZDEsIDB4ZmU4Y2NhYTIsIDB4MzY5OGQ0MGIsIDB4Y2ZhNmY1ODEsIDB4MjhhNTdhZGUsIDB4MjZkYWI3OGUsIDB4YTQzZmFkYmYsIDB4ZTQyYzNhOWQsIDB4MGQ1MDc4OTIsIDB4OWI2YTVmY2MsIDB4NjI1NDdlNDYsIDB4YzJmNjhkMTMsIDB4ZTg5MGQ4YjgsIDB4NWUyZTM5ZjcsIDB4ZjU4MmMzYWYsIDB4YmU5ZjVkODAsIDB4N2M2OWQwOTMsIDB4YTk2ZmQ1MmQsIDB4YjNjZjI1MTIsIDB4M2JjOGFjOTksIDB4YTcxMDE4N2QsIDB4NmVlODljNjMsIDB4N2JkYjNiYmIsIDB4MDljZDI2NzgsIDB4ZjQ2ZTU5MTgsIDB4MDFlYzlhYjcsIDB4YTg4MzRmOWEsIDB4NjVlNjk1NmUsIDB4N2VhYWZmZTYsIDB4MDgyMWJjY2YsIDB4ZTZlZjE1ZTgsIDB4ZDliYWU3OWIsIDB4Y2U0YTZmMzYsIDB4ZDRlYTlmMDksIDB4ZDYyOWIwN2MsIDB4YWYzMWE0YjIsIDB4MzEyYTNmMjMsIDB4MzBjNmE1OTQsIDB4YzAzNWEyNjYsIDB4Mzc3NDRlYmMsIDB4YTZmYzgyY2EsIDB4YjBlMDkwZDAsIDB4MTUzM2E3ZDgsIDB4NGFmMTA0OTgsIDB4Zjc0MWVjZGEsIDB4MGU3ZmNkNTAsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4NGQ0M2VmYjAsIDB4NTRjY2FhNGQsIDB4ZGZlNDk2MDQsIDB4ZTM5ZWQxYjUsIDB4MWI0YzZhODgsIDB4YjhjMTJjMWYsIDB4N2Y0NjY1NTEsIDB4MDQ5ZDVlZWEsIDB4NWQwMThjMzUsIDB4NzNmYTg3NzQsIDB4MmVmYjBiNDEsIDB4NWFiMzY3MWQsIDB4NTI5MmRiZDIsIDB4MzNlOTEwNTYsIDB4MTM2ZGQ2NDcsIDB4OGM5YWQ3NjEsIDB4N2EzN2ExMGMsIDB4OGU1OWY4MTQsIDB4ODllYjEzM2MsIDB4ZWVjZWE5MjcsIDB4MzViNzYxYzksIDB4ZWRlMTFjZTUsIDB4M2M3YTQ3YjEsIDB4NTk5Y2QyZGYsIDB4M2Y1NWYyNzMsIDB4NzkxODE0Y2UsIDB4YmY3M2M3MzcsIDB4ZWE1M2Y3Y2QsIDB4NWI1ZmZkYWEsIDB4MTRkZjNkNmYsIDB4ODY3ODQ0ZGIsIDB4ODFjYWFmZjMsIDB4M2ViOTY4YzQsIDB4MmMzODI0MzQsIDB4NWZjMmEzNDAsIDB4NzIxNjFkYzMsIDB4MGNiY2UyMjUsIDB4OGIyODNjNDksIDB4NDFmZjBkOTUsIDB4NzEzOWE4MDEsIDB4ZGUwODBjYjMsIDB4OWNkOGI0ZTQsIDB4OTA2NDU2YzEsIDB4NjE3YmNiODQsIDB4NzBkNTMyYjYsIDB4NzQ0ODZjNWMsIDB4NDJkMGI4NTddO1xuY29uc3QgVDcgPSBbMHhhNzUwNTFmNCwgMHg2NTUzN2U0MSwgMHhhNGMzMWExNywgMHg1ZTk2M2EyNywgMHg2YmNiM2JhYiwgMHg0NWYxMWY5ZCwgMHg1OGFiYWNmYSwgMHgwMzkzNGJlMywgMHhmYTU1MjAzMCwgMHg2ZGY2YWQ3NiwgMHg3NjkxODhjYywgMHg0YzI1ZjUwMiwgMHhkN2ZjNGZlNSwgMHhjYmQ3YzUyYSwgMHg0NDgwMjYzNSwgMHhhMzhmYjU2MiwgMHg1YTQ5ZGViMSwgMHgxYjY3MjViYSwgMHgwZTk4NDVlYSwgMHhjMGUxNWRmZSwgMHg3NTAyYzMyZiwgMHhmMDEyODE0YywgMHg5N2EzOGQ0NiwgMHhmOWM2NmJkMywgMHg1ZmU3MDM4ZiwgMHg5Yzk1MTU5MiwgMHg3YWViYmY2ZCwgMHg1OWRhOTU1MiwgMHg4MzJkZDRiZSwgMHgyMWQzNTg3NCwgMHg2OTI5NDllMCwgMHhjODQ0OGVjOSwgMHg4OTZhNzVjMiwgMHg3OTc4ZjQ4ZSwgMHgzZTZiOTk1OCwgMHg3MWRkMjdiOSwgMHg0ZmI2YmVlMSwgMHhhZDE3ZjA4OCwgMHhhYzY2YzkyMCwgMHgzYWI0N2RjZSwgMHg0YTE4NjNkZiwgMHgzMTgyZTUxYSwgMHgzMzYwOTc1MSwgMHg3ZjQ1NjI1MywgMHg3N2UwYjE2NCwgMHhhZTg0YmI2YiwgMHhhMDFjZmU4MSwgMHgyYjk0ZjkwOCwgMHg2ODU4NzA0OCwgMHhmZDE5OGY0NSwgMHg2Yzg3OTRkZSwgMHhmOGI3NTI3YiwgMHhkMzIzYWI3MywgMHgwMmUyNzI0YiwgMHg4ZjU3ZTMxZiwgMHhhYjJhNjY1NSwgMHgyODA3YjJlYiwgMHhjMjAzMmZiNSwgMHg3YjlhODZjNSwgMHgwOGE1ZDMzNywgMHg4N2YyMzAyOCwgMHhhNWIyMjNiZiwgMHg2YWJhMDIwMywgMHg4MjVjZWQxNiwgMHgxYzJiOGFjZiwgMHhiNDkyYTc3OSwgMHhmMmYwZjMwNywgMHhlMmExNGU2OSwgMHhmNGNkNjVkYSwgMHhiZWQ1MDYwNSwgMHg2MjFmZDEzNCwgMHhmZThhYzRhNiwgMHg1MzlkMzQyZSwgMHg1NWEwYTJmMywgMHhlMTMyMDU4YSwgMHhlYjc1YTRmNiwgMHhlYzM5MGI4MywgMHhlZmFhNDA2MCwgMHg5ZjA2NWU3MSwgMHgxMDUxYmQ2ZSwgMHg4YWY5M2UyMSwgMHgwNjNkOTZkZCwgMHgwNWFlZGQzZSwgMHhiZDQ2NGRlNiwgMHg4ZGI1OTE1NCwgMHg1ZDA1NzFjNCwgMHhkNDZmMDQwNiwgMHgxNWZmNjA1MCwgMHhmYjI0MTk5OCwgMHhlOTk3ZDZiZCwgMHg0M2NjODk0MCwgMHg5ZTc3NjdkOSwgMHg0MmJkYjBlOCwgMHg4Yjg4MDc4OSwgMHg1YjM4ZTcxOSwgMHhlZWRiNzljOCwgMHgwYTQ3YTE3YywgMHgwZmU5N2M0MiwgMHgxZWM5Zjg4NCwgMHgwMDAwMDAwMCwgMHg4NjgzMDk4MCwgMHhlZDQ4MzIyYiwgMHg3MGFjMWUxMSwgMHg3MjRlNmM1YSwgMHhmZmZiZmQwZSwgMHgzODU2MGY4NSwgMHhkNTFlM2RhZSwgMHgzOTI3MzYyZCwgMHhkOTY0MGEwZiwgMHhhNjIxNjg1YywgMHg1NGQxOWI1YiwgMHgyZTNhMjQzNiwgMHg2N2IxMGMwYSwgMHhlNzBmOTM1NywgMHg5NmQyYjRlZSwgMHg5MTllMWI5YiwgMHhjNTRmODBjMCwgMHgyMGEyNjFkYywgMHg0YjY5NWE3NywgMHgxYTE2MWMxMiwgMHhiYTBhZTI5MywgMHgyYWU1YzBhMCwgMHhlMDQzM2MyMiwgMHgxNzFkMTIxYiwgMHgwZDBiMGUwOSwgMHhjN2FkZjI4YiwgMHhhOGI5MmRiNiwgMHhhOWM4MTQxZSwgMHgxOTg1NTdmMSwgMHgwNzRjYWY3NSwgMHhkZGJiZWU5OSwgMHg2MGZkYTM3ZiwgMHgyNjlmZjcwMSwgMHhmNWJjNWM3MiwgMHgzYmM1NDQ2NiwgMHg3ZTM0NWJmYiwgMHgyOTc2OGI0MywgMHhjNmRjY2IyMywgMHhmYzY4YjZlZCwgMHhmMTYzYjhlNCwgMHhkY2NhZDczMSwgMHg4NTEwNDI2MywgMHgyMjQwMTM5NywgMHgxMTIwODRjNiwgMHgyNDdkODU0YSwgMHgzZGY4ZDJiYiwgMHgzMjExYWVmOSwgMHhhMTZkYzcyOSwgMHgyZjRiMWQ5ZSwgMHgzMGYzZGNiMiwgMHg1MmVjMGQ4NiwgMHhlM2QwNzdjMSwgMHgxNjZjMmJiMywgMHhiOTk5YTk3MCwgMHg0OGZhMTE5NCwgMHg2NDIyNDdlOSwgMHg4Y2M0YThmYywgMHgzZjFhYTBmMCwgMHgyY2Q4NTY3ZCwgMHg5MGVmMjIzMywgMHg0ZWM3ODc0OSwgMHhkMWMxZDkzOCwgMHhhMmZlOGNjYSwgMHgwYjM2OThkNCwgMHg4MWNmYTZmNSwgMHhkZTI4YTU3YSwgMHg4ZTI2ZGFiNywgMHhiZmE0M2ZhZCwgMHg5ZGU0MmMzYSwgMHg5MjBkNTA3OCwgMHhjYzliNmE1ZiwgMHg0NjYyNTQ3ZSwgMHgxM2MyZjY4ZCwgMHhiOGU4OTBkOCwgMHhmNzVlMmUzOSwgMHhhZmY1ODJjMywgMHg4MGJlOWY1ZCwgMHg5MzdjNjlkMCwgMHgyZGE5NmZkNSwgMHgxMmIzY2YyNSwgMHg5OTNiYzhhYywgMHg3ZGE3MTAxOCwgMHg2MzZlZTg5YywgMHhiYjdiZGIzYiwgMHg3ODA5Y2QyNiwgMHgxOGY0NmU1OSwgMHhiNzAxZWM5YSwgMHg5YWE4ODM0ZiwgMHg2ZTY1ZTY5NSwgMHhlNjdlYWFmZiwgMHhjZjA4MjFiYywgMHhlOGU2ZWYxNSwgMHg5YmQ5YmFlNywgMHgzNmNlNGE2ZiwgMHgwOWQ0ZWE5ZiwgMHg3Y2Q2MjliMCwgMHhiMmFmMzFhNCwgMHgyMzMxMmEzZiwgMHg5NDMwYzZhNSwgMHg2NmMwMzVhMiwgMHhiYzM3NzQ0ZSwgMHhjYWE2ZmM4MiwgMHhkMGIwZTA5MCwgMHhkODE1MzNhNywgMHg5ODRhZjEwNCwgMHhkYWY3NDFlYywgMHg1MDBlN2ZjZCwgMHhmNjJmMTc5MSwgMHhkNjhkNzY0ZCwgMHhiMDRkNDNlZiwgMHg0ZDU0Y2NhYSwgMHgwNGRmZTQ5NiwgMHhiNWUzOWVkMSwgMHg4ODFiNGM2YSwgMHgxZmI4YzEyYywgMHg1MTdmNDY2NSwgMHhlYTA0OWQ1ZSwgMHgzNTVkMDE4YywgMHg3NDczZmE4NywgMHg0MTJlZmIwYiwgMHgxZDVhYjM2NywgMHhkMjUyOTJkYiwgMHg1NjMzZTkxMCwgMHg0NzEzNmRkNiwgMHg2MThjOWFkNywgMHgwYzdhMzdhMSwgMHgxNDhlNTlmOCwgMHgzYzg5ZWIxMywgMHgyN2VlY2VhOSwgMHhjOTM1Yjc2MSwgMHhlNWVkZTExYywgMHhiMTNjN2E0NywgMHhkZjU5OWNkMiwgMHg3MzNmNTVmMiwgMHhjZTc5MTgxNCwgMHgzN2JmNzNjNywgMHhjZGVhNTNmNywgMHhhYTViNWZmZCwgMHg2ZjE0ZGYzZCwgMHhkYjg2Nzg0NCwgMHhmMzgxY2FhZiwgMHhjNDNlYjk2OCwgMHgzNDJjMzgyNCwgMHg0MDVmYzJhMywgMHhjMzcyMTYxZCwgMHgyNTBjYmNlMiwgMHg0OThiMjgzYywgMHg5NTQxZmYwZCwgMHgwMTcxMzlhOCwgMHhiM2RlMDgwYywgMHhlNDljZDhiNCwgMHhjMTkwNjQ1NiwgMHg4NDYxN2JjYiwgMHhiNjcwZDUzMiwgMHg1Yzc0NDg2YywgMHg1NzQyZDBiOF07XG5jb25zdCBUOCA9IFsweGY0YTc1MDUxLCAweDQxNjU1MzdlLCAweDE3YTRjMzFhLCAweDI3NWU5NjNhLCAweGFiNmJjYjNiLCAweDlkNDVmMTFmLCAweGZhNThhYmFjLCAweGUzMDM5MzRiLCAweDMwZmE1NTIwLCAweDc2NmRmNmFkLCAweGNjNzY5MTg4LCAweDAyNGMyNWY1LCAweGU1ZDdmYzRmLCAweDJhY2JkN2M1LCAweDM1NDQ4MDI2LCAweDYyYTM4ZmI1LCAweGIxNWE0OWRlLCAweGJhMWI2NzI1LCAweGVhMGU5ODQ1LCAweGZlYzBlMTVkLCAweDJmNzUwMmMzLCAweDRjZjAxMjgxLCAweDQ2OTdhMzhkLCAweGQzZjljNjZiLCAweDhmNWZlNzAzLCAweDkyOWM5NTE1LCAweDZkN2FlYmJmLCAweDUyNTlkYTk1LCAweGJlODMyZGQ0LCAweDc0MjFkMzU4LCAweGUwNjkyOTQ5LCAweGM5Yzg0NDhlLCAweGMyODk2YTc1LCAweDhlNzk3OGY0LCAweDU4M2U2Yjk5LCAweGI5NzFkZDI3LCAweGUxNGZiNmJlLCAweDg4YWQxN2YwLCAweDIwYWM2NmM5LCAweGNlM2FiNDdkLCAweGRmNGExODYzLCAweDFhMzE4MmU1LCAweDUxMzM2MDk3LCAweDUzN2Y0NTYyLCAweDY0NzdlMGIxLCAweDZiYWU4NGJiLCAweDgxYTAxY2ZlLCAweDA4MmI5NGY5LCAweDQ4Njg1ODcwLCAweDQ1ZmQxOThmLCAweGRlNmM4Nzk0LCAweDdiZjhiNzUyLCAweDczZDMyM2FiLCAweDRiMDJlMjcyLCAweDFmOGY1N2UzLCAweDU1YWIyYTY2LCAweGViMjgwN2IyLCAweGI1YzIwMzJmLCAweGM1N2I5YTg2LCAweDM3MDhhNWQzLCAweDI4ODdmMjMwLCAweGJmYTViMjIzLCAweDAzNmFiYTAyLCAweDE2ODI1Y2VkLCAweGNmMWMyYjhhLCAweDc5YjQ5MmE3LCAweDA3ZjJmMGYzLCAweDY5ZTJhMTRlLCAweGRhZjRjZDY1LCAweDA1YmVkNTA2LCAweDM0NjIxZmQxLCAweGE2ZmU4YWM0LCAweDJlNTM5ZDM0LCAweGYzNTVhMGEyLCAweDhhZTEzMjA1LCAweGY2ZWI3NWE0LCAweDgzZWMzOTBiLCAweDYwZWZhYTQwLCAweDcxOWYwNjVlLCAweDZlMTA1MWJkLCAweDIxOGFmOTNlLCAweGRkMDYzZDk2LCAweDNlMDVhZWRkLCAweGU2YmQ0NjRkLCAweDU0OGRiNTkxLCAweGM0NWQwNTcxLCAweDA2ZDQ2ZjA0LCAweDUwMTVmZjYwLCAweDk4ZmIyNDE5LCAweGJkZTk5N2Q2LCAweDQwNDNjYzg5LCAweGQ5OWU3NzY3LCAweGU4NDJiZGIwLCAweDg5OGI4ODA3LCAweDE5NWIzOGU3LCAweGM4ZWVkYjc5LCAweDdjMGE0N2ExLCAweDQyMGZlOTdjLCAweDg0MWVjOWY4LCAweDAwMDAwMDAwLCAweDgwODY4MzA5LCAweDJiZWQ0ODMyLCAweDExNzBhYzFlLCAweDVhNzI0ZTZjLCAweDBlZmZmYmZkLCAweDg1Mzg1NjBmLCAweGFlZDUxZTNkLCAweDJkMzkyNzM2LCAweDBmZDk2NDBhLCAweDVjYTYyMTY4LCAweDViNTRkMTliLCAweDM2MmUzYTI0LCAweDBhNjdiMTBjLCAweDU3ZTcwZjkzLCAweGVlOTZkMmI0LCAweDliOTE5ZTFiLCAweGMwYzU0ZjgwLCAweGRjMjBhMjYxLCAweDc3NGI2OTVhLCAweDEyMWExNjFjLCAweDkzYmEwYWUyLCAweGEwMmFlNWMwLCAweDIyZTA0MzNjLCAweDFiMTcxZDEyLCAweDA5MGQwYjBlLCAweDhiYzdhZGYyLCAweGI2YThiOTJkLCAweDFlYTljODE0LCAweGYxMTk4NTU3LCAweDc1MDc0Y2FmLCAweDk5ZGRiYmVlLCAweDdmNjBmZGEzLCAweDAxMjY5ZmY3LCAweDcyZjViYzVjLCAweDY2M2JjNTQ0LCAweGZiN2UzNDViLCAweDQzMjk3NjhiLCAweDIzYzZkY2NiLCAweGVkZmM2OGI2LCAweGU0ZjE2M2I4LCAweDMxZGNjYWQ3LCAweDYzODUxMDQyLCAweDk3MjI0MDEzLCAweGM2MTEyMDg0LCAweDRhMjQ3ZDg1LCAweGJiM2RmOGQyLCAweGY5MzIxMWFlLCAweDI5YTE2ZGM3LCAweDllMmY0YjFkLCAweGIyMzBmM2RjLCAweDg2NTJlYzBkLCAweGMxZTNkMDc3LCAweGIzMTY2YzJiLCAweDcwYjk5OWE5LCAweDk0NDhmYTExLCAweGU5NjQyMjQ3LCAweGZjOGNjNGE4LCAweGYwM2YxYWEwLCAweDdkMmNkODU2LCAweDMzOTBlZjIyLCAweDQ5NGVjNzg3LCAweDM4ZDFjMWQ5LCAweGNhYTJmZThjLCAweGQ0MGIzNjk4LCAweGY1ODFjZmE2LCAweDdhZGUyOGE1LCAweGI3OGUyNmRhLCAweGFkYmZhNDNmLCAweDNhOWRlNDJjLCAweDc4OTIwZDUwLCAweDVmY2M5YjZhLCAweDdlNDY2MjU0LCAweDhkMTNjMmY2LCAweGQ4YjhlODkwLCAweDM5Zjc1ZTJlLCAweGMzYWZmNTgyLCAweDVkODBiZTlmLCAweGQwOTM3YzY5LCAweGQ1MmRhOTZmLCAweDI1MTJiM2NmLCAweGFjOTkzYmM4LCAweDE4N2RhNzEwLCAweDljNjM2ZWU4LCAweDNiYmI3YmRiLCAweDI2NzgwOWNkLCAweDU5MThmNDZlLCAweDlhYjcwMWVjLCAweDRmOWFhODgzLCAweDk1NmU2NWU2LCAweGZmZTY3ZWFhLCAweGJjY2YwODIxLCAweDE1ZThlNmVmLCAweGU3OWJkOWJhLCAweDZmMzZjZTRhLCAweDlmMDlkNGVhLCAweGIwN2NkNjI5LCAweGE0YjJhZjMxLCAweDNmMjMzMTJhLCAweGE1OTQzMGM2LCAweGEyNjZjMDM1LCAweDRlYmMzNzc0LCAweDgyY2FhNmZjLCAweDkwZDBiMGUwLCAweGE3ZDgxNTMzLCAweDA0OTg0YWYxLCAweGVjZGFmNzQxLCAweGNkNTAwZTdmLCAweDkxZjYyZjE3LCAweDRkZDY4ZDc2LCAweGVmYjA0ZDQzLCAweGFhNGQ1NGNjLCAweDk2MDRkZmU0LCAweGQxYjVlMzllLCAweDZhODgxYjRjLCAweDJjMWZiOGMxLCAweDY1NTE3ZjQ2LCAweDVlZWEwNDlkLCAweDhjMzU1ZDAxLCAweDg3NzQ3M2ZhLCAweDBiNDEyZWZiLCAweDY3MWQ1YWIzLCAweGRiZDI1MjkyLCAweDEwNTYzM2U5LCAweGQ2NDcxMzZkLCAweGQ3NjE4YzlhLCAweGExMGM3YTM3LCAweGY4MTQ4ZTU5LCAweDEzM2M4OWViLCAweGE5MjdlZWNlLCAweDYxYzkzNWI3LCAweDFjZTVlZGUxLCAweDQ3YjEzYzdhLCAweGQyZGY1OTljLCAweGYyNzMzZjU1LCAweDE0Y2U3OTE4LCAweGM3MzdiZjczLCAweGY3Y2RlYTUzLCAweGZkYWE1YjVmLCAweDNkNmYxNGRmLCAweDQ0ZGI4Njc4LCAweGFmZjM4MWNhLCAweDY4YzQzZWI5LCAweDI0MzQyYzM4LCAweGEzNDA1ZmMyLCAweDFkYzM3MjE2LCAweGUyMjUwY2JjLCAweDNjNDk4YjI4LCAweDBkOTU0MWZmLCAweGE4MDE3MTM5LCAweDBjYjNkZTA4LCAweGI0ZTQ5Y2Q4LCAweDU2YzE5MDY0LCAweGNiODQ2MTdiLCAweDMyYjY3MGQ1LCAweDZjNWM3NDQ4LCAweGI4NTc0MmQwXTtcbi8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjcnlwdGlvbiBrZXkgZXhwYW5zaW9uXG5jb25zdCBVMSA9IFsweDAwMDAwMDAwLCAweDBlMDkwZDBiLCAweDFjMTIxYTE2LCAweDEyMWIxNzFkLCAweDM4MjQzNDJjLCAweDM2MmQzOTI3LCAweDI0MzYyZTNhLCAweDJhM2YyMzMxLCAweDcwNDg2ODU4LCAweDdlNDE2NTUzLCAweDZjNWE3MjRlLCAweDYyNTM3ZjQ1LCAweDQ4NmM1Yzc0LCAweDQ2NjU1MTdmLCAweDU0N2U0NjYyLCAweDVhNzc0YjY5LCAweGUwOTBkMGIwLCAweGVlOTlkZGJiLCAweGZjODJjYWE2LCAweGYyOGJjN2FkLCAweGQ4YjRlNDljLCAweGQ2YmRlOTk3LCAweGM0YTZmZThhLCAweGNhYWZmMzgxLCAweDkwZDhiOGU4LCAweDllZDFiNWUzLCAweDhjY2FhMmZlLCAweDgyYzNhZmY1LCAweGE4ZmM4Y2M0LCAweGE2ZjU4MWNmLCAweGI0ZWU5NmQyLCAweGJhZTc5YmQ5LCAweGRiM2JiYjdiLCAweGQ1MzJiNjcwLCAweGM3MjlhMTZkLCAweGM5MjBhYzY2LCAweGUzMWY4ZjU3LCAweGVkMTY4MjVjLCAweGZmMGQ5NTQxLCAweGYxMDQ5ODRhLCAweGFiNzNkMzIzLCAweGE1N2FkZTI4LCAweGI3NjFjOTM1LCAweGI5NjhjNDNlLCAweDkzNTdlNzBmLCAweDlkNWVlYTA0LCAweDhmNDVmZDE5LCAweDgxNGNmMDEyLCAweDNiYWI2YmNiLCAweDM1YTI2NmMwLCAweDI3Yjk3MWRkLCAweDI5YjA3Y2Q2LCAweDAzOGY1ZmU3LCAweDBkODY1MmVjLCAweDFmOWQ0NWYxLCAweDExOTQ0OGZhLCAweDRiZTMwMzkzLCAweDQ1ZWEwZTk4LCAweDU3ZjExOTg1LCAweDU5ZjgxNDhlLCAweDczYzczN2JmLCAweDdkY2UzYWI0LCAweDZmZDUyZGE5LCAweDYxZGMyMGEyLCAweGFkNzY2ZGY2LCAweGEzN2Y2MGZkLCAweGIxNjQ3N2UwLCAweGJmNmQ3YWViLCAweDk1NTI1OWRhLCAweDliNWI1NGQxLCAweDg5NDA0M2NjLCAweDg3NDk0ZWM3LCAweGRkM2UwNWFlLCAweGQzMzcwOGE1LCAweGMxMmMxZmI4LCAweGNmMjUxMmIzLCAweGU1MWEzMTgyLCAweGViMTMzYzg5LCAweGY5MDgyYjk0LCAweGY3MDEyNjlmLCAweDRkZTZiZDQ2LCAweDQzZWZiMDRkLCAweDUxZjRhNzUwLCAweDVmZmRhYTViLCAweDc1YzI4OTZhLCAweDdiY2I4NDYxLCAweDY5ZDA5MzdjLCAweDY3ZDk5ZTc3LCAweDNkYWVkNTFlLCAweDMzYTdkODE1LCAweDIxYmNjZjA4LCAweDJmYjVjMjAzLCAweDA1OGFlMTMyLCAweDBiODNlYzM5LCAweDE5OThmYjI0LCAweDE3OTFmNjJmLCAweDc2NGRkNjhkLCAweDc4NDRkYjg2LCAweDZhNWZjYzliLCAweDY0NTZjMTkwLCAweDRlNjllMmExLCAweDQwNjBlZmFhLCAweDUyN2JmOGI3LCAweDVjNzJmNWJjLCAweDA2MDViZWQ1LCAweDA4MGNiM2RlLCAweDFhMTdhNGMzLCAweDE0MWVhOWM4LCAweDNlMjE4YWY5LCAweDMwMjg4N2YyLCAweDIyMzM5MGVmLCAweDJjM2E5ZGU0LCAweDk2ZGQwNjNkLCAweDk4ZDQwYjM2LCAweDhhY2YxYzJiLCAweDg0YzYxMTIwLCAweGFlZjkzMjExLCAweGEwZjAzZjFhLCAweGIyZWIyODA3LCAweGJjZTIyNTBjLCAweGU2OTU2ZTY1LCAweGU4OWM2MzZlLCAweGZhODc3NDczLCAweGY0OGU3OTc4LCAweGRlYjE1YTQ5LCAweGQwYjg1NzQyLCAweGMyYTM0MDVmLCAweGNjYWE0ZDU0LCAweDQxZWNkYWY3LCAweDRmZTVkN2ZjLCAweDVkZmVjMGUxLCAweDUzZjdjZGVhLCAweDc5YzhlZWRiLCAweDc3YzFlM2QwLCAweDY1ZGFmNGNkLCAweDZiZDNmOWM2LCAweDMxYTRiMmFmLCAweDNmYWRiZmE0LCAweDJkYjZhOGI5LCAweDIzYmZhNWIyLCAweDA5ODA4NjgzLCAweDA3ODk4Yjg4LCAweDE1OTI5Yzk1LCAweDFiOWI5MTllLCAweGExN2MwYTQ3LCAweGFmNzUwNzRjLCAweGJkNmUxMDUxLCAweGIzNjcxZDVhLCAweDk5NTgzZTZiLCAweDk3NTEzMzYwLCAweDg1NGEyNDdkLCAweDhiNDMyOTc2LCAweGQxMzQ2MjFmLCAweGRmM2Q2ZjE0LCAweGNkMjY3ODA5LCAweGMzMmY3NTAyLCAweGU5MTA1NjMzLCAweGU3MTk1YjM4LCAweGY1MDI0YzI1LCAweGZiMGI0MTJlLCAweDlhZDc2MThjLCAweDk0ZGU2Yzg3LCAweDg2YzU3YjlhLCAweDg4Y2M3NjkxLCAweGEyZjM1NWEwLCAweGFjZmE1OGFiLCAweGJlZTE0ZmI2LCAweGIwZTg0MmJkLCAweGVhOWYwOWQ0LCAweGU0OTYwNGRmLCAweGY2OGQxM2MyLCAweGY4ODQxZWM5LCAweGQyYmIzZGY4LCAweGRjYjIzMGYzLCAweGNlYTkyN2VlLCAweGMwYTAyYWU1LCAweDdhNDdiMTNjLCAweDc0NGViYzM3LCAweDY2NTVhYjJhLCAweDY4NWNhNjIxLCAweDQyNjM4NTEwLCAweDRjNmE4ODFiLCAweDVlNzE5ZjA2LCAweDUwNzg5MjBkLCAweDBhMGZkOTY0LCAweDA0MDZkNDZmLCAweDE2MWRjMzcyLCAweDE4MTRjZTc5LCAweDMyMmJlZDQ4LCAweDNjMjJlMDQzLCAweDJlMzlmNzVlLCAweDIwMzBmYTU1LCAweGVjOWFiNzAxLCAweGUyOTNiYTBhLCAweGYwODhhZDE3LCAweGZlODFhMDFjLCAweGQ0YmU4MzJkLCAweGRhYjc4ZTI2LCAweGM4YWM5OTNiLCAweGM2YTU5NDMwLCAweDljZDJkZjU5LCAweDkyZGJkMjUyLCAweDgwYzBjNTRmLCAweDhlYzljODQ0LCAweGE0ZjZlYjc1LCAweGFhZmZlNjdlLCAweGI4ZTRmMTYzLCAweGI2ZWRmYzY4LCAweDBjMGE2N2IxLCAweDAyMDM2YWJhLCAweDEwMTg3ZGE3LCAweDFlMTE3MGFjLCAweDM0MmU1MzlkLCAweDNhMjc1ZTk2LCAweDI4M2M0OThiLCAweDI2MzU0NDgwLCAweDdjNDIwZmU5LCAweDcyNGIwMmUyLCAweDYwNTAxNWZmLCAweDZlNTkxOGY0LCAweDQ0NjYzYmM1LCAweDRhNmYzNmNlLCAweDU4NzQyMWQzLCAweDU2N2QyY2Q4LCAweDM3YTEwYzdhLCAweDM5YTgwMTcxLCAweDJiYjMxNjZjLCAweDI1YmExYjY3LCAweDBmODUzODU2LCAweDAxOGMzNTVkLCAweDEzOTcyMjQwLCAweDFkOWUyZjRiLCAweDQ3ZTk2NDIyLCAweDQ5ZTA2OTI5LCAweDViZmI3ZTM0LCAweDU1ZjI3MzNmLCAweDdmY2Q1MDBlLCAweDcxYzQ1ZDA1LCAweDYzZGY0YTE4LCAweDZkZDY0NzEzLCAweGQ3MzFkY2NhLCAweGQ5MzhkMWMxLCAweGNiMjNjNmRjLCAweGM1MmFjYmQ3LCAweGVmMTVlOGU2LCAweGUxMWNlNWVkLCAweGYzMDdmMmYwLCAweGZkMGVmZmZiLCAweGE3NzliNDkyLCAweGE5NzBiOTk5LCAweGJiNmJhZTg0LCAweGI1NjJhMzhmLCAweDlmNWQ4MGJlLCAweDkxNTQ4ZGI1LCAweDgzNGY5YWE4LCAweDhkNDY5N2EzXTtcbmNvbnN0IFUyID0gWzB4MDAwMDAwMDAsIDB4MGIwZTA5MGQsIDB4MTYxYzEyMWEsIDB4MWQxMjFiMTcsIDB4MmMzODI0MzQsIDB4MjczNjJkMzksIDB4M2EyNDM2MmUsIDB4MzEyYTNmMjMsIDB4NTg3MDQ4NjgsIDB4NTM3ZTQxNjUsIDB4NGU2YzVhNzIsIDB4NDU2MjUzN2YsIDB4NzQ0ODZjNWMsIDB4N2Y0NjY1NTEsIDB4NjI1NDdlNDYsIDB4Njk1YTc3NGIsIDB4YjBlMDkwZDAsIDB4YmJlZTk5ZGQsIDB4YTZmYzgyY2EsIDB4YWRmMjhiYzcsIDB4OWNkOGI0ZTQsIDB4OTdkNmJkZTksIDB4OGFjNGE2ZmUsIDB4ODFjYWFmZjMsIDB4ZTg5MGQ4YjgsIDB4ZTM5ZWQxYjUsIDB4ZmU4Y2NhYTIsIDB4ZjU4MmMzYWYsIDB4YzRhOGZjOGMsIDB4Y2ZhNmY1ODEsIDB4ZDJiNGVlOTYsIDB4ZDliYWU3OWIsIDB4N2JkYjNiYmIsIDB4NzBkNTMyYjYsIDB4NmRjNzI5YTEsIDB4NjZjOTIwYWMsIDB4NTdlMzFmOGYsIDB4NWNlZDE2ODIsIDB4NDFmZjBkOTUsIDB4NGFmMTA0OTgsIDB4MjNhYjczZDMsIDB4MjhhNTdhZGUsIDB4MzViNzYxYzksIDB4M2ViOTY4YzQsIDB4MGY5MzU3ZTcsIDB4MDQ5ZDVlZWEsIDB4MTk4ZjQ1ZmQsIDB4MTI4MTRjZjAsIDB4Y2IzYmFiNmIsIDB4YzAzNWEyNjYsIDB4ZGQyN2I5NzEsIDB4ZDYyOWIwN2MsIDB4ZTcwMzhmNWYsIDB4ZWMwZDg2NTIsIDB4ZjExZjlkNDUsIDB4ZmExMTk0NDgsIDB4OTM0YmUzMDMsIDB4OTg0NWVhMGUsIDB4ODU1N2YxMTksIDB4OGU1OWY4MTQsIDB4YmY3M2M3MzcsIDB4YjQ3ZGNlM2EsIDB4YTk2ZmQ1MmQsIDB4YTI2MWRjMjAsIDB4ZjZhZDc2NmQsIDB4ZmRhMzdmNjAsIDB4ZTBiMTY0NzcsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4ZDE5YjViNTQsIDB4Y2M4OTQwNDMsIDB4Yzc4NzQ5NGUsIDB4YWVkZDNlMDUsIDB4YTVkMzM3MDgsIDB4YjhjMTJjMWYsIDB4YjNjZjI1MTIsIDB4ODJlNTFhMzEsIDB4ODllYjEzM2MsIDB4OTRmOTA4MmIsIDB4OWZmNzAxMjYsIDB4NDY0ZGU2YmQsIDB4NGQ0M2VmYjAsIDB4NTA1MWY0YTcsIDB4NWI1ZmZkYWEsIDB4NmE3NWMyODksIDB4NjE3YmNiODQsIDB4N2M2OWQwOTMsIDB4Nzc2N2Q5OWUsIDB4MWUzZGFlZDUsIDB4MTUzM2E3ZDgsIDB4MDgyMWJjY2YsIDB4MDMyZmI1YzIsIDB4MzIwNThhZTEsIDB4MzkwYjgzZWMsIDB4MjQxOTk4ZmIsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4ODY3ODQ0ZGIsIDB4OWI2YTVmY2MsIDB4OTA2NDU2YzEsIDB4YTE0ZTY5ZTIsIDB4YWE0MDYwZWYsIDB4Yjc1MjdiZjgsIDB4YmM1YzcyZjUsIDB4ZDUwNjA1YmUsIDB4ZGUwODBjYjMsIDB4YzMxYTE3YTQsIDB4YzgxNDFlYTksIDB4ZjkzZTIxOGEsIDB4ZjIzMDI4ODcsIDB4ZWYyMjMzOTAsIDB4ZTQyYzNhOWQsIDB4M2Q5NmRkMDYsIDB4MzY5OGQ0MGIsIDB4MmI4YWNmMWMsIDB4MjA4NGM2MTEsIDB4MTFhZWY5MzIsIDB4MWFhMGYwM2YsIDB4MDdiMmViMjgsIDB4MGNiY2UyMjUsIDB4NjVlNjk1NmUsIDB4NmVlODljNjMsIDB4NzNmYTg3NzQsIDB4NzhmNDhlNzksIDB4NDlkZWIxNWEsIDB4NDJkMGI4NTcsIDB4NWZjMmEzNDAsIDB4NTRjY2FhNGQsIDB4Zjc0MWVjZGEsIDB4ZmM0ZmU1ZDcsIDB4ZTE1ZGZlYzAsIDB4ZWE1M2Y3Y2QsIDB4ZGI3OWM4ZWUsIDB4ZDA3N2MxZTMsIDB4Y2Q2NWRhZjQsIDB4YzY2YmQzZjksIDB4YWYzMWE0YjIsIDB4YTQzZmFkYmYsIDB4YjkyZGI2YTgsIDB4YjIyM2JmYTUsIDB4ODMwOTgwODYsIDB4ODgwNzg5OGIsIDB4OTUxNTkyOWMsIDB4OWUxYjliOTEsIDB4NDdhMTdjMGEsIDB4NGNhZjc1MDcsIDB4NTFiZDZlMTAsIDB4NWFiMzY3MWQsIDB4NmI5OTU4M2UsIDB4NjA5NzUxMzMsIDB4N2Q4NTRhMjQsIDB4NzY4YjQzMjksIDB4MWZkMTM0NjIsIDB4MTRkZjNkNmYsIDB4MDljZDI2NzgsIDB4MDJjMzJmNzUsIDB4MzNlOTEwNTYsIDB4MzhlNzE5NWIsIDB4MjVmNTAyNGMsIDB4MmVmYjBiNDEsIDB4OGM5YWQ3NjEsIDB4ODc5NGRlNmMsIDB4OWE4NmM1N2IsIDB4OTE4OGNjNzYsIDB4YTBhMmYzNTUsIDB4YWJhY2ZhNTgsIDB4YjZiZWUxNGYsIDB4YmRiMGU4NDIsIDB4ZDRlYTlmMDksIDB4ZGZlNDk2MDQsIDB4YzJmNjhkMTMsIDB4YzlmODg0MWUsIDB4ZjhkMmJiM2QsIDB4ZjNkY2IyMzAsIDB4ZWVjZWE5MjcsIDB4ZTVjMGEwMmEsIDB4M2M3YTQ3YjEsIDB4Mzc3NDRlYmMsIDB4MmE2NjU1YWIsIDB4MjE2ODVjYTYsIDB4MTA0MjYzODUsIDB4MWI0YzZhODgsIDB4MDY1ZTcxOWYsIDB4MGQ1MDc4OTIsIDB4NjQwYTBmZDksIDB4NmYwNDA2ZDQsIDB4NzIxNjFkYzMsIDB4NzkxODE0Y2UsIDB4NDgzMjJiZWQsIDB4NDMzYzIyZTAsIDB4NWUyZTM5ZjcsIDB4NTUyMDMwZmEsIDB4MDFlYzlhYjcsIDB4MGFlMjkzYmEsIDB4MTdmMDg4YWQsIDB4MWNmZTgxYTAsIDB4MmRkNGJlODMsIDB4MjZkYWI3OGUsIDB4M2JjOGFjOTksIDB4MzBjNmE1OTQsIDB4NTk5Y2QyZGYsIDB4NTI5MmRiZDIsIDB4NGY4MGMwYzUsIDB4NDQ4ZWM5YzgsIDB4NzVhNGY2ZWIsIDB4N2VhYWZmZTYsIDB4NjNiOGU0ZjEsIDB4NjhiNmVkZmMsIDB4YjEwYzBhNjcsIDB4YmEwMjAzNmEsIDB4YTcxMDE4N2QsIDB4YWMxZTExNzAsIDB4OWQzNDJlNTMsIDB4OTYzYTI3NWUsIDB4OGIyODNjNDksIDB4ODAyNjM1NDQsIDB4ZTk3YzQyMGYsIDB4ZTI3MjRiMDIsIDB4ZmY2MDUwMTUsIDB4ZjQ2ZTU5MTgsIDB4YzU0NDY2M2IsIDB4Y2U0YTZmMzYsIDB4ZDM1ODc0MjEsIDB4ZDg1NjdkMmMsIDB4N2EzN2ExMGMsIDB4NzEzOWE4MDEsIDB4NmMyYmIzMTYsIDB4NjcyNWJhMWIsIDB4NTYwZjg1MzgsIDB4NWQwMThjMzUsIDB4NDAxMzk3MjIsIDB4NGIxZDllMmYsIDB4MjI0N2U5NjQsIDB4Mjk0OWUwNjksIDB4MzQ1YmZiN2UsIDB4M2Y1NWYyNzMsIDB4MGU3ZmNkNTAsIDB4MDU3MWM0NWQsIDB4MTg2M2RmNGEsIDB4MTM2ZGQ2NDcsIDB4Y2FkNzMxZGMsIDB4YzFkOTM4ZDEsIDB4ZGNjYjIzYzYsIDB4ZDdjNTJhY2IsIDB4ZTZlZjE1ZTgsIDB4ZWRlMTFjZTUsIDB4ZjBmMzA3ZjIsIDB4ZmJmZDBlZmYsIDB4OTJhNzc5YjQsIDB4OTlhOTcwYjksIDB4ODRiYjZiYWUsIDB4OGZiNTYyYTMsIDB4YmU5ZjVkODAsIDB4YjU5MTU0OGQsIDB4YTg4MzRmOWEsIDB4YTM4ZDQ2OTddO1xuY29uc3QgVTMgPSBbMHgwMDAwMDAwMCwgMHgwZDBiMGUwOSwgMHgxYTE2MWMxMiwgMHgxNzFkMTIxYiwgMHgzNDJjMzgyNCwgMHgzOTI3MzYyZCwgMHgyZTNhMjQzNiwgMHgyMzMxMmEzZiwgMHg2ODU4NzA0OCwgMHg2NTUzN2U0MSwgMHg3MjRlNmM1YSwgMHg3ZjQ1NjI1MywgMHg1Yzc0NDg2YywgMHg1MTdmNDY2NSwgMHg0NjYyNTQ3ZSwgMHg0YjY5NWE3NywgMHhkMGIwZTA5MCwgMHhkZGJiZWU5OSwgMHhjYWE2ZmM4MiwgMHhjN2FkZjI4YiwgMHhlNDljZDhiNCwgMHhlOTk3ZDZiZCwgMHhmZThhYzRhNiwgMHhmMzgxY2FhZiwgMHhiOGU4OTBkOCwgMHhiNWUzOWVkMSwgMHhhMmZlOGNjYSwgMHhhZmY1ODJjMywgMHg4Y2M0YThmYywgMHg4MWNmYTZmNSwgMHg5NmQyYjRlZSwgMHg5YmQ5YmFlNywgMHhiYjdiZGIzYiwgMHhiNjcwZDUzMiwgMHhhMTZkYzcyOSwgMHhhYzY2YzkyMCwgMHg4ZjU3ZTMxZiwgMHg4MjVjZWQxNiwgMHg5NTQxZmYwZCwgMHg5ODRhZjEwNCwgMHhkMzIzYWI3MywgMHhkZTI4YTU3YSwgMHhjOTM1Yjc2MSwgMHhjNDNlYjk2OCwgMHhlNzBmOTM1NywgMHhlYTA0OWQ1ZSwgMHhmZDE5OGY0NSwgMHhmMDEyODE0YywgMHg2YmNiM2JhYiwgMHg2NmMwMzVhMiwgMHg3MWRkMjdiOSwgMHg3Y2Q2MjliMCwgMHg1ZmU3MDM4ZiwgMHg1MmVjMGQ4NiwgMHg0NWYxMWY5ZCwgMHg0OGZhMTE5NCwgMHgwMzkzNGJlMywgMHgwZTk4NDVlYSwgMHgxOTg1NTdmMSwgMHgxNDhlNTlmOCwgMHgzN2JmNzNjNywgMHgzYWI0N2RjZSwgMHgyZGE5NmZkNSwgMHgyMGEyNjFkYywgMHg2ZGY2YWQ3NiwgMHg2MGZkYTM3ZiwgMHg3N2UwYjE2NCwgMHg3YWViYmY2ZCwgMHg1OWRhOTU1MiwgMHg1NGQxOWI1YiwgMHg0M2NjODk0MCwgMHg0ZWM3ODc0OSwgMHgwNWFlZGQzZSwgMHgwOGE1ZDMzNywgMHgxZmI4YzEyYywgMHgxMmIzY2YyNSwgMHgzMTgyZTUxYSwgMHgzYzg5ZWIxMywgMHgyYjk0ZjkwOCwgMHgyNjlmZjcwMSwgMHhiZDQ2NGRlNiwgMHhiMDRkNDNlZiwgMHhhNzUwNTFmNCwgMHhhYTViNWZmZCwgMHg4OTZhNzVjMiwgMHg4NDYxN2JjYiwgMHg5MzdjNjlkMCwgMHg5ZTc3NjdkOSwgMHhkNTFlM2RhZSwgMHhkODE1MzNhNywgMHhjZjA4MjFiYywgMHhjMjAzMmZiNSwgMHhlMTMyMDU4YSwgMHhlYzM5MGI4MywgMHhmYjI0MTk5OCwgMHhmNjJmMTc5MSwgMHhkNjhkNzY0ZCwgMHhkYjg2Nzg0NCwgMHhjYzliNmE1ZiwgMHhjMTkwNjQ1NiwgMHhlMmExNGU2OSwgMHhlZmFhNDA2MCwgMHhmOGI3NTI3YiwgMHhmNWJjNWM3MiwgMHhiZWQ1MDYwNSwgMHhiM2RlMDgwYywgMHhhNGMzMWExNywgMHhhOWM4MTQxZSwgMHg4YWY5M2UyMSwgMHg4N2YyMzAyOCwgMHg5MGVmMjIzMywgMHg5ZGU0MmMzYSwgMHgwNjNkOTZkZCwgMHgwYjM2OThkNCwgMHgxYzJiOGFjZiwgMHgxMTIwODRjNiwgMHgzMjExYWVmOSwgMHgzZjFhYTBmMCwgMHgyODA3YjJlYiwgMHgyNTBjYmNlMiwgMHg2ZTY1ZTY5NSwgMHg2MzZlZTg5YywgMHg3NDczZmE4NywgMHg3OTc4ZjQ4ZSwgMHg1YTQ5ZGViMSwgMHg1NzQyZDBiOCwgMHg0MDVmYzJhMywgMHg0ZDU0Y2NhYSwgMHhkYWY3NDFlYywgMHhkN2ZjNGZlNSwgMHhjMGUxNWRmZSwgMHhjZGVhNTNmNywgMHhlZWRiNzljOCwgMHhlM2QwNzdjMSwgMHhmNGNkNjVkYSwgMHhmOWM2NmJkMywgMHhiMmFmMzFhNCwgMHhiZmE0M2ZhZCwgMHhhOGI5MmRiNiwgMHhhNWIyMjNiZiwgMHg4NjgzMDk4MCwgMHg4Yjg4MDc4OSwgMHg5Yzk1MTU5MiwgMHg5MTllMWI5YiwgMHgwYTQ3YTE3YywgMHgwNzRjYWY3NSwgMHgxMDUxYmQ2ZSwgMHgxZDVhYjM2NywgMHgzZTZiOTk1OCwgMHgzMzYwOTc1MSwgMHgyNDdkODU0YSwgMHgyOTc2OGI0MywgMHg2MjFmZDEzNCwgMHg2ZjE0ZGYzZCwgMHg3ODA5Y2QyNiwgMHg3NTAyYzMyZiwgMHg1NjMzZTkxMCwgMHg1YjM4ZTcxOSwgMHg0YzI1ZjUwMiwgMHg0MTJlZmIwYiwgMHg2MThjOWFkNywgMHg2Yzg3OTRkZSwgMHg3YjlhODZjNSwgMHg3NjkxODhjYywgMHg1NWEwYTJmMywgMHg1OGFiYWNmYSwgMHg0ZmI2YmVlMSwgMHg0MmJkYjBlOCwgMHgwOWQ0ZWE5ZiwgMHgwNGRmZTQ5NiwgMHgxM2MyZjY4ZCwgMHgxZWM5Zjg4NCwgMHgzZGY4ZDJiYiwgMHgzMGYzZGNiMiwgMHgyN2VlY2VhOSwgMHgyYWU1YzBhMCwgMHhiMTNjN2E0NywgMHhiYzM3NzQ0ZSwgMHhhYjJhNjY1NSwgMHhhNjIxNjg1YywgMHg4NTEwNDI2MywgMHg4ODFiNGM2YSwgMHg5ZjA2NWU3MSwgMHg5MjBkNTA3OCwgMHhkOTY0MGEwZiwgMHhkNDZmMDQwNiwgMHhjMzcyMTYxZCwgMHhjZTc5MTgxNCwgMHhlZDQ4MzIyYiwgMHhlMDQzM2MyMiwgMHhmNzVlMmUzOSwgMHhmYTU1MjAzMCwgMHhiNzAxZWM5YSwgMHhiYTBhZTI5MywgMHhhZDE3ZjA4OCwgMHhhMDFjZmU4MSwgMHg4MzJkZDRiZSwgMHg4ZTI2ZGFiNywgMHg5OTNiYzhhYywgMHg5NDMwYzZhNSwgMHhkZjU5OWNkMiwgMHhkMjUyOTJkYiwgMHhjNTRmODBjMCwgMHhjODQ0OGVjOSwgMHhlYjc1YTRmNiwgMHhlNjdlYWFmZiwgMHhmMTYzYjhlNCwgMHhmYzY4YjZlZCwgMHg2N2IxMGMwYSwgMHg2YWJhMDIwMywgMHg3ZGE3MTAxOCwgMHg3MGFjMWUxMSwgMHg1MzlkMzQyZSwgMHg1ZTk2M2EyNywgMHg0OThiMjgzYywgMHg0NDgwMjYzNSwgMHgwZmU5N2M0MiwgMHgwMmUyNzI0YiwgMHgxNWZmNjA1MCwgMHgxOGY0NmU1OSwgMHgzYmM1NDQ2NiwgMHgzNmNlNGE2ZiwgMHgyMWQzNTg3NCwgMHgyY2Q4NTY3ZCwgMHgwYzdhMzdhMSwgMHgwMTcxMzlhOCwgMHgxNjZjMmJiMywgMHgxYjY3MjViYSwgMHgzODU2MGY4NSwgMHgzNTVkMDE4YywgMHgyMjQwMTM5NywgMHgyZjRiMWQ5ZSwgMHg2NDIyNDdlOSwgMHg2OTI5NDllMCwgMHg3ZTM0NWJmYiwgMHg3MzNmNTVmMiwgMHg1MDBlN2ZjZCwgMHg1ZDA1NzFjNCwgMHg0YTE4NjNkZiwgMHg0NzEzNmRkNiwgMHhkY2NhZDczMSwgMHhkMWMxZDkzOCwgMHhjNmRjY2IyMywgMHhjYmQ3YzUyYSwgMHhlOGU2ZWYxNSwgMHhlNWVkZTExYywgMHhmMmYwZjMwNywgMHhmZmZiZmQwZSwgMHhiNDkyYTc3OSwgMHhiOTk5YTk3MCwgMHhhZTg0YmI2YiwgMHhhMzhmYjU2MiwgMHg4MGJlOWY1ZCwgMHg4ZGI1OTE1NCwgMHg5YWE4ODM0ZiwgMHg5N2EzOGQ0Nl07XG5jb25zdCBVNCA9IFsweDAwMDAwMDAwLCAweDA5MGQwYjBlLCAweDEyMWExNjFjLCAweDFiMTcxZDEyLCAweDI0MzQyYzM4LCAweDJkMzkyNzM2LCAweDM2MmUzYTI0LCAweDNmMjMzMTJhLCAweDQ4Njg1ODcwLCAweDQxNjU1MzdlLCAweDVhNzI0ZTZjLCAweDUzN2Y0NTYyLCAweDZjNWM3NDQ4LCAweDY1NTE3ZjQ2LCAweDdlNDY2MjU0LCAweDc3NGI2OTVhLCAweDkwZDBiMGUwLCAweDk5ZGRiYmVlLCAweDgyY2FhNmZjLCAweDhiYzdhZGYyLCAweGI0ZTQ5Y2Q4LCAweGJkZTk5N2Q2LCAweGE2ZmU4YWM0LCAweGFmZjM4MWNhLCAweGQ4YjhlODkwLCAweGQxYjVlMzllLCAweGNhYTJmZThjLCAweGMzYWZmNTgyLCAweGZjOGNjNGE4LCAweGY1ODFjZmE2LCAweGVlOTZkMmI0LCAweGU3OWJkOWJhLCAweDNiYmI3YmRiLCAweDMyYjY3MGQ1LCAweDI5YTE2ZGM3LCAweDIwYWM2NmM5LCAweDFmOGY1N2UzLCAweDE2ODI1Y2VkLCAweDBkOTU0MWZmLCAweDA0OTg0YWYxLCAweDczZDMyM2FiLCAweDdhZGUyOGE1LCAweDYxYzkzNWI3LCAweDY4YzQzZWI5LCAweDU3ZTcwZjkzLCAweDVlZWEwNDlkLCAweDQ1ZmQxOThmLCAweDRjZjAxMjgxLCAweGFiNmJjYjNiLCAweGEyNjZjMDM1LCAweGI5NzFkZDI3LCAweGIwN2NkNjI5LCAweDhmNWZlNzAzLCAweDg2NTJlYzBkLCAweDlkNDVmMTFmLCAweDk0NDhmYTExLCAweGUzMDM5MzRiLCAweGVhMGU5ODQ1LCAweGYxMTk4NTU3LCAweGY4MTQ4ZTU5LCAweGM3MzdiZjczLCAweGNlM2FiNDdkLCAweGQ1MmRhOTZmLCAweGRjMjBhMjYxLCAweDc2NmRmNmFkLCAweDdmNjBmZGEzLCAweDY0NzdlMGIxLCAweDZkN2FlYmJmLCAweDUyNTlkYTk1LCAweDViNTRkMTliLCAweDQwNDNjYzg5LCAweDQ5NGVjNzg3LCAweDNlMDVhZWRkLCAweDM3MDhhNWQzLCAweDJjMWZiOGMxLCAweDI1MTJiM2NmLCAweDFhMzE4MmU1LCAweDEzM2M4OWViLCAweDA4MmI5NGY5LCAweDAxMjY5ZmY3LCAweGU2YmQ0NjRkLCAweGVmYjA0ZDQzLCAweGY0YTc1MDUxLCAweGZkYWE1YjVmLCAweGMyODk2YTc1LCAweGNiODQ2MTdiLCAweGQwOTM3YzY5LCAweGQ5OWU3NzY3LCAweGFlZDUxZTNkLCAweGE3ZDgxNTMzLCAweGJjY2YwODIxLCAweGI1YzIwMzJmLCAweDhhZTEzMjA1LCAweDgzZWMzOTBiLCAweDk4ZmIyNDE5LCAweDkxZjYyZjE3LCAweDRkZDY4ZDc2LCAweDQ0ZGI4Njc4LCAweDVmY2M5YjZhLCAweDU2YzE5MDY0LCAweDY5ZTJhMTRlLCAweDYwZWZhYTQwLCAweDdiZjhiNzUyLCAweDcyZjViYzVjLCAweDA1YmVkNTA2LCAweDBjYjNkZTA4LCAweDE3YTRjMzFhLCAweDFlYTljODE0LCAweDIxOGFmOTNlLCAweDI4ODdmMjMwLCAweDMzOTBlZjIyLCAweDNhOWRlNDJjLCAweGRkMDYzZDk2LCAweGQ0MGIzNjk4LCAweGNmMWMyYjhhLCAweGM2MTEyMDg0LCAweGY5MzIxMWFlLCAweGYwM2YxYWEwLCAweGViMjgwN2IyLCAweGUyMjUwY2JjLCAweDk1NmU2NWU2LCAweDljNjM2ZWU4LCAweDg3NzQ3M2ZhLCAweDhlNzk3OGY0LCAweGIxNWE0OWRlLCAweGI4NTc0MmQwLCAweGEzNDA1ZmMyLCAweGFhNGQ1NGNjLCAweGVjZGFmNzQxLCAweGU1ZDdmYzRmLCAweGZlYzBlMTVkLCAweGY3Y2RlYTUzLCAweGM4ZWVkYjc5LCAweGMxZTNkMDc3LCAweGRhZjRjZDY1LCAweGQzZjljNjZiLCAweGE0YjJhZjMxLCAweGFkYmZhNDNmLCAweGI2YThiOTJkLCAweGJmYTViMjIzLCAweDgwODY4MzA5LCAweDg5OGI4ODA3LCAweDkyOWM5NTE1LCAweDliOTE5ZTFiLCAweDdjMGE0N2ExLCAweDc1MDc0Y2FmLCAweDZlMTA1MWJkLCAweDY3MWQ1YWIzLCAweDU4M2U2Yjk5LCAweDUxMzM2MDk3LCAweDRhMjQ3ZDg1LCAweDQzMjk3NjhiLCAweDM0NjIxZmQxLCAweDNkNmYxNGRmLCAweDI2NzgwOWNkLCAweDJmNzUwMmMzLCAweDEwNTYzM2U5LCAweDE5NWIzOGU3LCAweDAyNGMyNWY1LCAweDBiNDEyZWZiLCAweGQ3NjE4YzlhLCAweGRlNmM4Nzk0LCAweGM1N2I5YTg2LCAweGNjNzY5MTg4LCAweGYzNTVhMGEyLCAweGZhNThhYmFjLCAweGUxNGZiNmJlLCAweGU4NDJiZGIwLCAweDlmMDlkNGVhLCAweDk2MDRkZmU0LCAweDhkMTNjMmY2LCAweDg0MWVjOWY4LCAweGJiM2RmOGQyLCAweGIyMzBmM2RjLCAweGE5MjdlZWNlLCAweGEwMmFlNWMwLCAweDQ3YjEzYzdhLCAweDRlYmMzNzc0LCAweDU1YWIyYTY2LCAweDVjYTYyMTY4LCAweDYzODUxMDQyLCAweDZhODgxYjRjLCAweDcxOWYwNjVlLCAweDc4OTIwZDUwLCAweDBmZDk2NDBhLCAweDA2ZDQ2ZjA0LCAweDFkYzM3MjE2LCAweDE0Y2U3OTE4LCAweDJiZWQ0ODMyLCAweDIyZTA0MzNjLCAweDM5Zjc1ZTJlLCAweDMwZmE1NTIwLCAweDlhYjcwMWVjLCAweDkzYmEwYWUyLCAweDg4YWQxN2YwLCAweDgxYTAxY2ZlLCAweGJlODMyZGQ0LCAweGI3OGUyNmRhLCAweGFjOTkzYmM4LCAweGE1OTQzMGM2LCAweGQyZGY1OTljLCAweGRiZDI1MjkyLCAweGMwYzU0ZjgwLCAweGM5Yzg0NDhlLCAweGY2ZWI3NWE0LCAweGZmZTY3ZWFhLCAweGU0ZjE2M2I4LCAweGVkZmM2OGI2LCAweDBhNjdiMTBjLCAweDAzNmFiYTAyLCAweDE4N2RhNzEwLCAweDExNzBhYzFlLCAweDJlNTM5ZDM0LCAweDI3NWU5NjNhLCAweDNjNDk4YjI4LCAweDM1NDQ4MDI2LCAweDQyMGZlOTdjLCAweDRiMDJlMjcyLCAweDUwMTVmZjYwLCAweDU5MThmNDZlLCAweDY2M2JjNTQ0LCAweDZmMzZjZTRhLCAweDc0MjFkMzU4LCAweDdkMmNkODU2LCAweGExMGM3YTM3LCAweGE4MDE3MTM5LCAweGIzMTY2YzJiLCAweGJhMWI2NzI1LCAweDg1Mzg1NjBmLCAweDhjMzU1ZDAxLCAweDk3MjI0MDEzLCAweDllMmY0YjFkLCAweGU5NjQyMjQ3LCAweGUwNjkyOTQ5LCAweGZiN2UzNDViLCAweGYyNzMzZjU1LCAweGNkNTAwZTdmLCAweGM0NWQwNTcxLCAweGRmNGExODYzLCAweGQ2NDcxMzZkLCAweDMxZGNjYWQ3LCAweDM4ZDFjMWQ5LCAweDIzYzZkY2NiLCAweDJhY2JkN2M1LCAweDE1ZThlNmVmLCAweDFjZTVlZGUxLCAweDA3ZjJmMGYzLCAweDBlZmZmYmZkLCAweDc5YjQ5MmE3LCAweDcwYjk5OWE5LCAweDZiYWU4NGJiLCAweDYyYTM4ZmI1LCAweDVkODBiZTlmLCAweDU0OGRiNTkxLCAweDRmOWFhODgzLCAweDQ2OTdhMzhkXTtcbmZ1bmN0aW9uIGNvbnZlcnRUb0ludDMyKGJ5dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByZXN1bHQucHVzaCgoYnl0ZXNbaV0gPDwgMjQpIHwgKGJ5dGVzW2kgKyAxXSA8PCAxNikgfCAoYnl0ZXNbaSArIDJdIDw8IDgpIHwgYnl0ZXNbaSArIDNdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjbGFzcyBBRVMge1xuICAgIGdldCBrZXkoKSB7IHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfa2V5LCBcImZcIikuc2xpY2UoKTsgfVxuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICBfQUVTX2tleS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0FFU19LZC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0FFU19LZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFFUykpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19rZXksIG5ldyBVaW50OEFycmF5KGtleSksIFwiZlwiKTtcbiAgICAgICAgY29uc3Qgcm91bmRzID0gbnVtYmVyT2ZSb3VuZHNbdGhpcy5rZXkubGVuZ3RoXTtcbiAgICAgICAgaWYgKHJvdW5kcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGtleSBzaXplIChtdXN0IGJlIDE2LCAyNCBvciAzMiBieXRlcyknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbmNyeXB0aW9uIHJvdW5kIGtleXNcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQUVTX0tlLCBbXSwgXCJmXCIpO1xuICAgICAgICAvLyBkZWNyeXB0aW9uIHJvdW5kIGtleXNcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQUVTX0tkLCBbXSwgXCJmXCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSByb3VuZHM7IGkrKykge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIikucHVzaChbMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIikucHVzaChbMCwgMCwgMCwgMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdW5kS2V5Q291bnQgPSAocm91bmRzICsgMSkgKiA0O1xuICAgICAgICBjb25zdCBLQyA9IHRoaXMua2V5Lmxlbmd0aCAvIDQ7XG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIGtleSBpbnRvIGludHNcbiAgICAgICAgY29uc3QgdGsgPSBjb252ZXJ0VG9JbnQzMih0aGlzLmtleSk7XG4gICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xuICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgS0M7IGkrKykge1xuICAgICAgICAgICAgaW5kZXggPSBpID4+IDI7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtpbmRleF1baSAlIDRdID0gdGtbaV07XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKVtyb3VuZHMgLSBpbmRleF1baSAlIDRdID0gdGtbaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiAoZmlwcy0xOTcgc2VjdGlvbiA1LjIpXG4gICAgICAgIGxldCByY29ucG9pbnRlciA9IDA7XG4gICAgICAgIGxldCB0ID0gS0MsIHR0O1xuICAgICAgICB3aGlsZSAodCA8IHJvdW5kS2V5Q291bnQpIHtcbiAgICAgICAgICAgIHR0ID0gdGtbS0MgLSAxXTtcbiAgICAgICAgICAgIHRrWzBdIF49ICgoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMjQpIF5cbiAgICAgICAgICAgICAgICAoU1sodHQgPj4gOCkgJiAweEZGXSA8PCAxNikgXlxuICAgICAgICAgICAgICAgIChTW3R0ICYgMHhGRl0gPDwgOCkgXlxuICAgICAgICAgICAgICAgIFNbKHR0ID4+IDI0KSAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAocmNvbltyY29ucG9pbnRlcl0gPDwgMjQpKTtcbiAgICAgICAgICAgIHJjb25wb2ludGVyICs9IDE7XG4gICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIChmb3Igbm9uLTI1NiBiaXQpXG4gICAgICAgICAgICBpZiAoS0MgIT0gOCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgS0M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGtleSBleHBhbnNpb24gZm9yIDI1Ni1iaXQga2V5cyBpcyBcInNsaWdodGx5IGRpZmZlcmVudFwiIChmaXBzLTE5NylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgKEtDIC8gMik7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR0ID0gdGtbKEtDIC8gMikgLSAxXTtcbiAgICAgICAgICAgICAgICB0a1tLQyAvIDJdIF49IChTW3R0ICYgMHhGRl0gXlxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gOCkgJiAweEZGXSA8PCA4KSBeXG4gICAgICAgICAgICAgICAgICAgIChTWyh0dCA+PiAxNikgJiAweEZGXSA8PCAxNikgXlxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMjQpICYgMHhGRl0gPDwgMjQpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gKEtDIC8gMikgKyAxOyBpIDwgS0M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29weSB2YWx1ZXMgaW50byByb3VuZCBrZXkgYXJyYXlzXG4gICAgICAgICAgICBsZXQgaSA9IDAsIHIsIGM7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IEtDICYmIHQgPCByb3VuZEtleUNvdW50KSB7XG4gICAgICAgICAgICAgICAgciA9IHQgPj4gMjtcbiAgICAgICAgICAgICAgICBjID0gdCAlIDQ7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbcl1bY10gPSB0a1tpXTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKVtyb3VuZHMgLSByXVtjXSA9IHRrW2krK107XG4gICAgICAgICAgICAgICAgdCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGludmVyc2UtY2lwaGVyLWlmeSB0aGUgZGVjcnlwdGlvbiByb3VuZCBrZXkgKGZpcHMtMTk3IHNlY3Rpb24gNS4zKVxuICAgICAgICBmb3IgKGxldCByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IDQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHR0ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcl1bY107XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcl1bY10gPSAoVTFbKHR0ID4+IDI0KSAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgVTJbKHR0ID4+IDE2KSAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgVTNbKHR0ID4+IDgpICYgMHhGRl0gXlxuICAgICAgICAgICAgICAgICAgICBVNFt0dCAmIDB4RkZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAhPSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSAxNiBieXRlcyknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3VuZHMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKS5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBhID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAvLyBjb252ZXJ0IHBsYWludGV4dCB0byAoaW50cyBeIGtleSlcbiAgICAgICAgbGV0IHQgPSBjb252ZXJ0VG9JbnQzMihwbGFpbnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVswXVtpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG4gICAgICAgIGZvciAobGV0IHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IChUMVsodFtpXSA+PiAyNCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQyWyh0WyhpICsgMSkgJSA0XSA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQzWyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgVDRbdFsoaSArIDMpICUgNF0gJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpW3JdW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSBhLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGxhc3Qgcm91bmQgaXMgc3BlY2lhbFxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGxldCB0dCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpW3JvdW5kc11baV07XG4gICAgICAgICAgICByZXN1bHRbNCAqIGldID0gKFNbKHRbaV0gPj4gMjQpICYgMHhmZl0gXiAodHQgPj4gMjQpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAxXSA9IChTWyh0WyhpICsgMSkgJSA0XSA+PiAxNikgJiAweGZmXSBeICh0dCA+PiAxNikpICYgMHhmZjtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDJdID0gKFNbKHRbKGkgKyAyKSAlIDRdID4+IDgpICYgMHhmZl0gXiAodHQgPj4gOCkpICYgMHhmZjtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDNdID0gKFNbdFsoaSArIDMpICUgNF0gJiAweGZmXSBeIHR0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAhPSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91bmRzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIikubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgYSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXG4gICAgICAgIGxldCB0ID0gY29udmVydFRvSW50MzIoY2lwaGVydGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB0W2ldIF49IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpWzBdW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGx5IHJvdW5kIHRyYW5zZm9ybXNcbiAgICAgICAgZm9yIChsZXQgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gKFQ1Wyh0W2ldID4+IDI0KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgVDZbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgVDdbKHRbKGkgKyAyKSAlIDRdID4+IDgpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUOFt0WyhpICsgMSkgJSA0XSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcl1baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9IGEuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgbGFzdCByb3VuZCBpcyBzcGVjaWFsXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgbGV0IHR0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHR0ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzXVtpXTtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaV0gPSAoU2lbKHRbaV0gPj4gMjQpICYgMHhmZl0gXiAodHQgPj4gMjQpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAxXSA9IChTaVsodFsoaSArIDMpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAyXSA9IChTaVsodFsoaSArIDIpICUgNF0gPj4gOCkgJiAweGZmXSBeICh0dCA+PiA4KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgM10gPSAoU2lbdFsoaSArIDEpICUgNF0gJiAweGZmXSBeIHR0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5fQUVTX2tleSA9IG5ldyBXZWFrTWFwKCksIF9BRVNfS2QgPSBuZXcgV2Vha01hcCgpLCBfQUVTX0tlID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFlcy5qcy5tYXAiLCJpbXBvcnQgeyBBRVMgfSBmcm9tIFwiLi9hZXMuanNcIjtcbmV4cG9ydCBjbGFzcyBNb2RlT2ZPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGtleSwgY2xzKSB7XG4gICAgICAgIGlmIChjbHMgJiYgISh0aGlzIGluc3RhbmNlb2YgY2xzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IG11c3QgYmUgaW5zdGFudGlhdGVkIHdpdGggXCJuZXdcImApO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGFlczogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogbmV3IEFFUyhrZXkpIH0sXG4gICAgICAgICAgICBuYW1lOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBuYW1lIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS5qcy5tYXAiLCIvLyBDaXBoZXIgQmxvY2sgQ2hhaW5pbmdcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQ0JDX2l2LCBfQ0JDX2xhc3RCbG9jaztcbmltcG9ydCB7IE1vZGVPZk9wZXJhdGlvbiB9IGZyb20gXCIuL21vZGUuanNcIjtcbmV4cG9ydCBjbGFzcyBDQkMgZXh0ZW5kcyBNb2RlT2ZPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgaXYpIHtcbiAgICAgICAgc3VwZXIoXCJFQ0NcIiwga2V5LCBDQkMpO1xuICAgICAgICBfQ0JDX2l2LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ0JDX2xhc3RCbG9jay5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgaWYgKGl2KSB7XG4gICAgICAgICAgICBpZiAoaXYubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBpdiBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19pdiwgbmV3IFVpbnQ4QXJyYXkoaXYpLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DQkNfaXYsIG5ldyBVaW50OEFycmF5KDE2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIHRoaXMuaXYsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGl2KCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2l2LCBcImZcIikpOyB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFpbnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIilbal0gXj0gcGxhaW50ZXh0W2kgKyBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpKSwgXCJmXCIpO1xuICAgICAgICAgICAgY2lwaGVydGV4dC5zZXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaXBoZXJ0ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmFlcy5kZWNyeXB0KGNpcGhlcnRleHQuc3ViYXJyYXkoaSwgaSArIDE2KSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAgICAgICBwbGFpbnRleHRbaSArIGpdID0gYmxvY2tbal0gXiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIilbal07XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpW2pdID0gY2lwaGVydGV4dFtpICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9XG59XG5fQ0JDX2l2ID0gbmV3IFdlYWtNYXAoKSwgX0NCQ19sYXN0QmxvY2sgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS1jYmMuanMubWFwIiwiLy8gQ291bnRlciBNb2RlXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0NUUl9yZW1haW5pbmcsIF9DVFJfcmVtYWluaW5nSW5kZXgsIF9DVFJfY291bnRlcjtcbmltcG9ydCB7IE1vZGVPZk9wZXJhdGlvbiB9IGZyb20gXCIuL21vZGUuanNcIjtcbmV4cG9ydCBjbGFzcyBDVFIgZXh0ZW5kcyBNb2RlT2ZPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIHN1cGVyKFwiQ1RSXCIsIGtleSwgQ1RSKTtcbiAgICAgICAgLy8gUmVtYWluaW5nIGJ5dGVzIGZvciB0aGUgb25lLXRpbWUgcGFkXG4gICAgICAgIF9DVFJfcmVtYWluaW5nLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ1RSX3JlbWFpbmluZ0luZGV4LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvLyBUaGUgY3VycmVudCBjb3VudGVyXG4gICAgICAgIF9DVFJfY291bnRlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIG5ldyBVaW50OEFycmF5KDE2KSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpLmZpbGwoMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmcsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIiksIFwiZlwiKTsgLy8gVGhpcyB3aWxsIGJlIGRpc2NhcmRlZCBpbW1lZGlhdGVseVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIDE2LCBcImZcIik7XG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChpbml0aWFsVmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvdW50ZXJWYWx1ZShpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRDb3VudGVyQnl0ZXMoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY291bnRlcigpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikpOyB9XG4gICAgc2V0Q291bnRlclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNvdW50ZXIgaW5pdGlhbCBpbnRlZ2VyIHZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTU7IGluZGV4ID49IDA7IC0taW5kZXgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaW5kZXhdID0gdmFsdWUgJSAyNTY7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyAyNTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENvdW50ZXJCeXRlcyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY291bnRlciBpbml0aWFsIFVpbnQ4QXJyYXkgdmFsdWUgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikuc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgaW5jcmVtZW50KCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMTU7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpXSA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2ldKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY3J5cHR0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcnlwdHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIFwiZlwiKSA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nLCB0aGlzLmFlcy5lbmNyeXB0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikpLCBcImZcIik7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCAwLCBcImZcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyeXB0dGV4dFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nLCBcImZcIilbX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZ0luZGV4LCAoX2IgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIFwiZlwiKSwgX2EgPSBfYisrLCBfYiksIFwiZlwiKSwgX2FdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcnlwdHRleHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0KGNpcGhlcnRleHQpO1xuICAgIH1cbn1cbl9DVFJfcmVtYWluaW5nID0gbmV3IFdlYWtNYXAoKSwgX0NUUl9yZW1haW5pbmdJbmRleCA9IG5ldyBXZWFrTWFwKCksIF9DVFJfY291bnRlciA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWN0ci5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gcGtjczdQYWQoZGF0YSkge1xuICAgIGNvbnN0IHBhZGRlciA9IDE2IC0gKGRhdGEubGVuZ3RoICUgMTYpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgcGFkZGVyKTtcbiAgICByZXN1bHQuc2V0KGRhdGEpO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBwYWRkZXI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcGtjczdTdHJpcChkYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUEtDUyM3IGludmFsaWQgbGVuZ3RoJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhZGRlciA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgICBpZiAocGFkZGVyID4gMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUEtDUyM3IHBhZGRpbmcgYnl0ZSBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBwYWRkZXI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZXI7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtsZW5ndGggKyBpXSAhPT0gcGFkZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQS0NTIzcgaW52YWxpZCBwYWRkaW5nIGJ5dGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YS5zdWJhcnJheSgwLCBsZW5ndGgpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZGRpbmcuanMubWFwIiwiLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXNDb3B5LCBhc3NlcnRBcmd1bWVudCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBsb29zZUFycmF5aWZ5KGhleFN0cmluZykge1xuICAgIGlmICh0eXBlb2YgKGhleFN0cmluZykgPT09IFwic3RyaW5nXCIgJiYgIWhleFN0cmluZy5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgaGV4U3RyaW5nID0gXCIweFwiICsgaGV4U3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXNDb3B5KGhleFN0cmluZyk7XG59XG5leHBvcnQgZnVuY3Rpb24genBhZCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAnMCcgKyB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgaWYgKHR5cGVvZiAocGFzc3dvcmQpID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFwiTkZLQ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJ5dGVzQ29weShwYXNzd29yZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BlbHVuayhvYmplY3QsIF9wYXRoKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBfcGF0aC5tYXRjaCgvXihbYS16MC05JF8uLV0qKSg6KFthLXpdKykpPyghKT8kL2kpO1xuICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoICE9IG51bGwsIFwiaW52YWxpZCBwYXRoXCIsIFwicGF0aFwiLCBfcGF0aCk7XG4gICAgY29uc3QgcGF0aCA9IG1hdGNoWzFdO1xuICAgIGNvbnN0IHR5cGUgPSBtYXRjaFszXTtcbiAgICBjb25zdCByZXFkID0gKG1hdGNoWzRdID09PSBcIiFcIik7XG4gICAgbGV0IGN1ciA9IG9iamVjdDtcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgcGF0aC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcuJykpIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VyKSkge1xuICAgICAgICAgICAgaWYgKCFjb21wLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBjdXJbcGFyc2VJbnQoY29tcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cikge1xuICAgICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gY29tcCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGN1cltrZXldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1ciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ciA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudCghcmVxZCB8fCBjdXIgIT0gbnVsbCwgXCJtaXNzaW5nIHJlcXVpcmVkIHZhbHVlXCIsIFwicGF0aFwiLCBwYXRoKTtcbiAgICBpZiAodHlwZSAmJiBjdXIgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJpbnRcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJzdHJpbmdcIiAmJiBjdXIubWF0Y2goL14tP1swLTldKyQvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIoY3VyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cikgPT09IFwic3RyaW5nXCIgJiYgY3VyLm1hdGNoKC9eLT9bMC05Ll0qJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9vc2VBcnJheWlmeShjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShjdXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSB0eXBlb2YgKGN1cikpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGB3cm9uZyB0eXBlIGZvdW5kIGZvciAke3R5cGV9IGAsIFwicGF0aFwiLCBwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cjtcbn1cbi8qXG5leHBvcnQgZnVuY3Rpb24gZm9sbG93KG9iamVjdDogYW55LCBwYXRoOiBzdHJpbmcpOiBudWxsIHwgc3RyaW5nIHtcbiAgICBsZXQgY3VycmVudENoaWxkID0gb2JqZWN0O1xuXG4gICAgZm9yIChjb25zdCBjb21wIG9mIHBhdGgudG9Mb3dlckNhc2UoKS5zcGxpdCgnLycpKSB7XG5cbiAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcbiAgICAgICAgbGV0IG1hdGNoaW5nQ2hpbGQgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXJyZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGNvbXApIHtcbiAgICAgICAgICAgICAgICAgbWF0Y2hpbmdDaGlsZCA9IGN1cnJlbnRDaGlsZFtrZXldO1xuICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hpbmdDaGlsZCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIGN1cnJlbnRDaGlsZCA9IG1hdGNoaW5nQ2hpbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRDaGlsZDtcbn1cblxuLy8gXCJwYXRoL3RvL3NvbWV0aGluZzp0eXBlIVwiXG5leHBvcnQgZnVuY3Rpb24gZm9sbG93UmVxdWlyZWQoZGF0YTogYW55LCBwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZhbHVlID0gZm9sbG93KGRhdGEsIHBhdGgpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7IHJldHVybiB2YWx1ZTsgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB2YWx1ZVwiLCBgZGF0YTokeyBwYXRoIH1gLFxuICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbn1cbiovXG4vLyBTZWU6IGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmM0MTIyLnR4dCAoU2VjdGlvbiA0LjQpXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHV1aWRWNChyYW5kb21CeXRlczogQnl0ZXNMaWtlKTogc3RyaW5nIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHJhbmRvbUJ5dGVzLCBcInJhbmRvbUJ5dGVzXCIpO1xuXG4gICAgLy8gU2VjdGlvbjogNC4xLjM6XG4gICAgLy8gLSB0aW1lX2hpX2FuZF92ZXJzaW9uWzEyOjE2XSA9IDBiMDEwMFxuICAgIGJ5dGVzWzZdID0gKGJ5dGVzWzZdICYgMHgwZikgfCAweDQwO1xuXG4gICAgLy8gU2VjdGlvbiA0LjRcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbNl0gPSAwYjBcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbN10gPSAwYjFcbiAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAgIGNvbnN0IHZhbHVlID0gaGV4bGlmeShieXRlcyk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgIHZhbHVlLnN1YnN0cmluZygyLCAxMCksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDEwLCAxNCksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDE0LCAxOCksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDE4LCAyMiksXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDIyLCAzNCksXG4gICAgXS5qb2luKFwiLVwiKTtcbn1cbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCIvKipcbiAqICBUaGUgSlNPTiBXYWxsZXQgZm9ybWF0cyBhbGxvdyBhIHNpbXBsZSB3YXkgdG8gc3RvcmUgdGhlIHByaXZhdGVcbiAqICBrZXlzIG5lZWRlZCBpbiBFdGhlcmV1bSBhbG9uZyB3aXRoIHJlbGF0ZWQgaW5mb3JtYXRpb24gYW5kIGFsbG93c1xuICogIGZvciBleHRlbnNpYmxlIGZvcm1zIG9mIGVuY3J5cHRpb24uXG4gKlxuICogIFRoZXNlIHV0aWxpdGllcyBmYWNpbGl0YXRlIGRlY3J5cHRpbmcgYW5kIGVuY3J5cHRpbmcgdGhlIG1vc3QgY29tbW9uXG4gKiAgSlNPTiBXYWxsZXQgZm9ybWF0cy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvd2FsbGV0OkpTT04gV2FsbGV0cyAgW2pzb24td2FsbGV0c11cbiAqL1xuaW1wb3J0IHsgQ1RSIH0gZnJvbSBcImFlcy1qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIHBia2RmMiwgcmFuZG9tQnl0ZXMsIHNjcnlwdCwgc2NyeXB0U3luYyB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbXB1dGVBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGdldEJ5dGVzLCBoZXhsaWZ5LCB1dWlkVjQsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldFBhc3N3b3JkLCBzcGVsdW5rLCB6cGFkIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb24uanNcIjtcbmNvbnN0IGRlZmF1bHRQYXRoID0gXCJtLzQ0Jy82MCcvMCcvMC8wXCI7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSVqc29uJSUgaXMgYSB2YWxpZCBKU09OIEtleXN0b3JlIFdhbGxldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzS2V5c3RvcmVKc29uKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICgoZGF0YS52ZXJzaW9uICE9IG51bGwpID8gcGFyc2VJbnQoZGF0YS52ZXJzaW9uKSA6IDApO1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZWNyeXB0KGRhdGEsIGtleSwgY2lwaGVydGV4dCkge1xuICAgIGNvbnN0IGNpcGhlciA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8uY2lwaGVyOnN0cmluZ1wiKTtcbiAgICBpZiAoY2lwaGVyID09PSBcImFlcy0xMjgtY3RyXCIpIHtcbiAgICAgICAgY29uc3QgaXYgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmNpcGhlcnBhcmFtcy5pdjpkYXRhIVwiKTtcbiAgICAgICAgY29uc3QgYWVzQ3RyID0gbmV3IENUUihrZXksIGl2KTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYWVzQ3RyLmRlY3J5cHQoY2lwaGVydGV4dCkpO1xuICAgIH1cbiAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgY2lwaGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcImRlY3J5cHRcIlxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0QWNjb3VudChkYXRhLCBfa2V5KSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0Qnl0ZXMoX2tleSk7XG4gICAgY29uc3QgY2lwaGVydGV4dCA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8uY2lwaGVydGV4dDpkYXRhIVwiKTtcbiAgICBjb25zdCBjb21wdXRlZE1BQyA9IGhleGxpZnkoa2VjY2FrMjU2KGNvbmNhdChba2V5LnNsaWNlKDE2LCAzMiksIGNpcGhlcnRleHRdKSkpLnN1YnN0cmluZygyKTtcbiAgICBhc3NlcnRBcmd1bWVudChjb21wdXRlZE1BQyA9PT0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5tYWM6c3RyaW5nIVwiKS50b0xvd2VyQ2FzZSgpLCBcImluY29ycmVjdCBwYXNzd29yZFwiLCBcInBhc3N3b3JkXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBkZWNyeXB0KGRhdGEsIGtleS5zbGljZSgwLCAxNiksIGNpcGhlcnRleHQpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcyhwcml2YXRlS2V5KTtcbiAgICBpZiAoZGF0YS5hZGRyZXNzKSB7XG4gICAgICAgIGxldCBjaGVjayA9IGRhdGEuYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIWNoZWNrLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAgY2hlY2sgPSBcIjB4XCIgKyBjaGVjaztcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChnZXRBZGRyZXNzKGNoZWNrKSA9PT0gYWRkcmVzcywgXCJrZXlzdG9yZSBhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIiwgXCJhZGRyZXNzXCIsIGRhdGEuYWRkcmVzcyk7XG4gICAgfVxuICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3MsIHByaXZhdGVLZXkgfTtcbiAgICAvLyBWZXJzaW9uIDAuMSB4LWV0aGVycyBtZXRhZGF0YSBtdXN0IGNvbnRhaW4gYW4gZW5jcnlwdGVkIG1uZW1vbmljIHBocmFzZVxuICAgIGNvbnN0IHZlcnNpb24gPSBzcGVsdW5rKGRhdGEsIFwieC1ldGhlcnMudmVyc2lvbjpzdHJpbmdcIik7XG4gICAgaWYgKHZlcnNpb24gPT09IFwiMC4xXCIpIHtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNDaXBoZXJ0ZXh0ID0gc3BlbHVuayhkYXRhLCBcIngtZXRoZXJzLm1uZW1vbmljQ2lwaGVydGV4dDpkYXRhIVwiKTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNJdiA9IHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy5tbmVtb25pY0NvdW50ZXI6ZGF0YSFcIik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQWVzQ3RyID0gbmV3IENUUihtbmVtb25pY0tleSwgbW5lbW9uaWNJdik7XG4gICAgICAgIGFjY291bnQubW5lbW9uaWMgPSB7XG4gICAgICAgICAgICBwYXRoOiAoc3BlbHVuayhkYXRhLCBcIngtZXRoZXJzLnBhdGg6c3RyaW5nXCIpIHx8IGRlZmF1bHRQYXRoKSxcbiAgICAgICAgICAgIGxvY2FsZTogKHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy5sb2NhbGU6c3RyaW5nXCIpIHx8IFwiZW5cIiksXG4gICAgICAgICAgICBlbnRyb3B5OiBoZXhsaWZ5KGdldEJ5dGVzKG1uZW1vbmljQWVzQ3RyLmRlY3J5cHQobW5lbW9uaWNDaXBoZXJ0ZXh0KSkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50O1xufVxuZnVuY3Rpb24gZ2V0RGVjcnlwdEtkZlBhcmFtcyhkYXRhKSB7XG4gICAgY29uc3Qga2RmID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGY6c3RyaW5nXCIpO1xuICAgIGlmIChrZGYgJiYgdHlwZW9mIChrZGYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChrZGYudG9Mb3dlckNhc2UoKSA9PT0gXCJzY3J5cHRcIikge1xuICAgICAgICAgICAgY29uc3Qgc2FsdCA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnNhbHQ6ZGF0YSFcIik7XG4gICAgICAgICAgICBjb25zdCBOID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMubjppbnQhXCIpO1xuICAgICAgICAgICAgY29uc3QgciA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnI6aW50IVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5wOmludCFcIik7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgTiBpcyBhIHBvd2VyIG9mIDJcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE4gPiAwICYmIChOICYgKE4gLSAxKSkgPT09IDAsIFwiaW52YWxpZCBrZGYuTlwiLCBcImtkZi5OXCIsIE4pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQociA+IDAgJiYgcCA+IDAsIFwiaW52YWxpZCBrZGZcIiwgXCJrZGZcIiwga2RmKTtcbiAgICAgICAgICAgIGNvbnN0IGRrTGVuID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuZGtsZW46aW50IVwiKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGRrTGVuID09PSAzMiwgXCJpbnZhbGlkIGtkZi5ka2xlblwiLCBcImtkZi5kZmxlblwiLCBka0xlbik7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBcInNjcnlwdFwiLCBzYWx0LCBOLCByLCBwLCBka0xlbjogNjQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZGYudG9Mb3dlckNhc2UoKSA9PT0gXCJwYmtkZjJcIikge1xuICAgICAgICAgICAgY29uc3Qgc2FsdCA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnNhbHQ6ZGF0YSFcIik7XG4gICAgICAgICAgICBjb25zdCBwcmYgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5wcmY6c3RyaW5nIVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGFsZ29yaXRobSA9IHByZi5zcGxpdChcIi1cIikucG9wKCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhbGdvcml0aG0gPT09IFwic2hhMjU2XCIgfHwgYWxnb3JpdGhtID09PSBcInNoYTUxMlwiLCBcImludmFsaWQga2RmLnBkZlwiLCBcImtkZi5wZGZcIiwgcHJmKTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuYzppbnQhXCIpO1xuICAgICAgICAgICAgY29uc3QgZGtMZW4gPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5ka2xlbjppbnQhXCIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGtMZW4gPT09IDMyLCBcImludmFsaWQga2RmLmRrbGVuXCIsIFwia2RmLmRrbGVuXCIsIGRrTGVuKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwicGJrZGYyXCIsIHNhbHQsIGNvdW50LCBka0xlbiwgYWxnb3JpdGhtIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQga2V5LWRlcml2YXRpb24gZnVuY3Rpb25cIiwgXCJrZGZcIiwga2RmKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIGFjY291bnQgZGV0YWlscyBmb3IgdGhlIEpTT04gS2V5c3RvcmUgV2FsbGV0ICUlanNvbiUlXG4gKiAgdXNpbmcgJSVwYXNzd29yZCUlLlxuICpcbiAqICBJdCBpcyBwcmVmZXJyZWQgdG8gdXNlIHRoZSBbYXN5bmMgdmVyc2lvbl0oZGVjcnlwdEtleXN0b3JlSnNvbilcbiAqICBpbnN0ZWFkLCB3aGljaCBhbGxvd3MgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byBrZWVwIHRoZSB1c2VyIGluZm9ybWVkXG4gKiAgYXMgdG8gdGhlIGRlY3J5cHRpb24gc3RhdHVzLlxuICpcbiAqICBUaGlzIG1ldGhvZCB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIChmcmVlemluZyBhbGwgVUkpIHVudGlsIGRlY3J5cHRpb25cbiAqICBpcyBjb21wbGV0ZSwgd2hpY2ggY2FuIHRha2UgcXVpdGUgc29tZSB0aW1lLCBkZXBlbmRpbmcgb24gdGhlIHdhbGxldFxuICogIHBhcmFtdGVycyBhbmQgcGxhdGZvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNyeXB0S2V5c3RvcmVKc29uU3luYyhqc29uLCBfcGFzc3dvcmQpIHtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICBjb25zdCBwYXNzd29yZCA9IGdldFBhc3N3b3JkKF9wYXNzd29yZCk7XG4gICAgY29uc3QgcGFyYW1zID0gZ2V0RGVjcnlwdEtkZlBhcmFtcyhkYXRhKTtcbiAgICBpZiAocGFyYW1zLm5hbWUgPT09IFwicGJrZGYyXCIpIHtcbiAgICAgICAgY29uc3QgeyBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBrZXkgPSBwYmtkZjIocGFzc3dvcmQsIHNhbHQsIGNvdW50LCBka0xlbiwgYWxnb3JpdGhtKTtcbiAgICAgICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcbiAgICB9XG4gICAgYXNzZXJ0KHBhcmFtcy5uYW1lID09PSBcInNjcnlwdFwiLCBcImNhbm5vdCBiZSByZWFjaGVkXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IHBhcmFtcyB9KTtcbiAgICBjb25zdCB7IHNhbHQsIE4sIHIsIHAsIGRrTGVuIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qga2V5ID0gc2NyeXB0U3luYyhwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pO1xuICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XG59XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4geyBzZXRUaW1lb3V0KCgpID0+IHsgcmVzb2x2ZSgpOyB9LCBkdXJhdGlvbik7IH0pO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gdGhlIGRlY3J5cHRlZCBKU09OIEtleXN0b3JlIFdhbGxldCAlJWpzb24lJSB1c2luZyB0aGVcbiAqICAlJXBhc3N3b3JkJSUuXG4gKlxuICogIElmIHByb3ZpZGVkLCAlJXByb2dyZXNzJSUgd2lsbCBiZSBjYWxsZWQgcGVyaW9kaWNhbGx5IGR1cmluZyB0aGVcbiAqICBkZWNycHl0aW9uIHRvIHByb3ZpZGUgZmVlZGJhY2ssIGFuZCBpZiB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICogIGBgZmFsc2VgYCB3aWxsIGhhbHQgZGVjcnlwdGlvbi5cbiAqXG4gKiAgVGhlICUlcHJvZ3Jlc3NDYWxsYmFjayUlIHdpbGwgKiphbHdheXMqKiByZWNlaXZlIGBgMGBgIGJlZm9yZVxuICogIGRlY3J5cHRpb24gYmVnaW5zIGFuZCBgYDFgYCB3aGVuIGNvbXBsZXRlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjcnlwdEtleXN0b3JlSnNvbihqc29uLCBfcGFzc3dvcmQsIHByb2dyZXNzKSB7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgY29uc3QgcGFzc3dvcmQgPSBnZXRQYXNzd29yZChfcGFzc3dvcmQpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGdldERlY3J5cHRLZGZQYXJhbXMoZGF0YSk7XG4gICAgaWYgKHBhcmFtcy5uYW1lID09PSBcInBia2RmMlwiKSB7XG4gICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgICAgcHJvZ3Jlc3MoMCk7XG4gICAgICAgICAgICBhd2FpdCBzdGFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNhbHQsIGNvdW50LCBka0xlbiwgYWxnb3JpdGhtIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IGtleSA9IHBia2RmMihwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0pO1xuICAgICAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHByb2dyZXNzKDEpO1xuICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcbiAgICB9XG4gICAgYXNzZXJ0KHBhcmFtcy5uYW1lID09PSBcInNjcnlwdFwiLCBcImNhbm5vdCBiZSByZWFjaGVkXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IHBhcmFtcyB9KTtcbiAgICBjb25zdCB7IHNhbHQsIE4sIHIsIHAsIGRrTGVuIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3MpO1xuICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XG59XG5mdW5jdGlvbiBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAvLyBDaGVjay9nZW5lcmF0ZSB0aGUgc2FsdFxuICAgIGNvbnN0IHNhbHQgPSAob3B0aW9ucy5zYWx0ICE9IG51bGwpID8gZ2V0Qnl0ZXMob3B0aW9ucy5zYWx0LCBcIm9wdGlvbnMuc2FsdFwiKSA6IHJhbmRvbUJ5dGVzKDMyKTtcbiAgICAvLyBPdmVycmlkZSB0aGUgc2NyeXB0IHBhc3N3b3JkLWJhc2VkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnNcbiAgICBsZXQgTiA9ICgxIDw8IDE3KSwgciA9IDgsIHAgPSAxO1xuICAgIGlmIChvcHRpb25zLnNjcnlwdCkge1xuICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQuTikge1xuICAgICAgICAgICAgTiA9IG9wdGlvbnMuc2NyeXB0Lk47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0LnIpIHtcbiAgICAgICAgICAgIHIgPSBvcHRpb25zLnNjcnlwdC5yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5wKSB7XG4gICAgICAgICAgICBwID0gb3B0aW9ucy5zY3J5cHQucDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKE4pID09PSBcIm51bWJlclwiICYmIE4gPiAwICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKE4pICYmIChCaWdJbnQoTikgJiBCaWdJbnQoTiAtIDEpKSA9PT0gQmlnSW50KDApLCBcImludmFsaWQgc2NyeXB0IE4gcGFyYW1ldGVyXCIsIFwib3B0aW9ucy5OXCIsIE4pO1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAocikgPT09IFwibnVtYmVyXCIgJiYgciA+IDAgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIociksIFwiaW52YWxpZCBzY3J5cHQgciBwYXJhbWV0ZXJcIiwgXCJvcHRpb25zLnJcIiwgcik7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChwKSA9PT0gXCJudW1iZXJcIiAmJiBwID4gMCAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihwKSwgXCJpbnZhbGlkIHNjcnlwdCBwIHBhcmFtZXRlclwiLCBcIm9wdGlvbnMucFwiLCBwKTtcbiAgICByZXR1cm4geyBuYW1lOiBcInNjcnlwdFwiLCBka0xlbjogMzIsIHNhbHQsIE4sIHIsIHAgfTtcbn1cbmZ1bmN0aW9uIF9lbmNyeXB0S2V5c3RvcmUoa2V5LCBrZGYsIGFjY291bnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gZ2V0Qnl0ZXMoYWNjb3VudC5wcml2YXRlS2V5LCBcInByaXZhdGVLZXlcIik7XG4gICAgLy8gT3ZlcnJpZGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yXG4gICAgY29uc3QgaXYgPSAob3B0aW9ucy5pdiAhPSBudWxsKSA/IGdldEJ5dGVzKG9wdGlvbnMuaXYsIFwib3B0aW9ucy5pdlwiKSA6IHJhbmRvbUJ5dGVzKDE2KTtcbiAgICBhc3NlcnRBcmd1bWVudChpdi5sZW5ndGggPT09IDE2LCBcImludmFsaWQgb3B0aW9ucy5pdiBsZW5ndGhcIiwgXCJvcHRpb25zLml2XCIsIG9wdGlvbnMuaXYpO1xuICAgIC8vIE92ZXJyaWRlIHRoZSB1dWlkXG4gICAgY29uc3QgdXVpZFJhbmRvbSA9IChvcHRpb25zLnV1aWQgIT0gbnVsbCkgPyBnZXRCeXRlcyhvcHRpb25zLnV1aWQsIFwib3B0aW9ucy51dWlkXCIpIDogcmFuZG9tQnl0ZXMoMTYpO1xuICAgIGFzc2VydEFyZ3VtZW50KHV1aWRSYW5kb20ubGVuZ3RoID09PSAxNiwgXCJpbnZhbGlkIG9wdGlvbnMudXVpZCBsZW5ndGhcIiwgXCJvcHRpb25zLnV1aWRcIiwgb3B0aW9ucy5pdik7XG4gICAgLy8gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZW5jcnlwdCB0aGUgd2FsbGV0IChhcyBwZXIgV2ViMyBzZWNyZXQgc3RvcmFnZSlcbiAgICAvLyAtIDMyIGJ5dGVzICAgQXMgbm9ybWFsIGZvciB0aGUgV2ViMyBzZWNyZXQgc3RvcmFnZSAoZGVyaXZlZEtleSwgbWFjUHJlZml4KVxuICAgIC8vIC0gMzIgYnl0ZXMgICBBRVMga2V5IHRvIGVuY3J5cHQgbW5lbW9uaWMgd2l0aCAocmVxdWlyZWQgaGVyZSB0byBiZSBFdGhlcnMgV2FsbGV0KVxuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBrZXkuc2xpY2UoMCwgMTYpO1xuICAgIGNvbnN0IG1hY1ByZWZpeCA9IGtleS5zbGljZSgxNiwgMzIpO1xuICAgIC8vIEVuY3J5cHQgdGhlIHByaXZhdGUga2V5XG4gICAgY29uc3QgYWVzQ3RyID0gbmV3IENUUihkZXJpdmVkS2V5LCBpdik7XG4gICAgY29uc3QgY2lwaGVydGV4dCA9IGdldEJ5dGVzKGFlc0N0ci5lbmNyeXB0KHByaXZhdGVLZXkpKTtcbiAgICAvLyBDb21wdXRlIHRoZSBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUsIHVzZWQgdG8gY2hlY2sgdGhlIHBhc3N3b3JkXG4gICAgY29uc3QgbWFjID0ga2VjY2FrMjU2KGNvbmNhdChbbWFjUHJlZml4LCBjaXBoZXJ0ZXh0XSkpO1xuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9XZWIzLVNlY3JldC1TdG9yYWdlLURlZmluaXRpb25cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGlkOiB1dWlkVjQodXVpZFJhbmRvbSksXG4gICAgICAgIHZlcnNpb246IDMsXG4gICAgICAgIENyeXB0bzoge1xuICAgICAgICAgICAgY2lwaGVyOiBcImFlcy0xMjgtY3RyXCIsXG4gICAgICAgICAgICBjaXBoZXJwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBpdjogaGV4bGlmeShpdikuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNpcGhlcnRleHQ6IGhleGxpZnkoY2lwaGVydGV4dCkuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAga2RmOiBcInNjcnlwdFwiLFxuICAgICAgICAgICAga2RmcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgc2FsdDogaGV4bGlmeShrZGYuc2FsdCkuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgICAgIG46IGtkZi5OLFxuICAgICAgICAgICAgICAgIGRrbGVuOiAzMixcbiAgICAgICAgICAgICAgICBwOiBrZGYucCxcbiAgICAgICAgICAgICAgICByOiBrZGYuclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hYzogbWFjLnN1YnN0cmluZygyKVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgbW5lbW9uaWMsIGVuY3J5cHQgaXQgaW50byB0aGUgSlNPTiB3YWxsZXRcbiAgICBpZiAoYWNjb3VudC5tbmVtb25pYykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSAob3B0aW9ucy5jbGllbnQgIT0gbnVsbCkgPyBvcHRpb25zLmNsaWVudCA6IGBldGhlcnMvJHt2ZXJzaW9ufWA7XG4gICAgICAgIGNvbnN0IHBhdGggPSBhY2NvdW50Lm1uZW1vbmljLnBhdGggfHwgZGVmYXVsdFBhdGg7XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IGFjY291bnQubW5lbW9uaWMubG9jYWxlIHx8IFwiZW5cIjtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgY29uc3QgZW50cm9weSA9IGdldEJ5dGVzKGFjY291bnQubW5lbW9uaWMuZW50cm9weSwgXCJhY2NvdW50Lm1uZW1vbmljLmVudHJvcHlcIik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljSXYgPSByYW5kb21CeXRlcygxNik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQWVzQ3RyID0gbmV3IENUUihtbmVtb25pY0tleSwgbW5lbW9uaWNJdik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQ2lwaGVydGV4dCA9IGdldEJ5dGVzKG1uZW1vbmljQWVzQ3RyLmVuY3J5cHQoZW50cm9weSkpO1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSAobm93LmdldFVUQ0Z1bGxZZWFyKCkgKyBcIi1cIiArXG4gICAgICAgICAgICB6cGFkKG5vdy5nZXRVVENNb250aCgpICsgMSwgMikgKyBcIi1cIiArXG4gICAgICAgICAgICB6cGFkKG5vdy5nZXRVVENEYXRlKCksIDIpICsgXCJUXCIgK1xuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDSG91cnMoKSwgMikgKyBcIi1cIiArXG4gICAgICAgICAgICB6cGFkKG5vdy5nZXRVVENNaW51dGVzKCksIDIpICsgXCItXCIgK1xuICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDU2Vjb25kcygpLCAyKSArIFwiLjBaXCIpO1xuICAgICAgICBjb25zdCBnZXRoRmlsZW5hbWUgPSAoXCJVVEMtLVwiICsgdGltZXN0YW1wICsgXCItLVwiICsgZGF0YS5hZGRyZXNzKTtcbiAgICAgICAgZGF0YVtcIngtZXRoZXJzXCJdID0ge1xuICAgICAgICAgICAgY2xpZW50LCBnZXRoRmlsZW5hbWUsIHBhdGgsIGxvY2FsZSxcbiAgICAgICAgICAgIG1uZW1vbmljQ291bnRlcjogaGV4bGlmeShtbmVtb25pY0l2KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICBtbmVtb25pY0NpcGhlcnRleHQ6IGhleGxpZnkobW5lbW9uaWNDaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICB2ZXJzaW9uOiBcIjAuMVwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgSlNPTiBLZXlzdG9yZSBXYWxsZXQgZm9yICUlYWNjb3VudCUlIGVuY3J5cHRlZCB3aXRoXG4gKiAgJSVwYXNzd29yZCUlLlxuICpcbiAqICBUaGUgJSVvcHRpb25zJSUgY2FuIGJlIHVzZWQgdG8gdHVuZSB0aGUgcGFzc3dvcmQtYmFzZWQga2V5XG4gKiAgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzLCBleHBsaWNpdGx5IHNldCB0aGUgcmFuZG9tIHZhbHVlc1xuICogIHVzZWQuIEFueSBwcm92aWRlZCBbW1Byb2dyZXNzQ2FsbGJhY2tdXSBpcyBpZ25vcmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyhhY2NvdW50LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBwYXNzd29yZEJ5dGVzID0gZ2V0UGFzc3dvcmQocGFzc3dvcmQpO1xuICAgIGNvbnN0IGtkZiA9IGdldEVuY3J5cHRLZGZQYXJhbXMob3B0aW9ucyk7XG4gICAgY29uc3Qga2V5ID0gc2NyeXB0U3luYyhwYXNzd29yZEJ5dGVzLCBrZGYuc2FsdCwga2RmLk4sIGtkZi5yLCBrZGYucCwgNjQpO1xuICAgIHJldHVybiBfZW5jcnlwdEtleXN0b3JlKGdldEJ5dGVzKGtleSksIGtkZiwgYWNjb3VudCwgb3B0aW9ucyk7XG59XG4vKipcbiAqICBSZXNvbHZlZCB0byB0aGUgSlNPTiBLZXlzdG9yZSBXYWxsZXQgZm9yICUlYWNjb3VudCUlIGVuY3J5cHRlZFxuICogIHdpdGggJSVwYXNzd29yZCUlLlxuICpcbiAqICBUaGUgJSVvcHRpb25zJSUgY2FuIGJlIHVzZWQgdG8gdHVuZSB0aGUgcGFzc3dvcmQtYmFzZWQga2V5XG4gKiAgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzLCBleHBsaWNpdGx5IHNldCB0aGUgcmFuZG9tIHZhbHVlc1xuICogIHVzZWQgYW5kIHByb3ZpZGUgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byByZWNlaXZlIHBlcmlvZGljIHVwZGF0ZXNcbiAqICBvbiB0aGUgY29tcGxldGlvbiBzdGF0dXMuLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEtleXN0b3JlSnNvbihhY2NvdW50LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBwYXNzd29yZEJ5dGVzID0gZ2V0UGFzc3dvcmQocGFzc3dvcmQpO1xuICAgIGNvbnN0IGtkZiA9IGdldEVuY3J5cHRLZGZQYXJhbXMob3B0aW9ucyk7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgc2NyeXB0KHBhc3N3b3JkQnl0ZXMsIGtkZi5zYWx0LCBrZGYuTiwga2RmLnIsIGtkZi5wLCA2NCwgb3B0aW9ucy5wcm9ncmVzc0NhbGxiYWNrKTtcbiAgICByZXR1cm4gX2VuY3J5cHRLZXlzdG9yZShnZXRCeXRlcyhrZXkpLCBrZGYsIGFjY291bnQsIG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1rZXlzdG9yZS5qcy5tYXAiLCIvKipcbiAqICBFeHBsYWluIEhEIFdhbGxldHMuLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS93YWxsZXQ6SEQgV2FsbGV0cyAgW2hkLXdhbGxldHNdXG4gKi9cbmltcG9ydCB7IGNvbXB1dGVIbWFjLCByYW5kb21CeXRlcywgcmlwZW1kMTYwLCBTaWduaW5nS2V5LCBzaGEyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBWb2lkU2lnbmVyIH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29tcHV0ZUFkZHJlc3MgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBkZWNvZGVCYXNlNTgsIGRlZmluZVByb3BlcnRpZXMsIGVuY29kZUJhc2U1OCwgZ2V0Qnl0ZXMsIGhleGxpZnksIGlzQnl0ZXNMaWtlLCBnZXROdW1iZXIsIHRvQmVBcnJheSwgdG9CaWdJbnQsIHRvQmVIZXgsIGFzc2VydFByaXZhdGUsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IExhbmdFbiB9IGZyb20gXCIuLi93b3JkbGlzdHMvbGFuZy1lbi5qc1wiO1xuaW1wb3J0IHsgQmFzZVdhbGxldCB9IGZyb20gXCIuL2Jhc2Utd2FsbGV0LmpzXCI7XG5pbXBvcnQgeyBNbmVtb25pYyB9IGZyb20gXCIuL21uZW1vbmljLmpzXCI7XG5pbXBvcnQgeyBlbmNyeXB0S2V5c3RvcmVKc29uLCBlbmNyeXB0S2V5c3RvcmVKc29uU3luYywgfSBmcm9tIFwiLi9qc29uLWtleXN0b3JlLmpzXCI7XG4vKipcbiAqICBUaGUgZGVmYXVsdCBkZXJpdmF0aW9uIHBhdGggZm9yIEV0aGVyZXVtIEhEIE5vZGVzLiAoaS5lLiBgYFwibS80NCcvNjAnLzAnLzAvMFwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGF0aCA9IFwibS80NCcvNjAnLzAnLzAvMFwiO1xuLy8gXCJCaXRjb2luIHNlZWRcIlxuY29uc3QgTWFzdGVyU2VjcmV0ID0gbmV3IFVpbnQ4QXJyYXkoWzY2LCAxMDUsIDExNiwgOTksIDExMSwgMTA1LCAxMTAsIDMyLCAxMTUsIDEwMSwgMTAxLCAxMDBdKTtcbmNvbnN0IEhhcmRlbmVkQml0ID0gMHg4MDAwMDAwMDtcbmNvbnN0IE4gPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7XG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5mdW5jdGlvbiB6cGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0ID0gTmliYmxlc1t2YWx1ZSAlIDE2XSArIHJlc3VsdDtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnRydW5jKHZhbHVlIC8gMTYpO1xuICAgIH1cbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGxlbmd0aCAqIDIpIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiBlbmNvZGVCYXNlNThDaGVjayhfdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldEJ5dGVzKF92YWx1ZSk7XG4gICAgY29uc3QgY2hlY2sgPSBkYXRhU2xpY2Uoc2hhMjU2KHNoYTI1Nih2YWx1ZSkpLCAwLCA0KTtcbiAgICBjb25zdCBieXRlcyA9IGNvbmNhdChbdmFsdWUsIGNoZWNrXSk7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U1OChieXRlcyk7XG59XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmZ1bmN0aW9uIHNlcl9JKGluZGV4LCBjaGFpbkNvZGUsIHB1YmxpY0tleSwgcHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSgzNyk7XG4gICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcbiAgICAgICAgYXNzZXJ0KHByaXZhdGVLZXkgIT0gbnVsbCwgXCJjYW5ub3QgZGVyaXZlIGNoaWxkIG9mIG5ldXRlcmVkIG5vZGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRlcml2ZUNoaWxkXCJcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERhdGEgPSAweDAwIHx8IHNlcl8yNTYoa19wYXIpXG4gICAgICAgIGRhdGEuc2V0KGdldEJ5dGVzKHByaXZhdGVLZXkpLCAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIERhdGEgPSBzZXJfcChwb2ludChrX3BhcikpXG4gICAgICAgIGRhdGEuc2V0KGdldEJ5dGVzKHB1YmxpY0tleSkpO1xuICAgIH1cbiAgICAvLyBEYXRhICs9IHNlcl8zMihpKVxuICAgIGZvciAobGV0IGkgPSAyNDsgaSA+PSAwOyBpIC09IDgpIHtcbiAgICAgICAgZGF0YVszMyArIChpID4+IDMpXSA9ICgoaW5kZXggPj4gKDI0IC0gaSkpICYgMHhmZik7XG4gICAgfVxuICAgIGNvbnN0IEkgPSBnZXRCeXRlcyhjb21wdXRlSG1hYyhcInNoYTUxMlwiLCBjaGFpbkNvZGUsIGRhdGEpKTtcbiAgICByZXR1cm4geyBJTDogSS5zbGljZSgwLCAzMiksIElSOiBJLnNsaWNlKDMyKSB9O1xufVxuZnVuY3Rpb24gZGVyaXZlUGF0aChub2RlLCBwYXRoKSB7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KGNvbXBvbmVudHMubGVuZ3RoID4gMCwgXCJpbnZhbGlkIHBhdGhcIiwgXCJwYXRoXCIsIHBhdGgpO1xuICAgIGlmIChjb21wb25lbnRzWzBdID09PSBcIm1cIikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChub2RlLmRlcHRoID09PSAwLCBgY2Fubm90IGRlcml2ZSByb290IHBhdGggKGkuZS4gcGF0aCBzdGFydGluZyB3aXRoIFwibS9cIikgZm9yIGEgbm9kZSBhdCBub24temVybyBkZXB0aCAke25vZGUuZGVwdGh9YCwgXCJwYXRoXCIsIHBhdGgpO1xuICAgICAgICBjb21wb25lbnRzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBub2RlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJyQvKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQuc3Vic3RyaW5nKDAsIGNvbXBvbmVudC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgcGF0aCBpbmRleFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZGVyaXZlQ2hpbGQoSGFyZGVuZWRCaXQgKyBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgcGF0aCBpbmRleFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZGVyaXZlQ2hpbGQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBwYXRoIGNvbXBvbmVudFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIEFuICoqSEROb2RlV2FsbGV0KiogaXMgYSBbW1NpZ25lcl1dIGJhY2tlZCBieSB0aGUgcHJpdmF0ZSBrZXkgZGVyaXZlZFxuICogIGZyb20gYW4gSEQgTm9kZSB1c2luZyB0aGUgW1tsaW5rLWJpcC0zMl1dIHN0YW50YXJkLlxuICpcbiAqICBBbiBIRCBOb2RlIGZvcm1zIGEgaGllcmFyY2hhbCBzdHJ1Y3R1cmUgd2l0aCBlYWNoIEhEIE5vZGUgaGF2aW5nIGFcbiAqICBwcml2YXRlIGtleSBhbmQgdGhlIGFiaWxpdHkgdG8gZGVyaXZlIGNoaWxkIEhEIE5vZGVzLCBkZWZpbmVkIGJ5XG4gKiAgYSBwYXRoIGluZGljYXRpbmcgdGhlIGluZGV4IG9mIGVhY2ggY2hpbGQuXG4gKi9cbmV4cG9ydCBjbGFzcyBIRE5vZGVXYWxsZXQgZXh0ZW5kcyBCYXNlV2FsbGV0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKi9cbiAgICBwdWJsaWNLZXk7XG4gICAgLyoqXG4gICAgICogIFRoZSBmaW5nZXJwcmludC5cbiAgICAgKlxuICAgICAqICBBIGZpbmdlcnByaW50IGFsbG93cyBxdWljayBxYXkgdG8gZGV0ZWN0IHBhcmVudCBhbmQgY2hpbGQgbm9kZXMsXG4gICAgICogIGJ1dCBkZXZlbG9wZXJzIHNob3VsZCBiZSBwcmVwYXJlZCB0byBkZWFsIHdpdGggY29sbGlzaW9ucyBhcyBpdFxuICAgICAqICBpcyBvbmx5IDQgYnl0ZXMuXG4gICAgICovXG4gICAgZmluZ2VycHJpbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJlbnQgZmluZ2VycHJpbnQuXG4gICAgICovXG4gICAgcGFyZW50RmluZ2VycHJpbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBtbmVtb25pYyB1c2VkIHRvIGNyZWF0ZSB0aGlzIEhEIE5vZGUsIGlmIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqICBTb3VyY2VzIHN1Y2ggYXMgZXh0ZW5kZWQga2V5cyBkbyBub3QgZW5jb2RlIHRoZSBtbmVtb25pYywgaW5cbiAgICAgKiAgd2hpY2ggY2FzZSB0aGlzIHdpbGwgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgbW5lbW9uaWM7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbmNvZGUsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGEgcHVibGljIGtleSB1c2VkXG4gICAgICogIHRvIGRlcml2ZSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBjaGFpbkNvZGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXJpdmF0aW9uIHBhdGggb2YgdGhpcyB3YWxsZXQuXG4gICAgICpcbiAgICAgKiAgU2luY2UgZXh0ZW5kZWQga2V5cyBkbyBub3QgcHJvdmlkZSBmdWxsIHBhdGggZGV0YWlscywgdGhpc1xuICAgICAqICBtYXkgYmUgYGBudWxsYGAsIGlmIGluc3RhbnRpYXRlZCBmcm9tIGEgc291cmNlIHRoYXQgZG9lcyBub3RcbiAgICAgKiAgZW5jb2RlIGl0LlxuICAgICAqL1xuICAgIHBhdGg7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGlsZCBpbmRleCBvZiB0aGlzIHdhbGxldC4gVmFsdWVzIG92ZXIgYGAyICpcXCogMzFgYCBpbmRpY2F0ZVxuICAgICAqICB0aGUgbm9kZSBpcyBoYXJkZW5lZC5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRlcHRoIG9mIHRoaXMgd2FsbGV0LCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHNcbiAgICAgKiAgaW4gaXRzIHBhdGguXG4gICAgICovXG4gICAgZGVwdGg7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHNpZ25pbmdLZXksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aCwgbW5lbW9uaWMsIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKHNpZ25pbmdLZXksIHByb3ZpZGVyKTtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIkhETm9kZVdhbGxldFwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHB1YmxpY0tleTogc2lnbmluZ0tleS5jb21wcmVzc2VkUHVibGljS2V5IH0pO1xuICAgICAgICBjb25zdCBmaW5nZXJwcmludCA9IGRhdGFTbGljZShyaXBlbWQxNjAoc2hhMjU2KHRoaXMucHVibGljS2V5KSksIDAsIDQpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50LCBmaW5nZXJwcmludCxcbiAgICAgICAgICAgIGNoYWluQ29kZSwgcGF0aCwgaW5kZXgsIGRlcHRoXG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbW5lbW9uaWMgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCB0aGlzLnNpZ25pbmdLZXksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnBhdGgsIHRoaXMuaW5kZXgsIHRoaXMuZGVwdGgsIHRoaXMubW5lbW9uaWMsIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgI2FjY291bnQoKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3M6IHRoaXMuYWRkcmVzcywgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5IH07XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLm1uZW1vbmljO1xuICAgICAgICBpZiAodGhpcy5wYXRoICYmIG0gJiYgbS53b3JkbGlzdC5sb2NhbGUgPT09IFwiZW5cIiAmJiBtLnBhc3N3b3JkID09PSBcIlwiKSB7XG4gICAgICAgICAgICBhY2NvdW50Lm1uZW1vbmljID0ge1xuICAgICAgICAgICAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IFwiZW5cIixcbiAgICAgICAgICAgICAgICBlbnRyb3B5OiBtLmVudHJvcHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byBhIFtKU09OIEtleXN0b3JlIFdhbGxldF0oanNvbi13YWxsZXRzKSBlbmNyeXB0ZWQgd2l0aFxuICAgICAqICAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwcm9ncmVzc0NhbGxiYWNrJSUgaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlY2VpdmUgcGVyaW9kaWNcbiAgICAgKiAgdXBkYXRlcyBhcyB0aGUgZW5jcnlwdGlvbiBwcm9jZXNzIHByb2dyZXNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBlbmNyeXB0KHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBlbmNyeXB0S2V5c3RvcmVKc29uKHRoaXMuI2FjY291bnQoKSwgcGFzc3dvcmQsIHsgcHJvZ3Jlc3NDYWxsYmFjayB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBbSlNPTiBLZXlzdG9yZSBXYWxsZXRdKGpzb24td2FsbGV0cykgZW5jcnlwZWQgd2l0aFxuICAgICAqICAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZlcnNpb25dKGVuY3J5cHQpIGluc3RlYWQsXG4gICAgICogIHdoaWNoIGFsbG93cyBhIFtbUHJvZ3Jlc3NDYWxsYmFja11dIHRvIGtlZXAgdGhlIHVzZXIgaW5mb3JtZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2Qgd2lsbCBibG9jayB0aGUgZXZlbnQgbG9vcCAoZnJlZXppbmcgYWxsIFVJKSB1bnRpbFxuICAgICAqICBpdCBpcyBjb21wbGV0ZSwgd2hpY2ggbWF5IGJlIGEgbm9uLXRyaXZpYWwgZHVyYXRpb24uXG4gICAgICovXG4gICAgZW5jcnlwdFN5bmMocGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIGVuY3J5cHRLZXlzdG9yZUpzb25TeW5jKHRoaXMuI2FjY291bnQoKSwgcGFzc3dvcmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV4dGVuZGVkIGtleS5cbiAgICAgKlxuICAgICAqICBUaGlzIGtleSB3aWxsIGJlZ2luIHdpdGggdGhlIHByZWZpeCBgYHhwcml2YGAgYW5kIGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHJlY29uc3RydWN0IHRoaXMgSEQgTm9kZSB0byBkZXJpdmUgaXRzIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGdldCBleHRlbmRlZEtleSgpIHtcbiAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHRoZSBtYWlubmV0IHZhbHVlcyBmb3Igbm93LCBidXQgaWYgYW55b25lIG5lZWRzXG4gICAgICAgIC8vIHRlc3RuZXQgdmFsdWVzLCBsZXQgbWUga25vdy4gSSBiZWxpZXZlIGN1cnJlbnQgc2VudGltZW50IGlzIHRoYXRcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGFsd2F5cyB1c2UgbWFpbm5ldCwgYW5kIHVzZSBCSVAtNDQgdG8gZGVyaXZlIHRoZSBuZXR3b3JrXG4gICAgICAgIC8vICAgLSBNYWlubmV0OiBwdWJsaWM9MHgwNDg4QjIxRSwgcHJpdmF0ZT0weDA0ODhBREU0XG4gICAgICAgIC8vICAgLSBUZXN0bmV0OiBwdWJsaWM9MHgwNDM1ODdDRiwgcHJpdmF0ZT0weDA0MzU4Mzk0XG4gICAgICAgIGFzc2VydCh0aGlzLmRlcHRoIDwgMjU2LCBcIkRlcHRoIHRvbyBkZWVwXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImV4dGVuZGVkS2V5XCIgfSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVCYXNlNThDaGVjayhjb25jYXQoW1xuICAgICAgICAgICAgXCIweDA0ODhBREU0XCIsIHpwYWQodGhpcy5kZXB0aCwgMSksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICB6cGFkKHRoaXMuaW5kZXgsIDQpLCB0aGlzLmNoYWluQ29kZSxcbiAgICAgICAgICAgIGNvbmNhdChbXCIweDAwXCIsIHRoaXMucHJpdmF0ZUtleV0pXG4gICAgICAgIF0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHdhbGxldCBoYXMgYSBwYXRoLCBwcm92aWRpbmcgYSBUeXBlIEd1YXJkXG4gICAgICogIHRoYXQgdGhlIHBhdGggaXMgbm9uLW51bGwuXG4gICAgICovXG4gICAgaGFzUGF0aCgpIHsgcmV0dXJuICh0aGlzLnBhdGggIT0gbnVsbCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldXRlcmVkIEhEIE5vZGUsIHdoaWNoIHJlbW92ZXMgdGhlIHByaXZhdGUgZGV0YWlsc1xuICAgICAqICBvZiBhbiBIRCBOb2RlLlxuICAgICAqXG4gICAgICogIEEgbmV1dGVyZWQgbm9kZSBoYXMgbm8gcHJpdmF0ZSBrZXksIGJ1dCBjYW4gYmUgdXNlZCB0byBkZXJpdmVcbiAgICAgKiAgY2hpbGQgYWRkcmVzc2VzIGFuZCBvdGhlciBwdWJsaWMgZGF0YSBhYm91dCB0aGUgSEQgTm9kZS5cbiAgICAgKi9cbiAgICBuZXV0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSEROb2RlVm9pZFdhbGxldChfZ3VhcmQsIHRoaXMuYWRkcmVzcywgdGhpcy5wdWJsaWNLZXksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnBhdGgsIHRoaXMuaW5kZXgsIHRoaXMuZGVwdGgsIHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBjaGlsZCBmb3IgJSVpbmRleCUlLlxuICAgICAqL1xuICAgIGRlcml2ZUNoaWxkKF9pbmRleCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihfaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGluZGV4IDw9IDB4ZmZmZmZmZmYsIFwiaW52YWxpZCBpbmRleFwiLCBcImluZGV4XCIsIGluZGV4KTtcbiAgICAgICAgLy8gQmFzZSBwYXRoXG4gICAgICAgIGxldCBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgcGF0aCArPSBcIi9cIiArIChpbmRleCAmIH5IYXJkZW5lZEJpdCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggJiBIYXJkZW5lZEJpdCkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gXCInXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBJUiwgSUwgfSA9IHNlcl9JKGluZGV4LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5wdWJsaWNLZXksIHRoaXMucHJpdmF0ZUtleSk7XG4gICAgICAgIGNvbnN0IGtpID0gbmV3IFNpZ25pbmdLZXkodG9CZUhleCgodG9CaWdJbnQoSUwpICsgQmlnSW50KHRoaXMucHJpdmF0ZUtleSkpICUgTiwgMzIpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBraSwgdGhpcy5maW5nZXJwcmludCwgaGV4bGlmeShJUiksIHBhdGgsIGluZGV4LCB0aGlzLmRlcHRoICsgMSwgdGhpcy5tbmVtb25pYywgdGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIEhETm9kZSBmb3IgJSVwYXRoJSUgZnJvbSB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZGVyaXZlUGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBkZXJpdmVQYXRoKHRoaXMsIHBhdGgpO1xuICAgIH1cbiAgICBzdGF0aWMgI2Zyb21TZWVkKF9zZWVkLCBtbmVtb25pYykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpc0J5dGVzTGlrZShfc2VlZCksIFwiaW52YWxpZCBzZWVkXCIsIFwic2VlZFwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIGNvbnN0IHNlZWQgPSBnZXRCeXRlcyhfc2VlZCwgXCJzZWVkXCIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChzZWVkLmxlbmd0aCA+PSAxNiAmJiBzZWVkLmxlbmd0aCA8PSA2NCwgXCJpbnZhbGlkIHNlZWRcIiwgXCJzZWVkXCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgY29uc3QgSSA9IGdldEJ5dGVzKGNvbXB1dGVIbWFjKFwic2hhNTEyXCIsIE1hc3RlclNlY3JldCwgc2VlZCkpO1xuICAgICAgICBjb25zdCBzaWduaW5nS2V5ID0gbmV3IFNpZ25pbmdLZXkoaGV4bGlmeShJLnNsaWNlKDAsIDMyKSkpO1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIHNpZ25pbmdLZXksIFwiMHgwMDAwMDAwMFwiLCBoZXhsaWZ5KEkuc2xpY2UoMzIpKSwgXCJtXCIsIDAsIDAsIG1uZW1vbmljLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgSEQgTm9kZSBmcm9tICUlZXh0ZW5kZWRLZXklJS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVleHRlbmRlZEtleSUlIHdpbGwgZWl0aGVyIGhhdmUgYSBwcmVmaXggb3IgYGB4cHViYGAgb3JcbiAgICAgKiAgYGB4cHJpdmBgLCByZXR1cm5pbmcgYSBuZXV0ZXJlZCBIRCBOb2RlIChbW0hETm9kZVZvaWRXYWxsZXRdXSlcbiAgICAgKiAgb3IgZnVsbCBIRCBOb2RlIChbW0hETm9kZVdhbGxldCkgcmVzcGVjdGl2ZWx5LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRLZXkoZXh0ZW5kZWRLZXkpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0b0JlQXJyYXkoZGVjb2RlQmFzZTU4KGV4dGVuZGVkS2V5KSk7IC8vIEBUT0RPOiByZWRhY3RcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnl0ZXMubGVuZ3RoID09PSA4MiB8fCBlbmNvZGVCYXNlNThDaGVjayhieXRlcy5zbGljZSgwLCA3OCkpID09PSBleHRlbmRlZEtleSwgXCJpbnZhbGlkIGV4dGVuZGVkIGtleVwiLCBcImV4dGVuZGVkS2V5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICBjb25zdCBkZXB0aCA9IGJ5dGVzWzRdO1xuICAgICAgICBjb25zdCBwYXJlbnRGaW5nZXJwcmludCA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoNSwgOSkpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KGhleGxpZnkoYnl0ZXMuc2xpY2UoOSwgMTMpKS5zdWJzdHJpbmcoMiksIDE2KTtcbiAgICAgICAgY29uc3QgY2hhaW5Db2RlID0gaGV4bGlmeShieXRlcy5zbGljZSgxMywgNDUpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gYnl0ZXMuc2xpY2UoNDUsIDc4KTtcbiAgICAgICAgc3dpdGNoIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSkge1xuICAgICAgICAgICAgLy8gUHVibGljIEtleVxuICAgICAgICAgICAgY2FzZSBcIjB4MDQ4OGIyMWVcIjpcbiAgICAgICAgICAgIGNhc2UgXCIweDA0MzU4N2NmXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBoZXhsaWZ5KGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgY29tcHV0ZUFkZHJlc3MocHVibGljS2V5KSwgcHVibGljS2V5LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBudWxsLCBpbmRleCwgZGVwdGgsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJpdmF0ZSBLZXlcbiAgICAgICAgICAgIGNhc2UgXCIweDA0ODhhZGU0XCI6XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDM1ODM5NCBcIjpcbiAgICAgICAgICAgICAgICBpZiAoa2V5WzBdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIG5ldyBTaWduaW5nS2V5KGtleS5zbGljZSgxKSksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIG51bGwsIGluZGV4LCBkZXB0aCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBleHRlbmRlZCBrZXkgcHJlZml4XCIsIFwiZXh0ZW5kZWRLZXlcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IHJhbmRvbSBIRE5vZGUuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJhbmRvbShwYXNzd29yZCwgcGF0aCwgd29yZGxpc3QpIHtcbiAgICAgICAgaWYgKHBhc3N3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhc3N3b3JkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXRoID0gZGVmYXVsdFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gTGFuZ0VuLndvcmRsaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW5lbW9uaWMgPSBNbmVtb25pYy5mcm9tRW50cm9weShyYW5kb21CeXRlcygxNiksIHBhc3N3b3JkLCB3b3JkbGlzdCk7XG4gICAgICAgIHJldHVybiBIRE5vZGVXYWxsZXQuI2Zyb21TZWVkKG1uZW1vbmljLmNvbXB1dGVTZWVkKCksIG1uZW1vbmljKS5kZXJpdmVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGFuIEhEIE5vZGUgZnJvbSAlJW1uZW1vbmljJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21NbmVtb25pYyhtbmVtb25pYywgcGF0aCkge1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggPSBkZWZhdWx0UGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYW4gSEQgTm9kZSBmcm9tIGEgbW5lbW9uaWMgJSVwaHJhc2UlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBocmFzZShwaHJhc2UsIHBhc3N3b3JkLCBwYXRoLCB3b3JkbGlzdCkge1xuICAgICAgICBpZiAocGFzc3dvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFzc3dvcmQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGggPSBkZWZhdWx0UGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBMYW5nRW4ud29yZGxpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtbmVtb25pYyA9IE1uZW1vbmljLmZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYW4gSEQgTm9kZSBmcm9tIGEgJSVzZWVkJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TZWVkKHNlZWQpIHtcbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQoc2VlZCwgbnVsbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkhETm9kZVZvaWRXYWxsZXQqKiBjYW5ub3Qgc2lnbiwgYnV0IHByb3ZpZGVzIGFjY2VzcyB0b1xuICogIHRoZSBjaGlsZHJlbiBub2RlcyBvZiBhIFtbbGluay1iaXAtMzJdXSBIRCB3YWxsZXQgYWRkcmVzc2VzLlxuICpcbiAqICBUaGUgY2FuIGJlIGNyZWF0ZWQgYnkgdXNpbmcgYW4gZXh0ZW5kZWQgYGB4cHViYGAga2V5IHRvXG4gKiAgW1tIRE5vZGVXYWxsZXRfZnJvbUV4dGVuZGVkS2V5XV0gb3IgYnlcbiAqICBbbnVldGVyaW5nXShIRE5vZGVXYWxsZXQtbmV1dGVyKSBhIFtbSEROb2RlV2FsbGV0XV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBIRE5vZGVWb2lkV2FsbGV0IGV4dGVuZHMgVm9pZFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICovXG4gICAgcHVibGljS2V5O1xuICAgIC8qKlxuICAgICAqICBUaGUgZmluZ2VycHJpbnQuXG4gICAgICpcbiAgICAgKiAgQSBmaW5nZXJwcmludCBhbGxvd3MgcXVpY2sgcWF5IHRvIGRldGVjdCBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzLFxuICAgICAqICBidXQgZGV2ZWxvcGVycyBzaG91bGQgYmUgcHJlcGFyZWQgdG8gZGVhbCB3aXRoIGNvbGxpc2lvbnMgYXMgaXRcbiAgICAgKiAgaXMgb25seSA0IGJ5dGVzLlxuICAgICAqL1xuICAgIGZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFyZW50IG5vZGUgZmluZ2VycHJpbnQuXG4gICAgICovXG4gICAgcGFyZW50RmluZ2VycHJpbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbmNvZGUsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGEgcHVibGljIGtleSB1c2VkXG4gICAgICogIHRvIGRlcml2ZSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBjaGFpbkNvZGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXJpdmF0aW9uIHBhdGggb2YgdGhpcyB3YWxsZXQuXG4gICAgICpcbiAgICAgKiAgU2luY2UgZXh0ZW5kZWQga2V5cyBkbyBub3QgcHJvdmlkZXIgZnVsbCBwYXRoIGRldGFpbHMsIHRoaXNcbiAgICAgKiAgbWF5IGJlIGBgbnVsbGBgLCBpZiBpbnN0YW50aWF0ZWQgZnJvbSBhIHNvdXJjZSB0aGF0IGRvZXMgbm90XG4gICAgICogIGVub2NkZSBpdC5cbiAgICAgKi9cbiAgICBwYXRoO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hpbGQgaW5kZXggb2YgdGhpcyB3YWxsZXQuIFZhbHVlcyBvdmVyIGBgMiAqXFwqIDMxYGAgaW5kaWNhdGVcbiAgICAgKiAgdGhlIG5vZGUgaXMgaGFyZGVuZWQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXB0aCBvZiB0aGlzIHdhbGxldCwgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzXG4gICAgICogIGluIGl0cyBwYXRoLlxuICAgICAqL1xuICAgIGRlcHRoO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBhZGRyZXNzLCBwdWJsaWNLZXksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aCwgcHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIoYWRkcmVzcywgcHJvdmlkZXIpO1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiSEROb2RlVm9pZFdhbGxldFwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHB1YmxpY0tleSB9KTtcbiAgICAgICAgY29uc3QgZmluZ2VycHJpbnQgPSBkYXRhU2xpY2UocmlwZW1kMTYwKHNoYTI1NihwdWJsaWNLZXkpKSwgMCwgNCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgcHVibGljS2V5LCBmaW5nZXJwcmludCwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgcGF0aCwgaW5kZXgsIGRlcHRoXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSEROb2RlVm9pZFdhbGxldChfZ3VhcmQsIHRoaXMuYWRkcmVzcywgdGhpcy5wdWJsaWNLZXksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnBhdGgsIHRoaXMuaW5kZXgsIHRoaXMuZGVwdGgsIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBleHRlbmRlZCBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBrZXkgd2lsbCBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGB4cHViYGAgYW5kIGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHJlY29uc3RydWN0IHRoaXMgbmV1dGVyZWQga2V5IHRvIGRlcml2ZSBpdHMgY2hpbGRyZW4gYWRkcmVzc2VzLlxuICAgICAqL1xuICAgIGdldCBleHRlbmRlZEtleSgpIHtcbiAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHRoZSBtYWlubmV0IHZhbHVlcyBmb3Igbm93LCBidXQgaWYgYW55b25lIG5lZWRzXG4gICAgICAgIC8vIHRlc3RuZXQgdmFsdWVzLCBsZXQgbWUga25vdy4gSSBiZWxpZXZlIGN1cnJlbnQgc2VudGltZW50IGlzIHRoYXRcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGFsd2F5cyB1c2UgbWFpbm5ldCwgYW5kIHVzZSBCSVAtNDQgdG8gZGVyaXZlIHRoZSBuZXR3b3JrXG4gICAgICAgIC8vICAgLSBNYWlubmV0OiBwdWJsaWM9MHgwNDg4QjIxRSwgcHJpdmF0ZT0weDA0ODhBREU0XG4gICAgICAgIC8vICAgLSBUZXN0bmV0OiBwdWJsaWM9MHgwNDM1ODdDRiwgcHJpdmF0ZT0weDA0MzU4Mzk0XG4gICAgICAgIGFzc2VydCh0aGlzLmRlcHRoIDwgMjU2LCBcIkRlcHRoIHRvbyBkZWVwXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImV4dGVuZGVkS2V5XCIgfSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVCYXNlNThDaGVjayhjb25jYXQoW1xuICAgICAgICAgICAgXCIweDA0ODhCMjFFXCIsXG4gICAgICAgICAgICB6cGFkKHRoaXMuZGVwdGgsIDEpLFxuICAgICAgICAgICAgdGhpcy5wYXJlbnRGaW5nZXJwcmludCxcbiAgICAgICAgICAgIHpwYWQodGhpcy5pbmRleCwgNCksXG4gICAgICAgICAgICB0aGlzLmNoYWluQ29kZSxcbiAgICAgICAgICAgIHRoaXMucHVibGljS2V5LFxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB3YWxsZXQgaGFzIGEgcGF0aCwgcHJvdmlkaW5nIGEgVHlwZSBHdWFyZFxuICAgICAqICB0aGF0IHRoZSBwYXRoIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGhhc1BhdGgoKSB7IHJldHVybiAodGhpcy5wYXRoICE9IG51bGwpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgY2hpbGQgZm9yICUlaW5kZXglJS5cbiAgICAgKi9cbiAgICBkZXJpdmVDaGlsZChfaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIoX2luZGV4LCBcImluZGV4XCIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8PSAweGZmZmZmZmZmLCBcImludmFsaWQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIC8vIEJhc2UgcGF0aFxuICAgICAgICBsZXQgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgSVIsIElMIH0gPSBzZXJfSShpbmRleCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucHVibGljS2V5LCBudWxsKTtcbiAgICAgICAgY29uc3QgS2kgPSBTaWduaW5nS2V5LmFkZFBvaW50cyhJTCwgdGhpcy5wdWJsaWNLZXksIHRydWUpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gY29tcHV0ZUFkZHJlc3MoS2kpO1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCBhZGRyZXNzLCBLaSwgdGhpcy5maW5nZXJwcmludCwgaGV4bGlmeShJUiksIHBhdGgsIGluZGV4LCB0aGlzLmRlcHRoICsgMSwgdGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHNpZ25lciBmb3IgJSVwYXRoJSUgZnJvbSB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZGVyaXZlUGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBkZXJpdmVQYXRoKHRoaXMsIHBhdGgpO1xuICAgIH1cbn1cbi8qXG5leHBvcnQgY2xhc3MgSEROb2RlV2FsbGV0TWFuYWdlciB7XG4gICAgI3Jvb3Q6IEhETm9kZVdhbGxldDtcblxuICAgIGNvbnN0cnVjdG9yKHBocmFzZTogc3RyaW5nLCBwYXNzd29yZD86IG51bGwgfCBzdHJpbmcsIHBhdGg/OiBudWxsIHwgc3RyaW5nLCBsb2NhbGU/OiBudWxsIHwgV29yZGxpc3QpIHtcbiAgICAgICAgaWYgKHBhc3N3b3JkID09IG51bGwpIHsgcGFzc3dvcmQgPSBcIlwiOyB9XG4gICAgICAgIGlmIChwYXRoID09IG51bGwpIHsgcGF0aCA9IFwibS80NCcvNjAnLzAnLzBcIjsgfVxuICAgICAgICBpZiAobG9jYWxlID09IG51bGwpIHsgbG9jYWxlID0gTGFuZ0VuLndvcmRsaXN0KCk7IH1cbiAgICAgICAgdGhpcy4jcm9vdCA9IEhETm9kZVdhbGxldC5mcm9tUGhyYXNlKHBocmFzZSwgcGFzc3dvcmQsIHBhdGgsIGxvY2FsZSk7XG4gICAgfVxuXG4gICAgZ2V0U2lnbmVyKGluZGV4PzogbnVtYmVyKTogSEROb2RlV2FsbGV0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Jvb3QuZGVyaXZlQ2hpbGQoKGluZGV4ID09IG51bGwpID8gMDogaW5kZXgpO1xuICAgIH1cbn1cbiovXG4vKipcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstYmlwLTMyXV0gcGF0aCBmb3IgdGhlIGFjY291bnQgYXQgJSVpbmRleCUlLlxuICpcbiAqICBUaGlzIGlzIHRoZSBwYXR0ZXJuIHVzZWQgYnkgd2FsbGV0cyBsaWtlIExlZGdlci5cbiAqXG4gKiAgVGhlcmUgaXMgYWxzbyBhbiBbYWx0ZXJuYXRlIHBhdHRlcm5dKGdldEluZGV4ZWRBY2NvdW50UGF0aCkgdXNlZCBieVxuICogIHNvbWUgc29mdHdhcmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2NvdW50UGF0aChfaW5kZXgpIHtcbiAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihfaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCAmJiBpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgYWNjb3VudCBpbmRleFwiLCBcImluZGV4XCIsIGluZGV4KTtcbiAgICByZXR1cm4gYG0vNDQnLzYwJy8ke2luZGV4fScvMC8wYDtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIHBhdGggdXNpbmcgYW4gYWx0ZXJuYXRpdmUgcGF0dGVybiBmb3IgZGVyaXZpbmcgYWNjb3VudHMsXG4gKiAgYXQgJSVpbmRleCUlLlxuICpcbiAqICBUaGlzIGRlcml2YXRpb24gcGF0aCB1c2VzIHRoZSAvL2luZGV4Ly8gY29tcG9uZW50IHJhdGhlciB0aGFuIHRoZVxuICogIC8vYWNjb3VudC8vIGNvbXBvbmVudCB0byBkZXJpdmUgc2VxdWVudGlhbCBhY2NvdW50cy5cbiAqXG4gKiAgVGhpcyBpcyB0aGUgcGF0dGVybiB1c2VkIGJ5IHdhbGxldHMgbGlrZSBNZXRhTWFzay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluZGV4ZWRBY2NvdW50UGF0aChfaW5kZXgpIHtcbiAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihfaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCAmJiBpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgYWNjb3VudCBpbmRleFwiLCBcImluZGV4XCIsIGluZGV4KTtcbiAgICByZXR1cm4gYG0vNDQnLzYwJy8wJy8wLyR7aW5kZXh9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhkd2FsbGV0LmpzLm1hcCIsIi8qKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3dhbGxldDpKU09OIFdhbGxldHMgIFtqc29uLXdhbGxldHNdXG4gKi9cbmltcG9ydCB7IENCQywgcGtjczdTdHJpcCB9IGZyb20gXCJhZXMtanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcGJrZGYyIH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRQYXNzd29yZCwgbG9vc2VBcnJheWlmeSwgc3BlbHVuayB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSVqc29uJSUgaXMgYSB2YWxpZCBKU09OIENyb3dkc2FsZSB3YWxsZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Nyb3dkc2FsZUpzb24oanNvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICBpZiAoZGF0YS5lbmNzZWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3B5ZXRoc2FsZXRvb2xcbi8qKlxuICogIEJlZm9yZSBFdGhlcmV1bSBsYXVuY2hlZCwgaXQgd2FzIG5lY2Vzc2FyeSB0byBjcmVhdGUgYSB3YWxsZXRcbiAqICBmb3JtYXQgZm9yIGJhY2tlcnMgdG8gdXNlLCB3aGljaCB3b3VsZCBiZSB1c2VkIHRvIHJlY2VpdmUgZXRoZXJcbiAqICBhcyBhIHJld2FyZCBmb3IgY29udHJpYnV0aW5nIHRvIHRoZSBwcm9qZWN0LlxuICpcbiAqICBUaGUgW1tsaW5rLWNyb3dkc2FsZV1dIGZvcm1hdCBpcyBub3cgb2Jzb2xldGUsIGJ1dCBpdCBpcyBzdGlsbFxuICogIHVzZWZ1bCB0byBzdXBwb3J0IGFuZCB0aGUgYWRkaXRpb25hbCBjb2RlIGlzIGZhaXJseSB0cml2aWFsIGFzXG4gKiAgYWxsIHRoZSBwcmltaXRpdmVzIHJlcXVpcmVkIGFyZSB1c2VkIHRocm91Z2ggY29yZSBwb3J0aW9ucyBvZlxuICogIHRoZSBsaWJyYXJ5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdENyb3dkc2FsZUpzb24oanNvbiwgX3Bhc3N3b3JkKSB7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgY29uc3QgcGFzc3dvcmQgPSBnZXRQYXNzd29yZChfcGFzc3dvcmQpO1xuICAgIC8vIEV0aGVyZXVtIEFkZHJlc3NcbiAgICBjb25zdCBhZGRyZXNzID0gZ2V0QWRkcmVzcyhzcGVsdW5rKGRhdGEsIFwiZXRoYWRkcjpzdHJpbmchXCIpKTtcbiAgICAvLyBFbmNyeXB0ZWQgU2VlZFxuICAgIGNvbnN0IGVuY3NlZWQgPSBsb29zZUFycmF5aWZ5KHNwZWx1bmsoZGF0YSwgXCJlbmNzZWVkOnN0cmluZyFcIikpO1xuICAgIGFzc2VydEFyZ3VtZW50KGVuY3NlZWQgJiYgKGVuY3NlZWQubGVuZ3RoICUgMTYpID09PSAwLCBcImludmFsaWQgZW5jc2VlZFwiLCBcImpzb25cIiwganNvbik7XG4gICAgY29uc3Qga2V5ID0gZ2V0Qnl0ZXMocGJrZGYyKHBhc3N3b3JkLCBwYXNzd29yZCwgMjAwMCwgMzIsIFwic2hhMjU2XCIpKS5zbGljZSgwLCAxNik7XG4gICAgY29uc3QgaXYgPSBlbmNzZWVkLnNsaWNlKDAsIDE2KTtcbiAgICBjb25zdCBlbmNyeXB0ZWRTZWVkID0gZW5jc2VlZC5zbGljZSgxNik7XG4gICAgLy8gRGVjcnlwdCB0aGUgc2VlZFxuICAgIGNvbnN0IGFlc0NiYyA9IG5ldyBDQkMoa2V5LCBpdik7XG4gICAgY29uc3Qgc2VlZCA9IHBrY3M3U3RyaXAoZ2V0Qnl0ZXMoYWVzQ2JjLmRlY3J5cHQoZW5jcnlwdGVkU2VlZCkpKTtcbiAgICAvLyBUaGlzIHdhbGxldCBmb3JtYXQgaXMgd2VpcmQuLi4gQ29udmVydCB0aGUgYmluYXJ5IGVuY29kZWQgaGV4IHRvIGEgc3RyaW5nLlxuICAgIGxldCBzZWVkSGV4ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VlZEhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHNlZWRbaV0pO1xuICAgIH1cbiAgICByZXR1cm4geyBhZGRyZXNzLCBwcml2YXRlS2V5OiBpZChzZWVkSGV4KSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1jcm93ZHNhbGUuanMubWFwIiwiaW1wb3J0IHsgU2lnbmluZ0tleSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBCYXNlV2FsbGV0IH0gZnJvbSBcIi4vYmFzZS13YWxsZXQuanNcIjtcbmltcG9ydCB7IEhETm9kZVdhbGxldCB9IGZyb20gXCIuL2hkd2FsbGV0LmpzXCI7XG5pbXBvcnQgeyBkZWNyeXB0Q3Jvd2RzYWxlSnNvbiwgaXNDcm93ZHNhbGVKc29uIH0gZnJvbSBcIi4vanNvbi1jcm93ZHNhbGUuanNcIjtcbmltcG9ydCB7IGRlY3J5cHRLZXlzdG9yZUpzb24sIGRlY3J5cHRLZXlzdG9yZUpzb25TeW5jLCBlbmNyeXB0S2V5c3RvcmVKc29uLCBlbmNyeXB0S2V5c3RvcmVKc29uU3luYywgaXNLZXlzdG9yZUpzb24gfSBmcm9tIFwiLi9qc29uLWtleXN0b3JlLmpzXCI7XG5pbXBvcnQgeyBNbmVtb25pYyB9IGZyb20gXCIuL21uZW1vbmljLmpzXCI7XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4geyBzZXRUaW1lb3V0KCgpID0+IHsgcmVzb2x2ZSgpOyB9LCBkdXJhdGlvbik7IH0pO1xufVxuLyoqXG4gKiAgQSAqKldhbGxldCoqIG1hbmFnZXMgYSBzaW5nbGUgcHJpdmF0ZSBrZXkgd2hpY2ggaXMgdXNlZCB0byBzaWduXG4gKiAgdHJhbnNhY3Rpb25zLCBtZXNzYWdlcyBhbmQgb3RoZXIgY29tbW9uIHBheWxvYWRzLlxuICpcbiAqICBUaGlzIGNsYXNzIGlzIGdlbmVyYWxseSB0aGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgZGV2ZWxvcGVyc1xuICogIHRoYXQgd2lzaCB0byB1c2UgYSBwcml2YXRlIGtleSBkaXJlY3RseSwgYXMgaXQgY2FuIGNyZWF0ZVxuICogIGluc3RhbmNlcyBmcm9tIGEgbGFyZ2UgdmFyaWV0eSBvZiBjb21tb24gc291cmNlcywgaW5jbHVkaW5nXG4gKiAgcmF3IHByaXZhdGUga2V5LCBbW2xpbmstYmlwLTM5XV0gbW5lbW9uaWNzIGFuZCBlbmNyeXB0ZSBKU09OXG4gKiAgd2FsbGV0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFdhbGxldCBleHRlbmRzIEJhc2VXYWxsZXQge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgd2FsbGV0IGZvciB0aGUgcHJpdmF0ZSAlJWtleSUlLCBvcHRpb25hbGx5IGNvbm5lY3RlZFxuICAgICAqICB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioa2V5LCBwcm92aWRlcikge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiICYmICFrZXkuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgICAgICBrZXkgPSBcIjB4XCIgKyBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZ25pbmdLZXkgPSAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiKSA/IG5ldyBTaWduaW5nS2V5KGtleSkgOiBrZXk7XG4gICAgICAgIHN1cGVyKHNpZ25pbmdLZXksIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLnNpZ25pbmdLZXksIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cHRlZCB3aXRoXG4gICAgICogICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBJZiAlJXByb2dyZXNzQ2FsbGJhY2slJSBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVjZWl2ZSBwZXJpb2RpY1xuICAgICAqICB1cGRhdGVzIGFzIHRoZSBlbmNyeXB0aW9uIHByb2Nlc3MgcHJvZ3Jlc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGVuY3J5cHQocGFzc3dvcmQsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHsgYWRkcmVzczogdGhpcy5hZGRyZXNzLCBwcml2YXRlS2V5OiB0aGlzLnByaXZhdGVLZXkgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVuY3J5cHRLZXlzdG9yZUpzb24oYWNjb3VudCwgcGFzc3dvcmQsIHsgcHJvZ3Jlc3NDYWxsYmFjayB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBbSlNPTiBLZXlzdG9yZSBXYWxsZXRdKGpzb24td2FsbGV0cykgZW5jcnlwZWQgd2l0aFxuICAgICAqICAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZlcnNpb25dKGVuY3J5cHQpIGluc3RlYWQsXG4gICAgICogIHdoaWNoIGFsbG93cyBhIFtbUHJvZ3Jlc3NDYWxsYmFja11dIHRvIGtlZXAgdGhlIHVzZXIgaW5mb3JtZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2Qgd2lsbCBibG9jayB0aGUgZXZlbnQgbG9vcCAoZnJlZXppbmcgYWxsIFVJKSB1bnRpbFxuICAgICAqICBpdCBpcyBjb21wbGV0ZSwgd2hpY2ggbWF5IGJlIGEgbm9uLXRyaXZpYWwgZHVyYXRpb24uXG4gICAgICovXG4gICAgZW5jcnlwdFN5bmMocGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHsgYWRkcmVzczogdGhpcy5hZGRyZXNzLCBwcml2YXRlS2V5OiB0aGlzLnByaXZhdGVLZXkgfTtcbiAgICAgICAgcmV0dXJuIGVuY3J5cHRLZXlzdG9yZUpzb25TeW5jKGFjY291bnQsIHBhc3N3b3JkKTtcbiAgICB9XG4gICAgc3RhdGljICNmcm9tQWNjb3VudChhY2NvdW50KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGFjY291bnQsIFwiaW52YWxpZCBKU09OIHdhbGxldFwiLCBcImpzb25cIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIGlmIChcIm1uZW1vbmljXCIgaW4gYWNjb3VudCAmJiBhY2NvdW50Lm1uZW1vbmljICYmIGFjY291bnQubW5lbW9uaWMubG9jYWxlID09PSBcImVuXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1uZW1vbmljID0gTW5lbW9uaWMuZnJvbUVudHJvcHkoYWNjb3VudC5tbmVtb25pYy5lbnRyb3B5KTtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IEhETm9kZVdhbGxldC5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIGFjY291bnQubW5lbW9uaWMucGF0aCk7XG4gICAgICAgICAgICBpZiAod2FsbGV0LmFkZHJlc3MgPT09IGFjY291bnQuYWRkcmVzcyAmJiB3YWxsZXQucHJpdmF0ZUtleSA9PT0gYWNjb3VudC5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTklORzogSlNPTiBtaXNtYXRjaCBhZGRyZXNzL3ByaXZhdGVLZXkgIT0gbW5lbW9uaWM7IGZhbGxiYWNrIG9udG8gcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gbmV3IFdhbGxldChhY2NvdW50LnByaXZhdGVLZXkpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh3YWxsZXQuYWRkcmVzcyA9PT0gYWNjb3VudC5hZGRyZXNzLCBcImFkZHJlc3MvcHJpdmF0ZUtleSBtaXNtYXRjaFwiLCBcImpzb25cIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIChhc3luY2hyb25vdXNseSkgYSAqKldhbGxldCoqIGJ5IGRlY3J5cHRpbmcgdGhlICUlanNvbiUlXG4gICAgICogIHdpdGggJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIElmICUlcHJvZ3Jlc3MlJSBpcyBwcm92aWRlZCwgaXQgaXMgY2FsbGVkIHBlcmlvZGljYWxseSBkdXJpbmdcbiAgICAgKiAgZGVjcnlwdGlvbiBzbyB0aGF0IGFueSBVSSBjYW4gYmUgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUVuY3J5cHRlZEpzb24oanNvbiwgcGFzc3dvcmQsIHByb2dyZXNzKSB7XG4gICAgICAgIGxldCBhY2NvdW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzS2V5c3RvcmVKc29uKGpzb24pKSB7XG4gICAgICAgICAgICBhY2NvdW50ID0gYXdhaXQgZGVjcnlwdEtleXN0b3JlSnNvbihqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ3Jvd2RzYWxlSnNvbihqc29uKSkge1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MoMCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2NvdW50ID0gZGVjcnlwdENyb3dkc2FsZUpzb24oanNvbiwgcGFzc3dvcmQpO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MoMSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdhbGxldC4jZnJvbUFjY291bnQoYWNjb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgKipXYWxsZXQqKiBieSBkZWNyeXB0aW5nIHRoZSAlJWpzb24lJSB3aXRoICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBUaGUgW1tmcm9tRW5jcnlwdGVkSnNvbl1dIG1ldGhvZCBpcyBwcmVmZXJyZWQsIGFzIHRoaXMgbWV0aG9kXG4gICAgICogIHdpbGwgbG9jayB1cCBhbmQgZnJlZXplIHRoZSBVSSBkdXJpbmcgZGVjcnlwdGlvbiwgd2hpY2ggbWF5IHRha2VcbiAgICAgKiAgc29tZSB0aW1lLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRW5jcnlwdGVkSnNvblN5bmMoanNvbiwgcGFzc3dvcmQpIHtcbiAgICAgICAgbGV0IGFjY291bnQgPSBudWxsO1xuICAgICAgICBpZiAoaXNLZXlzdG9yZUpzb24oanNvbikpIHtcbiAgICAgICAgICAgIGFjY291bnQgPSBkZWNyeXB0S2V5c3RvcmVKc29uU3luYyhqc29uLCBwYXNzd29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDcm93ZHNhbGVKc29uKGpzb24pKSB7XG4gICAgICAgICAgICBhY2NvdW50ID0gZGVjcnlwdENyb3dkc2FsZUpzb24oanNvbiwgcGFzc3dvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBKU09OIHdhbGxldFwiLCBcImpzb25cIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdhbGxldC4jZnJvbUFjY291bnQoYWNjb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IHJhbmRvbSBbW0hETm9kZVdhbGxldF1dIHVzaW5nIHRoZSBhdmFpbGFibGVcbiAgICAgKiAgW2NyeXB0b2dyYXBoaWMgcmFuZG9tIHNvdXJjZV0ocmFuZG9tQnl0ZXMpLlxuICAgICAqXG4gICAgICogIElmIHRoZXJlIGlzIG5vIGNyeXRvZ3JhcGhpYyByYW5kb20gc291cmNlLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJhbmRvbShwcm92aWRlcikge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBIRE5vZGVXYWxsZXQuY3JlYXRlUmFuZG9tKCk7XG4gICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5jb25uZWN0KHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIFtbSEROb2RlV2FsbGV0XV0gZm9yICUlcGhyYXNlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBIRE5vZGVXYWxsZXQuZnJvbVBocmFzZShwaHJhc2UpO1xuICAgICAgICBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQuY29ubmVjdChwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWxsZXQuanMubWFwIiwiLyoqXHJcbiAqIGNvcmUvc3RvcmFnZS5qc1xyXG4gKlxyXG4gKiBFbmNyeXB0ZWQgc3RvcmFnZSB3cmFwcGVyIGZvciBDaHJvbWUgc3RvcmFnZSBBUElcclxuICogSGFuZGxlcyBib3RoIGVuY3J5cHRlZCAoZm9yIHNlbnNpdGl2ZSBkYXRhKSBhbmQgdW5lbmNyeXB0ZWQgc3RvcmFnZVxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XHJcblxyXG4vKipcclxuICogU2F2ZXMgdW5lbmNyeXB0ZWQgZGF0YSAoZm9yIG5vbi1zZW5zaXRpdmUgZGF0YSlcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFN0b3JhZ2Uga2V5XHJcbiAqIEBwYXJhbSB7YW55fSBkYXRhIC0gRGF0YSB0byBzdG9yZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlKGtleSwgZGF0YSkge1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoeyBba2V5XTogZGF0YSB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2F2ZSBkYXRhJyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogTG9hZHMgdW5lbmNyeXB0ZWQgZGF0YVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gU3RvcmFnZSBrZXlcclxuICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gU3RvcmVkIGRhdGEgb3IgbnVsbCBpZiBub3QgZm91bmRcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkKGtleSkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoa2V5KTtcclxuICAgIHJldHVybiByZXN1bHRba2V5XSB8fCBudWxsO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBkYXRhJyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBpdGVtIGZyb20gc3RvcmFnZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gU3RvcmFnZSBrZXlcclxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5yZW1vdmUoa2V5KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgZGF0YTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZW1vdmUgZGF0YScpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFycyBhbGwgc3RvcmFnZSAodXNlIHdpdGggY2F1dGlvbiEpXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFyKCkge1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5jbGVhcigpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbGVhcmluZyBzdG9yYWdlOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNsZWFyIHN0b3JhZ2UnKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIGFsbCBrZXlzIGluIHN0b3JhZ2VcclxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbEtleXMoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGFsbCA9IGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldChudWxsKTtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhhbGwpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGtleXM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHN0b3JhZ2Uga2V5cycpO1xyXG4gIH1cclxufVxyXG4iLCIvKipcbiAqIFV0aWxpdGllcyBmb3IgaGV4LCBieXRlcywgQ1NQUk5HLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5leHBvcnQgZnVuY3Rpb24gYW51bWJlcihuLCB0aXRsZSA9ICcnKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aXRsZSAmJiBgXCIke3RpdGxlfVwiIGA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtwcmVmaXh9ZXhwZWN0ZWQgaW50ZWdlciA+PSAwLCBnb3QgJHtufWApO1xuICAgIH1cbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFieXRlcyh2YWx1ZSwgbGVuZ3RoLCB0aXRsZSA9ICcnKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBpc0J5dGVzKHZhbHVlKTtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZT8ubGVuZ3RoO1xuICAgIGNvbnN0IG5lZWRzTGVuID0gbGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKCFieXRlcyB8fCAobmVlZHNMZW4gJiYgbGVuICE9PSBsZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRpdGxlICYmIGBcIiR7dGl0bGV9XCIgYDtcbiAgICAgICAgY29uc3Qgb2ZMZW4gPSBuZWVkc0xlbiA/IGAgb2YgbGVuZ3RoICR7bGVuZ3RofWAgOiAnJztcbiAgICAgICAgY29uc3QgZ290ID0gYnl0ZXMgPyBgbGVuZ3RoPSR7bGVufWAgOiBgdHlwZT0ke3R5cGVvZiB2YWx1ZX1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4ICsgJ2V4cGVjdGVkIFVpbnQ4QXJyYXknICsgb2ZMZW4gKyAnLCBnb3QgJyArIGdvdCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBoYXNoICovXG5leHBvcnQgZnVuY3Rpb24gYWhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBtdXN0IHdyYXBwZWQgYnkgdXRpbHMuY3JlYXRlSGFzaGVyJyk7XG4gICAgYW51bWJlcihoLm91dHB1dExlbik7XG4gICAgYW51bWJlcihoLmJsb2NrTGVuKTtcbn1cbi8qKiBBc3NlcnRzIGEgaGFzaCBpbnN0YW5jZSBoYXMgbm90IGJlZW4gZGVzdHJveWVkIC8gZmluaXNoZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG4vKiogQXNzZXJ0cyBvdXRwdXQgaXMgcHJvcGVybHktc2l6ZWQgYnl0ZSBhcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGFieXRlcyhvdXQsIHVuZGVmaW5lZCwgJ2RpZ2VzdEludG8oKSBvdXRwdXQnKTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImRpZ2VzdEludG8oKSBvdXRwdXRcIiBleHBlY3RlZCB0byBiZSBvZiBsZW5ndGggPj0nICsgbWluKTtcbiAgICB9XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1MzIoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cbi8qKiBaZXJvaXplIGEgYnl0ZSBhcnJheS4gV2FybmluZzogSlMgcHJvdmlkZXMgbm8gZ3VhcmFudGVlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbiguLi5hcnJheXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgICB9XG59XG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdHIod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG59XG4vKiogVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGwod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbn1cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydCBjb25zdCBpc0xFID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLyoqIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuICgoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gMjQpICYgMHhmZikpO1xufVxuLyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuZXhwb3J0IGNvbnN0IHN3YXA4SWZCRSA9IGlzTEVcbiAgICA/IChuKSA9PiBuXG4gICAgOiAobikgPT4gYnl0ZVN3YXAobik7XG4vKiogSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBjb25zdCBzd2FwMzJJZkJFID0gaXNMRVxuICAgID8gKHUpID0+IHVcbiAgICA6IGJ5dGVTd2FwMzI7XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvSGV4KCk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbiAqIENhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuICovXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vKiogUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZy4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBieXRlcyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQnVpbHQtaW4gZG9lc24ndCB2YWxpZGF0ZSBpbnB1dCB0byBiZSBzdHJpbmc6IHdlIGRvIHRoZSBjaGVjay5cbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBVaW50OEFycmF5LmZyb20oWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBleHBlY3RlZCcpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogSGVscGVyIGZvciBLREZzOiBjb25zdW1lcyB1aW50OGFycmF5IG9yIHN0cmluZy5cbiAqIFdoZW4gc3RyaW5nIGlzIHBhc3NlZCwgZG9lcyB1dGY4IGRlY29kaW5nLCB1c2luZyBUZXh0RGVjb2Rlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtkZklucHV0VG9CeXRlcyhkYXRhLCBlcnJvclRpdGxlID0gJycpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGFieXRlcyhkYXRhLCB1bmRlZmluZWQsIGVycm9yVGl0bGUpO1xufVxuLyoqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqIE1lcmdlcyBkZWZhdWx0IG9wdGlvbnMgYW5kIHBhc3NlZCBvcHRpb25zLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYge30udG9TdHJpbmcuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIENyZWF0ZXMgZnVuY3Rpb24gd2l0aCBvdXRwdXRMZW4sIGJsb2NrTGVuLCBjcmVhdGUgcHJvcGVydGllcyBmcm9tIGEgY2xhc3MgY29uc3RydWN0b3IuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKGhhc2hDb25zLCBpbmZvID0ge30pIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZShtc2cpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHVuZGVmaW5lZCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoQywgaW5mbyk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoaGFzaEMpO1xufVxuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgY29uc3QgY3IgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgPyBnbG9iYWxUaGlzLmNyeXB0byA6IG51bGw7XG4gICAgaWYgKHR5cGVvZiBjcj8uZ2V0UmFuZG9tVmFsdWVzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIGNyLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xufVxuLyoqIENyZWF0ZXMgT0lEIG9wdHMgZm9yIE5JU1QgaGFzaGVzLCB3aXRoIHByZWZpeCAwNiAwOSA2MCA4NiA0OCAwMSA2NSAwMyAwNCAwMi4gKi9cbmV4cG9ydCBjb25zdCBvaWROaXN0ID0gKHN1ZmZpeCkgPT4gKHtcbiAgICBvaWQ6IFVpbnQ4QXJyYXkuZnJvbShbMHgwNiwgMHgwOSwgMHg2MCwgMHg4NiwgMHg0OCwgMHgwMSwgMHg2NSwgMHgwMywgMHgwNCwgMHgwMiwgc3VmZml4XSksXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGFieXRlcywgYWV4aXN0cywgYWhhc2gsIGNsZWFuIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKiBJbnRlcm5hbCBjbGFzcyBmb3IgSE1BQy4gKi9cbmV4cG9ydCBjbGFzcyBfSE1BQyB7XG4gICAgb0hhc2g7XG4gICAgaUhhc2g7XG4gICAgYmxvY2tMZW47XG4gICAgb3V0cHV0TGVuO1xuICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgZGVzdHJveWVkID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IoaGFzaCwga2V5KSB7XG4gICAgICAgIGFoYXNoKGhhc2gpO1xuICAgICAgICBhYnl0ZXMoa2V5LCB1bmRlZmluZWQsICdrZXknKTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBjbGVhbihwYWQpO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhYnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbiwgJ291dHB1dCcpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fD0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuICogaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyJztcbiAqIGNvbnN0IG1hYzEgPSBobWFjKHNoYTI1NiwgJ2tleScsICdtZXNzYWdlJyk7XG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IF9ITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgX0hNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIiwiLyoqXG4gKiBIS0RGIChSRkMgNTg2OSk6IGV4dHJhY3QgKyBleHBhbmQgaW4gb25lIHN0ZXAuXG4gKiBTZWUgaHR0cHM6Ly9zb2F0b2suYmxvZy8yMDIxLzExLzE3L3VuZGVyc3RhbmRpbmctaGtkZi8uXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tIFwiLi9obWFjLmpzXCI7XG5pbXBvcnQgeyBhYnl0ZXMsIGFoYXNoLCBhbnVtYmVyLCBjbGVhbiB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vKipcbiAqIEhLREYtZXh0cmFjdCBmcm9tIHNwZWMuIExlc3MgaW1wb3J0YW50IHBhcnQuIGBIS0RGLUV4dHJhY3QoSUtNLCBzYWx0KSAtPiBQUktgXG4gKiBBcmd1bWVudHMgcG9zaXRpb24gZGlmZmVycyBmcm9tIHNwZWMgKElLTSBpcyBmaXJzdCBvbmUsIHNpbmNlIGl0IGlzIG5vdCBvcHRpb25hbClcbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgKGUuZy4gc2hhMjU2KVxuICogQHBhcmFtIGlrbSAtIGlucHV0IGtleWluZyBtYXRlcmlhbCwgdGhlIGluaXRpYWwga2V5XG4gKiBAcGFyYW0gc2FsdCAtIG9wdGlvbmFsIHNhbHQgdmFsdWUgKGEgbm9uLXNlY3JldCByYW5kb20gdmFsdWUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0KGhhc2gsIGlrbSwgc2FsdCkge1xuICAgIGFoYXNoKGhhc2gpO1xuICAgIC8vIE5PVEU6IHNvbWUgbGlicmFyaWVzIHRyZWF0IHplcm8tbGVuZ3RoIGFycmF5IGFzICdub3QgcHJvdmlkZWQnO1xuICAgIC8vIHdlIGRvbid0LCBzaW5jZSB3ZSBoYXZlIHVuZGVmaW5lZCBhcyAnbm90IHByb3ZpZGVkJ1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9SdXN0Q3J5cHRvL0tERnMvaXNzdWVzLzE1XG4gICAgaWYgKHNhbHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2FsdCA9IG5ldyBVaW50OEFycmF5KGhhc2gub3V0cHV0TGVuKTtcbiAgICByZXR1cm4gaG1hYyhoYXNoLCBzYWx0LCBpa20pO1xufVxuY29uc3QgSEtERl9DT1VOVEVSID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkub2YoMCk7XG5jb25zdCBFTVBUWV9CVUZGRVIgPSAvKiBAX19QVVJFX18gKi8gVWludDhBcnJheS5vZigpO1xuLyoqXG4gKiBIS0RGLWV4cGFuZCBmcm9tIHRoZSBzcGVjLiBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydC4gYEhLREYtRXhwYW5kKFBSSywgaW5mbywgTCkgLT4gT0tNYFxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCAoZS5nLiBzaGEyNTYpXG4gKiBAcGFyYW0gcHJrIC0gYSBwc2V1ZG9yYW5kb20ga2V5IG9mIGF0IGxlYXN0IEhhc2hMZW4gb2N0ZXRzICh1c3VhbGx5LCB0aGUgb3V0cHV0IGZyb20gdGhlIGV4dHJhY3Qgc3RlcClcbiAqIEBwYXJhbSBpbmZvIC0gb3B0aW9uYWwgY29udGV4dCBhbmQgYXBwbGljYXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb24gKGNhbiBiZSBhIHplcm8tbGVuZ3RoIHN0cmluZylcbiAqIEBwYXJhbSBsZW5ndGggLSBsZW5ndGggb2Ygb3V0cHV0IGtleWluZyBtYXRlcmlhbCBpbiBieXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kKGhhc2gsIHByaywgaW5mbywgbGVuZ3RoID0gMzIpIHtcbiAgICBhaGFzaChoYXNoKTtcbiAgICBhbnVtYmVyKGxlbmd0aCwgJ2xlbmd0aCcpO1xuICAgIGNvbnN0IG9sZW4gPSBoYXNoLm91dHB1dExlbjtcbiAgICBpZiAobGVuZ3RoID4gMjU1ICogb2xlbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggbXVzdCBiZSA8PSAyNTUqSGFzaExlbicpO1xuICAgIGNvbnN0IGJsb2NrcyA9IE1hdGguY2VpbChsZW5ndGggLyBvbGVuKTtcbiAgICBpZiAoaW5mbyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBpbmZvID0gRU1QVFlfQlVGRkVSO1xuICAgIGVsc2VcbiAgICAgICAgYWJ5dGVzKGluZm8sIHVuZGVmaW5lZCwgJ2luZm8nKTtcbiAgICAvLyBmaXJzdCBMKGVuZ3RoKSBvY3RldHMgb2YgVFxuICAgIGNvbnN0IG9rbSA9IG5ldyBVaW50OEFycmF5KGJsb2NrcyAqIG9sZW4pO1xuICAgIC8vIFJlLXVzZSBITUFDIGluc3RhbmNlIGJldHdlZW4gYmxvY2tzXG4gICAgY29uc3QgSE1BQyA9IGhtYWMuY3JlYXRlKGhhc2gsIHByayk7XG4gICAgY29uc3QgSE1BQ1RtcCA9IEhNQUMuX2Nsb25lSW50bygpO1xuICAgIGNvbnN0IFQgPSBuZXcgVWludDhBcnJheShITUFDLm91dHB1dExlbik7XG4gICAgZm9yIChsZXQgY291bnRlciA9IDA7IGNvdW50ZXIgPCBibG9ja3M7IGNvdW50ZXIrKykge1xuICAgICAgICBIS0RGX0NPVU5URVJbMF0gPSBjb3VudGVyICsgMTtcbiAgICAgICAgLy8gVCgwKSA9IGVtcHR5IHN0cmluZyAoemVybyBsZW5ndGgpXG4gICAgICAgIC8vIFQoTikgPSBITUFDLUhhc2goUFJLLCBUKE4tMSkgfCBpbmZvIHwgTilcbiAgICAgICAgSE1BQ1RtcC51cGRhdGUoY291bnRlciA9PT0gMCA/IEVNUFRZX0JVRkZFUiA6IFQpXG4gICAgICAgICAgICAudXBkYXRlKGluZm8pXG4gICAgICAgICAgICAudXBkYXRlKEhLREZfQ09VTlRFUilcbiAgICAgICAgICAgIC5kaWdlc3RJbnRvKFQpO1xuICAgICAgICBva20uc2V0KFQsIG9sZW4gKiBjb3VudGVyKTtcbiAgICAgICAgSE1BQy5fY2xvbmVJbnRvKEhNQUNUbXApO1xuICAgIH1cbiAgICBITUFDLmRlc3Ryb3koKTtcbiAgICBITUFDVG1wLmRlc3Ryb3koKTtcbiAgICBjbGVhbihULCBIS0RGX0NPVU5URVIpO1xuICAgIHJldHVybiBva20uc2xpY2UoMCwgbGVuZ3RoKTtcbn1cbi8qKlxuICogSEtERiAoUkZDIDU4NjkpOiBkZXJpdmUga2V5cyBmcm9tIGFuIGluaXRpYWwgaW5wdXQuXG4gKiBDb21iaW5lcyBoa2RmX2V4dHJhY3QgKyBoa2RmX2V4cGFuZCBpbiBvbmUgc3RlcFxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCAoZS5nLiBzaGEyNTYpXG4gKiBAcGFyYW0gaWttIC0gaW5wdXQga2V5aW5nIG1hdGVyaWFsLCB0aGUgaW5pdGlhbCBrZXlcbiAqIEBwYXJhbSBzYWx0IC0gb3B0aW9uYWwgc2FsdCB2YWx1ZSAoYSBub24tc2VjcmV0IHJhbmRvbSB2YWx1ZSlcbiAqIEBwYXJhbSBpbmZvIC0gb3B0aW9uYWwgY29udGV4dCBhbmQgYXBwbGljYXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb24gKGNhbiBiZSBhIHplcm8tbGVuZ3RoIHN0cmluZylcbiAqIEBwYXJhbSBsZW5ndGggLSBsZW5ndGggb2Ygb3V0cHV0IGtleWluZyBtYXRlcmlhbCBpbiBieXRlc1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhrZGYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2hrZGYnO1xuICogaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyJztcbiAqIGltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG4gKiBjb25zdCBpbnB1dEtleSA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAqIGNvbnN0IHNhbHQgPSByYW5kb21CeXRlcygzMik7XG4gKiBjb25zdCBpbmZvID0gJ2FwcGxpY2F0aW9uLWtleSc7XG4gKiBjb25zdCBoazEgPSBoa2RmKHNoYTI1NiwgaW5wdXRLZXksIHNhbHQsIGluZm8sIDMyKTtcbiAqL1xuZXhwb3J0IGNvbnN0IGhrZGYgPSAoaGFzaCwgaWttLCBzYWx0LCBpbmZvLCBsZW5ndGgpID0+IGV4cGFuZChoYXNoLCBleHRyYWN0KGhhc2gsIGlrbSwgc2FsdCksIGluZm8sIGxlbmd0aCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oa2RmLmpzLm1hcCIsIi8qKlxuICogSW50ZXJuYWwgTWVya2xlLURhbWdhcmQgaGFzaCB1dGlscy5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhb3V0cHV0LCBjbGVhbiwgY3JlYXRlVmlldyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vKiogQ2hvaWNlOiBhID8gYiA6IGMgKi9cbmV4cG9ydCBmdW5jdGlvbiBDaGkoYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKH5hICYgYyk7XG59XG4vKiogTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1dHMgaXMgdHJ1ZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNYWooYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG59XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hNRCB7XG4gICAgYmxvY2tMZW47XG4gICAgb3V0cHV0TGVuO1xuICAgIHBhZE9mZnNldDtcbiAgICBpc0xFO1xuICAgIC8vIEZvciBwYXJ0aWFsIHVwZGF0ZXMgbGVzcyB0aGFuIGJsb2NrIHNpemVcbiAgICBidWZmZXI7XG4gICAgdmlldztcbiAgICBmaW5pc2hlZCA9IGZhbHNlO1xuICAgIGxlbmd0aCA9IDA7XG4gICAgcG9zID0gMDtcbiAgICBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgYWJ5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpblxuICAgICAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgdmlldy5zZXRCaWdVaW50NjQoYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBtdXN0IGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gbXVzdCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fD0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG4vKipcbiAqIEluaXRpYWwgU0hBLTIgc3RhdGU6IGZyYWN0aW9uYWwgcGFydHMgb2Ygc3F1YXJlIHJvb3RzIG9mIGZpcnN0IDE2IHByaW1lcyAyLi41My5cbiAqIENoZWNrIG91dCBgdGVzdC9taXNjL3NoYTItZ2VuLWl2LmpzYCBmb3IgcmVjb21wdXRhdGlvbiBndWlkZS5cbiAqL1xuLyoqIEluaXRpYWwgU0hBMjU2IHN0YXRlLiBCaXRzIDAuLjMyIG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyLi4xOSAqL1xuZXhwb3J0IGNvbnN0IFNIQTI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5LFxuXSk7XG4vKiogSW5pdGlhbCBTSEEyMjQgc3RhdGUuIEJpdHMgMzIuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyMy4uNTMgKi9cbmV4cG9ydCBjb25zdCBTSEEyMjRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSwgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCxcbl0pO1xuLyoqIEluaXRpYWwgU0hBMzg0IHN0YXRlLiBCaXRzIDAuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyMy4uNTMgKi9cbmV4cG9ydCBjb25zdCBTSEEzODRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCwgMHg2MjlhMjkyYSwgMHgzNjdjZDUwNywgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNywgMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSxcbiAgICAweDY3MzMyNjY3LCAweGZmYzAwYjMxLCAweDhlYjQ0YTg3LCAweDY4NTgxNTExLCAweGRiMGMyZTBkLCAweDY0Zjk4ZmE3LCAweDQ3YjU0ODFkLCAweGJlZmE0ZmE0LFxuXSk7XG4vKiogSW5pdGlhbCBTSEE1MTIgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnQgY29uc3QgU0hBNTEyX0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgsIDB4YmI2N2FlODUsIDB4ODRjYWE3M2IsIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsIDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEsXG4gICAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSwgMHg5YjA1Njg4YywgMHgyYjNlNmMxZiwgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YiwgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSxcbl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X21kLmpzLm1hcCIsIi8qKlxuICogSW50ZXJuYWwgaGVscGVycyBmb3IgdTY0LiBCaWdVaW50NjRBcnJheSBpcyB0b28gc2xvdyBhcyBwZXIgMjAyNSwgc28gd2UgaW1wbGVtZW50IGl0IHVzaW5nIFVpbnQzMkFycmF5LlxuICogQHRvZG8gcmUtY2hlY2sgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MjIxMjU4OFxuICogQG1vZHVsZVxuICovXG5jb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0gbHN0Lmxlbmd0aDtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHsgYWRkLCBhZGQzSCwgYWRkM0wsIGFkZDRILCBhZGQ0TCwgYWRkNUgsIGFkZDVMLCBmcm9tQmlnLCByb3RsQkgsIHJvdGxCTCwgcm90bFNILCByb3RsU0wsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdHJCSCwgcm90ckJMLCByb3RyU0gsIHJvdHJTTCwgc2hyU0gsIHNoclNMLCBzcGxpdCwgdG9CaWcgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCIsIi8qKlxuICogU0hBMiBoYXNoIGZ1bmN0aW9uLiBBLmsuYS4gc2hhMjU2LCBzaGEzODQsIHNoYTUxMiwgc2hhNTEyXzIyNCwgc2hhNTEyXzI1Ni5cbiAqIFNIQTI1NiBpcyB0aGUgZmFzdGVzdCBoYXNoIGltcGxlbWVudGFibGUgaW4gSlMsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICogQ2hlY2sgb3V0IFtSRkMgNDYzNF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzQ2MzQpIGFuZFxuICogW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBDaGksIEhhc2hNRCwgTWFqLCBTSEEyMjRfSVYsIFNIQTI1Nl9JViwgU0hBMzg0X0lWLCBTSEE1MTJfSVYgfSBmcm9tIFwiLi9fbWQuanNcIjtcbmltcG9ydCAqIGFzIHU2NCBmcm9tIFwiLi9fdTY0LmpzXCI7XG5pbXBvcnQgeyBjbGVhbiwgY3JlYXRlSGFzaGVyLCBvaWROaXN0LCByb3RyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKlxuICogUm91bmQgY29uc3RhbnRzOlxuICogRmlyc3QgMzIgYml0cyBvZiBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vKiogUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlci4gXCJXXCIgY29tZXMgc3RyYWlnaHQgZnJvbSBzcGVjLiAqL1xuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbi8qKiBJbnRlcm5hbCAzMi1ieXRlIGJhc2UgU0hBMiBoYXNoIGNsYXNzLiAqL1xuY2xhc3MgU0hBMl8zMkIgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dExlbikge1xuICAgICAgICBzdXBlcig2NCwgb3V0cHV0TGVuLCA4LCBmYWxzZSk7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgY2xlYW4oU0hBMjU2X1cpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbi8qKiBJbnRlcm5hbCBTSEEyLTI1NiBoYXNoIGNsYXNzLiAqL1xuZXhwb3J0IGNsYXNzIF9TSEEyNTYgZXh0ZW5kcyBTSEEyXzMyQiB7XG4gICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICBBID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICBCID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICBDID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICBEID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICBFID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICBGID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICBHID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICBIID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMzIpO1xuICAgIH1cbn1cbi8qKiBJbnRlcm5hbCBTSEEyLTIyNCBoYXNoIGNsYXNzLiAqL1xuZXhwb3J0IGNsYXNzIF9TSEEyMjQgZXh0ZW5kcyBTSEEyXzMyQiB7XG4gICAgQSA9IFNIQTIyNF9JVlswXSB8IDA7XG4gICAgQiA9IFNIQTIyNF9JVlsxXSB8IDA7XG4gICAgQyA9IFNIQTIyNF9JVlsyXSB8IDA7XG4gICAgRCA9IFNIQTIyNF9JVlszXSB8IDA7XG4gICAgRSA9IFNIQTIyNF9JVls0XSB8IDA7XG4gICAgRiA9IFNIQTIyNF9JVls1XSB8IDA7XG4gICAgRyA9IFNIQTIyNF9JVls2XSB8IDA7XG4gICAgSCA9IFNIQTIyNF9JVls3XSB8IDA7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICB9XG59XG4vLyBTSEEyLTUxMiBpcyBzbG93ZXIgdGhhbiBzaGEyNTYgaW4ganMgYmVjYXVzZSB1NjQgb3BlcmF0aW9ucyBhcmUgc2xvdy5cbi8vIFJvdW5kIGNvbnRhbnRzXG4vLyBGaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEs1MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG5jb25zdCBTSEE1MTJfS2ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMF0pKCk7XG5jb25zdCBTSEE1MTJfS2wgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMV0pKCk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuLyoqIEludGVybmFsIDY0LWJ5dGUgYmFzZSBTSEEyIGhhc2ggY2xhc3MuICovXG5jbGFzcyBTSEEyXzY0QiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuKSB7XG4gICAgICAgIHN1cGVyKDEyOCwgb3V0cHV0TGVuLCAxNiwgZmFsc2UpO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IHU2NC5yb3RyU0woVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG4gICAgICAgICAgICBjb25zdCBTVU1oID0gdTY0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gdTY0LnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0goRWgsIEVsLCAxOCkgXiB1NjQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IHU2NC5yb3RyU0woRWgsIEVsLCAxNCkgXiB1NjQucm90clNMKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSB1NjQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQuYWRkNUgoVDFsbCwgSGgsIHNpZ21hMWgsIENISWgsIFNIQTUxMl9LaFtpXSwgU0hBNTEyX1dfSFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcbiAgICAgICAgICAgIC8vIFMwIDo9IChhIHJpZ2h0cm90YXRlIDI4KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzQpIHhvciAoYSByaWdodHJvdGF0ZSAzOSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGggPSB1NjQucm90clNIKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gdTY0LnJvdHJTTChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3QgTUFKaCA9IChBaCAmIEJoKSBeIChBaCAmIENoKSBeIChCaCAmIENoKTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmwgPSAoQWwgJiBCbCkgXiAoQWwgJiBDbCkgXiAoQmwgJiBDbCk7XG4gICAgICAgICAgICBIaCA9IEdoIHwgMDtcbiAgICAgICAgICAgIEhsID0gR2wgfCAwO1xuICAgICAgICAgICAgR2ggPSBGaCB8IDA7XG4gICAgICAgICAgICBHbCA9IEZsIHwgMDtcbiAgICAgICAgICAgIEZoID0gRWggfCAwO1xuICAgICAgICAgICAgRmwgPSBFbCB8IDA7XG4gICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IHU2NC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSB1NjQuYWRkM0goQWxsLCBUMWgsIHNpZ21hMGgsIE1BSmgpO1xuICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gdTY0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gdTY0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XG4gICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gdTY0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XG4gICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gdTY0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gdTY0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgY2xlYW4oU0hBNTEyX1dfSCwgU0hBNTEyX1dfTCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFuKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuLyoqIEludGVybmFsIFNIQTItNTEyIGhhc2ggY2xhc3MuICovXG5leHBvcnQgY2xhc3MgX1NIQTUxMiBleHRlbmRzIFNIQTJfNjRCIHtcbiAgICBBaCA9IFNIQTUxMl9JVlswXSB8IDA7XG4gICAgQWwgPSBTSEE1MTJfSVZbMV0gfCAwO1xuICAgIEJoID0gU0hBNTEyX0lWWzJdIHwgMDtcbiAgICBCbCA9IFNIQTUxMl9JVlszXSB8IDA7XG4gICAgQ2ggPSBTSEE1MTJfSVZbNF0gfCAwO1xuICAgIENsID0gU0hBNTEyX0lWWzVdIHwgMDtcbiAgICBEaCA9IFNIQTUxMl9JVls2XSB8IDA7XG4gICAgRGwgPSBTSEE1MTJfSVZbN10gfCAwO1xuICAgIEVoID0gU0hBNTEyX0lWWzhdIHwgMDtcbiAgICBFbCA9IFNIQTUxMl9JVls5XSB8IDA7XG4gICAgRmggPSBTSEE1MTJfSVZbMTBdIHwgMDtcbiAgICBGbCA9IFNIQTUxMl9JVlsxMV0gfCAwO1xuICAgIEdoID0gU0hBNTEyX0lWWzEyXSB8IDA7XG4gICAgR2wgPSBTSEE1MTJfSVZbMTNdIHwgMDtcbiAgICBIaCA9IFNIQTUxMl9JVlsxNF0gfCAwO1xuICAgIEhsID0gU0hBNTEyX0lWWzE1XSB8IDA7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0KTtcbiAgICB9XG59XG4vKiogSW50ZXJuYWwgU0hBMi0zODQgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBfU0hBMzg0IGV4dGVuZHMgU0hBMl82NEIge1xuICAgIEFoID0gU0hBMzg0X0lWWzBdIHwgMDtcbiAgICBBbCA9IFNIQTM4NF9JVlsxXSB8IDA7XG4gICAgQmggPSBTSEEzODRfSVZbMl0gfCAwO1xuICAgIEJsID0gU0hBMzg0X0lWWzNdIHwgMDtcbiAgICBDaCA9IFNIQTM4NF9JVls0XSB8IDA7XG4gICAgQ2wgPSBTSEEzODRfSVZbNV0gfCAwO1xuICAgIERoID0gU0hBMzg0X0lWWzZdIHwgMDtcbiAgICBEbCA9IFNIQTM4NF9JVls3XSB8IDA7XG4gICAgRWggPSBTSEEzODRfSVZbOF0gfCAwO1xuICAgIEVsID0gU0hBMzg0X0lWWzldIHwgMDtcbiAgICBGaCA9IFNIQTM4NF9JVlsxMF0gfCAwO1xuICAgIEZsID0gU0hBMzg0X0lWWzExXSB8IDA7XG4gICAgR2ggPSBTSEEzODRfSVZbMTJdIHwgMDtcbiAgICBHbCA9IFNIQTM4NF9JVlsxM10gfCAwO1xuICAgIEhoID0gU0hBMzg0X0lWWzE0XSB8IDA7XG4gICAgSGwgPSBTSEEzODRfSVZbMTVdIHwgMDtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNDgpO1xuICAgIH1cbn1cbi8qKlxuICogVHJ1bmNhdGVkIFNIQTUxMi8yNTYgYW5kIFNIQTUxMi8yMjQuXG4gKiBTSEE1MTJfSVYgaXMgWE9SZWQgd2l0aCAweGE1YTVhNWE1YTVhNWE1YTUsIHRoZW4gdXNlZCBhcyBcImludGVybWVkaWFyeVwiIElWIG9mIFNIQTUxMi90LlxuICogVGhlbiB0IGhhc2hlcyBzdHJpbmcgdG8gcHJvZHVjZSByZXN1bHQgSVYuXG4gKiBTZWUgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AuXG4gKi9cbi8qKiBTSEE1MTIvMjI0IElWICovXG5jb25zdCBUMjI0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4OGMzZDM3YzgsIDB4MTk1NDRkYTIsIDB4NzNlMTk5NjYsIDB4ODlkY2Q0ZDYsIDB4MWRmYWI3YWUsIDB4MzJmZjljODIsIDB4Njc5ZGQ1MTQsIDB4NTgyZjlmY2YsXG4gICAgMHgwZjZkMmI2OSwgMHg3YmQ0NGRhOCwgMHg3N2UzNmY3MywgMHgwNGM0ODk0MiwgMHgzZjlkODVhOCwgMHg2YTFkMzZjOCwgMHgxMTEyZTZhZCwgMHg5MWQ2OTJhMSxcbl0pO1xuLyoqIFNIQTUxMi8yNTYgSVYgKi9cbmNvbnN0IFQyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHgyMjMxMjE5NCwgMHhmYzJiZjcyYywgMHg5ZjU1NWZhMywgMHhjODRjNjRjMiwgMHgyMzkzYjg2YiwgMHg2ZjUzYjE1MSwgMHg5NjM4NzcxOSwgMHg1OTQwZWFiZCxcbiAgICAweDk2MjgzZWUyLCAweGE4OGVmZmUzLCAweGJlNWUxZTI1LCAweDUzODYzOTkyLCAweDJiMDE5OWZjLCAweDJjODViOGFhLCAweDBlYjcyZGRjLCAweDgxYzUyY2EyLFxuXSk7XG4vKiogSW50ZXJuYWwgU0hBMi01MTIvMjI0IGhhc2ggY2xhc3MuICovXG5leHBvcnQgY2xhc3MgX1NIQTUxMl8yMjQgZXh0ZW5kcyBTSEEyXzY0QiB7XG4gICAgQWggPSBUMjI0X0lWWzBdIHwgMDtcbiAgICBBbCA9IFQyMjRfSVZbMV0gfCAwO1xuICAgIEJoID0gVDIyNF9JVlsyXSB8IDA7XG4gICAgQmwgPSBUMjI0X0lWWzNdIHwgMDtcbiAgICBDaCA9IFQyMjRfSVZbNF0gfCAwO1xuICAgIENsID0gVDIyNF9JVls1XSB8IDA7XG4gICAgRGggPSBUMjI0X0lWWzZdIHwgMDtcbiAgICBEbCA9IFQyMjRfSVZbN10gfCAwO1xuICAgIEVoID0gVDIyNF9JVls4XSB8IDA7XG4gICAgRWwgPSBUMjI0X0lWWzldIHwgMDtcbiAgICBGaCA9IFQyMjRfSVZbMTBdIHwgMDtcbiAgICBGbCA9IFQyMjRfSVZbMTFdIHwgMDtcbiAgICBHaCA9IFQyMjRfSVZbMTJdIHwgMDtcbiAgICBHbCA9IFQyMjRfSVZbMTNdIHwgMDtcbiAgICBIaCA9IFQyMjRfSVZbMTRdIHwgMDtcbiAgICBIbCA9IFQyMjRfSVZbMTVdIHwgMDtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMjgpO1xuICAgIH1cbn1cbi8qKiBJbnRlcm5hbCBTSEEyLTUxMi8yNTYgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBfU0hBNTEyXzI1NiBleHRlbmRzIFNIQTJfNjRCIHtcbiAgICBBaCA9IFQyNTZfSVZbMF0gfCAwO1xuICAgIEFsID0gVDI1Nl9JVlsxXSB8IDA7XG4gICAgQmggPSBUMjU2X0lWWzJdIHwgMDtcbiAgICBCbCA9IFQyNTZfSVZbM10gfCAwO1xuICAgIENoID0gVDI1Nl9JVls0XSB8IDA7XG4gICAgQ2wgPSBUMjU2X0lWWzVdIHwgMDtcbiAgICBEaCA9IFQyNTZfSVZbNl0gfCAwO1xuICAgIERsID0gVDI1Nl9JVls3XSB8IDA7XG4gICAgRWggPSBUMjU2X0lWWzhdIHwgMDtcbiAgICBFbCA9IFQyNTZfSVZbOV0gfCAwO1xuICAgIEZoID0gVDI1Nl9JVlsxMF0gfCAwO1xuICAgIEZsID0gVDI1Nl9JVlsxMV0gfCAwO1xuICAgIEdoID0gVDI1Nl9JVlsxMl0gfCAwO1xuICAgIEdsID0gVDI1Nl9JVlsxM10gfCAwO1xuICAgIEhoID0gVDI1Nl9JVlsxNF0gfCAwO1xuICAgIEhsID0gVDI1Nl9JVlsxNV0gfCAwO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigzMik7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuIEluIEpTIGl0J3MgdGhlIGZhc3Rlc3Q6IGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLiBTb21lIGluZm86XG4gKlxuICogLSBUcnlpbmcgMl4xMjggaGFzaGVzIHdvdWxkIGdldCA1MCUgY2hhbmNlIG9mIGNvbGxpc2lvbiwgdXNpbmcgYmlydGhkYXkgYXR0YWNrLlxuICogLSBCVEMgbmV0d29yayBpcyBkb2luZyAyXjcwIGhhc2hlcy9zZWMgKDJeOTUgaGFzaGVzL3llYXIpIGFzIHBlciAyMDI1LlxuICogLSBFYWNoIHNoYTI1NiBoYXNoIGlzIGV4ZWN1dGluZyAyXjE4IGJpdCBvcGVyYXRpb25zLlxuICogLSBHb29kIDIwMjQgQVNJQ3MgY2FuIGRvIDIwMFRoL3NlYyB3aXRoIDM1MDAgd2F0dHMgb2YgcG93ZXIsIGNvcnJlc3BvbmRpbmcgdG8gMl4zNiBoYXNoZXMvam91bGUuXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBfU0hBMjU2KCksIFxuLyogQF9fUFVSRV9fICovIG9pZE5pc3QoMHgwMSkpO1xuLyoqIFNIQTItMjI0IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNCAqL1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IF9TSEEyMjQoKSwgXG4vKiBAX19QVVJFX18gKi8gb2lkTmlzdCgweDA0KSk7XG4vKiogU0hBMi01MTIgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IF9TSEE1MTIoKSwgXG4vKiBAX19QVVJFX18gKi8gb2lkTmlzdCgweDAzKSk7XG4vKiogU0hBMi0zODQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0IGNvbnN0IHNoYTM4NCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IF9TSEEzODQoKSwgXG4vKiBAX19QVVJFX18gKi8gb2lkTmlzdCgweDAyKSk7XG4vKipcbiAqIFNIQTItNTEyLzI1NiBcInRydW5jYXRlZFwiIGhhc2ggZnVuY3Rpb24sIHdpdGggaW1wcm92ZWQgcmVzaXN0YW5jZSB0byBsZW5ndGggZXh0ZW5zaW9uIGF0dGFja3MuXG4gKiBTZWUgdGhlIHBhcGVyIG9uIFt0cnVuY2F0ZWQgU0hBNTEyXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzU0OC5wZGYpLlxuICovXG5leHBvcnQgY29uc3Qgc2hhNTEyXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IF9TSEE1MTJfMjU2KCksIFxuLyogQF9fUFVSRV9fICovIG9pZE5pc3QoMHgwNikpO1xuLyoqXG4gKiBTSEEyLTUxMi8yMjQgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yMjQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBfU0hBNTEyXzIyNCgpLCBcbi8qIEBfX1BVUkVfXyAqLyBvaWROaXN0KDB4MDUpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTIuanMubWFwIiwiLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXJzIGZvciBibGFrZSBoYXNoLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyByb3RyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKlxuICogSW50ZXJuYWwgYmxha2UgdmFyaWFibGUuXG4gKiBGb3IgQkxBS0UyYiwgdGhlIHR3byBleHRyYSBwZXJtdXRhdGlvbnMgZm9yIHJvdW5kcyAxMCBhbmQgMTEgYXJlIFNJR01BWzEwLi4xMV0gPSBTSUdNQVswLi4xXS5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgQlNJR01BID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzLFxuICAgIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDQsXG4gICAgNywgOSwgMywgMSwgMTMsIDEyLCAxMSwgMTQsIDIsIDYsIDUsIDEwLCA0LCAwLCAxNSwgOCxcbiAgICA5LCAwLCA1LCA3LCAyLCA0LCAxMCwgMTUsIDE0LCAxLCAxMSwgMTIsIDYsIDgsIDMsIDEzLFxuICAgIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDksXG4gICAgMTIsIDUsIDEsIDE1LCAxNCwgMTMsIDQsIDEwLCAwLCA3LCA2LCAzLCA5LCAyLCA4LCAxMSxcbiAgICAxMywgMTEsIDcsIDE0LCAxMiwgMSwgMywgOSwgNSwgMCwgMTUsIDQsIDgsIDYsIDIsIDEwLFxuICAgIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsXG4gICAgMTAsIDIsIDgsIDQsIDcsIDYsIDEsIDUsIDE1LCAxMSwgOSwgMTQsIDMsIDEyLCAxMywgMCxcbiAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAgIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG4gICAgLy8gQmxha2UxLCB1bnVzZWQgaW4gb3RoZXJzXG4gICAgMTEsIDgsIDEyLCAwLCA1LCAyLCAxNSwgMTMsIDEwLCAxNCwgMywgNiwgNywgMSwgOSwgNCxcbiAgICA3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4LFxuICAgIDksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsXG4gICAgMiwgMTIsIDYsIDEwLCAwLCAxMSwgOCwgMywgNCwgMTMsIDcsIDUsIDE1LCAxNCwgMSwgOSxcbl0pO1xuLy8gTWl4aW5nIGZ1bmN0aW9uIEcgc3BsaXR0ZWQgaW4gdHdvIGhhbGZzXG5leHBvcnQgZnVuY3Rpb24gRzFzKGEsIGIsIGMsIGQsIHgpIHtcbiAgICBhID0gKGEgKyBiICsgeCkgfCAwO1xuICAgIGQgPSByb3RyKGQgXiBhLCAxNik7XG4gICAgYyA9IChjICsgZCkgfCAwO1xuICAgIGIgPSByb3RyKGIgXiBjLCAxMik7XG4gICAgcmV0dXJuIHsgYSwgYiwgYywgZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEcycyhhLCBiLCBjLCBkLCB4KSB7XG4gICAgYSA9IChhICsgYiArIHgpIHwgMDtcbiAgICBkID0gcm90cihkIF4gYSwgOCk7XG4gICAgYyA9IChjICsgZCkgfCAwO1xuICAgIGIgPSByb3RyKGIgXiBjLCA3KTtcbiAgICByZXR1cm4geyBhLCBiLCBjLCBkIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYmxha2UuanMubWFwIiwiLyoqXG4gKiBibGFrZTJiICg2NC1iaXQpICYgYmxha2UycyAoOCB0byAzMi1iaXQpIGhhc2ggZnVuY3Rpb25zLlxuICogYiBjb3VsZCBoYXZlIGJlZW4gZmFzdGVyLCBidXQgdGhlcmUgaXMgbm8gZmFzdCB1NjQgaW4ganMsIHNvIHMgaXMgMS41eCBmYXN0ZXIuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IEJTSUdNQSwgRzFzLCBHMnMgfSBmcm9tIFwiLi9fYmxha2UuanNcIjtcbmltcG9ydCB7IFNIQTI1Nl9JViB9IGZyb20gXCIuL19tZC5qc1wiO1xuaW1wb3J0ICogYXMgdTY0IGZyb20gXCIuL191NjQuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhbnVtYmVyLCBhb3V0cHV0LCBjbGVhbiwgY3JlYXRlSGFzaGVyLCBzd2FwMzJJZkJFLCBzd2FwOElmQkUsIHUzMiB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vLyBTYW1lIGFzIFNIQTUxMl9JViwgYnV0IHN3YXBwZWQgZW5kaWFubmVzczogTEUgaW5zdGVhZCBvZiBCRS4gaXZbMV0gaXMgaXZbMF0sIGV0Yy5cbmNvbnN0IEIyQl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGYzYmNjOTA4LCAweDZhMDllNjY3LCAweDg0Y2FhNzNiLCAweGJiNjdhZTg1LCAweGZlOTRmODJiLCAweDNjNmVmMzcyLCAweDVmMWQzNmYxLCAweGE1NGZmNTNhLFxuICAgIDB4YWRlNjgyZDEsIDB4NTEwZTUyN2YsIDB4MmIzZTZjMWYsIDB4OWIwNTY4OGMsIDB4ZmI0MWJkNmIsIDB4MWY4M2Q5YWIsIDB4MTM3ZTIxNzksIDB4NWJlMGNkMTksXG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXJcbmNvbnN0IEJCVUYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDMyKTtcbi8vIE1peGluZyBmdW5jdGlvbiBHIHNwbGl0dGVkIGluIHR3byBoYWxmc1xuZnVuY3Rpb24gRzFiKGEsIGIsIGMsIGQsIG1zZywgeCkge1xuICAgIC8vIE5PVEU6IFYgaXMgTEUgaGVyZVxuICAgIGNvbnN0IFhsID0gbXNnW3hdLCBYaCA9IG1zZ1t4ICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBBbCA9IEJCVUZbMiAqIGFdLCBBaCA9IEJCVUZbMiAqIGEgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IEJsID0gQkJVRlsyICogYl0sIEJoID0gQkJVRlsyICogYiArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgQ2wgPSBCQlVGWzIgKiBjXSwgQ2ggPSBCQlVGWzIgKiBjICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBEbCA9IEJCVUZbMiAqIGRdLCBEaCA9IEJCVUZbMiAqIGQgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgLy8gdlthXSA9ICh2W2FdICsgdltiXSArIHgpIHwgMDtcbiAgICBsZXQgbGwgPSB1NjQuYWRkM0woQWwsIEJsLCBYbCk7XG4gICAgQWggPSB1NjQuYWRkM0gobGwsIEFoLCBCaCwgWGgpO1xuICAgIEFsID0gbGwgfCAwO1xuICAgIC8vIHZbZF0gPSByb3RyKHZbZF0gXiB2W2FdLCAzMilcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IERoIF4gQWgsIERsOiBEbCBeIEFsIH0pO1xuICAgICh7IERoLCBEbCB9ID0geyBEaDogdTY0LnJvdHIzMkgoRGgsIERsKSwgRGw6IHU2NC5yb3RyMzJMKERoLCBEbCkgfSk7XG4gICAgLy8gdltjXSA9ICh2W2NdICsgdltkXSkgfCAwO1xuICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZChDaCwgQ2wsIERoLCBEbCkpO1xuICAgIC8vIHZbYl0gPSByb3RyKHZbYl0gXiB2W2NdLCAyNClcbiAgICAoeyBCaCwgQmwgfSA9IHsgQmg6IEJoIF4gQ2gsIEJsOiBCbCBeIENsIH0pO1xuICAgICh7IEJoLCBCbCB9ID0geyBCaDogdTY0LnJvdHJTSChCaCwgQmwsIDI0KSwgQmw6IHU2NC5yb3RyU0woQmgsIEJsLCAyNCkgfSk7XG4gICAgKChCQlVGWzIgKiBhXSA9IEFsKSwgKEJCVUZbMiAqIGEgKyAxXSA9IEFoKSk7XG4gICAgKChCQlVGWzIgKiBiXSA9IEJsKSwgKEJCVUZbMiAqIGIgKyAxXSA9IEJoKSk7XG4gICAgKChCQlVGWzIgKiBjXSA9IENsKSwgKEJCVUZbMiAqIGMgKyAxXSA9IENoKSk7XG4gICAgKChCQlVGWzIgKiBkXSA9IERsKSwgKEJCVUZbMiAqIGQgKyAxXSA9IERoKSk7XG59XG5mdW5jdGlvbiBHMmIoYSwgYiwgYywgZCwgbXNnLCB4KSB7XG4gICAgLy8gTk9URTogViBpcyBMRSBoZXJlXG4gICAgY29uc3QgWGwgPSBtc2dbeF0sIFhoID0gbXNnW3ggKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IEFsID0gQkJVRlsyICogYV0sIEFoID0gQkJVRlsyICogYSArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgQmwgPSBCQlVGWzIgKiBiXSwgQmggPSBCQlVGWzIgKiBiICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBDbCA9IEJCVUZbMiAqIGNdLCBDaCA9IEJCVUZbMiAqIGMgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IERsID0gQkJVRlsyICogZF0sIERoID0gQkJVRlsyICogZCArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAvLyB2W2FdID0gKHZbYV0gKyB2W2JdICsgeCkgfCAwO1xuICAgIGxldCBsbCA9IHU2NC5hZGQzTChBbCwgQmwsIFhsKTtcbiAgICBBaCA9IHU2NC5hZGQzSChsbCwgQWgsIEJoLCBYaCk7XG4gICAgQWwgPSBsbCB8IDA7XG4gICAgLy8gdltkXSA9IHJvdHIodltkXSBeIHZbYV0sIDE2KVxuICAgICh7IERoLCBEbCB9ID0geyBEaDogRGggXiBBaCwgRGw6IERsIF4gQWwgfSk7XG4gICAgKHsgRGgsIERsIH0gPSB7IERoOiB1NjQucm90clNIKERoLCBEbCwgMTYpLCBEbDogdTY0LnJvdHJTTChEaCwgRGwsIDE2KSB9KTtcbiAgICAvLyB2W2NdID0gKHZbY10gKyB2W2RdKSB8IDA7XG4gICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKENoLCBDbCwgRGgsIERsKSk7XG4gICAgLy8gdltiXSA9IHJvdHIodltiXSBeIHZbY10sIDYzKVxuICAgICh7IEJoLCBCbCB9ID0geyBCaDogQmggXiBDaCwgQmw6IEJsIF4gQ2wgfSk7XG4gICAgKHsgQmgsIEJsIH0gPSB7IEJoOiB1NjQucm90ckJIKEJoLCBCbCwgNjMpLCBCbDogdTY0LnJvdHJCTChCaCwgQmwsIDYzKSB9KTtcbiAgICAoKEJCVUZbMiAqIGFdID0gQWwpLCAoQkJVRlsyICogYSArIDFdID0gQWgpKTtcbiAgICAoKEJCVUZbMiAqIGJdID0gQmwpLCAoQkJVRlsyICogYiArIDFdID0gQmgpKTtcbiAgICAoKEJCVUZbMiAqIGNdID0gQ2wpLCAoQkJVRlsyICogYyArIDFdID0gQ2gpKTtcbiAgICAoKEJCVUZbMiAqIGRdID0gRGwpLCAoQkJVRlsyICogZCArIDFdID0gRGgpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQmxha2UyT3B0cyhvdXRwdXRMZW4sIG9wdHMgPSB7fSwga2V5TGVuLCBzYWx0TGVuLCBwZXJzTGVuKSB7XG4gICAgYW51bWJlcihrZXlMZW4pO1xuICAgIGlmIChvdXRwdXRMZW4gPCAwIHx8IG91dHB1dExlbiA+IGtleUxlbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRMZW4gYmlnZ2VyIHRoYW4ga2V5TGVuJyk7XG4gICAgY29uc3QgeyBrZXksIHNhbHQsIHBlcnNvbmFsaXphdGlvbiB9ID0gb3B0cztcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgKGtleS5sZW5ndGggPCAxIHx8IGtleS5sZW5ndGggPiBrZXlMZW4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wia2V5XCIgZXhwZWN0ZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG9mIGxlbmd0aD0xLi4nICsga2V5TGVuKTtcbiAgICBpZiAoc2FsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhYnl0ZXMoc2FsdCwgc2FsdExlbiwgJ3NhbHQnKTtcbiAgICBpZiAocGVyc29uYWxpemF0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFieXRlcyhwZXJzb25hbGl6YXRpb24sIHBlcnNMZW4sICdwZXJzb25hbGl6YXRpb24nKTtcbn1cbi8qKiBJbnRlcm5hbCBiYXNlIGNsYXNzIGZvciBCTEFLRTIuICovXG5leHBvcnQgY2xhc3MgX0JMQUtFMiB7XG4gICAgYnVmZmVyO1xuICAgIGJ1ZmZlcjMyO1xuICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgZGVzdHJveWVkID0gZmFsc2U7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBwb3MgPSAwO1xuICAgIGJsb2NrTGVuO1xuICAgIG91dHB1dExlbjtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuKSB7XG4gICAgICAgIGFudW1iZXIoYmxvY2tMZW4pO1xuICAgICAgICBhbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLmJ1ZmZlcjMyID0gdTMyKHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgYWJ5dGVzKGRhdGEpO1xuICAgICAgICAvLyBNYWluIGRpZmZlcmVuY2Ugd2l0aCBvdGhlciBoYXNoZXM6IHRoZXJlIGlzIGZsYWcgZm9yIGxhc3QgYmxvY2ssXG4gICAgICAgIC8vIHNvIHdlIGNhbm5vdCBwcm9jZXNzIGN1cnJlbnQgYmxvY2sgYmVmb3JlIHdlIGtub3cgdGhhdCB0aGVyZVxuICAgICAgICAvLyBpcyB0aGUgbmV4dCBvbmUuIFRoaXMgc2lnbmlmaWNhbnRseSBjb21wbGljYXRlcyBsb2dpYyBhbmQgcmVkdWNlcyBhYmlsaXR5XG4gICAgICAgIC8vIHRvIGRvIHplcm8tY29weSBwcm9jZXNzaW5nXG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgYnVmZmVyMzIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGEuYnVmZmVyO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICAvLyBJZiBidWZmZXIgaXMgZnVsbCBhbmQgd2Ugc3RpbGwgaGF2ZSBpbnB1dCAoZG9uJ3QgcHJvY2VzcyBsYXN0IGJsb2NrLCBzYW1lIGFzIGJsYWtlMnMpXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgc3dhcDMySWZCRShidWZmZXIzMik7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzcyhidWZmZXIzMiwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN3YXAzMklmQkUoYnVmZmVyMzIpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgY29uc3QgZGF0YU9mZnNldCA9IG9mZnNldCArIHBvcztcbiAgICAgICAgICAgIC8vIGZ1bGwgYmxvY2sgJiYgYWxpZ25lZCB0byA0IGJ5dGVzICYmIG5vdCBsYXN0IGluIGlucHV0XG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4gJiYgIShkYXRhT2Zmc2V0ICUgNCkgJiYgcG9zICsgdGFrZSA8IGxlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEzMiA9IG5ldyBVaW50MzJBcnJheShidWYsIGRhdGFPZmZzZXQsIE1hdGguZmxvb3IoKGxlbiAtIHBvcykgLyA0KSk7XG4gICAgICAgICAgICAgICAgc3dhcDMySWZCRShkYXRhMzIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvczMyID0gMDsgcG9zICsgYmxvY2tMZW4gPCBsZW47IHBvczMyICs9IGJ1ZmZlcjMyLmxlbmd0aCwgcG9zICs9IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IGJsb2NrTGVuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzKGRhdGEzMiwgcG9zMzIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dhcDMySWZCRShkYXRhMzIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgY29uc3QgeyBwb3MsIGJ1ZmZlcjMyIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpKTtcbiAgICAgICAgc3dhcDMySWZCRShidWZmZXIzMik7XG4gICAgICAgIHRoaXMuY29tcHJlc3MoYnVmZmVyMzIsIDAsIHRydWUpO1xuICAgICAgICBzd2FwMzJJZkJFKGJ1ZmZlcjMyKTtcbiAgICAgICAgY29uc3Qgb3V0MzIgPSB1MzIob3V0KTtcbiAgICAgICAgdGhpcy5nZXQoKS5mb3JFYWNoKCh2LCBpKSA9PiAob3V0MzJbaV0gPSBzd2FwOElmQkUodikpKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIG91dHB1dExlbiwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0byB8fD0gbmV3IHRoaXMuY29uc3RydWN0b3IoeyBka0xlbjogb3V0cHV0TGVuIH0pO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG4vKiogSW50ZXJuYWwgYmxha2UyYiBoYXNoIGNsYXNzLiAqL1xuZXhwb3J0IGNsYXNzIF9CTEFLRTJiIGV4dGVuZHMgX0JMQUtFMiB7XG4gICAgLy8gU2FtZSBhcyBTSEEtNTEyLCBidXQgTEVcbiAgICB2MGwgPSBCMkJfSVZbMF0gfCAwO1xuICAgIHYwaCA9IEIyQl9JVlsxXSB8IDA7XG4gICAgdjFsID0gQjJCX0lWWzJdIHwgMDtcbiAgICB2MWggPSBCMkJfSVZbM10gfCAwO1xuICAgIHYybCA9IEIyQl9JVls0XSB8IDA7XG4gICAgdjJoID0gQjJCX0lWWzVdIHwgMDtcbiAgICB2M2wgPSBCMkJfSVZbNl0gfCAwO1xuICAgIHYzaCA9IEIyQl9JVls3XSB8IDA7XG4gICAgdjRsID0gQjJCX0lWWzhdIHwgMDtcbiAgICB2NGggPSBCMkJfSVZbOV0gfCAwO1xuICAgIHY1bCA9IEIyQl9JVlsxMF0gfCAwO1xuICAgIHY1aCA9IEIyQl9JVlsxMV0gfCAwO1xuICAgIHY2bCA9IEIyQl9JVlsxMl0gfCAwO1xuICAgIHY2aCA9IEIyQl9JVlsxM10gfCAwO1xuICAgIHY3bCA9IEIyQl9JVlsxNF0gfCAwO1xuICAgIHY3aCA9IEIyQl9JVlsxNV0gfCAwO1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBvbGVuID0gb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gNjQgOiBvcHRzLmRrTGVuO1xuICAgICAgICBzdXBlcigxMjgsIG9sZW4pO1xuICAgICAgICBjaGVja0JsYWtlMk9wdHMob2xlbiwgb3B0cywgNjQsIDE2LCAxNik7XG4gICAgICAgIGxldCB7IGtleSwgcGVyc29uYWxpemF0aW9uLCBzYWx0IH0gPSBvcHRzO1xuICAgICAgICBsZXQga2V5TGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYnl0ZXMoa2V5LCB1bmRlZmluZWQsICdrZXknKTtcbiAgICAgICAgICAgIGtleUxlbmd0aCA9IGtleS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52MGwgXj0gdGhpcy5vdXRwdXRMZW4gfCAoa2V5TGVuZ3RoIDw8IDgpIHwgKDB4MDEgPDwgMTYpIHwgKDB4MDEgPDwgMjQpO1xuICAgICAgICBpZiAoc2FsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYnl0ZXMoc2FsdCwgdW5kZWZpbmVkLCAnc2FsdCcpO1xuICAgICAgICAgICAgY29uc3Qgc2x0ID0gdTMyKHNhbHQpO1xuICAgICAgICAgICAgdGhpcy52NGwgXj0gc3dhcDhJZkJFKHNsdFswXSk7XG4gICAgICAgICAgICB0aGlzLnY0aCBePSBzd2FwOElmQkUoc2x0WzFdKTtcbiAgICAgICAgICAgIHRoaXMudjVsIF49IHN3YXA4SWZCRShzbHRbMl0pO1xuICAgICAgICAgICAgdGhpcy52NWggXj0gc3dhcDhJZkJFKHNsdFszXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcnNvbmFsaXphdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYnl0ZXMocGVyc29uYWxpemF0aW9uLCB1bmRlZmluZWQsICdwZXJzb25hbGl6YXRpb24nKTtcbiAgICAgICAgICAgIGNvbnN0IHBlcnMgPSB1MzIocGVyc29uYWxpemF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudjZsIF49IHN3YXA4SWZCRShwZXJzWzBdKTtcbiAgICAgICAgICAgIHRoaXMudjZoIF49IHN3YXA4SWZCRShwZXJzWzFdKTtcbiAgICAgICAgICAgIHRoaXMudjdsIF49IHN3YXA4SWZCRShwZXJzWzJdKTtcbiAgICAgICAgICAgIHRoaXMudjdoIF49IHN3YXA4SWZCRShwZXJzWzNdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFBhZCB0byBibG9ja0xlbiBhbmQgdXBkYXRlXG4gICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuKTtcbiAgICAgICAgICAgIHRtcC5zZXQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRtcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBsZXQgeyB2MGwsIHYwaCwgdjFsLCB2MWgsIHYybCwgdjJoLCB2M2wsIHYzaCwgdjRsLCB2NGgsIHY1bCwgdjVoLCB2NmwsIHY2aCwgdjdsLCB2N2ggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbdjBsLCB2MGgsIHYxbCwgdjFoLCB2MmwsIHYyaCwgdjNsLCB2M2gsIHY0bCwgdjRoLCB2NWwsIHY1aCwgdjZsLCB2NmgsIHY3bCwgdjdoXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KHYwbCwgdjBoLCB2MWwsIHYxaCwgdjJsLCB2MmgsIHYzbCwgdjNoLCB2NGwsIHY0aCwgdjVsLCB2NWgsIHY2bCwgdjZoLCB2N2wsIHY3aCkge1xuICAgICAgICB0aGlzLnYwbCA9IHYwbCB8IDA7XG4gICAgICAgIHRoaXMudjBoID0gdjBoIHwgMDtcbiAgICAgICAgdGhpcy52MWwgPSB2MWwgfCAwO1xuICAgICAgICB0aGlzLnYxaCA9IHYxaCB8IDA7XG4gICAgICAgIHRoaXMudjJsID0gdjJsIHwgMDtcbiAgICAgICAgdGhpcy52MmggPSB2MmggfCAwO1xuICAgICAgICB0aGlzLnYzbCA9IHYzbCB8IDA7XG4gICAgICAgIHRoaXMudjNoID0gdjNoIHwgMDtcbiAgICAgICAgdGhpcy52NGwgPSB2NGwgfCAwO1xuICAgICAgICB0aGlzLnY0aCA9IHY0aCB8IDA7XG4gICAgICAgIHRoaXMudjVsID0gdjVsIHwgMDtcbiAgICAgICAgdGhpcy52NWggPSB2NWggfCAwO1xuICAgICAgICB0aGlzLnY2bCA9IHY2bCB8IDA7XG4gICAgICAgIHRoaXMudjZoID0gdjZoIHwgMDtcbiAgICAgICAgdGhpcy52N2wgPSB2N2wgfCAwO1xuICAgICAgICB0aGlzLnY3aCA9IHY3aCB8IDA7XG4gICAgfVxuICAgIGNvbXByZXNzKG1zZywgb2Zmc2V0LCBpc0xhc3QpIHtcbiAgICAgICAgdGhpcy5nZXQoKS5mb3JFYWNoKCh2LCBpKSA9PiAoQkJVRltpXSA9IHYpKTsgLy8gRmlyc3QgaGFsZiBmcm9tIHN0YXRlLlxuICAgICAgICBCQlVGLnNldChCMkJfSVYsIDE2KTsgLy8gU2Vjb25kIGhhbGYgZnJvbSBJVi5cbiAgICAgICAgbGV0IHsgaCwgbCB9ID0gdTY0LmZyb21CaWcoQmlnSW50KHRoaXMubGVuZ3RoKSk7XG4gICAgICAgIEJCVUZbMjRdID0gQjJCX0lWWzhdIF4gbDsgLy8gTG93IHdvcmQgb2YgdGhlIG9mZnNldC5cbiAgICAgICAgQkJVRlsyNV0gPSBCMkJfSVZbOV0gXiBoOyAvLyBIaWdoIHdvcmQuXG4gICAgICAgIC8vIEludmVydCBhbGwgYml0cyBmb3IgbGFzdCBibG9ja1xuICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICBCQlVGWzI4XSA9IH5CQlVGWzI4XTtcbiAgICAgICAgICAgIEJCVUZbMjldID0gfkJCVUZbMjldO1xuICAgICAgICB9XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgY29uc3QgcyA9IEJTSUdNQTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBHMWIoMCwgNCwgOCwgMTIsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMmIoMCwgNCwgOCwgMTIsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMWIoMSwgNSwgOSwgMTMsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMmIoMSwgNSwgOSwgMTMsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMWIoMiwgNiwgMTAsIDE0LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzJiKDIsIDYsIDEwLCAxNCwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcxYigzLCA3LCAxMSwgMTUsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMmIoMywgNywgMTEsIDE1LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzFiKDAsIDUsIDEwLCAxNSwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyYigwLCA1LCAxMCwgMTUsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMWIoMSwgNiwgMTEsIDEyLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzJiKDEsIDYsIDExLCAxMiwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcxYigyLCA3LCA4LCAxMywgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyYigyLCA3LCA4LCAxMywgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcxYigzLCA0LCA5LCAxNCwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyYigzLCA0LCA5LCAxNCwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnYwbCBePSBCQlVGWzBdIF4gQkJVRlsxNl07XG4gICAgICAgIHRoaXMudjBoIF49IEJCVUZbMV0gXiBCQlVGWzE3XTtcbiAgICAgICAgdGhpcy52MWwgXj0gQkJVRlsyXSBeIEJCVUZbMThdO1xuICAgICAgICB0aGlzLnYxaCBePSBCQlVGWzNdIF4gQkJVRlsxOV07XG4gICAgICAgIHRoaXMudjJsIF49IEJCVUZbNF0gXiBCQlVGWzIwXTtcbiAgICAgICAgdGhpcy52MmggXj0gQkJVRls1XSBeIEJCVUZbMjFdO1xuICAgICAgICB0aGlzLnYzbCBePSBCQlVGWzZdIF4gQkJVRlsyMl07XG4gICAgICAgIHRoaXMudjNoIF49IEJCVUZbN10gXiBCQlVGWzIzXTtcbiAgICAgICAgdGhpcy52NGwgXj0gQkJVRls4XSBeIEJCVUZbMjRdO1xuICAgICAgICB0aGlzLnY0aCBePSBCQlVGWzldIF4gQkJVRlsyNV07XG4gICAgICAgIHRoaXMudjVsIF49IEJCVUZbMTBdIF4gQkJVRlsyNl07XG4gICAgICAgIHRoaXMudjVoIF49IEJCVUZbMTFdIF4gQkJVRlsyN107XG4gICAgICAgIHRoaXMudjZsIF49IEJCVUZbMTJdIF4gQkJVRlsyOF07XG4gICAgICAgIHRoaXMudjZoIF49IEJCVUZbMTNdIF4gQkJVRlsyOV07XG4gICAgICAgIHRoaXMudjdsIF49IEJCVUZbMTRdIF4gQkJVRlszMF07XG4gICAgICAgIHRoaXMudjdoIF49IEJCVUZbMTVdIF4gQkJVRlszMV07XG4gICAgICAgIGNsZWFuKEJCVUYpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIGNsZWFuKHRoaXMuYnVmZmVyMzIpO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG4vKipcbiAqIEJsYWtlMmIgaGFzaCBmdW5jdGlvbi4gNjQtYml0LiAxLjV4IHNsb3dlciB0aGFuIGJsYWtlMnMgaW4gSlMuXG4gKiBAcGFyYW0gbXNnIC0gbWVzc2FnZSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICogQHBhcmFtIG9wdHMgLSBka0xlbiBvdXRwdXQgbGVuZ3RoLCBrZXkgZm9yIE1BQyBtb2RlLCBzYWx0LCBwZXJzb25hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGJsYWtlMmIgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKChvcHRzKSA9PiBuZXcgX0JMQUtFMmIob3B0cykpO1xuLyoqIEJMQUtFMi1jb21wcmVzcyBjb3JlIG1ldGhvZC4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXByZXNzKHMsIG9mZnNldCwgbXNnLCByb3VuZHMsIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5LCB2MTAsIHYxMSwgdjEyLCB2MTMsIHYxNCwgdjE1KSB7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmRzOyBpKyspIHtcbiAgICAgICAgKHsgYTogdjAsIGI6IHY0LCBjOiB2OCwgZDogdjEyIH0gPSBHMXModjAsIHY0LCB2OCwgdjEyLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MCwgYjogdjQsIGM6IHY4LCBkOiB2MTIgfSA9IEcycyh2MCwgdjQsIHY4LCB2MTIsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYxLCBiOiB2NSwgYzogdjksIGQ6IHYxMyB9ID0gRzFzKHYxLCB2NSwgdjksIHYxMywgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjEsIGI6IHY1LCBjOiB2OSwgZDogdjEzIH0gPSBHMnModjEsIHY1LCB2OSwgdjEzLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MiwgYjogdjYsIGM6IHYxMCwgZDogdjE0IH0gPSBHMXModjIsIHY2LCB2MTAsIHYxNCwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjIsIGI6IHY2LCBjOiB2MTAsIGQ6IHYxNCB9ID0gRzJzKHYyLCB2NiwgdjEwLCB2MTQsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYzLCBiOiB2NywgYzogdjExLCBkOiB2MTUgfSA9IEcxcyh2MywgdjcsIHYxMSwgdjE1LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MywgYjogdjcsIGM6IHYxMSwgZDogdjE1IH0gPSBHMnModjMsIHY3LCB2MTEsIHYxNSwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjAsIGI6IHY1LCBjOiB2MTAsIGQ6IHYxNSB9ID0gRzFzKHYwLCB2NSwgdjEwLCB2MTUsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYwLCBiOiB2NSwgYzogdjEwLCBkOiB2MTUgfSA9IEcycyh2MCwgdjUsIHYxMCwgdjE1LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MSwgYjogdjYsIGM6IHYxMSwgZDogdjEyIH0gPSBHMXModjEsIHY2LCB2MTEsIHYxMiwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjEsIGI6IHY2LCBjOiB2MTEsIGQ6IHYxMiB9ID0gRzJzKHYxLCB2NiwgdjExLCB2MTIsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYyLCBiOiB2NywgYzogdjgsIGQ6IHYxMyB9ID0gRzFzKHYyLCB2NywgdjgsIHYxMywgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjIsIGI6IHY3LCBjOiB2OCwgZDogdjEzIH0gPSBHMnModjIsIHY3LCB2OCwgdjEzLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MywgYjogdjQsIGM6IHY5LCBkOiB2MTQgfSA9IEcxcyh2MywgdjQsIHY5LCB2MTQsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYzLCBiOiB2NCwgYzogdjksIGQ6IHYxNCB9ID0gRzJzKHYzLCB2NCwgdjksIHYxNCwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjksIHYxMCwgdjExLCB2MTIsIHYxMywgdjE0LCB2MTUgfTtcbn1cbmNvbnN0IEIyU19JViA9IC8qIEBfX1BVUkVfXyAqLyBTSEEyNTZfSVYuc2xpY2UoKTtcbi8qKiBJbnRlcm5hbCBibGFrZTJzIGhhc2ggY2xhc3MuICovXG5leHBvcnQgY2xhc3MgX0JMQUtFMnMgZXh0ZW5kcyBfQkxBS0UyIHtcbiAgICAvLyBJbnRlcm5hbCBzdGF0ZSwgc2FtZSBhcyBTSEEtMjU2XG4gICAgdjAgPSBCMlNfSVZbMF0gfCAwO1xuICAgIHYxID0gQjJTX0lWWzFdIHwgMDtcbiAgICB2MiA9IEIyU19JVlsyXSB8IDA7XG4gICAgdjMgPSBCMlNfSVZbM10gfCAwO1xuICAgIHY0ID0gQjJTX0lWWzRdIHwgMDtcbiAgICB2NSA9IEIyU19JVls1XSB8IDA7XG4gICAgdjYgPSBCMlNfSVZbNl0gfCAwO1xuICAgIHY3ID0gQjJTX0lWWzddIHwgMDtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3Qgb2xlbiA9IG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IDMyIDogb3B0cy5ka0xlbjtcbiAgICAgICAgc3VwZXIoNjQsIG9sZW4pO1xuICAgICAgICBjaGVja0JsYWtlMk9wdHMob2xlbiwgb3B0cywgMzIsIDgsIDgpO1xuICAgICAgICBsZXQgeyBrZXksIHBlcnNvbmFsaXphdGlvbiwgc2FsdCB9ID0gb3B0cztcbiAgICAgICAgbGV0IGtleUxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWJ5dGVzKGtleSwgdW5kZWZpbmVkLCAna2V5Jyk7XG4gICAgICAgICAgICBrZXlMZW5ndGggPSBrZXkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudjAgXj0gdGhpcy5vdXRwdXRMZW4gfCAoa2V5TGVuZ3RoIDw8IDgpIHwgKDB4MDEgPDwgMTYpIHwgKDB4MDEgPDwgMjQpO1xuICAgICAgICBpZiAoc2FsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYnl0ZXMoc2FsdCwgdW5kZWZpbmVkLCAnc2FsdCcpO1xuICAgICAgICAgICAgY29uc3Qgc2x0ID0gdTMyKHNhbHQpO1xuICAgICAgICAgICAgdGhpcy52NCBePSBzd2FwOElmQkUoc2x0WzBdKTtcbiAgICAgICAgICAgIHRoaXMudjUgXj0gc3dhcDhJZkJFKHNsdFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcnNvbmFsaXphdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYnl0ZXMocGVyc29uYWxpemF0aW9uLCB1bmRlZmluZWQsICdwZXJzb25hbGl6YXRpb24nKTtcbiAgICAgICAgICAgIGNvbnN0IHBlcnMgPSB1MzIocGVyc29uYWxpemF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudjYgXj0gc3dhcDhJZkJFKHBlcnNbMF0pO1xuICAgICAgICAgICAgdGhpcy52NyBePSBzd2FwOElmQkUocGVyc1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBQYWQgdG8gYmxvY2tMZW4gYW5kIHVwZGF0ZVxuICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5ibG9ja0xlbik7XG4gICAgICAgICAgICB0bXAuc2V0KGtleSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0bXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3XTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2Nykge1xuICAgICAgICB0aGlzLnYwID0gdjAgfCAwO1xuICAgICAgICB0aGlzLnYxID0gdjEgfCAwO1xuICAgICAgICB0aGlzLnYyID0gdjIgfCAwO1xuICAgICAgICB0aGlzLnYzID0gdjMgfCAwO1xuICAgICAgICB0aGlzLnY0ID0gdjQgfCAwO1xuICAgICAgICB0aGlzLnY1ID0gdjUgfCAwO1xuICAgICAgICB0aGlzLnY2ID0gdjYgfCAwO1xuICAgICAgICB0aGlzLnY3ID0gdjcgfCAwO1xuICAgIH1cbiAgICBjb21wcmVzcyhtc2csIG9mZnNldCwgaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gdTY0LmZyb21CaWcoQmlnSW50KHRoaXMubGVuZ3RoKSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCB7IHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5LCB2MTAsIHYxMSwgdjEyLCB2MTMsIHYxNCwgdjE1IH0gPSBjb21wcmVzcyhCU0lHTUEsIG9mZnNldCwgbXNnLCAxMCwgdGhpcy52MCwgdGhpcy52MSwgdGhpcy52MiwgdGhpcy52MywgdGhpcy52NCwgdGhpcy52NSwgdGhpcy52NiwgdGhpcy52NywgQjJTX0lWWzBdLCBCMlNfSVZbMV0sIEIyU19JVlsyXSwgQjJTX0lWWzNdLCBsIF4gQjJTX0lWWzRdLCBoIF4gQjJTX0lWWzVdLCBpc0xhc3QgPyB+QjJTX0lWWzZdIDogQjJTX0lWWzZdLCBCMlNfSVZbN10pO1xuICAgICAgICB0aGlzLnYwIF49IHYwIF4gdjg7XG4gICAgICAgIHRoaXMudjEgXj0gdjEgXiB2OTtcbiAgICAgICAgdGhpcy52MiBePSB2MiBeIHYxMDtcbiAgICAgICAgdGhpcy52MyBePSB2MyBeIHYxMTtcbiAgICAgICAgdGhpcy52NCBePSB2NCBeIHYxMjtcbiAgICAgICAgdGhpcy52NSBePSB2NSBeIHYxMztcbiAgICAgICAgdGhpcy52NiBePSB2NiBeIHYxNDtcbiAgICAgICAgdGhpcy52NyBePSB2NyBeIHYxNTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcjMyKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuLyoqXG4gKiBCbGFrZTJzIGhhc2ggZnVuY3Rpb24uIEZvY3VzZXMgb24gOC1iaXQgdG8gMzItYml0IHBsYXRmb3Jtcy4gMS41eCBmYXN0ZXIgdGhhbiBibGFrZTJiIGluIEpTLlxuICogQHBhcmFtIG1zZyAtIG1lc3NhZ2UgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqIEBwYXJhbSBvcHRzIC0gZGtMZW4gb3V0cHV0IGxlbmd0aCwga2V5IGZvciBNQUMgbW9kZSwgc2FsdCwgcGVyc29uYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBibGFrZTJzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigob3B0cykgPT4gbmV3IF9CTEFLRTJzKG9wdHMpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsYWtlMi5qcy5tYXAiLCIvKipcbiAqIEFyZ29uMiBLREYgZnJvbSBSRkMgOTEwNi4gQ2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEga2V5IGZyb20gcGFzc3dvcmQgYW5kIHNhbHQuXG4gKiBXZSBzdWdnZXN0IHRvIHVzZSBTY3J5cHQuIEpTIEFyZ29uIGlzIDItMTB4IHNsb3dlciB0aGFuIG5hdGl2ZSBjb2RlIGJlY2F1c2Ugb2YgNjQtYml0bmVzczpcbiAqICogYXJnb24gdXNlcyB1aW50NjQsIGJ1dCBKUyBkb2Vzbid0IGhhdmUgZmFzdCB1aW50NjRhcnJheVxuICogKiB1aW50NjQgbXVsdGlwbGljYXRpb24gaXMgMS8zIG9mIHRpbWVcbiAqICogYFBgIGZ1bmN0aW9uIHdvdWxkIGJlIHZlcnkgbmljZSB3aXRoIHU2NCwgYmVjYXVzZSBtb3N0IG9mIHZhbHVlIHdpbGwgYmUgaW4gcmVnaXN0ZXJzLFxuICogICBob3Zld2VyIHdpdGggdTMyIGl0IHdpbGwgcmVxdWlyZSAzMiByZWdpc3RlcnMsIHdoaWNoIGlzIHRvbyBtdWNoLlxuICogKiBKUyBhcnJheXMgZG8gc2xvdyBib3VuZCBjaGVja3MsIHNvIHJlYWRpbmcgZnJvbSBgQTJfQlVGYCBzbG93cyBpdCBkb3duXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGFkZDNILCBhZGQzTCwgcm90cjMySCwgcm90cjMyTCwgcm90ckJILCByb3RyQkwsIHJvdHJTSCwgcm90clNMIH0gZnJvbSBcIi4vX3U2NC5qc1wiO1xuaW1wb3J0IHsgYmxha2UyYiB9IGZyb20gXCIuL2JsYWtlMi5qc1wiO1xuaW1wb3J0IHsgYW51bWJlciwgY2xlYW4sIGtkZklucHV0VG9CeXRlcywgbmV4dFRpY2ssIHUzMiwgdTggfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuY29uc3QgQVQgPSB7IEFyZ29uZDJkOiAwLCBBcmdvbjJpOiAxLCBBcmdvbjJpZDogMiB9O1xuY29uc3QgQVJHT04yX1NZTkNfUE9JTlRTID0gNDtcbmNvbnN0IGFieXRlc09yWmVybyA9IChidWYsIGVycm9yVGl0bGUgPSAnJykgPT4ge1xuICAgIGlmIChidWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkub2YoKTtcbiAgICByZXR1cm4ga2RmSW5wdXRUb0J5dGVzKGJ1ZiwgZXJyb3JUaXRsZSk7XG59O1xuLy8gdTMyICogdTMyID0gdTY0XG5mdW5jdGlvbiBtdWwoYSwgYikge1xuICAgIGNvbnN0IGFMID0gYSAmIDB4ZmZmZjtcbiAgICBjb25zdCBhSCA9IGEgPj4+IDE2O1xuICAgIGNvbnN0IGJMID0gYiAmIDB4ZmZmZjtcbiAgICBjb25zdCBiSCA9IGIgPj4+IDE2O1xuICAgIGNvbnN0IGxsID0gTWF0aC5pbXVsKGFMLCBiTCk7XG4gICAgY29uc3QgaGwgPSBNYXRoLmltdWwoYUgsIGJMKTtcbiAgICBjb25zdCBsaCA9IE1hdGguaW11bChhTCwgYkgpO1xuICAgIGNvbnN0IGhoID0gTWF0aC5pbXVsKGFILCBiSCk7XG4gICAgY29uc3QgY2FycnkgPSAobGwgPj4+IDE2KSArIChobCAmIDB4ZmZmZikgKyBsaDtcbiAgICBjb25zdCBoaWdoID0gKGhoICsgKGhsID4+PiAxNikgKyAoY2FycnkgPj4+IDE2KSkgfCAwO1xuICAgIGNvbnN0IGxvdyA9IChjYXJyeSA8PCAxNikgfCAobGwgJiAweGZmZmYpO1xuICAgIHJldHVybiB7IGg6IGhpZ2gsIGw6IGxvdyB9O1xufVxuZnVuY3Rpb24gbXVsMihhLCBiKSB7XG4gICAgLy8gMiAqIGEgKiBiICh2aWEgc2hpZnRzKVxuICAgIGNvbnN0IHsgaCwgbCB9ID0gbXVsKGEsIGIpO1xuICAgIHJldHVybiB7IGg6ICgoaCA8PCAxKSB8IChsID4+PiAzMSkpICYgMHhmZmZmX2ZmZmYsIGw6IChsIDw8IDEpICYgMHhmZmZmX2ZmZmYgfTtcbn1cbi8vIEJsYU1rYSBwZXJtdXRhdGlvbiBmb3IgQXJnb24yXG4vLyBBICsgQiArICgyICogdTMyKEEpICogdTMyKEIpKVxuZnVuY3Rpb24gYmxhbWthKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgeyBoOiBDaCwgbDogQ2wgfSA9IG11bDIoQWwsIEJsKTtcbiAgICAvLyBBICsgQiArICgyICogQSAqIEIpXG4gICAgY29uc3QgUmxsID0gYWRkM0woQWwsIEJsLCBDbCk7XG4gICAgcmV0dXJuIHsgaDogYWRkM0goUmxsLCBBaCwgQmgsIENoKSwgbDogUmxsIHwgMCB9O1xufVxuLy8gVGVtcG9yYXJ5IGJsb2NrIGJ1ZmZlclxuY29uc3QgQTJfQlVGID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7IC8vIDEwMjQgYnl0ZXMgKG1hdHJpeCAxNngxNilcbmZ1bmN0aW9uIEcoYSwgYiwgYywgZCkge1xuICAgIGxldCBBbCA9IEEyX0JVRlsyICogYV0sIEFoID0gQTJfQlVGWzIgKiBhICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBCbCA9IEEyX0JVRlsyICogYl0sIEJoID0gQTJfQlVGWzIgKiBiICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBDbCA9IEEyX0JVRlsyICogY10sIENoID0gQTJfQlVGWzIgKiBjICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBEbCA9IEEyX0JVRlsyICogZF0sIERoID0gQTJfQlVGWzIgKiBkICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gYmxhbWthKEFoLCBBbCwgQmgsIEJsKSk7XG4gICAgKHsgRGgsIERsIH0gPSB7IERoOiBEaCBeIEFoLCBEbDogRGwgXiBBbCB9KTtcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IHJvdHIzMkgoRGgsIERsKSwgRGw6IHJvdHIzMkwoRGgsIERsKSB9KTtcbiAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IGJsYW1rYShDaCwgQ2wsIERoLCBEbCkpO1xuICAgICh7IEJoLCBCbCB9ID0geyBCaDogQmggXiBDaCwgQmw6IEJsIF4gQ2wgfSk7XG4gICAgKHsgQmgsIEJsIH0gPSB7IEJoOiByb3RyU0goQmgsIEJsLCAyNCksIEJsOiByb3RyU0woQmgsIEJsLCAyNCkgfSk7XG4gICAgKHsgaDogQWgsIGw6IEFsIH0gPSBibGFta2EoQWgsIEFsLCBCaCwgQmwpKTtcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IERoIF4gQWgsIERsOiBEbCBeIEFsIH0pO1xuICAgICh7IERoLCBEbCB9ID0geyBEaDogcm90clNIKERoLCBEbCwgMTYpLCBEbDogcm90clNMKERoLCBEbCwgMTYpIH0pO1xuICAgICh7IGg6IENoLCBsOiBDbCB9ID0gYmxhbWthKENoLCBDbCwgRGgsIERsKSk7XG4gICAgKHsgQmgsIEJsIH0gPSB7IEJoOiBCaCBeIENoLCBCbDogQmwgXiBDbCB9KTtcbiAgICAoeyBCaCwgQmwgfSA9IHsgQmg6IHJvdHJCSChCaCwgQmwsIDYzKSwgQmw6IHJvdHJCTChCaCwgQmwsIDYzKSB9KTtcbiAgICAoKEEyX0JVRlsyICogYV0gPSBBbCksIChBMl9CVUZbMiAqIGEgKyAxXSA9IEFoKSk7XG4gICAgKChBMl9CVUZbMiAqIGJdID0gQmwpLCAoQTJfQlVGWzIgKiBiICsgMV0gPSBCaCkpO1xuICAgICgoQTJfQlVGWzIgKiBjXSA9IENsKSwgKEEyX0JVRlsyICogYyArIDFdID0gQ2gpKTtcbiAgICAoKEEyX0JVRlsyICogZF0gPSBEbCksIChBMl9CVUZbMiAqIGQgKyAxXSA9IERoKSk7XG59XG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIFAodjAwLCB2MDEsIHYwMiwgdjAzLCB2MDQsIHYwNSwgdjA2LCB2MDcsIHYwOCwgdjA5LCB2MTAsIHYxMSwgdjEyLCB2MTMsIHYxNCwgdjE1KSB7XG4gICAgRyh2MDAsIHYwNCwgdjA4LCB2MTIpO1xuICAgIEcodjAxLCB2MDUsIHYwOSwgdjEzKTtcbiAgICBHKHYwMiwgdjA2LCB2MTAsIHYxNCk7XG4gICAgRyh2MDMsIHYwNywgdjExLCB2MTUpO1xuICAgIEcodjAwLCB2MDUsIHYxMCwgdjE1KTtcbiAgICBHKHYwMSwgdjA2LCB2MTEsIHYxMik7XG4gICAgRyh2MDIsIHYwNywgdjA4LCB2MTMpO1xuICAgIEcodjAzLCB2MDQsIHYwOSwgdjE0KTtcbn1cbmZ1bmN0aW9uIGJsb2NrKHgsIHhQb3MsIHlQb3MsIG91dFBvcywgbmVlZFhvcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspXG4gICAgICAgIEEyX0JVRltpXSA9IHhbeFBvcyArIGldIF4geFt5UG9zICsgaV07XG4gICAgLy8gY29sdW1ucyAoOClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyODsgaSArPSAxNikge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgUChpLCBpICsgMSwgaSArIDIsIGkgKyAzLCBpICsgNCwgaSArIDUsIGkgKyA2LCBpICsgNywgaSArIDgsIGkgKyA5LCBpICsgMTAsIGkgKyAxMSwgaSArIDEyLCBpICsgMTMsIGkgKyAxNCwgaSArIDE1KTtcbiAgICB9XG4gICAgLy8gcm93cyAoOClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDIpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIFAoaSwgaSArIDEsIGkgKyAxNiwgaSArIDE3LCBpICsgMzIsIGkgKyAzMywgaSArIDQ4LCBpICsgNDksIGkgKyA2NCwgaSArIDY1LCBpICsgODAsIGkgKyA4MSwgaSArIDk2LCBpICsgOTcsIGkgKyAxMTIsIGkgKyAxMTMpO1xuICAgIH1cbiAgICBpZiAobmVlZFhvcilcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKylcbiAgICAgICAgICAgIHhbb3V0UG9zICsgaV0gXj0gQTJfQlVGW2ldIF4geFt4UG9zICsgaV0gXiB4W3lQb3MgKyBpXTtcbiAgICBlbHNlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspXG4gICAgICAgICAgICB4W291dFBvcyArIGldID0gQTJfQlVGW2ldIF4geFt4UG9zICsgaV0gXiB4W3lQb3MgKyBpXTtcbiAgICBjbGVhbihBMl9CVUYpO1xufVxuLy8gVmFyaWFibGUtTGVuZ3RoIEhhc2ggRnVuY3Rpb24gSCdcbmZ1bmN0aW9uIEhwKEEsIGRrTGVuKSB7XG4gICAgY29uc3QgQTggPSB1OChBKTtcbiAgICBjb25zdCBUID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuICAgIGNvbnN0IFQ4ID0gdTgoVCk7XG4gICAgVFswXSA9IGRrTGVuO1xuICAgIC8vIEZhc3QgcGF0aFxuICAgIGlmIChka0xlbiA8PSA2NClcbiAgICAgICAgcmV0dXJuIGJsYWtlMmIuY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKFQ4KS51cGRhdGUoQTgpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KGRrTGVuKTtcbiAgICBsZXQgViA9IGJsYWtlMmIuY3JlYXRlKHt9KS51cGRhdGUoVDgpLnVwZGF0ZShBOCkuZGlnZXN0KCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgLy8gRmlyc3QgYmxvY2tcbiAgICBvdXQuc2V0KFYuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICBwb3MgKz0gMzI7XG4gICAgLy8gUmVzdCBibG9ja3NcbiAgICBmb3IgKDsgZGtMZW4gLSBwb3MgPiA2NDsgcG9zICs9IDMyKSB7XG4gICAgICAgIGNvbnN0IFZoID0gYmxha2UyYi5jcmVhdGUoe30pLnVwZGF0ZShWKTtcbiAgICAgICAgVmguZGlnZXN0SW50byhWKTtcbiAgICAgICAgVmguZGVzdHJveSgpO1xuICAgICAgICBvdXQuc2V0KFYuc3ViYXJyYXkoMCwgMzIpLCBwb3MpO1xuICAgIH1cbiAgICAvLyBMYXN0IGJsb2NrXG4gICAgb3V0LnNldChibGFrZTJiKFYsIHsgZGtMZW46IGRrTGVuIC0gcG9zIH0pLCBwb3MpO1xuICAgIGNsZWFuKFYsIFQpO1xuICAgIHJldHVybiB1MzIob3V0KTtcbn1cbi8vIFVzZWQgb25seSBpbnNpZGUgcHJvY2VzcyBibG9jayFcbmZ1bmN0aW9uIGluZGV4QWxwaGEociwgcywgbGFuZUxlbiwgc2VnbWVudExlbiwgaW5kZXgsIHJhbmRMLCBzYW1lTGFuZSA9IGZhbHNlKSB7XG4gICAgLy8gVGhpcyBpcyB1Z2x5LCBidXQgY2xvc2UgZW5vdWdoIHRvIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBsZXQgYXJlYTtcbiAgICBpZiAociA9PT0gMCkge1xuICAgICAgICBpZiAocyA9PT0gMClcbiAgICAgICAgICAgIGFyZWEgPSBpbmRleCAtIDE7XG4gICAgICAgIGVsc2UgaWYgKHNhbWVMYW5lKVxuICAgICAgICAgICAgYXJlYSA9IHMgKiBzZWdtZW50TGVuICsgaW5kZXggLSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcmVhID0gcyAqIHNlZ21lbnRMZW4gKyAoaW5kZXggPT0gMCA/IC0xIDogMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNhbWVMYW5lKVxuICAgICAgICBhcmVhID0gbGFuZUxlbiAtIHNlZ21lbnRMZW4gKyBpbmRleCAtIDE7XG4gICAgZWxzZVxuICAgICAgICBhcmVhID0gbGFuZUxlbiAtIHNlZ21lbnRMZW4gKyAoaW5kZXggPT0gMCA/IC0xIDogMCk7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSByICE9PSAwICYmIHMgIT09IEFSR09OMl9TWU5DX1BPSU5UUyAtIDEgPyAocyArIDEpICogc2VnbWVudExlbiA6IDA7XG4gICAgY29uc3QgcmVsID0gYXJlYSAtIDEgLSBtdWwoYXJlYSwgbXVsKHJhbmRMLCByYW5kTCkuaCkuaDtcbiAgICByZXR1cm4gKHN0YXJ0UG9zICsgcmVsKSAlIGxhbmVMZW47XG59XG5jb25zdCBtYXhVaW50MzIgPSBNYXRoLnBvdygyLCAzMik7XG5mdW5jdGlvbiBpc1UzMihudW0pIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSAmJiBudW0gPj0gMCAmJiBudW0gPCBtYXhVaW50MzI7XG59XG5mdW5jdGlvbiBhcmdvbjJPcHRzKG9wdHMpIHtcbiAgICBjb25zdCBtZXJnZWQgPSB7XG4gICAgICAgIHZlcnNpb246IDB4MTMsXG4gICAgICAgIGRrTGVuOiAzMixcbiAgICAgICAgbWF4bWVtOiBtYXhVaW50MzIgLSAxLFxuICAgICAgICBhc3luY1RpY2s6IDEwLFxuICAgIH07XG4gICAgZm9yIChsZXQgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKG9wdHMpKVxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbWVyZ2VkW2tdID0gdjtcbiAgICBjb25zdCB7IGRrTGVuLCBwLCBtLCB0LCB2ZXJzaW9uLCBvblByb2dyZXNzLCBhc3luY1RpY2sgfSA9IG1lcmdlZDtcbiAgICBpZiAoIWlzVTMyKGRrTGVuKSB8fCBka0xlbiA8IDQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJka0xlblwiIG11c3QgYmUgNC4uJyk7XG4gICAgaWYgKCFpc1UzMihwKSB8fCBwIDwgMSB8fCBwID49IE1hdGgucG93KDIsIDI0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInBcIiBtdXN0IGJlIDEuLjJeMjQnKTtcbiAgICBpZiAoIWlzVTMyKG0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibVwiIG11c3QgYmUgMC4uMl4zMicpO1xuICAgIGlmICghaXNVMzIodCkgfHwgdCA8IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0XCIgKGl0ZXJhdGlvbnMpIG11c3QgYmUgMS4uMl4zMicpO1xuICAgIGlmIChvblByb2dyZXNzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9uUHJvZ3Jlc3MgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJwcm9ncmVzc0NiXCIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgYW51bWJlcihhc3luY1RpY2ssICdhc3luY1RpY2snKTtcbiAgICAvKlxuICAgIE1lbW9yeSBzaXplIG0gTVVTVCBiZSBhbiBpbnRlZ2VyIG51bWJlciBvZiBraWJpYnl0ZXMgZnJvbSA4KnAgdG8gMl4oMzIpLTEuIFRoZSBhY3R1YWwgbnVtYmVyIG9mIGJsb2NrcyBpcyBtJywgd2hpY2ggaXMgbSByb3VuZGVkIGRvd24gdG8gdGhlIG5lYXJlc3QgbXVsdGlwbGUgb2YgNCpwLlxuICAgICovXG4gICAgaWYgKCFpc1UzMihtKSB8fCBtIDwgOCAqIHApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJtXCIgKG1lbW9yeSkgbXVzdCBiZSBhdCBsZWFzdCA4KnAgYnl0ZXMnKTtcbiAgICBpZiAodmVyc2lvbiAhPT0gMHgxMCAmJiB2ZXJzaW9uICE9PSAweDEzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widmVyc2lvblwiIG11c3QgYmUgMHgxMCBvciAweDEzLCBnb3QgJyArIHZlcnNpb24pO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5mdW5jdGlvbiBhcmdvbjJJbml0KHBhc3N3b3JkLCBzYWx0LCB0eXBlLCBvcHRzKSB7XG4gICAgcGFzc3dvcmQgPSBrZGZJbnB1dFRvQnl0ZXMocGFzc3dvcmQsICdwYXNzd29yZCcpO1xuICAgIHNhbHQgPSBrZGZJbnB1dFRvQnl0ZXMoc2FsdCwgJ3NhbHQnKTtcbiAgICBpZiAoIWlzVTMyKHBhc3N3b3JkLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJwYXNzd29yZFwiIG11c3QgYmUgbGVzcyBvZiBsZW5ndGggMS4uNEdiJyk7XG4gICAgaWYgKCFpc1UzMihzYWx0Lmxlbmd0aCkgfHwgc2FsdC5sZW5ndGggPCA4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic2FsdFwiIG11c3QgYmUgb2YgbGVuZ3RoIDguLjRHYicpO1xuICAgIGlmICghT2JqZWN0LnZhbHVlcyhBVCkuaW5jbHVkZXModHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0eXBlXCIgd2FzIGludmFsaWQnKTtcbiAgICBsZXQgeyBwLCBka0xlbiwgbSwgdCwgdmVyc2lvbiwga2V5LCBwZXJzb25hbGl6YXRpb24sIG1heG1lbSwgb25Qcm9ncmVzcywgYXN5bmNUaWNrIH0gPSBhcmdvbjJPcHRzKG9wdHMpO1xuICAgIC8vIFZhbGlkYXRpb25cbiAgICBrZXkgPSBhYnl0ZXNPclplcm8oa2V5LCAna2V5Jyk7XG4gICAgcGVyc29uYWxpemF0aW9uID0gYWJ5dGVzT3JaZXJvKHBlcnNvbmFsaXphdGlvbiwgJ3BlcnNvbmFsaXphdGlvbicpO1xuICAgIC8vIEhfMCA9IEheKDY0KShMRTMyKHApIHx8IExFMzIoVCkgfHwgTEUzMihtKSB8fCBMRTMyKHQpIHx8XG4gICAgLy8gICAgICAgTEUzMih2KSB8fCBMRTMyKHkpIHx8IExFMzIobGVuZ3RoKFApKSB8fCBQIHx8XG4gICAgLy8gICAgICAgTEUzMihsZW5ndGgoUykpIHx8IFMgfHwgIExFMzIobGVuZ3RoKEspKSB8fCBLIHx8XG4gICAgLy8gICAgICAgTEUzMihsZW5ndGgoWCkpIHx8IFgpXG4gICAgY29uc3QgaCA9IGJsYWtlMmIuY3JlYXRlKCk7XG4gICAgY29uc3QgQlVGID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuICAgIGNvbnN0IEJVRjggPSB1OChCVUYpO1xuICAgIGZvciAobGV0IGl0ZW0gb2YgW3AsIGRrTGVuLCBtLCB0LCB2ZXJzaW9uLCB0eXBlXSkge1xuICAgICAgICBCVUZbMF0gPSBpdGVtO1xuICAgICAgICBoLnVwZGF0ZShCVUY4KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSBvZiBbcGFzc3dvcmQsIHNhbHQsIGtleSwgcGVyc29uYWxpemF0aW9uXSkge1xuICAgICAgICBCVUZbMF0gPSBpLmxlbmd0aDsgLy8gQlVGIGlzIHUzMiBhcnJheSwgdGhpcyBpcyB2YWxpZFxuICAgICAgICBoLnVwZGF0ZShCVUY4KS51cGRhdGUoaSk7XG4gICAgfVxuICAgIGNvbnN0IEgwID0gbmV3IFVpbnQzMkFycmF5KDE4KTtcbiAgICBjb25zdCBIMF84ID0gdTgoSDApO1xuICAgIGguZGlnZXN0SW50byhIMF84KTtcbiAgICAvLyAyNTYgdTMyID0gMTAyNCAoQkxPQ0tfU0laRSksIGZpbGxzIEEyX0JVRiBvbiBwcm9jZXNzaW5nXG4gICAgLy8gUGFyYW1zXG4gICAgY29uc3QgbGFuZXMgPSBwO1xuICAgIC8vIG0nID0gNCAqIHAgKiBmbG9vciAobSAvIDRwKVxuICAgIGNvbnN0IG1QID0gNCAqIHAgKiBNYXRoLmZsb29yKG0gLyAoQVJHT04yX1NZTkNfUE9JTlRTICogcCkpO1xuICAgIC8vcSA9IG0nIC8gcCBjb2x1bW5zXG4gICAgY29uc3QgbGFuZUxlbiA9IE1hdGguZmxvb3IobVAgLyBwKTtcbiAgICBjb25zdCBzZWdtZW50TGVuID0gTWF0aC5mbG9vcihsYW5lTGVuIC8gQVJHT04yX1NZTkNfUE9JTlRTKTtcbiAgICBjb25zdCBtZW1Vc2VkID0gbVAgKiAyNTY7XG4gICAgaWYgKCFpc1UzMihtYXhtZW0pIHx8IG1lbVVzZWQgPiBtYXhtZW0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJtYXhtZW1cIiBleHBlY3RlZCA8MioqMzIsIGdvdDogbWF4bWVtPScgKyBtYXhtZW0gKyAnLCBtZW11c2VkPScgKyBtZW1Vc2VkKTtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KG1lbVVzZWQpO1xuICAgIC8vIEZpbGwgZmlyc3QgYmxvY2tzXG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCBwOyBsKyspIHtcbiAgICAgICAgY29uc3QgaSA9IDI1NiAqIGxhbmVMZW4gKiBsO1xuICAgICAgICAvLyBCW2ldWzBdID0gSCdeKDEwMjQpKEhfMCB8fCBMRTMyKDApIHx8IExFMzIoaSkpXG4gICAgICAgIEgwWzE3XSA9IGw7XG4gICAgICAgIEgwWzE2XSA9IDA7XG4gICAgICAgIEIuc2V0KEhwKEgwLCAxMDI0KSwgaSk7XG4gICAgICAgIC8vIEJbaV1bMV0gPSBIJ14oMTAyNCkoSF8wIHx8IExFMzIoMSkgfHwgTEUzMihpKSlcbiAgICAgICAgSDBbMTZdID0gMTtcbiAgICAgICAgQi5zZXQoSHAoSDAsIDEwMjQpLCBpICsgMjU2KTtcbiAgICB9XG4gICAgbGV0IHBlckJsb2NrID0gKCkgPT4geyB9O1xuICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsQmxvY2sgPSB0ICogQVJHT04yX1NZTkNfUE9JTlRTICogcCAqIHNlZ21lbnRMZW47XG4gICAgICAgIC8vIEludm9rZSBjYWxsYmFjayBpZiBwcm9ncmVzcyBjaGFuZ2VzIGZyb20gMTAuMDEgdG8gMTAuMDJcbiAgICAgICAgLy8gQWxsb3dzIHRvIGRyYXcgc21vb3RoIHByb2dyZXNzIGJhciBvbiB1cCB0byA4SyBzY3JlZW5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tQZXIgPSBNYXRoLm1heChNYXRoLmZsb29yKHRvdGFsQmxvY2sgLyAxMDAwMCksIDEpO1xuICAgICAgICBsZXQgYmxvY2tDbnQgPSAwO1xuICAgICAgICBwZXJCbG9jayA9ICgpID0+IHtcbiAgICAgICAgICAgIGJsb2NrQ250Kys7XG4gICAgICAgICAgICBpZiAob25Qcm9ncmVzcyAmJiAoIShibG9ja0NudCAlIGNhbGxiYWNrUGVyKSB8fCBibG9ja0NudCA9PT0gdG90YWxCbG9jaykpXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhibG9ja0NudCAvIHRvdGFsQmxvY2spO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjbGVhbihCVUYsIEgwKTtcbiAgICByZXR1cm4geyB0eXBlLCBtUCwgcCwgdCwgdmVyc2lvbiwgQiwgbGFuZUxlbiwgbGFuZXMsIHNlZ21lbnRMZW4sIGRrTGVuLCBwZXJCbG9jaywgYXN5bmNUaWNrIH07XG59XG5mdW5jdGlvbiBhcmdvbjJPdXRwdXQoQiwgcCwgbGFuZUxlbiwgZGtMZW4pIHtcbiAgICBjb25zdCBCX2ZpbmFsID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCBwOyBsKyspXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjU2OyBqKyspXG4gICAgICAgICAgICBCX2ZpbmFsW2pdIF49IEJbMjU2ICogKGxhbmVMZW4gKiBsICsgbGFuZUxlbiAtIDEpICsgal07XG4gICAgY29uc3QgcmVzID0gdTgoSHAoQl9maW5hbCwgZGtMZW4pKTtcbiAgICBjbGVhbihCX2ZpbmFsKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKEIsIGFkZHJlc3MsIGwsIHIsIHMsIGluZGV4LCBsYW5lTGVuLCBzZWdtZW50TGVuLCBsYW5lcywgb2Zmc2V0LCBwcmV2LCBkYXRhSW5kZXBlbmRlbnQsIG5lZWRYb3IpIHtcbiAgICBpZiAob2Zmc2V0ICUgbGFuZUxlbilcbiAgICAgICAgcHJldiA9IG9mZnNldCAtIDE7XG4gICAgbGV0IHJhbmRMLCByYW5kSDtcbiAgICBpZiAoZGF0YUluZGVwZW5kZW50KSB7XG4gICAgICAgIGxldCBpMTI4ID0gaW5kZXggJSAxMjg7XG4gICAgICAgIGlmIChpMTI4ID09PSAwKSB7XG4gICAgICAgICAgICBhZGRyZXNzWzI1NiArIDEyXSsrO1xuICAgICAgICAgICAgYmxvY2soYWRkcmVzcywgMjU2LCAyICogMjU2LCAwLCBmYWxzZSk7XG4gICAgICAgICAgICBibG9jayhhZGRyZXNzLCAwLCAyICogMjU2LCAwLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZEwgPSBhZGRyZXNzWzIgKiBpMTI4XTtcbiAgICAgICAgcmFuZEggPSBhZGRyZXNzWzIgKiBpMTI4ICsgMV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBUID0gMjU2ICogcHJldjtcbiAgICAgICAgcmFuZEwgPSBCW1RdO1xuICAgICAgICByYW5kSCA9IEJbVCArIDFdO1xuICAgIH1cbiAgICAvLyBhZGRyZXNzIGJsb2NrXG4gICAgY29uc3QgcmVmTGFuZSA9IHIgPT09IDAgJiYgcyA9PT0gMCA/IGwgOiByYW5kSCAlIGxhbmVzO1xuICAgIGNvbnN0IHJlZlBvcyA9IGluZGV4QWxwaGEociwgcywgbGFuZUxlbiwgc2VnbWVudExlbiwgaW5kZXgsIHJhbmRMLCByZWZMYW5lID09IGwpO1xuICAgIGNvbnN0IHJlZkJsb2NrID0gbGFuZUxlbiAqIHJlZkxhbmUgKyByZWZQb3M7XG4gICAgLy8gQltpXVtqXSA9IEcoQltpXVtqLTFdLCBCW2xdW3pdKVxuICAgIGJsb2NrKEIsIDI1NiAqIHByZXYsIDI1NiAqIHJlZkJsb2NrLCBvZmZzZXQgKiAyNTYsIG5lZWRYb3IpO1xufVxuZnVuY3Rpb24gYXJnb24yKHR5cGUsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBtUCwgcCwgdCwgdmVyc2lvbiwgQiwgbGFuZUxlbiwgbGFuZXMsIHNlZ21lbnRMZW4sIGRrTGVuLCBwZXJCbG9jayB9ID0gYXJnb24ySW5pdChwYXNzd29yZCwgc2FsdCwgdHlwZSwgb3B0cyk7XG4gICAgLy8gUHJlLWxvb3Agc2V0dXBcbiAgICAvLyBbYWRkcmVzcywgaW5wdXQsIHplcm9fYmxvY2tdIGZvcm1hdCBzbyB3ZSBjYW4gcGFzcyBzaW5nbGUgVTMyIHRvIGJsb2NrIGZ1bmN0aW9uXG4gICAgY29uc3QgYWRkcmVzcyA9IG5ldyBVaW50MzJBcnJheSgzICogMjU2KTtcbiAgICBhZGRyZXNzWzI1NiArIDZdID0gbVA7XG4gICAgYWRkcmVzc1syNTYgKyA4XSA9IHQ7XG4gICAgYWRkcmVzc1syNTYgKyAxMF0gPSB0eXBlO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdDsgcisrKSB7XG4gICAgICAgIGNvbnN0IG5lZWRYb3IgPSByICE9PSAwICYmIHZlcnNpb24gPT09IDB4MTM7XG4gICAgICAgIGFkZHJlc3NbMjU2ICsgMF0gPSByO1xuICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IEFSR09OMl9TWU5DX1BPSU5UUzsgcysrKSB7XG4gICAgICAgICAgICBhZGRyZXNzWzI1NiArIDRdID0gcztcbiAgICAgICAgICAgIGNvbnN0IGRhdGFJbmRlcGVuZGVudCA9IHR5cGUgPT0gQVQuQXJnb24yaSB8fCAodHlwZSA9PSBBVC5BcmdvbjJpZCAmJiByID09PSAwICYmIHMgPCAyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgcDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1syNTYgKyAyXSA9IGw7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1syNTYgKyAxMl0gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHIgPT09IDAgJiYgcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBvcyA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhSW5kZXBlbmRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NbMjU2ICsgMTJdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jayhhZGRyZXNzLCAyNTYsIDIgKiAyNTYsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrKGFkZHJlc3MsIDAsIDIgKiAyNTYsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGJsb2NrIHBvc3Rpb25cbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gbCAqIGxhbmVMZW4gKyBzICogc2VnbWVudExlbiArIHN0YXJ0UG9zO1xuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIGJsb2NrIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgbGV0IHByZXYgPSBvZmZzZXQgJSBsYW5lTGVuID8gb2Zmc2V0IC0gMSA6IG9mZnNldCArIGxhbmVMZW4gLSAxO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gc3RhcnRQb3M7IGluZGV4IDwgc2VnbWVudExlbjsgaW5kZXgrKywgb2Zmc2V0KyssIHByZXYrKykge1xuICAgICAgICAgICAgICAgICAgICBwZXJCbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQmxvY2soQiwgYWRkcmVzcywgbCwgciwgcywgaW5kZXgsIGxhbmVMZW4sIHNlZ21lbnRMZW4sIGxhbmVzLCBvZmZzZXQsIHByZXYsIGRhdGFJbmRlcGVuZGVudCwgbmVlZFhvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFuKGFkZHJlc3MpO1xuICAgIHJldHVybiBhcmdvbjJPdXRwdXQoQiwgcCwgbGFuZUxlbiwgZGtMZW4pO1xufVxuLyoqIGFyZ29uMmQgR1BVLXJlc2lzdGFudCB2ZXJzaW9uLiAqL1xuZXhwb3J0IGNvbnN0IGFyZ29uMmQgPSAocGFzc3dvcmQsIHNhbHQsIG9wdHMpID0+IGFyZ29uMihBVC5BcmdvbmQyZCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuLyoqIGFyZ29uMmkgc2lkZS1jaGFubmVsLXJlc2lzdGFudCB2ZXJzaW9uLiAqL1xuZXhwb3J0IGNvbnN0IGFyZ29uMmkgPSAocGFzc3dvcmQsIHNhbHQsIG9wdHMpID0+IGFyZ29uMihBVC5BcmdvbjJpLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4vKiogYXJnb24yaWQsIGNvbWJpbmluZyBpK2QsIHRoZSBtb3N0IHBvcHVsYXIgdmVyc2lvbiBmcm9tIFJGQyA5MTA2ICovXG5leHBvcnQgY29uc3QgYXJnb24yaWQgPSAocGFzc3dvcmQsIHNhbHQsIG9wdHMpID0+IGFyZ29uMihBVC5BcmdvbjJpZCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuYXN5bmMgZnVuY3Rpb24gYXJnb24yQXN5bmModHlwZSwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IG1QLCBwLCB0LCB2ZXJzaW9uLCBCLCBsYW5lTGVuLCBsYW5lcywgc2VnbWVudExlbiwgZGtMZW4sIHBlckJsb2NrLCBhc3luY1RpY2sgfSA9IGFyZ29uMkluaXQocGFzc3dvcmQsIHNhbHQsIHR5cGUsIG9wdHMpO1xuICAgIC8vIFByZS1sb29wIHNldHVwXG4gICAgLy8gW2FkZHJlc3MsIGlucHV0LCB6ZXJvX2Jsb2NrXSBmb3JtYXQgc28gd2UgY2FuIHBhc3Mgc2luZ2xlIFUzMiB0byBibG9jayBmdW5jdGlvblxuICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgVWludDMyQXJyYXkoMyAqIDI1Nik7XG4gICAgYWRkcmVzc1syNTYgKyA2XSA9IG1QO1xuICAgIGFkZHJlc3NbMjU2ICsgOF0gPSB0O1xuICAgIGFkZHJlc3NbMjU2ICsgMTBdID0gdHlwZTtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdDsgcisrKSB7XG4gICAgICAgIGNvbnN0IG5lZWRYb3IgPSByICE9PSAwICYmIHZlcnNpb24gPT09IDB4MTM7XG4gICAgICAgIGFkZHJlc3NbMjU2ICsgMF0gPSByO1xuICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IEFSR09OMl9TWU5DX1BPSU5UUzsgcysrKSB7XG4gICAgICAgICAgICBhZGRyZXNzWzI1NiArIDRdID0gcztcbiAgICAgICAgICAgIGNvbnN0IGRhdGFJbmRlcGVuZGVudCA9IHR5cGUgPT0gQVQuQXJnb24yaSB8fCAodHlwZSA9PSBBVC5BcmdvbjJpZCAmJiByID09PSAwICYmIHMgPCAyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgcDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1syNTYgKyAyXSA9IGw7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1syNTYgKyAxMl0gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHIgPT09IDAgJiYgcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBvcyA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhSW5kZXBlbmRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NbMjU2ICsgMTJdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jayhhZGRyZXNzLCAyNTYsIDIgKiAyNTYsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrKGFkZHJlc3MsIDAsIDIgKiAyNTYsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGJsb2NrIHBvc3Rpb25cbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gbCAqIGxhbmVMZW4gKyBzICogc2VnbWVudExlbiArIHN0YXJ0UG9zO1xuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIGJsb2NrIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgbGV0IHByZXYgPSBvZmZzZXQgJSBsYW5lTGVuID8gb2Zmc2V0IC0gMSA6IG9mZnNldCArIGxhbmVMZW4gLSAxO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gc3RhcnRQb3M7IGluZGV4IDwgc2VnbWVudExlbjsgaW5kZXgrKywgb2Zmc2V0KyssIHByZXYrKykge1xuICAgICAgICAgICAgICAgICAgICBwZXJCbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQmxvY2soQiwgYWRkcmVzcywgbCwgciwgcywgaW5kZXgsIGxhbmVMZW4sIHNlZ21lbnRMZW4sIGxhbmVzLCBvZmZzZXQsIHByZXYsIGRhdGFJbmRlcGVuZGVudCwgbmVlZFhvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRpZmYgPj0gMCAmJiBkaWZmIDwgYXN5bmNUaWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRzICs9IGRpZmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYW4oYWRkcmVzcyk7XG4gICAgcmV0dXJuIGFyZ29uMk91dHB1dChCLCBwLCBsYW5lTGVuLCBka0xlbik7XG59XG4vKiogYXJnb24yZCBhc3luYyBHUFUtcmVzaXN0YW50IHZlcnNpb24uICovXG5leHBvcnQgY29uc3QgYXJnb24yZEFzeW5jID0gKHBhc3N3b3JkLCBzYWx0LCBvcHRzKSA9PiBhcmdvbjJBc3luYyhBVC5BcmdvbmQyZCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuLyoqIGFyZ29uMmkgYXN5bmMgc2lkZS1jaGFubmVsLXJlc2lzdGFudCB2ZXJzaW9uLiAqL1xuZXhwb3J0IGNvbnN0IGFyZ29uMmlBc3luYyA9IChwYXNzd29yZCwgc2FsdCwgb3B0cykgPT4gYXJnb24yQXN5bmMoQVQuQXJnb24yaSwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuLyoqIGFyZ29uMmlkIGFzeW5jLCBjb21iaW5pbmcgaStkLCB0aGUgbW9zdCBwb3B1bGFyIHZlcnNpb24gZnJvbSBSRkMgOTEwNiAqL1xuZXhwb3J0IGNvbnN0IGFyZ29uMmlkQXN5bmMgPSAocGFzc3dvcmQsIHNhbHQsIG9wdHMpID0+IGFyZ29uMkFzeW5jKEFULkFyZ29uMmlkLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmdvbjIuanMubWFwIl0sIm5hbWVzIjpbImNvcHkiLCJieXRlcyIsIkJOXzAiLCJCTl8xIiwibWFzayIsIk5pYmJsZXMiLCJvdXRwdXQiLCJpbml0IiwibG9ja2VkIiwiZ2V0VGltZSIsInJlc3BvbnNlIiwiZGVsYXkiLCJzdGFsbCIsIm9mZnNldCIsIm9iamVjdCIsImxlbmd0aCIsInJhbmRvbUJ5dGVzIiwicGFzc1Byb3BlcnRpZXMiLCJfZ3VhcmQiLCJhcmdzIiwiZ2V0VmFsdWUiLCJudW1iZXIiLCJuIiwiYiIsImhhc2giLCJleGlzdHMiLCJ1OGEiLCJ1MzIiLCJjcmVhdGVWaWV3Iiwicm90ciIsImlzTEUiLCJuZXh0VGljayIsInV0ZjhUb0J5dGVzIiwidG9CeXRlcyIsIndyYXBDb25zdHJ1Y3RvciIsIkhhc2giLCJhc3NlcnRIYXNoIiwiYXNzZXJ0RXhpc3RzIiwiYXNzZXJ0Qnl0ZXMiLCJobWFjIiwiSE1BQyIsImFzc2VydE51bWJlciIsInBia2RmMiIsInNldEJpZ1VpbnQ2NCIsIl8zMm4iLCJDaGkiLCJNYWoiLCJTSEEyNTZfSyIsIklWIiwiU0hBMjU2X1ciLCJTSEEyIiwiRyIsIlQxIiwiVDIiLCJzaGEyNTYiLCJTSEEyNTYiLCJVMzJfTUFTSzY0IiwiZnJvbUJpZyIsInNwbGl0Iiwicm90clNIIiwicm90clNMIiwicm90ckJIIiwicm90ckJMIiwicm90cjMySCIsInJvdHIzMkwiLCJhZGQiLCJhZGQzTCIsImFkZDNIIiwic2hhNTEyIiwiY3J5cHRvIiwiXzBuIiwiXzFuIiwiXzJuIiwicm90bCIsInJpcGVtZDE2MCIsIm5vYmxlX3JpcGVtZDE2MCIsImNyeXB0b19yYW5kb20iLCJOIiwic2NyeXB0IiwiUGkiLCJfbm9ibGVBc3luYyIsIl9ub2JsZVN5bmMiLCJIIiwiY29uY2F0Qnl0ZXMiLCJnZW4iLCJfM24iLCJQIiwiUyIsIkZwIiwibjIiLCJmIiwiYml0TGVuIiwid2luZG93IiwidXQudmFsaWRhdGVPYmplY3QiLCJzIiwidXQuY29uY2F0Qnl0ZXMiLCJ1dC5ieXRlc1RvSGV4IiwidXQuYnl0ZXNUb051bWJlckJFIiwibW9kLm1vZCIsIlUxIiwiVTIiLCJtdWwiLCJhIiwibW9kLmludmVydCIsInV0Lm51bWJlclRvQnl0ZXNCRSIsIlNpZ25hdHVyZSIsInV0LmhleFRvQnl0ZXMiLCJtb2QuZ2V0TWluSGFzaExlbmd0aCIsIm1vZC5tYXBIYXNoVG9GaWVsZCIsInV0LmJpdE1hc2siLCJ1dC5jcmVhdGVIbWFjRHJiZyIsInIiLCJCTl8yIiwiQk5fMjciLCJCTl8yOCIsIkJOXzM1IiwidiIsImJsb2NrIiwiY2hlY2tzdW0iLCJzaWduZWQiLCJCTl9NQVhfVUlOVDI1NiIsInZlcnNpb24iLCJleHBhbmQiLCJkZWNvZGUiLCJWIiwiZyIsImRlY29tcG9zZWQiLCJuYW1lIiwidHlwZSIsInZhbHVlIiwidGhyb3dFcnJvciIsImludGVybmFsIiwicmVzdWx0IiwiaW5kZXhlZCIsImlucHV0cyIsIlBhbmljUmVhc29ucyIsImJsb2NrTnVtYmVyIiwicmVjZWlwdCIsImZyYWdtZW50IiwidCIsImxpc3RlbmVyIiwiYWRkciIsInRhcmdldCIsImNvZGUiLCJkYXRhIiwiZXJyb3IiLCJhbGxvd051bGwiLCJkZWZhdWx0T3B0aW9ucyIsImZyb21CbG9jayIsInRvQmxvY2siLCJhZGRyZXNzIiwiZmlsdGVyIiwidHgiLCJmcm9tIiwicGF5bG9hZCIsImlkIiwiYWNjb3VudHMiLCJ3b3JkcyIsIndvcmRsaXN0IiwiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJpIiwienBhZCIsImRlZmF1bHRQYXRoIiwic2FsdCIsImRrTGVuIiwia2V5Iiwid2FsbGV0IiwidTY0LmFkZDNMIiwidTY0LmFkZDNIIiwidTY0LnJvdHIzMkgiLCJ1NjQucm90cjMyTCIsInU2NC5hZGQiLCJ1NjQucm90clNIIiwidTY0LnJvdHJTTCIsInU2NC5yb3RyQkgiLCJ1NjQucm90ckJMIiwidTY0LmZyb21CaWciLCJUOCIsIkJVRiJdLCJtYXBwaW5ncyI6IkFBSVksTUFBQyxVQUFVO0FDQ3ZCLFNBQVMsVUFBVSxPQUFPLE1BQU0sTUFBTTtBQUNsQyxRQUFNLFFBQVEsS0FBSyxNQUFNLEdBQUcsRUFBRSxJ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QUFHLElBQUksR0FBRyxHQUFFLElBQUssSUFBSSxJQUFJLEtBQUssR0FBRyxLQUFLLEdBQUcsTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUM1RCxXQUFLLEtBQUs7QUFDVixXQUFLLEtBQUs7QUFDVixXQUFLLEtBQUs7QUFDVixXQUFLLEtBQUs7QUFDVixXQUFLLEtBQUs7QUFDVixXQUFLLEtBQUs7QUFDVixZQUFNLE1BQU0sSUFBSSxNQUFNLEtBQUssU0FBUyxJQUFJO0FBQ3hDLFdBQUssSUFBSSxNQUFNLEtBQUssS0FBSyxTQUFTLElBQUk7QUFDdEMsV0FBSyxNQUFNO0FBQUEsSUFDZjtBQUVBLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLEtBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxLQUFLLEtB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QUFNLElBQUksR0FBRyxNQUFNLEtBQUssSUFBSSxJQUFJLE1BQU0sSUFBSTtBQUNqRSxNQUFJLE1BQU0sS0FBSyxJQUFJLElBQUksTUFBTSxJQUFJLEdBQUcsTUFBTSxLQUFLLElBQUksSUFBSSxNQUFNLElBQUk7QUFDakUsTUFBSSxNQUFNLEtBQUssSUFBSSxJQUFJLE1BQU0sSUFBSSxHQUFHLE1BQU0sS0FBSyxJQUFJLElBQUksTUFBTSxJQUFJO0FBRWpFLE1BQUksTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTTtBQUUvSyxXQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSyxHQUFHO0FBQzNCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxDQUFDO0FBQzVCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFdBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxFQUFFO0FBQUEsRUFDakM7QUFFQSxNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDMUIsTUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQzFCLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUMxQixNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDMUIsTUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQzFCLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUMxQixNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDMUIsTUFBSSxJQUFJLElB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S0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUN0QixVQUFJLEtBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDdEIsVUFBSSxLQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ3RCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsVUFBSSxLQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ3RCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksR0FBRyxFQUFFO0FBQ2pCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLEdBQUcsRUFBRTtBQUNqQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFB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RztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLEtBQUssR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxLQUFLLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSWxDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE1BQU0sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE1BQU0sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE1BQU0sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxNQUFNLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxHQUFHO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXBDLE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsR0FBRztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlwQyxPQUFPLE1BQU0sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEdBQUc7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJcEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJdEMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxJQUFJO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXRDLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsSUFBSTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUl0QyxPQUFPLElBQUksR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLElBQUk7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSW5DLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsQ0FBQztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSW5DLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsQ0FBQztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSW5DLE9BQU8sT0FBTyxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsQ0FBQztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUluQyxPQUFPLE9BQU8sR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJbkMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJckMsT0FBTyxRQUFRLEdBQUc7QUFBRSxXQUFPLEVBQUUsR0FBRyxFQUFFO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXJDLE9BQU8sUUFBUSxHQUFHO0FBQUUsV0FBTyxFQUFFLEdBQUcsRUFBRTtBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQyxPQUFPLFFBQVEsR0FBRztBQUFFLFdBQU8sSUFBSSxNQUFNLFFBQVEsV0FBVyxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSTVELE9BQU8sS0FBSyxHQUFHO0FBQUUsV0FBTyxJQUFJLE1BQU0sUUFBUSxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQUEsRUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSXhELE9BQU8sTUFBTSxHQUFHO0FBQUUsV0FBTyxJQUFJLE1BQU0sUUFBUSxTQUFTLENBQUM7QUFBQSxFQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJeEQsT0FBTyxPQUFPLEdBQUc7QUFBRSxXQUFPLElBQUksTUFBTSxRQUFRLFVBQVUsQ0FBQztBQUFBLEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUkxRCxPQUFPLE1BQU0sR0FBRyxTQUFT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QUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sR0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sR0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sR0FBTSxLQUFNLEdBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxHQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxHQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxHQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLElBQU0sR0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEdBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sR0FBTSxLQUFNLElBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sRUFBSTtBQUN6Z0QsTUFBTSxLQUFLLENBQUMsSUFBTSxHQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sR0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sR0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLEdBQU0sS0FBTSxLQUFNLElBQU0sR0FBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLEdBQU0sS0FBTSxLQUFNLEtBQU0sR0FBTSxHQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLElBQU0sSUFBTSxLQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxLQUFNLEdBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sSUFBTSxJQUFNLElBQU0sS0FBTSxLQUFNLElBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sSUFBTSxLQUFNLElBQU0sSUFBTSxJQUFNLEdBQU0sS0FBTSxLQUFNLEtBQU0sS0FBTSxJQUFNLEtBQU0sS0FBTSxJQUFNLElBQU0sSUFBTSxJQUFNLElBQU0sR0FBSTtBQUUxZ0QsTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxHQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksU0FBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxHQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxVQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksU0FBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxHQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksU0FBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxHQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksU0FBVTtBQUUxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFVBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksR0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksR0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksR0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxVQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFVBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksVUFBWSxZQUFZLFVBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksVUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksR0FBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksVUFBVTtBQUUxZ0csTUFBTSxLQUFLLENBQUMsR0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsR0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksVUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksVUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsR0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksVUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksVUFBVTtBQUMxZ0csTUFBTSxLQUFLLENBQUMsR0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksVUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxVQUFZLFdBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFdBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFVBQVksV0FBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxXQUFZLFdBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFZLFVBQVksV0FBWSxXQUFZLFdBQVksV0FBWSxZQUFZLFdBQVksWUFBWSxZQUFZLFlBQVks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QyxTQUF5QjtBQUFBLEVBQWEsTUFBTSxJQUFJLFFBQU87QUFBQSxFQUNwRCx3QkFBUSxDQUFJO0FBQUM7QUM1V3RCLE1BQU0sU0FBeUIsMkJBQVcsS0FBSztBQUFBLEVBQ2xEO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFDbEQ7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUNuRDtBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQ25EO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFDbkQ7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUNsRDtBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQ25EO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFDbEQ7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUNsRDtBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQ25EO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFDbkQ7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUNsRDtBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBO0FBQUEsRUFFbkQ7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUNuRDtBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQ25EO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFHO0FBQUEsRUFDbEQ7QUFBQSxFQUFHO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUk7QUFBQSxFQUFHO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBRztBQUFBLEVBQUc7QUFBQSxFQUFJO0FBQUEsRUFBSTtBQUFBLEVBQUc7QUFDdkQsQ0FBQztBQ2pCRCxNQUFNLFNBQXlCLDRCQUFZLEtBQUs7QUFBQSxFQUM1QztBQUFBLEVBQVk7QUFBQSxFQUFZO0FBQUEsRUFBWTtBQUFBLEVBQVk7QUFBQSxFQUFZO0FBQUEsRUFBWTtBQUFBLEVBQVk7QUFBQSxFQUNwRjtBQUFBLEVBQVk7QUFBQSxFQUFZO0FBQUEsRUFBWTtBQUFBLEVBQVk7QUFBQSxFQUFZO0FBQUEsRUFBWTtBQUFBLEVBQVk7QUFDeEYsQ0FBQztBQUVELE1BQU0sT0FBdUIsb0JBQUksWUFBWSxFQUFFO0FBRS9DLFNBQVMsSUFBSSxHQUFHNUIsSUFBRyxHQUFHLEdBQUcsS0FBSyxHQUFHO0FBRTdCLFFBQU0sS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLElBQUksSUFBSSxDQUFDO0FBQ2pDLE1BQUksS0FBSyxLQUFLLElBQUksQ0FBQyxHQUFHLEtBQUssS0FBSyxJQUFJLElBQUksQ0FBQztBQUN6QyxNQUFJLEtBQUssS0FBSyxJQUFJQSxFQUFDLEdBQUcsS0FBSyxLQUFLLElBQUlBLEtBQUksQ0FBQztBQUN6QyxNQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUM7QUFDekMsTUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDO0FBRXpDLE1BQUksS0FBS2lKLE1BQVUsSUFBSSxJQUFJLEVBQUU7QUFDN0IsT0FBS0MsTUFBVSxJQUFJLElBQUksSUFBSSxFQUFFO0FBQzdCLE9BQUssS0FBSztBQUVWLEdBQUMsRUFBRSxJQUFJLEdBQUUsSUFBSyxFQUFFLElBQUksS0FBSyxJQUFJLElBQUksS0FBSyxHQUFFO0FBQ3hDLEdBQUMsRUFBRSxJQUFJLEdBQUUsSUFBSyxFQUFFLElBQUlDLFFBQVksSUFBSSxFQUFFLEdBQUcsSUFBSUMsUUFBWSxFQUFNLEVBQUM7QUFFaEUsR0FBQyxFQUFFLEdBQUcsSUFBSSxHQUFHLEdBQUUsSUFBS0MsSUFBUSxJQUFJLElBQUksSUFBSSxFQUFFO0FBRTFDLEdBQUMsRUFBRSxJQUFJLEdBQUUsSUFBSyxFQUFFLElBQUksS0FBSyxJQUFJLElBQUksS0FBSyxHQUFFO0FBQ3hDLEdBQUMsRUFBRSxJQUFJLEdBQUUsSUFBSyxFQUFFLElBQUlDLE9BQVcsSUFBSSxJQUFJLEVBQUUsR0FBRyxJQUFJQyxPQUFXLElBQUksSUFBSSxFQUFFLEVBQUM7QUFDdEUsRUFBRSxLQUFLLElBQUksQ0FBQyxJQUFJLElBQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxJQUFJO0FBQ3hDLEVBQUUsS0FBSyxJQUFJdkosRUFBQyxJQUFJLElBQU0sS0FBSyxJQUFJQSxLQUFJLENBQUMsSUFBSTtBQUN4QyxFQUFFLEtBQUssSUFBSSxDQUFDLElBQUksSUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLElBQUk7QUFDeEMsRUFBRSxLQUFLLElBQUksQ0FBQyxJQUFJLElBQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxJQUFJO0FBQzVDO0FBQ0EsU0FBUyxJQUFJLEdBQUdBLElBQUcsR0FBRyxHQUFHLEtBQUssR0FBRztBQUU3QixRQUFNLEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJLElBQUksQ0FBQztBQUNqQyxNQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUM7QUFDekMsTUFBSSxLQUFLLEtBQUssSUFBSUEsRUFBQyxHQUFHLEtBQUssS0FBSyxJQUFJQSxLQUFJLENBQUM7QUFDekMsTUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDO0FBQ3pDLE1BQUksS0FBSyxLQUFLLElBQUksQ0FBQyxHQUFHLEtBQUssS0FBSyxJQUFJLElBQUksQ0FBQztBQUV6QyxNQUFJLEtBQUtpSixNQUFVLElBQUksSUFBSSxFQUFFO0FBQzdCLE9BQUtDLE1BQVUsSUFBSSxJQUFJLElBQUksRUFBRTtBQUM3QixPQUFLLEtBQUs7QUFFVixHQUFDLEVBQUUsSUFBSSxHQUFFLElBQUssRUFBRSxJQUFJLEtBQUssSUFBSSxJQUFJLEtBQUssR0FBRTtBQUN4QyxHQUFDLEVBQUUsSUFBSSxHQUFFLElBQUssRUFBRSxJQUFJSSxPQUFXLElBQUksSUFBSSxFQUFFLEdBQUcsSUFBSUMsT0FBVyxJQUFJLElBQUksRUFBRSxFQUFDO0FBRXRFLEdBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxHQUFFLElBQUtGLElBQVEsSUFBSSxJQUFJLElBQUksRUFBRTtBQUUxQyxHQUFDLEVBQUUsSUFBSSxHQUFFLElBQUssRUFBRSxJQUFJLEtBQUssSUFBSSxJQUFJLEtBQUssR0FBRTtBQUN4QyxHQUFDLEVBQUUsSUFBSSxHQUFFLElBQUssRUFBRSxJQUFJRyxPQUFXLElBQUksSUFBSSxFQUFFLEdBQUcsSUFBSUMsT0FBVyxJQUFJLElBQUksRUFBRSxFQUFDO0FBQ3RFLEVBQUUsS0FBSyxJQUFJLENBQUMsSUFBSSxJQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsSUFBSTtBQUN4QyxFQUFFLEtBQUssSUFBSXpKLEVBQUMsSUFBSSxJQUFNLEtBQUssSUFBSUEsS0FBSSxDQUFDLElBQUk7QUFDeEMsRUFBRSxLQUFLLElBQUksQ0FBQyxJQUFJLElBQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxJQUFJO0FBQ3hDLEVBQUUsS0FBSyxJQUFJLENBQUMsSUFBSSxJQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsSUFBSTtBQUM1QztBQUNBLFNBQVMsZ0JBQWdCLFdBQVcsT0FBTyxDQUFBLEdBQUksUUFBUSxTQUFTLFNBQVM7QUFDckUsVUFBUSxNQUFNO0FBQ2QsTUFBSSxZQUFZLEtBQUssWUFBWTtBQUM3QixVQUFNLElBQUksTUFBTSw4QkFBOEI7QUFDbEQsUUFBTSxFQUFFLEtBQUssTUFBTSxnQkFBZSxJQUFLO0FBQ3ZDLE1BQUksUUFBUSxXQUFjLElBQUksU0FBUyxLQUFLLElBQUksU0FBUztBQUNyRCxVQUFNLElBQUksTUFBTSxvREFBb0QsTUFBTTtBQUM5RSxNQUFJLFNBQVM7QUFDVCxXQUFPLE1BQU0sU0FBUyxNQUFNO0FBQ2hDLE1BQUksb0JBQW9CO0FBQ3BCLFdBQU8saUJBQWlCLFNBQVMsaUJBQWlCO0FBQzFEO0FBRU8sTUFBTSxRQUFRO0FBQUEsRUFDakI7QUFBQSxFQUNBO0FBQUEsRUFDQSxXQUFXO0FBQUEsRUFDWCxZQUFZO0FBQUEsRUFDWixTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTjtBQUFBLEVBQ0E7QUFBQSxFQUNBLFlBQVksVUFBVSxXQUFXO0FBQzdCLFlBQVEsUUFBUTtBQUNoQixZQUFRLFNBQVM7QUFDakIsU0FBSyxXQUFXO0FBQ2hCLFNBQUssWUFBWTtBQUNqQixTQUFLLFNBQVMsSUFBSSxXQUFXLFFBQVE7QUFDckMsU0FBSyxXQUFXLElBQUksS0FBSyxNQUFNO0FBQUEsRUFDbkM7QUFBQSxFQUNBLE9BQU8sTUFBTTtBQUNULFlBQVEsSUFBSTtBQUNaLFdBQU8sSUFBSTtBQUtYLFVBQU0sRUFBRSxVQUFVLFFBQVEsU0FBUSxJQUFLO0FBQ3ZDLFVBQU0sTUFBTSxLQUFLO0FBQ2pCLFVBQU0sU0FBUyxLQUFLO0FBQ3BCLFVBQU0sTUFBTSxLQUFLO0FBQ2pCLGFBQVMsTUFBTSxHQUFHLE1BQU0sT0FBTTtBQUUxQixVQUFJLEtBQUssUUFBUSxVQUFVO0FBQ3ZCLG1CQUFXLFFBQVE7QUFDbkIsYUFBSyxTQUFTLFVBQVUsR0FBRyxLQUFLO0FBQ2hDLG1CQUFXLFFBQVE7QUFDbkIsYUFBSyxNQUFNO0FBQUEsTUFDZjtBQUNBLFlBQU0sT0FBTyxLQUFLLElBQUksV0FBVyxLQUFLLEtBQUssTUFBTSxHQUFHO0FBQ3BELFlBQU0sYUFBYSxTQUFTO0FBRTVCLFVBQUksU0FBUyxZQUFZLEVBQUUsYUFBYSxNQUFNLE1BQU0sT0FBTyxLQUFLO0FBQzVELGNBQU0sU0FBUyxJQUFJLFlBQVksS0FBSyxZQUFZLEtBQUssT0FBTyxNQUFNLE9BQU8sQ0FBQyxDQUFDO0FBQzNFLG1CQUFXLE1BQU07QUFDakIsaUJBQVMsUUFBUSxHQUFHLE1BQU0sV0FBVyxLQUFLLFNBQVMsU0FBUyxRQUFRLE9BQU8sVUFBVTtBQUNqRixlQUFLLFVBQVU7QUFDZixlQUFLLFNBQVMsUUFBUSxPQUFPLEtBQUs7QUFBQSxRQUN0QztBQUNBLG1CQUFXLE1BQU07QUFDakI7QUFBQSxNQUNKO0FBQ0EsYUFBTyxJQUFJLEtBQUssU0FBUyxLQUFLLE1BQU0sSUFBSSxHQUFHLEtBQUssR0FBRztBQUNuRCxXQUFLLE9BQU87QUFDWixXQUFLLFVBQVU7QUFDZixhQUFPO0FBQUEsSUFDWDtBQUNBLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDQSxXQUFXLEtBQUs7QUFDWixZQUFRLElBQUk7QUFDWixZQUFRLEtBQUssSUFBSTtBQUNqQixVQUFNLEVBQUUsS0FBSyxTQUFRLElBQUs7QUFDMUIsU0FBSyxXQUFXO0FBRWhCLFVBQU0sS0FBSyxPQUFPLFNBQVMsR0FBRyxDQUFDO0FBQy9CLGVBQVcsUUFBUTtBQUNuQixTQUFLLFNBQVMsVUFBVSxHQUFHLElBQUk7QUFDL0IsZUFBVyxRQUFRO0FBQ25CLFVBQU0sUUFBUSxJQUFJLEdBQUc7QUFDckIsU0FBSyxJQUFHLEVBQUcsUUFBUSxDQUFDLEdBQUcsTUFBTyxNQUFNLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBRTtBQUFBLEVBQzFEO0FBQUEsRUFDQSxTQUFTO0FBQ0wsVUFBTSxFQUFFLFFBQVEsVUFBUyxJQUFLO0FBQzlCLFNBQUssV0FBVyxNQUFNO0FBQ3RCLFVBQU0sTUFBTSxPQUFPLE1BQU0sR0FBRyxTQUFTO0FBQ3JDLFNBQUssUUFBTztBQUNaLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDQSxXQUFXLElBQUk7QUFDWCxVQUFNLEVBQUUsUUFBUSxRQUFRLFVBQVUsV0FBVyxXQUFXLElBQUcsSUFBSztBQUNoRSxXQUFPLElBQUksS0FBSyxZQUFZLEVBQUUsT0FBTyxVQUFTLENBQUU7QUFDaEQsT0FBRyxJQUFJLEdBQUcsS0FBSyxJQUFHLENBQUU7QUFDcEIsT0FBRyxPQUFPLElBQUksTUFBTTtBQUNwQixPQUFHLFlBQVk7QUFDZixPQUFHLFdBQVc7QUFDZCxPQUFHLFNBQVM7QUFDWixPQUFHLE1BQU07QUFFVCxPQUFHLFlBQVk7QUFDZixXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsUUFBUTtBQUNKLFdBQU8sS0FBSyxXQUFVO0FBQUEsRUFDMUI7QUFDSjtBQUVPLE1BQU0saUJBQWlCLFFBQVE7QUFBQTtBQUFBLEVBRWxDLE1BQU0sT0FBTyxDQUFDLElBQUk7QUFBQSxFQUNsQixNQUFNLE9BQU8sQ0FBQyxJQUFJO0FBQUEsRUFDbEIsTUFBTSxPQUFPLENBQUMsSUFBSTtBQUFBLEVBQ2xCLE1BQU0sT0FBTyxDQUFDLElBQUk7QUFBQSxFQUNsQixNQUFNLE9BQU8sQ0FBQyxJQUFJO0FBQUEsRUFDbEIsTUFBTSxPQUFPLENBQUMsSUFBSTtBQUFBLEVBQ2xCLE1BQU0sT0FBTyxDQUFDLElBQUk7QUFBQSxFQUNsQixNQUFNLE9BQU8sQ0FBQyxJQUFJO0FBQUEsRUFDbEIsTUFBTSxPQUFPLENBQUMsSUFBSTtBQUFBLEVBQ2xCLE1BQU0sT0FBTyxDQUFDLElBQUk7QUFBQSxFQUNsQixNQUFNLE9BQU8sRUFBRSxJQUFJO0FBQUEsRUFDbkIsTUFBTSxPQUFPLEVBQUUsSUFBSTtBQUFBLEVBQ25CLE1BQU0sT0FBTyxFQUFFLElBQUk7QUFBQSxFQUNuQixNQUFNLE9BQU8sRUFBRSxJQUFJO0FBQUEsRUFDbkIsTUFBTSxPQUFPLEVBQUUsSUFBSTtBQUFBLEVBQ25CLE1BQU0sT0FBTyxFQUFFLElBQUk7QUFBQSxFQUNuQixZQUFZLE9BQU8sSUFBSTtBQUNuQixVQUFNLE9BQU8sS0FBSyxVQUFVLFNBQVksS0FBSyxLQUFLO0FBQ2xELFVBQU0sS0FBSyxJQUFJO0FBQ2Ysb0JBQWdCLE1BQU0sTUFBTSxJQUFJLElBQUksRUFBRTtBQUN0QyxRQUFJLEVBQUUsS0FBSyxpQkFBaUIsS0FBSSxJQUFLO0FBQ3JDLFFBQUksWUFBWTtBQUNoQixRQUFJLFFBQVEsUUFBVztBQUNuQixhQUFPLEtBQUssUUFBVyxLQUFLO0FBQzVCLGtCQUFZLElBQUk7QUFBQSxJQUNwQjtBQUNBLFNBQUssT0FBTyxLQUFLLFlBQWEsYUFBYSxJQUFNLEtBQVEsS0FBTyxLQUFRO0FBQ3hFLFFBQUksU0FBUyxRQUFXO0FBQ3BCLGFBQU8sTUFBTSxRQUFXLE1BQU07QUFDOUIsWUFBTSxNQUFNLElBQUksSUFBSTtBQUNwQixXQUFLLE9BQU8sVUFBVSxJQUFJLENBQUMsQ0FBQztBQUM1QixXQUFLLE9BQU8sVUFBVSxJQUFJLENBQUMsQ0FBQztBQUM1QixXQUFLLE9BQU8sVUFBVSxJQUFJLENBQUMsQ0FBQztBQUM1QixXQUFLLE9BQU8sVUFBVSxJQUFJLENBQUMsQ0FBQztBQUFBLElBQ2hDO0FBQ0EsUUFBSSxvQkFBb0IsUUFBVztBQUMvQixhQUFPLGlCQUFpQixRQUFXLGlCQUFpQjtBQUNwRCxZQUFNLE9BQU8sSUFBSSxlQUFlO0FBQ2hDLFdBQUssT0FBTyxVQUFVLEtBQUssQ0FBQyxDQUFDO0FBQzdCLFdBQUssT0FBTyxVQUFVLEtBQUssQ0FBQyxDQUFDO0FBQzdCLFdBQUssT0FBTyxVQUFVLEtBQUssQ0FBQyxDQUFDO0FBQzdCLFdBQUssT0FBTyxVQUFVLEtBQUssQ0FBQyxDQUFDO0FBQUEsSUFDakM7QUFDQSxRQUFJLFFBQVEsUUFBVztBQUVuQixZQUFNLE1BQU0sSUFBSSxXQUFXLEtBQUssUUFBUTtBQUN4QyxVQUFJLElBQUksR0FBRztBQUNYLFdBQUssT0FBTyxHQUFHO0FBQUEsSUFDbkI7QUFBQSxFQUNKO0FBQUE7QUFBQSxFQUVBLE1BQU07QUFDRixRQUFJLEVBQUUsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssSUFBRyxJQUFLO0FBQ3pGLFdBQU8sQ0FBQyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDMUY7QUFBQTtBQUFBLEVBRUEsSUFBSSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLO0FBQ2hGLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQUEsRUFDckI7QUFBQSxFQUNBLFNBQVMsS0FBSyxRQUFRLFFBQVE7QUFDMUIsU0FBSyxJQUFHLEVBQUcsUUFBUSxDQUFDLEdBQUcsTUFBTyxLQUFLLENBQUMsSUFBSSxDQUFFO0FBQzFDLFNBQUssSUFBSSxRQUFRLEVBQUU7QUFDbkIsUUFBSSxFQUFFLEdBQUcsRUFBQyxJQUFLMEosUUFBWSxPQUFPLEtBQUssTUFBTSxDQUFDO0FBQzlDLFNBQUssRUFBRSxJQUFJLE9BQU8sQ0FBQyxJQUFJO0FBQ3ZCLFNBQUssRUFBRSxJQUFJLE9BQU8sQ0FBQyxJQUFJO0FBRXZCLFFBQUksUUFBUTtBQUNSLFdBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ25CLFdBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQUEsSUFDdkI7QUFDQSxRQUFJLElBQUk7QUFDUixVQUFNLElBQUk7QUFDVixhQUFTLElBQUksR0FBRyxJQUFJLElBQUksS0FBSztBQUN6QixVQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksS0FBSyxTQUFTLElBQUksRUFBRSxHQUFHLENBQUM7QUFDekMsVUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEtBQUssU0FBUyxJQUFJLEVBQUUsR0FBRyxDQUFDO0FBQ3pDLFVBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxLQUFLLFNBQVMsSUFBSSxFQUFFLEdBQUcsQ0FBQztBQUN6QyxVQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksS0FBSyxTQUFTLElBQUksRUFBRSxHQUFHLENBQUM7QUFDekMsVUFBSSxHQUFHLEdBQUcsSUFBSSxJQUFJLEtBQUssU0FBUyxJQUFJLEVBQUUsR0FBRyxDQUFDO0FBQzFDLFVBQUksR0FBRyxHQUFHLElBQUksSUFBSSxLQUFLLFNBQVMsSUFBSSxFQUFFLEdBQUcsQ0FBQztBQUMxQyxVQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksS0FBSyxTQUFTLElBQUksRUFBRSxHQUFHLENBQUM7QUFDMUMsVUFBSSxHQUFHLEdBQUcsSUFBSSxJQUFJLEtBQUssU0FBUyxJQUFJLEVBQUUsR0FBRyxDQUFDO0FBQzFDLFVBQUksR0FBRyxHQUFHLElBQUksSUFBSSxLQUFLLFNBQVMsSUFBSSxFQUFFLEdBQUcsQ0FBQztBQUMxQyxVQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksS0FBSyxTQUFTLElBQUksRUFBRSxHQUFHLENBQUM7QUFDMUMsVUFBSSxHQUFHLEdBQUcsSUFBSSxJQUFJLEtBQUssU0FBUyxJQUFJLEVBQUUsR0FBRyxDQUFDO0FBQzFDLFVBQUksR0FBRyxHQUFHLElBQUksSUFBSSxLQUFLLFNBQVMsSUFBSSxFQUFFLEdBQUcsQ0FBQztBQUMxQyxVQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksS0FBSyxTQUFTLElBQUksRUFBRSxHQUFHLENBQUM7QUFDekMsVUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEtBQUssU0FBUyxJQUFJLEVBQUUsR0FBRyxDQUFDO0FBQ3pDLFVBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxLQUFLLFNBQVMsSUFBSSxFQUFFLEdBQUcsQ0FBQztBQUN6QyxVQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksS0FBSyxTQUFTLElBQUksRUFBRSxHQUFHLENBQUM7QUFBQSxJQUM3QztBQUNBLFNBQUssT0FBTyxLQUFLLENBQUMsSUFBSSxLQUFLLEVBQUU7QUFDN0IsU0FBSyxPQUFPLEtBQUssQ0FBQyxJQUFJLEtBQUssRUFBRTtBQUM3QixTQUFLLE9BQU8sS0FB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QUssT0FBTyxJQUFJLENBQUMsR0FBRyxLQUFLLE9BQU8sSUFBSSxJQUFJLENBQUM7QUFDN0MsTUFBSSxLQUFLLE9BQU8sSUFBSUEsRUFBQyxHQUFHLEtBQUssT0FBTyxJQUFJQSxLQUFJLENBQUM7QUFDN0MsTUFBSSxLQUFLLE9BQU8sSUFBSSxDQUFDLEdBQUcsS0FBSyxPQUFPLElBQUksSUFBSSxDQUFDO0FBQzdDLE1BQUksS0FBSyxPQUFPLElBQUksQ0FBQyxHQUFHLEtBQUssT0FBTyxJQUFJLElBQUksQ0FBQztBQUM3QyxHQUFDLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRSxJQUFLLE9BQU8sSUFBSSxJQUFJLElBQUksRUFBRTtBQUN6QyxHQUFDLEVBQUUsSUFBSSxHQUFFLElBQUssRUFBRSxJQUFJLEtBQUssSUFBSSxJQUFJLEtBQUssR0FBRTtBQUN4QyxHQUFDLEVBQUUsSUFBSSxHQUFFLElBQUssRUFBRSxJQUFJLFFBQVEsSUFBSSxFQUFFLEdBQUcsSUFBSSxRQUFRLEVBQU0sRUFBQztBQUN4RCxHQUFDLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRSxJQUFLLE9BQU8sSUFBSSxJQUFJLElBQUksRUFBRTtBQUN6QyxHQUFDLEVBQUUsSUFBSSxHQUFFLElBQUssRUFBRSxJQUFJLEtBQUssSUFBSSxJQUFJLEtBQUssR0FBRTtBQUN4QyxHQUFDLEVBQUUsSUFBSSxHQUFFLElBQUssRUFBRSxJQUFJLE9BQU8sSUFBSSxJQUFJLEVBQUUsR0FBRyxJQUFJLE9BQU8sSUFBSSxJQUFJLEVBQUUsRUFBQztBQUM5RCxHQUFDLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRSxJQUFLLE9BQU8sSUFBSSxJQUFJLElBQUksRUFBRTtBQUN6QyxHQUFDLEVBQUUsSUFBSSxHQUFFLElBQUssRUFBRSxJQUFJLEtBQUssSUFBSSxJQUFJLEtBQUssR0FBRTtBQUN4QyxHQUFDLEVBQUUsSUFBSSxHQUFFLElBQUssRUFBRSxJQUFJLE9BQU8sSUFBSSxJQUFJLEVBQUUsR0FBRyxJQUFJLE9BQU8sSUFBSSxJQUFJLEVBQUUsRUFB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LElBQUs7QUFDMUIsY0FBSSxFQUFFLFFBQVEsS0FBSyxPQUFPLFlBQVk7QUFDbEMsa0JBQU0sU0FBUTtBQUNkLGtCQUFNO0FBQUEsVUFDVjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDQSxRQUFNLE9BQU87QUFDYixTQUFPLGFBQWEsR0FBRyxHQUFHLFNBQVMsS0FBSztBQUM1QztBQU1ZLE1BQUMsZ0JBQWdCLENBQUMsVUFBVSxNQUFNLFNBQVMsWUFBWSxHQUFHLFVBQVUsVUFBVSxNQUFNLElBQUk7Ozs7Ozs7OzsiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSw5Niw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDcsMTA4LDEwOSwxMTAsMTExLDExMiwxMTMsMTE0LDExNV19
